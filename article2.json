[
    {
        "article_id": "7161036677182898207",
        "cover_image": "",
        "title": "vue高频面试知识点汇总【2023新春版】",
        "brief": "很喜欢`‘万变不离其宗’`这句话，希望在不断的思考中找到`Vue`中的`宗`，来解答面试官抛出的各种`Vue`问题，一起加油~",
        "user_name": "bqb",
        "view_count": 13129,
        "collect_count": 1155,
        "comment_count": 42,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/e40655a4d62c0313136fc23d36050e80~300x300.image",
        "category": "前端",
        "content": "很喜欢`‘万变不离其宗’`这句话，希望在不断的思考和总结中找到`Vue`中的`宗`，来解答面试官抛出的各种`Vue`问题，一起加油~\\n\\n## 一、`MVVM`原理\\n在`Vue2`官方文档中没有找到`Vue`是`MVVM`的直接证据，但文档有提到：虽然没有完全遵循`MVVM模型`，但是 Vue 的设计也受到了它的启发，因此在文档中经常会使用`vm`(ViewModel 的缩写) 这个变量名表示 Vue 实例。\\n\\n为了感受`MVVM模型`的启发，我简单列举下其概念。\\n\\nMVVM是Model-View-ViewModel的简写，由三部分构成：\\n- Model: 模型持有所有的数据、状态和程序逻辑\\n- View: 负责界面的布局和显示\\n- ViewModel：负责模型和界面之间的交互，是Model和View的桥梁\\n## 二、`SPA`单页面应用\\n单页Web应用（single page web application，SPA），就是只有一张Web页面的应用，是加载单个HTML页面并在用户与应用程序交互时动态更新该页面的Web应用程序。我们开发的`Vue`项目大多是借助个官方的`CLI`脚手架，快速搭建项目，直接通过`new Vue`构建一个实例，并将`el:'#app'`挂载参数传入，最后通过`npm run build`的方式打包后生成一个`index.html`，称这种只有一个`HTML`的页面为单页面应用。\\n\\n当然，`vue`也可以像`jq`一样引入，作为多页面应用的基础框架。\\n\\n## 三、`Vue`的特点\\n- 清晰的官方文档和好用的`api`，比较容易上手。\\n- 是一套用于构建用户界面的**渐进式框架**，将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库。\\n- 使用 **Virtual DOM**。\\n- 提供了**响应式** (Reactive) 和**组件化** (Composable) 的视图组件。\\n\\n## 四、`Vue`的构建入口\\nvue使用过程中可以采用以下两种方式：\\n- 在vue脚手架中直接使用，参考文档：`https://cn.vuejs.org/v2/guide/installation.html`\\n- 或者在html文件的头部通过静态文件的方式引入：\\n`<script src=\\\"https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js\\\"></script>`\\n\\n那么问题来了，使用的或者引入的到底是什么？<br>\\n答：引入的是已经打包好的vue.js文件，通过rollup构建打包所得。\\n\\n构建入口在哪里？<br>\\n答：在`vue`源码的package.json文件中：\\n```\\n\\\"scripts\\\": {\\n    // ...\\n    \\\"build\\\": \\\"node scripts/build.js\\\",\\n    \\\"build:ssr\\\": \\\"npm run build -- web-runtime-cjs,web-server-renderer\\\",\\n    \\\"build:weex\\\": \\\"npm run build -- weex\\\",\\n    // ...\\n  },\\n```\\n通过执行npm run build的时候，会进行scripts/build.js文件的执行，npm run build：ssr和npm run build：weex的时候，将ssr和weex作为参数传入，按照参数构建出不一样的vue.js打包文件。\\n\\n所以说，`vue`中的`package.json`文件就是构建的入口，具体构建流程可以参考[vue2入口：构建入口](https://juejin.cn/post/7128225931293884452)。\\n\\n## 五、对`import Vue from \\\"vue\\\"`的理解\\n\\n在使用脚手架开发项目时，会有一行代码`import Vue from \\\"vue\\\"`，那么这个`Vue`指的是什么。<br >\\n答：一个构造函数。\\n```\\nfunction Vue (options) {\\n  if (process.env.NODE_ENV !== 'production' &&\\n    !(this instanceof Vue)\\n  ) {\\n    warn('Vue is a constructor and should be called with the `new` keyword')\\n  }\\n  this._init(options)\\n}\\ninitMixin(Vue)\\nstateMixin(Vue)\\neventsMixin(Vue)\\nlifecycleMixin(Vue)\\nrenderMixin(Vue)\\n```\\n我们开发中引入的`Vue`其实就是这个构造函数，而且这个构造函数只能通过`new Vue`的方式进行使用，否则会在控制台打印警告信息。定义完后，还会通过`initMixin(Vue)`、`stateMixin(Vue)`、`eventsMixin(Vue)`、`lifecycleMixin(Vue)`和`renderMixin(Vue)`的方式为`Vue`原型中混入方法。我们通过`import Vue from \\\"Vue\\\"`引入的本质上就是一个原型上挂在了好多方法的构造函数。\\n\\n## 六、对`new Vue`的理解\\n```\\n// main.js文件\\nimport Vue from \\\"vue\\\";\\nvar app = new Vue({\\n  el: '#app',\\n  data() {\\n    return {\\n      msg: 'hello Vue~'\\n    }\\n  },\\n  template: `<div>{{msg}}</div>`,\\n})\\n\\nconsole.log(app);\\n```\\n`new Vue`就是对构造函数`Vue`进行实例化，执行结果如下：\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5b68a5e0eeda4dc28bd6ca3f2ad0c167~tplv-k3u1fbpfcp-watermark.image?)\\n\\n可以看出实例化后的实例中包含了很多属性，用来对当前`app`进行描述，当然复杂的`Vue`项目这个`app`将会是一个树结构，通过`$parent`和`$children`维护父子关系。\\n\\n`new Vue`的过程中还会执行`this._init`方法进行初始化处理。\\n\\n## 七、`编译`\\n\\n虚拟`DOM`的生成必须通过`render`函数实现，`render`函数的产生是在编译阶段完成，核心代码如下：\\n```\\nexport const createCompiler = createCompilerCreator(function baseCompile (\\n  template: string,\\n  options: CompilerOptions\\n): CompiledResult {\\n  const ast = parse(template.trim(), options)\\n  if (options.optimize !== false) {\\n    optimize(ast, options)\\n  }\\n  const code = generate(ast, options)\\n  return {\\n    ast,\\n    render: code.render,\\n    staticRenderFns: code.staticRenderFns\\n  }\\n})\\n```\\n主要完成的功能是：\\n- 通过`const ast = parse(template.trim(), options)`将`template`转换成`ast`树\\n- 通过`optimize(ast, options)`对`ast`进行优化\\n- 通过`const code = generate(ast, options)`将优化后的`ast`转换成包含`render`字符串的`code`对象，最终`render`字符串通过`new Function`转换为可执行的`render`函数\\n\\n`模板编译的真实入口`可以参考[vue2从template到render：模板编译入口](https://juejin.cn/post/7134253213871505415)<br>\\n`parse`可以参考[vue2从template到render：AST](https://juejin.cn/post/7134722260870365198)<br>\\n`optimize`可以参考[vue2从template到render：optimize](https://juejin.cn/post/7136206751602311175)<br>\\n`generate`可以参考[vue2从template到render：code](https://juejin.cn/post/7135783392133513252)\\n\\n## 八、虚拟`DOM`\\n**先看浏览器对`HTML`的理解**：\\n```\\n<div>  \\n    <h1>My title</h1>  \\n    Some text content  \\n    <!-- TODO: Add tagline -->  \\n</div>\\n```\\n当浏览器读到这些代码时，它会建立一个DOM树来保持追踪所有内容，如同你会画一张家谱树来追踪家庭成员的发展一样。\\n上述 HTML 对应的 DOM 节点树如下图所示：\\n\\n![544ef95bdd7c96a19d700ce613ab425a_dom-tree.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc218300418a46119b2b26f0d9269343~tplv-k3u1fbpfcp-watermark.image?)\\n每个元素都是一个节点。每段文字也是一个节点。甚至注释也都是节点。一个节点就是页面的一个部分。就像家谱树一样，每个节点都可以有孩子节点 (也就是说每个部分可以包含其它的一些部分)。\\n\\n**再看`Vue`对`HTML template`的理解**\\n\\nVue 通过建立一个**虚拟 DOM** 来追踪自己要如何改变真实 DOM。因为它所包含的信息会告诉 Vue 页面上需要渲染什么样的节点，包括及其子节点的描述信息。我们把这样的节点描述为“虚拟节点 (virtual node)”，也常简写它为“**VNode**”。“虚拟 DOM”是我们对由 Vue 组件树建立起来的整个 VNode 树的称呼。\\n\\n简言之，浏览器对HTML的理解是DOM树，Vue对`HTML`的理解是虚拟DOM，最后在`patch`阶段通过DOM操作的api将其渲染成真实的DOM节点。\\n\\n## 九、模板或者组件渲染\\n`Vue`中的编译会执行到逻辑`vm._update(vm._render(), hydrating)`，其中的`vm._render`执行会获取到`vNode`，`vm._update`就会对`vNode`进行`patch`的处理，又分为模板渲染和组件渲染。\\n\\n- 模板渲染，参考[vue2从数据到视图渲染：模板渲染](https://juejin.cn/post/7129095821261275167)\\n- 组件渲染，参考[vue2从数据到视图渲染：组件渲染](https://juejin.cn/post/7129095821261275167)\\n\\n## 十、数据响应式处理\\n\\n`Vue`的数据响应式处理的核心是`Object.defineProperty`，在递归响应式处理对象的过程中，为每一个属性定义了一个发布者`dep`，当进行`_render`函数执行时会访问到当前值，在`get`中通过`dep.depend`进行当前`Watcher`的收集，当数据发生变化时会在`set`中通过`dep.notify`进行`Watcher`的更新。\\n\\n数据响应式处理以及发布订阅者模式的关系请参考[vue2从数据变化到视图变化：发布订阅模式](https://juejin.cn/post/7130991439965585444)\\n\\n## 十一、`this.$set`\\n```\\nconst app = new Vue({\\n  el: \\\"#app\\\",\\n  data() {\\n    return {\\n      obj: {\\n        name: \\\"name-1\\\"\\n      }\\n    };\\n  },\\n  template: `<div @click=\\\"change\\\">{{obj.name}}的年龄是{{obj.age}}</div>`,\\n  methods: {\\n    change() {\\n      this.obj.name = 'name-2';\\n      this.obj.age = 30;\\n    }\\n  }\\n});\\n```\\n以上例子执行的结果是：<br>\\nname-1的年龄是<br>\\n当点击后依然是：<br>\\nname-2的年龄是<br>\\n可以看出点击后，`obj`的`name`属性变化得到了视图更新，而`age`属性并未进行变化。\\n\\n`name`属性响应式的过程中锁定了一个发布者`dep`，在当前视图渲染时在发布者`dep`的`subs`中做了记录，一旦其发生改变，就会触发`set`方法中的`dep.notify`，继而执行视图的重新渲染。然而，`age`属性并未进行响应式的处理，当其改变时就不能进行视图渲染。\\n\\n此时就需要通过`this.$set`的方式对其进行手动响应式的处理。具体细节请参考 [手动响应式处理和数组检测变化](https://juejin.cn/post/7131280408385159175)\\n## 十二、组件注册\\n组件的使用是先注册后使用，又分为：\\n- 全局注册：可以直接在页面中使用\\n- 局部注册：使用时需要通过`import xxx from xxx`的方式引入，并且在当前组件的选项`components`中增加局部组件的名称。\\n\\n全局注册和局部注册实现原理可以参考 [vue2从数据到视图渲染：组件注册(全局组件/局部组件)](https://juejin.cn/post/7129338204448260109)\\n\\n## 十三、异步组件\\nVue单页面应用中一个页面只有一个`<div id=\\\"app\\\"></div>`承载所有节点，因此复杂项目可能会出现首屏加载白屏等问题，Vue异步组件就很好的处理了这问题。\\n\\n异步组件的分类和实现原理请参考 [vue2从数据到视图渲染：异步组件](https://juejin.cn/post/7129784993663942693)\\n\\n## 十四、`this.$nextTick`\\n因为通过`new`实例化构造函数`Vue`的时候会执行初始化方法`this._init`，其中涉及到的方法大多都是同步执行。`nextTick`在vue中是一个很重要的方法，在`new Vue`实例化的同步过程中将一些需要异步处理的函数推到异步队列中去，可以等`new Vue`所有的同步任务执行完后，再执行异步队列中的函数。\\n\\n`nextTick`的实现可以参考 [vue2从数据变化到视图变化：nextTick](https://juejin.cn/post/7129855050259628068)，\\n\\n\\n## 十五、`keep-alive`内置组件\\n`vue`中支持组件化，并且也有用于缓存的内置组件`keep-alive`可直接使用，使用场景为`路由组件`和`动态组件`。\\n- `activated`表示进入组件的生命周期，`deactivated`表示离开组件的生命周期\\n- `include`表示匹配到的才缓存，`exclude`表示匹配到的都不缓存\\n- `max`表示最多可以缓存多少组件\\n\\n`keep-alive`的具体实现请参考 [vue中的keep-alive（源码分析）](https://juejin.cn/post/7155828702356439076/)\\n\\n## 十六、生命周期\\n`vue`中的生命周期有哪些？<br>\\n答案：`11`个，分别为`beforeCreate`、`created`、`beforeMount`、`mounted`、`beforeUpdate`、`updated`、`activated`、`deactivated`、`beforeDestroy`、`destroyed`和`errorCaptured`。\\n\\n具体实现请参考 [vue生命周期](https://juejin.cn/post/7140218856152236068)\\n\\n## 十七、`v-show`和`v-if`的区别\\n先看`v-if`和`v-show`的使用场景：\\n\\n（1）`v-if`更多的使用在需要考虑白屏时间或者切换次数很少的场景<br>\\n（2）`v-show`更多使用在`transition`控制的动画或者需要非常频繁地切换的场景\\n\\n再从底层实现思路上分析：\\n\\n（1）`v-if`条件为`false`时，会生成空的占位注释节点，那么在考虑首页白屏时间时，选用`v-if`比较合适。条件从`false`变化为`true`的话会从空的注释节点变成真实节点，条件再变为`false`时真实节点又会变成注释节点，如果切换次数比较多，那么开销会比较大，频繁切换场景不建议使用`v-if`。<br>\\n（2）`v-show`条件为`false`时，会生成真实的节点，只是为当前节点增加了`display:none`来控制其隐藏，相比`v-if`生成空的注释节点其首次渲染开销是比较大的，所以不建议用在考虑首屏白屏时间的场景。如果我们频繁切换`v-show`的值，从`display:none`到`display:block`之间的切换比起空的注释节点和真实节点的开销要小很多，这种场景就建议使用`v-show`。\\n\\n可以通过[vue中v-if和v-show的区别（源码分析）](https://juejin.cn/post/7139815983979757575)了解`v-if`和`v-show`详细过程。\\n\\n## 十八、`v-for`中`key`的作用\\n在`v-for`进行循环展示过程中，当数据发生变化进行渲染的过程中，会进行新旧节点列表的比对。首先新旧`vnode`列表首先通过`首首`、`尾尾`、`首尾`和`尾首`的方式进行比对，如果`key`相同则采取原地复用的策略进行节点的移动。\\n\\n如果首尾两两比对的方式找不到对应关系，继续通过`key`和`vnode`的对应关系进行寻找。\\n\\n如果`key`和`vnode`对应关系中找不到，继续通过`sameVnode`的方式在未比对的节点中进行寻找。\\n\\n如果都找不到，则将其按照新`vnode`进行`createElm`的方式进行创建，这种方式是比节点移动的方式计算量更大。\\n\\n最后将旧的`vnode`列表中没有进行匹配的`vnode`中的`vnode.elm`在父节点中移除。\\n\\n简单总结就是，新的`vnode`列表在旧的`vnode`列表中去寻找具有相同的`key`的节点进行原地复用，如果找不到则通过创建的方式`createElm`去创建一个，如果旧的`vnode`列表中没有进行匹配则在父节点中移除其`vnode.elm`。这就是原地复用逻辑的大体实现。\\n\\n具体`key`和`diff`算法的关系可以参考[vue2从数据变化到视图变化：diff算法图解](https://juejin.cn/post/7131760211609518094)\\n\\n## 十九、`v-for`和`v-if`能同时使用吗\\n答案是：用了也能出来预期的效果，但是会有性能浪费。\\n\\n同时包含`v-for`和`v-if`的`template`模板在编辑阶段会执行`v-for`比`v-if`优先级更高的编译流程；在生成`vnode`的阶段，会包含属性`isComment`为`true`的空白占位`vnode`；在`patch`阶段，会生成真实的占位节点。虽然一个空的占位节点无妨，但是如果数据量比较大的话，也是一个性能问题。\\n\\n当然，可以在获取到数据(一般是在`beforeCreate`或者`created`阶段)时进行过滤处理，也可以通过计算属性对其进行处理。\\n\\n可以通过[`v-for`和`v-if`可以一起使用吗？](https://juejin.cn/post/7137326610822201357)了解`v-for`和`v-if`的详细过程。\\n\\n## 二十、`vue`中的`data`为什么是函数\\n答案是：是不是一定是函数，得看场景。并且，也无需担心什么时候该将`data`写为函数还是对象，因为`vue`内部已经做了处理，并在控制台输出错误信息。\\n\\n**场景一**：`new Vue({data: ...})`<br>\\n这种场景主要为项目入口或者多个`html`页面各实例化一个`Vue`时，这里的`data`即可用对象的形式，也可用工厂函数返回对象的形式。因为，这里的`data`只会出现一次，不存在重复引用而引起的数据污染问题。\\n\\n**场景二**：组件场景中的选项<br>\\n在生成组件`vnode`的过程中，组件会在生成构造函数的过程中执行合并策略：\\n```\\n// data合并策略\\nstrats.data = function (\\n  parentVal,\\n  childVal,\\n  vm\\n) {\\n  if (!vm) {\\n    if (childVal && typeof childVal !== 'function') {\\n      process.env.NODE_ENV !== 'production' && warn(\\n        'The \\\"data\\\" option should be a function ' +\\n        'that returns a per-instance value in component ' +\\n        'definitions.',\\n        vm\\n      );\\n\\n      return parentVal\\n    }\\n    return mergeDataOrFn(parentVal, childVal)\\n  }\\n\\n  return mergeDataOrFn(parentVal, childVal, vm)\\n};\\n```\\n如果合并过程中发现子组件的数据不是函数，即`typeof childVal !== 'function'`成立，进而在开发环境会在控制台输出警告并且直接返回`parentVal`，说明这里压根就没有把`childVal`中的任何`data`信息合并到`options`中去。\\n\\n\\n可以通过[`vue`中的`data`为什么是函数？](https://juejin.cn/post/7139925047145316360)了解详细过程。\\n\\n## 二十一、`this.$watch`\\n使用场景：用来监听数据的变化，当数据发生变化的时候，可以做一些业务逻辑的处理。\\n\\n配置参数：\\n- `deep`：监听数据的深层变化\\n- `immediate`：立即触发回调函数\\n\\n实现思路： `Vue`构造函数定义完成以后，在执行`stateMixin(Vue)`时为`Vue.prototype`上定义`$watch`。该方法通过`const watcher = new Watcher(vm, expOrFn, cb, options)`进行`Watcher`的实例化，将`options`中的`user`属性设置为`true`。并且，`$watch`逻辑结束的会返回函数`function unwatchFn () { watcher.teardown() }`，用来取消侦听的函数。\\n\\n可以通过`watch`选项和`$watch`方法的区别[vue中的watch和$watch监听的事件，执行几次？](https://juejin.cn/post/7156172339414040584)来了解详细过程。\\n\\n## 二十二、计算属性和侦听属性的区别\\n**相同点：** 两者都是`Watcher`实例化过程中的产物\\n\\n**计算属性：**\\n- 使用场景：模板内的表达式主要用于简单运算，对于复杂的计算逻辑可以用计算属性\\n- 计算属性是基于它们的响应式依赖进行缓存的，当依赖的数据未发生变化时，多次调用无需重复执行函数\\n- 计算属性计算结果依赖于`data`中的值\\n- 同步操作，不支持异步\\n\\n**侦听属性：**\\n- 使用场景：当需要在数据变化时执行异步或开销较大的操作时，可以用侦听属性\\n- 可配置参数：可以通过配置`immediate`和`deep`来控制立即执行和深度监听的行为\\n- 侦听属性侦听的是`data`中定义的\\n\\n计算属性请参考[vue2从数据变化到视图变化：计算属性](https://juejin.cn/post/7132100391776452615)<br>\\n侦听属性请参考[vue2从数据变化到视图变化：侦听器](https://juejin.cn/post/7132312215402577956)\\n\\n## 二十三、`v-model`\\n```\\n// main.js\\nnew Vue({\\n  el: \\\"#app\\\",\\n  data() {\\n    return {\\n      msg: \\\"\\\"\\n    };\\n  },\\n  template: `<div>\\n    <input v-model=\\\"msg\\\" placeholder=\\\"edit me\\\">\\n    <p>msg is: {{ msg }}</p>\\n  </div>`\\n});\\n```\\n**普通input：**`input`中的`v-model`，最终通过`target.addEventListener`处理成在节点上监听`input`事件`function($event){msg=$event.target.value}}`的形式，当`input`值变化时`msg`也跟着改变。\\n```\\n// main.js\\nconst inputBox = {\\n  template: `<input @input=\\\"$emit('input', $event.target.value)\\\">`,\\n};\\n\\nnew Vue({\\n  el: \\\"#app\\\",\\n  template: `<div>\\n    <input-box v-model=\\\"msg\\\"></input-box>\\n    <p>{{msg}}</p>\\n  </div>`,\\n  components: {\\n    inputBox\\n  },\\n  data() {\\n    return {\\n      msg: 'hello world!'\\n    };\\n  },\\n});\\n```\\n**组件**：`v-model`在组件中则通过给点击事件绑定原生事件，当触发到`$emit`的时候，再进行回调函数`ƒunction input($$v) {msg=$$v}`的执行，进而达到子组件修改父组件中数据`msg`的目的。\\n\\n## 二十四、`v-slot`\\n\\n`v-slot`产生的主要目的是，在组件的使用过程中可以让父组件有修改子组件内容的能力，就像在子组件里面放了个插槽，让父组件往插槽内塞入父组件中的楔子；并且，父组件在子组件中嵌入的楔子也可以访问子组件中的数据。`v-slot`的产生让组件的应用更加灵活。\\n\\n### 1、具名插槽\\n```\\nlet baseLayout = {\\n  template: `<div class=\\\"container\\\">\\n    <header>\\n      <slot name=\\\"header\\\"></slot>\\n    </header>\\n    <main>\\n      <slot></slot>\\n    </main>\\n    <footer>\\n      <slot name=\\\"footer\\\"></slot>\\n    </footer>\\n  </div>`,\\n  data() {\\n    return {\\n      url: \\\"\\\"\\n    };\\n  }\\n};\\n\\nnew Vue({\\n  el: \\\"#app\\\",\\n  template: `<base-layout>\\n    <template v-slot:header>\\n      <h1>title-txt</h1>\\n    </template>\\n    <p>paragraph-1-txt</p>\\n    <p>paragraph-2-txt</p>\\n    <template v-slot:footer>\\n      <p>foot-txt</p>\\n    </template>\\n  </base-layout>`,\\n  components: {\\n    baseLayout\\n  }\\n});\\n```\\n引入的组件`baseLayout`中的`template`被添加了属性`v-slot:header`和`v-slot:footer`，子组件中定义了对应的插槽被添加了属性`name=\\\"header\\\"`和`name=\\\"footer\\\"`，未被进行插槽标识的内容被插入到了匿名的`<slot></slot>`中。\\n\\n### 2、作用域插槽\\n```\\nlet currentUser = {\\n  template: `<span>\\n    <slot name=\\\"user\\\" v-bind:userData=\\\"childData\\\">{{childData.firstName}}</slot>\\n  </span>`,\\n  data() {\\n    return {\\n      childData: {\\n        firstName: \\\"first\\\",\\n        lastName: \\\"last\\\"\\n      }\\n    };\\n  }\\n};\\n\\nnew Vue({\\n  el: \\\"#app\\\",\\n  template: `<current-user>\\n    <template v-slot:user=\\\"slotProps\\\">{{slotProps.userData.lastName}}</template>\\n  </current-user>`,\\n  components: {\\n    currentUser\\n  }\\n});\\n```\\n当前例子中作用域插槽通过`v-bind:userData=\\\"childData\\\"`的方式，将`childData`作为参数，父组件中通过`v-slot:user=\\\"slotProps\\\"`的方式进行接收，为父组件使用子组件中的数据提供了可能。\\n\\n`v-slot`的底层实现请参考[vue中的v-slot（源码分析）](https://juejin.cn/post/7144188805254709256)\\n\\n## 二十五、`Vue.filters`\\n`filters`类似于管道流可以将上一个过滤函数的结果作为下一个过滤函数的第一个参数，又可以在其中传递参数让过滤器更灵活。\\n```\\n// main.js文件\\nimport Vue from \\\"vue\\\";\\n\\nVue.filter(\\\"filterEmpty\\\", function(val) {\\n  return val || \\\"\\\";\\n});\\n\\nVue.filter(\\\"filterA\\\", function(val) {\\n  return val + \\\"平时周末的\\\";\\n});\\n\\nVue.filter(\\\"filterB\\\", function(val, info, fn) {\\n  return val + info + fn;\\n});\\n\\nnew Vue({\\n  el: \\\"#app\\\",\\n  template: `<div>{{msg | filterEmpty | filterA | filterB('爱好是', transformHobby('chess'))}}</div>`,\\n  data() {\\n    return {\\n      msg: \\\"张三\\\"\\n    };\\n  },\\n  methods: {\\n    transformHobby(type) {\\n      const map = {\\n        bike: \\\"骑行\\\",\\n        chess: \\\"象棋\\\",\\n        game: \\\"游戏\\\",\\n        swimming: \\\"游泳\\\"\\n      };\\n      return map[type] || \\\"未知\\\";\\n    }\\n  }\\n});\\n```\\n其中我们对`msg`通过`filterEmpty`、`filterA`和`filterB('爱好是', transformHobby('chess'))}`进行三层过滤。\\n\\n`Vue.filters`的底层实现请查看[vue中的filters（源码分析）](https://juejin.cn/post/7146889304143298597)\\n\\n## 二十六、`Vue.use`\\n- 作用：`Vue.use`被用来安装Vue.js插件，例如`vue-router`、`vuex`、`element-ui`。\\n- `install`方法：如果插件是一个对象，必须提供 `install` 方法。如果插件是一个函数，它会被作为`install`方法。`install`方法调用时，会将`Vue`作为参数传入。\\n- 调用时机：该方法需要在调用 `new Vue()` 之前被调用。\\n- 特点：当 install 方法被同一个插件多次调用，插件将只会被安装一次。\\n\\n## 二十七、`Vue.extend`和选项`extends`\\n### 1、`Vue.extend`\\n`Vue.extend`使用基础`Vue`构造器创建一个“子类”，参数是一个包含组件选项的对象，实例化的过程中可以修改其中的选项，为实现功能的继承提供了思路。\\n```\\nnew Vue({\\n  el: \\\"#app\\\",\\n  template: `<div><div id=\\\"person1\\\"></div><div id=\\\"person2\\\"></div></div>`,\\n  mounted() {\\n    // 定义子类构造函数\\n    var Profile = Vue.extend({\\n      template: '<p @click=\\\"showInfo\\\">{{name}} 喜欢 {{fruit}}</p>',\\n      data: function () {\\n        return {\\n          name: '张三',\\n          fruit: '苹果'\\n        }\\n      },\\n      methods: {\\n        showInfo() {\\n          console.log(`${this.name}喜欢${this.fruit}`)\\n        }\\n      }\\n    })\\n    // 实例化1，挂载到`#person1`上\\n    new Profile().$mount('#person1')\\n    // 实例化2，并修改其`data`选项，挂载到`#person2`上\\n    new Profile({\\n      data: function () {\\n        return {\\n          name: '李四',\\n          fruit: '香蕉'\\n        }\\n      },\\n    }).$mount('#person2')\\n  },\\n});\\n```\\n在当前例子中，通过`Vue.extend`构建了子类构造函数`Profile`，可以通过`new Profile`的方式实例化无数个`vm`实例。我们定义初始的`template`、`data`和`methods`供`vm`进行使用，如果有变化，在实例的过程中传入新的选项参数即可，比如例子中实例化第二个`vm`的时候就对`data`进行了调整。\\n\\n### 2、选项`extends`\\n`extends`允许声明扩展另一个组件 (可以是一个简单的选项对象或构造函数)，而无需使用 `Vue.extend`。这主要是为了便于扩展单文件组件，以实现组件继承的目的。\\n```\\nconst common = {\\n  template: `<div>{{name}}</div>`,\\n  data() {\\n    return {\\n      name: '表单'\\n    }\\n  }\\n}\\n\\nconst create = {\\n  extends: common,\\n  data() {\\n    return {\\n      name: '新增表单'\\n    }\\n  }\\n}\\n\\nconst edit = {\\n  extends: common,\\n  data() {\\n    return {\\n      name: '编辑表单'\\n    }\\n  }\\n}\\n\\nnew Vue({\\n  el: \\\"#app\\\",\\n  template: `<div>\\n    <create></create>\\n    <edit></edit>\\n  </div>`,\\n  components: {\\n    create,\\n    edit,\\n  }\\n});\\n```\\n当前极简demo中定义了公共的表单`common`，然后又在新增表单组件`create`和编辑表单组件`edit`中扩展了`common`。\\n\\n## 二十八、`Vue.mixin`和选项`mixins`\\n全局混入和局部混入视情况而定，主要区别在全局混入是通过`Vue.mixin`的方式将选项混入到了`Vue.options`中，在所有获取子组件构建函数的时候都将其进行了合并，是一种影响全部组件的混入策略。\\n\\n而局部混入是将选项通过配置`mixins`选项的方式合并到当前的子组件中，只有配置了`mixins`选项的组件才会受到混入影响，是一种局部的混入策略。\\n\\n## 二十九、`Vue.directive`和`directives`\\n### 1、使用场景\\n\\n主要用于对于DOM的操作，比如：文本框聚焦，节点位置控制、防抖节流、权限管理、复制操作等功能\\n\\n### 2、钩子函数\\n- `bind`：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。\\n- `inserted`：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。\\n- `update`：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新。\\n- `componentUpdated`：指令所在组件的 VNode **及其子 VNode** 全部更新后调用。\\n- `unbind`：只调用一次，指令与元素解绑时调用。\\n\\n### 3、钩子函数参数\\n- `el`：指令所绑定的元素，可以用来直接操作 DOM。\\n- `binding`：一个对象，包含以下 property：\\n    - `name`：指令名，不包括 `v-` 前缀。\\n    - `value`：指令的绑定值，例如：`v-my-directive=\\\"1 + 1\\\"` 中，绑定值为 `2`。\\n    - `oldValue`：指令绑定的前一个值，仅在 `update` 和 `componentUpdated` 钩子中可用。无论值是否改变都可用。\\n    - `expression`：字符串形式的指令表达式。例如 `v-my-directive=\\\"1 + 1\\\"` 中，表达式为 `\\\"1 + 1\\\"`。\\n    - `arg`：传给指令的参数，可选。例如 `v-my-directive:foo` 中，参数为 `\\\"foo\\\"`。\\n    - `modifiers`：一个包含修饰符的对象。例如：`v-my-directive.foo.bar` 中，修饰符对象为 `{ foo: true, bar: true }`。\\n- `vnode`：Vue 编译生成的虚拟节点。\\n- `oldVnode`：上一个虚拟节点，仅在 `update` 和 `componentUpdated` 钩子中可用。\\n\\n### 4、动态指令参数\\n\\n指令的参数可以是动态的。例如，在 `v-mydirective:[argument]=\\\"value\\\"` 中，`argument` 参数可以根据组件实例数据进行更新！这使得自定义指令可以在应用中被灵活使用。\\n\\n## 三十、`vue`中的原生事件\\n`vue`中可以通过`@`或者`v-on`的方式绑定事件，也可为其添加修饰符。\\n\\n```\\nnew Vue({\\n  el: '#app',\\n  template: `<div @click='divClick'><a @clickt='aClick' href=''>点击</a></div>`,\\n  methods: {\\n    divClick() {\\n      console.log('divClick')\\n    },\\n    aClick() {\\n      console.log('aClick')\\n    },\\n  }\\n})\\n```\\n以上例子如果点击`a`会触发其默认行为，如果`href`不为空还会进行跳转。除此之外，点击还会继续触发`div`上绑定的点击事件。\\n\\n如果通过`@click.stop.prevent='aClick'`的方式为`a`标签的点击事件添加修饰符`stop`和`prevent`，那么就不会触发其`a`的默认行为，即使`href`不为空也不会进行跳转，同时，`div`上的点击事件也不会进行触发。\\n\\n模板的渲染一般分为编译生成`render`函数、`render`函数执行生成`vNode`和`patch`进行渲染。下面按照这步骤进行简单分析。\\n### 1、`render`\\n通过编译生成的`render`函数：\\n```\\nwith(this) {\\n    return _c('div', {\\n        on: {\\n            \\\"click\\\": divClick\\n        }\\n    }, [_c('a', {\\n        attrs: {\\n            \\\"href\\\": \\\"http://www.baidu.com\\\"\\n        },\\n        on: {\\n            \\\"click\\\": function ($event) {\\n                $event.stopPropagation();\\n                $event.preventDefault();\\n                return aClick($event)\\n            }\\n        }\\n    }, [_v(\\\"点击\\\")])])\\n}\\n```\\n其中`div`的`on`作为`div`事件描述。`a`标签的`attrs`作为属性描述，`on`作为事件描述，在描述中`.stop`被编译成了`$event.stopPropagation()`来阻止事件冒泡，`.prevent`被编译成了`$event.preventDefault()`用来阻止`a`标签的默认行为。\\n### 2、`vNode`\\n通过执行`Vue.prototype._render`将`render`函数转换成`vNode`。\\n### 3、`patch`\\n`patch`的过程中，当完成`$el`节点的渲染后会执行`invokeCreateHooks(vnode, insertedVnodeQueue)`逻辑，其中，针对`attrs`会将其设置为`$el`的真实属性，当前例子中会为`a`标签设置`herf`属性。针对`on`会通过`target.addEventListener`的方式将其处理过的事件绑定到`$el`上，当前例子中会分别对`div`和`a`中的`click`进行处理，再通过`addEventListener`的方式进行绑定。\\n\\n### 小结\\n`vue`中的事件，从编译生成`render`再通过`Vue.prototype._render`函数执行`render`到生成`vNode`，主要是通过`on`作为描述。在`patch`渲染阶段，将`on`描述的事件进行处理再通过`addEventListener`的方式绑定到`$el`上。\\n\\n## 三十一、常用修饰符\\n\\n### 1、表单修饰符\\n\\n#### （1）`.lazy`\\n在默认情况下，`v-model` 在每次 `input` 事件触发后将输入框的值与数据进行同步 ，可以添加 `lazy` 修饰符，从而转为在 `change` 事件之后进行同步:\\n```\\n<input v-model.lazy=\\\"msg\\\">\\n```\\n\\n#### （2）`.number`\\n如果想自动将用户的输入值转为数值类型，可以给 `v-model` 添加 `number` 修饰符：\\n```\\n<input v-model.number=\\\"age\\\" type=\\\"number\\\">\\n```\\n\\n#### （3）`.trim`\\n如果要自动过滤用户输入的首尾空白字符，可以给 `v-model` 添加 `trim` 修饰符：\\n```\\n<input v-model.trim=\\\"msg\\\">\\n```\\n\\n### 2、事件修饰符\\n\\n#### （1）`.stop`\\n阻止单击事件继续传播。\\n```\\n<!--这里只会触发a-->\\n<div @click=\\\"divClick\\\"><a v-on:click.stop=\\\"aClick\\\">点击</a></div>\\n```\\n#### （2）`.prevent`\\n阻止标签的默认行为。\\n```\\n<a href=\\\"http://www.baidu.com\\\" v-on:click.prevent=\\\"aClick\\\">点击</a>\\n```\\n\\n#### （3）`.capture`\\n事件先在有`.capture`修饰符的节点上触发，然后在其包裹的内部节点中触发。\\n```\\n<!--这里先执行divClick事件，然后再执行aClick事件-->\\n<div @click=\\\"divClick\\\"><a v-on:click=\\\"aClick\\\">点击</a></div>\\n```\\n\\n#### （4）`.self`\\n只当在 event.target 是当前元素自身时触发处理函数，即事件不是从内部元素触发的。\\n```\\n<!--在a标签上点击时只会触发aClick事件，只有点击phrase的时候才会触发divClick事件-->\\n<div @click.self=\\\"divClick\\\">phrase<a v-on:click=\\\"aClick\\\">点击</a></div>\\n```\\n\\n#### （5）`.once`\\n不像其它只能对原生的 DOM 事件起作用的修饰符，`.once` 修饰符还能被用到自定义的组件事件上，表示当前事件只触发一次。\\n```\\n<a v-on:click.once=\\\"aClick\\\">点击</a>\\n```\\n\\n#### （6）`.passive`\\n`.passive` 修饰符尤其能够提升移动端的性能\\n```\\n<!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 -->  \\n<!-- 而不会等待 `onScroll` 完成 -->  \\n<!-- 这其中包含 `event.preventDefault()` 的情况 -->  \\n<div v-on:scroll.passive=\\\"onScroll\\\">...</div>\\n```\\n\\n### 3、其他修饰符\\n除了表单和事件的修饰符，`Vue`还提供了很多其他修饰符，在使用的时候可以查阅文档。\\n\\n### 小结\\n> `Vue`中提供了很多好用的功能和`api`，那么修饰符的出现就为功能和`api`提供了更为丰富的扩展属性和更大的灵活度。\\n\\n## 三十二、`vue-router`\\n`vue`路由是单页面中视图切换的方案，有三种`mode`:\\n- hash，#后的仅仅作为参数，不属于url部分\\n- history，路径作为请求url请求资源链接，如果找不到会出现404错误\\n- abstract，服务端渲染场景\\nhash场景下，会出现`url`链接，再修改其view-router中对应的值。\\n\\n了解`vue-router`的底层实现请参考[vue2视图切换：vue-router](https://juejin.cn/post/7141965586099077157)\\n\\n## 三十三、`vuex`\\n`vuex`是状态管理仓库，一般使用的场景为：多个视图依赖于同一状态，来自不同视图的行为需要变更同一状态。其管理的状态是响应式的，修改也只能显式提交`mutation`的方式修改。`vuex`有`state`、`getter`、`mutation`、`action`和`module`五个核心，并且通过`module`实现了`vuex`树的管理。\\n\\n了解`vuex`的底层实现请参考[vue2状态管理：vuex](https://juejin.cn/post/7141965586099077157)\\n\\n## 三十四、`eventBus`\\n**使用场景**：兄弟组件传参\\n```\\nconst eventBus = new Vue();\\n\\nconst A = {\\n  template: `<div @click=\\\"send\\\">component-a</div>`,\\n  methods: {\\n    send() {\\n      eventBus.$emit('sendData', 'data from A')\\n    }\\n  },\\n}\\n\\nconst B = {\\n  template: `<div>component-b</div>`,\\n  created() {\\n    eventBus.$on('sendData', (args) => {\\n      console.log(args)\\n    })\\n  },\\n}\\n\\nnew Vue({\\n  el: '#app',\\n  components: {\\n    A,\\n    B,\\n  },\\n  template: `<div><A></A><B></B></div>`,\\n})\\n```\\n在当前例子中，`A`组件和`B`组件称为兄弟组件，`A`组件通过事件总线`eventBus`中的`$emit`分发事件，`B`组件则通过`$on`来监听事件。\\n\\n**实现原理：**`eventsMixin`\\n```\\nexport function eventsMixin (Vue: Class<Component>) {\\n  const hookRE = /^hook:/\\n  Vue.prototype.$on = function (event: string | Array<string>, fn: Function): Component {\\n    const vm: Component = this\\n    if (Array.isArray(event)) {\\n      for (let i = 0, l = event.length; i < l; i++) {\\n        vm.$on(event[i], fn)\\n      }\\n    } else {\\n      (vm._events[event] || (vm._events[event] = [])).push(fn)\\n      // optimize hook:event cost by using a boolean flag marked at registration\\n      // instead of a hash lookup\\n      if (hookRE.test(event)) {\\n        vm._hasHookEvent = true\\n      }\\n    }\\n    return vm\\n  }\\n\\n  Vue.prototype.$once = function (event: string, fn: Function): Component {\\n    const vm: Component = this\\n    function on () {\\n      vm.$off(event, on)\\n      fn.apply(vm, arguments)\\n    }\\n    on.fn = fn\\n    vm.$on(event, on)\\n    return vm\\n  }\\n\\n  Vue.prototype.$off = function (event?: string | Array<string>, fn?: Function): Component {\\n    const vm: Component = this\\n    // all\\n    if (!arguments.length) {\\n      vm._events = Object.create(null)\\n      return vm\\n    }\\n    // array of events\\n    if (Array.isArray(event)) {\\n      for (let i = 0, l = event.length; i < l; i++) {\\n        vm.$off(event[i], fn)\\n      }\\n      return vm\\n    }\\n    // specific event\\n    const cbs = vm._events[event]\\n    if (!cbs) {\\n      return vm\\n    }\\n    if (!fn) {\\n      vm._events[event] = null\\n      return vm\\n    }\\n    // specific handler\\n    let cb\\n    let i = cbs.length\\n    while (i--) {\\n      cb = cbs[i]\\n      if (cb === fn || cb.fn === fn) {\\n        cbs.splice(i, 1)\\n        break\\n      }\\n    }\\n    return vm\\n  }\\n\\n  Vue.prototype.$emit = function (event: string): Component {\\n    const vm: Component = this\\n    if (process.env.NODE_ENV !== 'production') {\\n      const lowerCaseEvent = event.toLowerCase()\\n      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {\\n        tip(\\n          `Event \\\"${lowerCaseEvent}\\\" is emitted in component ` +\\n          `${formatComponentName(vm)} but the handler is registered for \\\"${event}\\\". ` +\\n          `Note that HTML attributes are case-insensitive and you cannot use ` +\\n          `v-on to listen to camelCase events when using in-DOM templates. ` +\\n          `You should probably use \\\"${hyphenate(event)}\\\" instead of \\\"${event}\\\".`\\n        )\\n      }\\n    }\\n    let cbs = vm._events[event]\\n    if (cbs) {\\n      cbs = cbs.length > 1 ? toArray(cbs) : cbs\\n      const args = toArray(arguments, 1)\\n      const info = `event handler for \\\"${event}\\\"`\\n      for (let i = 0, l = cbs.length; i < l; i++) {\\n        invokeWithErrorHandling(cbs[i], vm, args, vm, info)\\n      }\\n    }\\n    return vm\\n  }\\n}\\n```\\n在`Vue`构造函数定义完执行的`eventsMixin`函数中，在`Vue.prototype`上分别定义了`$on`、`$emit`、`$off`和`$once`的方法易实现对事件的绑定、分发、取消和只执行一次的方法。`eventBus`就是利用了当`new Vue`实例化后实例上的`$on`、`$emit`、`$off`和`$once`进行数据传递。\\n\\n## 三十五、`ref`\\n**使用场景：** 父组件获取子组件数据或者执行子组件方法\\n```\\nconst A = {\\n  template: `<div>{{childData.age}}</div>`,\\n  data() {\\n    return {\\n      childData: {\\n        name: 'qb',\\n        age: 30\\n      },\\n    }\\n  },\\n  methods: {\\n    increaseAge() {\\n      this.childData.age++;\\n    }\\n  }\\n}\\n\\nnew Vue({\\n  el: '#app',\\n  components: {\\n    A,\\n  },\\n  template: `<A ref='childRef' @click.native='changeChildData'></A>`,\\n  methods: {\\n    changeChildData() {\\n      // 执行子组件的方法\\n      this.$refs.childRef.increaseAge()\\n      // 获取子组件的数据\\n      console.log(this.$refs.childRef.childData);\\n    },\\n  }\\n})\\n```\\n在当前例子中，通过`ref='childRef'`的方式在当前组件中定义一个`ref`，可以通过`this.$refs.childRef`的方式获取到子组件`A`。可以通过`this.$refs.childRef.increaseAge()`的方式执行子组件中`age`增加的方法，也可以通过`this.$refs.childRef.childData`的方式获取到子组件中的数据。\\n\\n## 三十六、`props`\\n**使用场景：** 父子传参\\n```\\nconst A = {\\n  template: `<div @click='emitData'>{{childData}}</div>`,\\n  props: ['childData'],\\n  methods: {\\n    emitData() {\\n      this.$emit('emitChildData', 'data from child')\\n    }\\n  },\\n}\\n\\nnew Vue({\\n  el: '#app',\\n  components: {\\n    A\\n  },\\n  template: `<A :childData='parentData' @emitChildData='getChildData'></A>`,\\n  data() {\\n    return {\\n      parentData: 'data from parent'\\n    }\\n  },\\n  methods: {\\n    getChildData(v) {\\n      console.log(v);\\n    }\\n  }\\n})\\n```\\n从当前例子中可以看出，数据父传子是通过`:childData='parentData'`的方式，数据子传父是通过`this.$emit('emitChildData', 'data from child')`的方式，然后，父组件通过`@emitChildData='getChildData'`的方式进行获取。\\n\\n### 1、父组件`render`函数\\n`new Vue`中传入的模板`template`经过遍历生成的`render`函数如下：\\n```\\nwith(this) {\\n    return _c('A', {\\n        attrs: {\\n            \\\"childData\\\": parentData\\n        },\\n        on: {\\n            \\\"emitChildData\\\": getChildData\\n        }\\n    })\\n}\\n```\\n其中`data`部分有`attrs`和`on`来描述属性和方法。\\n\\n在通过`createComponent`创建组件`vnode`的过程中，会通过`const propsData = extractPropsFromVNodeData(data, Ctor, tag)`的方式获取`props`，通过`const listeners = data.on`的方式获取`listeners`，最后将其作为参数通过`new VNode(options)`的方式实例化组件`vnode`。\\n\\n### 2、子组件渲染\\n在通过`const child = vnode.componentInstance = createComponentInstanceForVnode(\\n        vnode,\\n        activeInstance\\n      )`创建组件实例的过程中，会执行到组件继承自`Vue`的`._init`方法，通过`initEvents`将事件处理后存储到`vm._events`中，通过`initProps`将`childData`赋值到子组件`A`的`vm`实例上，并进行响应式处理，让其可以通过`vm.childData`的方式访问，并且数据发生变化时视图也可以发生改变。\\n      \\n组件模板编译后对应的`render`函数是:\\n```\\nwith(this) {\\n    return _c('div', {\\n        on: {\\n            \\\"click\\\": emitData\\n        }\\n    }, [_v(_s(childData))])\\n}\\n```\\n在`createElm`完成节点的创建后，在`invokeCreateHooks(vnode, insertedVnodeQueue)`阶段，给`DOM`原生节点节点绑定`emitData`。\\n\\n### 3、`this.$emit`\\n在点击执行`this.$emit`时，会通过`var cbs = vm._events[event]`取出`_events`中的事件进行执行。\\n\\n至此，父组件中的传递的数据就在子组件中可以通过`this.xxx`的方式获得，也可以通过`this.$emit`的方式将子组件中的数据传递给父组件。\\n\\n`prop`数据发生改变引起视图变化的底层逻辑请参考[vue2从数据变化到视图变化：props引起视图变化详解](https://juejin.cn/post/7132758292681457700)\\n\\n## 三十七、`$attrs`和`$listeners`\\n**使用场景：** 父子组件非`props`属性和非`native`方法传递\\n```\\n// main.js文件\\nimport Vue from \\\"vue\\\";\\n\\nconst B = {\\n  template: `<div @click=\\\"emitData\\\">{{ formParentData }}</div>`,\\n  data() {\\n    return {\\n      formParentData: ''\\n    }\\n  },\\n  inheritAttrs: false,\\n\\n  created() {\\n    this.formParentData = this.$attrs;\\n    console.log(this.$attrs, '--------------a-component-$attrs')\\n    console.log(this.$listeners, '--------------b-component-$listeners')\\n  },\\n  methods: {\\n    emitData() {\\n      this.$emit('onFun', 'form B component')\\n    }\\n  },\\n}\\n\\nconst A = {\\n  template: `<B v-bind='$attrs' v-on='$listeners'></B>`,\\n  components: {\\n    B,\\n  },\\n  props: ['propData'],\\n  inheritAttrs: false,\\n  created() {\\n    console.log(this.$attrs, '--------------b-component-$attrs')\\n    console.log(this.$listeners, '--------------b-component-$listeners')\\n  }\\n}\\n\\nnew Vue({\\n  el: '#app',\\n  components: {\\n    A,\\n  },\\n  template: `<A :attrData='parentData' :propData='parentData' @click.native=\\\"nativeFun\\\" @onFun=\\\"onFun\\\"></A>`,\\n  data() {\\n    return {\\n      parentData: 'msg'\\n    }\\n  },\\n  methods: {\\n    nativeFun() {\\n      console.log('方法A');\\n    },\\n    onFun(v) {\\n      console.log('方法B', v);\\n    },\\n  }\\n})\\n```\\n当前例子中，`new Vue`的`template`模板中有`attrData`、`propData`、`click.native`和`onFun`在进行传递。实际运行后，在`A`组件中`this.$attrs`为`{attrData: 'msg'}`，`this.$listeners`为`{onFun:f(...)}`。在`A`组件中通过`v-bind='$attrs'`和`v-on='$listeners'`的方式继续进行属性和方法的传递，在`B`组件中就可以获取到`A`组件中传入的`$attrs`和`$listeners`。\\n\\n当前例子中完成了非`props`属性和非`native`方法的传递，并且通过`v-bind='$attrs'`和`v-on='$listeners'`的方式实现了属性和方法的跨层级传递。\\n\\n同时通过`this.$emit`的方法触发了根节点中`onFun`事件。\\n\\n关于例子中的`inheritAttrs: false`，默认情况下父作用域的不被认作`props`的`attribute`绑定将会“回退”且作为普通的`HTML`属性应用在子组件的根元素上。当撰写包裹一个目标元素或另一个组件的组件时，这可能不会总是符合预期行为。通过设置`inheritAttrs`到`false`，这些默认行为将会被去掉。\\n\\n## 三十八、`$parent`和`$children`\\n**使用场景：** 利用父子关系进行数据的获取或者方法的调用\\n```\\nconst A = {\\n  template: `<div @click=\\\"changeParentData\\\">{{childRandom}}</div>`,\\n  data() {\\n    return {\\n      childRandom: Math.random()\\n    }\\n  },\\n  mounted() {\\n    console.log(this.$parent.parentCount, '--child-created--'); // 获取父组件中的parentCount\\n  },\\n  methods: {\\n    changeParentData() {\\n      console.log(this.$parent); // 打印当前实例的$parent\\n      this.$parent.changeParentData(); // 调用当前父级中的方法`changeParentData`\\n    },\\n    changeChildData() {\\n      this.childRandom = Math.random();\\n    }\\n  }\\n}\\nconst B = {\\n  template: `<div>b-component</div>`,\\n}\\n\\nnew Vue({\\n  el: '#app',\\n  components: {\\n    A,\\n    B,\\n  },\\n  template: `<div><A></A><B></B><p>{{parentCount}}</p><button  @click=\\\"changeChildrenData\\\">修改子组件数据</button></div>`,\\n  data() {\\n    return {\\n      parentCount: 1\\n    }\\n  },\\n  mounted() {\\n    console.log(this.$children[0].childRandom, '--parent-created--'); // 获取第一个子组件中的childRandom\\n  },\\n  methods: {\\n    changeParentData() {\\n      this.parentCount++;\\n    },\\n    changeChildrenData() {\\n      console.log(this.$children); // 此时有两个子组件\\n      this.$children[0].changeChildData(); // 调起第一个子组件中的'changeChildData'方法\\n    }\\n  }\\n})\\n```\\n在当前例子中，父组件可以通过`this.$children`获取所有的子组件，这里有`A`组件和`B`组件，可以通过`this.$children[0].childRandom`的方式获取子组件`A`中的数据，也可以通过`this.$children[0].changeChildData()`的方式调起子组件`A`中的方法。\\n\\n子组件可以通过`this.$parent`的方式获取父组件，可以通过`this.$parent.parentCount`获取父组件中的数据，也可以通过`this.$parent.changeParentData()`的方式修改父组件中的数据。\\n\\n`Vue`中`$parent`和`$children`父子关系的底层构建请参考[杂谈：$parent/$children的底层逻辑](https://juejin.cn/post/7162097166725414942/)\\n\\n## 三十九、`inject`和`provide`\\n使用场景：嵌套组件多层级传参\\n```\\nconst B = {\\n  template: `<div>{{parentData1}}{{parentData2}}</div>`,\\n  inject: ['parentData1', 'parentData2'],\\n}\\n\\nconst A = {\\n  template: `<B></B>`,\\n  components: {\\n    B,\\n  },\\n}\\n\\nnew Vue({\\n  el: '#app',\\n  components: {\\n    A,\\n  },\\n  template: `<A></A>`,\\n  provide: {\\n    parentData1: {\\n      name: 'name-2',\\n      age: 30\\n    },\\n    parentData2: {\\n      name: 'name-2',\\n      age: 29\\n    },\\n  }\\n})\\n```\\n例子中在`new Vue`的时候通过`provide`提供了两个数据来源`parentData1`和`parentData2`，然后跨了一个`A`组件在`B`组件中通过`inject`注入了这两个数据。\\n\\n### 1、`initProvide` \\n在执行组件内部的`this._init`初始化方法时，会执行到`initProvide`逻辑：\\n```\\nexport function initProvide (vm: Component) {\\n  const provide = vm.$options.provide\\n  if (provide) {\\n    vm._provided = typeof provide === 'function'\\n      ? provide.call(vm)\\n      : provide\\n  }\\n}\\n```\\n如果在当前`vm.$options`中存在`provide`，会将其执行结果赋值给`vm._provided`。\\n### 2、`initInjections`\\n```\\nfunction initInjections (vm: Component) {\\n  const result = resolveInject(vm.$options.inject, vm)\\n  if (result) {\\n    toggleObserving(false)\\n    Object.keys(result).forEach(key => {\\n      /* istanbul ignore else */\\n      if (process.env.NODE_ENV !== 'production') {\\n        defineReactive(vm, key, result[key], () => {\\n          warn(\\n            `Avoid mutating an injected value directly since the changes will be ` +\\n            `overwritten whenever the provided component re-renders. ` +\\n            `injection being mutated: \\\"${key}\\\"`,\\n            vm\\n          )\\n        })\\n      } else {\\n        defineReactive(vm, key, result[key])\\n      }\\n    })\\n    toggleObserving(true)\\n  }\\n}\\nfunction resolveInject (inject: any, vm: Component): ?Object {\\n  if (inject) {\\n    // inject is :any because flow is not smart enough to figure out cached\\n    const result = Object.create(null)\\n    const keys = hasSymbol\\n      ? Reflect.ownKeys(inject)\\n      : Object.keys(inject)\\n\\n    for (let i = 0; i < keys.length; i++) {\\n      const key = keys[i]\\n      // #6574 in case the inject object is observed...\\n      if (key === '__ob__') continue\\n      const provideKey = inject[key].from\\n      let source = vm\\n      while (source) {\\n        if (source._provided && hasOwn(source._provided, provideKey)) {\\n          result[key] = source._provided[provideKey]\\n          break\\n        }\\n        source = source.$parent\\n      }\\n      if (!source) {\\n        if ('default' in inject[key]) {\\n          const provideDefault = inject[key].default\\n          result[key] = typeof provideDefault === 'function'\\n            ? provideDefault.call(vm)\\n            : provideDefault\\n        } else if (process.env.NODE_ENV !== 'production') {\\n          warn(`Injection \\\"${key}\\\" not found`, vm)\\n        }\\n      }\\n    }\\n    return result\\n  }\\n}\\n```\\n如果当前组件中有选项`inject`，会以`while`循环的方式不断在`source = source.$parent`中寻找`_provided`，然后获取到祖先组件中提供的数据源，这是实现祖先组件向所有子孙后代注入依赖的核心。\\n\\n## 四十、`Vue`项目能做的性能优化\\n### 1、`v-if`和`v-show`\\n- 频繁切换时使用`v-show`，利用其缓存特性\\n- 首屏渲染时使用`v-if`，如果为`false`则不进行渲染\\n### 2、`v-for`的`key`\\n- 列表变化时，循环时使用唯一不变的`key`，借助其本地复用策略\\n- 列表只进行一次渲染时，`key`可以采用循环的`index`\\n### 3、侦听器和计算属性\\n- 侦听器`watch`用于数据变化时引起其他行为\\n- 多使用`compouter`计算属性顾名思义就是新计算而来的属性，如果依赖的数据未发生变化，不会触发重新计算\\n### 4、合理使用生命周期\\n- 在`destroyed`阶段进行绑定事件或者定时器的销毁\\n- 使用动态组件的时候通过`keep-alive`包裹进行缓存处理，相关的操作可以在`actived`阶段激活\\n### 5、数据响应式处理\\n- 不需要响应式处理的数据可以通过`Object.freeze`处理，或者直接通过`this.xxx = xxx`的方式进行定义\\n- 需要响应式处理的属性可以通过`this.$set`的方式处理，而不是`JSON.parse(JSON.stringify(XXX))`的方式\\n### 6、路由加载方式\\n- 页面组件可以采用异步加载的方式\\n### 7、插件引入\\n- 第三方插件可以采用按需加载的方式，比如`element-ui`。\\n### 8、减少代码量\\n- 采用`mixin`的方式抽离公共方法\\n- 抽离公共组件\\n- 定义公共方法至公共`js`中\\n- 抽离公共`css`\\n### 9、编译方式\\n- 如果线上需要`template`的编译，可以采用完成版`vue.esm.js`\\n- 如果线上无需`template`的编译，可采用运行时版本`vue.runtime.esm.js`，相比完整版体积要小大约`30%`\\n### 10、渲染方式\\n- 服务端渲染，如果是需要`SEO`的网站可以采用服务端渲染的方式\\n- 前端渲染，一些企业内部使用的后端管理系统可以采用前端渲染的方式\\n### 11、字体图标的使用\\n- 有些图片图标尽可能使用字体图标\\n\\n## 四十一、`Vue`项目白屏问题\\n- 1、开启`gzip`压缩减小文件体积。\\n- 2、`webpack`设置`productionSourceMap:false`，不在线上环境打包`.map`文件。\\n- 3、路由懒加载\\n- 4、异步组件的使用\\n- 5、静态资源使用`cdn`链接引入\\n- 6、采用`ssr`服务端渲染方案\\n- 7、骨架屏或者`loading`效果填充空白间隙\\n- 8、首次不渲染的隐藏采用`v-if`\\n- 9、注重代码规范：抽取公共组件，公共js，公共css样式，减小代码体积。删除无用代码，减少非必要注释。防止写出死循环等等\\n- 10、删除辅助开发的`console.log`\\n- 11、非`Vue`角度思考：非重要文件采用异步加载方式、css样式采用媒体查询、采用域名分片技术、http1升级成http2、如果是SSR项目考虑服务端渲染有没有可优化的点、请求头是否带了多余信息等思路\\n\\n内容有些多，大体可以归类为从服务端拿到资源的速度、资源的体积和渲染是否阻塞的角度去作答。\\n\\n## 四十二、从`0`到`1`构建一个`Vue`项目需要注意什么\\n- 架子：选用合适的初始化脚手架(`vue-cli2.0`或者`vue-cli3.0`)\\n- 请求：数据`axios`请求的配置\\n- 登录：登录注册系统\\n- 路由：路由管理页面\\n- 数据：`vuex`全局数据管理\\n- 权限：权限管理系统\\n- 埋点：埋点系统\\n- 插件：第三方插件的选取以及引入方式\\n- 错误：错误页面\\n- 入口：前端资源直接当静态资源，或者服务端模板拉取\\n- `SEO`：如果考虑`SEO`建议采用`SSR`方案\\n- 组件：基础组件/业务组件\\n- 样式：样式预处理起，公共样式抽取\\n- 方法：公共方法抽离\\n\\n## 四十三、`SSR`\\n### 1、什么是服务端渲染（SSR）？\\nVue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务器端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记\\\"激活\\\"为客户端上完全可交互的应用程序。\\n### 2、为什么使用服务端渲染（SSR）？\\n与传统 SPA (单页应用程序 (Single-Page Application)) 相比，服务器端渲染 (SSR) 的优势主要在于：\\n- 更好的 SEO，由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面。\\n- 更快的内容到达时间 (time-to-content)，特别是对于缓慢的网络情况或运行缓慢的设备。\\n### 3、使用服务器端渲染 (SSR) 时需要考虑的问题？\\n使用服务器端渲染 (SSR) 时还需要有一些权衡之处\\n-   开发条件所限。浏览器特定的代码，只能在某些生命周期钩子函数 (lifecycle hook) 中使用；一些外部扩展库 (external library) 可能需要特殊处理，才能在服务器渲染应用程序中运行。\\n-   涉及构建设置和部署的更多要求。与可以部署在任何静态文件服务器上的完全静态单页面应用程序 (SPA) 不同，服务器渲染应用程序，需要处于 Node.js server 运行环境。\\n-   更多的服务器端负载。在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用 CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 (high traffic) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。\\n\\n## 四十四、`scoped`\\n在`Vue`项目开发的项目中如果样式中未使用`scoped`，组件间的样式会出现覆盖的问题。\\n\\n**反例：**\\n```\\n// app.vue文件\\n<template>\\n  <div>\\n    <h3 class=\\\"title\\\">app-txt</h3>\\n    <child></child>\\n  </div>\\n</template>\\n\\n<script>\\nimport child from \\\"@/components/child\\\";\\nexport default {\\n  components: { child },\\n};\\n</script>\\n\\n<style>\\n.title {\\n  color: red;\\n}\\n</style>\\n```\\n\\n```\\n// child.vue文件\\n<template>\\n  <h3 class=\\\"title\\\">child-txt</h3>\\n</template>\\n\\n<style>\\n  .title {\\n    color: green;\\n  }\\n</style>\\n```\\n\\n父组件和子组件的样式颜色都为`green`，子组件中的样式覆盖了父组件的样式。\\n\\n**正例：**\\n\\n```\\n<template>\\n  <h3 class=\\\"title\\\">child-txt</h3>\\n</template>\\n\\n<style scoped>\\n  .title {\\n    color: green;\\n  }\\n</style>\\n```\\n此时，父组件中颜色为`red`，子组件中颜色为`green`。\\n\\n**主要原因：**\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e4b3818e9f4e40a9acc00e957c114b71~tplv-k3u1fbpfcp-watermark.image?)\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8343809daa3f49a98914c238b13e1ae7~tplv-k3u1fbpfcp-watermark.image?)\\n例子中的DOM节点和CSS层叠样式中都被添加了`data-v-xxx`来表示唯一，所以`scoped`是给当前组件的节点和样式唯一标识为`data-v-xxx`，避免了样式覆盖。\\n\\n## 四十五、`created`、`watch`和`computed`的执行顺序\\n\\n请参考 [杂谈：vue中created、watch和computed的执行顺序](https://juejin.cn/post/7169990997223407646)\\n\\n## 四十六、`created`中两次数据修改，会触发几次页面更新\\n\\n请参考 [杂谈：created中两次数据修改，会触发几次页面更新？](https://juejin.cn/post/7170248485705351175)\\n\\n## 写在最后\\n\\n漫漫寒冬里，潜心沉淀，静待春暖花开，一切可期~",
        "tags": [
            "前端",
            "面试",
            "Vue.js"
        ]
    },
    {
        "article_id": "7170767923005358094",
        "cover_image": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bdc9311d551443ada7786342e63d28d8~tplv-k3u1fbpfcp-watermark.image?",
        "title": "疫情当下，远程工作兴起！前端音视频通话？学！🔥",
        "brief": "制作 https 自签名证书，使用 nginx 反向代理 https，使用 socket.io 来实现客户端与信令服务器的通信，实现一个 WebRTC + 信令服务器自动建立连接的音视频实时通话。",
        "user_name": "荣顶",
        "view_count": 8260,
        "collect_count": 213,
        "comment_count": 24,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/26f254d4ee2f1e58081b5f503fd01dda~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: smartblue\\nhighlight: atom-one-dark\\n---\\n\\n>作者：[荣顶](https://github.com/wangrongding) 、[github](https://github.com/wangrongding)  \\n声明：文章为稀土掘金技术社区首发签约文章，14天内禁止转载，14天后未获授权禁止转载，侵权必究！\\n\\n## 前言\\n\\n- [WebRTC 从实战到未来！迎接风口，前端必学的技术 🔥](https://juejin.cn/post/7151932832041058340)\\n- [WebRTC 从实战到未来！前端如何实现一个最简单的音视频通话？🔥](https://juejin.cn/post/7165539003465531399)\\n\\n看到前两篇文章都非常受欢迎，非常的开心！🤖 继续加油！冲！  \\n我们也在前两篇文章中大概讲解了 音视频媒体流的获取，处理，以及在上一篇文章中为了更直观的演示 WebRTC 建立点对点通信的过程，通过手动交换 sdp 来建 p2p 连接，实现了一个最简单的音视频通话，但在实际的应用场景中，我们几乎不可能会通过手动来交换 sdp ，因为这样会增加很多的工作量，也不方便，所以我们借助一个信令服务器来帮助我们实现自动建立连接的这个过程。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f2daf17b2c8e4b8fa4824467c7603ae4~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n## 从这篇文章中你将学到\\n\\n- 学会如何制作 https 的自签名证书\\n- 学会如何使用 nginx 反向代理 https\\n- 学会使用 socket.io 来实现客户端与信令服务器的通信\\n- 了解并实现一个 WebRTC + 信令服务器自动建立连接的音视频实时通话\\n\\n## 体验地址\\n\\n[👉🏻 1.本文示例在线体验地址](https://frontend-park.vercel.app/audio-and-video/webRTC/signaling-p2p)  \\n[👉🏻 2.本文客户端源代码地址](https://github.com/wangrongding/frontend-park)  \\n[👉🏻 3.本文服务端源代码地址](https://github.com/wangrongding/node-park/blob/main/src/signaling/signaling-http-server.js)\\n\\n你可以开两个浏览器 tab 或者用不同的设备，根据说明即可体验。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/49c4ff3a08364415b368422e86f033a6~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n## 了解信令前，需要了解的几个概念\\n\\n结合上一篇讲到的 `SDP` , `NAT` , `ICE`，我们还需要了解：`STUN`，`TURN`服务，以及`ICE候选者的种类`。\\n\\n### 候选者的种类\\n\\nWebRTC 众多的链接候选者中，可以分为三类：\\n\\n- `host`：本机候选者（设备的 ipv4 或 ipv6 地址，即内网地址，一般会有两个，分别对应 udp 和 tcp，ip 相同，端口不同），ICE 尝试与对方建立 P2P 连接时的首选，一般这个地址为内网地址，如果双方位于同一个内网，那么直接建立成功。\\n- `srflx`：P2P 链接候选者（STUN 服务返回的你这个主机的外网地址），在第一次尝试连接失败时，说明双方不在同一个内网，ICE 将使用 STUN 服务获取主机的公网地址以及映射端口，然后开始尝试通过用这个公网 IP 和对方建立连接。\\n- `relay`：中继服务器候选者，如果第二次仍然失败了（当 `STUN` 不适用时(某些 NAT 会为每个连接分配不同的端口，导致获取的端口和视频连接端口并不一致），那么意味着双方无法直接建立 P2P 连接，这时候就只能通过一个中继服务器，即 `TURN` 服务器来和双方建立连接，然后中转他们之间传输的内容，这种对服务器开销最大，而且也会增加时延，所以只有在没得选择的情况下采用。\\n\\n所以可以总结为三类候选者中，`host` 候选者的优先级是最高的，当 `host` 类型的候选者无法建立链接的时候，WebRTC 会从 `srflx` 候选者中进行连通性测试，也就是尝试通过 `P2P` 的方式连接双方，如果失败才会尝试使用 `relay` 的方式进行链接。\\n\\n### STUN (Session Traversal Utilities for NAT)\\n\\n我们需要知道的是：主机要想访问公网资源，必须有自己的公网地址，只有这样，我们才能在访问资源主机的时候，让它通过我们主机的公网地址找到我们的主机，并把你想要访问的资源发送给你。\\n\\n> 一般情况下，在一个网段内的主机只有内网 IP 和端口号，那内网的主机是如何访问公网资源的呢？实际上，内网的网关都有 NAT 的功能，NAT 的功能是将内网 IP 映射转换成公网地址。当我们的内网主机想要访问公网资源的时候，内网网关会将请求的内网地址映射成公网地址，然后将请求发送到要访问的公网服务器上，服务器处理好请求之后，将响应数据传递给请求中携带的公网地址上，该公网接收到响应数据之后，它的网关就会通过之前的地址映射最终中转给内网的主机。通过这种方式实现内网主机访问公网资源的需求。  \\n> 基于以上的这种方式，我们可以知道内网主机虽然不知道自己在公网的地址，但是内网主机访问的服务器是知道内网主机对应的公网 IP 的，于是我们在公网中架设一台服务器，通过这台服务器可以询问到自己的公网地址。实际上这一询问流程已经被定义成了一套规范，就是 STUN 协议。  \\n> NAT 遍历操作由 Session Traversal Utilities for NAT (STUN) 服务器执行。 STUN 方法是一种用于终端检查其“公共 IP 地址和端口”的过程的协议。当客户端向 STUN 服务器发送请求时，它会发送通信所需的信息以及客户端用来与其他设备通信的公共 IP 地址。但是，即使在这种情况下，如果无法进行通信，也会将其传输到 TURN 服务器。\\n\\n简单概括就是，我们要知道自己的`外网 IP 地址`，依靠的就是 `STUN` 服务。客户端通过给公网的 STUN 服务器发送请求获得自己的公网地址信息，以及是否能够被（穿过路由器）访问。\\n\\n[协议地址](https://www.rfc-editor.org/rfc/rfc5389)\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b12e0c9d88044a788ac56627a515140~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n### TURN (Session Traversal Utilities for NAT)\\n\\nWebRTC 通信双方通过 P2P 的方式无法建立链接的情况下，会使用 relay 服务进行中转服务。 relay 是所有候选者中优先级最低的链接方式，但是 relay 也是连通率最高的方式。WebRTC 通信双方通过向 TURN 服务器发送 Allocation 指令获得在 relay 服务器上的端口，用于中转 UDP 数据。\\n\\n> 总结上面的内容，WebRTC 的通信双方在进行链接之前会按照优先级收集链接的候选者，按照优先级的高低，分别是：在本级收集所有的 host 类型的候选者进行内网链接，通过 STUN 协议收集 srflx 候选者进行 P2P 链接，通过 TURN 协议收集 relay 候选者通过中转服务器链接并传输 UDP 数据。\\n\\n很显然这种方式是开销很大的，所以只有在没得选择的情况下采用。\\n\\n[协议地址](https://www.rfc-editor.org/rfc/rfc7065)\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8b03272406d49ada507ecd8217771c4~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n一般我们都会通过 [coturn](https://github.com/coturn/coturn)会[restund](https://creytiv.com/restund.html)来搭建 `STUN` 和 `TURN` 服务。非常的方便，我使用的是开源社区提供的 `coturn`，它是一个比较成熟的项目。我会在第 4,5 篇文章讲到如何搭建它，这篇我们直接用现成的 `STUN` 服务就行。至于 `TURN`服务...🥲 目前我还没有一个比较好的服务器，能顶得住这种，我后面看看搞一台合适的过来搭建一个，供大家在线体验一下。\\n\\n所以这篇文章我们做的 demo 可以在内网，以及网络环境不是特别复杂的外网下进行音视频通话。（一方位于 NAT 网络内部，或者双方都在 `非对称NAT`网络内的情况）\\n\\n## 什么叫信令？\\n\\n我们知道 `WebRTC` 想要直接通过 `P2P` 连接进行通信，需要一个中继的过程(在两个终端之间传递控制信息的过程)，这个中继的过程就称之为`信令`。  \\n所以简单来说，信令就是在两个设备之间发送控制信息以确定通信协议、信道、媒体编解码器和格式以及数据传输方法以及任何所需的路由信息的过程，而执行此操作的服务器称为`信令服务器`。\\n\\n信令服务器按照与聊天室相同的方式对连接的节点进行逻辑分组，并帮助各端相互交换 `SDP` 等信息。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a1001dc7f6b7417ea2809773a02f00de~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n> 关于 WebRTC 的信令流程最重要的一点是： **「信令在规范中并没有定义」** 所以开发者需要自己决定如何实现这个过程。开发者可以为应用程序引擎选择任意的信息协议（如 SIP 或 XMPP），任意双向通信信道（如 WebSocket 或 XMLHttpRequest) 与持久连接服务器的 API（如 Google Channel API）一起工作。\\n\\n根据上面的说明我们就可以知道信令服务器的实现方式有很多种，可以根据要开发的服务的性质使用现有的信令协议，也可以通过轮询/长轮询或 websocket 等适当的双向通信通道来实现。\\n\\n由于信令的核心是交换异步发送的对等信息（SDP，Candidate）。因此，将其实现为支持全双工通信的 websocket 最为合适。下面我面会通过 socket.io 来实现一个简单的信令服务器。\\n\\n有点像村里相亲的，一开始不认识对方，没法直接联系，需要通过媒介，中间人来传递消息后，你们可能知道对方的位置啊，联系方式啊等等才能很好的直接建立联系。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5d4d8c69ef034c4baae5a49b5d1ebe3e~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5af419763ad5460d981009a2bffbf34f~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n这张图很清楚的描述了这个过程。\\n\\n各端通过信令服务器交换 `SDP` 信息，然后各端通过 `P2P` 连接进行通信。\\n\\n关于信令更多的详细内容可以参考：[MDN 信令的介绍](https://developer.mozilla.org/zh-CN/docs/Web/API/WebRTC_API/Session_lifetime#%E4%BF%A1%E4%BB%A4)，[MDN 信令与视频通话](https://developer.mozilla.org/zh-CN/docs/Web/API/WebRTC_API/Signaling_and_video_calling)\\n\\n## 信令服务器的具体实现\\n\\n下面我们主要使用 `socket.io` 来实现一个简单的信令服务器。\\n\\n为什么使用它呢？\\n\\n就像 Axios 是对 XMLHttpRequest 的封装， 而 Socket.io 就是对 WebSocket 的封装，并且实现了 WebSocket 的服务端代码。Socket.IO 将 WebSocket 和轮询（Polling）机制以及其它的实时通信方式封装成了通用的接口，并且在服务端实现了这些实时机制的相应代码。也就是说，WebSocket 仅仅是 Socket.IO 实现实时通信的一个子集。Socket.IO 简化了 WebSocket API，统一了返回传输的 API。\\n\\n总结一下就是：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d51d89c1ee854331851482042081c44b~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n用它来写非常的简单方便，下面我们就用 express 配合 socket.io 来实现一个简单的信令服务器。\\n\\n### 信令服务的搭建\\n\\n我们用 nodejs 来写服务端，首先我们要安装一下 `socket.io`\\n\\n```bash\\n# 服务端\\nnpm i express socket.io\\n```\\n\\n然后我们创建一个 `server.js` 文件，用来启动一个没有业务逻辑的信令服务。\\n\\n```js\\nimport http from 'http'\\nimport { Server } from 'socket.io'\\nimport express from 'express'\\n\\nconst port = 3000\\nconst app = express()\\nconst httpServer = http.createServer(app)\\n// 创建信令服务器\\nconst io = new Server(httpServer, {\\n  cors: {\\n    origin: '*', // 允许跨域\\n    methods: ['GET', 'POST'], // 允许的请求方式\\n    allowedHeaders: '*', // 允许的请求头\\n    credentials: true, // 允许携带cookie\\n  },\\n  allowEIO3: true, // 是否启用与Socket.IO v2客户端的兼容性\\n  transport: ['websocket'], // 仅允许websocket,[\\\"polling\\\", \\\"websocket\\\"]\\n})\\n\\n// 在指定端口启动服务器\\nhttpServer.listen(port, () => {\\n  console.log('\\\\n Http server up and running at => http://%s:%s', httpServer.address().address, httpServer.address().port)\\n})\\n\\n// 监听用户连接\\nio.on('connection', (socket) => {\\n  console.log('connection~')\\n\\n  // 监听连接断开\\n  socket.on('disconnect', () => {\\n    console.log('disconnect~')\\n  })\\n})\\n```\\n\\n这里我们使用了 `express` 来创建一个简单的服务，然后使用 `socket.io` 来创建一个 websocket 服务。\\n\\n这样一个 简单 websocket 服务架子就搭好了。我们先启动这个服务.\\n\\n```bash\\nnode server.js\\n```\\n\\n是不是很简单~~\\n\\n### 客户端需要做的事情\\n\\n然后我们在客户端也要安装配套的 `socket.io-client`\\n\\n```bash\\n# 客户端\\nnpm i socket.io-client\\n```\\n\\n然后我们在客户端代码中引入 `socket.io-client`，并且连接到我们刚启动的信令服务。\\n\\n```js\\nimport io from 'socket.io-client'\\n\\n// 连接到信令服务\\nconst socket = io('http://localhost:3000')\\n```\\n\\n由于 WebRTC 是需要在 `https` 协议下才能使用的，所以我们需要在本地生成一个 自签名的`https` 证书。（当然，你客户端直接在 localhost 下测试就不需要通过 https 了）。\\n\\n要不然，你在 https 协议的页面，请求 http 资源时，浏览器会报错，因为 https 页面中的资源必须是 https 的，否则浏览器会阻止加载。\\n\\nhttps，对应的我们信令服务的地址也需要是 https，不然就会报错\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/44664b5bb8ee46b4827eb812e2249d90~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n所以下面我们需要自签一张证书。\\n\\n## 自签证书\\n\\n我们可以通过 openssl 生成自签证书，并将其保存在本地。我一直觉得用 OpenSSL 弄好麻烦，这里我使用 mkcert，它作为本地 https 的快速解决方案，用起来非常方便。\\n\\n> [mkcert](https://github.com/FiloSottile/mkcert) 是一个用 Go 语言编写的工具，它可以轻松地为本地开发生成有效的 TLS 证书。它使用了一个名为 local CA 的根证书，这个根证书是由 mkcert 生成的，它会被安装到系统的受信任的根证书列表中。\\n\\n下面一起来通过 mkcert 生成自签证书，并将其保存在本地。\\n\\n### 安装 mkcert 并生成证书\\n\\n我这边使用的是 macos ，安装起来很方便，其他系统的安装方式可以参考 [mkcert 文档](https://github.com/FiloSottile/mkcert),[本地 https 快速解决方案——mkcert](https://blog.dteam.top/posts/2019-04/%E6%9C%AC%E5%9C%B0https%E5%BF%AB%E9%80%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88mkcert.html)，基本都差不多\\n\\n```sh\\n# 安装 mkcert\\nbrew install mkcert\\n# 安装完成后，执行↓\\nmkcert -install\\n```\\n\\n安装完成后，我们就可以使用 mkcert 生成自签证书了，这里我生成了一个名为 localhost 的证书，证书保存在当前目录下。\\n\\n生成证书也很简单，就一行命令\\n\\n```sh\\n# mkcert domain1 [domain2 [...]]\\n\\n# 本地的直接这样就ok\\nmkcert localhost 127.0.0.1 ::1\\n```\\n\\n生成的证书包含两个文件，一个是证书文件，一个是私钥文件，这两个文件都是必须的，因为证书文件是公开的，而私钥文件是私有的，它们是一对。\\n\\n```sh\\nlocalhost.pem\\nlocalhost-key.pem\\n```\\n\\n生成完毕后，不管你是在 nginx 中使用还是在 node 中使用，只需要将在 nginx 或者 node 中指定证书文件和私钥文件的路径即可。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ae475542dc0467fa697d9c609305e0f~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n### node 中使用\\n\\n```js\\nimport { Server } from 'socket.io'\\nimport express from 'express'\\nimport https from 'https'\\nimport path from 'path'\\nimport { fileURLToPath } from 'url'\\nimport fs from 'fs'\\n\\nconst __filename = fileURLToPath(import.meta.url)\\nconst __dirname = path.dirname(__filename)\\n\\n//https证书\\nconst options = {\\n  cert: fs.readFileSync(path.join(__dirname, '../assets/localhost.pem')),\\n  key: fs.readFileSync(path.join(__dirname, '../assets/localhost-key.pem')),\\n}\\nconst app = express()\\nconst httpsServer = https.createServer(options, app)\\n\\nhttpsServer.listen(3333, '0.0.0.0', () => {\\n  console.log('Https server up and running...')\\n})\\n```\\n\\n### nginx 中使用\\n\\n在本地测试的话怎么样都行，到线上环境的时候，可以去各大云服务商申请证书，上传到服务器和自签的证书一样使用就行了，这块就不多说了。\\n\\n(需要注意的是，ip 证书非常的贵，一般都是直接用一个域名证书，然后通过 nginx 做转发)\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/74baba5bd88d4796b944e081848fda44~tplv-k3u1fbpfcp-zoom-1.image)  \\n或者你只是想在线上测试的话，也一样通过 mkcert 工具来生成本地的自签 HTTPS 证书就行了，只不过这个证书浏览器会提示不安全，但是用来测试还是可以的。\\n\\n```sh\\nserver {\\n    #SSL 默认访问端口号为 443\\n    listen 12345 ssl;\\n    #请填写证书文件的相对路径或绝对路径\\n    ssl_certificate /path/to/localhost.pem;\\n    #请填写私钥文件的相对路径或绝对路径\\n    ssl_certificate_key /path/to/localhost-key.pem;\\n    #请填写绑定证书的域名\\n    server_name localhost;\\n\\n    location / {\\n      proxy_pass http://localhost:3000;\\n\\n      # 为了让代理服务器了解客户端将协议切换到 WebSocket 的意图，下面三个标头必须加上\\n      proxy_http_version 1.1;\\n      proxy_set_header Upgrade $http_upgrade;\\n      proxy_set_header Connection 'upgrade';\\n\\n      # http://nginx.org/en/docs/http/websocket.html\\n      # https://echizen.github.io/tech/2018/10-21-nginx-websocket\\n    }\\n}\\n```\\n\\n### 客户端使用\\n\\n比如我这边用 vite 创建的项目，我在 vite.config.ts 中要配置 https，直接按照下面的代码配置就行了。其他脚手架生成的项目也是类似的。\\n\\n```typescript\\n// https://vitejs.dev/config/\\nimport * as fs from 'fs'\\n\\nexport default defineConfig((config) => ({\\n  // 配置主机、端口、https…\\n  server: {\\n    https: {\\n      key: fs.readFileSync(`${__dirname}/localhost-key.pem`),\\n      cert: fs.readFileSync(`${__dirname}/localhost.pem`),\\n    },\\n  },\\n}))\\n```\\n\\nok, 到这里，铺垫工作就完成了，下面我们就可以正式开始写前后端的相关逻辑了。\\n\\n## 信令服务的逻辑实现\\n\\n还记的我们上一篇文章中是如何实现 p2p 通信的吗？\\n\\n我们通过手动传输本地和远程的 `SDP`等信息来实现 P2P 通信，所以这次我们只需要把这个过程交给 socket 服务来处理就行了。\\n\\n首先我们需要安装并引入 `socket.io-client`，然后连接到我们上一小节启动的信令服务。\\n\\n```typescript\\nimport io from 'socket.io-client'\\nconst socket = io('https://localhost:3000')\\n```\\n\\n然后我们需要监听一些服务端的事件，这个我们根据具体需求来定义。\\n\\nsocket.io 最主要的就是 `on` 和 `emit` 两个方法，在客户端 `on` 用来监听服务端的事件，`emit` 用来触发服务端的事件。在服务端 `on` 用来监听客户端的事件，`emit` 用来触发客户端的事件。还有一些其他的 api 我们直接对着文档来就行，所以说它使用起来非常的简单。\\n\\n### 定义客户端需要监听的事件\\n\\nok，我们先来看一下我们需要监听的事件。\\n\\n```typescript\\n// 连接成功时触发\\nsocket.on('connect', () => {\\n  handleConnect()\\n})\\n\\n// 断开连接时触发\\nsocket.on('disconnect', (reason) => {\\n  if (reason === 'io server disconnect') {\\n    // 断线是由服务器发起的，重新连接。\\n    socket.connect()\\n  }\\n  ElMessage.warning('您已断开连接')\\n})\\n// 服务端发送报错信息\\nsocket.on('error', (data) => {\\n  ElMessage.error(data)\\n})\\n// 当有用户加入房间时触发\\nsocket.on('welcome', (data) => {\\n  ElMessage.success(data.userId === userId ? '🦄成功加入房间' : `🦄${data.userId}加入房间`)\\n})\\n// 当有用户离开房间时触发\\nsocket.on('leave', (data) => {\\n  ElMessage.warning(data.userId === userId ? '🦄成功离开房间' : `🦄${data.userId}离开房间`)\\n})\\n// 当有用户发送消息时触发\\nsocket.on('message', (data) => {})\\n// 创建offer,发送给远端\\nsocket.on('createOffer', (data) => {\\n  // 如果已经创建过，直接发送\\n  if (offerSdp) {\\n    socket.emit('offer', {\\n      userId,\\n      roomId: roomId.value,\\n      sdp: offerSdp,\\n    })\\n    return\\n  }\\n  createOffer() // 创建 offer\\n})\\n// 收到offer,创建answer\\nsocket.on('offer', (data) => {\\n  createAnswer(data.sdp)\\n})\\n// 收到answer,设置远端sdp\\nsocket.on('answer', (data) => {\\n  addAnswer(data.sdp)\\n})\\n```\\n\\n当然你也可以根据自己的习惯直接把所有事件都包在 `socket.on('message',(data)=>{})` 里，data 里加好 type 就行，这样只需要保留几个关键事件，其余的都走 message 事件的逻辑。\\n\\n### 定义信令服务端需要监听的事件\\n\\n```javascript\\n// 用户连接\\nio.on('connection', (socket) => {\\n  console.log('connection~')\\n  // 用户加入房间\\n  socket.on('join', (data) => {\\n    console.log('join~', data)\\n    handleUserJoin(socket, data)\\n  })\\n  // 用户离开房间\\n  socket.on('leave', (data) => {\\n    console.log('leave', data)\\n    handleUserDisconnect(socket)\\n  })\\n  // 监听连接断开\\n  socket.on('disconnect', () => {\\n    console.log('disconnect~')\\n    handleUserDisconnect(socket)\\n  })\\n  //=============================\\n  // 用户发送 offer\\n  socket.on('offer', (data) => {\\n    socket.to(data.roomId).emit('offer', data)\\n  })\\n  // 用户发送 answer\\n  socket.on('answer', (data) => {\\n    socket.to(data.roomId).emit('answer', data)\\n  })\\n  // 用户发送消息\\n  socket.on('message', (data) => {\\n    console.log('message', data)\\n  })\\n})\\n```\\n\\n### 客户端加入房间\\n\\n接下来我们需要实现客户端加入房间的逻辑，这个逻辑其实就是告诉服务端，我要加入某个房间，然后服务端会把我这个房间的其他客户端的信息告诉我。\\n\\n```typescript\\n// 随机一个用户名，后面你可以自己改成输入框让用户输入\\nconst userId = Math.random().toString(36).substring(2)\\n// 房间号，这里随便写一个，后面你可以自己改成输入框让用户输入\\nconst roomId = 123\\n\\n// 加入房间\\nfunction joinRoom() {\\n  socket.emit('join', { userId, roomId })\\n}\\n```\\n\\n### 服务端接手客户端加入房间的逻辑\\n\\n服务端接手客户端加入房间的逻辑，其实就是把客户端的信息保存到服务端的内存中，然后把这个房间的其他客户端的信息告诉客户端。\\n\\n```js\\n// 服务端，当用户加入房间\\nsocket.on('join', (data) => {\\n  handleUserJoin(socket, data)\\n})\\n\\n// 房间信息\\nconst ROOM_LIST = []\\n// 每个房间最多容纳的人数\\nconst MAX_USER_COUNT = 2\\n// 用户加入房间\\nfunction handleUserJoin(socket, data) {\\n  const filterRoom = ROOM_LIST.filter((item) => item.roomId === data.roomId)[0]\\n  let room = { roomId: data.roomId, userList: [] }\\n\\n  // 判断房间是否存在\\n  if (filterRoom) {\\n    room = filterRoom\\n  } else {\\n    ROOM_LIST.push(room)\\n  }\\n\\n  // 每个房间人数不超过预设的人数\\n  if (room.userList.length >= MAX_USER_COUNT) {\\n    socket.emit('error', '房间人数已满，请稍后再试')\\n    return\\n  }\\n\\n  // 当房间里的人数为0且管理员还没有设置，设置管理员\\n  if (room.userList.length === 0) {\\n    room.admin = data.userId\\n  }\\n\\n  // 判断用户是否已经在房间里\\n  if (room.userList.some((item) => item.userId === data.userId)) {\\n    socket.emit('error', '用户已在房间里')\\n    return\\n  }\\n  // 把用户信息保存到房间里\\n  room.userList.push(data)\\n  console.log(data.userId, '加入房间')\\n\\n  socket.userId = data.userId\\n  socket.roomId = data.roomId\\n\\n  // 将用户加入房间\\n  socket.join(data.roomId)\\n  // 通知房间内的其他用户\\n  socket.to(data.roomId).emit('welcome', data)\\n  // 通知自己加入房间成功，\\n  socket.emit('joined', data)\\n}\\n```\\n\\n### 客户端创建提案\\n\\n这里，我们主要对上一篇创建提案的代码中添加 socket 发送的逻辑，我们需要在当有 ICE 候选改变时，将这些 本地的 SDP 描述发送到服务端，服务端再将这些信息转发给远程的客户端。这里我们先写发送逻辑，后面再去服务端写好接收逻辑就行。\\n\\n```typescript\\n// 成功加入房间\\nsocket.on('joined', (room, id) => {\\n  ElMessage.success('🦄🦄🦄成功加入房间')\\n  createOffer()\\n})\\n\\n// 创建 offer\\nasync function createOffer() {\\n  // 当一个新的offer ICE候选人被创建时触发事件\\n  peerConnection.onicecandidate = async (event) => {\\n    if (event.candidate) {\\n      offerSdp = JSON.stringify(peerConnection.localDescription)\\n      // 发送 offer\\n      if (offerSdp) {\\n        socket.emit('offer', {\\n          userId,\\n          roomId: roomId.value,\\n          sdp: offerSdp,\\n        })\\n      }\\n    }\\n  }\\n  const offer = await peerConnection.createOffer()\\n  await peerConnection.setLocalDescription(offer)\\n}\\n```\\n\\n其中的 `onicecandidate` 事件，是用来监听 ICE 服务器返回的候选地址，当 ICE 服务器返回一个新的候选地址时，就会触发该事件，这里我们通过 `socket.emit` 将这个候选地址发送给信令服务。\\n\\n当你在后期连接成功的时候，其实可以把 候选人信息(candidate) 打印出来可以看看，当两个设备在同一个内网中连接的时候， candidate 的地址为一个 ipv6 长格式的内网地址和一个 ipv4 的内网地址。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c348e5cf89d4c99accc6ad48f17c5bd~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n当两个设备不在同一个内网中连接的时候，可以看到 candidate 的地址最后为一个 ipv4 的外网地址,说明它尝试了两次连接，第一次是内网连接，第二次是外网连接。证明了前面说的三种类型的先后连接方式。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/665360ce135545cba442b6d99bac944a~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n### 信令服务端接收提案\\n\\n接下来我们需要在服务端接收到客户端发送的提案后，将这个提案转发给远端的客户端。\\n\\n```typescript\\n// 接收 offer\\nsocket.on('offer', (data) => {\\n  // console.log('offer', data)\\n  socket.to(data.roomId).emit('offer', data)\\n})\\n```\\n\\n### 客户端接收远程的提案\\n\\n接下来我们需要在客户端接收到远程的提案后，将这个提案设置成 RemoteDescription。然后创建应答，将应答设置成本地描述，在候选人信息改变时，将应答发送给服务端。\\n\\n```typescript\\n// 创建 answer\\nasync function createAnswer(val: string) {\\n  const offer = JSON.parse(val)\\n  peerConnection.onicecandidate = async (event) => {\\n    // 当一个新的 answer ICE candidate 被创建时\\n    if (event.candidate) {\\n      socket.emit('answer', {\\n        userId,\\n        roomId: roomId.value,\\n        sdp: JSON.stringify(peerConnection.localDescription),\\n      })\\n    }\\n  }\\n  await peerConnection.setRemoteDescription(offer)\\n  const answer = await peerConnection.createAnswer()\\n  await peerConnection.setLocalDescription(answer)\\n}\\n```\\n\\n### 客户端创建 answer 的逻辑\\n\\n作为接收方，在拿到 offer 后，我们就可以创建 answer 并设置到本地描述中，然后通过信令服务器发送 answer 给对端。\\n\\n```typescript\\nconst createAnswer = async () => {\\n  // 解析字符串\\n  const offer = JSON.parse(offerSdp)\\n  pc.onicecandidate = async (event) => {\\n    // Event that fires off when a new answer ICE candidate is created\\n    if (event.candidate) {\\n      answerSdp = JSON.stringify(pc.localDescription)\\n    }\\n  }\\n  await pc.setRemoteDescription(offer)\\n  const answer = await pc.createAnswer()\\n  await pc.setLocalDescription(answer)\\n}\\n```\\n\\n### 客户端最后再添加 answer 的逻辑\\n\\n作为发起方，接下来我们需要在客户端接收到 接收方的应答后，将这个应答设置成 RemoteDescription。这样，一个最简单的 WebRTC 通信流程就完成了。\\n\\n```typescript\\n// 添加 answer(应答)\\nconst addAnswer = async () => {\\n  const answer = JSON.parse(answerSdp)\\n  if (!pc.currentRemoteDescription) {\\n    pc.setRemoteDescription(answer)\\n  }\\n}\\n```\\n\\n### 离开房间\\n\\n```typescript\\n// 离开房间\\nfunction handleLeave() {\\n  // 关闭对等连接\\n  peerConnection.close()\\n  // 发送离开的消息\\n  socket.emit('leave', { userId, roomId: roomId.value })\\n  // 关闭socket连接\\n  socket.disconnect()\\n}\\n```\\n\\n这样我们大体的 WebRTC 通信流程就完成了，下面我们就把它部署到服务器上。\\n\\n## 部署信令服务\\n\\n我们可以用 `Docker` 配合 `Nginx` 来部署你的服务，这里不做重点讲，我们主要通过 `pm2` 来帮忙部署这个服务，让我们可以快捷的测试看看， `pm2` 是一个带有负载均衡功能的 Node 应用的进程管理器，可以让你的 `Node` 应用始终保持在线，同时提供了一些其他的功能，比如日志记录、进程监控、进程守护等。\\n\\n### 安装 pm2\\n\\n```sh\\n# 安装 pm2\\nnpm install pm2 -g\\n```\\n\\n### 启动服务\\n\\n```bash\\n# 启动\\npm2 start index.js\\n# 查看\\npm2 list\\n# 停止\\npm2 stop index.js\\n# 重启\\npm2 restart index.js\\n# 删除\\npm2 delete index.js\\n```\\n\\n### 开机自启动\\n\\n```bash\\n# 生成开机启动脚本\\npm2 startup\\n# 保存当前进程列表\\npm2 save\\n```\\n\\n## 最后\\n\\n[👉🏻 1.本文示例在线体验地址](https://frontend-park.vercel.app/audio-and-video/webRTC/signaling-p2p)  \\n[👉🏻 2.本文客户端源代码地址](https://github.com/wangrongding/frontend-park)  \\n[👉🏻 3.本文服务端源代码地址](https://github.com/wangrongding/node-park/blob/main/src/signaling/signaling-http-server.js)\\n\\n你可以开两个浏览器 tab 或者用不同的设备，输入房间号进去体验下。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/60f0dfd24e8d4d2aa06ddb4497966d22~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n本篇文章主要是通过信令服务队上一篇文章的进阶处理，实现了自动连接的音视频通话。大家如果有什么问题，可以在评论区留言，我会及时回复。\\n\\n所有的文章都在 [👉🏻 这个专栏中](https://juejin.cn/column/7139951010042085407) ，如果您喜欢这个专栏的文章，或者对您有一些帮助，可以点赞鼓励，我会继续产出更好的文章给大家 ~ 谢谢🥰\\n",
        "tags": [
            "前端",
            "JavaScript",
            "WebRTC"
        ]
    },
    {
        "article_id": "7158009281735262239",
        "cover_image": "",
        "title": "为什么说 bind 的实现非常考验对原型链的理解？",
        "brief": "bind 的实现其实非常考验对原型链的理解。bind 和 apply，call 是 JS 修改 this 指向的三把利器 🔱。但看似简单的内容，实则包含了 JS 的两大核心内容：原型链和构造函数。",
        "user_name": "圆圆01",
        "view_count": 11327,
        "collect_count": 323,
        "comment_count": 28,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/320f144367404cb3aabb8790dbc007cb~300x300.image",
        "category": "前端",
        "content": "# 前言\\n**bind 的实现其实非常考验对原型链的理解。**\\n\\nbind 和 apply，call 是 JS 修改 this 指向的三把利器 🔱。\\n\\n对于 apply，call 来说，bind 的区别在于会返回一个修改了 this 指向的新函数，并不会立即执行。\\n\\n但看似简单的内容，实则包含了 JS 的两大核心内容：原型链和构造函数 (new) 。\\n\\n这篇文章分为两部分：\\n- 一部分讲如何实现一个基础版本的 bind 方法，带大家做好热身运动；\\n- 另一部分进入主题，详细讲解如何通过原型链来实现一个让人眼前一亮的 bind 方法 ✨。\\n\\n# 一、实现 bind 方法\\n\\n## 1. 改变 this 指向\\n\\n简单说，bind 方法会返回一个改变了 this 指向的新方法。\\n\\n举个 🌰：\\n\\n```js\\nvar name = 'Jack';\\nvar Yve = {\\n    name: 'Yvette'\\n};\\nfunction person() {\\n    console.log(this.name);\\n}\\nperson(); // Jack\\nvar bindYve = person.bind(Yve);\\nbindYve(); // Yvette\\n```\\n根据这个特点，我们来实现第一版的 bind 方法：\\n\\n```js\\n\\n// v1.0：返回一个改变了 this 指向的方法\\n\\nFunction.prototype.bind2 = function (context) {\\n    // 首先要获取调用bind的函数，也就是绑定函数，用this可以获取\\n    var self = this; // 用self绑定this，因为下面函数中的this指向已经改变（存放当前函数的this）\\n    return function () {\\n        // 用apply来改变this指向（apply的实现并不复杂，文末放有链接可以查看）\\n        self.apply(context);\\n    }\\n}\\n```\\n\\n## 2. 函数柯里化\\nbind 方法的另一个特点是支持柯里化：函数的参数可以分多次传入，即可以在 bind 中传入一部分参数，在执行返回的函数的时候，再传入另一部分参数。\\n\\n举个 🌰：\\n\\n```js\\nvar name = 'Jack';\\nvar Yve = {\\n    name: 'Yvette'\\n};\\nfunction person(age, job, gender) {\\n    console.log(this.name, age, job, gender);\\n}\\nperson(22, 'engineer', 'female');\\n// Jack 22 engineer female\\nvar bindYve = person.bind(Yve, 22, 'engineer');\\nbindYve('female');\\n// Yvette 22 engineer female\\n```\\n\\n根据这个特点，我们来实现第二版的 bind 方法：\\n```js\\n\\n// v2.0：支持函数柯里化，分段接收参数\\n\\nFunction.prototype.bind2 = function (context) {\\n    // 首先要获取调用bind的函数，也就是绑定函数，用this可以获取\\n    var self = this; // 用self绑定this，因为下面函数中的this指向已经改变（存放当前函数的this）\\n    var args = [...arguments].slice(1); // 用slice方法取第二个到最后一个参数（获取除了this指向对象以外的参数）\\n    return function () {\\n        // 这里的arguments是指bind返回的函数传入的参数\\n        var restArgs = [...arguments];\\n        // 用apply来改变this指向，拼接bind方法传入的参数和bind方法返回的函数传入的参数，统一在最后通过apply执行。\\n        self.apply(context, args.concat(restArgs));\\n    }\\n}\\n```\\n## 3. 返回值\\n\\n别忘啦，函数是可以有返回值的，举个 🌰：\\n\\n\\n```js\\nvar name = 'Jack';\\nvar Yve = {\\n    name: 'Yvette'\\n};\\nfunction person(age, job, gender) {\\n    return {\\n        name: this.name,\\n        age,\\n        job,\\n        gender\\n    }\\n}\\nvar jack = person(22, 'engineer', 'female');\\nconsole.log(jack);\\n// {name: 'Jack', age: 22, job: 'engineer', gender: 'female'}\\nvar bindYve = person.bind(Yve, 22, 'engineer');\\nvar Yvette = bindYve('female');\\nconsole.log(Yvette);\\n// {name: 'Yvette', age: 22, job: 'engineer', gender: 'female'}\\n\\nvar bindYve2 = person.bind2(Yve, 22, 'engineer');\\nvar Yvette2 = bindYve2('female');\\nconsole.log(Yvette2);\\n// undefined\\n```\\n\\n而我们实现的 bind 方法在返回的函数中并没有把结果返回，所以得到的结果是 undefined，而不是返回值。\\n\\n这个比较简单，补充一下：\\n\\n```js\\n\\n// v2.1：拿到返回值\\n\\nFunction.prototype.bind2 = function (context) {\\n    var self = this;\\n    var args = [...arguments].slice(1);\\n    return function () {\\n        var restArgs = [...arguments];\\n        // 返回执行结果\\n        return self.apply(context, args.concat(restArgs));\\n    }\\n}\\n```\\n\\n做完前面这些热身运动，下面我们进入今天的主题 🎃\\n\\n# 二、使用原型链完整构建 bind 方法\\n\\n## 1. 作为构造函数调用\\n\\nbind 方法还有一个重要的的特点，绑定函数也可以使用 new 运算符构造，也就是说还可以将 bind 返回的函数作为构造函数。提供的 this 值会被忽略，但传入的参数仍然生效。\\n\\n举个 🌰：\\n\\n```js\\nvar name = 'Jack';\\nvar Yve = {\\n    name: 'Yvette'\\n};\\nfunction person(age, job, gender) {\\n    console.log(this.name, age, job, gender);\\n}\\nvar bindYve = person.bind(Yve, 22, 'engineer');\\nvar obj = new bindYve('female');\\n// undefined 22 'engineer' 'female'\\n```\\n\\n我们在全局和 Yve 中都声明了 name 值，但最后 `this.name` 的结果依然是 undefind，说明 bind 方法绑定的 this 失效了，原因在于返回函数 bindYve 被作为构造函数调用了，了解 new 关键字原理的童鞋就会知道，此时的 this 已经指向了实例 obj。\\n\\n> 这一块和 new 的模拟实现结合在一起理解，更容易掌握两者的原理，做到融会贯通。关于 new 的原理可以参考：[JavaScript 深入系列之 new 操作符的模拟实现](https://github.com/yuanyuanbyte/Blog/issues/110)。\\n\\n我们知道了作为构造函数调用时，this 指向实例，原先通过 bind 绑定的 this 失效。很显然前面实现的 bind 始终会通过 `self.apply(context)` 将 this 指向 context，不符合这一特点。\\n\\n所以，在返回函数作为构造函数调用时，就不用修改 this 指向了，直接 `self.apply(this)`即可。*因为作为构造函数调用时，this 就是指向实例，所以这里不需要做其他操作。*\\n\\n结论有了，那如何知道返回函数是被作为构造函数调用的呢？\\n\\n**我们可以用 instanceof 来判断返回函数的原型是否在实例的原型链上。**\\n\\n举个 🌰 大家就明白啦：\\n\\n```js\\nvar func = function (){\\n    console.log(this instanceof func);\\n} \\n\\n// 作为普通函数调用\\nfunc(); \\n// false\\n\\n// 作为构造函数调用\\nnew func(); \\n// true\\n```\\n\\n不同的调用方法，函数的 this 指向不同，利用这个特点即可得知返回函数是否作为构造函数调用：\\n- 作为普通函数调用时，this 指向 window，结果为 false；\\n- 作为构造函数调用时，this 指向实例，实例的 `__proto__` 属性指向构造函数的 prototype，结果为 true。\\n\\n了解这个原理后，实现就简单了：\\n\\n```js\\n\\n// v3.0：实现作为构造函数调用时this指向失效的效果\\n\\nFunction.prototype.bind2 = function (context) {\\n    var self = this;\\n    var args = [...arguments].slice(1);\\n\\n    var fBound = function () {\\n        var restArgs = [...arguments];\\n        // 作为普通函数调用时，this 指向 window，结果为 false；\\n        // 作为构造函数调用时，this 指向实例，实例的 `__proto__` 属性指向构造函数的 prototype，结果为 true\\n        return self.apply(this instanceof fBound ? this : context, args.concat(restArgs));\\n    }\\n    return fBound;\\n}\\n```\\n\\n> 这里其实考察了原型链的知识，关于原型链的内容可以参考：[JavaScript 深入系列之从原型到原型链](https://github.com/yuanyuanbyte/Blog/issues/89)。\\n\\n\\n## 2. 继承函数的原型\\n作为构造函数调用时，实例还会继承函数的原型。\\n\\n举个 🌰：\\n\\n```js\\nvar name = 'Jack';\\nvar Yve = {\\n    name: 'Yvette'\\n};\\nfunction person(age, job, gender) {\\n    this.work = '福报'; // 实例属性\\n    console.log(this.name, age, job, gender);\\n}\\nperson.prototype.clockIn = function () {\\n    console.log(996);\\n}\\nvar bindYve = person.bind(Yve, 22, 'engineer');\\nvar obj = new bindYve('female');\\nobj.work; // 福报\\nobj.clockIn(); // 996\\n```\\n\\n但上一版的实现中并没有做到原型的继承：\\n\\n```js\\n...\\nvar bindYve2 = person.bind2(Yve, 22, 'engineer');\\nvar obj2 = new bindYve2('female');\\nobj2.work; // 福报\\nobj2.clockIn() // obj2.clockIn is not a function\\n```\\n\\n这个问题怎么解决呢？\\n\\n**我们可以修改返回函数的原型，使返回函数的原型指向绑定函数的原型（这样实例就可以继承函数的原型），然后在返回函数中用 instanceof 来判断绑定函数的原型是否在实例的原型链上。** 因为实例的构造函数是返回函数，而返回函数的原型又指向了绑定函数的原型，所以绑定函数的原型肯定在实例的原型链上 **（我画了一个图，来帮大家理解这段内容 🙋‍♀️）**。\\n\\n先看如何用代码来实现：\\n\\n```js\\n\\n// v4.0：继承函数的原型\\n\\nFunction.prototype.bind2 = function (context) {\\n    var self = this;\\n    var args = [...arguments].slice(1);\\n\\n    var fBound = function () {\\n        var restArgs = [...arguments];\\n        /**\\n         * 用 instanceof 来判断绑定函数 self 的原型是否在实例的原型链上：\\n         * 1. 使用 new 运算符作为构造函数调用时，this 指向实例\\n         *    因为我们在下面通过`fBound.prototype = this.prototype;`修改了 fBound 的原型为绑定函数的原型，所以此时结果为 true，this 指向实例。\\n         * 2. 正常作为普通函数调用时，this 指向 window，此时结果为 false，this 指向绑定的 context；\\n         */\\n        return self.apply(this instanceof self ? this : context, args.concat(restArgs));\\n    }\\n    // 修改返回函数的 prototype 为绑定函数的 prototype，实例就可以继承函数的原型中的值\\n    fBound.prototype = this.prototype;\\n    return fBound;\\n}\\n```\\n\\n结合前面的例子画了一张图来帮大家梳理一下：\\n\\n![img1.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f8d6378a06c14a4da2860acdbbbd47a2~tplv-k3u1fbpfcp-watermark.image?)\\n\\n从上图可以得知使用 new 运算符作为构造函数调用时，绑定函数 person 的原型在实例 obj 的原型链上。使用 `this instanceof self` 来检测绑定函数 self(例子中的 person 方法)的原型是否在实例 obj 的原型链上，就可以知道返回函数是否被作为构造函数调用了 👌。\\n\\n## 3. 维护原型关系\\n\\n到这里，我们已经实现了返回函数作为构造函数调用时的效果，大家也明白了这些方法的原理，很棒！但还不够完美 🙅‍♀️\\n\\n为什么？\\n\\n因为这样的实现存在一个问题，我们修改返回函数的原型为绑定函数的原型，再配合 instanceof 来判断返回函数是否作为构造函数调用，思路是合理的，但直接让返回函数的原型指向绑定函数的原型就太粗暴了 🥺\\n\\n```js\\nfBound.prototype = this.prototype;\\n```\\n\\n了解堆栈的童鞋就会知道，这样的写法其实只是做了一个**简单的对象引用**，即把返回函数的原型指向了绑定函数原型对象的引用，**我画了一个存储结构的示意图，帮大家理解一下 😉**：\\n\\n![截屏2022-10-27 00.41.10.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98da849702974a3e91e984c64d8a8553~tplv-k3u1fbpfcp-watermark.image?)\\n**两个原型指向同一个对象，任何的操作都会相互影响。**\\n\\n比如实例在原型上新增方法或者修改属性，绑定函数的原型也会跟着改变，举个 🌰：\\n\\n```js\\nvar name = 'Jack';\\nvar Yve = {\\n    name: 'Yvette'\\n};\\n\\nfunction person(age, job, gender) {\\n    console.log(this.name, age, job, gender);\\n}\\nvar bindYve = person.bind2(Yve, 22, 'enginner');\\nvar obj = new bindYve('female');\\n\\n// 实例在原型上新增一个方法\\nobj.__proto__.clickLike = function(){\\n    console.log('一键三连');\\n}\\nobj.clickLike(); // 一键三连\\n\\n// 绑定函数的原型也有了这个方法\\nperson.prototype.clickLike(); // 一键三连\\n```\\n\\n或者直接操作返回函数的原型，也是同样效果：\\n\\n```js\\n...\\nvar bindYve = person.bind2(Yve, 22, 'enginner');\\n\\n// 返回函数的原型新增一个方法\\nbindYve.prototype.clickLike = function(){\\n    console.log('下次一定');\\n}\\nbindYve.prototype.clickLike(); // 下次一定\\n\\n// 绑定函数的原型也有了这个方法\\nperson.prototype.clickLike(); // 下次一定\\n```\\n**解决这个问题我们可以用一个空函数作为中间变量，通过这个中间变量来维护原型关系，从而让 `fBound.prototype` 与 `person.prototype` 不再指向同一个原型对象。**\\n\\n来看代码实现（最终版本）：\\n\\n```js\\n\\n// v5.0：最终版本\\n\\nFunction.prototype.bind2 = function (context) {\\n    var self = this;\\n    var args = [...arguments].slice(1);\\n\\n    var fBound = function () {\\n        var restArgs = [...arguments];\\n        return self.apply(this instanceof self ? this : context, args.concat(restArgs));\\n    }\\n    // 用一个空函数 fn 作为中间变量\\n    var fn = function() {};\\n    // 使中间变量 fn 的 prototype 指向绑定函数的 prototype\\n    fn.prototype = this.prototype;\\n    // 再使返回函数的 prototype 指向 fn 的实例，通过中间变量 fn 来维护原型关系\\n    fBound.prototype = new fn();\\n    return fBound;\\n}\\n```\\n画了一张图帮大家梳理这段代码：\\n\\n![截屏2022-10-21 22.01.06.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20c5b6a9c7fb4accbdef28c4e209bc7a~tplv-k3u1fbpfcp-watermark.image?)\\n\\n从上图可以发现，中间变量 fn 的实例 维护了返回函数 fBound 和 绑定函数 person 的原型关系，使我们可以继续使用 instanceof 来判断返回函数是否作为构造函数调用；同时，也“隔离”了返回函数原型和绑定函数原型，返回函数的原型指向了 fn 的实例，所以再怎么操作返回函数的 prototype 或者返回函数实例的 `__proto__` 属性都碰不着绑定函数的 prototype，解决了 `fBound.prototype` 与 `person.prototype` 指向同一个原型对象的问题。\\n\\n到这里，我们已经知道了如何实现一个漂亮的 bind 方法，非常棒！\\n\\n![干杯.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f88bcc801e04bfab00a48ddca53cfd2~tplv-k3u1fbpfcp-watermark.image?)\\n\\n实现 bind 方法的内容已经讲完，但关于原型链的内容还有一些没有讲，我们把这些补上 🙆‍♀️\\n\\n前文讲到 fn 的实例“隔离”了返回函数原型和绑定函数原型，但其实这只是“半隔离”，我们还是可以通过 `fBound.prototype.__proto__` 或者 `obj.__proto__.__proto__` 来修改绑定函数的原型，这个情况大家需要了解。\\n\\n比如：\\n\\n\\n```js\\nvar name = 'Jack';\\nvar Yve = {\\n    name: 'Yvette'\\n};\\n\\nfunction person(age, job, gender) {\\n    console.log(this.name, age, job, gender);\\n}\\nvar bindYve = person.bind2(Yve, 22, 'enginner');\\nvar obj = new bindYve('female');\\n\\n// 实例原型新增一个方法\\nobj.__proto__.clickLike = function(){\\n    console.log('下次一定');\\n}\\nobj.clickLike(); \\n// 下次一定\\n\\n// 绑定函数的原型不再被影响\\nperson.prototype.clickLike(); \\n// person.prototype.clickLike is not a function\\n\\n// 但通过原型链依然可以修改绑定函数的原型\\nbindYve.prototype.__proto__.a = function(){console.log(11111)};\\nperson.prototype.a(); \\n// 11111\\nobj.__proto__.__proto__.b = function(){console.log(22222)};\\nperson.prototype.b(); \\n// 22222\\n```\\n\\n这也是 JavaScript 作为一种基于原型的语言的特点。\\n\\n另外，从前面的图中可以很清楚的发现 fn 的原型也在返回函数 fBound 的原型链上，所以也可以用 `this instanceof fn` 来判断返回函数是否作为构造函数调用。但相较而言，还是 `this instanceof self` 更加直观。\\n\\n到此，关于原型链的一些内容也讲完啦，希望对大家有所帮助 😊\\n\\n![比心.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fde559e5d4e0474bb9b78015d3aa8818~tplv-k3u1fbpfcp-watermark.image?)\\n\\n# 三、结尾\\n如果这篇文章对你的学习有所帮助，欢迎点赞 👍 收藏 ⭐ 留言 📝 ，**你的支持是我创作分享的动力！**\\n\\n更多内容，可以查看 [圆圆的 blog](https://github.com/yuanyuanbyte/Blog) 💦\\n",
        "tags": [
            "前端",
            "JavaScript",
            "面试"
        ]
    },
    {
        "article_id": "7186194619318108219",
        "cover_image": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/15fd050207eb4d00ad0de8569d559642~tplv-k3u1fbpfcp-watermark.image?",
        "title": "前端面试知识体系（一）",
        "brief": "前端面试知识体系（一）1024bibi.com # 如何实现网页多标签tab通讯 使用 WebSocket 1. 无跨域限制 2. 需要服务端支持，成本高 通过 localStorage 通讯",
        "user_name": "我是哪吒",
        "view_count": 1592,
        "collect_count": 27,
        "comment_count": 0,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/5596f94458b88fabc66a4cd9a0395288~300x300.image",
        "category": "前端",
        "content": "我的博客来源：https://1024bibi.com/2018/01/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%EF%BC%88%E4%B8%80%EF%BC%89/\\n\\n# 防抖和节流有什么区别，分别用于什么场景\\n\\n- 节流：限制执行频率，有节奏的执行；\\n- 防抖：限制执行次数，多次密集的触发只执行一次；\\n\\n## 防抖 debounce\\n\\n```js\\nfunction debounce(fn, delay = 200) {\\n\\tlet timer = 0\\n\\t\\n\\treturn function () {\\n\\t\\tif (timer) clearTimeout(timer);\\n\\t\\t\\n\\t\\ttimer = setTimeout(() => {\\n\\t\\t\\tfn.apply(this, arguments); // 透传 this 和参数\\n\\t\\t\\ttimer = 0\\n\\t\\t}, delay)\\n\\t}\\n}\\n```\\n\\n```js\\nconst input = document.getElementById('input')\\ninput.addEventListener('keyup', debounce(() => {\\n\\tconsole.log('发起搜索', input.value)\\n}), 300)\\n```\\n\\n## 节流 throttle \\n\\n例如：drag或scroll期间触发某个回调，要设置一个时间间隔\\n\\n# px % em rem vw/vh 有什么区别\\n\\n## px 和 %\\n\\n- px基本单位，绝对单位（固定的），其他的都是相对单位\\n- % 相对于父元素的宽度比例\\n- 元素内的垂直居中\\n\\n```js\\n<style>\\n #container {\\n  width: 200px;\\n  height: 200px;\\n  position: relative;\\n  background-color: #ccc;\\n }\\n #box {\\n  width: 100px;\\n  height: 100px;\\n  position: absolute;\\n  left: 50%;\\n  top: 50%;\\n  margin-top: -50px;\\n  margin-left: -50px;\\n  background-color: blue;\\n }\\n</style>\\n<div id=\\\"container\\\">\\n <div id=\\\"box\\\"></div>\\n</div>\\n```\\n\\n## em 和 rem\\n\\n- em 相对于当前元素的 font-size\\n- rem 相对于根节点的 font-size\\n\\n```js\\n<div style=\\\"font-size: 20px;\\\">\\n <p style=\\\"text-indent: 2em; font-size: 40px;\\\">首行缩进</p> // font-size: 40px; text-indent: 80px;\\n <p style=\\\"text-indent: 2em;\\\">哪吒, 算法猫叔</p> // font-size: 20px; text-indent: 40px;\\n</div>\\n```\\n\\n```js\\n<style>\\n @media only screen and (max-width: 374px) {\\n  // iphone5 或者更小的尺寸，以 iphone5 的宽度（320px）比例设置 font-size\\n  html {\\n   font-size: 86px;\\n  }\\n }\\n @media only screen and (min-width: 375px) and (max-width: 413px) {\\n  // iphone6/7/8 和 iphone x\\n  html {\\n   font-size: 100px;\\n  }\\n }\\n @media only screen and (min-width: 414px) {\\n  // iphone6p 或者更大的尺寸，以 iphone6p 的宽度(414px)比例设置 font-size\\n  html {\\n   font-size: 110px;\\n  }\\n }\\n p {\\n  font-size: .16rem;\\n }\\n</style>\\n```\\n\\n## vw / vh\\n\\n- vw 屏幕宽度的 1%\\n- vh 屏幕高度的 1%\\n- vmin 两者的最小值，vmax 两者的最大值\\n\\n```js\\n<div id=\\\"div1\\\"> div1 </div>\\n<div id=\\\"div2\\\"> div2 </div>\\n<div id=\\\"div3\\\"> div3 </div>\\n<style>\\n div {\\n  border: 1px solid #ccc;\\n  margin-top: 20px;\\n }\\n #div1 {\\n  width: 10vw;\\n  height: 10vh;\\n }\\n #div2 {\\n  width: 10vmax;\\n  height: 10vmax;\\n }\\n #div3 {\\n  width: 10vmin;\\n  height: 10vmin;\\n }\\n</style>\\n```\\n\\n# 什么时候不能使用箭头函数\\n\\n## 箭头函数有什么缺点？\\n\\n- 没有 arguments\\n- 无法通过 apply call bind 改变 this\\n- 某些箭头函数代码难以阅读\\n\\n## 什么时候不能使用箭头函数？\\n\\n- 不适用-对象方法\\n\\n```js\\nconst obj = {\\n name: '哪吒，B站，算法猫叔',\\n getName: () => {\\n  return this.name\\n }\\n}\\nconsole.log(obj.getName())\\n```\\n\\n- 不适用-原型方法\\n\\n```js\\nconst obj = {\\n name: '哪吒，B站，算法猫叔'\\n}\\nobj.__proto__.getName = () => {\\n return this.name\\n}\\nconsole.log( obj.getName() )\\n```\\n\\n- 不适用-构造函数\\n\\n```js\\nconst Foo = (name, age) => {\\n this.name = name\\n this.age = age\\n}\\nconst f = new Foo('张三', 20)\\n// 报错 Foo is not a constructor\\n```\\n\\n- 不适用-动态上下文中的回调函数\\n\\n```js\\nconst btn1 = document.getElementById('btn1')\\nbtn1.addEventListener('click', () => {\\n // console.log(this === window)\\n this.innerHTMl = 'clicked'\\n})\\n```\\n\\n- 不适用-Vue生命周期和method : vue组件本质上一个 JS 对象\\n- React 组件（非Hooks）本质上是一个 es6 class，class里面适用箭头函数没问题\\n\\n```js\\n{\\n data() { return { name:  '哪吒，B站：算法猫叔' } },\\n methods: {\\n  getName: () => {\\n   // 报错 Cannot read properties of undefined (reading 'name')\\n  return this.name\\n  },\\n  // getName() {\\n  //  return this.name // 正常\\n  // }\\n },\\n mounted: () => {\\n  // 报错\\n },\\n // mounted() {\\n //  正常\\n // }\\n}\\n```\\n\\n# JS中for-in和for-of有什么区别\\n\\nfor of 去遍历可以generator\\n\\n```js\\nconst arr = [10, 20, 30]\\nfor (let val of arr) {\\n console.log(val); // 值\\n}\\n\\nconst str = 'abc'\\nfor (let c of str) {\\n console.log(c);\\n}\\n\\nfunction fn() {\\n for (let arg of arguments) {\\n  console.log(arg)\\n }\\n}\\nfn(100, 200, 'aaa')\\n\\nconst pList  = document.getElementsByTagName('p')\\n// querySelectorAll('p')\\nfor (let p of pList) {\\n console.log(p)\\n}\\n```\\n\\n- 遍历对象： for ... in 可以，for ... of 不可以\\n- 遍历Map Set：for...of 可以，for...in 不可以\\n- 遍历generator：for...of 可以，for ... in 不可以\\n\\n```js\\n对象，数组，字符串可枚举的，就可以使用for ... in 循环\\nconst obj1 = { x: 100 }\\nObject.getOwnPropertyDescriptors(obj1)\\nx:\\nconfigurable: true\\nenumerable: true\\nvalue: 100\\nwriteable: true\\n```\\n\\n- 可枚举 vs 可迭代\\n\\nfor ... in 用于可枚举数据，如对象，数组，字符串，得到key\\n\\nfor ... of 用于可迭代数据，如数组，字符串，Map，Set，得到value\\n\\n# for-await-of有什么作用\\n\\nfor await...of 用于遍历多个Promise\\n\\n```js\\nfunction createPromise(val) {\\n return new Promise((resolve) => {\\n  setTimeout(() => {\\n   resolve(val)\\n  }, 1000)\\n })\\n}\\n\\n(async function () {\\n const p1 = createPromise(100)\\n const p2 = createPromise(200)\\n const p3 = createPromise(300)\\n // const res1 = await p1\\n // console.log(res1)\\n // const res2 = await p2\\n // console.log(res2)\\n // const res3 = await p3\\n // console.log(res3)\\n const list = [p1, p2, p3]\\n // Promise.all(list).then(res => console.log(res))\\n\\n for await (let res of list) {\\n  console.log(res)\\n }\\n})()\\n```\\n\\n# offsetHeight - scrollHeight - clientHeight区别\\n\\n盒子模型: width, height, padding, border, margin, box-sizing\\n\\noffsetHeight offsetWidth : border + padding + content\\n\\nclientHeight clientWidth: padding + content\\n\\nscrollHeight scrollWidth: padding + 实际内容尺寸\\n\\n# HTMLCollection和NodeList有什么区\\n\\n- DOM是一颗树，所有节点都是Node\\n- Node是Element的基类\\n- Element是其他HTML元素的基类，如HTMLDivElement\\n\\n```js\\nconst p1 = document.getElementById('p1')\\nclass Node {}\\n\\n// document\\nclass Document extends Node {}\\nclass DocumentFragment extends Node {}\\n\\n// 文本和注释\\nclass CharacterData extends Node {}\\nclass Comment extends CharacterData {}\\nclass Text extends CharacterData {}\\n\\n// elem\\nclass Element extends Node {}\\nclass HTMLElement extends Element {}\\nclass HTMLDivElement extends HTMLElement {}\\nclass HTMLInputElement extends HTMLElement {}\\n```\\n\\n- HTMLCollection 是 Element 的集合\\n- NodeList 是 Node 集合\\n\\n```js\\n<p id=\\\"p1\\\">\\n <b>node</b> vs <em>element</em>\\n</p>\\n\\n<script>\\n const p1 = document.getElementById('p1')\\n console.log(p1.children)\\n \\n console.log(p1.childNodes)\\n // [b,text,em,comment]\\n</script>\\n```\\n\\n划重点：\\n\\n- 获取 Node 和 Element 的返回结果可能不一样\\n- 如 elem.childNodes 和 elem.children 不一样\\n- 前者包含Text和Comment节点，后者不会\\n\\n类数组 变成 数组\\n\\n```js\\nconst arr1 = Array.from(list)\\nconst arr2 = Array.prototype.slice.call(list)\\nconst arr3 = [...list]\\n```\\n\\n# Vue中computed和watch有什么区别\\n\\n- computed 用于计算产生新的数据\\n- watch 用于监听现有数据\\n\\n```js\\nwatch: {\\n name(newValue, oldValue) {\\n  console.log('watch name', newValue, oldValue)\\n }\\n},\\ncomputed: {\\n userInfo() {\\n  return this.name + this.city\\n }\\n}\\n```\\n\\ncomputed有缓存 watch没有缓存\\n\\n# Vue组件通讯有几种方式\\n\\n```js\\nprops和$emit\\n\\n$parent\\n\\n自定义事件\\n\\n$refs\\n\\n$attr\\n\\nprovide/inject\\n\\nvuex\\n\\n---\\n\\n$attrs $listeners\\n\\nvue3 移除 $listeners\\n\\n上一级没有接收到的\\n\\nprops: ['x'], // $attrs\\n\\nemits: ['getX'], // $listeners\\n\\nObject.keys(this.$attrs)\\n\\n<l3 v-bind=\\\"$attrs\\\"></l3>\\n\\ndom结点: inheritAttrs: false\\n\\n---\\n\\nthis.$parent\\nthis.$refs\\n\\nprovide: {\\n info: 'aaa'\\n}\\n\\nprovide() {\\n return {\\n  info: computed(() => this.name)\\n }\\n}\\n\\n---\\n\\n父子组件\\n\\n上下级组件（跨多级）通讯\\n\\n全局组件\\n```\\n\\n# Vuex中action和mutation有什么区别\\n\\nmutation: 原子操作，必须同步代码\\n\\naction: 可包含多个mutation；可包含异步代码\\n\\n# JS严格模式有什么特点\\n\\n```js\\n'use strict' // 全局开启\\n\\nfunction fn() {\\n 'use strict' // 某个函数开启\\n}\\n```\\n\\n- 全局变量必须先声明\\n- 禁止使用 with\\n- 创建eval作用域\\n- 禁止this指向window\\n- 函数参数不能重名\\n\\n# JS内存垃圾回收用什么算法\\n\\n垃圾回收 GC\\n\\n```js\\n什么是垃圾回收？\\n\\nfunction fn1() {\\n const a = 'aa'\\n console.log(a)\\n \\n const obj = { x: 100 }\\n console.log(obj)\\n}\\nfn1()\\n```\\n\\n```js\\nfunction fn2() {\\n const obj = { x: 100 }\\n window.obj = obj\\n}\\nfn2()\\n\\n\\nfunction getDataFns() {\\n const data = {} // 闭包\\n return {\\n  get(key) {\\n   return data[key]\\n  },\\n  set(key, value) {\\n   data[key] = value\\n  }\\n }\\n}\\nconst { get, set } = getDataFns()\\nset('x', 100)\\nget('x')\\n```\\n\\n```js\\n引用计数(之前）\\n\\n// 对象被 a 引用\\nlet a = { x: 100 }\\nlet a1 = a\\na = 10\\na1 = null\\n\\n// 循环引用\\nfunction fn3() {\\n const obj1 = {}\\n const obj2 = {}\\n obj1.a = obj2\\n obj2.a = obj1\\n}\\nfn3()\\n\\n// ie6-7 内存泄漏的 bug\\nvar div1 = document.getElementById('div1')\\ndiv1.a = div1\\ndiv1.someBigData = {}\\n\\n标记清除（现代）\\n// JS 根 window\\n```\\n\\n# JS闭包是内存泄漏吗\\n\\n闭包的数据是不可以被垃圾回收的\\n\\n# 如何检测JS内存泄漏\\n\\n检测内存变化\\n\\n```js\\nconst arr = []\\nfor (let i = 0; i < 10 * 10000; i++) {\\n arr.push(i)\\n}\\n\\nfunction bind() {\\n // 模拟一个比较大的数据\\n const obj = {\\n  str: JSON.stringify(arr) // 简单的拷贝\\n }\\n window.addEventListener('resize', () => {\\n  console.log(obj)\\n })\\n}\\n\\nlet n = 0\\nfunction start() {\\n setTimeout(() => {\\n  bind()\\n  n++\\n  \\n  // 执行 50 次\\n  if (n < 50) {\\n   start()\\n  } else {\\n   alert('done')\\n  }\\n }, 200)\\n}\\n\\ndocument.getElementById('btn1').addEventListener('click', () => {\\n start()\\n})\\n```\\n\\n# JS内存泄漏的场景有哪些\\n\\n1. 被全局变量，函数引用，组件销毁时未清除\\n2. 被全局事件，定时器引用，组件销毁时未清除\\n3. 被自定义事件引用，组件销毁时未清除\\n\\n# JS内存泄漏的场景有哪些-扩展-WeakMap和Weak\\n\\n```js\\n// 标记清除算法\\nconst data = {}\\nfunction fn1() {\\n const obj = { x: 100 }\\n data.obj = obj\\n}\\nfn1()\\n```\\n\\n```js\\nconst map = new Map()\\nfunction fn1() {\\n const obj = { x: 100 }\\n map.set('a', obj)\\n}\\nfn1()\\n```\\n\\n```js\\n// WeakMap WeakSet 弱引用\\n<script>\\n const wMap = new WeakMap(); // 弱引用\\n function fn1() {\\n  const obj = { x: 100 }\\n  wMap.set(obj, 100) // WeakMap的key，只能是引用类型\\n }\\n fn1()\\n // WeakSet\\n</script>\\n```\\n\\n# Ajax-Fetch-Axios三者有什么区别\\n\\n1. Ajax(Asynchronous Javascript and XML)，一种技术统称\\n2. Fetch，一个具体的原生API\\n\\t浏览器原生API，用于网络请求\\n\\t和XMLHttpRequest一个级别\\n\\tFetch语法更加简洁，易用，支持Promise\\n3. Axios，是一个第三方库\\n\\t最常用的网络请求lib\\n\\t内部可用XMLHttpRequest和Fetch来实现\\n4. lib（库）和API（原生的函数）的区别\\n5. fetch 和 XMLHttpRequest 全局的API\\n\\n# 用XMLHttpRequest实现Ajax\\n\\n```js\\nfunction ajax1(url, sucessFn) {\\n const xhr = new XMLHttpRequest();\\n xhr.open(\\\"GET\\\", url, false);\\n xhr.onreadystatechange = function () {\\n  // 这里的函数异步执行\\n  if (xhr.readyState == 4) {\\n   if (xhr.status == 200) {\\n    successFn(xhr.responseText);\\n   }\\n  }\\n }\\n xhr.send(null);\\n}\\n\\nfunction ajax2(url) {\\n return fetch(url).then(res => res.json());\\n}\\n```\\n\\n# 请描述TPC三次握手和四次挥手\\n\\n## 建立TCP连接\\n\\n1. 先建立连接（确保双方都有收发消息的能力）\\n2. 再传输内容（如发送给一个get请求）\\n3. 网络连接是TCP协议，传输内容是HTTP协议\\n4. SYN\\n\\tSYN+ACK\\n\\tACK\\n\\n## 四次挥手-关闭连接\\n\\n```js\\n1. FIN ->\\n2. ACK <-\\n3. FIN <-\\n4. ACK ->\\n```\\n\\n# HTTP跨域时为何要发送options请求\\n\\n## 跨域请求\\n\\n1. 浏览器同源策略\\n2. 同源策略一般限制Ajax网络请求，不能跨域请求server\\n3. 不会限制`<link> <img> <script> <iframe>`加载第三方资源\\n\\n## JSONP\\n\\n```js\\n// www.aaa.com网页\\n<script>\\n window.onSuccess = function(data) {\\n  console.log(data)\\n }\\n</script>\\n<script src=\\\"https://www.bbb.com/api/getData\\\"></script>\\n\\n// https://www.bbb.com... 返回了一段字符串\\n'onSuccess({ errno: 0, data: {} })'\\n```\\n\\n```js\\n// CORS 配置允许跨域（服务端）\\nresponse.setHeader(\\\"Access-Control-Allow-Origin\\\", \\\"http://localhost:8011\\\") // 或者\\\"*\\\"\\nresponse.setHeader(\\\"Access-Control-Allow-Headers\\\", \\\"X-Requested-With\\\")\\nresponse.setHeader(\\\"Access-Control-Allow-Methods\\\", \\\"PUT,POST,GET,DELETE,OPTIONS\\\")\\nresponse.setHeader(\\\"Access-Control-Allow-Credentials\\\", \\\"true\\\") // 允许跨域接收 cookie\\n```\\n\\noptions请求，是跨域请求之前的预检查；浏览器自行发起的，无需我们干预，不会影响实际的功能\\n\\n# 浏览器和nodejs事件循环（EventLoop）有什么\\n\\n## 单线程和异步\\n\\n1. JS是单线程的（无论在浏览器还是nodejs）\\n2. 浏览器中JS执行和DOM渲染共用一个线程\\n3. 异步\\n\\t宏任务 和 微任务\\n\\t\\t宏任务，如 setTimeout setInterval 网络请求\\n\\t\\t微任务，如 promise async / await\\n\\t\\t微任务在下一轮DOM渲染之前执行，宏任务在之后执行\\n\\t\\t微任务： MutationObserver 监听DOM树的变化，Mutation observer 是用于代替 Mutation  events 作为观察DOM树结构发生变化时，做出相应处理的API\\n\\t\\tMutationObserver接口提供了监视对DOM树所做更改的能力。它被设计为旧的Mutation Events功能的替代品，该功能是DOM3 Events规范的一部分。\\n\\t\\t\\n```js\\nconst p = document.createElement('p')\\np.innerHTML = 'new paragraph'\\ndocument.body.appendChild(p)\\n\\nconst list = document.getElementsByTagName('p')\\nconsole.log('length---', listh.length)\\n\\nconsole.log('start')\\n// 渲染之后\\nsetTimeout(() => {\\n const list = document.getElementsByTagName('p')\\n console.log('length on timeout---', list.length) // 2\\n alert('阻塞 timeout')\\n})\\n// 渲染之前\\nPromise.resolve().then(() => {\\n const list = document.getElementsByTagName('p')\\n console.log('length on promise.then---', list.length) // 2\\n alert('阻塞 promise')\\n})\\nconsole.log('end')\\n```\\n\\n```js\\n// 同步任务 -> 异步任务 -> 宏任务\\n// 微任务要比宏任务要快\\n// Event Loop\\n\\n<script>\\n console.log('start')\\n setTimeout(() => {\\n  console.log('timeout')\\n })\\n Promise.resolve().then(() => {\\n  console.log('promise then')\\n ))\\n console.log('end')\\n\\n // ajax(url, fn) // 300ms\\n \\n // Event Loop 继续监听\\n // 宏任务 MarcoTask Queue\\n // () => {\\n //   console.log('timeout')\\n // }\\n // fn\\n \\n // DOM 渲染\\n // 微任务 MicroTask Queue\\n // () => {\\n //   console.log('promise then')\\n // }\\n</script>\\n```\\n\\n## Nodejs异步\\n\\n1. Nodejs同样使用ES语法，也是单线程，也需要异步\\n2. 异步任务也分：宏任务+微任务\\n3. 但是，它的宏任务和微任务，分不同类型，有不同优先级\\n\\n## 虚拟DOM（vdom）真的很快吗\\n\\n1. vdom: Virtual DOM，虚拟DOM 用JS对象模拟DOM节点数据\\n2. 组件化 数据视图分离，数据驱动视图 只关注业务数据，而不用再关心DOM变化\\n3. vdom并不快，js直接操作dom才是最快的\\n\\t但”数据驱动视图“要有合适的技术方案，不能全部dom重建\\n\\tvdom就是目前最合适的技术方案（并不是因为它快，而是合适）\\n\\n## 遍历一个数组用for和forEach哪个更快\\n\\n- for更快\\n- forEach每次都要创建一个函数来调用，而for不会创建函数\\n- 函数需要独立的作用域，会有额外的开销\\n\\n## nodejs如何开启多进程，进程如何通讯-进程和线程的\\n\\n进程 process vs 线程 thread\\n进程，OS 进行资源分配和调度的最小单位，有独立内存空间\\n线程，OS 进行运算调度的最小单位，共享进程内存空间\\nJS是单线程的，但可以开启多进程执行，如WebWorker\\njs 不可以开启一个线程\\n\\n为何需要多进程？\\n1. 多核CPU，更适合处理多进程\\n2. 内存较大，多个进程才能更好的利用（单进程有内存上限）\\n3. 总之，“压榨”机器资源，更快，更节省 单个进程内存2G左右\\n\\n```js\\nnodejs如何开启多进程\\n\\n// console.info(process.pid)\\nconst http = require('http')\\n\\nconst server = http.createServer()\\nserver.listen(3000, () => {\\n console.log('localhost: 3000')\\n})\\n\\nconsole.info(process.pid)\\n\\n// WebWorker 进程\\n// fork\\nconst http = require('http')\\nconst server = http.createServer((req, res) => {\\n if (req.url === '/get-sum') {\\n   console.info('主进程 id', process.id)\\n   \\n   res.end('hello')\\n }\\n})\\nserver.listen(3000, () => {\\n console.info('localhost: 3000')\\n})\\n\\n// cluster 进程\\n```\\n\\n```js\\n// 子进程，计算\\nfunction getSum() {\\n let sum = 0\\n for (let i = 0; i < 10000; i++) {\\n  sum += i\\n }\\n return sum\\n}\\n\\nprocess.on('message', data => {\\n console.log('子进程 id', process.pid)\\n console.log(‘子进程接受到的信息：', data)\\n\\n const sum = getSum()\\n // 发送消息给主进程\\n process.send(sum)\\n})\\n```\\n\\n```js\\nconst http = require('http')\\nconst fork = require('child_process').fork\\n\\nconst server = http.createServer((req, res) => {\\n if (req.url === '/get-sum') {\\n  console.info('主进程 id', process.pid)\\n\\n   // 开启子进程\\n  const  computeProcess = fork('./compute.js')\\n  computeProcess.send('开始计算')\\n\\n  computeProcess.on('message', data => {\\n    console.info('主进程接受到的信息：', data)\\n    res.end('sum is' + data)\\n  })\\n\\n  computeProcess.on('close', () => {\\n    console.info('子进程因报错而退出')\\n    computeProcess.kill()\\n    res.end('error')\\n  })\\n }\\n})\\n\\nserver.listen(3000, () => {\\n console.info('localhost: 3000')\\n})\\n```\\n\\n```js\\nconst http = require('http')\\nconst cpuCoreLength = require('os').cpus().length\\nconst cluster = require('cluster')\\n\\nif (cluster.isMaster) {\\n for (let i = 0; i < cpuCoreLength; i++) {\\n  cluster.fork() // 开启子进程\\n }\\n cluster.on('exit', worker => {\\n  console.log('子进程退出')\\n  cluster.fork() // 进程守护\\n })\\n} else {\\n // 多个子进程会共享一个 TCP 连接，提供一份网络服务\\n  const server = http.createServer((req, res) => {\\n  res.writeHead(200)\\n  res.end('done')\\n })\\n server.listen(3000)\\n}\\n```\\n\\n开启子进程 child_process.fork 和 cluster.fork\\n使用 send 和 on 传递消息\\n\\n# 请描述js-bridge的实现原理\\n\\n1. JS无法直接调用 native API\\n2. 需要通过一些特定的“格式”来调用\\n3. JS Bridge的常见实现方式\\n\\t1. 注册全局API\\n\\t2. URL Scheme\\n\\n```js\\n// 封装 JS-bridge\\nconst sdk = {\\n invoke(url, data = {}, onSuccess, onError) {\\n   const iframe = document.createElement('iframe')\\n   iframe.style.visibility = 'hidden'\\n   document.body.appendChild(iframe)\\n   \\n   iframe.onload = () => {\\n    const content = iframe1.contentWindow.document.body.innerHTML\\n   }\\n }\\n}\\n```\\n\\n# requestIdleCallback和request \\n\\n由React fiber引起的关注\\n1. 组建树转换为链表，可分段渲染\\n2. 渲染时可以暂停，去执行其他高优任务，空闲时再继续渲染\\n3. 如何判断空闲？ - requestIdleCallback\\n\\n区别\\n1. requestAnimationFrame 每次渲染完都会执行，高优\\n2. requestIdleCallback 空闲时才执行，低优\\n\\n\\n```js\\n<p>requestAnimationFrame</p>\\n<button id=\\\"btn1\\\">change</button>\\n<div id=\\\"box\\\"></div>\\n\\n<script>\\nconst box = document.getElementById('box')\\ndocument.getElementById('btn1').addEventListener('click', () => {\\n let curWidth = 100\\n const maxWidth = 400\\n function addWidth() {\\n  curWidth = curWidth + 3\\n  box.style.width = `${curWidth}px`\\n  if (curWidth < maxWidth) {\\n   window.requestIdleCallback(addWidth) // 时间不用自己控制\\n  }\\n }\\n})\\n</script>\\n```\\n\\n```js\\nstart\\nend\\ntimeout\\nrequestAnimationFrame\\nrequestIdleCallback\\n\\nwindow.onload = () => {\\n\\n console.info('start')\\n setTimeout(() => {\\n  console.info('timeout')\\n })\\n // 宏任务，顺序交换也一样\\n // 高优\\n window.requestAnimationFrame(() => {\\n  console.info('requestAnimationFrame')\\n })\\n // 低优\\n window.requestIdleCallback(() => {\\n  console.info('requestIdleCallback')\\n })\\n\\n console.info('end')\\n}\\n```\\n\\n# Vue每个生命周期都做了什么\\n\\n- beforeCreate\\n\\t创建一个空白的Vue实例\\n\\tdata method 尚未被初始化，不可使用\\n- created\\n\\tvue实例初始化完成，完成响应式绑定\\n\\tdata method都已经初始化完成，可调用\\n\\t尚未开始渲染模板\\n- beforeMount\\n\\t编译模版，调用render生成vdom\\n\\t还没有开始渲染DOM\\n\\n\\t$el null \\n\\telement没有\\n- mounted\\n\\t完成DOM渲染\\n\\t组件创建完成\\n\\t开始由“创建阶段”进入“运行阶段”\\n- beforeUpdate\\n\\tdata发生变化之后\\n\\t准备更新DOM（尚未更新DOM）\\n- updated\\n\\tdata发生变化，且DOM更新完成\\n\\t（不要在updated中修改data，可能会导致死循环）\\n- beforeUnmount\\n\\t组件进入销毁阶段（尚未销毁，可正常使用）\\n\\t可移除，解绑一些全局事件，自定义事件\\n- unmounted\\n\\t组件被销毁了\\n\\t所有子组件也都被销毁了\\n- keep-alive组件\\n\\tonActivated 缓存组件被激活\\n\\tonDeactivated 缓存组件被隐藏\\n\\n```js\\n<keep-alive>\\n <Child1 v-if=\\\"num === 1\\\"></Child1>\\n <Child2 v-else></Child2>\\n</keep-alive>\\n\\n// Child1 2\\ncreated() {\\n console.log() // keep-alive 中只创建\\n}\\nactivated() {}\\ndeactivated() {}\\n\\n// 创建一次被缓存\\n```\\n\\n```js\\nchild1 created\\nchild1 activated\\nchild2 created\\nchild1 deactivated\\nchild2 activated\\nchild2 deactivated\\nchild1 activated\\n```\\n\\n- vue什么时候操作DOM比较合适\\n\\tmounted和updated都不能保证子组件全部挂载完成\\n\\t使用$nextTick渲染DOM\\n\\n\\t只有nextTick操作DOM才是最安全的\\n\\n```js\\n$nextTick\\nmounted() {\\n this.$nextTick(function () {\\n  // 仅在整个视图都被渲染之后才会运行的代码\\n })\\n}\\n```\\n\\n- ajax 应该在那个生命周期？\\n\\t有两个选择：created 和 mounted\\n\\t推荐：mounted\\n- vue3 Composition API 生命周期有何区别？\\n\\t用setup代替了beforeCreate和created\\n\\t使用Hooks函数的形式，如mounted改为onMounted()\\n\\n```js\\nimport { onUpdated, onMounted } from 'vue'\\nexport default {\\n setup() {\\n  onMounted(() => {\\n \\n  })\\n  onUpdated(() => {\\n  \\n  })\\n }\\n}\\n```\\n\\n# Vue2和Vue3和React三者的diff算法有什么\\n\\n介绍diff算法\\ndiff算法很早就有\\n\\ntree diff优化\\n只比较同一层级，不跨级比较\\ntag 不同则删掉重建（不再去比较内部的细节）\\n子节点通过key区分（key的重要性）\\n\\nvue3最长递增子序列\\nvue2 双端比较\\nReact 仅右移\\n\\n# Vue-router的MemoryHistory是什么\\n\\nHash, WebHistory, MemoryHistory( v4 之前叫做 abstract history)\\n\\n# 移动端H5点击有300ms延迟，该如何解决\\n\\nFastClick原理\\n监听touchend事件（touchstart touchend会先于click触发）\\n使用自定义DOM事件模拟一个click事件\\n把默认的click事件（300ms之后触发）禁止掉\\n\\n现代浏览器的改进\\n\\n```js\\n<head>\\n <meta charset=\\\"UTF-8\\\">\\n <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\">\\n <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"ie=edge\\\">\\n</head>\\n```\\n\\n# HTTP请求中token和cookie有什么区别-cookie\\n\\n1. cookie\\n\\tHTTP无状态，每次请求都要带cookie，以帮助识别身份\\n\\t服务端也可以向客户端set-cookie，cookie大小限制4kb\\n\\t默认有跨域限制：不可跨域共享、传递cookie\\n2. withCredentials 前端设置跨域cookie共享\\n\\tcookie本地存储\\n\\tHTML5之前cookie常被用于本地存储\\n\\tHTML5之后推荐使用localStorage和sessionStorage\\n3. 现在浏览器开始禁止第三方cookie\\n\\t和跨域限制不同。这里是：禁止网页引入的第三方JS设置cookie\\n\\t打击第三方广告，保护用户隐私\\n\\t新增属性 SameSite: Strict/Lax/None；值可自己选择\\n4. 浏览器的Cookie新增加了一个SameSite属性，用来防止CSRF攻击和用户追踪\\n5. cookie和session\\n\\tcookie用于登录验证，存储用户标识\\n\\tsession在服务端，存储用户详细信息，和cookie信息一一对应\\n\\tcookie和session是常见登录验证解决方案\\n\\n# HTTP请求中token和cookie有什么区别-token\\n\\n1. token vs cookie\\n\\tcookie是HTTP规范，而token是自定义传递\\n\\tcookie会默认被浏览器存储，而token需自己存储\\n\\ttoken默认没有跨域限制\\n2. jwt (json web token) 可以取代 cookie和session\\n\\t前端发起登录，后端验证成功之后，返回一个加密的token\\n\\t前端自行存储这个token（其中包含了用户信息，加密了）\\n\\t以后访问服务端接口，都带着这个token，作为用户信息\\n3. cookie：HTTP标准；跨域限制；配合session使用\\n4. token：无标准；无跨域限制；用于JWT\\n\\n# session和JWT哪个更好\\n\\n1. session缺点\\n\\t占用服务端内存，硬件成本高\\n\\t多进程，多服务器时，不好同步，需使用第三方缓存，如redis\\n\\t默认有跨域限制\\n2. session优点\\n\\t原理简单，易于学习\\n\\t用户信息存储在服务端，可快速禁某个用户\\n3. jwt 优点\\n\\t不占用服务端内存\\n\\t多进程，多服务器 不受影响\\n\\t没有跨域限制\\n4. jwt 缺点\\n\\t用户信息存储在客户端，无法快速封禁某用户\\n\\t万一服务端秘钥被泄漏，则用户信息全部丢失\\n\\ttoken体积一般大于cookie，会增加请求的数据量\\n\\n如有严格管理用户信息的需求（保密，快速封禁）推荐session\\n如没有特殊要求，则使用jwt\\n\\n# 如何实现SSO单点登录\\n\\n1. 基于cookie\\n\\tcookie默认不可跨域共享，但有些情况下可设置为共享\\n\\t主域名相同，如www.baidu.com image.baidu.com\\n\\t设置cookie domain为主域名，即可共享cookie\\n2. sso\\n\\t主域名完全不同，则cookie无法共享\\n\\t可使用sso技术方案\\n\\n# HTTP协议和UDP协议有什么区别\\n\\n网络协议\\nHTT P协议在应用层\\nTCP UDP 协议再传输层\\n严格来说，应该拿TCP和UDP进行比较\\n\\nOSI的体系结构\\n```js\\n7. 应用层\\n6. 表示层\\n5. 会话层\\n4. 运输层\\n3. 网络层\\n2. 数据链路层\\n1. 物理层\\n```\\n\\nTCP/IP的体系结构\\n\\n```js\\n1. 应用层（各种应用层协议，如DNS，HTTP，SMTP等）\\n2. 运输层（TCP或UDP）\\n3. 网际层（IP）\\n4. 网络接口层\\n```\\n\\n TCP协议\\n1. 有连接（三次握手）\\n2. 有断开（四次挥手）\\n3. 稳定传输\\n\\nUDP协议\\n1. 无连接，无断开\\n2. 不稳定传输，但效率高\\n3. 如视频会议，语音通话\\n\\nHTTP是应用层，TCP UDP是传输层\\nTCP有连接，有断开，稳定传输\\nUDP无连接，无断开，不稳定传输，但效率高\\n\\n# HTTP协议1.0和1.1和2.0有什么区别\\n\\n1. HTTP1.0 弃用\\n\\t最基础的HTTP协议\\n\\t支持基本的GET，POST的方法\\n2. HTTP1.1\\n\\t缓存策略 cache-control E-tag等\\n\\t支持长连接Connection: keep-alive，一次TCP连接多次请求\\n\\t断点续传，状态码 206\\n\\t支持新的方法PUT DELETE等，可用于Restful API\\n3. HTTP2.0\\n\\t可压缩header，减少体积\\n\\t多路复用，一次TCP连接中可以多个HTTP并行请求\\n\\t服务端推送\\n\\n# 什么是HTTPS中间人攻击，如何预防\\n\\nHTTP S 加密传输\\nHTTP明文传输\\nHTTP S 加密传输 HTTP+TLS/SSL\\n\\n# script标签的defer和async有什么区别 \\n\\n`<script src=\\\"xxx.js\\\" async 或 defer></script>`\\n\\n无：HTML暂停解析，下载JS，执行JS，再继续解析HTMl\\ndefer：HTML继续解析，并行下载JS，HTML解析完再执行JS\\nasync: HTML继续解析，并行下载JS，执行JS，再解析HTM L\\n\\n# prefetch和dns-prefetch分别\\n\\npreload和prefetch\\npreload资源在当前页面使用，会优先加载\\nprefetch资源在未来页面使用，空闲时加载\\n\\n```js\\n<head>\\n\\n<link rel=\\\"preload\\\" href=\\\"style.css\\\" as=\\\"style\\\">\\n<link rel=\\\"preload\\\" href=\\\"main.js\\\" as=\\\"script\\\">\\n\\n<link rel=\\\"prefetch\\\" href=\\\"other.js\\\" as=\\\"script\\\">\\n\\n<link rel=\\\"stylesheet\\\" href=\\\"style.css\\\">\\n\\n</head>\\n<body>\\n<script src=\\\"main.js\\\" defer></script>\\n</body>\\n```\\n\\ndns-prefetch 和 preconnect\\ndns-prefetch即DNS预查询\\npreconnect即DNS预连接\\n\\n多个域名时，当前已经解析完，预查询，预连接\\n\\n```js\\n<link rel=\\\"dns-prefetch\\\" href=\\\"域名\\\">\\n<link rel=\\\"dns-preconnect\\\" href=\\\"\\\" crossorigin></link>\\n```\\n\\nprefetch 是资源预获取（和preload相关）\\ndns-prefetch 是DNS预查询（和preconnect相关）\\n\\n# 前端攻击手段有哪些，该如何预防\\n\\n1. xss\\n\\tCross Site Script 跨站脚本攻击\\n\\t手段：黑客将JS代码插入到网页内容中，渲染时执行JS代码\\n\\t预防：特殊字符替换（前端或者后端）\\n\\n`const newStr = str.replaceAll('<', '&lt;').replaceAll('>', '&gt;')`\\n\\n2. Vue React 默认屏蔽xss攻击\\n\\t除了用 vue v-html react dangerouslySetInnerHTML\\n3. CSRF\\n\\tCross Site Request Forgery 跨站请求伪造\\n\\t手段：黑客诱导用户去访问另一个网站的接口，伪造请求\\n\\t预防：严格的跨站限制 + 验证码机制\\n4. CSRF详细过程\\n\\t用户登录了A网站，有了cookie\\n\\t黑客诱导用户到B网站，并发起A网站的请求\\n\\tA网站的API发现有cookie，认为是用户自己操作的\\n5. CSRF预防手段\\n\\t严格的跨域请求限制，如判断referrer(请求来源)\\n\\t为cookie设置SameSite，禁止跨域传递cookie\\n\\t关键接口使用短信验证码\\n6. 点击劫持\\n\\tClick Jacking\\n\\t手段：诱导界面上蒙一个通明的iframe，诱导用户点击\\n\\t预防：让iframe不能跨域加载\\n7. 点击劫持 预防\\n\\n```js\\nif (top.location.hostname !== self.location.hostname) {\\n alert(\\\"您正在访问不安全的页面，即将跳转到安全页面！“)\\n top.location.href = self.location.href\\n}\\n\\nhearders\\n\\nX-Frame-Options: sameorigin\\n```\\n\\n8. DDoS\\n\\tDIstribute denial-of-service分布式拒绝服务\\n\\t手段：分布式的，大规模的流量访问，使服务器瘫痪\\n\\t预防：软件层不好做，需硬件预防（如阿里云WAF）\\n9. SQL注入\\n\\t手段：黑客提交内容时写入SQL语句，破坏数据库\\n\\t预防：处理输入的内容，替换特殊字符\\n10. xss, ddos, csrf, sql注入, 点击劫持\\n\\n# WebSocket和HTTP协议有什么区别\\n\\n1. WebSocket\\n\\t支持端对端通讯\\n\\t可以由client发起，也可以由server发起\\n\\t用于：消息通知，直播间讨论区，聊天室，协同编辑\\n\\n```js\\nnpm init -y\\nnpm install ws --save\\nnpm install nodemon --save-dev\\n```\\n\\n```js\\nconst { WebSocketServer } = require('ws')\\n\\nconst wsServer = new WebSocketServer({ port: 3000 })\\n\\nwsServer.on('connection', ws => {\\n console.info('connected')\\n \\n ws.on('message', msg => {\\n  console.info('收到了信息', msg.toString)\\n  \\n  // 服务端向客户端发送信息\\n  setTimeout(() => {\\n   ws.send('服务端已经收到了信息：' + msg.toString())\\n  }, 2000)\\n })\\n})\\n\\n\\n\\n<button id=\\\"btn-send\\\">发送消息</button>\\n\\nconst ws = new WebSocket('ws://127..0.0.1:3000')\\nws.onopen = () => {\\n console.info('opened')\\n ws.send('client opened')\\n}\\nws.onmessage = event = {\\n console.info('收到了信息', event.data)\\n}\\n\\nconst btnSend = document.getElementById('btn-send')\\nbtnSend.addEventListener('click', () => {\\n console.info('clicked')\\n ws.send('当前时间' + Date.now())\\n})\\n```\\n\\nWebSocket 连接过程\\n先发起一个 HTTP 请求\\n成功之后再升级到 WebSocket 协议，再通讯\\n\\nWebSocket 和 HTTP 区别\\nWebSocket 协议名是 ws:// ， 可双端发起请求\\nWebSocket 没有跨域限制\\n通过send和onmessage通讯（HTTP通过req和res）\\n\\n```js\\nws可升级为 wss （像https）\\nimport { createServer } from 'https'\\nimport { readFileSync } from 'fs'\\nimport { WebSocketServer } from 'ws'\\n\\nconst server = createServer ({\\n cert: readFileSync('/path/to/cert.pem'),\\n key: readFileSync('/path/to/key.pem')\\n})\\n\\nconst wss = new WebSocketServer({ server })\\n```\\n\\n```js\\n扩展：实际项目推荐socket.io, api更简洁\\nio.on('connection', socket => {\\n socket.emit('request', /*...*/)\\n io.emit('broadcast', ...)\\n socket.on('reply', () => {})\\n})\\n```\\n\\n```js\\nconst { WebSocketServer } = require('ws')\\n\\nconst wsServer = new WebSocketServer({ port: 3000 })\\n\\nconst list = new Set()\\n\\nwsServer.on('connection', curWs => {\\n console.info('connected')\\n\\n list.add(curWs)\\n\\n curWs.on('message', msg => {\\n  console.info('received message', msg.toString())\\n  \\n  // 传递给其他客户端\\n  list.forEach(ws => {\\n   if (ws === curWs) return\\n   ws.send(msg.toString())\\n  })\\n })\\n})\\n```\\n\\n# WebSocket和HTTP长轮询的区别\\n\\n1. 区别\\n\\tHTTP长轮询：客户端发起请求，服务端等待，不会立即返回\\n\\tWebSocket：客户端可发起请求，服务端也可发起请求\\n2. 注意：\\n\\tHTTP长轮询，需处理timeout，即 timeout 之后重新发请求\\n\\n# 从输入URL到网页显示的完整过程\\n\\n步骤：\\n网络请求：\\nDNS查询（得到IP），建立TCP连接（三次握手）\\n浏览器发起HTTP请求\\n收到请求响应，得到HTML源代码\\n\\n继续请求静态资源\\n解析HTML过程中，遇到静态资源还会继续发起网络请求\\nJS CSS 图片 视频等\\n注意：静态资源可能有强缓存，此时不必请求\\n\\n解析：字符串 -> 结构化数据\\nHTML构建DOM树\\nCSS构建CSSOM树（style tree）\\n两者结合，形成 render tree\\n\\n渲染\\n解析过程很复杂\\nCSS 可能来自 `<style> <link>`\\nJS 可能内嵌，或外链，还有 defer async 逻辑\\nimg 可能内嵌（base64），可能外链\\n\\n优化解析\\nCSS放在`<head>`中，不要异步加载CSS\\nJS放在`<body>`最下面（或合理使用 defer async）\\n`<img>` 提前定义 width height\\n\\n渲染：Render Tree 绘制到页面\\n计算各个DOM的尺寸，定位，最后绘制到页面\\n遇到JS可能会执行（参考 defer async）\\n异步CSS，图片加载，可能会触发重新渲染\\n\\n网络请求：DNS解析，HTTP请求\\n解析：DOM树，CSSOM树，Render Tree\\n渲染：计算，绘制，同时执行JS\\n\\n# 网页重绘repaint和重排reflow有什么\\n\\n1. 网页动画\\n2. Modal Dialog 弹窗\\n3. 增加/删除一个元素，显示/隐藏一个元素\\n\\n重绘 repaint\\n\\n1. 元素外观改变，如颜色，背景色\\n2. 但元素的尺寸，定位不变，不会影响其他元素的位置\\n\\n重排 reflow\\n\\n1. 重新计算尺寸和布局，可能会影响其他元素的位置\\n2. 如元素高度增加，可能会使相邻元素位置下移\\n\\n区别\\n\\n1. 重排比重绘要影响更大，消耗也更大\\n2. 所以，要尽量避免无意义的重排\\n\\n减少重排的方法 1/2\\n\\n1. 集中修改样式，或直接切换 css class\\n2. 修改之前先设置 display: none, 脱离文档流\\n3. 使用bfc特性，不影响其他元素位置\\n\\n减少重排的方法 2/2\\n\\n1. 频繁触发（resize scroll）使用节流和防抖\\n2. 使用 createDocumentFragment 批量操作 DOM\\n3. 优化动画，使用 CSS3 和 requestAnimationFrame\\n\\n扩展：BFC\\n\\n1. Block Format Context 块级格式化上下文\\n2. 内部的元素无论如何改动，都不会影响其他元素的位置\\n\\n触发 BFC 的条件 1/2\\n\\n1. 根节点 `<html>`\\n2. float: left/right\\n3. overflow: auto/scroll/hidden;\\n\\n触发 BFC 的条件 2/2\\n\\n1. display: inline-block / table / table-row / table-cell;\\n2. display: flex/grid; 的直接子元素\\n3. position: absolute / fixed;\\n\\n# 如何实现网页多标签tab通讯\\n\\n使用 WebSocket\\n\\n1. 无跨域限制\\n2. 需要服务端支持，成本高\\n\\n通过 localStorage 通讯\\n\\n1. 同域的 A 和 B 两个页面\\n2. A页面设置 localStorage\\n3. B页面可监听到 localStorage 值的修改\\n\\n通过 SharedWorker 通讯\\n\\n1. SharedWorker 是 WebWorker 的一种\\n2. WebWorker 可开启子进程执行 JS，但不能操作 DOM\\n3. SharedWorker 可单独开启一个进程，用于同域页面通讯\\n\\n",
        "tags": [
            "前端",
            "JavaScript",
            "面试"
        ]
    },
    {
        "article_id": "7171683211896946724",
        "cover_image": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7473e9cc698546288cdbf03f7912b9d4~tplv-k3u1fbpfcp-watermark.image?",
        "title": "一个特殊下拉选择",
        "brief": "一个使下拉框可输入的下拉框。解决下拉数据无匹配时候又要新增的一些问题。基于element-ui和vue2.",
        "user_name": "华菱下水道二组_历飞宇",
        "view_count": 2851,
        "collect_count": 46,
        "comment_count": 2,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/bd1c7caabe140167819b50b7914e8b1e~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: nico\\nhighlight: atelier-estuary-light\\n---\\n\\n## 🍉【主要功能】：\\n> 样例为粗例，暂未优化。基于element 的el-select。主要功能是当输入值不与下拉数据匹配时，将该输入值获取。本样例客制化严重。如要封装到自己框架的话，请用心修改。element-ui本身也提供了类似的方法，（filterable，default-first-option）两个属性。看需求取用吧\\n\\n## 🎨**示例**：\\n#### 1.输入x时匹配出相关信息\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/082184813b684e41868420fb45f0f17d~tplv-k3u1fbpfcp-watermark.image?)\\n#### 2.输入pppp时，匹配无数据\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/24274f30202645c7b5d6676d48e6086d~tplv-k3u1fbpfcp-watermark.image?)\\n#### 3.失焦时pppp保留在输入框内\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/133f9cf1014249c582197d0ffa69ee12~tplv-k3u1fbpfcp-watermark.image?)\\n#### 4.再次选择时，初始化选择列表。置灰pppp\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4da6f48a0377491ca4e338686cc5e70b~tplv-k3u1fbpfcp-watermark.image?)\\n## 🍉代码：\\n```js\\n<template>\\n  <el-select\\n    id=\\\"selectInput\\\"\\n    ref=\\\"searchSelect\\\"\\n    v-model=\\\"num\\\"\\n    filterable\\n    placeholder=\\\"请选择\\\"\\n    :filter-method=\\\"dataFilter\\\"\\n    @visible-change=\\\"visibleChange\\\"\\n    @focus=\\\"onFocus\\\"\\n    @blur=\\\"onBlur\\\"\\n    @change=\\\"onChange\\\"\\n  >\\n    <el-option\\n      v-for=\\\"item in options\\\"\\n      :key=\\\"item.account\\\"\\n      :label=\\\"item.name\\\"\\n      :value=\\\"item.account\\\"\\n    >{{ item.name }} </el-option>\\n  </el-select>\\n</template>\\n\\n<script>\\nexport default {\\n  name: 'KeepSelectValue',\\n  model: {\\n    prop: 'value',\\n    event: 'change',\\n  },\\n  props: {\\n    jsonData: {\\n      type: Array,\\n      default: () => [],\\n    },\\n    wants: {\\n      type: String,\\n      default: 'id',\\n    },\\n    value: {\\n      type: [String, Number],\\n      default: \\\"\\\",\\n    },\\n  },\\n  data() {\\n    return {\\n      options: this.jsonData,\\n      num: this.value,\\n      optionsFilter: this.jsonData,\\n    };\\n  },\\n  watch: {\\n    value: {\\n      handler(val) {\\n        this.num = val;\\n      },\\n      immediate: true,\\n      deep: true,\\n    },\\n  },\\n\\n  methods: {\\n    dataFilter(val) {\\n      this.num = val;\\n      if (val) {\\n        this.options = this.optionsFilter.filter((item) => {\\n          if (item.name.includes(val) || item.name.toUpperCase().includes(val.toUpperCase())) {\\n            return true;\\n          }\\n        });\\n      } else {\\n        this.options = this.optionsFilter;\\n      }\\n    },\\n    onFocus(e) {\\n      this.options = this.jsonData;\\n      const value = e.target.value;\\n      setTimeout(() => {\\n        const input = this.$refs.searchSelect.$children[0].$refs.input;\\n        input.value = value;\\n      });\\n    },\\n    onBlur() {\\n      console.log(this.num, 'sssss');\\n      this.$emit(\\\"update:value\\\", this.num);\\n      this.$emit(\\\"change\\\", this.num);\\n    },\\n    onChange(val) {\\n      this.$emit(\\\"update:value\\\", val);\\n      this.$emit(\\\"change\\\", val);\\n    },\\n    visibleChange(val) {\\n      if (!val) {\\n        const input = this.$refs.searchSelect.$children[0].$refs.input;\\n        input.blur();\\n      }\\n    },\\n  },\\n};\\n</script>\\n\\n```\\n",
        "tags": [
            "前端",
            "JavaScript",
            "Vue.js"
        ]
    },
    {
        "article_id": "7181654898805571643",
        "cover_image": "",
        "title": "万万没想到，go的数据库操作，也能像php一样溜了",
        "brief": "Hi,各位go的小伙伴。 很多人都是从php转过来的吧，不知道你们有没有发现，go界的orm并没有像php的orm一样好用。这篇文章里，我们认真的讨论下这个问题，并且会在后面提出解决方案。",
        "user_name": "程序员汤汤",
        "view_count": 10350,
        "collect_count": 32,
        "comment_count": 50,
        "avatar": "https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/27/16cd120eeeed063b~tplv-t2oaga2asx-image.image",
        "category": "后端",
        "content": "Hi,各位go的小伙伴。\\n\\n很多人都是从php转过来的吧，不知道你们有没有发现，go界的orm并没有像php的orm一样好用。这篇文章里，我们认真的讨论下这个问题，并且会在后面提出解决方案。\\n\\n\\n![微信图片_20221226163624.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2633189906904ec5be5f13cb05a5d61f~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n## php的方便\\n比如你想实现一个关联查询，在php里，你只需要不断的使用箭头函数就可以了。\\n\\n```php\\n$users = DB::table('users')->whereIn('id', [1, 2, 3])->orderBy('name', 'desc')->get();\\n```\\n以上代码，很简单实现了对一个表的查询操作，并且将查询结果以name做倒序排列，很简单\\n\\n但是做同样的工作，在go里面就比较麻烦了\\n\\n## go的麻烦\\n如果你使用go的原生查询的话，你需要写如下的代码\\n```go\\nrows, err := db.Query(\\\"select * from users where id in (?,?,?) order by name desc\\\", 1, 2, 3)\\n```\\n基本上说，你需要手写一个完整的sql语句，全手动\\n\\n什么！手写sql语句，不是咱不会写，关键是没必要手写啊，是吧。\\n\\n全手写可能带来两个问题\\n1. 某些同学对于sql语法可能不熟悉，容易有语法错误  \\n2. 某些同学可能写sql不认真，容易有拼写错误，尤其是条件多，占位符多的时候  \\n\\n\\n如果你使用gorm之类的orm工具，可能会这样写\\n```go\\ndb.Where(\\\"id in (?)\\\", []int{1,2,3}).Order(\\\"create_time desc\\\").Find(&users)\\n```\\n\\n很显然对比原生的来说，好一些，不用手写select 等关键字了，但是核心问题还是没解决，还需要手写 id in (?)\\n之类的。相当于之前是全手工，现在是半手工半自动了。\\n\\n我这个例子里，条件就一个，在实际业务中，查询条件会有很多，并且数量还不一定，这种半自动的方法还是不太好的。\\n\\n\\n## 解决方案\\n既然有问题，那就有解决方案。很明显，最理想的方案就是保持与php的一致。那么go能做到这样吗？\\n\\n答案是毫无疑问的，可以的。\\n\\n这里推荐一个新的数据库操作库,可以很方便的完成这样的工作\\n\\n[tangpanqing/aorm: Operate Database So Easy For GoLang Developer (github.com)](https://github.com/tangpanqing/aorm)\\n\\n它有一些显著的特性\\n-    代码简洁，高性能\\n-    支持 MySQL,MsSQL,Postgres,Sqlite3 数据库\\n-    支持 空值查询\\n-    支持 自动迁移\\n-    支持 SQL 拼接\\n\\n我们来看具体使用,就刚才的操作\\n```go\\naorm.Use(db).Table(\\\"users\\\").WhereIn(\\\"id\\\", []int{1,2,3}).OrderBy(\\\"name\\\",\\\"desc\\\").GetMany(&users)\\n```\\n对比php的写法\\n```php\\n$users = DB::table('users')->whereIn('id', [1, 2, 3])->orderBy('name', 'desc')->get();\\n```\\n不能说一模一样吧，那简直是一模一样是不是？\\n\\n我们再来看看如果是查询条件不确定怎么办？\\n\\n**这是列表查询经常遇到的问题，前端传过来的数据数量是不一定的，我们需要根据不同的数据，来增加或者减少不同的条件，进而产生不同的sql，查询不同的结果**\\n\\n```go\\n    var listByWhere []Person\\n    \\n    var where1 []builder.WhereItem\\n    where1 = append(where1, builder.WhereItem{Field: \\\"type\\\", Opt: builder.Eq, Val: 0})\\n    where1 = append(where1, builder.WhereItem{Field: \\\"age\\\", Opt: builder.In, Val: []int{18, 20}})\\n    where1 = append(where1, builder.WhereItem{Field: \\\"money\\\", Opt: builder.Between, Val: []float64{100.1, 200.9}})\\n    where1 = append(where1, builder.WhereItem{Field: \\\"money\\\", Opt: builder.Eq, Val: 100.15})\\n    where1 = append(where1, builder.WhereItem{Field: \\\"name\\\", Opt: builder.Like, Val: []string{\\\"%\\\", \\\"li\\\", \\\"%\\\"}})\\n    \\n    aorm.Use(db).Debug(true).Table(\\\"person\\\").WhereArr(where1).GetMany(&listByWhere)\\n    for i := 0; i < len(listByWhere); i++ {\\n        fmt.Println(listByWhere[i])\\n    }\\n```\\n如上，你可以定义一个builder.WhereItem的切片(数组)，然后根据前端传过来的信息，来增加和减少这个数组里的项，最后将这个查询数组，传递给aorm进行最后查询，最终得到结果。\\n\\n**由上面的例子可以看出，和PHP一样，你只是需要输入关键的字段名，关键的数据这就行了，其他的sql关键字，以及多种条件的拼接，aorm库自动帮你完成了。完美解决语法错误问题，以及拼写错误问题。**\\n\\n\\n怎么样，香不香？\\n\\n## 写在最后\\n\\naorm库非常的好用，为go工程师带来了php一般的开发体验，推荐各位快快用起来。\\n\\n[tangpanqing/aorm: Operate Database So Easy For GoLang Developer (github.com)](https://github.com/tangpanqing/aorm)\\n\\n![微信图片_20221226163643.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d55bc4ad346446e39d9d32bdf0c4566b~tplv-k3u1fbpfcp-watermark.image?)\\n",
        "tags": [
            "Go",
            "数据库",
            "PHP"
        ]
    },
    {
        "article_id": "7167725818125221918",
        "cover_image": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/668ef1a289964e7796af1ede60a695ad~tplv-k3u1fbpfcp-watermark.image?",
        "title": "开发H5都会喜欢这个Vite插件",
        "brief": "在开发小程序的时候经常会通过手机扫描小程序开发工具生成的二维码来快速在手机上打开正在开发的小程序进行功能调试，但是在H5开发时却还是通过聊天软件来粘贴地址，费时费力，所以我将编写一个Vite插件来支持",
        "user_name": "小鑫同学",
        "view_count": 4187,
        "collect_count": 45,
        "comment_count": 9,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/5ead43b3213f176d5ab1e30432149b4d~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: smartblue\\n---\\n> 🎄Hi~ 大家好，我是[小鑫同学 (opens new window)](https://it200.cn/) ，一位长期从事前端开发的编程爱好者，我将使用更为实用的案例输出更多的编程知识，同时我信奉分享是成长的唯一捷径，在这里也希望我的每一篇文章都能成为你技术落地的参考~\\n> \\n\\n在开发小程序的时候经常会通过手机扫描小程序开发工具生成的二维码来快速在手机上打开正在开发的小程序进行功能调试，但是在H5开发时却还是通过聊天软件来粘贴地址，费时费力，所以我将编写一个Vite插件来支持终端显示二维码的功能。\\n\\n## 1. Vite插件开发辅助\\n\\n开发Vite插件建议使用开源项目[generator-vite-plugin](https://github.com/OSpoon/generator-vite-plugin)，可以通过简单了两步操作实现一个Vite插件开发的基本环境,还贴心的配置了调试脚本方便第一次开发插件时手忙脚乱；\\n\\n\\n### 1.1 安装generator-vite-plugin：\\n\\n```bash\\n$ npm i -g yo\\n$ npm i -g generator-vite-plugin\\n```\\n\\n### 1.2 生成Vite插件基本环境：\\n\\n```bash\\n$ yo vite-plugin\\n```\\n\\n\\n![%E5%88%9B%E5%BB%BAVite%E6%8F%92%E4%BB%B6%E6%A8%A1%E6%9D%BF.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/79fec35639ac49a49e183bb273315ac8~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## 2. DevQRCode插件开发\\n\\n通过第一步已经生成了`vite-plugin-dev-qrcode` 插件的基本状态，这里要介绍几个基本的前提要素：\\n\\n1. 手机端需要和电脑端处于同一局域网环境；\\n2. 手机端必须使用局域网分配的IP访问H5页面，Local地址无效；\\n3. Vite默认启动不提供Network地址，需要增加`--host` 参数，插件中默认已配置；\\n\\n### 2.1 获取Vite启动后分配的URLs：\\n\\n`vite`命令执行后会在终端启动一个开发服务器，并分配给我们访问该服务的地址，所以这里要关注的就是`configureServer` 这个钩子函数，通过该函数提供的`server` 对象可以获取到该服务的相关信息；\\n\\n在`server`对象的`ViteDevServer` 类型定义中看到如下参数，在`server.listen` 之后urls将会打印到终端，这正是我要找的属性；\\n\\n```tsx\\n/**\\n * The resolved urls Vite prints on the CLI. null in middleware mode or\\n * before `server.listen` is called.\\n */\\nresolvedUrls: ResolvedServerUrls | null;\\n```\\n\\n### 2.2 溯源Vite如何终端输出信息：\\n\\n上一步知道了urls如何获取，这一步要解决的就是vite到底是如何输出urls到终端的？在Vite源码的`packages/vite/src/node/server/index.ts` 文件中有如下这段函数，可以看出这个函数将`resolvedUrls` 内容进行了打印，在加上`ViteDevServer` 类型定义中对该函数的注释，就完全锁定了这个就是我的目标函数；\\n\\n```tsx\\nprintUrls() {\\n  if (server.resolvedUrls) {\\n    printServerUrls(\\n      server.resolvedUrls,\\n      serverConfig.host,\\n      config.logger.info\\n    )\\n  } else if (middlewareMode) {\\n    throw new Error('cannot print server URLs in middleware mode.')\\n  } else {\\n    throw new Error(\\n      'cannot print server URLs before server.listen is called.'\\n    )\\n  }\\n}\\n```\\n\\n```tsx\\n/**\\n * Print server urls\\n */\\nprintUrls(): void;\\n```\\n\\n### 2.3 生成二维码并在适时打印到终端：\\n\\n生成的二维码要同urls一同输出，保持一致，这里要使用到扩展的手段来让`server.printUrls` 得到支持，类似的手段在Vue2的数组响应式实现中也有体现，不知道你是否还有印象；\\n\\n具体的二维码生成使用到了`qrcode-terminal` 模块，丰富的样式输出使用`kolorist`模块，具体代码如下：\\n\\n```tsx\\nconfigureServer(server: ViteDevServer) {\\n  const _print = server.printUrls;\\n  server.printUrls = () => {\\n    _print();\\n    const host = server.resolvedUrls?.network[0];\\n    if (host) {\\n      console.log(`${bold(\\\"Scan QR code to open quickly. ⤦\\\")}`);\\n      qrcode.generate(`${host}`, { small: true });\\n    } else {\\n      console.log(\\n        `  ${green(\\\"➜\\\")}  ${yellow(\\\"Failed to get the network address.\\\")}`\\n      );\\n    }\\n  };\\n}\\n```\\n\\n\\n![Untitled.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f42e9899b59249afab9b8fa39a919fc1~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## 总结：\\n\\n实现这个插件仅仅使用了十几行代码，期间翻阅了Vite插件的开发文档和源码，分别找到了开发服务器的相关钩子函数拿到了Vite打印的urls信息，并通过扩展`printUrls` 函数在保证原始逻辑正常执行的情况下增加二维码输出的功能。怎么样，这个插件你会写了吗？尝试一下吧~\\n\\n> **这一篇就结束了，欢迎点赞、评论、分享支持一下。你的支持和肯定，是我坚持写作的动力~** <br>\\n> 最后可以关注我@小鑫同学。欢迎[点此扫码联系 (opens new window)](https://it200.cn/)交流，共同进步（还可以帮你**fix**🐛）~\\n\\n***本文正在参加***[「金石计划 . 瓜分6万现金大奖」](https://juejin.cn/post/7162096952883019783)\\n",
        "tags": [
            "Vite",
            "前端",
            "掘金·金石计划"
        ]
    },
    {
        "article_id": "7156209800714387492",
        "cover_image": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/167bb45974474fe8967d484509097ea1~tplv-k3u1fbpfcp-watermark.image?",
        "title": "Vue3指令——搜索框输入防抖实现",
        "brief": "我正在参加「掘金·启航计划」 大家好，我是 Lvzl, 一个三年工作经验的前端小菜鸡，在掘金平台分享一些 平时学习的感悟 & 实际项目场景 的文章。 前言 「搜索🔍」这个场景在各种业务的系统中都是是非",
        "user_name": "Lvzl",
        "view_count": 5294,
        "collect_count": 177,
        "comment_count": 23,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/87ef25a78d591c9982d3bcdcd9907130~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: vue-pro\\n---\\n我正在参加「掘金·启航计划」\\n\\n大家好，我是 [Lvzl](https://juejin.cn/user/1055186511205390 \\\"https://juejin.cn/user/1055186511205390\\\"), 一个三年工作经验的前端小菜鸡，在[掘金](https://juejin.cn/ \\\"https://juejin.cn/\\\")平台分享一些 平时学习的感悟 & 实际项目场景 的文章。\\n\\n## 前言\\n「搜索🔍」这个场景在各种业务的系统中都是是非常常见的，比如电商平台的商品搜索、百度搜索、掘金搜索、google搜索......，只要是有内容呈现给用户的，都少不了搜索功能。\\n\\n按照触发搜索动作的不同可分为：\\n1. 输完关键字后手动触发搜索\\n2. 输入字符自动搜索\\n\\n第一种是由用户去决定何时进行搜索，没啥问题。\\n\\n第二种是通过监听用户录入的事件自动搜索，自动搜索能在一定程度上提升用户体验（比如在用户输入时关键词联想提示），同时也可能会带来问题，因为`input`事件触发是非常频繁的，比如下面这个示例：\\n\\n打开百度的搜索，找到输入框的dom，然后绑定一个`input`事件，看看我们录入一个`telephone`会触发多少次`input`事件：\\n```js\\ntemp1.addEventListener('oninput', (val) => console.log(val))\\n```\\n触发了10次：\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d058c58bb14449319051d164a1adbb67~tplv-k3u1fbpfcp-watermark.image?)\\n那如果每触发一次都会调用后台接口查询，那当用户量足够大，就会给后台服务器带来很大的压力，导致接口响应慢，甚至引起服务器宕机，也会给用户带来不好的体验。\\n\\n为了不引起过多请求给服务端造成压力，我们期望在用户在输入完以后再发起请求，那怎么判断用户是否输入完了❓\\n\\n可以认为当用户在一个固定的时间内都没有录入字符是输入完成/暂时输入完成。这个是老生常谈的知识点了————「防抖」和「节流」。掘金有很多文章专门写这个的，笔者在此不过多描述，简单一笔带过说下笔者的看法。\\n\\n## 防抖 & 节流\\n\\n### 防抖\\n防抖的函数在调用后，如果在防抖时间内没有再次触发，就会在过了 防抖时间 后执行；如果在防抖时间内再次触发，不论触发多少次，执行的时机会一直往后延迟，直到满足最后一次调用时间 小于 当前时间减去防抖时间才会执行。\\n```js\\nfunction debounce(fn, time) {\\n  let timer\\n  return function (...argu) {\\n    if (timer) {\\n      clearTimeout(timer)\\n      timer = null\\n    }\\n    timer = setTimeout(() => {\\n      fn(...argu)\\n      clearTimeout(timer)\\n      timer = null\\n    }, time)\\n  }\\n}\\n```\\n\\n### 节流\\n节流函数在调用后，在设置的节流时间后执行一次，在此期间，不论触发多少次，都直接`return`了。\\n```js\\nfunction throttle(fn, time) {\\n  let flag = true\\n  return function (...argu) {\\n    if (!flag) {\\n      return\\n    }\\n    flag = false\\n    let timer = setTimeout(() => {\\n      fn(...argu)\\n      flag = true\\n      clearTimeout(timer)\\n      timer = null\\n    }, time)\\n  }\\n}\\n```\\n再来看下加了防抖 & 节流 处理的`input`事件执行情况：\\n\\n- 防抖：\\n![1.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2969d20cb8f4700b9ce56fdf3cf44d0~tplv-k3u1fbpfcp-watermark.image?)\\n\\n- 防抖 + 节流：\\n![1.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/498d73ca4e9d45de9e13bfd6073a4166~tplv-k3u1fbpfcp-watermark.image?)\\n\\n从上面的两个图不难看出防抖 和节流的区别，节流的函数如果一直被触发，每隔一段时间执行一次。而防抖则是一直延迟，最后执行一次。\\n\\n### 输入防抖存在的问题\\n\\n上面的防抖函数执行貌似没啥问题，前提是我们输入的是英文，如果是中文输入就出问题了，看下图：\\n\\n![1.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/964a803913aa482fa857fc826618d0a2~tplv-k3u1fbpfcp-watermark.image?)\\n\\n当中文输入的时候，即使已经防抖处理了，还可能会执行多次。接下来咱们进入正题了，如何实现输入防抖Vue3指令(并解决中文输入触发多次的问题)。\\n\\n## 指令实现\\n为什么要以指令的方式实现❓我能想到的有以下两点：\\n1. 将防抖处理的逻辑封装在指令内部重用，更易用。\\n2. 指令要支持`input`输入框，也要支持封装`input`的组件，也就是说需要进行`底层 DOM 访问的逻辑`，而这一点恰好是指令提供的能力之一。\\n\\n需要补充`Vue 指令`相关知识的同学点这里[自定义指令](https://cn.vuejs.org/guide/reusability/custom-directives.html#introduce)\\n\\n期望使用方式：\\n```vue\\n<template>\\n  <input v-model=\\\"val\\\" v-debounceInput:600=\\\"onInput\\\" />\\n</template>\\n\\n<script setup lang=\\\"ts\\\">\\nimport { ref } from 'vue'\\n\\nconst val = ref('')\\nfunction onInput(e: Event): void {\\n  console.log(e)\\n}\\n</script>\\n```\\n即指令的绑定值为 执行逻辑，指令参数为 防抖时长。\\n\\n指令实现：\\n```ts\\nimport { debounce, isFunction } from '../../utils/index'\\n\\nlet inputFunction: (event: Event) => {}\\n\\n// 由于要同时支持 input 输入框和封装 input 的组件，因此需要去找到input这个元素。\\nfunction findInput(el: HTMLElement): HTMLElement | null {\\n  const quene: HTMLElement[] = []\\n  quene.push(el)\\n  while (quene.length > 0) {\\n    const current = quene.shift()\\n    if (current?.tagName === 'INPUT') {\\n      return current\\n    }\\n    if (current?.childNodes) {\\n      quene.push(...current.childNodes)\\n    }\\n  }\\n  return null\\n}\\n\\nexport default {\\n  mounted(el: HTMLElement, binding: any) {\\n    const { value, arg } = binding\\n    if (value && isFunction(value)) {\\n      let timeout = 600\\n      if (arg && !Number.isNaN(arg)) {\\n        timeout = Number(arg)\\n      }\\n      inputFunction = debounce(value, timeout) // 执行函数防抖处理\\n      const input = findInput(el)\\n      el._INPUT = input\\n      if (input) {\\n        input.addEventListener('input', inputFunction)\\n      }\\n    }\\n  },\\n  beforeUnmount(el: HTMLElement) {\\n    if (el._INPUT) {\\n      el._INPUT.removeEventListener('input', inputFunction)\\n      el._INPUT = null\\n    }\\n  }\\n}\\n\\n```\\n接着处理中文输入可能会触发多次的问题。可借助[compositionstart](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/compositionstart_event)和[compositionend](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/compositionend_event)来实现。\\n- 输入法编辑器开始新的输入合成时会触发 `compositionstart` 事件。例如，当用户使用拼音输入法开始输入汉字时，这个事件就会被触发。\\n- 当文本段落的组成完成或取消时，`compositionend` 事件将被触发 (具有特殊字符的触发，需要一系列键和其他输入，如语音识别或移动中的字词建议)。\\n\\n在一开始拼音输入法时就设置`composing`为true，因此在`compositionEnd`没有调用之前都不会执行函数，等`compositionEnd`调用，通过`dispatchEvent`派发一个`input`事件出去，保证逻辑一定会执行。\\n```ts\\nfunction compositionStart(event: CompositionEvent) {\\n  event.target.composing = true\\n}\\nfunction compositionEnd(e: CompositionEvent) {\\n  e.target.composing = false\\n  const event = new Event('input', { bubbles: true })\\n  e.target?.dispatchEvent(event)\\n}\\n\\nexport default {\\n  mounted(el: HTMLElement, binding: any) {\\n    //...\\n      if (input) {\\n        input.addEventListener('input', inputFunction)\\n        input.addEventListener('compositionstart', compositionStart)\\n        input.addEventListener('compositionend', compositionEnd)\\n      }\\n    //...\\n  },\\n  beforeUnmount(el: HTMLElement) {\\n    if (el._INPUT) {\\n      el._INPUT.removeEventListener('input', inputFunction)\\n      el._INPUT.removeEventListener('compositionstart', compositionStart)\\n      el._INPUT.removeEventListener('compositionend', compositionEnd)\\n    }\\n  }\\n}\\n```\\n防抖实现 & 判断是 `function`\\n```js\\nexport function debounce(input: (event: Event) => any, timeout: number): (this: HTMLElement, ev: Event) => any {\\n  let timer: string | number | NodeJS.Timeout | undefined\\n  return (event: Event) => {\\n    // @ts-ignore\\n    if (event.target.composing === true) {\\n      return\\n    }\\n    if (timer) {\\n      clearTimeout(timer)\\n      timer = undefined\\n    }\\n    timer = setTimeout(() => {\\n      input(event)\\n      clearTimeout(timer)\\n      timer = undefined\\n    }, timeout)\\n  }\\n}\\n\\nexport function isFunction(param: any): boolean {\\n  return Object.prototype.toString.call(param) === '[object Function]'\\n}\\n```\\n注册指令（全局注册）：\\n```js\\ncreateApp(App).directive('debounceInput', debounceInput).mount('#app')\\n```\\n写个案例测试一下：\\n```vue\\n<template>\\n  <div>防抖</div>\\n  <input v-model=\\\"val\\\" v-debounceInput=\\\"onInput\\\" />\\n  <div>普通</div>\\n  <input v-model=\\\"count\\\" type=\\\"text\\\" @input=\\\"onInput\\\" />\\n</template>\\n\\n<script setup lang=\\\"ts\\\">\\nimport { ref } from 'vue'\\n\\nconst val = ref('')\\nconst count = ref('')\\nfunction onInput(e: Event): void {\\n  console.log('调用了onInput')\\n}\\n</script>\\n```\\n看下最终的效果：\\n\\n![1.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4184e7b3fd9b48459a87d073633a00b1~tplv-k3u1fbpfcp-watermark.image?)\\n\\n差别还是非常明显的。指令已发布[npm仓库](https://www.npmjs.com/package/vue-next-directive)，有需要可自取。\\n\\n## 总结\\n🌹感谢浏览，通过本文你可以了解到以下内容：\\n1. 防抖\\n2. 节流\\n3. Vue3指令开发\\n4. compositionstart 事件 （需要注意浏览器兼容性）\\n5. compositionend 事件（需要注意浏览器兼容性）\\n",
        "tags": [
            "Vue.js",
            "JavaScript",
            "前端"
        ]
    },
    {
        "article_id": "7191378274202124344",
        "cover_image": "",
        "title": "vue中多行(单行)文本溢出才会出现提示的自定义指令",
        "brief": "平时开发中，如果标题超出多行，我们希望出现省略号，并且为其添加简单提示。但是，如果我们在全局写公共class类，行数不好控制。统一加title=xxx，又会出现文本是否超出都会出现title的现象。",
        "user_name": "bqb",
        "view_count": 3413,
        "collect_count": 49,
        "comment_count": 1,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/e40655a4d62c0313136fc23d36050e80~300x300.image",
        "category": "前端",
        "content": "> 平时开发中，如果标题超出多行，我们希望出现省略号，并且为其添加简单提示。但是，如果我们在全局写公共`class`类，行数不好控制。如果统一加`title=xxx`，又会出现文本是否超出都会出现`title`的现象。\\n\\n我们可以利用`vue`中的自定义指令，很方便的实现多行文本溢出和简单提示的效果。\\n```\\n// 以下代码可以直接粘贴进自己的`.vue`文件中查看效果\\n<template>\\n  <div class=\\\"parent\\\">\\n    <h3>标题</h3>\\n    <div class=\\\"child\\\" v-ellipsis=\\\"3\\\">\\n      {{ msg }}\\n    </div>\\n  </div>\\n</template>\\n\\n<script>\\nexport default {\\n  data() {\\n    return {\\n      msg:\\n        \\\"好雨知时节，当春乃发生。随风潜入夜，润物细无声。野径云俱黑，江船火独明。晓看红湿处，花重锦官城。\\\",\\n    };\\n  },\\n  directives: {\\n    ellipsis: {\\n      inserted: function (el, binding) {\\n        // 获取期望的文本行数，默认为1\\n        const n = binding.value || 1;\\n        // （1）实现超出n行有省略号\\n        el.style.display = \\\"-webkit-box\\\";\\n        el.style.webkitBoxOrient = \\\"vertical\\\";\\n        el.style.webkitLineClamp = n;\\n        el.style.overflow = \\\"hidden\\\";\\n        // （2）实现鼠标移入在溢出情况下才有提示文案\\n        if (el.clientHeight < el.scrollHeight) {\\n          el.title = el.innerHTML;\\n        }\\n      },\\n    },\\n  },\\n};\\n</script>\\n\\n<style>\\n.parent {\\n  display: flex;\\n  align-items: center;\\n  width: 200px;\\n  font-size: 12px;\\n  border: 1px solid #aaa;\\n}\\nh3 {\\n  margin-right: 4px;\\n  white-space: nowrap;\\n}\\n</style>\\n```\\n`多行使用方式`：\\n```\\n<div class=\\\"child\\\" v-ellipsis=\\\"3\\\">\\n  {{ msg }}\\n</div>\\n```\\n此时，如果超出`3`行，就会出现`...`和`title`提示文案。\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/81fdaef40c5e4e43b6840654ec0128ea~tplv-k3u1fbpfcp-watermark.image?)\\n\\n`v-ellipsis='3'`就可以实现省略号和超出期望行数后的`title`提示功能。<br>\\n\\n`单行使用方式：`\\n```\\n<div class=\\\"child\\\" v-ellipsis>\\n  {{ msg }}\\n</div>\\n```\\n单行情况可以省略行数，如果超出单行就会出现`...`和`title`的提示文案。\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5f72270511c34fdaa958795c0be4770f~tplv-k3u1fbpfcp-watermark.image?)\\n\\n`v-ellipsis`就可以实现单行溢出并且出现`title`提示的效果。\\n### 写在最后\\n---\\n如果有用，记得点个赞支持一下吆~\\n\\n",
        "tags": [
            "前端",
            "Vue.js",
            "架构"
        ]
    },
    {
        "article_id": "7195198331520286778",
        "cover_image": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e8e4a6c1a22463d9fa0d7b80ccd9c95~tplv-k3u1fbpfcp-watermark.image?",
        "title": "简述 YAML",
        "brief": "YAML是一种数据序列化语言，可让以紧凑且可读的格式存储复杂数据。它对于 DevOps 和虚拟化来说很重要，因为它对于构建高效的数据管理系统和自动化至关重要。虽然经常被开发人员忽视，特别是前端工程师，",
        "user_name": "天行无忌",
        "view_count": 515,
        "collect_count": 1,
        "comment_count": 0,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/ee5b3d33c959244bf7b70b28bb3a4d07~300x300.image",
        "category": "开发工具",
        "content": "YAML是一种数据序列化语言，可让以紧凑且可读的格式存储复杂数据。它对于 DevOps 和虚拟化来说很重要，因为它对于构建高效的数据管理系统和自动化至关重要。虽然经常被开发人员忽视，特别是前端工程师，但它是一个功能强大且简单的工具，掌握后可以大大改善工作方式和效率。\\n\\n本文将快速介绍一下 YAML。\\n\\n### 什么是 YAML？\\n\\nYAML 是一种数据序列化语言，用于以人类可读的形式存储信息。它最初代表 `Yet Another Markup Language`，但后来改为`YAML Ain't Markup Language`，以区别于真正的标记语言。\\n\\n它类似于 `XML` 和 `JSON` 格式 ，但使用更简约的语法，即使同时保持类似的功能。YAML 通常用于在基础架构即代码 (IoC) 程序中创建配置文件或在 DevOps 开发管道中管理容器。\\n\\nYAML 已被用于创建自动化协议，这些协议可以执行 YAML 文件中列出的一系列命令。这意味着系统可以更加独立和响应迅速，而无需额外的开发人员关注。\\n\\n随着越来越多的公司采用 DevOps 和虚拟化，YAML 正迅速成为现代开发人员职位的必备技能。通过使用 PyYAML 库、Docker 等流行技术的支持，YAML 也很容易与现有技术结合。\\n\\n### YAML 与 JSON 与 XML\\n\\n#### YAML（`.yml`）\\n\\n* 人类可读代码\\n* 极简语法\\n* 专为数据而设计\\n* 类似于 JSON 的内联样式（是 JSON 的超集）\\n* 允许评注释\\n* 不带引号的字符串\\n* 被认为是`更干净`的 JSON\\n* 高级功能（可扩展数据类型、关系锚点和保留键顺序的映射类型）\\n\\n在nodejs开发中，结合swagger，可以更好的提供 API 文档。\\n\\n#### JSON\\n\\n* 更难阅读\\n* 明确、严格的语法要求\\n* 类似于 YAML 的内联样式（一些 YAML 解析器可以读取 JSON 文件）\\n* 暂无注释\\n* 字符串需要双引号\\n\\n实例：JSON 在 Web 开发中很受欢迎，因为它最适合序列化格式和通过 HTTP 连接传输数据。\\n\\n#### XML\\n\\n* 更难阅读\\n* 更冗长\\n* 充当标记语言，而 YAML 用于数据格式化\\n* 包含比 YAML 更多的特性，比如标签属性\\n* 更严格定义的文档模式\\n\\n实例： XML 最适合需要对验证、模式和名称空间进行精细控制的复杂项目。XML 不是人类可读的，需要更多的带宽和存储容量，但提供了无与伦比的控制。\\n\\n",
        "tags": [
            "Swagger",
            "Docker",
            "Node.js"
        ]
    },
    {
        "article_id": "7194319078285606973",
        "cover_image": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/24619bbdad1f42faa78f1dc6dba24001~tplv-k3u1fbpfcp-watermark.image?",
        "title": "微信小程序使用canvas生成分享海报功能复盘",
        "brief": "微信小程序生成分享海报简单复盘！使用 canvas 绘制矩形，圆角矩形，文本超出显示省略号，主题切换等。",
        "user_name": "是阿恒呀",
        "view_count": 804,
        "collect_count": 11,
        "comment_count": 5,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/fc91f147957b57a559caea4a11efdbf2~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: juejin\\n---\\n\\n\\n## 前言\\n\\n近期需要开发一个微信小程序生成海报分享的功能。在h5一般都会直接采用 `html2canvas` 或者 `dom2image` 之类的库直接处理。但是由于小程序不具备传统意义的dom元素，所以也没有办法采用此类工具。\\n所以就只能一笔一笔的用 `canvas` 画出来了，下面对实现这个功能中遇到的问题做一个简单的复盘。\\n\\n制作要求：\\n\\n- 主题切换。\\n- 图片弹框展示，适应不同的手机尺寸。\\n- 图片上层有弹出框展示保存图片按钮。\\n- 海报内容，\\n  - 标题部分根据实际内容展示，可能为一行也可能为两行\\n  - 描述部分，最多展示四行，超出的显示成...\\n  - 圆角图片展示\\n  - 圆角虚线框\\n\\n基本方案流程\\n\\n1. 预先加载好所有需要的图片。\\n2. 在偏离视窗显示区域使用 `canvas` 绘制海报，并生成临时文件。\\n3. 弹窗的图片使用 生成的临时图片。\\n4. 设置图片的宽度为适应屏幕的，可通过定位或者`flex`来实现，图片高度根据宽度自动缩放。超出的内容滚动显示。\\n\\n效果图如下：\\n\\n![WechatIMG200.jpeg](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f68124f46b34e8f9547cf41b79ca4bc~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n![yF7fk78Le1z7346f54f4e368f5c483f547611aafa9f4.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb0196ad31cb4a88aad0e9cb3447c645~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## 微信canvas组件的相关问题\\n\\n`canvas` 属于微信客户端创建的原生组件，所以需要注意一些原生组件的限制\\n\\n- 原生组件的层级是最高的，所以页面中的其他组件无论设置 `z-index` 为多少，都无法盖在原生组件上。\\n   - 后插入的原生组件可以覆盖之前的原生组件。\\n- 原生组件还无法在 `picker-view` 中使用\\n- 部分 CSS 样式无法应用于原生组件\\n  - 无法对原生组件设置 CSS 动画\\n  - 无法定义原生组件为 `position: fixed`\\n  - 不能在父级节点使用 `overflow: hidden` 来裁剪原生组件的显示区域\\n\\n所以无法使用 `canvas` 绘制的图片直接用于显示。会遇到层级以及尺寸的问题。\\n\\n## 预加载图片资源\\n\\n在绘制之前我们需要先加载好图片资源并保存。\\n\\n```js\\nfunction create(){\\n    const img1 = preLoadImg(\\\"https:xxxx.img1\\\", 'img1')\\n    const img2 = preLoadImg(\\\"https:xxxx.img2\\\", 'img2')\\n    const img3 = preLoadImg(\\\"https:xxxx.img3\\\", 'img3')\\n\\n    Promise.all([img1, img2, img3]).then(res=>{\\n        // 开始绘制canvas\\n    })\\n}\\n\\n\\nfunction preLoadImg(url, taskId) {\\n\\n    if(this.imageTempPath[taskId]) return Promise.resolve();\\n    \\n    if (!url) return Promise.resolve();\\n\\n    url = /^https/.test(url) ? url : `https:${url}`;\\n\\n    return wx.getImageInfo({src: url}).then((res)=>{\\n        this.imageTempPath[taskId] = res.path;\\n    })\\n}\\n```\\n\\n\\n## 文本处理\\n\\n### 计算不同长度的文本绘制高度\\n\\n对于不同的文本长度，可能存在占一行或者多行的情况，这个时候对于文本以下的内容绘制的 `y` 轴坐标会造成影响。\\n\\n解决方案：先定义好每一个元素在标准情况下的坐标位置，然后对于存在可能有占据空间改变的文本，通过测量其文本宽度，计算出实际占据行数，然后出多出的 `y` 轴位置`(diff)`，并在后续的元素绘制上加上这个差值。\\n\\n基本思路：\\n1. 测量出文本的实际绘制需要的总长度\\n2. 计算出实际绘制多少行\\n3. 计算实际绘制行数与默认行数的高度差\\n\\n计算方法如下：\\n\\n```js\\nfunction getWordDiffDistance(\\n    ctx,        // canvas 上下文\\n    text,       // 要计算的文本\\n    baseline,   // 默认显示行数\\n    lineHeight, // 行高\\n    fontSize,   // 字号\\n    textIndent, // 首行缩进字符\\n    maxWidth,   // 每一行绘制的最大宽度\\n    maxLine     // 最大允许显示行数\\n) {\\n    // 设置上下文的字号\\n    ctx.setFontSize(fontSize);\\n\\n    // 首行缩进的宽度\\n    const textIndentWidth = fontSize * textIndent;\\n     //实际总共能分多少行\\n    let allRow = Math.ceil((ctx.measureText(text).width + textIndentWidth) / maxWidth);\\n\\n    allRow = Math.min(allRow, maxLine);\\n\\n    return (allRow - baseline) * lineHeight;\\n}\\n```\\n\\n\\n> ctx.measureText() 要先设置好文本属性。\\n\\n### 文本超出指定行数后显示 ...\\n\\n基本思路：\\n 1. 设置好 canvas 上下文的文字样式\\n 2. 通过 measureText 计算出当前文本需要绘制多少行\\n 3. 如果是首行且设置了首行缩进，绘制的 x 要加上缩进的宽度\\n 4. 然后计算出每一行要绘制的文字并进行绘制，并记录最后的截取位置\\n 5. 如果最后一行的实际绘制宽度大于设置的最大宽度，添加... 否则正常绘制\\n   \\n```js\\ndealWords(options) {\\n    const {\\n        ctx,\\n        fontSize,\\n        word,\\n        maxWidth,\\n        x,\\n        y,\\n        maxLine,\\n        lineHeight,\\n        style,\\n        textIndent = 0,\\n    } = options;\\n    ctx.font = style || \\\"normal 12px PingFangSC-Regular\\\";\\n\\n     //设置字体大小\\n    ctx.setFontSize(fontSize);\\n\\n     // 首行缩进的宽度\\n    const textIndentWidth = fontSize * textIndent;\\n\\n     //实际总共能分多少行\\n    let allRow = Math.ceil((ctx.measureText(word).width + textIndentWidth) / maxWidth);\\n\\n     //实际能分多少行与设置的最大显示行数比，谁小就用谁做循环次数\\n    let count = allRow >= maxLine ? maxLine : allRow;\\n\\n     //当前字符串的截断点\\n    let endPos = 0;\\n    for (let j = 0; j < count; j++) {\\n        let startWidth = 0;\\n        if (j == 0 && textIndent) startWidth = textIndentWidth;\\n        let rowRealMaxWidth = maxWidth - startWidth;\\n\\n         //当前剩余的字符串\\n        let nowStr = word.slice(endPos);\\n\\n         //每一行当前宽度\\n        let rowWid = 0;\\n        if (ctx.measureText(nowStr).width > rowRealMaxWidth) {\\n            //如果当前的字符串宽度大于最大宽度，然后开始截取\\n            for (let m = 0; m < nowStr.length; m++) {\\n                 //当前字符串总宽度\\n                rowWid += ctx.measureText(nowStr[m]).width;\\n                if (rowWid > rowRealMaxWidth) {\\n                    if (j === maxLine - 1) {\\n                    //如果是最后一行\\n                    ctx.fillText(\\n                        nowStr.slice(0, m - 1) + \\\"...\\\",\\n                        x + startWidth,\\n                        y + (j + 1) * lineHeight\\n                    ); //(j+1)*18这是每一行的高度\\n                    } else {\\n                    ctx.fillText(\\n                        nowStr.slice(0, m),\\n                        x + startWidth,\\n                        y + (j + 1) * lineHeight\\n                    );\\n                    }\\n                    endPos += m; //下次截断点\\n                    break;\\n                }\\n            }\\n        } else {\\n            //如果当前的字符串宽度小于最大宽度就直接输出\\n            ctx.fillText(nowStr.slice(0), x, y + (j + 1) * lineHeight);\\n        }\\n    }\\n}\\n```\\n> 绘制多行文本计算行宽的时候，空白字符可能会对最终的计算结果造成一定影响，所以可以先对其空白字符进行过滤。\\n\\n\\n### 图文对齐\\n\\n微信小程序中通过 `setTextBaseline` 设置文本竖直对齐方式。可选值有 `top`,`bottom`,`middle`,`normal`;\\n\\n![15.set-text-baseline.def44f63.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/daf35d4c77814f98a3acb5d0379cea42~tplv-k3u1fbpfcp-watermark.image?)\\n\\n图片的坐标基点为左上角坐标，所以在绘制的时候要注意 `y` 的起始坐标。如果有修改 文本的对齐方式，在结束的时候最好将文本竖直对齐方式设置为 `normal`,避免影响后续的绘制。\\n\\n## 形状处理 \\n\\n### 绘制圆角矩形路径\\n\\n使用`arc()`方式绘制弧线 \\n\\n![15.3386108-18f319a9517ffcf4.webp](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3812da011fb244b6aadb0e1a32b49362~tplv-k3u1fbpfcp-watermark.image?)\\n\\n```js\\n// 按照canvas的弧度从 0 - 2PI 开始顺时针绘制\\nfunction drawRoundRectPathWithArc(ctx, x, y, width, height, radius) {\\n    ctx.beginPath();\\n    // 从右下角顺时针绘制，弧度从0到1/2PI\\n    ctx.arc(x + width - radius, y + height - radius, radius, 0, Math.PI / 2);\\n\\n    // 矩形下边线\\n    ctx.lineTo(x + radius, y + height);\\n\\n    // 左下角圆弧，弧度从1/2PI到PI\\n    ctx.arc(x + radius, y + height - radius, radius, Math.PI / 2, Math.PI);\\n\\n    // 矩形左边线\\n    ctx.lineTo(x, y + radius);\\n\\n    // 左上角圆弧，弧度从PI到3/2PI\\n    ctx.arc(x + radius, y + radius, radius, Math.PI, (Math.PI * 3) / 2);\\n\\n    // 上边线\\n    ctx.lineTo(x + width - radius, y);\\n\\n    //右上角圆弧\\n    ctx.arc(x + width - radius,y + radius, radius, (Math.PI * 3) / 2, Math.PI * 2);\\n\\n    //右边线\\n    ctx.lineTo(x + width, y + height - radius);\\n    ctx.closePath();\\n}\\n```\\n\\n使用`arcTo()`方式绘制弧线\\n\\n```js\\nfunction drawRoundRectPathWithArcTo(ctx, x, y, width, height, radius) {\\n    ctx.beginPath();\\n\\n    // 上边线\\n    ctx.lineTo(x + width - radius, y);\\n\\n    // 右上弧线\\n    ctx.arcTo(x + width, y, x + width, y + radius, radius)\\n\\n    //右边线\\n    ctx.lineTo(x + width, y + height - radius);\\n\\n\\n    // 从右下角顺时针绘制，弧度从0到1/2PI\\n    ctx.arcTo(x + width, y + height, x + width - radius, y + height, radius)\\n\\n    // 矩形下边线\\n    ctx.lineTo(x + radius, y + height);\\n\\n    // 左下角圆弧，弧度从1/2PI到PI\\n    ctx.arcTo(x, y + height, x, y +height -radius, radius)\\n\\n    // 矩形左边线\\n    ctx.lineTo(x, y + radius);\\n\\n    // 左上角圆弧，弧度从PI到3/2PI\\n    ctx.arcTo(x,y, x+ radius, y, radius)\\n\\n    \\n    ctx.closePath();\\n}\\n```\\n\\n### 背景色填充\\n\\n```js\\nfunction fillRoundRectPath(ctx, x, y, width, height, radius, color){\\n    ctx.save();\\n    this.drawRoundRectPathWithArc(ctx, x, y, width, height, radius);\\n    ctx.setFillStyle(color);\\n    ctx.fill();\\n    ctx.restore();\\n}\\n```\\n\\n### 图片填充\\n\\n```js\\nfunction drawRoundRectImg(ctx, x, y, width, height, radius, img) {\\n    if(!img) return\\n    ctx.save();\\n    this.drawRoundRectPathWithArc(ctx, x, y, width, height, radius);\\n    // 剪切  原始画布中剪切任意形状和尺寸。一旦剪切了某个区域，则所有之后的绘图都会被限制在被剪切的区域内\\n    ctx.clip();\\n    ctx.drawImage(img, x, y, width, height);\\n    ctx.restore();\\n}\\n```\\n\\n### 虚线框\\n\\n```js\\nfunction strokeRoundRectPath(ctx, x, y, width, height, radius) {\\n    this.drawRoundRectPathWithArc(ctx, x, y, width, height, radius);\\n    ctx.strokeStyle = \\\"#DDDDDD\\\";\\n    ctx.lineWidth = 0.5;\\n    ctx.setLineDash([6, 5]);\\n    ctx.stroke();\\n}\\n```\\n\\n## 生成临时图片\\n\\n`wx.canvasToTempFilePath(Object object, Object this)`\\n\\n把当前画布指定区域的内容导出生成指定大小的图片。在 `draw()` 回调里调用该方法才能保证图片导出成功。\\n\\n```js\\nctx.draw(false, async () => {\\n    // canvas画布转成图片并返回图片地址\\n    const { tempFilePath } = await wx.canvasToTempFilePath(\\n        {\\n            x: 0,       // 指定的画布区域的左上角横坐标\\t\\n            y: 0,       // 指定的画布区域的左上角纵坐标\\n            width: posterImg_width,     // 指定的画布区域的宽度\\t\\n            height: posterImg_height,   // 指定的画布区域的高度\\n            destWidth: posterImg_width * pixelRatio, // 输出的图片的宽度 导出大小为 canvas 的 pixelRatio 倍\\n            destHeight: posterImg_height * pixelRatio, // 输出的图片的高度 \\n            canvasId: \\\"posterCanvas\\\",\\n        },\\n        this\\n    );\\n    this.posterTempFilePath = tempFilePath;\\n});\\n```\\n\\n##  不同像素手机的显示适配问题\\n\\n由于只是一张图片的展示，所以显示适配的问题久很好解决。\\n- 设置图片父层容器的侧边距，使容器自动撑开。\\n- 图片宽度设置为 `width:100%`, 设置 `mode=\\\"widthFix\\\"`让图片自动缩放。\\n\\n\\n## 微信本地保存临时图片\\n```js\\nfunction savePoster(tempFilePath) {\\n    wx.saveImageToPhotosAlbum({\\n        filePath: tempFilePath,\\n    }).then(()=> {\\n        wx.showToast({\\n            title: \\\"保存成功\\\", \\n            icon: \\\"success\\\",\\n            duration: 2000,\\n            mask: true, \\n        });\\n    },\\n    (err) => {\\n        wx.showToast({\\n            title: \\\"保存失败\\\",\\n            icon: \\\"none\\\",\\n            duration: 2000,\\n            mask: true,\\n        });\\n    },);\\n}\\n```\\n\\n## 主题切换\\n\\n通过替换不同的背景图片来切换不同的主题。\\n\\n## 参考文章\\n\\n[说说如何使用 Canvas 绘制弧线与曲线](https://www.jianshu.com/p/5afebf4c43f0)\\n\\n[canvas生成分享海报](https://ext.dcloud.net.cn/plugin?id=5149)\\n",
        "tags": [
            "前端",
            "微信小程序",
            "Canvas"
        ]
    },
    {
        "article_id": "7131801252500865055",
        "cover_image": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a116048dd5a9475889469e1e33240bcd~tplv-k3u1fbpfcp-watermark.image?",
        "title": "关于前端低代码的一些个人观点",
        "brief": "2022，低代码彻底火了，甚至火到没有点相关经验，都不好意思出去面试的程度，堪称lowcode“元年”。在整个互联网大裁员的背景下，无论你是否相信它是降本提效的利器，都不重要了。因为行业趋势总是这般浩",
        "user_name": "郑鱼咚",
        "view_count": 73647,
        "collect_count": 592,
        "comment_count": 277,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/5a3703acdec4ac063d1a675e0718863b~300x300.image",
        "category": "前端",
        "content": "2022，低代码彻底火了，甚至火到没有点相关经验，都不好意思出去面试的程度，堪称lowcode“元年”。在整个互联网大裁员的背景下，无论你是否相信它是降本提效的利器，彷佛都不重要了。因为行业趋势总是这般浩浩荡荡，是不以个人意志为转移的。从下图某技术峰会的分享主题中就可见一斑。\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/940410a2c38a4fbab33b85c9ea6f9031~tplv-k3u1fbpfcp-watermark.image?)\\n\\n刚好笔者最近正在开发一个B端低代码的平台。所以，想把这段时间的感悟整理一下与大家分享一些。不过，开头先声明一点，本文只聊观点与感悟，不聊具体技术细节。 \\n\\n## 低代码的产生背景\\n### 互联网产品趋于标准化\\n据我观察，有相当一部分的程序员一提起低代码就摇头say no，表示曾经被这些低代码平台“伤害过”，因为产品需求一旦涉及平台暂不支持的功能，轻则导致加班返工，重则绩效堪忧，甚至丢了工作。  \\n\\n这是一个新事物发展初期必经的一个阶段: 与现有环境水土不服。假如站在更高的角度，设想一下: 当有一天，你的老板宣布，产品经理以后提的需求一律不得超出低代码平台支持的能力范围时，该作何感想。不要轻易说不可能，因为资本的本质就是追逐利润，假如由于这些非标需求额外付出的开发成本，创造不了预期的收益，那对那些试错成本宽容度较低的团队而言，这些需求完全没有存在的必要（回头想一想，你的产品经理提的那些奇奇怪怪且上线没几天就又改回去的需求，你真的认为有价值嘛）。\\n\\n了解点软件外包行业的都知道，很多外包订单都是先copy一个个的模版项目，在之上稍加改动即可交付。因为和他们对接的大部分客户需求都很标准化。比如，客户需要开发一个H5商城，商品、订单、物流再加一个商品运营后台就完全可以满足需求了，甚至不在意UI的样式与竞品一模一样。不过这里也不排除有定制化开发的报价相比完全套模版会高出一大截的因素，但这也至少说明这些非标需求是锦上添花的功能，根本不是刚需。  \\n\\n其实大厂也有这个趋势。毕竟各厂的业务范围越来越出现交叉的态势，产品层面也都是互相copy，真正具有创新性的产品越来越少。C端的产品，尤其在一些大厂充分竞争或者优势的业务领域，因为要追求UI设计、交互、产品体验的差异性，所以相对不容易标准化。比如每年双11的促销各家要紧跟潮流，玩法每年都不尽相同，这种就很难标准化。但大部分的B端产品，对定制化要求不高，随着产品形式的固化，用户已然形成了一套约定俗成的交互习惯。\\n\\n### 应用开发的技术栈趋于成熟\\n就拿前端出活的主力:js框架来说，vue、react虽然还在大版本的迭代，但对整个开发方式的影响，已经不足以与15、16年jQuery到现代框架的那种革命性相提并论了。更多是一些类如更灵活的逻辑拆分、服务端渲染等方面的优化。针对前端开发中的痛点，拆分出的比如构建工具、前端框架、框架之上的UI组件库、跨端等等各个技术领域的边界，也都划分的比较明确了，且发展日趋成熟。这是前端低代码出现的技术背景。\\n\\n## 前端低代码实现\\n笔者对低代码的理解是: 可以通过配置化的低成本交互方式（主流是拖拽）加上少量的一些胶水代码，去满足一类应用的需求。这里笔者以发展更加成熟的B端低代码讲述，C端也是很类似，但是因为样式、动画等定制要求要比B端的复杂许多，所以目前前端低代码相对成熟的应用是在B端。低代码实现原理其实非常简单，就是先预置丰富的原子组件，通过拖拽选择所需组件在画板上进行位置的编排。之后，进行一些组件属性的设置。\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/459ca8c3c44a49139466c34402f012e8~tplv-k3u1fbpfcp-watermark.image?)\\n\\n最终生产出一份jsonSchema或者供开发者二次开发的“源代码”，驱动用户端的内容渲染。原理虽然简单明确，但它也有一些实现难点。比如以下几种：\\n- 一、宏观设计\\n  - 首先设计一个能够面向不同业务场景的低代码项目，是个不小的挑战。\\n    比如一个公司级别的低代码项目，目标是赋能各条业务线。这个就会有一个问题：每个业务对低代码平台的能力要求是不同的，除了大量可复用的功能，肯定也会有不少的定制化需求。甚至各条业务线的产品形态很不一致，有面向C端的，有面向B端的。 \\n    \\n    如果是中心化的思想，一套低代码平台，满足各业务线的需求，首先人力成本很难均摊下去，其次平台随着接入业务线增多，不可避免的会变得臃肿不堪，难以维护。如果每个业务线都独立做一套符合自身业务特性的低代码，这样难度会降低不少，但也意味着公司级别的低代码物料复用变得困难。\\n    讲下业界目前比较流行的解决方案：\\n    1.  在公司级甚至业界推动低代码协议统一。这样就让跨业务甚至业界的物料复用变得可能，阿里前端委员会为此付出了不少努力，大家有空可以了解下。\\n    2.  将低代码架构分层。先有一个低代码基础架构，再用它去“生成”一个个面向具体业务场景的低代码平台。那么如何设计好这个“生成低代码平台的低代码平台”就成为了重中之中。这有点类似于低代码“中台”与“前台”的关系。\\n    \\n   \\n- 二、实现细节\\n    - 1. 状态联动  \\n这个相对好解决一些。 阿里的formily、x-render、jsonschema-form等这些成熟方案的都能够解决，他们之间的差异更多的是在联动性能上，不过这也是在超长表单场景下差距才会比较明显。\\n    - 2. 事件编排  \\n下图就是目前最常见的一种设计，可以配置点击一个button时，要触发哪种类型的事件，事件触发要调用哪些函数，一般都会内置一些比较常见的函数，比如打开一个Modal框等。如果内置不满足需求，就需要插入一些定制化的代码。\\n\\n以下是阿里lowcode-engine的交互设计。\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/584accd7348847f482d068a68432e187~tplv-k3u1fbpfcp-watermark.image?)\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/296f99f9a3db41ceb2009a885ad24301~tplv-k3u1fbpfcp-watermark.image?)  \\n\\n这个平台内置的相对简单。我接触过的内置相对丰富的是[iofod](https://fx.iofod.cn/)这个全场景低代码平台，这里为他们的开发者打个广告。笔者还与他们的开发者加了好友，吃惊的是这么大的工作量竟然是一个人完成的，体验下来比很多公司团队级的产品都用心。 \\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e01743991d5489a83d9b8843cde65ce~tplv-k3u1fbpfcp-watermark.image?)  \\n\\n- 3. 异步数据绑定\\n\\n传统的前端开发大量时间其实是花在与后端接口的对接上，这些工作在目前前端低代码的开发模式中，一点都不会少。\\n\\n如下图，你需要一个表单回填的功能。后端给的详情数据，与前端表单需要的格式差异很大，这里就不得不去手写一个转换函数去解决。\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1eec4409b724353af6ebfd158d0d7b4~tplv-k3u1fbpfcp-watermark.image?)\\n\\n这也是低代码平台大家诟病最多的一点，即：还是需要写代码。但是低代码的价值，从来就不是追求一行代码不写，而是让开发者尽量的少写代码。有人说，我copy代码其实来的更快，而且这功能我开发起来很熟，代码不会有任何问题。但是，你是不是经常在提交cr之后，又悄悄的commit了几个fix呢。最可怕的是测试也觉得这功能很常见，不用细测了，将隐患带上了线。试着回顾一下过往项目的bug列表，是不是很多都是因为不经意的走神或者疏忽造成的。这就是低代码目前就能够解决的一个问题，通过内置一些常见的功能，减少常见功能的开发、测试成本。使大部分功能的交付质量，不依赖于某一个开发者在某一段时间的开发经验、精力及水平。这是笔者认为，现阶段低代码技术的最大价值。\\n\\n## 低代码对行业的影响\\n\\n### 框架、类库的作者也许会喜闻乐见\\n因为之前要面向不同层次的前端开发者，框架、库的作者往往会在API设计时尽量追求友好易懂，但这种追求会在其他方面比如性能方面作出妥协。这就像尤雨溪说的那样，框架开发有时更像是“带着镣铐跳舞”。很多时侯，用起来“爽”与高性能是一件不可兼得的事情，编程语言的发展就是一例，java、python、js等这些高级语言的流行，本质就是通过牺牲一部分的性能，从而提升普通开发者的编程体验。如果未来的前端框架，只面向低代码平台的开发者，而这些开发者的编程水平大概率比较强时，那么API的设计就可以更加贴近框架一侧，这会让这些框架的潜力发挥的更加彻底。\\n\\n## 自上而下的推动最有效\\n下边讲一下前端视角去推广低代码，可能会遇到的问题:  \\n\\n- 前端开发模式换用低代码之后，UI及产品经理如果还是按照原先对你的期待去要求实现效果。这肯定会造成一些难解的冲突与麻烦。他们也许会认为这个开发最近肯定偷懒了。以往像让某个按钮变个颜色，换个位置这种轻而易举就能答应的事情，现在要思索很久或者直接给个此功能无法支持的回复，这显然不符合产品方的利益。    \\n\\n- 前文提到，如果只是前端开发模式换用低代码，而后端的字段约束，返回格式还是像以前那样的随意，肯定会造成低代码平台上需要处理前后端交互兼容的地方越来越多，这就导致可维护性大大降低。有人说这里可以用node做一个BFF层的接口格式转换，但这种方式也只是换了个地方写兼容代码，治标不治本。\\n\\n所以，最理想是整个产研团队一块推动的方式。这样产品、前端、后端、测试整个流程都对低代码平台有一个统一的功能预期，产品不提非标需求，前后端不写非标代码，测试不测非标功能，这样才能更好的发挥低代码的价值。但是，想想好像有哪里不对劲。至于是哪里不对劲？下一段就会讲到。\\n\\n## 会造成失业吗\\n\\n一定会造成一部分失业。是的，笔者对这个问题表现的偏悲观一些，或者说，更理性一些。针对这个问题，我也询问过很多身边的同行，有一部分说根本不会造成程序员失业，他们给出常见理由如下：\\n1. 低代码平台是用来帮助开发者从日常繁琐重复的工作中解放中，去做一些更有价值的事情。是一件双赢的事情，怎么会失业呢？\\n2. 低代码也是需要人力去开发的，本身就会创造一些岗位出来，这会抵消掉由于它的流行所替代的那些HC。\\n3. 低代码太弱了，比如某一个细分领域且复杂的功能就无法实现。   \\n\\n但这里其实存在一个量上的误解。假如团队有10个人，因为换用低代码之后，只需要2-3个人即可搞定日常的开发，那老板就哪怕花费原先6个人的工资去雇佣剩下的2-3个高手程序员，也是一笔划算的“交易”。而且，这已经不单单是我的设想，而是朋友公司里真实发生的事情。  \\n\\n他们公司的技术负责人，高价请了两个架构师，负责低代码平台的开发、维护。后续用5、6k的低薪资去招聘大量的工作内容就是拖拖拽拽的低代码开发者，甚至是无任何编程经验的人员，简单培训之后即可上岗。遇到需要写专业代码或者比较复杂的的场景，就先记录下来，之后让架构师过来解决。\\n\\n至于第三种观点，我认为低代码其实很像自动驾驶的普及。目前司机这个岗位的存在必要，还是因为现阶段的自动驾驶不够完美。当它应对的场景越来越多，甚至超过经验丰富的老司机时，那司机这个岗位就会消失了。当然，另一方面想，这其实也是一件技术进步带来的好事，可以降低事故发生的几率。\\n\\n这些当然还听起来至少不像是近期会发生的事情。作为一名开发者，目前能做的就是，专注于一些真正有价值的事情上，努力提升自己的不可替代性。优秀的编程思想，架构能力永远是稀缺资源。\\n\\n## 不看好目前的低代码创业\\n\\n目前的低代码发展过程中还未出现一些真正的具有壁垒的技术。稍有点研发实力的公司都能做，而且，因为对自己的业务相对更加了解，做出来会更适合公司的实际情况。当然，目前提供低代码服务的很大一部分公司，很多都是之前做企业SASS、PASS的换了个产品名字，他们之前的产品本来就有市场，所以低代码只是一个帮助他们营销的噱头罢了。\\n\\n## 总结\\n低代码一定是有发展前景的，目前在一些特定的企业oa、sass或者标准化的业务场景比如审批流等特定场景下已经取得了不错的应用。  \\n\\n未来已来。你相信与否已变得不再重要，重要的是当你的老板某一天从隔壁老板口里知晓，这世上存在一种不需要写代码，或者只需少量程序员皆可交付应用的开发方式时，一定会至少先让你们试一试。如果真有那么一天，你刚好是CTO或者决策者，一定记得调研完帮兄弟们说一句，不行，这玩意十分不靠谱！\\n",
        "tags": [
            "前端",
            "JavaScript",
            "架构"
        ]
    },
    {
        "article_id": "7173596154297810957",
        "cover_image": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8aa2aed6e8244565884cbf975a57bbcc~tplv-k3u1fbpfcp-watermark.image?",
        "title": "前端录屏+定位源码，帮你快速定位线上bug",
        "brief": "如何快速定位线上bug，是多数开发者都会遇到的难题 web-see 前端监控，提供了前端录屏+定位源码方式，让bug无处藏身",
        "user_name": "海阔_天空",
        "view_count": 15251,
        "collect_count": 534,
        "comment_count": 29,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/855a56c7c01cfae34279302336d4cf15~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: juejin\\nhighlight: androidstudio\\n---\\n\\n## 前言\\n\\n如何快速定位线上bug，是多数开发者都会遇到的难题\\n\\n[web-see](https://github.com/xy-sea/web-see) 前端监控方案，提供了 **前端录屏+定位源码** 方式，让bug无处藏身\\n\\n这是前端监控的第二篇，该篇讲解如何实现错误还原功能，第一篇 [从0到1搭建前端监控平台，面试必备的亮点项目（已开源）](https://juejin.cn/post/7172072612430872584) 没有看过的小伙伴，建议先了解下\\n\\n## 最终效果\\n\\n在监控后台，通过报错信息列表，可以查看具体报错的源码，以及报错时的录屏回放\\n\\n效果演示：\\n\\n![video.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d7cec0ead4704c1eba109c3d64bb98b7~tplv-k3u1fbpfcp-watermark.image?)\\n\\n录屏记录了用户的所有操作，红色的线代表了鼠标的移动轨迹\\n\\n## 定位源码\\n\\n前端项目发布上线，代码一般都会进行压缩、混淆、甚至加密，当线上代码报错时，很难定位到具体的源码\\n\\nSourceMap 完美解决了代码反解的问题，项目在打包时，除了生成最终 `XXX.js` 文件外，还会额外生成一个 `XXX.js.map` 的文件\\n\\n.map 文件里包含了原始代码及其映射信息，可以利用它反解出报错信息的源码\\n\\n### SourceMap 文件\\n\\n先了解下 SourceMap 的基本内容\\n\\n例如 `app.a2a3ceec.js` 代码如下：\\n\\n```\\nvar add=function(x, y){return x+y;};\\n//# sourceMappingURL=app.a2a3ceec.js.map\\n```\\n\\n其中 sourceMappingURL 用来说明该文件对应的map文件\\n\\n对应的 `app.a2a3ceec.js.map` 代码如下：\\n\\n```\\n{\\n  version : 3, // SourceMap标准版本,最新的为3\\n  file: \\\"js/app.a2a3ceec.js\\\", // 转换后的文件名\\n  sourceRoot : \\\"\\\", // 转换前的文件所在目录，如果与转换前的文件在同一目录，该项为空\\n  sources: [ // 转换前的文件，该项是一个数组，表示可能存在多个文件合并\\n    \\\"webpack://web-see-demo/./src/App.vue\\\",\\n    \\\"webpack://web-see-demo/./src/main.js\\\"\\n  ], \\n  names: [], // 转换前的所有变量名和属性名\\n  sourcesContent: [ // 原始文件内容\\n    \\\"const add = (x,y) => {\\\\n  return x+y;\\\\n}\\\"\\n  ],\\n  // 所有映射点\\n  mappings: \\\"AAAA,IAAM,GAAG,GAAG,UAAC,CAAQ,EAAC,CAAQ;IAC5B,OAAO,CAAC,GAAC,CAAC,CAAC;AACb,CAAC,CAAA\\\"\\n}\\n```\\n\\n其中 sources 和 sourcesContent 是关键字段，下文的还原示例中将用到\\n\\n### source-map-js 库\\n\\n代码还原，这里主要使用 [source-map-js](https://www.npmjs.com/package/source-map) 库，下面介绍下如何使用\\n\\n示例代码：\\n\\n```\\nimport sourceMap from 'source-map-js';\\n\\n/**\\n* findCodeBySourceMap用于获取map文件对应的源代码\\n* @param { string } fileName .map文件名称\\n* @param { number } line 发生错误的行号\\n* @param { number } column 发生错误的列号\\n* @param { function } 回调函数，返回对应的源码\\n*/\\nconst findCodeBySourceMap = async ({ fileName, line, column }, callback) => {\\n  // loadSourceMap 用于获取服务器上 .map 的文件内容\\n  let sourceData = await loadSourceMap(fileName);\\n  let { sourcesContent, sources } = sourceData;\\n  // SourceMapConsumer实例表示一个已解析的源映射\\n  // 可以通过在生成的源中给它一个文件位置来查询有关原始文件位置的信息\\n  let consumer = await new sourceMap.SourceMapConsumer(sourceData);\\n  // 输入错误的发生行和列，可以得到源码对应原始文件、行和列信息\\n  let result = consumer.originalPositionFor({\\n    line: Number(line),\\n    column: Number(column)\\n  });\\n  // 从sourcesContent得到具体的源码信息\\n  let code = sourcesContent[sources.indexOf(result.source)];\\n  ……\\n  callback(code)\\n```\\n\\n本小节的[代码仓库](https://github.com/xy-sea/web-see-demo/blob/main/src/utils/sourcemap.js)\\n\\nsource-map 的还原流程：\\n\\n1、从服务器获取指定.map 的文件内容\\n\\n2、new 一个 SourceMapConsumer 的实例，表示一个已解析的源映射，给它一个文件位置来查询有关原始文件位置的信息\\n\\n3、输入报错发生的行和列，可以得到源码对应原始文件名、行和列信息\\n\\n4、从源文件的 sourcesContent 字段中，获取对应的源码信息\\n\\n接下来的重点就变为：如何获取报错发生的原始文件名、行和列信息\\n\\n### error-stack-parser 库\\n\\n通过第一篇文章的介绍，我们知道可以通过多种方式来捕获报错\\n\\n比如 error事件、unhandledrejection事件、vue 中通过Vue.config.errorHander、react中通过componentDidCatch\\n\\n为了消除各浏览器的差异，使用 [error-stack-parser](https://www.npmjs.com/package/error-stack-parser) 库来提取给定错误的原始文件名、行和列信息\\n\\n示例代码：\\n\\n```\\nimport ErrorStackParser from 'error-stack-parser';\\n\\nErrorStackParser.parse(new Error('BOOM'));\\n\\n// 返回值 StackFrame 堆栈列表\\n[\\n    StackFrame({functionName: 'foo', args: [], fileName: 'path/to/file.js', lineNumber: 35, columnNumber: 79, isNative: false, isEval: false}),\\n    StackFrame({functionName: 'Bar', fileName: 'https://cdn.somewherefast.com/utils.min.js', lineNumber: 1, columnNumber: 832, isNative: false, isEval: false, isConstructor: true}),\\n    StackFrame(... and so on ...)\\n]\\n```\\n\\n这里简单说明下 JS 堆栈列表\\n\\n堆栈示例：\\n\\n```\\nfunction c() {\\n  try {\\n    var bar = baz;\\n    throw new Error()\\n  } catch (e) {\\n    console.log(e.stack);\\n  }\\n}\\nfunction b() {\\n  c();\\n}\\nfunction a() {\\n  b();\\n}\\na();\\n```\\n\\n上述代码中会在执行到 c 函数的时候报错，调用栈为 a -> b -> c，如下图所示：\\n\\n![stack.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df327d21999a456dbfc0390ca019e846~tplv-k3u1fbpfcp-watermark.image?)\\n\\n一般我们只需要定位到 c 函数的堆栈信息，所以使用 error-stack-parser 库的时候，只取 StackFrame 数组中的第一个元素\\n\\n最终代码：\\n\\n```\\nimport ErrorStackParser from 'error-stack-parser';\\n\\n// 取StackFrame数组中的第一个元素\\nlet stackFrame = ErrorStackParser.parse(error)[0];\\n// 获取对应的原始文件名、行和列信息，并上报\\nlet { fileName, columnNumber, lineNumber } = stackFrame;\\n```\\n\\n### 示例演示\\n\\n下载 [web-see-demo](https://github.com/xy-sea/web-see-demo) 安装并运行\\n\\n1）点击 **js错误** 按钮，会执行 HomeView.vue 文件中的 codeErr 方法\\n\\ncodeErr的源码为：\\n\\n![codeErr.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d1161baacbf41e792c142eb7daf3081~tplv-k3u1fbpfcp-watermark.image?)\\n\\n2）Vue.config.errorHander中捕获到报错信息为：\\n\\n![length.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ccd49dc7b6c044c19fb86ad995bfe6c7~tplv-k3u1fbpfcp-watermark.image?)\\n\\n3）使用 ErrorStackParser.parse 解析后的stackFrame为：\\n\\n![stackFrame.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3005695c19914239bfce98f604786042~tplv-k3u1fbpfcp-watermark.image?)\\n\\n4）经过 consumer.originalPositionFor 还原后的 result 结果为：\\n\\n![result.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/419738f017e946b2af2e0bd4f6052194~tplv-k3u1fbpfcp-watermark.image?)\\n\\n5）最终拿到的源码：\\n\\n![code.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac9bd0c70154496a872fcfda1dfcc259~tplv-k3u1fbpfcp-watermark.image?)\\n\\n### 流程总结\\n\\n![sourcemap.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/15e69b9ac2c44370adafb627c65ef26a~tplv-k3u1fbpfcp-watermark.image?)\\n\\n如上图所示，定位源码流程总结：\\n\\n1、项目中引入监控 SDK，打包后将js文件发布到服务器上\\n\\n2、将 .map 文件放到指定的地址，统一存储\\n\\n3、当线上代码报错时，利用 error-stack-parser 获取具体原始文件名、行和列信息，并上报\\n\\n4、利用 source-map 从 .map 文件中得到对应的源码并展示\\n\\n## 前端录屏\\n\\nweb-see 监控通过 [rrweb](https://github.com/rrweb-io/rrweb) 提供了前端录屏的功能\\n\\n### rrweb 使用\\n\\n先介绍下在vue中如何使用\\n\\n录制示例：\\n\\n```\\nimport { record } from 'rrweb';\\n// events存储录屏信息\\nlet events = [];\\n// record 用于记录 `DOM` 中的所有变更\\nrrweb.record({\\n  emit(event, isCheckout) {\\n    // isCheckout 是一个标识，告诉你重新制作了快照\\n    if (isCheckout) {\\n      events.push([]);\\n    }\\n    events.push(event);\\n  },\\n  recordCanvas: true, // 记录 canvas 内容\\n  checkoutEveryNms: 10 * 1000, // 每10s重新制作快照\\n  checkoutEveryNth: 200, // 每 200 个 event 重新制作快照\\n});\\n```\\n\\n播放示例：\\n\\n```\\n<template>\\n  <div ref='player'>\\n  </div>\\n</template>\\n<script>\\nimport rrwebPlayer from 'rrweb-player';\\nimport 'rrweb-player/dist/style.css';\\nexport default {\\n   mounted() {\\n     // 将记录的变更按照对应的时间一一重放\\n     new rrwebPlayer(\\n        {\\n          target: this.$refs.player, // 回放所需要的HTML元素\\n          data: { events }\\n        },\\n        {\\n          UNSAFE_replayCanvas: true // 回放 canvas 内容\\n        }\\n     )\\n   }\\n}\\n</script>\\n```\\n\\n### rrweb 原理浅析\\n\\nrrweb 主要由 `rrweb` 、 `rrweb-player` 和 `rrweb-snapshot` 三个库组成：\\n\\n1）rrweb：提供了 record 和 replay 两个方法；record 方法用来记录页面上 DOM 的变化，replay 方法支持根据时间戳去还原 DOM 的变化\\n \\n2）rrweb-player：基于 svelte 模板实现，为 rrweb 提供了回放的 GUI 工具，支持暂停、倍速播放、拖拽时间轴等功能。内部调用了 rrweb 的提供的 replay 等方法\\n\\n3）rrweb-snapshot：包括 snapshot 和 rebuilding 两大特性，snapshot 用来序列化 DOM 为增量快照，rebuilding 负责将增量快照还原为 DOM\\n\\nrrweb 整体流程：\\n\\n1）rrweb 在录制时会首先进行首屏 DOM 快照，遍历整个页面的 DOM 树，转换为 JSON 结构数据，使用增量快照的处理方式，通过 `mutationObserver` 获取 DOM 增量变化，同步转换为 JSON 数据进行存储\\n\\n2）整个录制的过程会生成 unique id，来确定增量数据所对应的 DOM 节点，通过 timestamp 保证回放顺序。\\n\\n3） 回放时，会创建一个 iframe 作为承载事件回放的容器，针对首屏 DOM 快照进行重建，在遍历 JSON 的同时，根据序列化后的节点数据构建出实际的 DOM 节点\\n\\n4）rrweb 可以监听的用户行为包括：鼠标移动，鼠标交互，页面滚动，视窗变化、用户输入等，通过添加相应的监听事件来实现\\n\\n### 压缩数据\\n\\n如果一直录屏，数据量是巨大的\\n\\n实测下来，录制10s的时长，数据大小约为 8M 左右（页面的不同复杂度、用户不同操作的频率都会造成大小不一样）\\n\\n数据如果不经过压缩，直接传给后端，面对大量的用户，需要非常高的带宽做支持。还好，rrweb官方提供了[数据压缩函数](https://github.com/rrweb-io/rrweb/blob/master/docs/recipes/optimize-storage.zh_CN.md)\\n\\n基于 packFn 的单数据压缩，在录制时可以作为 `packFn` 传入\\n\\n```\\nrrweb.record({\\n  emit(event) {},\\n  packFn: rrweb.pack,\\n});\\n```\\n\\n回放时，需要传入 rrweb.unpack 作为 `unpackFn` 传入\\n\\n```\\nconst replayer = new rrweb.Replayer(events, {\\n  unpackFn: rrweb.unpack,\\n});\\n```\\n\\n但是官方提供的压缩方式，是对每个 event 数据单独进行压缩，压缩比不高。实测下来，压缩比在70%左右，比如原来 8M 的数据，压缩后为 2.4M 左右\\n\\n官方更加推荐将多个 event 批量一次性压缩，这样压缩效果更好\\n\\nweb-see 内部使用 **[pako.js](https://www.npmjs.com/package/pako)、[js-base64](https://www.npmjs.com/package/js-base64)** 相结合的压缩方式，实测下来，压缩比为 85% 以上，原来 8M 的数据，压缩后为 1.2M 左右\\n\\n压缩代码示例：\\n\\n```\\nimport pako from 'pako';\\nimport { Base64 } from 'js-base64';\\n\\n// 压缩\\nexport function zip(data) {\\n  if (!data) return data;\\n  // 判断数据是否需要转为JSON\\n  const dataJson = typeof data !== 'string' && typeof data !== 'number' ? JSON.stringify(data) : data;\\n  // 使用Base64.encode处理字符编码，兼容中文\\n  const str = Base64.encode(dataJson);\\n  let binaryString = pako.gzip(str);\\n  let arr = Array.from(binaryString);\\n  let s = '';\\n  arr.forEach((item) => {\\n    s += String.fromCharCode(item);\\n  });\\n  return Base64.btoa(s);\\n}\\n```\\n\\n解压代码示例：\\n\\n```\\nimport { Base64 } from 'js-base64';\\nimport pako from 'pako';\\n\\n// 解压\\nexport function unzip(b64Data) {\\n  let strData = Base64.atob(b64Data);\\n  let charData = strData.split('').map(function (x) {\\n    return x.charCodeAt(0);\\n  });\\n  let binData = new Uint8Array(charData);\\n  let data = pako.ungzip(binData);\\n  // ↓切片处理数据，防止内存溢出报错↓\\n  let str = '';\\n  const chunk = 8 * 1024;\\n  let i;\\n  for (i = 0; i < data.length / chunk; i++) {\\n    str += String.fromCharCode.apply(null, data.slice(i * chunk, (i + 1) * chunk));\\n  }\\n  str += String.fromCharCode.apply(null, data.slice(i * chunk));\\n  // ↑切片处理数据，防止内存溢出报错↑\\n  const unzipStr = Base64.decode(str);\\n  let result = '';\\n  // 对象或数组进行JSON转换\\n  try {\\n    result = JSON.parse(unzipStr);\\n  } catch (error) {\\n    if (/Unexpected token o in JSON at position 0/.test(error)) {\\n      // 如果没有转换成功，代表值为基本数据，直接赋值\\n      result = unzipStr;\\n    }\\n  }\\n  return result;\\n}\\n```\\n\\n### 何时上报录屏数据\\n\\n一般关注的是，页面报错的时候用户做了哪些操作，所以目前只把报错前10s的录屏上报到服务端\\n\\n如何只上报报错时的录屏信息呢 ？\\n\\n1）window上设置 hasError、recordScreenId 变量，hasError用来判断某段时间代码是否报错；recordScreenId 用来记录此次录屏的id\\n\\n2）当页面发出报错需要上报时，判断是否开启了录屏，如果开启了，将 hasError 设为 true，同时将 window 上的 recordScreenId，存储到此次上报信息的 data 中\\n\\n3）rrweb 设置10s重新制作快照的频率，每次重置录屏时，判断 hasError 是否为 true（即这段时间内是否发生报错），有的话将这次的录屏信息上报，并重置录屏信息和 recordScreenId，作为下次录屏使用\\n\\n4）后台报错列表，从本次报错报的data中取出 recordScreenId 来播放录屏\\n\\n录屏的代码示例：\\n\\n```\\nhandleScreen() {\\n try {\\n  // 存储录屏信息\\n  let events = [];\\n  record({\\n    emit(event, isCheckout) {\\n      if (isCheckout) {\\n        // 此段时间内发生错误，上报录屏信息\\n        if (_support.hasError) {\\n          let recordScreenId = _support.recordScreenId;\\n          // 重置recordScreenId，作为下次使用\\n          _support.recordScreenId = generateUUID();\\n          transportData.send({\\n            type: EVENTTYPES.RECORDSCREEN,\\n            recordScreenId,\\n            time: getTimestamp(),\\n            status: STATUS_CODE.OK,\\n            events: zip(events)\\n          });\\n          events = [];\\n          _support.hasError = false;\\n        } else {\\n          // 不上报，清空录屏\\n          events = [];\\n          _support.recordScreenId = generateUUID();\\n        }\\n      }\\n      events.push(event);\\n    },\\n    recordCanvas: true,\\n    // 默认每10s重新制作快照\\n    checkoutEveryNms: 1000 * options.recordScreentime\\n  });\\n```\\n\\n### 支持 canvas 录屏\\n\\n演示示例：\\n\\n![canvas.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2a49f1a513b4fc7a5437d81747bdf61~tplv-k3u1fbpfcp-watermark.image?)\\n\\n录屏中可以显示页面中的 canvas 图形，以及鼠标悬浮时的图形提示信息\\n\\nrrweb配置如下：\\n```\\nnew rrwebPlayer({\\n    target: document.getElementById('canvas'),\\n    props: {\\n      events: result,\\n      // 回放时开启回放 canvas 内容\\n      UNSAFE_replayCanvas: true\\n    }\\n});\\n```\\n\\nrrweb [官方配置](https://github.com/rrweb-io/rrweb/blob/master/docs/recipes/canvas.zh_CN.md) 如下：\\n\\n![Canvas.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f6108f834bf14d3384a866a4b013d17e~tplv-k3u1fbpfcp-watermark.image?)\\n\\n[测试demo](https://github.com/xy-sea/blog/tree/dev/rrweb) 如下：\\n\\n![echart.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e2dc3784c5e4b22a60a4ff12505793f~tplv-k3u1fbpfcp-watermark.image?)\\n\\n感谢@千山暮雪c 的指导，搞懂了rrweb中关于Canvas的配置 😘😘\\n\\n## 总结\\n\\n前端录屏+定位源码，是目前比较流行的错误还原方式，对于快速定位线上bug大有裨益\\n\\n这两篇文章只是关于前端监控的入门级介绍，其中可以深挖的点还有很多，欢迎小伙们多多讨论与交流 💕\\n\\n最后推荐一篇阿里前端监控负责人的专题演讲：[《大前端时代前端监控的最佳实践》](https://mp.weixin.qq.com/s/YiKRY_LDURY0uONtEhkUfg)，了解下前端监控的天花板有多高 🌸\\n\\n天冷了，别忘了穿秋裤撒\\n\\n<img src=\\\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e21d5e53654e4e56b3f929b3db7ca2b6~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"cool.jpg\\\" width=\\\"30%\\\" />\\n",
        "tags": [
            "前端",
            "JavaScript",
            "监控"
        ]
    },
    {
        "article_id": "7169228978559926285",
        "cover_image": "",
        "title": "3天3定制大屏，反向PUA",
        "brief": "摘要     本次分享一段无讨价还价余地的单人3天定制化大屏全过程（强调说拖拽屏的请绕道,和你想的不一样）,要动效、要地图、要流光。天坑的心理博弈到最终解决的过程及技术思路。 前因      没啥征兆",
        "user_name": "沈二到不行",
        "view_count": 3874,
        "collect_count": 50,
        "comment_count": 11,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/328f88bdfcc9cf39e32b9f936a80d0fb~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: vuepress\\n---\\n# 摘要\\n &ensp;&ensp;&ensp;&ensp;本次分享一段无讨价还价余地的单人3天**定制化大屏**全过程（强调说拖拽屏的请绕道,和你想的不一样）,要动效、要地图、要流光。天坑的心理博弈到最终解决的过程及技术思路。\\n# 前因\\n   &ensp;&ensp;&ensp;&ensp; 没啥征兆突然接到说，要在下周完成2个大屏的定制开发,起初没提有动效,定时器等等内容的要求,只是说要根据美工的设计完成相关内容，并不觉得有啥难度，周末突发指令,要3D要3个大屏,给我顿时整傻了,挡了3d的无理要求,拗不过加码,3个大屏又附加了动效、定时器、翻牌器，流光等效果。\\n     <br/>&ensp;&ensp;&ensp;&ensp;总之是能动的都要动,经过一番心态炸裂的心理建设后，👽推掉了其他开发任务，对你没看错，还有3项任务排着队，（安安静静的写代码都是个奢望）,周末为了缓解惆怅,试着找了找合适能加速开发过程的组件(主要是效果类),到此处可能会有人吐槽，模板多如牛毛找个模板不香嘛，此处补充一下，未定制稍微好说一些,定制的和常规的模板兼容可能还没手写的快,因此着重找了组件。\\n# 过程\\n&ensp;&ensp;&ensp;&ensp; 可能是机缘到了运气好,顺手就找了一个符合要求的组件[Vue 大屏数据展示组件库](http://datav.jiaminghi.com/guide/#%E5%88%9B%E5%BB%BAvue%E9%A1%B9%E7%9B%AE),想要的装饰、边框、翻牌器、排名轮播等都有,基本把动效问题解决了一大半,剩下的主要就是地图、图表及内容布局、定时器、数据流调整。\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/57a3d6d4ae6b4cc48f7f7a9144171543~tplv-k3u1fbpfcp-watermark.image?)\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d80760f7bfc448389901494b7cd9dc6~tplv-k3u1fbpfcp-watermark.image?)\\n- 💪 合适的工具找到了,因为内容多,尽量提取卡片等边框组件化,某些可能有标题或者无标题,边框样式不同等,随时写随时加入参兼容,我的步骤是第一个尽量抽组件,第二个兼容扩展组件,第三个基本就不费什么时间了。\\n- 💪 解决布局问题,Layout每个UI组件基本都有,但有个问题需注意flex布局问题尽量先搞定**gutter栅格间隔**,的原理再去处理,避免随意的padding或者margin造成的时间浪费。\\n- 💪 echarts之前的社区貌似是被关闭了,很多老哥可能没有找到社区案例的地址，[补充一下](https://www.makeapie.cn/echarts_3.html?queryStr=svg) 地图功能大略和以下差不多，主要就是SVG加载原理加上元素数据的组件。\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/044fdf2eb7be4307b0ba9adfaf00e423~tplv-k3u1fbpfcp-watermark.image?)\\n- 💪定时器相关的内容，主要是每个区块触发的时间点要区分,因此存在很多的定时任务,关闭时容易遗漏，因此简单做了处理,销毁时统一销毁\\n```js\\n/**\\n * 调度器\\n */\\nexport default class dispatcher {\\n  constructor() {\\n    this.watcher = [];\\n  }\\n  startNew(callBack, timer) {\\n    var timer = setInterval(callBack, timer);\\n    this.watcher.push(timer);\\n  }\\n  destroyed() {\\n    //移除\\n    for (let index = 0; index < this.watcher.length; index++) {\\n      const element = array[index];\\n      clearInterval(element);\\n    }\\n  }\\n}\\n\\n```\\n- 💪 数据流的处理,之前在文章里面吐槽了单端的问题，因此即便是前期的模拟数据，我也习惯梳理好数据流以待后来适配，并不会因为时间问题随意去搞,避免加重后期的工作量。\\n- 💪 最后初步成型后的好处，逐步反哺体现，细化的部分基本轻松就进行了调整,但你以为用组件就完了嘛，以上的组件原理很好，一些不太归纳的svg动画处理成组件后,的的确确增加了便捷性,但**定制**二字不是说说而已,还是得继承重写,重新定义部分动画。\\n- 💪 至此逐步进入尾声，也顺利完成和美工的切磋，**加班？开玩笑吧，兽人永不为奴！！**，至于后两天的时间，是专门挤出来给领导提意见修改的，**“唉，卑微的程序猿！！”**\\n# 题外话\\n   &ensp;&ensp;&ensp;&ensp; 行业及职业焦虑就像波光粼粼的水面，哪怕微风一吹,也会震颤不止，外加本段工作沉下来，且情况复杂，越来越发现做软件的特质跟人的问题相关性很强,注定 **“江湖只能孤身一人”**,正好又是世界杯，之前有讨论,说是中国团队项目对比“乒乓球”和“足球”,**英雄主义**特质明显,但一直在强调团队协作,工作里面这几年听到最多的是依旧是**和人打交道最难**，我的焦虑又在烦躁不堪的时候突然冒出头来。\\n   <br/>&ensp;&ensp;&ensp;&ensp; 之后,经历了一些事,又找到一个方向，疫情结束后的方向，在结束前是不是应该预测准备一些东西，于是，内心又莫名的斗志满满，也许焦虑的源头本质就是失去方向,对未来失去斗志和信心才反复的吧。\\n   \\n   ***本文正在参加[「金石计划 . 瓜分6万现金大奖」](https://juejin.cn/post/7162096952883019783 \\\"https://juejin.cn/post/7162096952883019783\\\")***\\n",
        "tags": [
            "掘金·金石计划",
            "Vue.js",
            "前端"
        ]
    },
    {
        "article_id": "7185501830040944698",
        "cover_image": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f2058bf2d1b0420ba9418faf4fec8291~tplv-k3u1fbpfcp-watermark.image?",
        "title": "console.log 一定会导致内存泄漏？不打开 devtools 就不会",
        "brief": "昨天的文章通过 Performance 和 Memory 工具证明了打开 devtools 的时候 console.log 会有内存泄漏。 有 console.log 的时候，内存是这样的： 去掉之后",
        "user_name": "zxg_神说要有光",
        "view_count": 9952,
        "collect_count": 67,
        "comment_count": 27,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/4e9e751e2b32fb8afbbf559a296ccbf2~300x300.image",
        "category": "前端",
        "content": "[昨天的文章](https://juejin.cn/post/7185128318235541563)通过 Performance 和 Memory 工具证明了打开 devtools 的时候 console.log 会有内存泄漏。\\n\\n有 console.log 的时候，内存是这样的：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8675af65e0394403ad46dd3fedb42e3c~tplv-k3u1fbpfcp-watermark.image?)\\n\\n去掉之后是这样的：\\n\\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a884087e19804e5a9533f2ef47c8501f~tplv-k3u1fbpfcp-watermark.image?)\\n\\n我们得出结论，console.log 会导致内存泄漏。\\n\\n这点没错。\\n\\n但很多同学会有疑问，是不是因为打开 devtools 才有内存泄漏，不打开就不会呢？\\n\\n这个我测试了一下：点击几次按钮，这时候应该调用了 console.log 打印了，然后我过了 10 分钟，确保执行过 gc 了，再打开控制台，依然是可以看到那个对象的详情的。\\n\\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/82ee19afbf30422bb0612d8d1e2082b0~tplv-k3u1fbpfcp-watermark.image?)\\n\\n这说明打印的对象没有被 gc，不然怎么还可以看到详情呢？\\n\\n于是我得出结论，不打开 devtools 也是有内存泄漏的。\\n\\n但我今天换了种测试方法，貌似不打开 devtools 时 console.log 是没有内存泄漏的。\\n\\n不打开 devtools 怎么确定内存泄漏问题呢？\\n\\n看下内存大小不就知道了？\\n\\n通过 performance.memory.totalJSHeapSize 是可以拿到堆内存大小的。\\n\\n我们通过分析 console.log 的代码执行后的堆内存大小变化就行。\\n\\n也就是这样：\\n\\n```html\\n<!DOCTYPE html>\\n<html lang=\\\"en\\\">\\n<body>\\n    <button id=\\\"btn\\\">点我</button>\\n    <div id=\\\"box\\\"></div>  \\n    <script>\\n        const btn = document.getElementById('btn');\\n        const box = document.getElementById('box');\\n\\n        btn.addEventListener('click', function() {\\n            const MB = 1024 * 1024;\\n            log();\\n\\n            function log() {\\n                const memory = performance.memory.totalJSHeapSize;\\n                const usagedMemory = Math.floor(memory / MB);\\n                box.insertAdjacentHTML('beforeend', `<span>${usagedMemory} </span>`);\\n\\n                const obj = {usagedMemory, str: 'g'.repeat(50 * MB)};\\n                console.log(obj); \\n\\n                setTimeout(() => log(), 50);\\n            }\\n        });\\n    </script>\\n</body>\\n</html>\\n```\\n\\n按钮点击的时候，拿到当前堆内存的大小。然后打印一个大字符串和堆内存大小。\\n\\n因为我们看不到控制台，所以也会加到 dom 中来显示。\\n\\n通过定时器不断的执行这样的操作。\\n\\n我们先打开 devtools 测试下：\\n\\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e4bf7f9187004061a47b4391c1415597~tplv-k3u1fbpfcp-watermark.image?)\\n\\n可以看到每次打印后内存都在增长，并且在内存达到 4G 的时候就崩溃了。\\n\\n说明 console.log 确实存在内存泄漏。\\n\\n那我们再关掉 devtools 测试下：\\n\\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/264efe34ca984abda4ad654081a70e5c~tplv-k3u1fbpfcp-watermark.image?)\\n\\n内存一直稳定不变，说明函数执行完之后，作用域销毁，打印的对象就被销毁了，没有内存泄漏。\\n\\n我们过程中打开 devtools 测试下：\\n\\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/26dcb75a85d54c218628acc20d52325f~tplv-k3u1fbpfcp-watermark.image?)\\n\\n可以看到一打开 devtools，再次执行 console.log 的时候，内存就增长了，说明这时候内存泄漏了。\\n\\n那如果我先打开 devtools，然后再关掉呢？\\n\\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d5324973da8c4ce38e877cdeac7cf887~tplv-k3u1fbpfcp-watermark.image?)\\n\\n可以看到，只要关闭了 devtools，内存就稳定了。但之前打印的对象依然被引用着，那部分内存不会被释放。\\n\\n这样，我们就可以得出结论：**不打开 devtools 的时候，console.log 不会内存泄漏。**\\n\\n（但我感觉我之前的测试方式也没错呀，不知道哪里有问题）\\n\\n还有同学问，那如果直接打印字符串呢？\\n\\n我们直接打印字符串试一下：\\n\\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad3b477d2df747f699eca9da161a56d4~tplv-k3u1fbpfcp-watermark.image?)\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6417ec409a6344a8a68c5e5aeabf6cf8~tplv-k3u1fbpfcp-watermark.image?)\\n\\n可以看到，内存也是平稳的。\\n\\n为什么呢？字符串不也是对象、可以看到详情的吗？\\n\\n这是因为字符串比较特殊，有个叫做常量池的东西。\\n\\n录制一下内存快照：\\n\\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a921bcba93c74ad6943a04fc71c391db~tplv-k3u1fbpfcp-watermark.image?)\\n\\n看一下字符串占用的内存：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20d027ee350b420e8e1eb97806beba55~tplv-k3u1fbpfcp-watermark.image?)\\n\\n是 @91 的地址。\\n\\n我过了一段时间再录制了一次快照，依然只有一个字符串，地址是 @91。\\n\\n这就是字符串常量池的作用，同样的字符串只会创建一次，减少了相同字符串的内存占用。\\n\\n但 string 还有另一种创建方式：new String\\n\\n这种方式就不一样了：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d030f75174aa42b79a24ea2eb4fcaa65~tplv-k3u1fbpfcp-watermark.image?)\\n\\n这时候创建的是一个堆中的对象，然后引用了常量池中的 string。\\n\\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cdf00dda30e64e72903022491be41058~tplv-k3u1fbpfcp-watermark.image?)\\n\\n这也是为啥字符串字面量是 string，而 new String 是 object：\\n\\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc373996c17f48dfb68e5c4cfe7c466f~tplv-k3u1fbpfcp-watermark.image?)\\n\\n因为会不断在堆中创建对象，所以这时候 console.log 的内存泄漏依然会使堆内存上升：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9fe7838f922b4188bfbb3d210bc2692c~tplv-k3u1fbpfcp-watermark.image?)\\n\\n那 node.js 的 console.log 有没有内存泄漏呢？\\n\\n我们也用同样的方式测试下就好了，只是这时候拿到内存数据是用 progress.memoryUsage() 的 api：\\n\\n```javascript\\nconst MB = 1024 * 1024;\\n\\nlog();\\n\\nfunction log() {\\n    const memory = process.memoryUsage().heapUsed\\n    const usagedMemory = Math.floor(memory / MB);\\n\\n    const obj = { usagedMemory, obj: 'g'.repeat(50 * MB) };\\n    console.log(obj); \\n\\n    setTimeout(() => log(), 50);\\n}\\n```\\n\\n执行一下：\\n\\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f19f72ef028542b5a0794d611bbb2bd2~tplv-k3u1fbpfcp-watermark.image?)\\n\\n可以看到内存是稳定的，并不会内存泄漏。\\n\\n这是因为 node 打印的是序列化以后的对象，并不是对象引用。\\n\\n## 总结\\n\\nconsole.log 在 devtools 打开的时候是有内存泄漏的，因为控制台打印的是对象引用。但是不打开 devtools 是不会有内存泄漏的。\\n\\n我们通过打印内存占用大小的方式来证明了这一点。\\n\\nstring 因为常量池的存在，同样的字符串只会创建一次。new String 的话才会在堆中创建一个对象，然后指向常量池中的字符串字面量。\\n\\n此外，nodejs 打印的是序列化以后的对象，所以是没有内存泄漏的。\\n\\n所以，生产环境也是可以用 console.log 的，没有内存泄漏问题。\\n\\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c87b695d8e064b1397473c793c481907~tplv-k3u1fbpfcp-watermark.image?)\\n\\n",
        "tags": [
            "前端",
            "JavaScript",
            "Node.js"
        ]
    },
    {
        "article_id": "7155354834877546532",
        "cover_image": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9570e5b115684a44bc4abc82104515a6~tplv-k3u1fbpfcp-watermark.image?",
        "title": "webpack热更新原理-隔壁屋阿珍都看懂了",
        "brief": "前端进阶的必看的模块热更新原理。了解hmr的运行机制，有助于对我们项目运行原理的理解，对项目优化有新的认知~",
        "user_name": "世杰是真狗",
        "view_count": 2561,
        "collect_count": 54,
        "comment_count": 6,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/b6daa5245d28d1baa2bec8cbbceb8e77~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: fancy\\n---\\n\\n## 前言\\n\\n>在旧开发的时代，前端项目在开发的过程中修改代码，很有可能是手动切到浏览器刷新页面来看到改动效果。操作不方便且页面之前的编辑记录也都丢失，体验可以说为0。想象一下一个表达你努力填满了所有输入项，结果因为调了一下样式就丢失了所有输入内容，你的心情如何？\\n\\n随后变出现live reload自动刷新，解决了手动切的尴尬操作但页面的状态问题仍未解决。\\n\\n随着前端工程化的推进，HMR（Hot Module Replace）热模块替换的技术的出现急不可耐，我们可以很简单的配置便能感受这优雅的开发体验。>\\n\\n下面就让我们一起分析HMR是如何工作的吧！\\n\\n## 什么是浏览器的热更新？\\n\\n什么是浏览器的热更新？有些同学可能认为是保存自动编译、或者是自动刷新浏览器就叫热更新；又或者代码能够热替换就是热更新。\\n\\n这些说的都对，但不全面。浏览器热更新技术严格的讲，指的是我们开发时能够在浏览器页面中实时看到我们代码的变化产生效果的流程。热更新技术包含了监听本地文件、增量编译构建、代码热替换、socket通信等技术点。\\n\\n## HMR最简单的理解\\n\\n相信你已经或多或少看到过一些监听开发代码改动，浏览器与静态服务器socket通信的一些HMR相关点。\\n\\n\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d936539374a34f92be30850f78eef626~tplv-k3u1fbpfcp-watermark.image?)\\n\\n这个图描绘了大致的工作原理。能够帮助你站在更高的角度去俯视这个过程中的流转、以及关键角色。\\n接下来就是对其中的流程一步一步进行剖析。\\n\\n## HMR流程原理\\n\\n### 先了解webpack热更新的重要插件\\n\\n- webpack-dev-server\\n- webpack-dev-middleware\\n- webpack-hot-middleware\\n\\n这里可能有很多同学会混淆这几个插件的作用。\\n\\n首先来看`webpack-dev-middleware`插件,他最主要是能够将webpack编译产物提交给服务器，并且他将产物放置在内存中【这也是为啥我们在开发过程中在文件夹中找不到我们的打包代码】;\\n\\n而`webpack-hot-middleware`插件则提供热更新的能力【通过使用webpack提供的热更新API实现，所以背后干活的还是webpack】；*这个插件在新版本中似乎已经不再需要了*\\n\\n 这两个插件一般都是配套使用的，以提供完整的热更新能力。\\n \\n而`webpack-dev-server`是【node-express[启动服务] + webpack-dev-middleware + webpack-hot-middleware】的集成封装，有了他，你就可以方便的启动一个具有热更新功能的本地服务器。不用你自己手写什么`let app = new express();app.listen(8080);`这样的启动服务代码了。\\n\\n再补充一些知识点：\\n\\n- webSocket：长连接双向通信【让服务器与浏览器连接起来，方便通信】\\n- webpack的构建可以选择watch模式，他自身已经具备了监听文件变化，持续构建的能力。但还未有将自动刷新客户端的能力，并且对新构建的文件未有进行热替换的能力。\\n- 而webpack-dev-server则是提供自动刷新客户端的能力，他启动一个静态资源托管服务器，客户端访问该服务器，并且通过socket与客户端长连接以便在新构建后通知到客户端进行更新\\n- 而webpack内置插件HotModuleReplacement.plugin插件则是提供热替换的能力：在客户端拿到新代码后，将新代码与旧代码替换\\n\\n*tips: webpack热更新的过程中涉及到比较多的角色，一定要区分好各个角色在过程中发乎着不同的作用。*\\n\\n\\n**让我们运行`npm run serve`，开始分析这个过程吧！**\\n\\npackage.json\\n\\n```js\\n...\\n  \\\"scripts\\\": {\\n    \\\"build\\\": \\\"webpack\\\",\\n    \\\"serve\\\": \\\"webpack-dev-server\\\"\\n  },\\n...\\n```\\n\\n### 第一阶段：初始化环境\\n\\n\\n兜兜转转便来到了`webpack-dev-server/lib/Server.js`\\n\\n`webpack-dev-server`做了非常关键的3个动作：\\n- 启动静态服务器\\n- 开通长连接\\n- 为打包产物注入HMR代码【使得客户端具备热更新能力】\\n\\n启动静态服务器、开通长连接这两个动作很好理解，也可以对应上图去理解。\\n那么【 为打包产物注入HMR代码【使得客户端具备热更新能力】是啥意思呢？\\n\\n想象一下，当你的代码在浏览器运行的时候，怎么跟服务器进行长连接呢？这部分代码你肯定是没有写过。这是由webpack-dev-server插件注入到我们产物代码中的。此外除了长连接代码，还有热更新的代码替换等代码都是要被注入的。\\n\\n**我们来看看插件是如何在我们的产物中注入代码的？**\\n\\n过程比想象的要简单，通过在我们的webpack入口entry中新增文件，在webpack进行构建的时候从entry开始顺藤摸瓜组织代码便一同打包进来。\\n\\n我们可以看到注入了两个文件：\\n- webpack-dev-server/client 【socket管理】\\n- webpack/hot/dev-server 【热更新能力】\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d607b761a1546f1931884decfbeb64a~tplv-k3u1fbpfcp-watermark.image?)\\n假如你想写个代码弄崩你们项目，是不是可以考虑写个无限递归的代码用这种代码注入的方式去执行呢。这样一来排查就相对困难啦，到时候再化身救火秃神！想想都觉得厉害。\\n\\n<img src=\\\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8a0fe483a5742e5aea021bf54de11c5~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\" width=\\\"30%\\\" />\\n\\n紧接着构建过程以compiler.watch()的方式运行，这种模式下打包完不会结束掉打包进程，而是持续运行，监听文件变化后进行增量构建【前面有提到这是webpack的能力之一】。一般`npm run build`的方式就是执行compiler.run()打包一次就结束了。\\n\\ncompiler.watch()构建后的产物通过webpack-dev-middleware插件提交到服务器。\\n\\n而webpack提供的持续监控文件变化的能力是基于node的fs.watch()实现的。他的原理是通过轮询文件的修改时间比对去判断该文件是否发生变化。\\n\\n至此我们的项目处于一种运行的状态，能够对代码改动触发增量构建并更新到服务器。\\n\\n以上的过程可以理解为 环境初始化阶段。\\n\\n### 第二阶段：客户端热更新\\n\\n接着我们打开一个浏览器访问：localhost:XXX时，就能够访问到我们的页面。\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f80edfdc85949149c3e6c70729a5ad5~tplv-k3u1fbpfcp-watermark.image?)\\n\\n我们可以看到浏览器已经跟服务器进行了长连接。\\n\\n先来看看我们的项目代码：\\n\\n入口文件index.js  // 导入writeA.js并处理writeA.js的热更新逻辑\\n\\n```js\\nimport './writeA'\\nif(module.hot) {\\n    module.hot.accept('./writeA.js', () => {\\n        console.log('index.js 捕获到writeA.js的变化...');\\n        let writeAEl = document.getElementById('ttt');\\n        if(writeAEl) {\\n            writeAEl.parentNode.removeChild(writeAEl)\\n        }\\n    })\\n}\\n```\\nwriteA.js  // 给body插入元素\\n\\n```js\\nlet myElement = document.createElement('div')\\nmyElement.innerText = 'writeA.js 123456'\\nmyElement.id = 'ttt'\\ndocument.body.appendChild(myElement);\\nconsole.log('writeA.js run...');\\n```\\n代码很简单，module.hot.accept的意思就是捕获writeA.js的改动，如果他改动了就触发逻辑。module.hot.accept的触发时机会在后面提到。\\n\\n然后修改writeA.js文件并保存，可以看到浏览器请求了两个文件：\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2bc9699fb1a748ec82d65037a58e03c4~tplv-k3u1fbpfcp-watermark.image?)\\n\\n在修改文件后，触发webpack增量构建【只构建了writeA.js模块，所以速度极快】，当构建结束后会提交到服务器，服务器通过socket通知给浏览器，浏览器收到通知后下载更新文件，下载后对文件进行热替换。大概就是这么一个过程。\\n\\n这里补充一个知识点：如何知道构建结束并调用socket通知浏览器的？\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/24b42f59bb2c4d18b1566619e4523c75~tplv-k3u1fbpfcp-watermark.image?)\\n\\n代码层面也很好理解，`webpack-dev-server`插件监听`hooks.done`【这里需要你对webpack的`tapable`机制有一定了解，类似于发布订阅模式，当编译完成就会触发钩子`hooks.done`,插件可以监听钩子做自己的逻辑】，触发则调用socket发送消息给客户端，此时会把本次构建生成的hash一起传给客户端。\\n\\n这里重点关注浏览器收到这个构建hash后的动作，也是热更新过程的重中之重。\\n\\n客户端socket收到hash消息后，先将hash值保存起来。再收到ok消息后调用`reloadApp()`\\n\\n伪代码：\\n\\n```js\\n// 路径 webpackd-dev-server/client/reloadApp.js\\nreloadApp() {\\n  if(hot) {\\n      hotEmitter.emit(\\\"webpackHotUpdate\\\", hash); // 走这里\\n  }esle {\\n      window.location.reload()\\n  }\\n}\\n```\\n\\n发出一个通知事件`hotEmitter.emit(\\\"\\\"webpackHotUpdate)`,这时候`webpack/hot/dev-server.js`【这个文件是上面提到被注入到客户端的代码】监听到该事件：\\n\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a1722969ec846f79045e95fe4365f14~tplv-k3u1fbpfcp-watermark.image?)\\n\\n他最主要要是执行了`module.hot.check()`函数，那个这个函数又是哪里来的？\\n这是`webpack/lib/hmr/HotModuleReplacement.runtime.js`在构建的过程中给module对象添加hot属性，对应上面webpack-dev-server插件的能力：为打包产物注入HMR代码。\\n\\n`module.hot.check`函数调用`hmrDownloadManifest`利用fetch下载我们常见到的XXX.hot-update.json更新清单\\n\\n```js\\n// XXX.hot-update.json\\n  {\\n    \\\"c\\\":[\\\"index\\\"], // 更新chunk\\n    \\\"r\\\":[],\\n    \\\"m\\\":[]\\n    // 有些是有\\\"h\\\":hash,版本不同略微不一样\\n  }\\n```\\n然后回调`hmrDownloadUpdateHandlers`通过插入<sctipt>标签的方式下载并执行**XXX.hot-update.js文件\\n    \\n// XXX.hot-update.js\\n    \\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/347113757d5e4bd2a401f167b7583c08~tplv-k3u1fbpfcp-watermark.image?)\\n\\nxxx.hot-update.js文件执行了一个函数`window.webpackHotUpdatewebpack_study_1`，该函数也是webpack注入代码执行的过程中给window添加的函数，他的作用大致就是将更新的chunk、modules信息保存下来先，以便后续处理这些信息。\\n    \\n` module.hot.check()函数代码: `\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c6065b08c7c4e1ea2f018c054ab1571~tplv-k3u1fbpfcp-watermark.image?)\\n\\n    \\n在下载完更新XXX.hot-update.js完成后，最后就是应用上这些新代码：\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b53bf7eb1ab641ea943fb2f6c9f463ad~tplv-k3u1fbpfcp-watermark.image?)\\n应用新代码的核心方法：\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f56bdad7764e4eae82a4dfd589b2dc88~tplv-k3u1fbpfcp-watermark.image?)\\n    \\n这个函数大致就是替换并运行模块代码，执行热替换函数【`module.hot.accept`】!\\n\\n替换的过程涉及到webpack的关于module、chunk、chunkGraph、moduleGraph这样的知识，没有再去深入讲解module如何被替换。建议看之前写过的一篇文章全面的了解webpack的构建原理[# webpack原理解析【长文万字】](https://juejin.cn/post/7125696644435148831)。\\n\\n\\n可以看到，修改后的writeA.js重新运行一次，然后index.js对writeA.js的`hot.accept()`被触发。  \\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/320aaf2e27414bffab55fe5de7c5f3fe~tplv-k3u1fbpfcp-watermark.image?)\\n    \\n至此整个热更新的过程结束！！！\\n    \\n下面我们再梳理一遍客户端从收到socket消息ok之后的调用流程：\\n    \\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/552a1d4d899d434aab759728ef8416bb~tplv-k3u1fbpfcp-watermark.image?)\\n    \\n这么看好像整个热更新过程也好像没那么容易理解不是吗？\\n\\n## 上帝视角看流程\\n \\n       \\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a659988dc6c43b1a9754befba6411cb~tplv-k3u1fbpfcp-watermark.image?)\\n\\n写多少字都不如一个好图易理解、易记忆。\\n\\n    \\n    \\n    \\n## 最后\\n知道的越多，不知道的也越多。在阅读源码的过程中，也发现了很多坑点，例如看到了很多`$XXXX$`这样的命名，不理解为什么要这么做。也看到很多“console.log(url)”这样字符串包裹的代码\\n    \\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a7c51fd3844e4f8e8ac8892480ee3353~tplv-k3u1fbpfcp-watermark.image?)\\n \\n阅读难度巨增，不知道为啥会设计成这样，也没有思考会不会有更好的解决办法。一些函数名都是动态生成计算等等，都给我在阅读源码时增加了很多难度。还有就是webpack构建进程与静态服务器之间的交互过程目前理解也相对有限。在阅读文章的时候，一定要对各个角色有所区分，不要把那些功能混淆了。\\n    \\n## 另外：\\n热更新的moduel.hot.accept()函数来实现视图更新、页面状态保存等热更新效果的逻辑实际开发中是非常复杂的，不像上图中那样简单。但所幸，webpack中的很多loader都帮我们实现了该函数的效果。如style-loader、vue-loader等等，有了这些，我们才能够更加专注于开发业务代码。此时，不由得深深佩服这些造轮子的大佬，自愧不如。\\n    \\n~ 如果本篇文章能够让你了解到HMR的运行机制的话，请麻烦东东你的小手点个赞再走！❤👍 ~\\n\\n\\n",
        "tags": [
            "Webpack",
            "前端",
            "JavaScript"
        ]
    },
    {
        "article_id": "7160358329934413837",
        "cover_image": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d55576b37c8c4e56935461252a18aaf3~tplv-k3u1fbpfcp-watermark.image?",
        "title": "如何花一天时间打造一款前端在线代码编辑器——实现代码预览",
        "brief": "vue-Playground 功能第一次尝试这种在线编码时感觉挺新奇，浏览器端居然可以直接运行 typescript，还具备编译的能力，今天就从技术选型和架构的层面打造一款前端在线代码编辑器。",
        "user_name": "残月公子",
        "view_count": 3902,
        "collect_count": 89,
        "comment_count": 1,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/4f5f8646f59917e9665b371bf005d000~300x300.image",
        "category": "前端",
        "content": "## 前言\\n\\n好久都没写博客了，这两天稍微空闲些打算找个技术专题来写一些东西。本想写写最近非常火的 Turbopack，但考虑到没有深入的研究其运行原理，如果要写可能就要是流于表面讲讲用法，感觉价值也不是很高，故此还是选了之前预研过的在线编辑器。\\n\\n目前社区中一些开源的框架在部署文档时为方便开发者快速了解使用，都会实现一套自己的在线编辑器。如\\n* [omi-Playground](https://omi.cdn-go.cn/play/latest/index.html) \\n* [typescript-Play](https://www.typescriptlang.org/play) \\n* [vue-Playground](https://sfc.vuejs.org/) \\n* [掘金-Code](https://code.juejin.cn/) \\n\\n第一次体验这种功能时挺新奇，浏览器端居然可以直接运行 typescript、less、scss 等代码，还可以有自己的独立的运行时环境，最重要的是沙箱环境中可以有自己的依赖项（沙箱中执行代码时可以自动加载对应的依赖，如加载 vue、react 这种运行时依赖）。\\n\\n后续也陆续调研了此类工具的一些架构，基于这些理论架构花费了几天的时间简单实现了一套 WebComponent 技术栈的在线编辑器，感兴趣的可以 [在线体验， 浏览器代开奥](https://static-cdn.canyuegongzi.xyz/wu-code-playground/index.html) 。\\n\\n既然专题已定，那说干就干，先做一个基本的架构设计。\\n\\n## 架构设计\\n\\n既然要做在线的编译器，那首先得支持编辑代码，其次得有一个能独立运行的沙箱环境，最后就是需要具备代码的编译能力（浏览器不支持直接执行 typescript、less 此类的代码）。\\n\\n<img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76795d50d763488db13d6bf3b76eb481~tplv-k3u1fbpfcp-zoom-1.image\\\" class=\\\"medium-zoom medium-zoom-image\\\">\\n\\n基于设想做了一个简单的架构，架构基于浏览器以及 WebWorker 环境，Compiler 是核心枢纽负责三方通信，有了基本的架构设计，后续开始针对每个模块进行技术选型以及开发。\\n\\n## 模块设计\\n\\n### 编辑器\\n\\nWeb 编辑器是前端领域中算是比较深入的一个领域了，常见的 Md 编辑器、富文本编辑器等，从能力层来说，任何具备输入能力的控件都能承担架构中 Editor 的角色，但考虑到用户体验，如代码智能提示、代码格式美化、主题色等，故此还是选一款成熟的编辑器。\\n\\n目前社区中也有很多优秀代码编辑器，诸如，\\n* [codemirror](https://github.com/codemirror/codemirror5) \\n* [monaco-editor](https://github.com/microsoft/monaco-editor) \\n* [vue-codemirror](https://github.com/surmon-china/vue-codemirror) \\n\\ncodemirror是一块比较老牌的插件，功能非常丰富，但工程化集成稍微困难些，因此方案中未采用该插件，故此此处不再赘述演示，感兴趣的可以移步去官网瞅瞅。\\n\\n此方案中选用大大名顶顶的 monaco-editor 的编辑器，monaco-editor 是一个浏览器端的代码编辑器库，同时它也是 VS Code 所使用的编辑器。monaco-editor 可以看作是一个编辑器控件，只提供了基础的编辑器与语言相关的接口，可以被用于任何基于 Web 技术构建的项目中，而 VS Code 包含了文件管理、版本控制、插件等功能，是一款桌面软件。monaco-editor 的 GitHub 仓库中不包含任何实际功能代码，因为其源代码与 VS Code 在同一个仓库，只是在版本发布时会构建出独立的编辑器代码。目前社区中对于集成 monaco-editor 的方案比较多，此处大致做一个方案对比。\\n\\n#### monaco-editor-webpack-plugin\\n\\n**插件安装**\\n\\n[monaco-editor-webpack-plugin](https://www.npmjs.com/package/monaco-editor-webpack-plugin) 是一个基于 webpack 的集成方案，周下载量大致 204k 左右，此处拷贝了下官网的集成代码。\\n\\n```\\nconst MonacoWebpackPlugin = require('monaco-editor-webpack-plugin');\\nconst path = require('path');\\n\\nmodule.exports = {\\n\\tentry: './index.js',\\n\\toutput: {\\n\\t\\tpath: path.resolve(__dirname, 'dist'),\\n\\t\\tfilename: 'app.js'\\n\\t},\\n\\tmodule: {\\n\\t\\trules: [\\n\\t\\t\\t{\\n\\t\\t\\t\\ttest: /\\\\.css$/,\\n\\t\\t\\t\\tuse: ['style-loader', 'css-loader']\\n\\t\\t\\t},\\n\\t\\t\\t{\\n\\t\\t\\t\\ttest: /\\\\.ttf$/,\\n\\t\\t\\t\\tuse: ['file-loader']\\n\\t\\t\\t}\\n\\t\\t]\\n\\t},\\n\\tplugins: [new MonacoWebpackPlugin()]\\n};\\n```\\n\\n**实例化**\\n\\n```ts\\nimport * as monaco from 'monaco-editor';\\n// or import * as monaco from 'monaco-editor/esm/vs/editor/editor.api';\\n// if shipping only a subset of the features & languages is desired\\n\\nmonaco.editor.create(document.getElementById('container'), {\\n\\tvalue: 'console.log(\\\"Hello, world\\\")',\\n\\tlanguage: 'javascript'\\n});\\n```\\n\\n#### @monaco-editor/loader\\n\\nmonaco-editor-webpack-plugin 虽好，但限制了工具链只能 webpack 使用，通过开源社区了解到 [@monaco-editor/loader](https://www.npmjs.com/package/@monaco-editor/loader) ，周下载量大致 224k 左右， 用官网的描述就是\\n\\n> The utility to easy setup monaco-editor into your browser。Configure and download monaco sources via its loader script, without needing to use webpack's (or any other module bundler's) configuration files\\n\\n**实例化**\\n\\n```ts\\nimport loader from '@monaco-editor/loader';\\n\\nloader.init().then(monaco => {\\n  monaco.editor.create(document.querySelector(\\\"#dom\\\"), {\\n    value: '// some comment',\\n    language: 'javascript',\\n  });\\n});\\n```\\n\\n#### @monaco-editor/react\\n\\n@monaco-editor/loader 方案很优秀，但货比三家还是调研了另外一个方案，[@monaco-editor/react](https://www.npmjs.com/package/@monaco-editor/react) ，周下载量大致 219k 左右，是一款基于 react 的组件。\\n\\n> Monaco Editor for React · use the monaco-editor in any React application without needing to use webpack (or rollup/parcel/etc) configuration files / plugins\\n\\n**实例化**\\n\\n```tsx\\nimport React from \\\"react\\\";\\nimport ReactDOM from \\\"react-dom\\\";\\n\\nimport Editor from \\\"@monaco-editor/react\\\";\\n\\nfunction App() {\\n  return (\\n   <Editor\\n     height=\\\"90vh\\\"\\n     defaultLanguage=\\\"javascript\\\"\\n     defaultValue=\\\"// some comment\\\"\\n   />\\n  );\\n}\\n\\nconst rootElement = document.getElementById(\\\"root\\\");\\nReactDOM.render(<App />, rootElement);\\n```\\n\\n**Editor 的实现最后使用了 monaco-editor + @monaco-editor/loader 的方案，封装了一个基于 WebComponent 的插件：[wu-code-monaco-editor](https://docs.wu-component.com/component-plus/Complex/CodeEditor.html) 。**\\n\\n### 沙箱环境\\n\\n因编辑器输入代码的不可信任，所以需要一个沙箱环境来执行代码, 防止程序访问/影响主页面。\\n\\n> 在计算机安全中，沙箱（Sandbox）是一种用于隔离正在运行程序的安全机制，通常用于执行未经测试或不受信任的程序或代码，它会为待执行的程序创建一个独立的执行环境，内部程序的执行不会影响到外部程序的运行。\\n\\n该方案中选用了最传统的 Iframe 方案，毕竟它的兼容性最好，功能最完善（沙箱做的最彻底，js 作用域、css 隔离等），但此处还是列举了几个社区中其他的沙箱方案。\\n\\n#### Proxy Sandbox\\n\\n可以通过代理 Proxy 实现对象的劫持， 通过 window 对象的修改进行记录，在卸载时删除这些记录，在应用再次激活时恢复这些记录，来达到模拟沙箱环境的目的。此处贴了一份社区中的实现代码，可以略作研习。\\n\\n```ts\\n// 修改window属性的公共方法\\nconst updateHostProp = (prop: any, value, isDel?) => {\\n    if (value === undefined || isDel) {\\n        delete window[prop];\\n    } else {\\n        window[prop] = value;\\n    }\\n};\\n\\nclass ProxySandbox {\\n    private currentUpdatedPropsValueMap = new Map()\\n    private modifiedPropsMap = new Map()\\n    private addedPropsMap = new Map()\\n    public name: string = \\\"\\\";\\n    public proxy: any;\\n\\n    /**\\n     * 激活沙箱\\n     */\\n    public active() {\\n        // 根据记录还原沙箱\\n        this.currentUpdatedPropsValueMap.forEach((v, p) => updateHostProp(p, v));\\n    }\\n\\n    /**\\n     * 关闭沙箱\\n     */\\n    public inactive() {\\n        // 1 将沙箱期间修改的属性还原为原先的属性\\n        this.modifiedPropsMap.forEach((v, p) => updateHostProp(p, v));\\n        // 2 将沙箱期间新增的全局变量消除\\n        this.addedPropsMap.forEach((_, p) => updateHostProp(p, undefined, true));\\n    }\\n\\n    constructor(name) {\\n        this.name = name;\\n        this.proxy = null;\\n        // 存放新增的全局变量\\n        this.addedPropsMap  = new Map();\\n        // 存放沙箱期间更新的全局变量\\n        this.modifiedPropsMap = new Map();\\n        // 存在新增和修改的全局变量，在沙箱激活的时候使用\\n        this.currentUpdatedPropsValueMap = new Map();\\n\\n        const { addedPropsMap, currentUpdatedPropsValueMap, modifiedPropsMap } = this;\\n        const fakeWindow = Object.create(null);\\n        const proxy = new Proxy(fakeWindow, {\\n            set(target, prop, value) {\\n                if (!window.hasOwnProperty(prop)) {\\n                    // 如果window上没有的属性，记录到新增属性里\\n                    addedPropsMap.set(prop, value);\\n                } else if (!modifiedPropsMap.has(prop)) {\\n                    // 如果当前window对象有该属性，且未更新过，则记录该属性在window上的初始值\\n                    const originalValue = window[prop];\\n                    modifiedPropsMap.set(prop, originalValue);\\n                }\\n                // 记录修改属性以及修改后的值\\n                currentUpdatedPropsValueMap.set(prop, value);\\n                // 设置值到全局window上\\n                updateHostProp(prop, value);\\n                return true;\\n            },\\n            get(target, prop) {\\n                return window[prop];\\n            },\\n        });\\n        this.proxy = proxy;\\n    }\\n}\\n\\nconst newSandBox: ProxySandbox = new ProxySandbox('代理沙箱');\\nconst proxyWindow = newSandBox.proxy;\\nproxyWindow.a = '1';\\nconsole.log('开启沙箱：', proxyWindow.a, window.a);\\nnewSandBox.inactive(); //失活沙箱\\nconsole.log('失活沙箱：', proxyWindow.a, window.a);\\nnewSandBox.active(); //失活沙箱\\nconsole.log('重新激活沙箱：', proxyWindow.a, window.a);\\n\\n```\\n\\n以上代码实现了基础版的沙箱， 通过 active 方法开始沙箱代理，社区中的 qiankunu 等此类的微前端架构中基本都采用了此类的设计。\\n\\n#### Diff Sandbox\\n\\n除 Proxy 方式外，我们可以通过 diff 的方式创建沙箱，一般作为 Proxy Sandbox 的降级方案，在应用运行的时候保存一个快照 window 对象，将当前 window 对象的全部属性都复制到快照对象上，子应用卸载的时候将 window 对象修改做个 diff，将不同的属性用个 modifyMap 保存起来，再次挂载的时候再加上这些修改的属性。\\n\\n```ts\\nclass DiffSandbox {\\n    public name: any;\\n    public modifyMap: {};\\n    private windowSnapshot: {};\\n    constructor(name) {\\n        this.name = name;\\n        this.modifyMap = {}; // 存放修改的属性\\n        this.windowSnapshot = {};\\n    }\\n    public active() {\\n        // 缓存active状态的沙箱\\n        this.windowSnapshot = {};\\n        for (const item in window) {\\n            this.windowSnapshot[item] = window[item];\\n        }\\n\\n        Object.keys(this.modifyMap).forEach(p => {\\n            window[p] = this.modifyMap[p];\\n        });\\n\\n    }\\n\\n    public inactive() {\\n        for (const item in window) {\\n            if (this.windowSnapshot[item] !== window[item]) {\\n                // 记录变更\\n                this.modifyMap[item] = window[item];\\n                // 还原window\\n                window[item] = this.windowSnapshot[item];\\n            }\\n        }\\n    }\\n}\\nconst diffSandbox = new DiffSandbox('diff沙箱');\\ndiffSandbox.active();  // 激活沙箱\\nwindow.a = '1';\\nconsole.log('开启沙箱：', window.a);\\ndiffSandbox.inactive(); //失活沙箱\\nconsole.log('失活沙箱：', window.a);\\ndiffSandbox.active();   // 重新激活\\nconsole.log('再次激活', window.a);\\n\\n```\\n\\n#### iframe\\n\\niframe 方案是该设计中的沙箱方案，此处细细道说。\\n\\n<img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fcd1137dfccb4f43b86463b0576b2a00~tplv-k3u1fbpfcp-zoom-1.image\\\" class=\\\"medium-zoom medium-zoom-image\\\">\\n\\n宿主环境中通过实例化 new ProxySandbox() 操作来创建加载 Iframe， Iframe 加载完毕后会监听来自宿主的消息，诸如执行代码、加载依赖。内部也可以通过 postMessage 向宿主环境发送消息，此逻辑参考了  [@vue/repl](https://github.com/vuejs/repl#readme)  \\n\\n```ts\\nlet uid = 1;\\nexport class ProxySandbox {\\n    iframe: HTMLIFrameElement\\n    handlers: Record<string, Function>\\n    pending_cmds: Map<\\n        number,\\n        { resolve: (value: unknown) => void; reject: (reason?: any) => void }\\n        >\\n    handle_event: (e: any) => void\\n\\n    constructor(iframe: HTMLIFrameElement, handlers: Record<string, Function>) {\\n        this.iframe = iframe;\\n        this.handlers = handlers;\\n\\n        this.pending_cmds = new Map();\\n\\n        this.handle_event = (e) => this.handle_repl_message(e);\\n        window.addEventListener('message', this.handle_event, false);\\n    }\\n\\n    destroy() {\\n        window.removeEventListener('message', this.handle_event);\\n    }\\n\\n    iframe_command(action: string, args: any) {\\n        return new Promise((resolve, reject) => {\\n            const cmd_id = uid++;\\n\\n            this.pending_cmds.set(cmd_id, { resolve, reject });\\n\\n            this.iframe.contentWindow!.postMessage({ action, cmd_id, args }, '*');\\n        });\\n    }\\n\\n    handle_command_message(cmd_data: any) {\\n        const action = cmd_data.action;\\n        const id = cmd_data.cmd_id;\\n        const handler = this.pending_cmds.get(id);\\n\\n        if (handler) {\\n            this.pending_cmds.delete(id);\\n            if (action === 'cmd_error') {\\n                const { message, stack } = cmd_data;\\n                const e = new Error(message);\\n                e.stack = stack;\\n                handler.reject(e);\\n            }\\n\\n            if (action === 'cmd_ok') {\\n                handler.resolve(cmd_data.args);\\n            }\\n        } else if (action !== 'cmd_error' && action !== 'cmd_ok') {\\n            console.error('command not found', id, cmd_data, [\\n                ...this.pending_cmds.keys()\\n            ]);\\n        }\\n    }\\n\\n    handle_repl_message(event: any) {\\n        if (event.source !== this.iframe.contentWindow) return;\\n\\n        const { action, args } = event.data;\\n        this.handlers.on_default_event(event);\\n        switch (action) {\\n            case 'cmd_error':\\n            case 'cmd_ok':\\n                return this.handle_command_message(event.data);\\n            case 'fetch_progress':\\n                return this.handlers.on_fetch_progress(args.remaining);\\n            case 'error':\\n                return this.handlers.on_error(event.data);\\n            case 'unhandledrejection':\\n                return this.handlers.on_unhandled_rejection(event.data);\\n            case 'console':\\n                return this.handlers.on_console(event.data);\\n            case 'console_group':\\n                return this.handlers.on_console_group(event.data);\\n            case 'console_group_collapsed':\\n                return this.handlers.on_console_group_collapsed(event.data);\\n            case 'console_group_end':\\n                return this.handlers.on_console_group_end(event.data);\\n        }\\n    }\\n\\n    eval(script: string | string[]) {\\n        return this.iframe_command('eval', { script });\\n    }\\n\\n    handle_links() {\\n        return this.iframe_command('catch_clicks', {});\\n    }\\n\\n    load_depend(options: Record<any, any>) {\\n        return this.iframe_command('load_dependencies', options);\\n    }\\n}\\n```\\n\\n### 在线编译\\n\\nEditor 和 Sandbox 方案既定，最后就是代码的编译问题，此方案中仅涉及 TypeScript 的编译。\\n\\nmonaco-editor 提供了 Worker 编译代码的能力，使用起来也是非常方便，读取到编辑器中输入的代码后直接输入到 Worker 中，等待编译完成再调用上章中沙箱提供的 eval 的接口送入沙箱中即可。\\n\\n```ts\\n\\nexport const compileTS = async (uri: InstanceType<typeof monaco.Uri>) => {\\n    // const tsWorker = await monaco.languages.typescript.getTypeScriptWorker();\\n    const monaco = window.monaco;\\n    // 读取编译子线程\\n    const tsWorker = await monaco.languages.typescript.getTypeScriptWorker();\\n    const client = await tsWorker(uri);\\n    const result = await client.getEmitOutput(uri.toString());\\n    const files = result.outputFiles[0];\\n    return files.text;\\n};\\n\\nexport class WuCodePlayground extends WuComponent {\\n    /// .....code\\n    constructor() {\\n        super();\\n    }\\n    \\n    /**\\n     * 核心逻辑， 读取输入的代码，执行 compileTS 编译\\n     */\\n    public async runCode() {\\n        const editor = this.editorContainer.editor;\\n        const tsJs: string = await compileTS(editor.getModel(\\\"typescript\\\").uri);\\n        this.previewContainer.runCode('ts', tsJs);\\n\\n    }\\n    /// .....code\\n}\\n\\n```\\n\\n至于其他诸如 less, scss 等的编译问题社区中也有成熟的方案：\\n\\n* [less](https://lesscss.org/)\\n* [sass](http://sass.js.org/)\\n\\n## 思考\\n\\n时间太晚了写不动了，此方案在实时过程中有很多的细节问题后续抽空在记录吧，如沙箱中通过如何通过 import-maps 加载运行时依赖、沙箱与宿主间通信如何保证稳定、以及 WebComponent 不能重复定义等问题。\\n\\n* [感兴趣的可以移步到这里参阅源码](https://github.com/wu-component/web-component-plus/tree/master/component/packages/wu-code-playground/src)\\n* [组件](https://docs.wu-component.com/component-plus/Complex/CodeEditor.html)\\n\\n## 参考资料\\n\\n* [@vue/repl](https://github.com/vuejs/repl#readme)  \\n* [monaco-editor](https://microsoft.github.io/monaco-editor/)  \\n* [writing-a-javascript-framework-sandboxed-code-evaluation](https://blog.risingstack.com/writing-a-javascript-framework-sandboxed-code-evaluation/)  \\n* [create-a-custom-web-editor-using-typescript-react-antlr-and-monaco-editor](https://betterprogramming.pub/create-a-custom-web-editor-using-typescript-react-antlr-and-monaco-editor-part-1-2f710c69c18c)\\n* [To create a lightweight WebIDE, reading this article is enough](https://segmentfault.com/a/1190000041686221/en)\\n* [import-maps](https://html.spec.whatwg.org/multipage/webappapis.html#import-maps)\\n",
        "tags": [
            "前端",
            "架构",
            "TypeScript"
        ]
    },
    {
        "article_id": "7187570397565419581",
        "cover_image": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1777c3411ac24b0889792d56343f1195~tplv-k3u1fbpfcp-watermark.image?",
        "title": "CSS 奇思妙想之酷炫倒影",
        "brief": "在 CSS 中，倒影是一种比较常见的效果。今天，我们就将尝试，使用 CSS 完成各类不同的倒影效果，话不多说，直接进入主题。 实现倒影的两种方式 首先，快速过一下在 CSS 中，实现倒影的 2 种方式",
        "user_name": "chokcoco",
        "view_count": 5657,
        "collect_count": 76,
        "comment_count": 10,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/d5909b97177d58b77d02a83a620abd18~300x300.image",
        "category": "前端",
        "content": "在 CSS 中，倒影是一种比较常见的效果。今天，我们就将尝试，使用 CSS 完成各类不同的倒影效果，话不多说，直接进入主题。\\n\\n## 实现倒影的两种方式\\n\\n首先，快速过一下在 CSS 中，实现倒影的 2 种方式。\\n\\n### 使用 -webkit-box-reflect\\n\\n正常而言，`-webkit-box-reflect` 是一种非常便捷及快速的实现倒影的方式。\\n\\n`-webkit-box-reflect` 的语法非常简单，最基本的用法像是这样：\\n\\n```CSS\\ndiv {\\n    -webkit-box-reflect: below;\\n}\\n```\\n\\n其中，below 可以是 below | above | left | right 代表下上左右，也就是有 4 个方向可以选。\\n\\n看这么一个例子：\\n\\n```CSS\\ndiv {\\n    background-image: url('image.png');\\n    -webkit-box-reflect: below 2px linear-gradient(transparent, rgba(0, 0, 0, .5));\\n}\\n```\\n\\n看看效果，有了虚实变化之后，这样就更像是一个倒影。\\n\\n简单而言，使用 `-webkit-box-reflec` 可以做到：\\n\\n1. 不同方向的投影\\n2. 投影的距离\\n3. 投影的虚实，可叠加一层蒙版控制透明度\\n\\n上面 3 点即是 `-webkit-box-reflec` 的特点，同时，也表明了它存在一定的局限性，同时，在今天，从 `-webkit-box-reflec` 的名字也能看出来，存在一点兼容性问题。所以，如果，我们想实现更负杂一点的倒影效果。利用下面一种方式可能更好。\\n\\n### 利用实现多一个反向元素实现\\n\\n这个方法其实是更为普遍的。也就是我们实现一个反向的效果即可。通常会利用元素的伪元素。\\n\\n代码非常简单，以文字为例子：\\n\\n```HTML\\n<p content=\\\"Reflect\\\">Reflect</p>\\n```\\n```CSS\\np {\\n    position: relative;\\n    \\n    &::before {\\n        content: attr(content);\\n        position: absolute;\\n        inset: 0;\\n        transform: rotatex(180deg) translatey(15px);\\n        transform-origin: 50% 100%;\\n    }\\n}\\n```\\n\\n就是通过元素的伪元素，再旋转 180 度，放置到正确合适的位置即可，效果如下：\\n\\n<img width=\\\"370\\\" alt=\\\"image\\\" src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bea36a4609be438ca21f8c0a0c79e19c~tplv-k3u1fbpfcp-zoom-1.image\\\">\\n\\n虽然这个代码多一点，但是由于这是一整个可控制的元素，所以基于它，我们可以实现的效果就能够非常丰富。\\n\\n## 实现各式倒影效果\\n\\n下面，我们就基于上述的 DEMO，丰富我们的倒影效果。\\n\\n我们核心要做的，就是通过改造伪元素，实现不同的效果，得到不一样的倒影。\\n\\n1. 通过 mask，控制透明度，控制条纹\\n\\n我们可以通过 mask，有效的控制倒影的透明度：\\n\\n```CSS\\np::before {\\n    mask: linear-gradient(transparent, #000);\\n}\\n```\\n\\n效果如下：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2817e146bb784d079495dfd04d980aa8~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n透明度的控制也可以是这种从左往右的：\\n\\n```CSS\\np::before {\\n  mask: \\n    linear-gradient(\\n      90deg,\\n      transparent,\\n      rgba(255, 255, 255, 0.01) 25%,\\n      white,\\n      rgba(255, 255, 255, 0.01) 75%,\\n      transparent\\n  );\\n}\\n```\\n\\n效果如下：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea1ce9babfb44c05a83897810efcaf21~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n当然，mask 可以有不同的作用，不仅仅是控制透明度，也可以实现横线分隔、竖线分隔、斜线分隔：\\n\\n```CSS\\np::before {\\n  mask: repeating-linear-gradient(\\n    transparent,\\n    transparent 3px,\\n    white 3px,\\n    white 4px\\n  );\\n}\\n```\\n\\n这个是横线，效果如下：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51de7217aa4e46e79fb2b65217081c14~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n改变 mask 的角度，就可以得到各种不同方向的效果：\\n\\n```CSS\\np::before {\\n  mask: repeating-linear-gradient(\\n    90deg,\\n    transparent,\\n    transparent 3px,\\n    white 3px,\\n    white 4px\\n  );\\n}\\n```\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b4958006217d4927ac4525841d97c761~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n是的，我们还可以把上述两个不同的 mask 效果叠加在一起，那么就会是这样：\\n\\n```CSS\\np::before {\\n  mask: \\n  repeating-linear-gradient(\\n      transparent,\\n      transparent 3px,\\n      white 3px,\\n      white 4px\\n  ),\\n  linear-gradient(transparent 40%, white 90%);\\n}\\n```\\n\\n那么，就会是渐变消失叠加线段分隔的效果：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1363b83615d448458b611f1e91ac20e6~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n上面的效果，再叠加上角度控制，就是另外一种效果：\\n\\n```CSS\\np::before {\\n  mask: \\n    repeating-linear-gradient(\\n        35deg,\\n        transparent,\\n        transparent 3px,\\n        white 3px,\\n        white 4px\\n    ),\\n    linear-gradient(-90deg, transparent, transparent, white);\\n}\\n```\\n\\n效果如下：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/84429c8ce7704987b668b24491b4f7fe~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n2. 配合 transform，实现斜体\\n\\n通过叠加 transform，我们就能很好的让字体有一个适合的倾斜角度，像是这样：\\n\\n```CSS\\np::before {\\n  mask: linear-gradient(transparent 20%, rgba(255, 255, 255, .7) 95%);\\n  transform: rotatex(180deg) translatey(15px) skew(135deg) translatex(-10px);\\n}\\n```\\n\\n效果如下：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0596c67fdae4279b32151098fa419af~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n当然，控制 mask，能有各式的纹理：\\n\\n```CSS\\np::before {\\n  mask: \\n    repeating-linear-gradient(35deg, transparent, transparent 2px, white 2px, white 4px),\\n    repeating-linear-gradient(-35deg, transparent, transparent 2px, white 2px, white 4px),\\n    linear-gradient(transparent 30%, white 95%);\\n  transform: rotatex(180deg) translatey(15px) skew(135deg) translatex(-10px);\\n}\\n```\\n\\n效果如下：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e08e40d60977441d96959d2ec4fecc6f~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n如果把另外一个伪元素也用上呢，就能丰富倒影的方向：\\n\\n```CSS\\np {\\n  &::before {\\n    mask: linear-gradient(transparent 5%, rgba(255, 255, 255, .9) 95%);\\n    transform: rotatex(180deg) translatey(11px) skew(125deg) translatex(-10px);\\n    background: #333;\\n    color: transparent;\\n    background-clip: text;\\n    z-index: 1;\\n  }\\n  &::after {\\n    transform: rotatex(180deg) translatey(11px) skew(-125deg) translatex(8px);\\n    background: #ddd;\\n    color: transparent;\\n    background-clip: text;\\n    mask: linear-gradient(transparent 5%, rgba(255, 255, 255, .9) 95%);\\n  }\\n}\\n```\\n\\n像是这样：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/18f365c2ddc04e1fb10bae9afdea7a31~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n3. 借助滤镜实现虚化\\n\\n再接着，我们可以借助滤镜，继续丰富倒影的效果。\\n\\n譬如简单的一层模糊滤镜：\\n\\n```CSS\\np::before {\\n  mask: linear-gradient(transparent 5%, rgba(255, 255, 255, .9) 99%);\\n  transform: rotatex(180deg) translatey(6px) skew(135deg) translatex(-8px);\\n  filter: blur(8px);\\n}\\n```\\n\\n效果如下：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f2e250e5dca14271bd84cb73f8bb0f43~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n或者是半截式的，模糊倒影：\\n\\n```CSS\\np::before {\\n  transform: rotatex(180deg) translatey(15px);\\n  filter: blur(4px);\\n  mask: linear-gradient(transparent 30%, white 90%);\\n}\\n```\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/07b1b87bad324932bdb5c29a348d1aec~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n或者是多个滤镜叠加在一起：\\n\\n```CSS\\np::before {\\n  transform: rotatex(180deg) translatey(15px);\\n  filter: blur(9px) brightness(1.5);\\n}\\n```\\n\\n效果如下：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4585bb913c8440cbbe3c1231f47ee701~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n上述所有效果的 Demo，你可以在这里找到：\\n\\n[CodePen Demo -- Text Reflect Effect Demo](https://codepen.io/Chokcoco/pen/mdjRYZb)\\n\\n## 尝试更换字体以及利用 background-clip: text\\n\\n再接着，我们可以尝试更换不同的字体。其实，通过 `background-clip: text` 的特性，给文字染上不同的效果。\\n\\n譬如，我们选择了这样一张图片：\\n\\n![211817598-69d82c13-aee3-4cd5-b3a8-b52d63375243.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a5d4695c6cd4872a44ea05d542b7f77~tplv-k3u1fbpfcp-watermark.image?)\\n\\n通过 `background-clip: text` 作用给文字，像是这样：\\n\\n```CSS\\np {\\n    position: relative;\\n    font-family: 'new font', sans-serif;\\n    background: url(花里胡哨的图片.jpg);\\n    background-clip: text;\\n    color: transparent;\\n    \\n    &::before {\\n        content: attr(content);\\n        position: absolute;\\n        inset: 0;\\n        transform: rotatex(180deg) translatey(24px);\\n        transform-origin: 50% 100%;\\n        background: inherit;\\n        background-clip: text;\\n        color: transparent;\\n    }\\n}\\n```\\n\\n再重复上述的效果一次，我们就能得到更为多样的不同的效果，下面是整体效果展示图：\\n\\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e8e915cbfa04f36890bb1d97d62f33d~tplv-k3u1fbpfcp-watermark.image?)\\n\\n完整的代码，你可以戳这里：[CodePen Demo -- Text Reflect Effect Demo](https://codepen.io/Chokcoco/pen/rNrmeaO)\\n\\n## 最后\\n\\n当然，倒影能做的效果远不止这些，感兴趣的读者可以尝试使用更多 CSS 属性，制作更多有意思的倒影效果。\\n\\n好了，本文到此结束，希望本文对你有所帮助 :)\\n\\n更多精彩 CSS 技术文章汇总在我的 [Github -- iCSS](https://github.com/chokcoco/iCSS) ，持续更新，欢迎点个 star 订阅收藏。\\n\\n如果还有什么疑问或者建议，可以多多交流，原创文章，文笔有限，才疏学浅，文中若有不正之处，万望告知。",
        "tags": [
            "前端",
            "CSS",
            "JavaScript"
        ]
    },
    {
        "article_id": "7170843707217412126",
        "cover_image": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c6c5d03c3e794f7bb7973136d2f9e8eb~tplv-k3u1fbpfcp-watermark.image?",
        "title": "Vite 配置篇：日常开发掌握这些配置就够了！",
        "brief": "不知道有没有这样的兄弟，学习 Vite 的时候，官网上各种配置看的是眼花缭乱。不知道哪些需要掌握，哪些只用简单了解一下。为了提高大家的效率，我把日常开发中常用的配置梳理了一下分享给大家！",
        "user_name": "前端阿飞",
        "view_count": 4289,
        "collect_count": 344,
        "comment_count": 18,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/b0a631ea4a7865906f96329d9676169e~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: scrolls-light\\nhighlight: atom-one-light\\n---\\n> 本文为稀土掘金技术社区首发签约文章，14天内禁止转载，14天后未获授权禁止转载，侵权必究！\\n\\n不知道有没有这样的兄弟，学习 Vite 的时候，官网上各种配置看的是眼花缭乱。不知道哪些需要掌握，哪些只用简单了解一下。为了提高大家的效率，我把项目中常用的配置梳理了一下分享给大家，希望对你上手 Vite 有所帮助。话不多说，开干！\\n\\n\\n## css.preprocessorOptions\\n传递给 CSS 预处理器的配置选项，这些配置会传递到预处理器的执行参数中去。例如，在 scss 中定义一个全局变量：\\n\\n```js\\n// vite.config.js\\nimport { defineConfig } from 'vite' // 使用 defineConfig 工具函数获取类型提示：\\n\\nexport default defineConfig({\\n  css: {\\n    preprocessorOptions: {\\n      scss: {\\n        additionalData: `$injectedColor: orange;` // 全局变量\\n      }\\n    }\\n  }\\n})\\n```\\n我们也可以定义一个全局变量文件，然后再引入这个文件：\\n\\n```scss\\n// src/assets/styles/variables.scss\\n$injectedColor: orange;\\n$injectedFontSize: 16px;\\n```\\n```js\\n// vite.config.js\\nimport { defineConfig } from 'vite'\\n\\nexport default defineConfig({\\n  css: {\\n    preprocessorOptions: {\\n      scss: {\\n        additionalData: `@import '/src/assets/styles/variables.scss';` // 引入全局变量文件\\n      }\\n    }\\n  }\\n})\\n```\\n这样在 `.scss` 文件或 `.vue` 文件中就可以使用这些变量了。\\n\\n## css.postcss\\nPostCSS 也是用来处理 CSS 的，只不过它更像是一个工具箱，可以添加各种插件来处理 CSS 。像浏览器样式兼容问题、浏览器适配等，都可以通过 PostCSS 来解决。\\n\\nVite 对 PostCSS 有良好的支持，我们只需要安装相应的插件就可以了。如移动端使用 `postcss-px-to-viewport` 对不同设备进行布局适配：\\n\\n```js\\nnpm install postcss-px-to-viewport -D\\n```\\n\\n```js\\n// vite.config.js\\nimport { defineConfig } from 'vite'\\nimport postcssPxToViewport from 'postcss-px-to-viewport'\\n\\nexport default defineConfig({\\n  css: {\\n    postcss: {\\n      plugins: [\\n        // viewport 布局适配\\n        postcssPxToViewport({\\n          viewportWidth: 375\\n        })\\n      ]\\n    }\\n  }\\n})\\n```\\n这样我们书写的 px 单位就会转为 vw 或 vh ，很轻松地解决了适配问题。\\n\\n## resolve.alias\\n定义路径别名也是我们常用的一个功能，我们通常会给 `scr` 定义一个路径别名：\\n\\n```js\\n// vite.config.js\\nimport { defineConfig } from 'vite'\\nimport path from 'path'\\n\\nexport default defineConfig({\\n  resolve: {\\n    alias: {\\n      '@': path.resolve(__dirname, './src') // 路径别名\\n    }\\n  }\\n})\\n```\\n我们也可以使用插件，来自动给 `src` 和 `src` 下所有的文件夹定义路径别名：\\n\\n```js\\n// vite.config.js\\nimport { defineConfig } from 'vite'\\nimport { ViteAliases } from './node_modules/vite-aliases' // 通过名称引入会报错，可能是插件问题\\n\\nexport default defineConfig({\\n  plugins: [\\n    ViteAliases()\\n  ]\\n})\\n```\\n相应的路径别名如下：\\n```\\nsrc -> @\\n  assets -> @assets\\n  components -> @components\\n  router -> @router\\n  stores -> @stores\\n  views -> @views\\n  ...\\n```\\n\\n## resolve.extensions\\n导入时想要省略的扩展名列表。默认值为 `['.mjs', '.js', '.ts', '.jsx', '.tsx', '.json']` 。\\n\\n```js\\n// vite.config.js\\nimport { defineConfig } from 'vite'\\nimport path from 'path'\\n\\nexport default defineConfig({\\n  resolve: {\\n    extensions: ['.js', '.ts', '.json'] // 导入时想要省略的扩展名列表\\n  }\\n})\\n```\\n\\n注意：不建议忽略自定义导入类型的扩展名（例如：`.vue`），因为它会影响 IDE 和类型支持。\\n\\n## optimizeDeps.force\\n是否开启强制依赖预构建。`node_modules` 中的依赖模块构建过一次就会缓存在 `node_modules/.vite/deps` 文件夹下，下一次会直接使用缓存的文件。而有时候我们想要修改依赖模块的代码，做一些测试或者打个补丁，这时候就要用到强制依赖预构建。\\n\\n```js\\n// vite.config.js\\nimport { defineConfig } from 'vite'\\n\\nexport default defineConfig({\\n  optimizeDeps: {\\n    force: true // 强制进行依赖预构建\\n  },\\n})\\n```\\n除了这个方法，我们还可以通过删除 `.vite` 文件夹或运行 `npx vite --force` 来强制进行依赖预构建。\\n\\n## server.host\\n指定服务器监听哪个 IP 地址。默认值为 `localhost` ，只会监听本地的 `127.0.0.1` 。当我们开发移动端项目时，需要在手机浏览器上访问当前项目。这时候可以将 host 设置为  `true` 或 `0.0.0.0` ，这样服务器就会监听所有地址，包括局域网和公网地址。\\n\\n```js\\n// vite.config.js\\nimport { defineConfig } from 'vite'\\n\\nexport default defineConfig({\\n  server: {\\n    host: true // 监听所有地址\\n  }\\n})\\n```\\n效果如下：\\n\\n![5e157d5a4ca827d5dafbc354ff135e1.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be981240d2f044c88a47ac6e0472ca9e~tplv-k3u1fbpfcp-watermark.image?)\\n\\n当手机和电脑处于同一个网络环境下，我们就可以通过下面那个地址进行访问了。\\n## server.proxy\\n反向代理也是我们经常会用到的一个功能，通常我们使用它来进行跨域：\\n\\n```js\\n// vite.config.js\\nimport { defineConfig } from 'vite'\\n\\nexport default defineConfig({\\n  server: {\\n    proxy: {\\n      // 字符串简写写法\\n      '/foo': 'http://localhost:4567',\\n      // 选项写法\\n      '/api': {\\n        target: 'http://jsonplaceholder.typicode.com',\\n        changeOrigin: true,\\n        rewrite: (path) => path.replace(/^\\\\/api/, '')\\n      },\\n      // 正则表达式写法\\n      '^/fallback/.*': {\\n        target: 'http://jsonplaceholder.typicode.com',\\n        changeOrigin: true,\\n        rewrite: (path) => path.replace(/^\\\\/fallback/, '')\\n      },\\n      // 使用 proxy 实例\\n      '/api': {\\n        target: 'http://jsonplaceholder.typicode.com',\\n        changeOrigin: true,\\n        configure: (proxy, options) => {\\n          // proxy 是 'http-proxy' 的实例\\n        }\\n      },\\n      // Proxying websockets or socket.io\\n      '/socket.io': {\\n        target: 'ws://localhost:3000',\\n        ws: true\\n      }\\n    }\\n  }\\n})\\n```\\n\\n## base\\n开发或生产环境服务的公共基础路径。可以是以下几种值：\\n-   绝对 URL 路径，例如 `/foo/`\\n-   完整的 URL，例如 `https://foo.com/`\\n-   空字符串或 `./`（用于嵌入形式的开发）\\n\\n```js\\n// vite.config.js\\nimport { defineConfig } from 'vite'\\n\\nexport default defineConfig({\\n  base: '/foo/' // 开发或生产环境服务的公共基础路径\\n})\\n```\\n\\n## build.outdir\\n指定打包文件的输出目录。默认值为 `dist` ，当 `dist` 被占用或公司有统一命名规范时，可进行调整。\\n\\n```js\\n// vite.config.js\\nimport { defineConfig } from 'vite'\\n\\nexport default defineConfig({\\n  build: {\\n    outDir: 'build' // 打包文件的输出目录\\n  }\\n})\\n```\\n## build.assetsDir\\n指定生成静态资源的存放目录。默认值为 `assets` ，可根据需要进行调整。\\n```js\\n// vite.config.js\\nimport { defineConfig } from 'vite'\\n\\nexport default defineConfig({\\n  build: {\\n    assetsDir: 'static' // 静态资源的存放目录\\n  }\\n})\\n```\\n## build.assetsInlineLimit\\n图片转 base64 编码的阈值。为防止过多的 http 请求，Vite 会将小于此阈值的图片转为 base64 格式，可根据实际需求进行调整。\\n```js\\n// vite.config.js\\nimport { defineConfig } from 'vite'\\n\\nexport default defineConfig({\\n  build: {\\n    assetsInlineLimit: 4096 // 图片转 base64 编码的阈值\\n  }\\n})\\n```\\n## plugins\\n插件相信大家都不陌生了。我们可以使用官方插件，也可以社区插件。如使用 [@vitejs/plugin-vue](https://github.com/vitejs/vite/tree/main/packages/plugin-vue) 提供 Vue3 单文件组件的支持，使用 [vite-plugin-mock](https://github.com/vbenjs/vite-plugin-mock) 让我们更轻松地 mock 数据。\\n\\n```js\\nnpm i mockjs -S\\nnpm i vite-plugin-mock -D\\n```\\n```js\\n// vite.config.js\\nimport { defineConfig } from 'vite'\\nimport vue from '@vitejs/plugin-vue'\\nimport { viteMockServe } from 'vite-plugin-mock'\\n\\nexport default defineConfig({\\n  plugins: [\\n    vue(),\\n    viteMockServe()\\n  ]\\n})\\n```\\n更多社区插件，大家可以查看 [awesome-vite](https://github.com/vitejs/awesome-vite#plugins) 。当然如果有特殊需求，我们也可以自己写一个插件。后续我也会带大家手写一个自己的插件。\\n\\n## 完整代码\\n\\n```js\\n// vite.config.js\\nimport { defineConfig } from 'vite' // 使用 defineConfig 工具函数获取类型提示：\\nimport vue from '@vitejs/plugin-vue'\\nimport { viteMockServe } from 'vite-plugin-mock'\\n\\nexport default defineConfig({\\n  base: '/foo/', // 开发或生产环境服务的公共基础路径\\n  optimizeDeps: {\\n    force: true // 强制进行依赖预构建\\n  },\\n  css: {\\n    preprocessorOptions: {\\n      scss: {\\n        additionalData: `@import '/src/assets/styles/variables.scss';` // 引入全局变量文件\\n      }\\n    },\\n    postcss: {\\n      plugins: [\\n        // viewport 布局适配\\n        postcssPxToViewport({\\n          viewportWidth: 375\\n        })\\n      ]\\n    }\\n  },\\n  resolve: {\\n    alias: {\\n      '@': path.resolve(__dirname, './src') // 路径别名\\n    },\\n    extensions: ['.js', '.ts', '.json'] // 导入时想要省略的扩展名列表\\n  },\\n  server: {\\n    host: true, // 监听所有地址\\n    proxy: {\\n      // 字符串简写写法\\n      '/foo': 'http://localhost:4567',\\n      // 选项写法\\n      '/api': {\\n        target: 'http://jsonplaceholder.typicode.com',\\n        changeOrigin: true,\\n        rewrite: (path) => path.replace(/^\\\\/api/, '')\\n      },\\n      // 正则表达式写法\\n      '^/fallback/.*': {\\n        target: 'http://jsonplaceholder.typicode.com',\\n        changeOrigin: true,\\n        rewrite: (path) => path.replace(/^\\\\/fallback/, '')\\n      },\\n      // 使用 proxy 实例\\n      '/api': {\\n        target: 'http://jsonplaceholder.typicode.com',\\n        changeOrigin: true,\\n        configure: (proxy, options) => {\\n          // proxy 是 'http-proxy' 的实例\\n        }\\n      },\\n      // Proxying websockets or socket.io\\n      '/socket.io': {\\n        target: 'ws://localhost:3000',\\n        ws: true\\n      }\\n    }\\n  },\\n  build: {\\n    outDir: 'build', // 打包文件的输出目录\\n    assetsDir: 'static', // 静态资源的存放目录\\n    assetsInlineLimit: 4096 // 图片转 base64 编码的阈值\\n  },\\n  plugins: [\\n    vue(),\\n    viteMockServe()\\n  ]\\n})\\n```\\n\\n## 小结\\n其实日常开发掌握这些配置就足够了，如果遇到特殊的场景我们再去查文档就可以，而不需要一开始就把所有配置都学习一遍。Vite 配置整体来说和 Webpack 大同小异，只不过 Vite 更傻瓜式，把能做的基本都帮我们做好了。我们只用修改少量配置，甚至不用修改配置，就可以满足日常开发的需求。\\n\\n你还知道哪些常用的配置呢，欢迎在评论区留言。也欢迎关注我的专栏 [Vue3 特训营](https://juejin.cn/column/7139898687873875981) ，后面我会分享更多 Vue3 和 Vite 相关的知识。\\n\\n如果本文对你有所帮助，记得点个赞呦！😋\\n\\n参考资料：[Vite 官方中文文档](https://cn.vitejs.dev)\\n",
        "tags": [
            "前端",
            "Vue.js",
            "Vite"
        ]
    },
    {
        "article_id": "7175456651007230013",
        "cover_image": "",
        "title": "【知识梳理】前端路由的两种模式",
        "brief": "一、概述  这是几年前写的的一篇文章，发在了简书上面，现在看来仍然有一些不足，所以再次整理一下发在掘金。 二、什么是单页面应用（SPA）？  首先我们需要了解一下前置的基础知识————SPA（单页面应",
        "user_name": "许啊切",
        "view_count": 823,
        "collect_count": 13,
        "comment_count": 0,
        "avatar": "https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/mirror-assets/169989a5685a90730fe~tplv-t2oaga2asx-image.image",
        "category": "前端",
        "content": "### 一、概述\\n---\\n&emsp;这是几年前写的的一篇文章，发在了简书上面，现在看来仍然有一些不足，所以再次整理一下发在掘金。\\n\\n### 二、什么是单页面应用（SPA）？\\n---\\n&emsp;首先我们需要了解一下前置的基础知识————SPA（单页面应用）。互联网是一步一步发展到今天的，让我们用一个普通用户能够察觉到的衡量因素——上网速度，来观察互联网的发展。由一开始的拨号上网，到宽带上网，再到如今的百兆光纤等等。信息的高速公路逐渐发展应用于全球的各个方面。\\n\\n&emsp;对于Web应用来说，也朝着内容更加丰富，上网更加便捷，浏览更加快速的方向发展。还记得12年高中的时候，使用oppo a203这款非智能手机登录3G qq进行农场偷菜和抢车位，还是很有趣的。话说回来，传统的一个页面映射了一个html、css、js的模式，也逐渐有了自己的弊端。那就是切换页面需要从服务器上下载对应的html等静态资源文件。这些文件大小不算小，就造成了页面加载速度的慢，影响了用户体验。同时这种模式的前端开发还处于JQuery和前后端没有分离的阶段。\\n\\n&emsp；时代不断的在发展。在这个快节奏的时代，互联网都在追求更快、更丝滑的体验。基于这样的背景，一个新的模式产生了：组件化。组件化的模式缩小了文件的颗粒度，把不同的逻辑视图块分割为小的独立组件，将不同页面当成多个组件之间的排列组合。而 html 则是作为包裹这些组合后的多个组件的容器。\\n\\n&emsp;这样下来，用户访问多个页面的过程中，浏览器只会从服务器上下载一个 html 文件。当页面需要切换时，浏览器从服务器上加载相应的组件js代码，使得传输的数据比传统模式大大减少了，从而加快了web页面的流畅度与加载速度，给用户一种“快速丝滑”的体验。这样的应用也叫做单页面应用，因为整个应用只有一个 html 文件。这种开发理念催生了目前Vue、React框架的诞生，也让前端开发走进了前后端分离的阶段了，有了更多的话语权。\\n\\n\\n### 三、什么是前端路由？\\n---\\n&emsp;再说明前端路由是什么之前，我们先要知道路由是什么意思。路由顾名思义就是指通向某个地方的路径，说白了就是去哪要怎么走，像是公园里面的路牌一样。传统的路由指的是后端路由，用户在浏览器中访问一个页面：https://www.baidu.com/index。 浏览器把这个路径发送给后端服务器，后端服务器根据这个地址找到对应的html文件，然后把该页面文件发送给浏览器，浏览器接受到了html文件后渲染出来展示给用户。\\n\\n&emsp;对于 Vue 这类渐进式的前端开发框架，为了构建SPA，需要引入了前端路由。因为当 url 发生改变，只是表示页面组件的排列组合方式变了，并不需要向后端发送请求重载页面，这也是 Vue-Router 的存在意义。\\n\\n&emsp;前端路由的核心，就在于：**改变视图的同时不会向后端发出重新获取html文件的请求**。\\n\\n### 四、前端路由造成的矛盾？\\n---\\n&emsp;前端路由是不同的 Url 对应不同的组件排列组合方式，但是浏览器不知道运行的是 SPA，它还是认为是传统的 Web 应用——不同页面对应不同的 html文件。所以当你的 url 发生改变时，浏览器依然会向服务器发起新的 url 的资源请求，这是我们不希望浏览器做的。\\n&emsp;我们想要做到改变路由的同时不会向后端发出请求（注意⚠，这里指的是对于html文件的请求）。\\n\\n### 五、浏览器提供的两种支持：hash\\n---\\n&emsp;hash——即地址栏Url的 `#` 符号(此 hash 不是密码学里的散列运算)，它代表着网页中的一个位置，相当于一个锚点。它右边的字符，就是该位置的标识符。比如：`https://www.example.com/index.html/#/print`就代表了网页 index 的 print 位置。浏览器在读取这个 url 后，会自动将 print 位置滚动至可视区域。\\n\\n1. 如何设置 `#` 位置呢？</br>\\n&emsp;为网页设置 hash 标识符，有两个方法。第一个是使用a标签的name属性，比如\\\\<a name=\\\"print\\\">\\\\</a>，第二个是id属性，比如\\\\<div id=\\\"print\\\">\\\\</div>\\n\\n2. `#`的特点？</br>\\n&emsp;比如这个url：`http://www.jianshu.com/#/article`，hash的值是`#/article`。它的特点在于hash值虽然出现在 url 中，但不会被包括在 http 请求中的，对后端完全没有影响。因此改变 hash 值不会重新加载页面。\\n\\n3. 如何读取`#`值?</br>\\n&emsp;使用 window.location.hash 可以读取 hash 值的，它的读取结果是`#/article`这种格式的，包括#符号在内。另外，这个属性是可读可写的。写入时，则会在不重载网页的前提下，创造一条访问历史记录。每一次改变#后的部分，都会在浏览器的访问历史中增加一个记录，使用\\\"后退\\\"按钮，就可以回到上一个位置。这对于ajax应用程序特别有用，可以用不同的#值，表示不同的访问状态，然后向用户给出可以访问某个状态的链接。值得注意的是，上述规则对IE 6和IE 7不成立，它们不会因为#的改变而增加历史记录。\\n\\n4. Vue-Router如何监听 hash 的改变从而向服务器请求不同的组件js代码？</br>\\n&emsp;答案是浏览器的提供的事件监听机制。当 URL 的片段标识符更改时，将触发**hashchange**事件 (跟在＃符号后面的 URL 部分，包括＃符号)，所以可以再 addEventListener 方法中使用 `hashchange`事件：\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1cbf9d85aa3e47a39f64aea364fb3ce4~tplv-k3u1fbpfcp-watermark.image?)\\n\\n### 六、浏览器提供的两种支持：history\\n---\\n&emsp;HTML5 history对象新增了一个 `history.pushState()`方法用于向当前浏览器会话的历史堆栈中添加一个状态（state），每当用户导航到新状态时，都会触发[`popstate`](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/popstate_event)事件，并且该事件的状态属性包含历史记录条目的状态对象的副本。这两个方法应用于浏览器的历史记录栈，在当前已有的 `back`、`forward`、`go` 的基础之上，它们提供了对历史记录进行修改的功能。只是当它们执行修改时，虽然改变了当前的 URL，但浏览器不会立即向后端发送请求。\\n\\n&emsp;Vue-Router在 history 模式下重写了 window.pushState 和 window.replaceState 方法，让这个方法在调用时也会触发 `popstate`事件。这样通过监听 popstate 事件就可以知道页面url发生了改变，从而向服务器请求新的js文件。\\n\\n### 七、hash 和 history 的使用场景\\n---\\n&emsp;一般场景下，hash 和 history 都可以，除非你更在意颜值， `#` 符号夹杂在 URL 里看起来确实有些丑陋。\\n>如果不想要很丑的 hash，我们可以用路由的 history 模式，这种模式充分利用 history.pushState API 来完成  \\nURL 跳转而无须重新加载页面。—— [Vue-router 官网](https://router.vuejs.org/zh-cn/essentials/history-mode.html)。\\n\\n另外，根据 [Mozilla Develop Network](https://developer.mozilla.org/zh-CN/docs/Web) 的介绍，调用 `history.pushState()` 相比于直接修改 `hash`，存在以下优势：\\n\\n-   `pushState()` 设置的新 URL 可以是与当前 URL 同源的任意 URL；而 `hash` 只可修改 `#` 后面的部分，因此只能设置与当前 URL 同文档的 URL；\\n-   `pushState()` 设置的新 URL 可以与当前 URL 一模一样，这样也会把记录添加到栈中；而 `hash` 设置的新值必须与原来不一样才会触发动作将记录添加到栈中；\\n-   `pushState()` 通过 `stateObject` 参数可以添加任意类型的数据到记录中；而 `hash` 只可添加短字符串；\\n-   `pushState()` 可额外设置 `title` 属性供后续使用。\\n\\n当然啦，`history` 也不是样样都好。SPA 虽然在浏览器里游刃有余，但真要通过 URL 向后端发起 HTTP 请求时，两者的差异就来了。尤其在用户手动输入 URL 后回车，或者刷新（重启）浏览器的时候。\\n\\n1.  `hash` 模式下，仅 `hash` 符号之前的内容会被包含在请求中，如 `http://www.abc.com`，因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回 404 错误。\\n1.  `history` 模式下，前端的 URL 必须和实际向后端发起请求的 URL 一致，如 `http://www.abc.com/book/id`。如果后端缺少对 `/book/id` 的路由处理，将返回 404 错误。[Vue-Router 官网](https://router.vuejs.org/zh-cn/essentials/history-mode.html)里如此描述： **“不过这种模式要玩好，还需要后台配置支持……所以呢，你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。”**\\n\\n### 八、小结\\n---\\n&emsp;结合自身例子，对于一般的 Vue + Vue-Router + Webpack + XXX 形式的 Web 开发场景，用 history 模式即可，只需在后端（Apache 或 Nginx）进行简单的路由配置，同时搭配前端路由的 404 页面支持。\\n\\n\\n\\n",
        "tags": [
            "前端",
            "Vue.js",
            "JavaScript"
        ]
    },
    {
        "article_id": "7170746000112353293",
        "cover_image": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/414d1be720dd4586b59a8fc5cca4f31f~tplv-k3u1fbpfcp-watermark.image?",
        "title": "Nuxt3正式版发布，教你用vite+nuxt+pinia+vueuse搞定前端SSR项目",
        "brief": "翘首期盼，终于终于，稳定版的Nuxt3它来了；Nuxt3是基于Vite、Vue3和Nitro的Nuxt框架的重构，具有一流的Typescript支持，且这次更新对内核进行了精简，使之速度更快，体验更好",
        "user_name": "易师傅",
        "view_count": 11520,
        "collect_count": 317,
        "comment_count": 55,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/c01c52dcc59b98c1b026eb96f408329f~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: cyanosis\\n---\\n\\n> 作者：[易师傅](https://github.com/jeddygong) 、[github](https://github.com/jeddygong)\\n>\\n> 声明：文章为稀土掘金技术社区首发签约文章，14天内禁止转载，14天后未获授权禁止转载，侵权必究！\\n\\n# 前言\\n\\n大家好，我是[易师傅](https://github.com/jeddygong)，一个专门搞前端的搬（touch）砖（fish）师傅 ~\\n\\n翘首期盼，终于终于，稳定版的 `Nuxt3` 它来了，它带着六亲不认的步伐走过来了 ~\\n\\n11 月 16 日，全球最大的 `Nuxt` 会议 `Nuxt Nation 2022` 在线举行，并正式发布了 `Nuxt.js 3.0` 的第一个稳定版本。\\n\\n[Nuxt3](https://nuxt.com/) 是基于 `Vite`、`Vue3` 和 `Nitro` 的 `Nuxt` 框架的重构，具有一流的 `Typescript` 支持，且这次更新对内核进行了精简，使之速度更快，体验更好。\\n\\n\\n\\n# 一、了解 `SSR`\\n\\n在介绍 `Nuxt3` 之前，肯定要先介绍一波 `服务端渲染`，毕竟 `Nuxt` 就是一个基于 `Vue.js` 的服务端渲染应用框架；\\n\\n## 什么是 `SSR`\\n   `服务器端渲染`（Server-Side Rendering）是指由服务端完成页面的 HTML 结构拼接的页面处理技术，发送到浏览器，然后为其绑定状态与事件，成为完全可交互页面的过程。\\n\\n   简单理解就是html是由服务端写出，可以动态改变页面内容，即所谓的动态页面。早年的 [php](https://baike.baidu.com/item/php/9337)、[asp](https://baike.baidu.com/item/asp/128906) 、[jsp](https://baike.baidu.com/item/jsp/141543) 这些 Server page 都是 SSR 的。\\n   \\n## 为什么使用 `SSR`\\n-   网页内容在服务器端渲染完成，一次性传输到浏览器，所以 `首屏加载速度非常快`；\\n-   `有利于SEO`，因为服务器返回的是一个完整的 html，在浏览器可以看到完整的 dom，对于爬虫、百度搜索等引擎就比较友好；\\n\\n# 二、Nuxt 3\\n\\n苦于在 `Nuxt3.0 RC` 版本中的不稳定等等一系列问题，现在它终于稳定的发布了 ~\\n\\n`Nuxt` 是一个基于 `Vue.js` 的服务端渲染应用框架，如同 `next` 对于 `react` 一般；\\n\\n\\n## 更新 API 稳定性\\n\\nNuxt 3 带有稳定的、生产就绪的 API 和 50 多个由社区和 Nuxt 团队使用 Nuxt Kit 构建的[支持模块](https://nuxt.com/modules)。\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff35c9e797c14170b7d850998884e718~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n## 浏览器和 Node.js 支持 \\n\\n**浏览器支持**：`Nuxt 3` 官方仅支持长期自动更新的浏览器，且更新过程不需要用户的干预，例如 `Chrome`、`Firefox`、`Safari` 等。\\n\\n**服务端支持**：`Nuxt 3` 目前支持 Node.js 14、16、18 和 19。Nuxt.js 团队鼓励大家使用 Node.js 的最新 LTS 版本，一旦它们被主要部署平台广泛采用，Nuxt.js 团队就会将其推送。由于 14.x 即将结束支持，强烈建议更新到最新的 18.x 版本。\\n\\n\\n## 新特性包括：\\n\\n-   **更轻量**：以现代浏览器为目标的服务器部署和客户端产物最多可缩小 75 倍\\n-   **更快**：基于 nitro 提供动态代码分割能力，以优化冷启动性能\\n-   **Hybrid**：增量静态生成和其他的高级功能现在都成为可能\\n-   **Suspense**：在任意组件和导航前后都可以获取数据\\n-  **Composition API**：使用 Composition API 和 Nuxt 3 的 composables 实现真正的代码复用\\n-   **Nuxt CLI**：没有任何依赖，帮你轻松搭建项目和集成模块\\n-   **Nuxt Devtools**：通过直接在浏览器中查看信息和快速修复实现更快地工作\\n-   **Nuxt Kit**：具有 Typescript 和跨版本兼容性的全新模块开发\\n-   **Webpack 5**：更快的构建时间和更小的包大小，无需配置\\n-   **Vite**：使用 Vite 作为打包工具，体验闪电般快速的 HMR\\n-   **Vue 3**：Vue 3 是你下一个 Web 应用程序的坚实基础\\n-   **TypeScript**：使用原生 TypeScript 和 ESM 构建，无需额外步骤\\n\\n更多新特性见[官网文档](https://nuxt.com/docs/getting-started/introduction)\\n\\n\\n## 项目模板快速查看\\n[github 仓库地址](https://github.com/jeddygong/vite-templates/tree/master/vite-nuxt3-app)\\n\\n# 三、初始化项目\\n\\n* Nodejs >= 16.11\\n* pnpm >= 7.x\\n\\n**1.初始化：**\\n```\\nnpx nuxi init first-nuxt-app\\n```\\n\\n**2.安装依赖**\\n```\\ncd first-nuxt-app\\n\\n# yarn\\nyarn install\\n\\n# npm\\nnpm install\\n\\n# pnpm\\npnpm install\\n```\\n\\n**注意：** 如果你用 `pnpm` 安装依赖，请创建一个 `.npmrc` 文件，且设置:\\n\\n```\\nshamefully-hoist=true\\n```\\n\\n再使用 pnpm 安装\\n\\n```\\npnpm install\\n```\\n\\n\\n**3. 运行**\\n\\n```\\npnpm run dev\\n```\\n\\n**4. 访问**\\n\\n打开本地链接 http://localhost:3000/ 就可以开始访问了\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2502c9e554cf496491f0369e8ca91a07~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n\\n**Q：** 啊，这也太简单了吧，那是不是就代表结束了，那我们就开始研发吧！\\n\\n**A：** 好像是的，一时之间我竟然语塞，毕竟可以正常打开访问了 ~\\n\\n**5.思考：**\\n\\n我们看看仓库代码（如下图）\\n\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/871d2c6c50484957b75d7e8fddf55e1f~tplv-k3u1fbpfcp-watermark.image?)\\n\\n发现仓库代码啥都没有，就一个 `app.vue`，身为一个前端 er，一看这跟我们常见的前端框架目录架构不一样啊！\\n\\n这不是在跟我开玩笑吗？\\n\\n别急嘛，您接着往下看 ~\\n\\n# 四、配置 `eslint + prettier + husky + commitlint`\\n\\n**eslint + prettier**：`代码质量` 与 `代码风格` 是我们必须要做的项任务，正所谓没有规矩不成方圆；\\n\\n**husky + commitlint**：`git hooks` 和 `提交检测` 我们也是必须要集成的；\\n\\n这样子的配置我之前文章讲过许多，感兴趣的可以参考我之前文章 《[手把手教你用 vite + vue3 + ts + pinia + vueuse 打造企业级前端项目](https://juejin.cn/post/7079785777692934174#heading-8)》和《[非大厂的我们，如何去搞Vue/React Hooks和Utils的企业开源工具库？](https://juejin.cn/post/7165671737076482062#heading-3)》\\n\\n关于为什么要有他们，如果你还有疑问，可以看看我的上一篇文章[《前端规范都有哪些》](https://juejin.cn/post/7151983972828839943#heading-5)的介绍；\\n\\n# 五、新建常用目录\\n\\n我们刚刚讲了，发现整个仓库就一个 `app.vue`，那么我们当然不能将就他啊，肯定是要折腾一番呀 ~\\n\\n## 1. 新建 `app(src)` 目录\\n```\\nmkdir src\\n```\\n\\n并且把 `app.vue` 文件移入到 `src` 目录下\\n\\n同时修改配置文件 `nuxt.config.ts`：\\n```ts\\n// https://nuxt.com/docs/api/configuration/nuxt-config\\nexport default defineNuxtConfig({\\n  srcDir: 'src/',\\n})\\n```\\n\\n再 pnpm dev 运行，发现跟上面初始化的一样\\n\\n## 2. 配置页面路由目录：`pages`\\n\\n**1.新建 `src/pages` 目录：**\\n```\\nmkdir src/pages\\n```\\n\\n**2. 新建 `src/pages/index.vue` 首页：**\\n```\\ntouch src/pages/index.vue\\n```\\n\\n**3. 配置 `src/pages/index.vue`**\\n\\n```\\n<template>\\n  <div>\\n    <h1>欢迎来到易师傅的第一个页面</h1>\\n  </div>\\n</template>\\n```\\n\\n**4. 修改 `src/app.vue` 入口**\\n```\\n<template>\\n  <div>\\n    <!-- 路由出口 -->\\n    <NuxtPage></NuxtPage>\\n  </div>\\n</template>\\n```\\n\\n**5. 再 `pnpm dev` 运行**\\n\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/816beb2977004a908f65c1d614a9a101~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n大家再不烦想一下：**到这里如果你想配置一个列表页或者详细页，应该怎么去做呢？**\\n\\n## 3. 新增多个页面静态路由\\n\\n正如上面所问的，如何去配置一个 `列表页` 或者 `详细页`；\\n\\n其实配置方法很简单，和上面的 `src/pages/index.vue` 首页类似；\\n\\n下面我们以 `列表页` 为例：\\n\\n**1.新建 `src/pages/list.vue` 文件：**\\n```\\n<template>\\n  <div>\\n    <h1>欢迎来到易师傅的列表页面</h1>\\n    <ul>\\n      <li>11111</li>\\n      <li>22222</li>\\n      <li>33333</li>\\n      <li>44444</li>\\n      <li>55555</li>\\n      <li>66666</li>\\n      <li>77777</li>\\n      <li>88888</li>\\n      <li>99999</li>\\n    </ul>\\n  </div>\\n</template>\\n```\\n\\n**2. 在 `src/pages/index.vue` 配置路由跳转**\\n\\n```\\n<template>\\n  <div>\\n    <h1>欢迎来到易师傅的第一个页面</h1>\\n\\n    <NuxtLink to=\\\"/list\\\">进入列表页</NuxtLink>\\n  </div>\\n</template>\\n```\\n**3. 预览**\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ad7fd5a1c8a463eac965a43e11a459b~tplv-k3u1fbpfcp-watermark.image?)\\n\\n`<NuxtLink>` 是 Vue Router 中 `<RouterLink>` 组件和 HTM L`<a>` 标签的替代品；\\n\\n关于 NuxtLink 的更多使用，可参考[官方文档](https://nuxt.com/docs/api/components/nuxt-link#nuxtlink)\\n\\n> 根据上面的 `src/pages/list.vue` 文件，我们可以得知页面中 `http://localhost:3000/list` 就对应了这个文件，所以如果把 `list.vue` 换成 `detail.vue`，路由地址就是 `http://localhost:3000/detail` 了；这就代表的这个页面的静态路由了 ~\\n\\n## 4. 新增多个页面动态路由\\n\\n`动态路由` 顾名思义就是这个路由地址是可变的，是动态的；\\n\\n使用场景一般就是文章的详细页，因为一般一篇文章会有对应的一个 `id`，那这个 `id` 就是动态的；\\n\\n那如何去实现呢？\\n\\n**1. 新建 `src/pages/[id]` 目录（目录名一定要是 [id]）：**\\n```\\nmkdir src/pages/[id]\\n```\\n\\n**2. 新建 `src/pages/[id]/index.vue` 文件：**\\n```\\n<template>\\n  <div>\\n    <h1>易师傅的详细页面</h1>\\n\\n    <h2>title 1</h2>\\n\\n    <p>内容 1</p>\\n\\n    <h2>title 2</h2>\\n\\n    <p>内容 2</p>\\n\\n    <h2>title 3</h2>\\n\\n    <p>内容 3</p>\\n\\n    <h2>title 4</h2>\\n\\n    <p>内容 4</p>\\n  </div>\\n</template>\\n```\\n**3. 页面中访问：`http://localhost:3000/[id]`**\\n\\n其中 `[id]` 是一个动态的数字，可以是 `http://localhost:3000/111`，也可以是 `http://localhost:3000/222`；\\n\\n\\n## 5. 新增 `layouts` 模板\\n\\n熟悉 `php` 开发或者 `jsp` 的同学，肯定都会知道 `服务端渲染` 会有一个通用模板目录，在 nuxt3 中也有，其目录名叫 `layouts`\\n\\n像一般通用的模板，例如 `头部 header` 与 `底部 footer` 之类的，也有一些较为通用的通用模板；\\n\\n可能有些同学会问，这不就是一个公共组件吗，干嘛非得叫 `layouts` 模板；\\n\\n额... 其实你这么想也没错，但是不过他们还是有一些使用和渲染上的差异；\\n\\n\\n**1. 新建 `src/layouts` 目录**\\n\\n**2. 新建 `src/layouts/default.vue` 默认文件**\\n```\\n<template>\\n  <div>\\n    <h1>这里是易师傅的默认模板，可以添加在所有页面，也可单独添加</h1>\\n    <slot />\\n  </div>\\n</template>\\n```\\n**3. 在全局页面中配置： `src/app.vue`（也就是每个页面中都会有该模板）**\\n```\\n<template>\\n  <div>\\n    <!-- 路由出口 -->\\n    <NuxtLayout>\\n      <NuxtPage></NuxtPage>\\n    </NuxtLayout>\\n  </div>\\n</template>\\n```\\n\\n> 这样你无论打开哪个页面都会存在该模板了；\\n\\n**4. 自定义模板（类似 header、footer）**\\n\\n新建 `src/layouts/header.vue`\\n```\\n<template>\\n  <header class=\\\"header\\\">\\n    <h1>这里是易师傅的默认模板 header</h1>\\n  </header>\\n</template>\\n```\\n\\n**5. 使用自定义模板**\\n```\\n<template>\\n  <div>\\n    <NuxtLayout name=\\\"header\\\"/>\\n    <NuxtLink to=\\\"/list\\\">进入列表页</NuxtLink>\\n  </div>\\n</template>\\n```\\n\\n**6. 预览**\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f3dd09de542d425697c126e6f6904979~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n# 六、配置组件 `components`\\n\\n熟悉 `vue` 或者 `react` 的同学，对组件一定不陌生，在 `nuxt3` 同样集成了组件 `components`；\\n\\n只是在 `Nuxt3` 中会自动导入您 `components/` 目录中的所有组件，也就是说当你想使用组件时，不要 `import` 了，直接使用即可；\\n\\n## 1. 组件的使用指南\\n\\n**1. 新建 `src/components` 目录**\\n\\n**2. 新建 `src/components/ListItem.vue` 文件**\\n```\\n<template>\\n  <ul>\\n    <li>\\n      <NuxtLink to=\\\"/111\\\">111</NuxtLink>\\n    </li>\\n    <li>\\n      <NuxtLink to=\\\"/222\\\">222</NuxtLink>\\n    </li>\\n    <li>\\n      <NuxtLink to=\\\"/333\\\">333</NuxtLink>\\n    </li>\\n    <li>\\n      <NuxtLink to=\\\"/444\\\">444</NuxtLink>\\n    </li>\\n    <li>\\n      <NuxtLink to=\\\"/555\\\">555</NuxtLink>\\n    </li>\\n    <li>\\n      <NuxtLink to=\\\"/666\\\">666</NuxtLink>\\n    </li>\\n  </ul>\\n</template>\\n```\\n**3. 在 `src/pages/list.vue` 文件中使用**\\n```\\n<template>\\n  <div>\\n    <h1>欢迎来到易师傅的列表页面</h1>\\n    <ListItem></ListItem>\\n  </div>\\n</template>\\n```\\n> 根据代码，我们看到我们并没有用 `import` 去导入 `ListItem.vue`，还是正常的渲染了；\\n\\n**4. `components` 嵌套目录组件使用**\\n\\n如果您在嵌套目录中有一个组件，例如：\\n```\\n components/\\n --| list/\\n ----| detail/\\n ------| Button.vue\\n```\\n那么我们可以直接在其它地方使用：\\n```\\n<ListDetailButton />\\n```\\n\\n\\n## 2. \\\\<ClientOnly/> 组件\\n\\n`Nuxt` 提供了 `<ClientOnly>` 专门用于仅在客户端渲染组件的组件；\\n\\n要仅在客户端导入组件，请在仅客户端插件中注册该组件。\\n\\n```\\n<template>\\n  <div>\\n    <ClientOnly>\\n      <!-- 此组件仅在客户端显示 -->\\n      <Comments />\\n    </ClientOnly>\\n  </div>\\n</template>\\n\\n```\\n\\n# 七、配置插件 `plugins`\\n\\nNuxt 会自动读取 `plugins` 目录中的文件并在创建 Vue 应用程序时加载它们；\\n\\n你可以在文件名中使用 `.server` 或 `.client` 后缀来让插件在 `服务器端` 或 `客户端` 加载插件；\\n\\n**1. 新建 `src/plugins` 目录**\\n\\n**2. 以 vue 指令为例：新建 `src/plugins/directives.ts` 文件**\\n\\n```\\nexport default defineNuxtPlugin((nuxtApp) => {\\n  nuxtApp.vueApp.directive('focus', {\\n    mounted (el) {\\n      el.focus()\\n    },\\n    getSSRProps (binding, vnode) {\\n      // you can provide SSR-specific props here\\n      return {}\\n    }\\n  })\\n})\\n```\\n\\n> 当然还有其它许多 vue 关联的插件，这里就不一一举例了；\\n\\n\\n# 八、用 `composables` 灵活配置 `hooks`\\n\\n在 `Nuxt 3` 中使用该目录时，`composables/` 目录将自动导入，将 Vue 可组合项（Hooks）自动导入到您的应用程序中，即不需要在其它地方 `import`；\\n\\n所以你如果写一些通用的 `hooks`，只需放入该目录下即可；\\n\\n## `composables` 的基本使用指南\\n\\n**1. 新建 `src/composables` 目录**\\n\\n**2. 新建 `src/composables/useFoo.ts` 文件**\\n```\\nexport const useFoo = () => {\\n  return useState('foo', () => 'bar')\\n}\\n```\\n\\n**3. 在 `src/pages/index.vue` 中使用**\\n\\n```\\n<template>\\n  <div>\\n    <h1>欢迎来到易师傅的第一个页面</h1>\\n    <NuxtLink to=\\\"/list\\\">进入列表页</NuxtLink>\\n  </div>\\n</template>\\n\\n<script setup>\\n  const foo = useFoo()\\n</script>\\n```\\n\\n> 根据以上操作，你可以创建属于你自己的 hooks\\n\\n# 九、`Nuxt` 常用的 `Hooks`\\n\\n> 以下 hooks 为内部集成的 API，不需要手动 import 导入即可使用；\\n\\n## 1. useAppConfig\\n\\n访问项目中的 Nuxt 配置\\n```\\nconst appConfig = useAppConfig()\\n\\nconsole.log(appConfig)\\n```\\n## 2. useAsyncData\\n\\n在页面、组件和插件中，您可以使用 useAsyncData 来访问异步返回的数据；\\n```\\nconst { data, pending, error, refresh } = await useAsyncData(\\n  'mountains',\\n  () => $fetch('https://api.nuxtjs.dev/mountains')\\n)\\n```\\n\\n## 3. useFetch\\n\\n顾名思义，这就是一个 fetch 请求；\\n\\n在页面、组件或者插件中可以使用 `useFetch` 获取任意URL资源。\\n\\n`useFetch`是对`useAsyncData`包装，自动生成key同时推断响应类型，用起来更简单。\\n\\n```\\nconst param1 = ref('value1')\\nconst { data, pending, error, refresh } = await useFetch('https://api.nuxtjs.dev/mountains',{\\n    query: { param1, param2: 'value2' }\\n})\\n```\\n\\n## 4. useCookie\\n\\n在页面、组件和插件中，可以使用 `useCookie `一个 SSR 友好的 hooks 来读取和写入 cookie。\\n\\n```\\n<template>\\n  <div>\\n    <h1> Counter: {{ counter || '-' }}</h1>\\n    <button @click=\\\"counter = null\\\">\\n      reset\\n    </button>\\n    <button @click=\\\"counter--\\\">\\n      -\\n    </button>\\n    <button @click=\\\"counter++\\\">\\n      +\\n    </button>\\n  </div>\\n</template>\\n\\n<script setup>\\nconst counter = useCookie('counter')\\ncounter.value = counter.value || Math.round(Math.random() * 1000)\\n</script>\\n\\n```\\n## 5. useHead\\n\\nNuxt 提供 `useHead` 可组合项来添加和自定义 Nuxt 应用程序各个页面的头部属性。\\n\\n## 6. useRoute\\nuseRoute 是一个在实际项目开发中使用较多的 hooks，主要返回当前路由的一些数据；并且必须在 `setup` 函数、插件或路由中间件中调用。\\n```\\n<script setup>\\nconst route = useRoute()\\nconst { data: mountain } = await useFetch(`https://api.nuxtjs.dev/mountains/${route.params.slug}`)\\n</script>\\n\\n<template>\\n  <div>\\n    <h1>{{ mountain.title }}</h1>\\n    <p>{{ mountain.description }}</p>\\n  </div>\\n</template>\\n\\n```\\n\\n## 7. useRouter\\n\\nuseRouter 返回路由器的实例，并且必须在设置函数、插件或路由中间件中调用。\\n\\n```ts\\nconst router = useRouter();\\nrouter.back();\\nrouter.forward();\\nrouter.go();\\nrouter.push({ path: \\\"/home\\\" });\\nrouter.replace({ hash: \\\"#bio\\\" });\\n```\\n\\n> 更多 Hooks 等相关 API 请查看[官网文档](https://nuxt.com/docs/api/composables/use-app-config)\\n\\n\\n# 十、配置 `pinia`\\n\\n`pinia` 我这里就不做多的介绍了，简单解释就是与 vuex 类似的一个状态管理器；\\n\\n**1. 安装：**\\n```bash\\npnpm install pinia @pinia/nuxt\\n```\\n\\n**2. 配置 `nuxt.config.js`**\\n```ts\\n// nuxt.config.js\\nexport default defineNuxtConfig({\\n  // ... 其他配置\\n  modules: [\\n    // ...\\n    '@pinia/nuxt',\\n  ],\\n})\\n```\\n\\n**3. 新建 `src/stores/index.ts` ：**\\n\\n**4. 新建 `src/stores/useUserStore.ts` ：**\\n```\\nimport { defineStore } from 'pinia'\\n\\nconst USER_INFO = {\\n  userName: '易师傅',\\n  id: 1,\\n  sex: '男',\\n}\\n\\nexport const useUserStore = defineStore('userInfo', () => {\\n\\n  const userInfo = reactive(USER_INFO)\\n\\n  return {\\n    userInfo,\\n  }\\n})\\n```\\n\\n**5. 使用**\\n```\\n<template>\\n  <div>\\n    <strong>\\n      姓名：{{ userInfo.userName }}\\n      性别：{{ userInfo.sex }}\\n    </strong>\\n  </div>\\n</template>\\n\\n<script setup lang=\\\"ts\\\">\\nimport { useUserStore } from '@/stores'\\nconst userInfo = useUserStore().userInfo\\n</script>\\n```\\n\\n> 至此就可以愉快的使用 pinia 了 ~\\n\\n\\n# 十一、配置 `vueuse`\\n\\n`VueUse` 是一个基于 `Composition API` 的实用函数集合。\\n\\n一句话：它就是一个工具函数包；\\n\\n**1. 安装：**\\n```bash\\npnpm install @vueuse/nuxt @vueuse/core\\n```\\n\\n**2. 配置 `nuxt.config.js`**\\n```ts\\n// nuxt.config.js\\nexport default defineNuxtConfig({\\n  // ... 其他配置\\n  modules: [\\n    // ...\\n    '@vueuse/nuxt',\\n  ],\\n})\\n```\\n\\n**3. 使用 VueUse 函数：**\\n```\\n<script setup lang=\\\"ts\\\">\\nconst { x, y } = useMouse()\\n</script>\\n\\n<template>\\n  <div>pos: {{x}}, {{y}}</div>\\n</template>\\n```\\n\\n> 是的，就是这么简单\\n\\n# 十二、配置 `css/scss/less/stylus`\\n\\ncss 的集成有多种方式，有使用原生 `css` 的，也有使用 `less` 和 `scss` 的，也有使用 `stylus` 的；\\n\\n为了快速上手，这里我就不一一介绍了，下面主要以 scss 为例；\\n\\n\\n**1. 安装：**\\n```bash\\npnpm install sass --save-dev\\n```\\n\\n**2. 新建 `src/assets/styles` 目录添加默认 `default.scss`**\\n```scss\\n$bgColor: rgb(125, 159, 172);\\n$theme: red;\\n```\\n**3. 在 `nuxt.config.ts` 中添加 `scss` 的配置**\\n```ts\\nexport default defineNuxtConfig({\\n    vite: {\\n        css: {\\n            preprocessorOptions: {\\n                scss: {\\n                    additionalData: '@import \\\"@/assets/styles/default.scss\\\";'\\t\\n                }\\n            }\\n        }\\n    }\\n})\\n```\\n\\n**3. 使用**\\n```\\n<style lang=\\\"scss\\\">\\nbody {\\n  background-color: $bgColor;\\n  color: $theme;\\n}\\n</style>\\n```\\n\\n> 如果你想添加其它的 scss mixins 等方法，可自行添加\\n\\n# 十三、其它\\n\\n到这里，项目的基本结构与目录就 ok 了；\\n\\n但是咱们试想一下，如果你的领导让你去做 nuxt3 的 SSR 项目，你是不是应该考虑的更多？\\n\\n其实目前咱们只是把项目搭建完了，项目上线后的服务器的 `打包部署`、`性能压测`、`服务并发`、`负载均衡`等等都是需要咱们去考量的；\\n\\n关于这些，我会在后面新开专栏细讲，敬请期待 ~\\n\\n---\\n\\n另外，nuxt 中还有一些配置是没有讲到的，例如：\\n\\n* 其它 `plugins` 等可自行挖掘；\\n* `server` 目录下的 API 路由等；\\n* `middleware` 路由中间件；\\n* `nuxt.config.ts` 配置相关；    \\n* 等等\\n\\n感兴趣的可自行查阅[官方文档](https://nuxt.com/docs/getting-started/introduction)\\n    \\n\\n# 总结\\n\\n目前 Nuxt3 稳定版已正式发布，如若您想写一个 SSR 项目，Nuxt3 不失为你的一个选择；\\n\\n项目模板地址：[github](https://github.com/jeddygong/vite-templates/tree/master/vite-nuxt3-app)\\n\\n\\n# 最后\\n\\n该系列会是一个持续更新系列，关于 `前端基建`，笔者主要会从如下图几个方面讲解，如果您想第一时间看到我的更新文章，可以[关注我](https://juejin.cn/user/2305054774145918/columns)和我的《[前端要搞基建](https://juejin.cn/column/7139087916306792462)》专栏\\n\\n\\n![前端基建之路.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a19d71d87a224af3962f634172e031d5~tplv-k3u1fbpfcp-watermark.image?)\\n\\n专栏往期更新文章：\\n\\n1. [非大厂的我们，要如何去搞前端基建？](https://juejin.cn/post/7144881028661723167)\\n2. [非大厂的我们，如何去卷一套标准的前端团队规范？](https://juejin.cn/post/7151983972828839943)\\n3. [非大厂的我们，如何去搞Vue/React Hooks和Utils的企业开源工具库？](https://juejin.cn/post/7165671737076482062)\\n4. [如何管理企业工具库在pnpm monorepo多仓库模式下的版本与发包](https://juejin.cn/post/7168277813223981063)\\n\\n---\\n目前正集结一班大佬在写开源工具库（[工具库仓库地址](https://github.com/vmejs/vmejs)）；\\n\\n如果您对 `前端工具库` 感兴趣，欢迎加入我们 ~\\n\\n如果您对 `Vue Hooks` 感兴趣，想写自己的 Hooks，欢迎加入我们 ~\\n\\n如果您对 `React Hooks` 感兴趣，想写自己的 Hooks，欢迎加入我们 ~\\n\\n联系 vx: JeddyGong（备注开源）\\n\\n---\\n\\n如果想跟我一起**讨论技术吹水摸鱼**， 欢迎加入[前端学习群聊](https://juejin.cn/pin/7130457188992024583)(群人数太多，只能加vx，望谅解) vx: [JeddyGong](https://juejin.cn/pin/7130457188992024583)\\n\\n感谢大家的支持，码字实在不易，其中如若有错误，望指出，如果您觉得文章不错，记得 `点赞关注加收藏` 哦 ~\\n\\n[关注我](https://juejin.cn/user/2305054774145918/columns)，带您一起搞基建 ~",
        "tags": [
            "前端",
            "Nuxt.js",
            "Vue.js"
        ]
    },
    {
        "article_id": "7179878208001540152",
        "cover_image": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4e1194dd2364223ae202140f934ad4e~tplv-k3u1fbpfcp-watermark.image?",
        "title": "【年终总结】疫情，搬家，解封，希望",
        "brief": "回顾2022，展望2023，我正在参与2022年终总结征文大赛活动 回顾2022 接下来，有一些絮絮叨叨，你且别烦，听我跟您细细道来 沪漂的租房经历 2021年七月份正式开启沪漂之旅，初来乍到投奔了朋",
        "user_name": "晴天蜗牛不一般",
        "view_count": 1959,
        "collect_count": 1,
        "comment_count": 8,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/883440482645bc6e4a38d26ef1a7ec4a~300x300.image",
        "category": "代码人生",
        "content": "---\\ntheme: channing-cyan\\n---\\n回顾2022，展望2023，我正在参与[2022年终总结征文大赛活动](https://juejin.cn/post/7172462429929111559 \\\"https://juejin.cn/post/7172462429929111559\\\")\\n\\n# 回顾2022\\n\\n接下来，有一些絮絮叨叨，你且别烦，听我跟您细细道来\\n\\n## 沪漂的租房经历\\n\\n2021年七月份正式开启沪漂之旅，初来乍到投奔了朋友，暂居在他八号线芦恒路3.6k\\n大洋租到的一处由别墅豪宅的客厅所隔出来的屋子内😂，性价比如此之低的屋子让我对上海的房价有了新的认知\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e06489d5ce0740ccb250d54a8433a7b1~tplv-k3u1fbpfcp-watermark.image?)\\n\\n![1671682528077.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5fbd4c895d564c9c954b47afbe334806~tplv-k3u1fbpfcp-watermark.image?)\\n\\n开始找房子后，当我看到一个3k大洋的主卧时，满满的宜家风，没有丝毫犹豫 就是他了...\\n\\n这时单纯的我信心满满的以为自己淘到了性价比很高的房子，急切搬家的心情，让我都忽略了房东还没有置办齐必需的家具。\\n\\n后来，房东拼xx买了帆布柜子，塑料凳子，我自置了办公桌，室友又借了把靠椅给我（塑料凳子坐变形了），带着情绪住进了这个一眼相中的房子。\\n\\n![8ffb08c2ad7bde3117945395dfc6cb6.jpg](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e1c52248b0d429aac2054cacd1f07ad~tplv-k3u1fbpfcp-watermark.image?)\\n\\n床板空隙太大，床垫太薄，窗户漏风...\\n\\n![4c87dd584d6251b77736ebff7910bee.jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8eab95bb15149c8acb6a9efe6e36e17~tplv-k3u1fbpfcp-watermark.image?)\\n\\n压死骆驼的最后一根稻草：当我了解了沪漂同事比我小一千的房租和快十分钟的通勤后\\n\\n我这不纯纯大冤种吗😒😒😒\\n\\n合同中写了要满六个月之后方可转租...\\n\\n时间来到2022年，为了尽快将房屋转租出去，我自费将帆布柜子换成了实木衣柜（冤种上线），电脑桌也送给下一任，在春节回来后的第一个周末，房子如愿转租\\n\\n![406d0583fd29ff63f865fa33acebf54.jpg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97c89c5f42a448e2974ab66767ed15e8~tplv-k3u1fbpfcp-watermark.image?)\\n\\n有了第一次失败的租房经历，我也有了上海租房的经验，这一次我不再急功近利，找的更加耐心\\n\\n“一个人带俩猫，通勤要一个小时内，价格2.5k左右，不要隔断，不要中介，不要二房东，水电民用，家具齐全......”\\n\\n在大城市漂泊的年轻人看到这些条件应该深有体会，租到一个合适的房子唯有碰运气。\\n\\n很遗憾，这段时间没有找到让自己满意的房子，新的租户要搬进来了，于是我2.9短租了两个月的公寓，希望在这两个月内找到各方面让自己满意的房子\\n\\n大正月的开始了我的又一次搬家之旅\\n\\n理想是美好的，现实是残酷的。在这个密不透风，不见天日，房间挨着房间，几百几千户的公寓楼中，因为疫情，原本两个月的租期续到了四个月，而这四个月中我又经历了什么？\\n\\n## 被疫情笼罩的生活\\n\\n### 封控\\n公寓中空气流动差，人员密集杂乱，时不时就会有人密接次密接甚至被感染，而只要有一例，就是全封，所以我被封时间来的更早一些 3.12日 第一次因为疫情被封，3.14 日解封可以出门见见太阳了，这时全市静默的迹象已经初现，路上行人寥寥，商家大门紧闭，居家办公一周后，全市开启静默。\\n\\n原以为会一个周，两个周，谁曾想两个月，三个月，无时无刻都在怀念自由\\n\\n![Suggestion.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e2dc3f91b604fb2b1878bfa2c1fa0aa~tplv-k3u1fbpfcp-watermark.image?)\\n\\n### 工作\\n两个多个月的居家办公，让人无比的想念公司😂😂😂\\n\\n正赶上新项目启动，一切的沟通、工作都是远程，也切实感受到远程工作的壁垒，尤其是需求的沟通，各种线上会议让人心烦意乱。\\n\\n公寓里白天光线很弱，前后左右都是房间，白天像黑夜一样，作息完全乱掉，加上项目工期紧，领导的催促，几乎每天加班到深夜，凌晨倒头就睡，起床埋头就干...\\n\\n![不上班行不行啊.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b04167250e6946ac93853856faa9b7f8~tplv-k3u1fbpfcp-watermark.image?)\\n\\n### 核酸\\n原来疫情真的会让人抑郁，好在隔三岔五的核酸检测有让人透气的机会，大口大口的呼吸新鲜空气，沐浴上午的阳光，短短的二十分钟便给整个人充满了电\\n\\n咱也是一次核酸未落，有序排队，早做早撤，从未中招 \\n\\n![Suggestion (2).gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ac86f61f4e5466b910b739019db0142~tplv-k3u1fbpfcp-watermark.image?)\\n\\n### 吃饭\\n被封控，最重要也是最难的还是吃饭问题，好赖咱也是个程序员，不仅具备抢菜的技能，做饭的特质咱也有，同时，为了增进邻里关系，我也有积极的参与各种团购，据不完全统计，不到三个月的时间里雪碧+可乐，我喝了有60罐，加上政府的大力扶持，吃穿不愁，甚至胖了5斤\\n\\n一些做饭的证据(就这条件了😂)：\\n\\n![3aa4b49efbb10148064d34dfedefaea.jpg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7eb1c1b0b39743b39ce62863887dd421~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n![190fd52a48a643c86a9cd01c46ab267.jpg](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/47a23dcd2aa64cfaa9e01e98fdbdcf73~tplv-k3u1fbpfcp-watermark.image?)\\n\\n一些政府帮助的证据：\\n\\n![1671689500251.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb82ba98e4124bfa9ad55d9173a7220e~tplv-k3u1fbpfcp-watermark.image?)\\n\\n![1671689529365.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13a6a5d9df994c2aa7528b7f074b2015~tplv-k3u1fbpfcp-watermark.image?)\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61a0f2a89a954ac7a02f4aa0c0da7dab~tplv-k3u1fbpfcp-watermark.image?)\\n\\n### 解封\\n完成了项目交付，度过了饥一顿饱一顿的时刻（主要是懒的做饭，胖了纯是没有活动🤭😁😎），抑郁对我也敬而远之\\n\\n终于，迎来了解封。这一天等了太久，从冬天到春天再到夏天\\n\\n**Winter** ❄️❄️❄️\\n\\n![e10d8e1f76a5a98e27af1e96708685f.jpg](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c4842c695baa4c0c81f253575e5b8eb2~tplv-k3u1fbpfcp-watermark.image?)\\n\\n**Spring** 🌸🌸🌸\\n\\n![f5df069247dd79c62c112f9f94e2a51.jpg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/337374cf1ff04b15a45e96eaf3cbc67c~tplv-k3u1fbpfcp-watermark.image?)\\n\\n**Summer** 🏀🏀🏀\\n\\n![d4147ea6a00cb3d38f79bcc91926fb8.jpg](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/15978e9ad34b4fc98e723bcc041f46a9~tplv-k3u1fbpfcp-watermark.image?)\\n\\n解封后的第一件事情：闲逛和理发\\n\\n\\n![56bb841332dde4dcb3518f3b8d94e6c.jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5cfd2e330f77412f9695bf76e8132050~tplv-k3u1fbpfcp-watermark.image?)\\n\\n![ff0f7abd29d2cf44ad54dd8a3ac992c.jpg](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/29734b95dfc54f9ca627fc6494d9e028~tplv-k3u1fbpfcp-watermark.image?)\\n\\n第二件事情：搬家\\n\\n这一次，搬到了我心满意足，超级奈斯，赶我都不走的房子\\n![48a7e79dc6812e7e471eac4d1dcd056.jpg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87b6142c024444d6b40254801df8c9c6~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## 这一年的快速成长\\n如果2021年是我人生中的转折点（开启沪漂之旅），2022就是转折之后的阵痛期，需要适应新的环境、新的规则、新的期望等，并且需要建立新的关系、新的习惯、新的生活方式。这个过程可能会带来一些心理压力、情绪波动，尤其是在疫情之下。就像苏炳添改变起跑脚创造亚洲记录的故事一样，这一年，通过努力调整和适应，我走出了这个阵痛期并且获得了新的能力和成长\\n\\n**工作上**\\n\\n对考试系统的二次加工和改造，对原有的问卷和答题逻辑进行重构，并新增一套独立的考评方案，原系统是典型的考试系统针对考生，修改后的系统用户群体非简单的考生群体且答题时效，答题次数，问题类型，考评依据，问卷管理等等涉及到的改动之处细到字体图标，大到模块重构，跨系统业务联动\\n\\n在别人代码的基础进行大规模的二次加工和改造，且用户需求和所需逻辑与原有系统相悖时，其难度不亚于一次重构\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/84adcb07ed084371b28b7950e0c9c518~tplv-k3u1fbpfcp-watermark.image?)\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c42d08dd5134467d96feb8eb139a3d5e~tplv-k3u1fbpfcp-watermark.image?)\\n\\n这一次项目的成功交付也让我能力上得到了充分的提升，疫情期间的加班加点，业务上的沟通同时让我的沟通能力抗压能力取得了很大的进步\\n\\n\\n参与了多个业务管理系统的开发，对开发管理系统所具备的技术更加游刃有余，同事之间的合作更加流畅，用到了更多自动化工具，提高了开发效率\\n\\n做了多个可视化项目，封装了一些通用的组件比如echarts共用组件，大屏可视化ui等等，增加了更多类型的项目经验，提升了自己的组件封装能力\\n\\n**闲暇时**\\n\\n这一年开始尝试在掘金连续发表文章。\\n\\n起初是因为很多bug，问题解决以后再次遇到，第一时间还是baidu，\\n希望让自己养成一个好的习惯，在掘金记录一下。\\n\\n当开始码字时，凡事希望做到完美的心理促使自己精益求精，慢慢的写的字越来越多，问题记录的愈加详细，到看到文章被推荐到首页时，那种感觉真是上瘾，随着这种感觉的愈发强烈，活动参加的越来越多，羊毛薅的越来越爽，不知不觉中又完成了掘金升4的小目标\\n\\n感谢掘金的不断鞭策，让我朝着一个一个小目标前进，不知不觉习惯已经养成\\n\\n![愿好人一生平安感谢有你.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c7d2dc0bebc94f78b8b203f6b472b878~tplv-k3u1fbpfcp-watermark.image?)\\n\\n# 展望2023\\n## 列一个目标（心愿）清单\\n\\n1. 房东的房子卖不掉（刚住了三个月，房东为了孩子上学要把这个房子卖掉，已经挂牌了），新的一年不用搬家\\n2. 要么加薪，要么跳槽加薪，再成长都不抵涨薪管用呐😂😂😂\\n3. 拓展技术类型，学习是一生的事业\\n4. 我希望自己写出来的每一篇文章都是有意义的，新的一年继续提高文章质量，丰富文章内容\\n5. 疫情退散，基金大涨\\n6. 有钱有闲，找个时间咱也去远方逛逛\\n\\n![愿望成真.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c4cf77b4a1b49ab87b6e198babac875~tplv-k3u1fbpfcp-watermark.image?)\\n",
        "tags": [
            "前端",
            "年终总结",
            "掘金社区"
        ]
    },
    {
        "article_id": "7188802380392038458",
        "cover_image": "https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/67e1447d4cad43a6a040e62367ca7048~tplv-k3u1fbpfcp-watermark.image?",
        "title": "使用canvas+ts实现坦克大战小游戏",
        "brief": "使用canvas+ts实现坦克大战小游戏，附源码，代码注释全，有兴趣的小伙伴来看一下吧，欢迎前来批评指正！",
        "user_name": "来世做春风",
        "view_count": 776,
        "collect_count": 13,
        "comment_count": 0,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/046aec00261b64251b52e574fcaad23d~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: smartblue\\n---\\n# 前言\\n    \\n技术栈 canvas + ts + webpack\\n\\n预览地址：https://1933669775.github.io/tanKeDaZhan/dist/index.html\\n\\n源码：https://github.com/1933669775/tanKeDaZhan\\n\\n欢迎批评指正\\n   \\n## 项目架构\\n\\n### webpack配置\\n\\n简单配置一下\\n\\n具体有：scss、ts、压缩js、压缩html、webpack-cli一些基础的东西\\n   \\n   \\n```js\\nconst path = require('path')\\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\\nconst TerserPlugin = require(\\\"terser-webpack-plugin\\\")\\n\\nmodule.exports = {\\n  entry: './src/ts/index.ts',\\n  output: {\\n    filename: '[name].[contenthash].js',\\n    path: path.resolve(__dirname, 'dist'),\\n    clean: true,\\n  },\\n  resolve: {\\n    extensions: ['.tsx', '.ts', '.js'],\\n  },\\n  module: {\\n    rules: [\\n      {\\n        test: /.s[ac]ss$/i,\\n        use: [\\n          'style-loader',\\n          'css-loader',\\n          'sass-loader',\\n        ],\\n      },\\n      {\\n        test: /.tsx?$/,\\n        use: 'ts-loader',\\n        exclude: /node_modules/,\\n      },\\n      { test: /.txt$/, use: 'raw-loader' }\\n    ]\\n  },\\n  plugins: [\\n    new HtmlWebpackPlugin({\\n      template: 'index.html',\\n      minify:{\\n        collapseWhitespace: true,\\n      }\\n    }),\\n  ],\\n  optimization: {\\n    runtimeChunk: 'single',\\n    mangleWasmImports: true,\\n    minimize: true,\\n    minimizer: [new TerserPlugin()],\\n    splitChunks: {\\n      cacheGroups: {\\n        vendor: {\\n          test: /[\\\\/]node_modules[\\\\/]/,\\n          name: 'vendors',\\n          chunks: 'all',\\n        },\\n      },\\n    },\\n  },\\n  devServer: {\\n    static: './dist',\\n  },\\n}\\n```\\n\\n### 代码结构\\n\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea5382f187014859b0da513ac09fbc2b~tplv-k3u1fbpfcp-watermark.image?)\\n\\nBattleCity -- 公共父类，存放多个类通用的属性或方法\\n\\nBullet -- 子弹类，存放子弹生成及移动，绘制子弹等逻辑\\n\\nconfig -- 存放固定配置\\n\\nCreateMap -- 地图类，存放绘制地图逻辑\\n\\nEnemy --敌人类，存放创建敌人，敌人移动等逻辑\\n\\nTank --坦克类，存放坦克的移动逻辑，碰撞逻辑，绘制逻辑\\n\\n## 父类\\n\\n\\n```js\\nimport Tank from \\\"./Tank\\\";\\nimport config from './config'\\n// @ts-ignore\\nimport Modal from \\\"custom-dialog\\\"\\n\\ntype hitObj = {\\n  x: number,\\n  y: number,\\n  w: number,\\n  h: number\\n}\\n\\n// 坦克大战、类，所有类的父亲\\nconst canvas = document.querySelector('canvas') as HTMLCanvasElement\\nconst ctx = canvas.getContext('2d') as CanvasRenderingContext2D\\n\\nexport default class BattleCity {\\n  // canvas 元素\\n  canvas: HTMLCanvasElement\\n  // canvas绘画的上下文对象\\n  ctx: CanvasRenderingContext2D\\n  // canvas的宽度\\n  cw: number\\n  // cnavas的高度\\n  ch: number\\n  // 配置信息\\n  config: any\\n  // 弹框\\n  dialog = Modal\\n\\n  // 地图对象\\n  static barrierObj_: Array<{\\n    x: number,\\n    y: number,\\n    w: number,\\n    h: number,\\n    type: string\\n  }> = []\\n  // 敌人对象\\n  static enemyAll_: Array<{\\n    // 子弹的定时器ID\\n    bulletId?: NodeJS.Timer,\\n    // 转向的定时器ID\\n    turnToId?: NodeJS.Timer,\\n    tankObj: Tank\\n  }> = []\\n  // 子弹对象\\n  static bulletAll_: Array<{\\n    x: number,\\n    y: number,\\n    dir: string,\\n    seed: number,\\n    color: string\\n  }> = []\\n  // 关卡参数\\n  static levelParams_: {\\n    enemySeed: number,\\n    enemyAmount: number,\\n    enemyCeiling: number,\\n    enemyLife: number,\\n    myTankLife: number,\\n    enemyCreateSeed: number,\\n  }\\n  // 关卡关数\\n  static level_: number = 0\\n  // 消灭敌人\\n  static enemyVanishNum_: number = 0\\n  // 游戏是否结束\\n  static isFinish_: Boolean\\n\\n  constructor() {\\n    this.canvas = canvas\\n    this.cw = this.canvas.width\\n    this.ch = this.canvas.height\\n    this.ctx = ctx\\n    this.config = config\\n    this.dialog = new Modal()\\n  }\\n\\n  // 绘制边框矩形\\n  borderRect(x: number, y: number, w: number, h: number) {\\n    const { ctx } = this\\n    ctx.beginPath()\\n    ctx.fillRect(x, y, w, h)\\n    ctx.strokeRect(x, y, w, h)\\n    ctx.closePath()\\n  }\\n\\n  // 根据图形中心旋转\\n  // x、y、宽、高、角度\\n  rotate(x: number, y: number, w: number, h: number, r: number) {\\n    let xx = x + (w / 2)\\n    let yy = y + (h / 2)\\n\\n    const { ctx } = this\\n    ctx.translate(xx, yy);\\n    ctx.rotate((r * Math.PI) / 180);\\n    ctx.translate(- xx, - yy)\\n  }\\n\\n  // 碰撞检测\\n  hitDetection(hitObj1: hitObj, hitObj2: hitObj) {\\n    return hitObj1.x + hitObj1.w >= hitObj2.x &&\\n        hitObj1.x <= hitObj2.x + hitObj2.w &&\\n        hitObj1.y + hitObj1.h >= hitObj2.y &&\\n        hitObj1.y <= hitObj2.y + hitObj2.h;\\n  }\\n\\n  // 更新游戏状态的页面元素\\n  updateStatus() {\\n    (<Element>document.querySelector('#myLife')).innerHTML = String(this.myTanke.tankObj.lifeVal);\\n    (<Element>document.querySelector('#enemyNum')).innerHTML = String(this.levelParams.enemyAmount - this.enemyVanishNum)\\n  }\\n\\n  // 地图对象\\n  get barrierObj() {\\n    return BattleCity.barrierObj_\\n  }\\n  set barrierObj(val) {\\n    BattleCity.barrierObj_ = val\\n  }\\n  // 敌人对象\\n  get enemyAll() {\\n    return BattleCity.enemyAll_\\n  }\\n  set enemyAll(val) {\\n    BattleCity.enemyAll_ = val\\n  }\\n  // 子弹对象\\n  get bulletAll() {\\n    return BattleCity.bulletAll_\\n  }\\n  set bulletAll(val) {\\n    BattleCity.bulletAll_ = val\\n  }\\n  // 关卡参数\\n  get levelParams() {\\n    return BattleCity.levelParams_\\n  }\\n  set levelParams(val) {\\n    BattleCity.levelParams_ = val\\n  }\\n  // 消灭敌人数量\\n  get enemyVanishNum() {\\n    return BattleCity.enemyVanishNum_\\n  }\\n  set enemyVanishNum(val) {\\n    BattleCity.enemyVanishNum_ = val\\n  }\\n  // 关卡关数\\n  get level(){\\n    return BattleCity.level_\\n  }\\n  set level(val) {\\n    BattleCity.level_ = val\\n  }\\n  // 游戏是否结束\\n  get isFinish(){\\n    return BattleCity.isFinish_\\n  }\\n  set isFinish(val) {\\n    BattleCity.isFinish_ = val\\n  }\\n\\n  // 主角坦克\\n  get myTanke() {\\n    return BattleCity.enemyAll_.find(v => v.tankObj.color === this.config.myTankColor) as { tankObj: Tank, lifeVal: number }\\n  }\\n}\\n\\n```\\n\\n存放通用的属性或者方法\\n\\n## 子弹类\\n\\n\\n### 子弹绘制\\n\\n\\n```js\\n// 子弹对象类型\\n bulletAll: Array<{\\n    x: number,\\n    y: number,\\n    dir: string,\\n    seed: number,\\n    color: string\\n  }>\\n// 绘制子弹\\n// 绘制一个简单的小圆球\\nredrawBullet() {\\n    const { ctx } = this\\n    this.bulletAll?.forEach(v => {\\n      ctx.beginPath()\\n      ctx.save()\\n      ctx.fillStyle = v.color\\n      ctx.arc(v.x, v.y, 3, 0, Math.PI * 2)\\n      ctx.fill()\\n      ctx.restore()\\n      ctx.closePath()\\n    })\\n}\\n```\\n\\n这里bulletAll是一个对象，里面存放是所有子弹，创建子弹时候会往bulletAll里面添加对象，这里就会绘制。\\n\\n### 子弹移动\\n\\n\\n```js\\n// 子弹移动\\n// 这种写法是为了防止this问题，了解过react的小伙伴应该不陌生\\n  move = () => {\\n    const { canvas } = this\\n    // 子弹超出边界就会删除\\n    this.bulletAll = this.bulletAll?.filter(v => {\\n      return !(v.x < 0 || v.x > canvas.width || v.y < 0 || v.y > canvas.height)\\n    })\\n\\n    // 根据方向改变子弹位置\\n    this.bulletAll = this.bulletAll?.map(v => {\\n      switch (v.dir) {\\n        case '上' : v.y -= v.seed; break;\\n        case '下' : v.y += v.seed; break;\\n        case '左' : v.x -= v.seed; break;\\n        case '右' : v.x += v.seed; break;\\n      }\\n      return v\\n    }) || []\\n\\n    this.isBulletHit()\\n    this.redrawBullet()\\n  }\\n```\\n\\n这里根据bulletAll里面的dir方向字段来判断x、y的加减操作\\n\\n### 子弹碰撞检测\\n\\n\\n\\n```js\\n// 判断子弹碰撞\\n  isBulletHit() {\\n    const mc = this.config.myTankColor\\n    // 第一层遍历 遍历子弹\\n    this.bulletAll = this.bulletAll.filter((v1) => {\\n      const bulletHitObj = {\\n        x: v1.x,\\n        y: v1.y,\\n        w: 5,\\n        h: 5,\\n      }\\n      // 是否删除子弹\\n      let isRemoveBullet = false\\n      // 是否删除敌人\\n      let isRemoveEnemy = false\\n      // 是否删除我的坦克\\n      let isRemoveMyTanke = false\\n\\n      // 遍历墙\\n      this.barrierObj = this.barrierObj.filter(v2 => {\\n        // 子弹是否撞到墙\\n        let isHit = this.hitDetection(bulletHitObj, v2)\\n        // 撞上了就会删除这个子弹\\n        if (isHit) isRemoveBullet = true\\n\\n        // 如果撞上了会返回一个false，本次循环会被过滤掉\\n        // 如果是障碍物不会删除\\n        return v2.type === 'z' ? true : !isHit\\n      })\\n\\n      // 家没了\\n      if (this.barrierObj.filter(v2 => v2.type === 'j').length <= 0 && !this.isFinish) {\\n        this.isFinish = true\\n        // 删除主角坦克\\n        this.enemyAll = this.enemyAll.filter(v => v.tankObj.color !== mc)\\n        this.dialog.alert({\\n          content: '家没了，大侠请重新来过',\\n          buttons: {\\n            ok(){\\n              return true;\\n            },\\n          }\\n        })\\n        return\\n      }\\n\\n      // 主角子弹判断\\n      if (v1.color === mc) {\\n        // 遍历敌人\\n        this.enemyAll = this.enemyAll.filter((v2, i2) => {\\n          if (v2.tankObj.color === mc) return true\\n          // 子弹对敌人的碰撞检测\\n          let isHit = this.hitDetection(bulletHitObj, {\\n            x: v2.tankObj.tankX,\\n            y: v2.tankObj.tankY,\\n            w: v2.tankObj.tankW,\\n            h: v2.tankObj.tankH,\\n          })\\n          // 撞上了\\n          if (isHit) {\\n            isRemoveBullet = true\\n            // 坦克不在无敌状态才可以扣除生命值\\n            if (!v2.tankObj.isInvincible) {\\n              this.enemyAll[i2].tankObj.lifeVal -= 1\\n            }\\n            // 击中扣除生命值\\n            // 判断生命值是否小于0\\n            if (this.enemyAll[i2].tankObj.lifeVal <= 0) {\\n              // 如果小于0删除敌人 将敌人的计时器清除\\n              isRemoveEnemy = true\\n              clearTimeout(v2.bulletId)\\n              clearTimeout(v2.turnToId)\\n              // 消灭敌人数 +1\\n              this.enemyVanishNum ++\\n              if (this.enemyVanishNum >= this.levelParams.enemyAmount) {\\n                this.dialog.alert( {\\n                  content:\\n                    this.level === 0 ? '胜利了，你可以开始下一关' :\\n                    this.level === 1 ? '你居然过了第二关，有点实力' :\\n                    this.level === 2 ? '牛啊，给你个大拇指' : '',\\n                  buttons: {\\n                    ok(){\\n                      return true;\\n                    },\\n                  }\\n                })\\n              }\\n              this.updateStatus()\\n            }\\n          } else {\\n            // 没撞上\\n            isRemoveEnemy = false\\n          }\\n          return !isRemoveEnemy\\n        })\\n      }\\n      else\\n      // 敌人子弹判断\\n      if (v1.color !== mc) {\\n        this.enemyAll = this.enemyAll.filter((v2, i2) => {\\n          // 不是主角坦克的会被过滤\\n          if (v2.tankObj.color !== mc) return v2\\n          // 敌人子弹对主角的碰撞检测\\n          let isHit = this.hitDetection(bulletHitObj, {\\n            x: v2.tankObj.tankX,\\n            y: v2.tankObj.tankY,\\n            w: v2.tankObj.tankW,\\n            h: v2.tankObj.tankH,\\n          })\\n          // 撞到了\\n          if (isHit) {\\n            // 坦克不在无敌状态才可以扣除生命值\\n            if (!v2.tankObj.isInvincible) {\\n              // 击中扣除生命值\\n              this.enemyAll[i2].tankObj.lifeVal -= 1\\n              // 主角扣除生命值会有1秒的无敌时间\\n              v2.tankObj.invincible(500)\\n            }\\n            isRemoveBullet = true\\n            this.updateStatus()\\n            // 游戏失败\\n            if (this.enemyAll[i2].tankObj.lifeVal <= 0) {\\n              this.isFinish = true\\n              isRemoveMyTanke = true\\n              this.dialog.alert( {\\n                content: '失败，坦克没了，大侠请重新来过',\\n                buttons: {\\n                  ok(){\\n                    return true;\\n                  },\\n                }\\n              })\\n            }\\n          }\\n          return !isRemoveMyTanke\\n        })\\n      }\\n\\n      // 如果要删除子弹就在这个位置加上一个子弹碰撞特效\\n      if (isRemoveBullet) this.effectsAll.push({\\n        x: v1.x,\\n        y: v1.y,\\n        radius: 0,\\n        color: v1.color\\n      })\\n      // 将这个子弹过滤\\n      return !isRemoveBullet\\n    })\\n  }\\n```\\n\\n**子弹共同点**\\n\\n判断地形，如果撞到非障碍物地形该地形都会消失，撞到障碍物子弹会消失。\\n\\n敌人子弹或者主角子弹撞到对方判断是否是无敌状态，如果是不会扣血\\n\\n并且子弹消失之前会出现子弹爆炸特效\\n\\n**敌人子弹：**\\n\\n判断是否碰撞到主角，如果碰撞会扣除血量，血量为零时游戏失败\\n\\n敌人子弹撞到主角会触发一个短暂的无敌时间\\n\\n**主角子弹：**\\n\\n判断是否碰撞到敌人，如果碰撞会扣除血量，血量为零时该敌人销毁\\n\\n### 子弹爆炸特效\\n\\n\\n\\n```js\\n// 子弹碰撞效果绘制\\n  drawHitEffects() {\\n    // 半径递增\\n    this.effectsAll = this.effectsAll.map(v => {\\n      v.radius ++\\n      this.drawFires(v.x, v.y, 12, v.radius, v.color)\\n      return v\\n    })\\n\\n    // 过滤半径超过某个值的\\n    this.effectsAll = this.effectsAll.filter(v => v.radius <= 13)\\n  }\\n\\n  // 绘制烟花效果\\n  drawFires(x: number, y: number, count: number, radius: number, color: string) {\\n    const { ctx } = this\\n\\n    for (let i1 = 0; i1 <= 2; i1 ++) {\\n      for (let i2 = 0; i2 < count; i2++) {\\n        // 渲染出当前数据\\n        let angle = 360 / (count / i1) * i2;\\n        let radians = angle * Math.PI / 180;\\n        let moveX = x + Math.cos(radians) * radius / i1\\n        let moveY = y + Math.sin(radians) * radius / i1\\n        // 开始路径\\n        ctx.beginPath();\\n        ctx.arc(moveX, moveY, 1.3, Math.PI * 2, 0, false);\\n        // 结束\\n        ctx.closePath();\\n        ctx.fillStyle = color\\n        ctx.fill();\\n      }\\n    }\\n  }\\n```\\n\\n一个简单的烟花效果，当半径递增到一定程度会消失\\n\\n## 地图类\\n\\n### 地图结构\\n\\n\\n```js\\nconst mapObj = [\\n// @enemySeed 敌人速度\\n// @enemyCeiling 敌人上限(地图最多可以出现多少敌人)\\n// @enemyAmount 敌人数量\\n// @enemyLife 敌人生命\\n// @myTankLife 主角生命\\n// @enemyCreateSeed 敌人创建速度(毫秒)\\n    // 第一关\\n    {\\n        enemySeed: 2,\\n        enemyAmount: 10,\\n        enemyCeiling: 5,\\n        enemyLife: 2,\\n        myTankLife: 4,\\n        enemyCreateSeed: 1500,\\n        map: [\\n          // q = 墙 j = 家 z = 障碍\\n          '                                ',\\n          '                                ',\\n          '                                ',\\n          '                                ',\\n          '                                ',\\n          '                                ',\\n          '          q         q           ',\\n          '         q q       q q          ',\\n          '        q   q     q   q         ',\\n          '       q     q   q     q        ',\\n          'q     q       q q       q      q',\\n          'qq     q       q       q      qq',\\n          'qqq     q             q      qqq',\\n          'qqqq     q           q      qqqq',\\n          'qqqqq     q         q      qqqqq',\\n          '           q       q            ',\\n          '            q     q             ',\\n          '             q   q              ',\\n          '              q q               ',\\n          '               q                ',\\n          '    zzzzz              zzzzz    ',\\n          '    zzzzz              zzzzz    ',\\n          '                                ',\\n          '            qqqqqqq             ',\\n          '            qqjjjqq             ',\\n          '            qqjjjqq             ',\\n        ]\\n    }\\n]\\n\\n```\\n\\n这是一个关卡结构，每一关都有不用的地图，和敌人强度，主角血量的不同\\n\\n### 切分地图\\n\\n\\n```js\\n// 创建地图\\ncreate() {\\n    // 需要减去像素比\\n    this.barrierObj = []\\n    this.currentLevel = this.level\\n    this.levelParams = mapObj[this.level]\\n    // 当前地图\\n    const cm = mapObj[this.level].map\\n    // 绘画格子宽度\\n    const dw = this.cw / cm[0].length\\n    // 绘画格子高度\\n    const dh = this.ch / cm.length\\n    // 循环当前地图\\n    cm.forEach((v1, i1) => {\\n      // 遍历字符串\\n      for (let i2 = 0; i2 < v1.length; i2 ++) {\\n        const x = (dw * i2) / devicePixelRatio, y = (dh * i1) / devicePixelRatio\\n        if (v1[i2] !== ' ') {\\n          this.barrierObj.push({\\n            x,\\n            y,\\n            w: (dw / devicePixelRatio),\\n            h: (dh / devicePixelRatio),\\n            type: v1[i2]\\n          })\\n        }\\n      }\\n    })\\n    this.drawMap()\\n  }\\n```\\n\\n根据关卡来选择是那个数组，取里面的地图\\n\\n再根据canvas的宽度和高度来切分\\n\\n然后遍历这个二维数组，根据里面的值来判断地形，存到一个对象里面。这个对象存放绘制地图的信息。\\n\\n### 绘制地图\\n\\n\\n```js\\n// 绘制地图\\n// 这个方法会被一直调用\\n  drawMap = () => {\\n    this.barrierObj.forEach(v => {\\n      v.type === 'q' ? this.drawWall(v.x, v.y, v.w, v.h, this.config.wallColor) : false\\n      v.type === 'j' ? this.drawFamily(v.x, v.y, v.w, v.h) : false\\n      v.type === 'z' ? this.drawBarrier(v.x, v.y, v.w, v.h) : false\\n    })\\n  }\\n\\n  // 绘制墙壁\\n  // 该方法会根据canvas的宽高进行计算、并且平铺\\n  drawWall(x: number, y: number, w: number, h: number, color: string) {\\n    const { ctx } = this\\n\\n    ctx.fillStyle = color\\n    // 墙的主体绘制\\n    ctx.beginPath()\\n    ctx.fillRect(x, y, w, h)\\n    ctx.closePath()\\n\\n    // 墙里面的线绘制\\n    const num = h / 2\\n    ctx.strokeStyle = this.config.wallLineColor\\n    ctx.lineWidth = 2\\n    for (let i = 1; i <= 2; i ++) {\\n      if (i % 2 === 1) {\\n        // 这里 加1、减1是为了让线贴合到墙里面，不让它超出\\n        ctx.beginPath()\\n        ctx.strokeRect(x, y + (num * i) - num, (w - w / 2), num)\\n        ctx.moveTo((x) + (w - w / 2), y + num * i)\\n        ctx.lineTo(x + w, y + num * i)\\n        ctx.moveTo((x) + (w - w / 2), y + (num * i) - num)\\n        ctx.lineTo(x + w, y + (num * i) - num)\\n        ctx.stroke()\\n        ctx.closePath()\\n      } else {\\n        ctx.beginPath()\\n        ctx.moveTo(x + w / 4, y + (num * i))\\n        ctx.lineTo(x + w / 4, y + (num * i) - num)\\n        ctx.moveTo(x + (w / 2) + (w / 4), y + (num * i))\\n        ctx.lineTo(x + (w / 2) + (w / 4), y + (num * i) - num)\\n        ctx.stroke()\\n        ctx.closePath()\\n      }\\n    }\\n  }\\n\\n  // 绘制家\\n  drawFamily(x: number, y: number, w: number, h: number) {\\n    const { ctx } = this\\n    ctx.beginPath()\\n    ctx.strokeStyle = 'red'\\n    ctx.font=`${w / 1.5}px Arial`;\\n    ctx.fillText('家',x,y + h)\\n    ctx.closePath()\\n  }\\n\\n  // 绘制 障碍\\n  drawBarrier(x: number, y: number, w: number, h: number) {\\n    const { ctx } = this\\n    ctx.beginPath()\\n    ctx.save()\\n    ctx.fillStyle = '#fff'\\n    ctx.fillRect(x, y, w, h)\\n    ctx.restore()\\n    ctx.closePath()\\n  }\\n```\\n\\n根据不同的地形来绘制\\n\\n## 坦克类\\n\\n### 坦克绘制\\n\\n\\n```js\\n// 绘制坦克\\n  drawTank() {\\n    const x = this.tankX, y = this.tankY\\n    const { ctx, tankW, tankH } = this\\n\\n    // 绘制左右坦轮\\n    ctx.beginPath()\\n    ctx.save()\\n\\n    ctx.fillStyle = this.color\\n    // 根据方向旋转角度\\n    this.rotate(x, y, tankW, tankH, this.dir === '上' ? 0 : this.dir === '下' ? 180 : this.dir === '左' ? 270 : 90)\\n    ctx.fillRect(x, y, tankW / 4, tankH)\\n    ctx.fillRect(x + (tankW - tankW / 4), y, tankW / 4, tankH)\\n\\n    ctx.strokeStyle = 'rgba(153,153,153,0.6)'\\n\\n    // 一层遍历，将左右两边分开\\n    for (let i = 1; i <= 2; i ++) {\\n      ctx.lineWidth = 1\\n      // 绘制坦轮里面的横线\\n      for (let k = 1; k <= 5; k ++) {\\n        const currentY = y + (tankH / 5) * k\\n        switch (i) {\\n          // 左\\n          case 1: {\\n            ctx.moveTo(x, currentY)\\n            ctx.lineTo(x + tankW / 4, currentY)\\n          }\\n            break;\\n          default: {\\n            // 右\\n            ctx.moveTo(x + tankW - tankW / 4, currentY)\\n            ctx.lineTo(x + (tankW - tankW / 4) + tankW / 4, currentY)\\n          }\\n            break;\\n        }\\n      }\\n      ctx.stroke()\\n    }\\n\\n    // 绘制坦身\\n    this.borderRect(x + (tankW / 2) - ((tankW / 2.6) / 2), y + ((tankH - (tankH / 1.4)) / 2), tankW / 2.6, tankH / 1.4)\\n    ctx.lineWidth = 1\\n    // 绘制炮管\\n    this.borderRect(x + ((tankW / 2) - ((tankW / 6) / 2)), y - 5, tankW / 6, tankH / 1.3)\\n\\n    // 绘制无敌样式\\n    if (this.isInvincible) {\\n      ctx.beginPath()\\n      ctx.strokeStyle = 'rgba(255,130,0)'\\n      ctx.arc(x + (tankW / 2), y + (tankH / 2), tankW - 2, Math.PI * 2, 0)\\n      ctx.stroke()\\n      ctx.closePath()\\n    }\\n    ctx.restore()\\n    ctx.closePath()\\n\\n    // 绘制裂痕\\n    if (\\n        // 低过半血就会出现裂痕\\n        // 判断是主角坦克还是敌人坦克，两种坦克血量不同\\n        this.lifeVal <= (this.color === this.config.myTankColor ?  this.levelParams.myTankLife / 2 : this.levelParams.enemyLife / 2)\\n    ) {\\n      ctx.beginPath()\\n      ctx.save()\\n      ctx.strokeStyle = '#000'\\n      ctx.lineWidth = 3\\n      ctx.moveTo(x + tankH / 4, y)\\n      ctx.lineTo(x + 5, y + tankH / 2)\\n      ctx.lineTo(x + tankH / 3, y + tankH / 2)\\n      ctx.lineTo(x + tankH / 4, y + tankH)\\n      ctx.moveTo(x + tankH - 5, y)\\n      ctx.lineTo(x + tankH - 5, y + tankH / 2)\\n      ctx.lineTo(x + tankH, y + tankH / 2)\\n      ctx.lineTo(x + tankH - 10, y + tankH)\\n      ctx.stroke()\\n      ctx.restore()\\n      ctx.closePath()\\n    }\\n  }\\n```\\n\\n自己瞎画的，考虑到无敌状态的绘制、还有坦克血量过半的效果绘制\\n\\n\\n\\n### 坦克移动\\n\\n\\n```js\\n// 坦克移动\\n// 返回promise  reslove = 碰撞\\n  move = () => {\\n    return new Promise((reslove) => {\\n      let { canvas, tankW, tankH, hitDetection, tankX, tankY } = this\\n      const cw = canvas.width\\n      const ch = canvas.height\\n      const mapBottom = (ch - (tankH * devicePixelRatio)) / devicePixelRatio\\n\\n      // 移动\\n      if (tankX > 0) this.dir === '左' ? tankX -= this.seed : false\\n      if (tankX + tankW < cw) this.dir === '右' ? tankX += this.seed : false\\n      if (tankY > 0) this.dir === '上' ? tankY -= this.seed : false\\n      if (tankY < mapBottom) this.dir === '下' ? tankY += this.seed : false\\n\\n      // 遍历所以墙的位置 然后于坦克的位置进行碰撞检测\\n      const moveResult1 = this.barrierObj.find(v => {\\n        return hitDetection({\\n          x: tankX,\\n          y: tankY,\\n          w: tankW,\\n          h: tankH\\n        }, v)\\n      })\\n\\n      // 撞到边界\\n      if ((tankX <= 0 || tankX + tankW >= cw || tankY <= 0 || tankY >= mapBottom) && (this.color !== this.config.myTankColor)) reslove(null)\\n      // 撞到墙了\\n      if (moveResult1) return reslove(null)\\n\\n      // 没有障碍物\\n      this.tankX = tankX\\n      this.tankY = tankY\\n    })\\n  }\\n```\\n\\n碰撞检测这里需要注意的是，一定要先减x、y的值，再检测，没有碰撞再赋值，不然会进入一个逻辑闭环\\n\\n值得一起的是一个撞到边界，或者碰到障碍物，会返回一个回调的逻辑。这个是为了防止敌人坦克一直碰到边界不走的问题\\n\\n### 无敌效果\\n\\n\\n```js\\n// 开启无敌\\n// @time 无敌的时间（毫秒）\\ninvincible(time: number) {\\nthis.isInvincible = true\\nsetTimeout(() => {\\n  this.isInvincible = false\\n}, time)\\n}\\n```\\n\\n很简单的一个定时改状态逻辑\\n\\n## 敌人类\\n\\n### 创建敌人\\n\\n\\n```js\\n // 创建敌人\\n  create() {\\n    // 防止多次开计时器\\n    if (this.createEnemyId !== null) clearInterval(this.createEnemyId)\\n    // 上来就创建一个敌人\\n    this.createHandle()\\n    // 创建\\n    this.createEnemyId = setInterval(() => {\\n      // 限制地图上最大显示的敌人坦克数量\\n      // 并且限制 关卡敌人数量 - 消灭敌人数量\\n      if (\\n        this.enemyAll.length <= this.levelParams.enemyCeiling &&\\n        (this.levelParams.enemyAmount - this.enemyVanishNum) > this.enemyAll.length - 1\\n      ) this.createHandle()\\n    }, this.levelParams.enemyCreateSeed)\\n    this.move()\\n  }\\n```\\n\\n1. 开一个定时器，来批量创建敌人\\n2. 根据关卡的参数限制敌人数量\\n\\n\\n### 敌人行为\\n\\n### 敌人转向和创建敌人的具体操作\\n\\n\\n```js\\n// 转向\\n  // @tankObj 要转向的坦克对象\\n  // @not 随机值不会随机到这个位置\\n  turnTo(tankObj: Tank, not?: string) {\\n    const arr = ['下', '上', '左', '右'].filter(v => not !== v)\\n    this.enemyAll = this.enemyAll.map((v) => {\\n      // 判断哪一个坦克需要转向\\n      if (tankObj === v.tankObj) {\\n        // 取随机值\\n        v.tankObj.dir = arr[Math.floor(Math.random() * arr.length)] as '上' | '下' | '左' | '右'\\n        return v\\n      }\\n      return  v\\n    })\\n  }\\n\\n  // 创造敌人的操作\\n  createHandle() {\\n    // 时间间隔\\n    const arrLaunch = [1.2, 1.5, 1.8, 2, 2.2, 2.5]\\n    // 随机获取发射间隔的值\\n    const launchVal = arrLaunch[Math.floor(Math.random() * arrLaunch.length)] as 2 | 2.5 | 3 | 3.5 | 4\\n    // new 坦克对象\\n    const tankObj = new Tank(this.levelParams.enemySeed, 'e80000',this.levelParams.enemyLife, 100, 0, )\\n    // 发射子弹的定时器\\n    const bulletId = setInterval(() => {\\n      this.enemyBullet(tankObj)\\n    }, (launchVal * 1000) / 1.5)\\n    // 转向的定时器\\n    const turnToId = setInterval(() => {\\n      this.turnTo(tankObj)\\n    }, launchVal * 1000)\\n    // 创造敌人\\n    this.enemyAll.push({\\n      bulletId,\\n      turnToId,\\n      tankObj\\n    })\\n    this.draw()\\n  }\\n\\n  // 绘制敌人\\n  draw = () => {\\n    this.enemyAll.forEach(v => {\\n      v.tankObj.drawTank()\\n    })\\n  }\\n\\n```\\n\\n绘制敌人直接调用Tank类里面的绘制方法\\n\\n\\n这里敌人行为是创建的时候开了两个计时器，一个控制发射子弹，一个控制转向。\\n\\n转向时间是几个固定的时间间隔里面取随机值，发射子弹时间取的是转向时间的一半\\n\\n这样的效果就是每个坦克行为都是独立的\\n\\n#### 敌人移动\\n\\n\\n```js\\n// 敌人移动\\n  move = () => {\\n    this.enemyAll = this.enemyAll.map((v) => {\\n      // 这个判断成立代表这次遍历的坦克是主角，不需要移动\\n      if (v.tankObj.color === 'yellow') return v\\n      // 如果非主角需要移动\\n      v.tankObj.move().then(() => {\\n        this.turnTo(v.tankObj, v.tankObj.dir)\\n      })\\n      return v\\n    })\\n  }\\n```\\n\\n这里直接调用Tank类里面的移动方法，参数是方向\\n\\n碰撞到障碍物会返回一个promise，操作是直接转向，这样的效果就是坦克一直在移动，不会停止\\n\\n\\n#### 敌人发射子弹\\n\\n\\n```js\\n// 敌人发射子弹\\n  enemyBullet = (tankObj: Tank) => {\\n    const { tankW, tankH, tankX, tankY, dir } = tankObj\\n    this.bulletAll.push({\\n      dir,\\n      x: tankX + tankW / 2,\\n      y: tankY + tankH / 2,\\n      seed: 4,\\n      color: 'red'\\n    })\\n  }\\n```\\n\\n很简单的添加逻辑\\n\\n## 控制器\\n\\n控制器是将多个类链接起的桥梁\\n\\n还存放主角坦克和移动操作\\n\\n### 主角坦克移动\\n\\n\\n```js\\n// 键盘控制操作\\n  controllerHandle() {\\n    window.onkeydown = (e) => {\\n      switch (e.key) {\\n        case 'ArrowUp': {\\n          this.dir = '上'\\n          this.move()\\n        }\\n          break;\\n        case 'ArrowDown': {\\n          this.dir = '下'\\n          this.move()\\n        }\\n          break;\\n        case 'ArrowLeft': {\\n          this.dir = '左'\\n          this.move()\\n        }\\n          break;\\n        case 'ArrowRight': {\\n          this.dir = '右'\\n          this.move()\\n        }\\n          break;\\n        case ' ': {\\n          this.launchBullet()\\n        }\\n      }\\n    }\\n\\n    // 键盘抬起\\n    window.onkeyup = (e) => {\\n      // 只有在移动状态下、并且抬起的上下左右四个按钮，才会执行该方法\\n      if (this.isMove && (e.key === 'ArrowDown' || e.key === 'ArrowRight' || e.key === 'ArrowLeft' || e.key === 'ArrowUp')) {\\n        this.isMove = false\\n      }\\n    }\\n  }\\n\\n  // 控制移动\\n  move = () => {\\n    // 防止多次执行\\n    if (!this.isMove) {\\n      this.isMove = true\\n      this.moveHandle()\\n    }\\n  }\\n  \\n  // 移动操作\\n  moveHandle = () => {\\n    // 只有当键盘为按下状态的时候才会执行该方法\\n    if (this.isMove) {\\n      // 更改主角坦克的方向状态\\n      this.Tank.enemyAll = this.Tank.enemyAll.map(v => {\\n        // 判断主角坦克\\n        if (v.tankObj === this.Tank) {\\n          v.tankObj.dir = this.dir\\n          return v\\n        }\\n        return v\\n      })\\n      this.Tank.move()\\n      window.requestAnimationFrame(this.moveHandle)\\n    }\\n  }\\n```\\n\\n先绑定键盘按下事件，判断上下左右\\n\\n键盘按下会改变一个状态，递归调用一个方法，来进行移动操作\\n\\n如果抬起会被监听到，改变这个状态，不会再进行移动\\n\\n这里我是把主角坦克放到敌人坦克的数组里面去了，这样可以集体减。这么整叫enemyAll其实有不太合适了，但是用的地方有点多，懒得改了。\\n\\n### 主角子弹发射\\n\\n\\n```js\\n//  发射子弹\\n  launchBullet() {\\n    // 如果游戏状态结束不郧西发射子弹\\n    if (this.Tank.isFinish) return\\n    // 防抖\\n    if (this.bulletTimeID !== null) clearTimeout(this.bulletTimeID)\\n    this.bulletTimeID = setTimeout(() => {\\n      const { tankW, tankH, tankX, tankY, config } = this.Tank\\n      this.Bullet.bulletAll.push({\\n        dir: this.dir,\\n        x: tankX + tankW / 2,\\n        y: tankY + tankH / 2,\\n        seed: config.myBulletSeed,\\n        color: config.myTankColor\\n      })\\n    }, 100)\\n  }\\n```\\n\\n还是简单的添加数据\\n\\n这里做了一个防抖操作，是为了防止长按键盘执行，这样就不是子弹，是激光了\\n\\n### 画\\n\\n\\n```js\\n // 重绘\\n  redraw = () => {\\n    const { ctx, canvas  } = this.Tank\\n    // 清除\\n    ctx.clearRect(0, 0, canvas.width, canvas.height)\\n\\n    // 调用绘制方法\\n    this.CreateMap.drawMap()\\n    this.Enemy.move()\\n    this.Bullet.move()\\n    this.Enemy.draw()\\n    this.Bullet.drawHitEffects()\\n\\n    window.requestAnimationFrame(this.redraw)\\n  }\\n```\\n\\n很关键的步骤，这个每一刻都在调用，来一帧一帧绘制图像\\n\\n\\n## canvas模糊问题解决\\n\\n之前一直用台式机做的，分辨率很高，两千多大概吧。后来放到我笔记本上做我发现变的很模糊。\\n\\n具体原因可以看这篇文章：https://juejin.cn/post/7067415002289799205\\n\\n就说一下我的解决方案吧\\n\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6417d51bc33d4ecc96f733cf54b919ab~tplv-k3u1fbpfcp-watermark.image?)\\n\\n安装了一个包\\n\\n但是还不够，绘制的时候还需要计算屏幕的`devicePixelRatio`\\n\\n\\n```js\\ncreate() {\\n    this.barrierObj = []\\n    this.currentLevel = this.level\\n    this.levelParams = mapObj[this.level]\\n    // 当前地图\\n    const cm = mapObj[this.level].map\\n    // 绘画格子宽度\\n    const dw = this.cw / cm[0].length\\n    // 绘画格子高度\\n    const dh = this.ch / cm.length\\n    // 循环当前地图\\n    cm.forEach((v1, i1) => {\\n      // 遍历字符串\\n      for (let i2 = 0; i2 < v1.length; i2 ++) {\\n        // 计算像素比---------------\\n        const x = (dw * i2) / devicePixelRatio, y = (dh * i1) / devicePixelRatio\\n        if (v1[i2] !== ' ') {\\n          this.barrierObj.push({\\n            x,\\n            y,\\n            // 计算像素比------------\\n            w: (dw / devicePixelRatio),\\n            h: (dh / devicePixelRatio),\\n            type: v1[i2]\\n          })\\n        }\\n      }\\n    })\\n    this.drawMap()\\n  }\\n```\\n\\n大致就这样，有兴趣的兄弟可以可以去看源码深入研究\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n    \\n   \\n   \\n",
        "tags": [
            "前端",
            "TypeScript",
            "Canvas"
        ]
    },
    {
        "article_id": "7191642637797949495",
        "cover_image": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c8e4fc43cb0478792c39fd692ef46a1~tplv-k3u1fbpfcp-watermark.image?",
        "title": "视野修炼-技术周刊第21期",
        "brief": "1. 2022 State of JS 结果出炉 2. CodePen 2022 Top100 3. 中国亲戚关系计算器。。。更多内容详见文章",
        "user_name": "粥里有勺糖",
        "view_count": 2864,
        "collect_count": 7,
        "comment_count": 4,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/5877bbfbefbd0c812f684b56f769b478~300x300.image",
        "category": "阅读",
        "content": "---\\ntheme: smartblue\\n---\\n\\n欢迎来到第 21 期的【视野修炼 - 技术周刊】，下面是本期的精选内容简介。\\n\\n🔥强烈推荐\\n1. 2022 State of JS 结果出炉\\n2. CodePen: 2022 Top100\\n3. 中国亲戚关系计算器\\n\\n🔧开源&工具\\n\\n4. Iconbolt\\n5. 音乐聊天室\\n\\n📚文章&资讯\\n\\n6. ESLint 2022 年终总结\\n7. 2023 年大淘宝 Web 端技术概览\\n8. 交互式的 3D CSS 教程\\n\\n**​推荐大家关注一下最后的推荐内容（周刊的主要内容来源渠道）**\\n\\n下面开始本期内容的介绍，预计阅读时间 9 分钟\\n\\n## 🔥强烈推荐\\n### [1. 2022 State of JS 结果出炉](https://2022.stateofjs.com/zh-Hans/)\\n**此小节内容较丰富**\\n\\n先来看一些JS特性的使用统计数据\\n\\n![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13e314a23eb64bb59c74f9c1cc19aca6~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n下面介绍一些感觉比较有用的JS特性（根据笔者喜好程度）\\n\\n#### `Array.prototype.at`\\n可以通过index进行前后查找取值，这个绝对好用\\n```js\\nconst arr = [1,2,3,4]\\narr.at(0) // 1\\narr.at(-1) // 4\\n```\\n#### `Array.prototype.findLast`\\n与`find`查找顺序相反，从后往前查符合条件的1项\\n```js\\n;[1, 2, 3, 4].findLast((v) => v % 2) // 3\\n```\\n\\n#### `空值合并`\\n这个开发中挺常用 `??`，左值为`null`或`undefined`时返回右值 `x ?? y`\\n\\n下面举个例子 **设置默认值的场景**\\n\\n有个这样的对象，期望获取的时候对 `null`, `undefined` 场景附默认值\\n```js\\nconst obj = { n: 0,m: null }\\n\\n```\\n\\n使用对象解构，`null` 不会正常工作\\n```js\\nconst { n = 1, m = 2, l = 3 } = obj\\n// 结果如下\\n// 0, null, 3\\n```\\n\\n使用 `||` 运算符的场景，无法准确处理 `0`,`false`,`''`等场景\\n\\n```js\\nlet { n, m, l } = obj\\nn = n || 1\\nm = m || 2\\nl = l || 3\\n// 1, 2, 3\\n```\\n现在换成`??`看一下\\n```js\\nlet { n, m, l } = obj\\nn = n ?? 1\\nm = m ?? 2\\nl = l ?? 3\\n// 0, 2, 3\\n```\\n\\n#### `数字分隔符`\\n主要用于表示大数时，阅读更加方便\\n\\n比如下面这个，一眼看不出多少个 0\\n```js\\nconst num1 = 1000000000000\\n```\\n咱们用上这个特性表示一下，一下就“数”出来了\\n```js\\nconst num2 = 1_0000_0000_0000\\n\\nconsole.log(num1 === num2) // true\\n```\\n\\n#### `Promise.allSettled`\\n\\n区别于 `Promise.all` ，其传入的 `promise` 无论结果（`reject/resolve`）如何，`Promise.allSettled` 都会是 resolve 的，其返回的数据结构如下\\n```ts\\ninterface ReturnValue{\\n  status: 'fulfilled' | 'rejected'\\n\\n  // 当 status 为 fulfilled 时 返回的数据\\n  value?: any\\n  // 当 status 为 rejected 时 返回的数据\\n  reason?: any\\n}\\n```\\n下面是个例子\\n```ts\\nconst p1 = Promise.resolve(1)\\nconst p2 = Promise.reject(new Error('2'))\\n\\nPromise.allSettled([p1, p2]).then((res) => {\\n  res.forEach((v) =>\\n    console.log(\\n      'allSettled',\\n      v.status,\\n      v.status === 'fulfilled' ? v.value : v.reason?.message\\n    )\\n  )\\n})\\n// allSettled fulfilled 1\\n// allSettled rejected 2\\n```\\n\\n\\n#### `Promise.any`\\n和 `promise.all` 作用相反，传入的 promise 只要有一个状态变为 `fulfilled` 即可，只有所有的都`rejected` 失败，才需要 catch\\n\\n下面是`fulfilled`例子\\n```js\\nconst p1 = new Promise((resolve) =>\\n  setTimeout(() => {\\n    console.log('setTimeout', 'p1')\\n    resolve('p1')\\n  }, 200)\\n)\\n\\nconst p2 = new Promise((resolve) =>\\n  setTimeout(() => {\\n    console.log('setTimeout', 'p2')\\n    resolve('p2')\\n  }, 100)\\n)\\n\\nPromise.any([p1, p2]).then((v) => console.log('any', v))\\n// setTimeout p2\\n// any p2\\n// setTimeout p1\\n```\\n`rejected`例子\\n```js\\nPromise.any([\\n  Promise.reject(new Error('err1')),\\n  Promise.reject(new Error('err2'))\\n]).catch((e) => {\\n  console.log(e.message)\\n  console.log(e.errors.map((v) => v.message))\\n})\\n// All promises were rejected\\n// [ 'err1', 'err2' ]\\n```\\n可以用于并发多个异步，取任意一个成功响应的场景\\n\\n#### `类的私有字段`\\n在 js 里 通常通过 `_fieldName` 表明私有字段（约定），但实际上也能被访问到\\n\\n现在可以使用 `#fieldName` 表明私有字段，类似 TS 中 `private fieldName`，外部无法访问\\n\\n下面是个例子\\n```js\\nclass OldPeople {\\n  _name = 'xm'\\n}\\n\\nclass NewPeople {\\n  #name = 'sl'\\n}\\nconst p1 = new OldPeople()\\nconsole.log(p1['_name']) // 'xm'\\n\\nconst p2 = new NewPeople()\\n\\nconsole.log(p1['#name']) // undefined\\n```\\n\\n#### `X Assignment`\\n这个咱们常见的就是 `+=`,`-=`\\n\\n这些主要是用于缩写`x = x ○ y`等价于`x ○= y`\\n\\n现在是支持`&&`,`??`,`||`等\\n\\n比如简写前面的赋默认值\\n```js\\nlet { a } = obj\\na ??= 1\\n```\\n\\n再来看一下 `库/框架`\\n\\n![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ddb11439ffd847f0b19330aa276cd4cf~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n* 前端框架：Svelte > React > Vue > Preact > Angular\\n* 构建工具：Vite > esbuild > Rollup > Parcel > webpack\\n\\n工具类库\\n\\n![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5144defaef994781ba06867aa087540f~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n今年的亮点\\n\\n![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ce87c678b394d0eaf19293d3f8af654~tplv-k3u1fbpfcp-zoom-1.image)\\n\\nVite 占据了3个板块\\n\\n### [2. CodePen: 2022 Top100](https://codepen.io/2022/popular/pens)\\n很多炫酷和令人眼前一样的东西，推荐大家刷一下，下面贴几个\\n\\n\\n\\n![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5889d6817f5647b18583da69dcbd6292~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n### [3. 中国亲戚关系计算器](https://passer-by.com/relationship/)\\n\\n![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/19045b8932254f889eb0fe1a5ced397a~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n功能很强大，除了常规的`关系找称呼`，还支持其它3种，其中 `称呼找关系` 是笔者觉得最赞的\\n\\n## 🔧开源&工具\\n### [4. Iconbolt](https://www.iconbolt.com/)\\n\\n一个 SVG 图标仓库，收集了7万多个图标，都可以免费使用。\\n\\n![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc327df4679d40f49649419e1a4727ae~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n### [5. 音乐聊天室](https://chat.jiangly.com/#/)\\n一个开源的多人实时通讯多房间在线音乐聊天室，可以私有化部署，给自己的博客添加一个实时聊天互(mo)动(yu)的功能\\n\\n![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/192b440100cd4a388289269732725cd6~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n\\n## 📚文章&资讯\\n### [6. ESLint 2022 年终总结](https://eslint.org/blog/2023/01/eslint-2022-year-review/)\\nemm。。。 作者回顾了2022做的一些事，展望了一下未来（[重写Eslint](https://github.com/eslint/eslint/discussions/16557)）\\n\\n\\n### [7. 2023 年大淘宝 Web 端技术概览](https://mp.weixin.qq.com/s/9JCqhRh2cIkyXEAOLI6N5Q)\\n淘宝 Web 技术地图和技术产品的介绍（部分产品包含单独的介绍文章）\\n\\n![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/15364923f90c4e529d78f1f4f8fccebf~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n对相关技术感兴趣的可单独深入（增长技术视野广度的好机会）\\n\\n### [8. 交互式的 3D CSS 教程](https://garden.bradwoods.io/notes/css/3d)\\n\\n![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6353b9ff0414083ba0132e6447f1dd0~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n通过交互式的学习，很容易理解上手`perspective`、`perspectiveOrigin`、`translateZ`、`rotate3d`这4个属性\\n\\n## 😛趣图\\n\\n![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b3d04c970a24cc287eab81b690e7f0c~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n\\n篇幅有限，如果你还没看够，可移步后面的推荐渠道，继续游览，历史周刊（<20）移步[博客](https://sugarat.top/weekly/index.html)\\n\\n## ⭐️强力推荐关注\\n* [阮一峰: 科技爱好者周刊](https://www.ruanyifeng.com/blog/archives.html) - 记录每周值得分享的科技内容，周五发布\\n* [云谦：MDH 前端周刊](https://www.yuque.com/chencheng/mdh-weekly) - 前端资讯和分享\\n* [童欧巴：前端食堂](https://github.com/Geekhyt/weekly) - 你的前端食堂，吃好每一顿饭\\n* [rottenpen：FE News](https://rottenpen.zhubai.love/) - 分享前端，生活\\n* [知识星球：咲奈的平行时空](https://public.zsxq.com/groups/28851452458181.html) - 前端前沿技术、资讯、方法论分享\\n\\n",
        "tags": [
            "前端",
            "JavaScript",
            "GitHub"
        ]
    },
    {
        "article_id": "7193259086522581047",
        "cover_image": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88b10cb98c564885b8f2f906b9553bb3~tplv-k3u1fbpfcp-watermark.image?",
        "title": "简述 styled-components 性能",
        "brief": "styled-components 是一个流行的 React 库，一个 CSS in JS 样式框架，它使用 JavaScript 中的标记模板字面量和 CSS 的强大功能来提供一个平台",
        "user_name": "天行无忌",
        "view_count": 2023,
        "collect_count": 11,
        "comment_count": 3,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/ee5b3d33c959244bf7b70b28bb3a4d07~300x300.image",
        "category": "前端",
        "content": "> 2023年春节假期最后一天，新的一年工作即将开始，保持一颗奋斗的心！\\n\\n`styled-components` 是一个流行的 React 库，一个 `CSS in JS` 样式框架，它使用 JavaScript 中的标记模板字面量和 CSS 的强大功能来提供一个平台，允许编写实际的 CSS 来设置 React 组件的样式，同时兼顾开发人员体验和性能。\\n\\n基本上是在编写 CSS，但使用的是 Javascript。实际上可以命名自己的标签，以便更容易识别它们。可以使用 Javascript 更改属性的值，这非常适合具有动态内容的应用程序。\\n\\n官方网站：[https://styled-components.com/](https://styled-components.com/)\\n\\n下面是一段使用的代码：\\n\\n```\\nconst Button = styled.a`\\n  /* This renders the buttons above... Edit me! */\\n  display: inline-block;\\n  border-radius: 3px;\\n  padding: 0.5rem 0;\\n  margin: 0.5rem 1rem;\\n  width: 11rem;\\n  background: transparent;\\n  color: white;\\n  border: 2px solid white;\\n\\n  /* The GitHub button is a primary button\\n   * edit this to target it specifically! */\\n  ${props => props.primary && css`\\n    background: white;\\n    color: black;\\n  `}\\n`\\n```\\n\\n`styled-components` 的痛点\\n\\n* 一个额外的包裹\\n* 更大的 JS 包\\n* 影响 CSS 性能（特定环境）\\n* CSS文件和JS文件的处理方式不一样\\n\\n现在使用谷歌浏览器开发工具 Lighthouse 来对比一下样式组件性能和模块化CSS的性能。测试的环境将模拟安卓环境、网络设置为慢速3G模式、CPU设置为 4 核。\\n\\n开始之前先简单介绍几个前端性能指标：\\n\\n* FCP：`First Contentful Paint` 首次内容绘制，指浏览器渲染出第一个内容的时间，内容可以是文本、img标签、SVG元素等，但是不包括 `iframe` 和白色背景的 `Canvas` 元素。\\n* SI：`Speed Index` 首屏展现平均值，这是 Lighthouse 的六项性能指标之一。\\n* LCP：`Largest Contentful Paint` 最大内容绘制，指可视区内容最大的可见元素出现在屏幕上的时间，衡量加载性能的核心指标。\\n* TTI：`Time to Interactive` 可交互时间，该指标用于测量页面从开始加载到主要子资源完成渲染，并能够快速、可靠地响应用户输入所需的时间。\\n\\n#### styled-components 性能\\n\\n* 平均性能范围：`8995` 毫秒\\n* FCP：`2.1`\\n* SI：`7.6`\\n* LCP：`12`\\n* TTI：`12.5`\\n\\n\\n#### 模块化 CSS 性能\\n\\n\\n* 平均性能范围：`13809` 毫秒\\n* FCP：`2.2`\\n* SI：`9.1`\\n* LCP：`13.1`\\n* TTI：`13.2`\\n\\n从上述两组数据看到，在平均性能范围内，`styled-components` 节省了 `4814` 毫秒！考虑到 CSS 规则根本没有改变这一事实，速度指数和其他指标的提升也相当大。上述性能数据是有一定的前提环境，但从官方的介绍来看，整体性能还是不错的。\\n\\n### 结论\\n\\n可以在 React 中使用这两种技术并创建令人惊叹的WEB应用，这只是为正确的工作选择正确的工具的问题。如果有一个高度可定制的仪表板将代码库更改为模块化 CSS 可能没有意义。然而，如果用户来自移动设备，建议尝试看看WEB应用使用模块化 CSS 的速度有多快。最终选用什么方式还有其他的决定因素，性能只是其中之一。",
        "tags": [
            "React.js",
            "CSS",
            "性能优化"
        ]
    },
    {
        "article_id": "7195105268681113655",
        "cover_image": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d20f96d28cf440239645340f6a48cac0~tplv-k3u1fbpfcp-watermark.image?",
        "title": "react特性篇 - 在你写memo()之前",
        "brief": "在你写memo()之前 有很多描写React性能优化的文章。一般而言，如果某些state更新缓慢的话，你需要： 验证是否正在运行一个生产环境的构建。（开发环境构建会刻意地缓慢一些，极端情况下可能会慢一",
        "user_name": "Lynn_to",
        "view_count": 1129,
        "collect_count": 1,
        "comment_count": 9,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/3d4f75acafabe250f5f828e27b4542c8~300x300.image",
        "category": "前端",
        "content": "**开启掘金成长之旅！这是我参与「掘金日新计划 · 2 月更文挑战」的第 1 天，[点击查看活动详情](https://juejin.cn/post/7194721470063312933 \\\"https://juejin.cn/post/7194721470063312933\\\")**\\n\\n# 在你写memo()之前\\n\\n有很多描写React性能优化的文章。一般而言，如果某些state更新缓慢的话，你需要：\\n\\n1.  验证是否正在运行一个生产环境的构建。（开发环境构建会刻意地缓慢一些，极端情况下可能会慢一个数量级）\\n1.  验证是否将树中的状态放在了一个比实际所需更高的位置上。（例如，将输入框的state放到了集中的store里可能不是一个好主意）\\n1.  运行React开发者工具来检测是什么导致了二次渲染，以及在高开销的子树上包裹`memo()`。（以及在需要的地方使用`useMemo()`）\\n\\n最后一步是很烦人的，特别是对于介于两者之间的组件，理想情况下，编译器可以为您完成这一步。未来也许会。 **在这篇文章里，我想分享两种不同的技巧。**  它们十分基础，这也正是为什么人们很少会意识到它们可以提升渲染性能。 **这些技巧和你已经知道的内容是互补的** 它们并不会替代`memo` 或者 `useMemo`，但是先试一试它们还是不错的\\n\\n## 一个（人工）减缓的组件\\n\\n这里是一个具有严重渲染性能问题的组件\\n\\n```javascript\\nimport { useState } from 'react';\\n\\nexport default function App() {\\n  let [color, setColor] = useState('red');\\n  return (\\n    <div>\\n      <input value={color} onChange={(e) => setColor(e.target.value)} />\\n      <p style={{ color }}>Hello, world!</p>\\n      <ExpensiveTree />\\n    </div>\\n  );\\n}\\n\\nfunction ExpensiveTree() {\\n  let now = performance.now();\\n  while (performance.now() - now < 100) {\\n    // Artificial delay -- do nothing for 100ms\\n  }\\n  return <p>I am a very slow component tree.</p>;\\n}\\n```\\n\\n\\n问题就是当`App`中的`color`变化时，我们会重新渲染一次被我们手动大幅延缓渲染的`<ExpensiveTree />`组件。 我可以直接在它[上面写个memo()]()然后收工大吉，但是现在已经有很多这方面的文章了，所以我不会再花时间讲解如何使用memo()来优化。我只想展示 两种不同的解决方案。\\n\\n## 解法 1： 向下移动State\\n\\n如果你仔细看一下渲染代码，你会注意到返回的树中只有一部分真正关心当前的`color`：\\n\\n```\\nexport default function App() {\\n  let [color, setColor] = useState('red');  return (\\n    <div>\\n      <input value={color} onChange={(e) => setColor(e.target.value)} />      <p style={{ color }}>Hello, world!</p>      <ExpensiveTree />\\n    </div>\\n  );\\n}\\n```\\n\\n所以让我们把这一部分提取到`Form`组件中然后将state移动到该组件里：\\n\\n```\\nexport default function App() {\\n  return (\\n    <>\\n      <Form />      <ExpensiveTree />\\n    </>\\n  );\\n}\\n\\nfunction Form() {\\n  let [color, setColor] = useState('red');  return (\\n    <>\\n      <input value={color} onChange={(e) => setColor(e.target.value)} />      <p style={{ color }}>Hello, world!</p>    </>\\n  );\\n}\\n```\\n\\n\\n现在如果`color`变化了，只有`Form`会重新渲染。问题解决了。\\n\\n## 解法 2：内容提升\\n\\n当一部分state在高开销树的上层代码中使用时上述解法就无法奏效了。举个例子，如果我们将`color`放到父元素`div`中。\\n\\n```\\nexport default function App() {\\n  let [color, setColor] = useState('red');  return (\\n    <div style={{ color }}>      <input value={color} onChange={(e) => setColor(e.target.value)} />\\n      <p>Hello, world!</p>\\n      <ExpensiveTree />\\n    </div>\\n  );\\n}\\n```\\n\\n\\n\\n现在看起来我们似乎没办法再将不使用`color`的部分提取到另一个组件中了，因为这部分代码会首先包含父组件的`div`，然后才包含 `<ExpensiveTree />`。这时候无法避免使用`memo`了，对吗？又或者，我们也有办法避免？\\n\\n…\\n\\n…\\n\\n…\\n\\n答案显而易见：\\n\\n```\\nexport default function App() {\\n  return (\\n    <ColorPicker>\\n      <p>Hello, world!</p>      <ExpensiveTree />    </ColorPicker>\\n  );\\n}\\n\\nfunction ColorPicker({ children }) {  let [color, setColor] = useState(\\\"red\\\");\\n  return (\\n    <div style={{ color }}>\\n      <input value={color} onChange={(e) => setColor(e.target.value)} />\\n      {children}    </div>\\n  );\\n}\\n```\\n\\n\\n\\n我们将`App`组件分割为两个子组件。依赖`color`的代码就和`color` state变量一起放入`ColorPicker`组件里。 不关心`color`的部分就依然放在`App`组件中，然后以JSX内容的形式传递给`ColorPicker`，也被称为`children`属性。 当`color`变化时，`ColorPicker`会重新渲染。但是它仍然保存着上一次从`App`中拿到的相同的`children`属性，所以React并不会访问那棵子树。 因此，`ExpensiveTree`不会重新渲染。\\n\\n## 寓意是什么？\\n\\n在你用`memo`或者`useMemo`做优化时，如果你可以从不变的部分里分割出变化的部分，那么这看起来可能是有意义的。 关于这些方式有趣的部分是**他们本身并不真的和性能有关**. 使用children属性来拆分组件通常会使应用程序的数据流更容易追踪，并且可以减少贯穿树的props数量。在这种情况下提高性能是锦上添花，而不是最终目标。 奇怪的是，这种模式在将来还会带来更多的性能好处。 举个例子，当[服务器组件]() 稳定且可被采用时，我们的`ColorPicker`组件就可以从服务器上获取到它的`children`。 整个`<ExpensiveTree />`组件或其部分都可以在服务器上运行，即使是顶级的React状态更新也会在客户机上“跳过”这些部分。 这是`memo`做不到的事情!但是，这两种方法是互补的。不要忽视state下移(和内容提升!) 然后，如果这还不够，那就使用Profiler然后用memo来写吧。\\n\\n## 我之前不是读过这个吗？\\n\\n\\n这并不是一个新想法。这只是一个React组合模型的自然结果。它太简单了以至于得不到赏识，然而它值得更多的爱。",
        "tags": [
            "掘金·日新计划",
            "React.js",
            "JavaScript"
        ]
    },
    {
        "article_id": "7182849459855261754",
        "cover_image": "",
        "title": "一个很少遇到的网络状态码 -- 499",
        "brief": "业务背景 前段时间运维拦截到了一些 499 网络状态码报警，我对该问题进行了简单排查，本文对该状态码做简单的一个介绍。 解决思路 查阅文档得知，499 是 nginx 引入的非标准状态代码，用于在 n",
        "user_name": "suedar",
        "view_count": 3174,
        "collect_count": 5,
        "comment_count": 1,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/36fa925bbad2163268d24cbacdc14a4c~300x300.image",
        "category": "前端",
        "content": "### 一、问题背景\\n前段时间运维拦截到了一些 499 网络状态码报警，我对该问题进行了简单排查，本文对该状态码做简单的一个介绍。\\n\\n### 二、问题探寻\\n### 2.1 问题探寻-过程\\n> [499 - CLIENT CLOSED REQUEST] A non-standard status code introduced by nginx for the case when a client closes the connection while nginx is processing the request.\\n\\n查阅[文档](https://httpstatus.in/499/)得知，499 是 nginx 引入的非标准状态代码，用于在 nginx 服务器在处理请求时客户端关闭连接的情况。作为 4xx 开头状态码，表明的是这个请求的过程中是客户端发生了错误。\\n\\n查阅代码得知，是在某个业务场景，用户点击的服务不同，需要调用接口查询价格，在查询价格的接口下存在这个错误报警。\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a9394e1b0a042a187c3df1f93d2ebe4~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n再切换服务的时候，在上一个请求接口没有返回前，发起新的接口请求并取消上一个请求，这个逻辑是符合预期的。（当然防抖要加上）\\n\\n尽管在客户端侧只能看到一个被 cancel 的请求，但是这个请求在 nginx 拦截到的状态码是 499。\\n\\n\\n既然是符合预期的场景，那么其实不该告警，于是联系运维去掉关于该状态码低频状态下的告警。\\n\\n\\n### 2.1 问题探寻-取消 ajax 请求\\n\\n顺便我们看看怎么[取消 ajax 请求](https://axios-http.com/docs/cancellation)\\n\\n```\\nconst controller = new AbortController();\\n\\naxios.get('/foo/bar', {\\n   signal: controller.signal\\n}).then(function(response) {\\n   //...\\n});\\n// cancel the request\\ncontroller.abort()\\n```\\n\\n自 v0.22 后 ajax 换成以上的方法，因此我也换成这种写法进行介绍。\\n\\n把以上方法进行一些封装。\\n\\n```\\n// cancel-request.js\\nimport qs from 'qs'\\nexport default class CancelRequest {\\n  constructor() {\\n    this.pendingRequest = new Map()\\n  }\\n  // 根据请求信息生成唯一标识 key\\n  geterateReqKey(config) {\\n    const { url, method, params, data } = config\\n    return [url, method, qs.stringify(params), qs.stringify(data)].join('&')\\n  }\\n  // 把当前请求信息添加到pendingRequest对象中\\n  addPendingRequest(config, CancelToken) {\\n  \\tif (!config.cancelDuplicated) return\\n    const requestKey = this.geterateReqKey(config)\\n    if (!config.signal) {\\n    \\tconst controller = new AbortController()\\n    \\t\\n    \\tif (!this.pendingRequest.has(requestKey)) {\\n    \\t\\t// 把请求取消方法作为 map 值存起来\\n    \\t\\tthis.pendingRequest.set(requestKey, controller)\\n    \\t}\\n    \\tconfig.signal = controller.signal\\n    }\\n  }\\n  // 检查是否存在重复请求，若存在则取消前一次请求\\n  removePendingRequest(config) {\\n  \\tif (!config.cancelDuplicated) return\\n    const requestKey = this.geterateReqKey(config)\\n    if (this.pendingRequest.has(requestKey)) {\\n      const controller = this.pendingRequest.get(requestKey)\\n      // 取消请求\\n      controller.abort()\\n      // 删除map中对应的属性\\n      this.removeRequestKey(config)\\n    }\\n  }\\n  // 从pendingRequest中删除对应的key\\n  removeRequestKey(config) {\\n    const requestKey = this.geterateReqKey(config)\\n    this.pendingRequest.delete(requestKey)\\n  }\\n}\\n```\\n\\n```\\n// request.js\\nimport axios from 'axios';\\nimport CancelRequest from './cancel-request.js'\\n// 实例化\\nlet cancelRequest = new CancelRequest()\\nconst instance = axios.create({\\n  // ...\\n});\\n\\n// 请求拦截器\\ninstance.interceptors.request.use(config => {\\n  // 在请求开始之前检查先前的请求，如果是重复请求，删除之前的\\n  cancelRequest.removePendingRequest(config);\\n  // 如果不存在就将当前请求添加到pendingRequest\\n  cancelRequest.addPendingRequest(config);\\n    return config;\\n}, err => {\\n    Promise.reject(err);\\n});\\n// 响应拦截器\\ninstance.interceptors.response.use(res => {\\n  // 移除成功请求记录\\n    cancelRequest.removeRequestKey(res.config)\\n    return res.data;\\n}, err => {\\n  // 失败时也需要移除\\n    cancelRequest.removeRequestKey(err.config || {} )\\n    Promise.reject(err);\\n});\\nexport default instance;\\n```\\n\\n我们将 cancelDuplicated 作为是否开启取消重复请求的开关，于是，在业务接口处，我们采用\\n\\n```\\nimport { request } from '@/utils/request'\\nexport const exampleRequest = (params) => {\\n  return request('apicode', params，{\\n  \\tcancelDuplicated: true\\n  })\\n}\\n```\\n\\n就可以开启该配置。",
        "tags": [
            "前端",
            "HTTP",
            "Nginx"
        ]
    },
    {
        "article_id": "7160852432916856840",
        "cover_image": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/47cdc66ca06641678a1984ecf07add52~tplv-k3u1fbpfcp-watermark.image?",
        "title": "Github上5.3k的游戏！异形工厂的制作思路",
        "brief": "很早之前，我就关注到了Github上一款叫做shapez的高星游戏,主要玩法就和他的名字一样，是个需要利用开采器，传送带等各种工具来完成每个关卡所需要收集的开采物的游戏。。",
        "user_name": "Gatsby",
        "view_count": 5535,
        "collect_count": 183,
        "comment_count": 23,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/ad5e8d60463e248a9e576250337fcf1a~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: smartblue\\n---\\n# 前言\\n**很早之前**，我就关注到了Github上一款叫做**shapez**的高星游戏,主要玩法就和他的名字一样，是个需要利用开采器，传送带等各种工具来完成每个关卡所需要收集的开采物的游戏（游戏链接：https://shapez.io/ , 原创作者：https://github.com/tobspr-games/shapez.io ）。边玩的时候一边感叹，怎么能用JS做出性能这么优秀的高难度逻辑的游戏。那时候的我对JS的运用只能说是停留在能操控DOM元素。做点简单逻辑游戏的份上。也幻想尝试着做这个游戏，但是直接就在创建地图的阶段就暴毙了。\\n\\n**往后的时间里**，我一直都在不断磨炼自己的JS运用技术，特意去参考学习了很多大佬解析的一些游戏源代码。相对的在这方面的提升也是肉眼可见的。\\n\\n到了今天的10月中旬慢慢终于闲下来的时候，我终于是想起了shapez这款游戏，决心一定要挑战一下哪怕只是抽象的能完成多少就完成多少。\\n\\n# 分析\\n## 原版游戏分析\\n先对原版游戏进行一下分析，他的地图是可以**不断动态创建**的，且进行缩小到最小地图之后大概显示**50万**个网格，但是经过研究了一段时间后发现，在不放置任何工具的时候他永远只会不断更新一块4块16*16大小的网格高亮区域。其余地方是**不会以高刷新率重新更新全部画布**的，但如果在其他区域放置一个工具的话，会在那个放置点的16 * 16的方向上形成一个新的高亮刷新区域。\\n\\n\\n<p align=center><img src=\\\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e0e468a335848d1ac17dc68ca86582a~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"高亮刷新.gif\\\" width=\\\"70%\\\" /></p>\\n\\n那么对于地图上那些蓝的绿的红的开采区是如何生成的我后面也慢慢想到一个叫做**柏林噪点**的东西，虽然不能百分百确定，但至少我觉得生成的东西就和这游戏地图上的板块是非常相似的\\n\\n<p align=center><img src=\\\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96211a87397c41c7bbc442376d2b117d~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\" width=\\\"70%\\\" /></p>\\n\\n<p align=center><img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f09a64c0ad5437f95d7d9329ad02d3f~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\" width=\\\"70%\\\" /></p>\\n\\n其余的工具放置之类的功能相对就比较简单这里就不做更多讲解了\\n\\n## 制作流程\\n这是我对自己要所要完成的功能做的一个最基本的规划，规划内容如下：\\n```mermaid\\ngraph TD\\ncanvas网格地图绘制 --> 地图缩放拖动动态创建显示 --> 地图板块填充噪点等 --> 地图工具放置 --> 地图开采运行/中心接收/进入下一关\\n```\\n\\n# 制作\\n那么分析完了就可以开始动手了，但是为了方便以后的制作，我对自己的代码规范，以及预留一些添加后面功能板块的位置也是很有必要的。\\n\\n## canvas网格地图绘制\\n先要想想这个网格怎么创建，根据刚刚的分析如果光是创建2级数组作为地图存储的话会导致后面要完成放置工具变成高亮刷新区域后期就很难添加了，所以我的想法是这样的。 地图X Y坐标分别代表分别是二维数组的maps[y][x],在数组值里保存一个Class类，里面再存一个二维数组：如下面的。（ps：应该是还有别的方法的但是我觉得最简单的就是这种）\\n\\n```js\\n[\\n    [\\n        {grids: [[]]},{},{},{}\\n    ],\\n    [{},{},{},{}],\\n    [{},{},{},{}],\\n]\\n```\\n然后就是封装类开始实现，先封装好canvas相关操作的类\\n```\\n// 绘制canvas地图\\nclass Map {\\n    constructor() {\\n        this.canvas = document.querySelector('canvas');\\n        this.ctx = this.canvas.getContext('2d');\\n        // 屏幕大小一致的canvas\\n        window.onresize = () => {\\n            this.canvas.width = document.documentElement.clientWidth;\\n            this.canvas.height = document.documentElement.clientHeight;\\n        }\\n        // 保存加载好的图片\\n        this.loadImg = {}\\n\\n        this.runTimer = null;\\n    }\\n\\n    // 绘画开始\\n    begin(){\\n        this.ctx.beginPath();\\n        this.ctx.save();\\n    }\\n\\n    // 绘画结束\\n    close(){\\n        this.ctx.closePath();\\n        this.ctx.restore();\\n    }\\n    \\n    // 重新绘制地图\\n    one(){\\n        this.ctx.clearRect(0,0, document.documentElement.clientWidth, document.documentElement.clientHeight)\\n\\n        app.maps.flat().map(item => item.update());\\n    }\\n   \\n    // 旋转\\n    rotate(x, y, rotate){\\n        this.ctx.translate(x + 3.25, y + 3.25);\\n        this.ctx.rotate(rotate * Math.PI / 180);\\n        this.ctx.translate(-x - 3.25, -y - 3.25);\\n    }\\n\\n    // 绘画图片\\n    drawImage(x, y, name, w = 20, h, cx, cy, cw, ch){\\n        if(this.loadImg[name]){\\n            if(cw && ch){\\n                console.log(cx, cy, cw, ch, x, y, w, h || w);\\n                this.ctx.drawImage(this.loadImg[name], cx, cy, cw, ch, x, y, w, h || w);\\n            }else{\\n                this.ctx.drawImage(this.loadImg[name], x, y, w, h || w);\\n            }\\n        }else{\\n            let img = new Image();\\n            img.src = `${name}`;\\n            img.onload = () => this.loadImg[name] = img;\\n        }\\n    }\\n}\\n```\\n再去封装一个存入地图数据的Grid类，因为是用**Vue**写的里面有带**app.???** 一般都是之前封装的函数\\n```\\n// 地图里的网格方块\\nclass Item {\\n    constructor(i, j) {\\n        this.i = i;\\n        this.j = j;\\n        this.x = i * app.game.w;\\n        this.y = j * app.game.h;\\n        this.img = '';\\n        this.w = (app.game.w / 16);\\n    }\\n}\\n\\nclass Grid extends Item{\\n    constructor(i, j, color, prop) {\\n        super(i, j)\\n        // 随机的开采区的颜色\\n        this.color = color;\\n        // 假如是灰色的添加图形\\n        this.prop = prop;\\n\\n        this.main = null;\\n\\n        // 根据show来判断是否随机在二维数组中生成存入一个噪点\\n        this.show = ~~(Math.random() * 3);\\n        this.first = false;\\n        // 存入一个16*16的二维数组\\n        this.grids = new Array(16).fill(0).map((item, j) => {\\n            return new Array(16).fill(0).map((item, i) => {\\n                return new Block(i, j, false, false)\\n            })\\n        })\\n        if(this.show > 0) return;\\n        this.getRandomHP(7, 7, 20)\\n    }\\n\\n    update(){\\n        if(this.show > 0) return;\\n        this.add();\\n\\n        app.map.begin();\\n        this.grids.map((item, j) => {\\n            item.map((item, i) => {\\n                if(app.line){\\n                    app.map.ctx.strokeStyle = '#E3E7EA';\\n                    app.map.ctx.lineWidth = '0.2'\\n                    app.map.ctx.strokeRect(this.x + (i * 6.5), this.y + (j * 6.5), Math.abs(app.game.w) / 16, Math.abs(app.game.h) / 16);\\n                }\\n            })\\n        })\\n        app.map.close();\\n    }\\n}\\n```\\n初步就绘制出以下的区块\\n\\n<p align=center><img src=\\\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/137877aca1f6465996b24c91edf185dc~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\"  width=\\\"70%\\\"/></p>\\n\\n## 地图缩放拖动\\n这个拖动功能基本就是计算个偏移量的事情，所以不用多做解释啦。但对于这个定点缩放确实让我想了好一阵子。首先我的想法是通过直接增加绘制方块时候canvas增减绘制 **x y** 的偏移位和 **w h** 的大小来完成缩放效果发现并不理想。于是我直接采用了 canvas的 **scale** 和 **translate** 方法来进行偏移和缩放。\\n<p align=center><img src=\\\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9768cac3df9d4942b37e7fe3ad07a918~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"原缩放.gif\\\"  width=\\\"70%\\\"/></p>\\n大概就是这样的方法\\n\\n```\\nlet ctx = document.getElementById('canvas').getContext('2d');\\nlet obj = {\\n    fontX: 0,\\n    fontY: 0,\\n    fontZoom: 1,\\n    curZoom: 1,\\n    translateX: 0,\\n    translateY: 0,\\n    draw() {\\n        ctx.fillRect(150, 150, 50, 50)\\n    },\\n    zoom(offsetX, offsetY, z) {\\n        ctx.save()\\n        ctx.clearRect(0, 0, 300, 300);\\n        this.curZoom = this.fontZoom + z\\n        this.translateX = offsetX - (offsetX - this.translateX) * this.curZoom / this.fontZoom\\n        this.translateY = offsetY - (offsetY - this.translateY) * this.curZoom / this.fontZoom\\n        ctx.translate(this.translateX, this.translateY);\\n        ctx.scale(this.curZoom, this.curZoom);\\n        this.draw()\\n        ctx.restore()\\n        this.fontY = offsetY\\n        this.fontX = offsetX\\n        this.fontZoom = this.curZoom\\n    }\\n}\\nobj.draw()\\ndocument.getElementById('canvas').addEventListener('mousewheel', (e) => {\\n    let z = e.deltaY > 0 ? -0.1 : 0.1\\n    obj.zoom(e.offsetX, e.offsetY, z)\\n})\\n```\\n\\n<p align=center><img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d7d81d6b11c48888f1eb340f7a4126a~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"缩放.gif\\\"  width=\\\"70%\\\"/></p>\\n\\n## 地图板块填充\\n\\n### 噪点生成\\n那种真的像**我的世界地图**一样的噪点生成代码理解和写起来实在是麻烦了，所以我只要自创一个符合我要求的也不知道算不算“噪点”的demo。原理很简单，这里我直接用**exl表**来做一个简单的模型：简单来说就是假如中心点的位置是7，他的四周都是7的以内的随机数。当然为了避免7直接随机到1的尴尬状况，所以我是采用 **7/2+(7*Math.random())** 就可以保证得到的数字至少是在一半以上，接下来通过图片就很好理解了\\n\\n\\n<img src=\\\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b03c1fb1f56140e4ba0f4cb4f37f625d~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\" width=\\\"70%\\\" />\\n\\n> （注意：这些代码只是方便看我单独做的demo，在实际游戏中运用请看在线代码）\\n```\\nclass Grid{\\n    constructor() {\\n        this.canvas = document.querySelector('canvas');\\n        this.ctx = this.canvas.getContext('2d');\\n        this.grids = new Array(15).fill(0).map((item, j) => {\\n            return new Array(15).fill(0).map((item, i) => {\\n                return {if: false, rp: false};\\n            })\\n        })\\n        this.getRandomHP(7, 7, 15)\\n    }\\n\\n    //寻找附近的方块\\n    getNearby(i, j, rp){\\n        return [\\n            [i - 1, j],\\n            [i + 1, j],\\n            [i, j - 1],\\n            [i, j + 1],\\n        ].map(item => {\\n            // console.log((this.grids[item[1]][item[0]].rp <= 1 && this.grids[item[1]][item[0]].rp !== false), this.grids[item[1]][item[0]].rp)\\n            if(!(this.grids[item[1]] && this.grids[item[1]][item[0]]) || rp <= 1 || this.grids[item[1]][item[0]].if === true) return false;\\n            this.grids[item[1]][item[0]].if = true;\\n            let rand = ~~(Math.random() * rp / 2) + ~~(rp / 2);\\n\\n            return {\\n                i: item[0],\\n                j: item[1],\\n                rp: rand\\n            }\\n        })\\n    }\\n\\n    // 随机生成一个噪点\\n    getRandomHP(i, j, rp){\\n        this.getNearby(i, j, rp).filter(item => {\\n            if(!item) return;\\n            this.getRandomHP(item.i, item.j, item.rp)\\n        })\\n    }\\n\\n    // 根据噪点填充方格\\n    createMap(){\\n        this.grids.map((item, j) => {\\n            item.map((items, i) => {\\n                this.stroke(i, j)\\n                if(items.if) this.draw(i, j)\\n            })\\n        })\\n    }\\n\\n    // 填充方格\\n    draw(i, j){\\n        this.ctx.beginPath();\\n        this.ctx.save()\\n        this.ctx.fillStyle = 'red';\\n        this.ctx.fillRect(i * 30, j * 30, 30, 30);\\n        this.ctx.closePath();\\n        this.ctx.restore()\\n    }\\n\\n    // 划线\\n    stroke(i, j){\\n        this.ctx.beginPath();\\n        this.ctx.save()\\n        this.ctx.strokeStyle = 'red';\\n        this.ctx.strokeRect(i * 30, j * 30, 30, 30);\\n        this.ctx.closePath();\\n        this.ctx.restore()\\n    }\\n}\\n\\nlet grid = new Grid();\\nlet btn = document.querySelector('button');\\nbtn.onclick = function (){\\n    grid.createMap();\\n}\\n```\\n实现出来的效果和原版对比\\n\\n<p align=center><img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/044a7eaca4d5484b884c1e9fbacb3c32~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\"  width=\\\"70%\\\"/></p>\\n\\n<p align=center><img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab7e5faacce94907baebe7c6e4fa9ed0~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\"  width=\\\"70%\\\"/></p>\\n\\n看看 看看，对比一下还是很像的嘛！\\n\\n<p align=center><img src=\\\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c02d3d5947734589b51321f0ebeb427d~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"_@8((VME1[B~HW8L]KC`3R4.png\\\" width=\\\"50%\\\" /></p>\\n\\n### 各种类型的开采区\\n开采区就比较简单啦，无非就是把噪点里填充的红色板块填充些别的什么。封装一个通用的开采区的Class类，然后再通过继承来分别创建不同类型的开采区。现在看起来可能有点多余了，但后面是有这几种开采区都需要添加不同的功能的。\\n```\\n// 所有图片网址保存成的对象\\nlet urlImg = {\\n    red: 'https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bcdf1d95fb2f4203899f56ac4e0d5177~tplv-k3u1fbpfcp-zoom-mark-crop-v2:240:240:0:0.awebp?',\\n    blue: 'https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a1a8496861a64eb8b72ca6e77a969edb~tplv-k3u1fbpfcp-zoom-mark-crop-v2:240:240:0:0.awebp?',\\n    green: 'https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e03f33112ab486b8fbca50797782a78~tplv-k3u1fbpfcp-zoom-mark-crop-v2:240:240:0:0.awebp?',\\n    circular: 'https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da017de4947847acb217eb51e3a778a5~tplv-k3u1fbpfcp-zoom-mark-crop-v2:240:240:0:0.awebp?',\\n    square: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ccdd6b9183b745f8914cea5797b677e2~tplv-k3u1fbpfcp-zoom-mark-crop-v2:240:240:0:0.awebp?',\\n    cut: 'https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f6336eefefa94937adfe7e0ade7d25b1~tplv-k3u1fbpfcp-watermark.image?',\\n    main: 'https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/971af565f1b54f9494614722e50fc6da~tplv-k3u1fbpfcp-zoom-mark-crop-v2:240:240:0:0.awebp?',\\n    weizi: 'https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e1b5fdb97a54668914529840c037a6e~tplv-k3u1fbpfcp-zoom-mark-crop-v2:240:240:0:0.awebp?',\\n    miner: 'https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df7bc18ef96c40af8e8ff74fbed9c5bb~tplv-k3u1fbpfcp-watermark.image?',\\n    remove: 'https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9934ebad4852405dab42d5e956c4d70f~tplv-k3u1fbpfcp-zoom-mark-crop-v2:460:460:0:0.awebp?',\\n    path_top_bottom: 'https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f5ba39cbf6a470b9091164eb1e469f0~tplv-k3u1fbpfcp-watermark.image?',\\n    path_bottom_top: 'https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89a739cc9118468cbb9d2a70a22bffc2~tplv-k3u1fbpfcp-watermark.image?',\\n    path_left_right: 'https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1cbdfa5844d4deb87ac23624e6898e2~tplv-k3u1fbpfcp-watermark.image?',\\n    path_right_left: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/83c6bac94f3b4837a4c5bbdc29fd8979~tplv-k3u1fbpfcp-watermark.image?',\\n\\n    path_left_bottom: 'https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5416f686ed1a4f80ac940e6ced5459f5~tplv-k3u1fbpfcp-watermark.image?',\\n    path_top_left: 'https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6274f62a2ffc458f9851e679b96a8134~tplv-k3u1fbpfcp-watermark.image?',\\n    path_right_top: 'https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/24490d7fc5de4c9ea0694bdea8e90f77~tplv-k3u1fbpfcp-watermark.image?',\\n    path_bottom_right: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/148fbcef46e341f19e444fbceabca65c~tplv-k3u1fbpfcp-watermark.image?',\\n\\n    path_right_bottom: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/84bbd233b4d6415f8da8781b91fee3b1~tplv-k3u1fbpfcp-watermark.image?',\\n    path_top_right: 'https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d5f15016ac940a28b599e38e43d3636~tplv-k3u1fbpfcp-watermark.image?',\\n    path_left_top: 'https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f22d1be13e6424d8274d304a6082ea7~tplv-k3u1fbpfcp-watermark.image?',\\n    path_bottom_left: 'https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4461257ffd7b4f9fb66f761ef16f0d56~tplv-k3u1fbpfcp-watermark.image?',\\n}\\n\\n// 每个方块里的矿物继承Class\\nclass Color extends Item{\\n    constructor(i, j, color, prop = null) {\\n        super(i, j);\\n        this.color = color;\\n        this.prop = prop;\\n    }\\n\\n    update(){\\n        if(app.line){\\n            app.map.ctx.globalAlpha = .5;\\n            app.map.drawImage(this.i + 1.5, this.j + 1.5, urlImg[this.prop || Object.keys(this.color)[0]], Math.abs(app.game.w) / 32);\\n        }\\n        app.map.ctx.fillStyle = Object.values(this.color)[0];\\n        app.map.ctx.fillRect(this.i, this.j, Math.abs(app.game.w) / 16, Math.abs(app.game.h) / 16)\\n    }\\n}\\n\\n// 绿色染料块\\nclass Green extends Color{\\n    constructor(i, j, color) {\\n        super(i, j, color);\\n    }\\n}\\n\\n// 蓝色染料块\\nclass Blue extends Color{\\n    constructor(i, j, color) {\\n        super(i, j, color);\\n    }\\n}\\n\\n// 红色染料块\\nclass Red extends Color{\\n    constructor(i, j, color) {\\n        super(i, j, color);\\n    }\\n}\\n\\n// 灰色染料块，同时里面的正方形或者圆形\\nclass Grey extends Color{\\n    constructor(i, j, color, prop) {\\n        super(i, j, color, prop);\\n    }\\n}\\n\\n// 地图中心点\\nclass Main extends Item{\\n    constructor(i, j, grids) {\\n        super(i, j);\\n        this.grids = grids\\n        this.img = 'main';\\n        this.w = 26;\\n        this.init();\\n    }\\n\\n    init(){\\n        this.type = app.levels[app.level].type;\\n        this.num = app.levels[app.level].num;\\n        this.getNum = 0;\\n    }\\n\\n    update(){\\n        if(app.line){\\n            app.map.drawImage(this.x + 39, this.y + 39, urlImg['main'], 26);\\n\\n            this.info(this.x, this.y)\\n        }else{\\n            new Array(4).fill(0).map((item, j) => {\\n                new Array(4).fill(0).map((item, i) => {\\n                    this.grids[6 + j][6 + i].tool = 'main';\\n                    app.map.ctx.fillStyle = 'red';\\n                    app.map.ctx.fillRect(this.x + ((i + 6) * 6.5), this.y + ((j + 6) * 6.5), Math.abs(app.game.w) / 16, Math.abs(app.game.h) / 16)\\n                })\\n            })\\n\\n            app.map.drawImage((this.x + 26), this.y, urlImg['weizi'], 52);\\n        }\\n    }\\n\\n    info(x, y){\\n        app.map.ctx.font = 'bold 1.5px Arial';\\n        app.map.ctx.textAlign = 'left';\\n        app.map.ctx.fillStyle = '#ffffff';\\n        app.map.ctx.fillText('关卡', x + (6 * 6.5) + 3.5, y + (7 * 6.5) - 2.5);\\n        app.map.ctx.fillText(app.level + 1, x + (6 * 6.5) + 4.5, y + (7 * 6.5) - 0.5);\\n\\n\\n        app.map.drawImage((x + (6 * 6.5) + 4.5), y + (7 * 6.5) + 1, urlImg[this.type], 7.5);\\n        // app.map.drawImage(\\n        //     x + (6 * 6.5) + 4.5,\\n        //     y + (7 * 6.5) + 1,\\n        //     urlImg[this.type],\\n        //     7.5,\\n        //     7.5,\\n        //     -30,\\n        //     0,\\n        //     60,\\n        //     60\\n        // )\\n\\n        app.map.ctx.font = 'bold 3px Arial';\\n        app.map.ctx.textAlign = 'left';\\n        app.map.ctx.fillStyle = '#555';\\n        app.map.ctx.fillText('关卡', x + (8 * 6.5) - 1.8, y + (7 * 6.5));\\n        app.map.ctx.fillText('解锁', x + (8 * 6.5) - 1.8, y + (9 * 6.5) - 2);\\n        app.map.ctx.fillStyle = '#FD0752';\\n        app.map.ctx.fillText(app.levels[app.level].info, x + (8 * 6.5) - 1.8, y + (9 * 6.5) + 1.5);\\n\\n\\n        app.map.ctx.font = 'bold 5px Arial';\\n        app.map.ctx.textAlign = 'left';\\n        app.map.ctx.fillStyle = '#555';\\n        app.map.ctx.fillText(this.getNum, x + (8 * 6.5) + 1.5, y + (8 * 6.5) - 2);\\n        app.map.ctx.font = 'bold 3px Arial';\\n        app.map.ctx.fillStyle = '#b1b1b1';\\n        app.map.ctx.fillText(\\\"/\\\" + this.num, x + (8 * 6.5) + 1.5, y + (8 * 6.5) + 1);\\n    }\\n}\\n\\n```\\nGrid类里新增一个 **add方法** 放入的生成的噪点里\\n```\\n// 添加噪点\\nadd(){\\n    if(this.show > 0 && !app.line) return;\\n    if(this.first) return;\\n    this.grids = this.grids.map((item, j) => {\\n        return item.map((item, i) => {\\n            if(item.if) {\\n                let color = new cont[Object.keys(this.color)[0]](this.x + (i * 6.5), this.y + (j * 6.5), this.color, this.prop)\\n                color.update();\\n                item.color = color;\\n                return item;\\n            }\\n            return item\\n        })\\n    })\\n    this.first = true;\\n}\\n\\n// canvas网格地图绘制里的 Grid 类里的 update\\nupdate(){\\n    if(this.show > 0 && !app.line) return;\\n    // 调用把不同类型的开采区添加进噪点\\n    this.add();\\n\\n    app.map.begin();\\n    this.grids.map((item, j) => {\\n        item.map((item, i) => {\\n            if(app.line){\\n                app.map.ctx.strokeStyle = '#E3E7EA';\\n                app.map.ctx.lineWidth = '0.2'\\n                app.map.ctx.strokeRect(this.x + (i * 6.5), this.y + (j * 6.5), Math.abs(app.game.w) / 16, Math.abs(app.game.h) / 16);\\n            }\\n            if(item.if) {\\n                item.color.update();\\n            }\\n        })\\n    })\\n    app.map.close();\\n}\\n\\nlet cont = {red: Red, green: Green, blue: Blue, grey: Grey};\\n```\\n别眨眼！看看完成出来的效果（图一原版，图二完成的效果），是不是有一种以假乱真甚至更好看的感觉！\\n\\n<p align=center><img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/41a4691aa11448d0a0dd8ec132559b5d~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\"  width=\\\"70%\\\"/></p>\\n\\n<p align=center><img src=\\\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d7742306b804724b5b2c62088f2e914~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\"  width=\\\"70%\\\"/></p>\\n\\n## 地图工具放置\\n因为只写了第一关的原因，目前我只搞的工具也就是第一关和第二关的首先创建一个tools的大数组，里面保存的每个对象都代表一个工具，我来讲讲对象里面的每个属性都代表什么：\\n\\n| 属性 | 代表的东西 |\\n| --- | --- |\\n| type | 工具类型 |\\n| img | 工具的图片 |\\n| level | 解锁这个工具的关卡 |\\n\\n```\\n// 所有工具\\nlet tools: [\\n    {type: 'path', img: 'https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89a739cc9118468cbb9d2a70a22bffc2~tplv-k3u1fbpfcp-watermark.image?', level: 0},\\n    {type: '', img: '', level: 9},\\n    {type: '', img: '', level: 9},\\n    {type: 'miner', img: 'https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df7bc18ef96c40af8e8ff74fbed9c5bb~tplv-k3u1fbpfcp-watermark.image?', level: 0},\\n    {type: 'cut', img: 'https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f6336eefefa94937adfe7e0ade7d25b1~tplv-k3u1fbpfcp-watermark.image?', level: 1},\\n    {type: '', img: '', level: 9},\\n    {type: '', img: '', level: 9},\\n    {type: '', img: '', level: 9},\\n    {type: '', img: '', level: 9},\\n    {type: 'remove', img: 'https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9934ebad4852405dab42d5e956c4d70f~tplv-k3u1fbpfcp-zoom-mark-crop-v2:460:460:0:0.awebp?', level: 1},\\n];\\n// 正在使用的工具保存\\nlet tool = [];\\n\\n// 方向数组\\nlet dirs = [\\n    'top',\\n    'right',\\n    'bottom',\\n    'left',\\n];\\n// 现在的方向\\nlet dir = 0;\\n```\\n然后就是和开采区的创建一样，一个主类，然后分出每个工具的继承类\\n```\\n// 工具通用继承Class\\nclass Tool{\\n    constructor(i, j) {\\n        this.i = i;\\n        this.j = j;\\n        this.w = app.game.w / 16;\\n        this.h = app.game.h / 16;\\n        this.x = this.i * this.w;\\n        this.y = this.j * this.h;\\n        this.img = '';\\n        this.pre = false;\\n        this.timer = false;\\n        this.goods = []\\n    }\\n\\n    update(fn){\\n        if(this.img === '') return;\\n\\n        app.map.begin();\\n        fn && fn();\\n        app.map.drawImage(this.x, this.y, urlImg[this.img], this.w);\\n        app.map.close();\\n    }\\n\\n    getNearby() {\\n        return [\\n            [this.i - 1, this.j, 'left'],\\n            [this.i + 1, this.j, 'right'],\\n            [this.i, this.j - 1, 'top'],\\n            [this.i, this.j + 1, 'bottom'],\\n        ].map(item => {\\n            return {\\n                grid: app.game.getGrid(...item),\\n                dir: item[2]\\n            }\\n        }).filter(item => item.grid.tool)\\n    }\\n\\n    getNearbyGrid(){\\n        return [\\n            [this.i - 1, this.j, 'left'],\\n            [this.i + 1, this.j, 'right'],\\n            [this.i, this.j - 1, 'top'],\\n            [this.i, this.j + 1, 'bottom'],\\n        ].map(item => {\\n            return {\\n                grid: app.game.getGrid(...item),\\n                dir: item[2]\\n            }\\n        }).filter(item => item.grid)\\n    }\\n}\\n\\n// 开采器工具\\nclass Miner extends Tool{\\n    constructor(i, j, dir) {\\n        super(i, j, dir);\\n        this.img = 'miner';\\n        this.dir = dir;\\n        this.pre = false;\\n    }\\n\\n    update(){\\n        super.update(() => {\\n            if(this.dir === 'right'){\\n                this.rotate = 90;\\n            }else if(this.dir === 'bottom'){\\n                this.rotate = 180;\\n            }else if(this.dir === 'left'){\\n                this.rotate = 270\\n            }else if(this.dir === 'top'){\\n                this.rotate = 0;\\n            }\\n            app.map.ctx.globalAlpha = this.pre ? .4 : 1;\\n            app.map.rotate(this.x, this.y, this.rotate);\\n        })\\n    }\\n}\\n\\n// 剪切工具\\nclass Cut extends Tool{\\n    constructor(i, j, dir) {\\n        super(i, j, dir);\\n        this.img = 'cut'\\n        this.dir = dir;\\n        this.pre = false;\\n    }\\n\\n    update(){\\n        if(this.dir === 'right'){\\n            this.rotate = 90;\\n        }else if(this.dir === 'bottom'){\\n            this.rotate = 180;\\n        }else if(this.dir === 'left'){\\n            this.rotate = 270\\n        }else if(this.dir === 'top'){\\n            this.rotate = 0;\\n        }\\n\\n        app.map.begin();\\n        app.map.ctx.globalAlpha = this.pre ? .4 : 1;\\n        app.map.rotate(this.x, this.y, this.rotate);\\n        console.log(this.w * this.wd, this.h * this.hd)\\n        app.map.drawImage(this.x, this.y, urlImg[this.img], this.w * 2, this.h);\\n        app.map.close();\\n    }\\n}\\n\\n// 画路工具\\nclass Path extends Tool{\\n    constructor(i, j, dir, nextDir) {\\n        super(i, j, dir);\\n        this.dir = dir;\\n        this.img = '';\\n        if (nextDir) {\\n            this.nextDir = nextDir;\\n            this.img = `path_${this.dir}_${this.nextDir}`;\\n            return;\\n        }\\n        this.nextDir = app.reversePos(this.dir)\\n\\n        this.img = `path_${this.dir}_${this.nextDir}`;\\n    }\\n\\n    update(){\\n        super.update(() => {\\n            app.map.ctx.globalAlpha = this.pre ? .4 : 1;\\n        })\\n    }\\n}\\n```\\n<p align=center><img src=\\\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa463c2c01f846b6b93fb33b8688f000~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"工具使用.gif\\\"  width=\\\"70%\\\"/></p>\\n\\n## 地图开采与运行\\n逻辑很浅显，就是开采器的放置位置是可开采的区域里，并且开采器的朝向旁边的路起始方向是一致的就能进行开采，那么这层逻辑有了，需要思考的就是怎么生成开采出的东西，还有中心收集点的正确收集判断了\\n\\n### 判断是否达到生成的条件\\n```\\nclass Tool{\\n    // 生成开采物判断\\n    isCorrect(){\\n        if(this instanceof Miner) {\\n            if(app.game.getGrid(this.i, this.j).color){\\n                let nearby = this.getNearbyGrid().filter(item => {\\n                    if(item.grid.tool && (app.reversePos(item.grid.tool.dir) === this.dir)){\\n                        return true;\\n                    }else{\\n                        return false;\\n                    }\\n                })\\n\\n                if(nearby.length < 1) return false;\\n                return true\\n            }\\n        }\\n    }\\n}\\n```\\n### 生成开采物\\n```\\n// 每个方块开采出来的东西\\nclass Goods{\\n    constructor(i ,j, type, dir) {\\n        this.i = i;\\n        this.j = j;\\n        this.x = this.i * 6.5;\\n        this.y = this.j * 6.5;\\n        this.type = type;\\n        this.dir = dir;\\n    }\\n\\n    // 判断下一步该往哪走\\n    update(){\\n        this.i = ((parseFloat(this.x.toFixed(1)) + 6.5) / 6.5);\\n        this.j = ((parseFloat(this.y).toFixed(1)) / 6.5);\\n        let grid = app.game.getGrid(this.i, this.j);\\n        if(((parseFloat(this.x.toFixed(1)) + 6.5) % 6.5 === 0) && ((parseFloat(this.y).toFixed(1)) % 6.5 === 0)){\\n\\n            if(grid.tool) this.dir = grid.tool.nextDir || grid.tool.dir;\\n            else this.dir = '';\\n\\n            let nearby = [];\\n            if(grid.tool !== 'main') nearby = grid.tool.getNearby().filter(item => {\\n                return item.dir === this.dir && item.grid.tool\\n            })\\n            this.getMain(grid)\\n            if(nearby.length < 1) this.dir = '';\\n        }\\n        app.map.drawImage(this.x + (8), this.y + (1.5), urlImg[this.type], 104 / 32);\\n        // app.map.drawImage(this.x + (8), this.y + (1.5), urlImg[this.type], 104 / 32, 104 / 32, this.x + (8), this.y + (1.5), 104 / 32, 104 / 32);\\n    }\\n\\n    // 是否传输进入中心点，并判断是否符合中心点需求\\n    getMain(grid){\\n        if(!grid.tool || grid.tool === 'main') return;\\n\\n        let nearby = grid.tool.getNearby().filter(item => {\\n            return grid.tool && (grid.tool.nextDir === item.dir) && item.grid.tool === 'main';\\n        })\\n\\n        if(nearby.length >= 1) {\\n            if(this.type === app.game.get(40, 39).main.type){\\n                setTimeout(() => {\\n                    app.game.get(40, 39).main.getNum += 1;\\n                    app.game.get(40, 39).main.info();\\n                    if(app.game.get(40, 39).main.getNum === app.game.get(40, 39).main.num){\\n                        app.level += 1\\n                        app.game.get(40, 39).main.init();\\n                        $('.rank').show();\\n                        app.game.get(40, 39).main.info();\\n                    }\\n                }, 1000)\\n            }\\n        }\\n    }\\n}\\n```\\n最终效果.\\n<p align=center><img src=\\\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea0401685e6d4f08aaa23d96d7952127~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"完成游戏.gif\\\"  width=\\\"70%\\\"/></p>\\n\\n# 在线代码链接\\n\\n[https://code.juejin.cn/pen/7157617542360465416](url) \\n\\n[异形工厂（更新中） - 码上掘金 (juejin.cn)](https://code.juejin.cn/pen/7157617542360465416)\\n\\n# 结束语\\n目前截止到我准备发布这篇文章的时候，这个游戏其实也才做到第二关。但接下来关卡的制作无疑是飞速的，因为剩下需要考虑的知识变成了每个关卡解锁的工具使用上的思路编写了，如果这个星期的时间充裕的话我会抓经更新完剩下的关卡~ 当然上面的代码解析也只是讲了一些比较模糊的概念，如果掘友们有需要我进行**详细解析的功能板块**可以在**评论区留言**我会抓经和下几关的内容同时更新出一篇相关文章的！！也希望掘友们能为我的**文章**和**在线代码** 动动手指 **点个赞**！爱你们~\\n\\n<p align=center><img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/883ced87fc0a47428099d17c7c5be66c~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"B8JEXOV)94WX`PQ(0YV6V1K.gif\\\"  width=\\\"70%\\\"/></p>\\n",
        "tags": [
            "前端",
            "JavaScript",
            "Vue.js"
        ]
    },
    {
        "article_id": "7193964951517954104",
        "cover_image": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a3e406ba82f14eb69cc58eaa7c9767ee~tplv-k3u1fbpfcp-watermark.image?",
        "title": "一起来聊聊 Go 的核心竞争力",
        "brief": "现在，越来越多的人了解 Go 语言，学习 Go 语言，越来越多的公司开始尝试采用 Go 语言。那么 Gopher的核心竞争力在哪里？与 Java 后端工程师究竟差别在哪？",
        "user_name": "FengY_HYY",
        "view_count": 2711,
        "collect_count": 22,
        "comment_count": 6,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/55bfd9e46fd3285098abb7efa4545685~300x300.image",
        "category": "代码人生",
        "content": "现在，越来越多的人了解 Go 语言，学习 Go 语言，越来越多的公司开始尝试采用 Go 语言。我也是一直在用 Go 作为服务端开发的主力语言，也了解过 Java 和 Spring 那一整套服务端开发体系，时常在想，Java 的这一套体系，在长时间的迭代下，技术沉淀和业务覆盖已经非常完善，为什么 Go 还能脱颖而出？让大家所熟知。我知道，这中间存在一些从众效应，尤其是大公司的带头使用带来的引领作用，这为 Go 的声名带来了正向反馈，使 Go 越来越被人们所了解。\\n\\n抛开这些不谈，Go 本身也是有一些独门绝技，否则，它活不过开头，也就没有后续的正向反馈作用了。我想，找出这些独门绝技绝不是无用的思维内耗，它可以让我们这些 Gopher 找到未来发展的方向，确定未来学习的思路。\\n\\n#### 当我们比较 Java 和 Go，我们在比较什么？\\n\\n2007 年 9 月，像往常一样，一位程序员正靠在椅子上喝着咖啡，他在等着自己提交的代码被编译结束。这是一个巨大的工程，整个编译过程大约要持续 45 分钟，而他现在能做的也只有等待。这时，桌面上弹出的待办事项引起了他的注意，这是一次即将开始的宣讲会，几位 C++ 的同事将宣讲有关即将发布的 C++11 的新特性，他自然不能错过，于是他离开工位，坐到了会议室。\\n\\n讲台上，负责宣讲的同事神采飞扬，滔滔不绝地介绍着整整 35 项新特性。据他们透露，这还只是其中一部分。他抿了一口咖啡，仔细地听着，右值引用，这是什么鬼？可变参数模版，听起来倒很 C++...... 突然他感觉有些厌烦，C++真的需要这么多新特性吗？他想，有人说语言升级的更大成就不是添加了多少东西，而是减少了什么东西，尽管这话有些片面，但不失为有一定的道理。\\n\\n他的思绪回到了几个月前，那时候他在宣讲一个由他创造的语言 Newsqueak，这个语言使用了 CSP 并发模型，这是一个很优雅的模型，他想把它加入到 C++ 中，可总是没办法协调的很完美，问题出在哪？似乎 C++ 太过复杂了，他也不敢说自己完全理解了 C++。\\n\\n讲台上的声音突然停止了，这打断了他的思绪。另一位同事上来介绍一个新特性：原子类型。这是语言层面支持的原子性，通过硬件来保证的原子性。听到这里，他突然握紧了自己的咖啡杯，是的，问题出在这里，将这样一组微观定义的细节放入一个已经不堪重负的类型系统中，是短视的。因为底层的硬件在未来十年可能会发生翻天覆地的变化，将语言与当下的硬件紧密结合是不明智的。\\n\\n他应该设计一门新语言，一门面向未来的语言，它简约、易懂、使用 CSP 模型。这个想法使他热血澎湃，他想着会议一结束就去和坐在他旁边的 *Robert Griesemer* 交流这个想法。当主持人宣布会议结束时，他迫不及待的走回办公桌，看到桌上自己的电脑已经提示编译完成，耗时 45 分钟。\\n\\n对了，他想，这个新语言还要有个功能，那就是编译快。\\n\\n这篇小短文不是我的杜撰，而是 Go 语言的作者之一 Rob Pike 的真实经历，尽管经过了艺术加工，但我们也可以看到文中主角敏锐的判断力。是的，十年过去了，软件的运行环境发生了翻天覆地的变化，原先你可以确切地说，我的程序运行在什么架构 CPU、几 G 内存的机器上。现在，容器和 Kubernetes 的变革已经让你回答不了这个问题。它可能这一秒运行在这台机器，下一秒被调度到其它机器；甚至机器本身，也可能是虚拟机、或者虚拟机虚拟出来的虚拟机。硬件已经被抽象，变成了一个被称作“云”的庞然大物。\\n\\n让我们从 Go 诞生的故事回到当下，Java 语言依旧是服务端当之无愧的王者，而 Go 语言会是那颗闪着银白色寒芒的天狼星吗？很多人在发问，也有很多人从语法、框架、面向对象和面向接口......层面去对比，去分析。\\n\\n我也一直在思考这个问题，我现在的答案是，会，但有前提条件。\\n\\n如果我们一直从语法、框架、面向对象的层面去对比，那么永远也不会有结果，“术”的层面总是各有优劣的，我们要一起往更深一层次去分析。\\n\\n于 Java 而言，核心是 Spring，以及那句名言：“一切皆对象”。很多 Java 程序员最爱干的，应该就是“抽象”这个事儿，所以如何合理的设计和抽象，让代码可读，成为了衡量 Java 程序员最重要的指标之一。从公司的角度看，日积月累的抽象，也让内部的框架越来越复杂，功能越来越多，甚至最后，这个框架本身都可以拿去 2B 的市场去卖个好价钱。框架，也成为了Java最大的护城河，很多刚从 Java 转 Go 的程序员都会问一个可爱的问题：“Go 有类似于 Java 这种 Spring 的框架吗？”\\n\\n请大家等等，请大家停下来想想，如果 Go 有这种框架，那么转 Go 的意义是什么呢？Go 的 CSP 模型这么吸引人，Java 难道就没有吗？ Java 以前不够快，现在还不够快吗？容器镜像大？能大多少，这点差距对你的业务真的很重要吗？\\n\\n如果这些问题无法回答，那么转 Go 只不过是一次内耗，或者是某人的一次 KPI 行动。\\n\\n事实上，我认为，如果不是一样东西的横空出世，Go 是不可能取代 Java 的，你不可能在竞争对手的优势领域打败它。\\n\\n这样东西叫微服务（Microservices），谈到它，大家应该很不陌生。微服务嘛，那就得拆，把服务拆散，怎么拆呢？网上搜，有人说：“这么办，单体服务，我们竖着给它一刀，把它按业务拆分，这叫 SOA 架构；再横着给它一刀，把它按代码层次拆分，这叫水平分层架构。好了！这就是微服务了。”当年我看到这句话，豁然开朗，原来，SOA+水平分层就是微服务，简单，这就把单体服务按在手术台上大卸八块。\\n\\n等等，各位，我们还是要停下来想想，就这么一个服务拆分方案，有必要搞得这么火吗？\\n\\n有人又说，那是因为你切的不对，你得按照 DDD（领域驱动设计） 的法则来切。\\n\\n让我们先放下手中的手术刀，回顾一下微服务的定义：“微服务是一种通过多个小型服务组合来构建单个应用的架构风格，这些服务围绕业务能力而非特定的技术标准来构建。各个服务可以采用不同的编程语言，不同的数据存储技术，运行在不同的进程之中。服务采取轻量级的通信机制和自动化的部署机制实现通信与运维。”这个定义到底在说什么？\\n\\n不同语言？不同进程？轻量通信？那我 Java 的 Spring 怎么办，别的语言不一定有。我框架封装的通信不可能轻量啊，要实现那么多功能：负载均衡、限流、健康检查、监控等等等等，难道我每个语言都实现一遍吗？\\n\\n想到这里，我们回到本节的开头之问，我们的比较，本质并不是 Java 和 Go 之争，而是以 SDK、Libary为代表的框架思想，和微服务代表的服务思想之争。这是一场思想上的革命，在微服务看来，整个系统是由一个一个的服务组成的，服务和服务之间相互解耦，各自完成自己的职责，共同对外提供服务。在这个世界里，不存在一种上帝般的框架，所有服务都要接入，都要信仰。\\n\\n失去了框架的束缚，各服务可以自由迭代，自由选择语言，自由替换，自由伸缩。容器和 Kubernetes 会保证这些服务的有序调度，ServicesMesh 会保证负载均衡、限流、健康检查、监控等一系列事项的正确运行。\\n\\n因此，正是因为现在流行的这些技术，催生了微服务的土壤。这是一种思想观念的转变，从重框架，重设计的思想，转变为重服务，重Sidecar的思想，而我们正处在这一时代的变革之中，Java社区、Java的维护者，这些世界顶级的聪明人，他们何尝不知道，Java也在改变，也想顺应这个时代的变化，变得轻量、快速。但有个人告诉过我们，看待事物要辩证的看待，当年Java搭建的护城河，那些让它登顶的技术，同样也是它现在要改变所碰到的最大壁垒。\\n\\n在这个时代的转变中，Go语言成为了其中的基石，不是因为它设计的多么精妙（事实上，比它设计的精妙的语言多的是），而是因为它是其中一些技术的关键语言。\\n\\n#### 编程历史学\\n\\n我一直在想，为什么我们的大学没有这样一门学科，从世界第一台计算机埃尼阿克开始，编程经历了多少令人心醉的故事，衍生出了多少技术分支。其中一些分支永远也不会有人提交了，它输在了时代的竞争中；其中一些分支被合并到主线，成为了我们的主流技术。也许是编程技术发展的太快，相比回溯过去，我们更向往未来的提交。\\n\\n但回溯真的不仅仅是一种怀念，它让我们了解到一个技术的由来，而不仅仅是通过它的官网简介，我们要知道它为什么出现，要解决什么问题。通过历史的经验，我们可以总结出，它能不能解决这些问题。\\n\\n是的，我已经从事编程5年了，也时常听到这些问题，有人说，技术更新换代太快，学不动了；有人说，技术没什么用的，不要沉迷技术；有人说，我们要学习底层技术，才不会被时代淘汰。\\n\\n各位读者还记得自己第一次运行成功的喜悦吗？为什么，为什么越到后面越悲观了呢？为什么35岁淘汰论总是围绕着技术人？\\n\\n如果在技术范围内找问题的答案，永远也不会有答案。学习更多的技术防止淘汰？如果你学的技术本身就要被时代淘汰，这和49加入国军有什么区别。花心思学习底层技术？各位如果是编程新手，我想说，现在市场上这种岗位非常少，专门为这些底层，如操作系统、算法、网络设计的专门岗位，即使有，要求也非常高。你可以让底层技术作为你的优势科目，但千万不能想着光靠它吃饭。\\n\\n一定要跳出技术看技术。本质上，技术就是一种工具，谁的工具？市场、公司的工具。它们用技术为自己盈利，用技术制造护城河，打败竞争对手。虽然和“技术改变世界”的口号不一样，我们技术人似乎是时代的弄潮儿，其实不是，从古至今，盈利才是时代的本质。技术可以很重要，也可以很不重要，取决于它们用技术作为自己的核心盈利点还是边缘辅助业务。\\n\\n请先不要去痛骂资本，痛骂它们是金钱的奴隶。辩证地想一想，正是因为它们想盈利，它们选择了先进的技术，技术才能改变世界。\\n\\n那么，未来它们需要什么样的技术，学了这些技术的人就不会被淘汰，反而会成为自己的核心竞争力。\\n\\n怎么样，以上是不是一句废话，你可能会说，我要是知道未来它们会用什么技术，我还干技术干什么，我去买彩票不好吗？稍安勿躁，各位：我们虽然不是东方朔，但是我们可以了解历史，去思考“一门技术的创造原因是什么？被选择的原因是什么？它在那个历史条件下被选择，在如今的环境下还会被选择吗？或者是被淘汰?我该不该选择学习这门技术？”\\n\\n以史为鉴，可以知兴衰。这就是编程历史学的魅力。\\n\\n#### Gopher 的真正核心竞争力\\n\\n到了这儿，各位Gopher是不是有点激动，计算机和编程已经深入了各行各业，程序员再也不是原来那个神秘、高收入、令人尊敬的工程师，也只不过是一个普通的技术人员。下一步，时代的车轮滚滚转动，市场选择微服务，选择一种更进退自如、能够自愈的架构方式，代替原来万能框架，又会带来一次新的变革。\\n\\n在这场变革中，Gopher如果不能转变观念，还是以学习java那一套来学习go世界，应该很快会碰到一个问题，那就是go本身也没什么好学的。\\n\\ngo面试就没有Java面试那么丰富的知识点，没有23种设计模式，没有JVM，语法层面也没有什么特别多的问题，更没有统一的框架可以问。也只能问问Channel、GC 这块。\\n\\n所以既要学好 Go 本身，更要学好微服务，学好实现微服务要用到的各种工具：容器、Kubernetes、ServicesMesh。由于这些工具很多都是用 Go 编写，这就为我们的阅读、学习、改造提供了便利。近水楼台先得月，这就是Gopher的核心竞争力。\\n\\n#### 微服务的优与劣\\n\\n总结一下，微服务是一场架构层面的变革，而 Go 由于其简单实用的语法、编译快、可执行文件小等特点，是微服务所依赖的底层基础设施常用语言，这也许会为 Go 开发者进一步学习提供一定的基础，但“千里之行始于足下”，如果不认真去学，一步一个脚印，知识也不会凭空而来。\\n\\n我在前面的篇幅着重介绍了微服务，似乎它就是未来软件开发的首选，以后每个开发、每个公司都会选择它，但我们都知道：“软件开发没有'银弹'”，一个事物，如果它的优势越明显，那么它的劣势也越明显，而且一般来说，它的劣势就是它优势的反面。\\n\\n微服务优势可以总结有如下几点：\\n\\n1. 业务代码和技术代码分离\\n\\n原先在框架内部的代码如负载均衡、服务注册、熔断限流、链路追踪等等，均沉淀到技术底层，对业务的开发人员透明化，业务开发人员可以更好的思考用什么语言、什么存储去实现服务逻辑，而不必受到框架的限制。\\n\\n2. 快速迭代，稳定发布\\n\\n微服务专注于一项功能，且有清晰的接口边界。这样，无论是迭代升级，还是完全推到重来，改造的成本都比较小。而且，由于底层调度系统的支持，发布服务时再也不用等到凌晨用户量少的时候偷偷更新一下，发布变得更快速更稳定。\\n\\n3. 简化开发步骤，提升效率\\n\\n微服务化以后，对于普通开发人员而言，负担是更轻了的，技术代码的抽离使底层技术成为黑盒，开发新服务只需要一个轻量的框架，快速配置一下即可马上开始开发，梦回 SpringBoot 时代。\\n\\n而微服务的劣势，同样也是三点：\\n\\n1. 沉重的技术架构带来的考验\\n\\n代码的分离势必导致团队内对底层服务的了解更少了，即使团队内有人愿意去学习，一方面可能了解的人不愿意花心思科普；另一方面自己也有沉重的业务开发负担，精力不够。\\n\\n所以有关微服务的书籍都会不约而同的提到“康威定律”，就是要求这些分离出去的技术设施需要独立团队维护。自从阿里提出“中台化”战略后，这些基础设施也有高大上的名字：“技术中台”。\\n\\n但理想很丰满，现实很骨感。就我的角度看，这样一个团队在中小型公司存活的概率不大，一方面这些设施的建设是长期工程，短期难见成效；另一方面，这个团队在内部推行新设施的阻力也是比较大的，容易遭到业务侧的反对。\\n\\n可是这个团队无法成立，微服务就只能沦为拆服务的游戏。\\n\\n2. DevOps 的要求\\n\\n微服务同样对运维团队提出了更高的要求，也就是现在常听的“DevOps”。原先发布可能就是丢个包上去就行，那些“build once , run anywhere”什么的口号都是广告，实际上普通的公司也没那么多的平台需求。\\n\\n现在发布要搭建一套自动化发布流，与“技术中台”团队有更多的重合部分。实际上问题和“技术中台”团队碰到的差不多，效益和推广问题。\\n\\n但 DevOps 稍微温和一些，因为实打实的能在短期内看到效果（发布变快了）。\\n\\n3. 固化程序员的阶层\\n\\n普通开发者能更快的开发程序，关注更少的架构侧的变化，对公司是好事，对个人不见得是好事。技术团队由人人都可能成为精英，变成了少量精英带领大量技术工人。原先人人开发，线上出现问题，大家各自解决 bug。现在，bug 先由基础设施过滤一遍，一些可能不会出现，一些可能基础设施本身就解决了。导致工人们无法处理更多的 bug，获得更多的实践经验。\\n\\n举个例子，一个新手后端开发，原先写的代码可能会导致流量过大时出现内存泄露，本来是一个严重的错误，但是在微服务架构下，流量变大时，服务自动扩容，可能内存泄露根本不会被触发，那这位新手后端开发永远也不会知道自己的代码哪里出现了问题。\\n\\n那么，精英们在优化基础设施的过程中越来越巩固自己的知识，工人们却已经无法通过实践更新自己的认知，这种马太效应会越来越分化精英和工人之间的差距。\\n\\n工人们能通过学习改变自己吗？就软件学科而言，很难。没有实践，看再多书，学再多的东西，只不过是什么时候会忘记的问题。\\n\\n\\n#### 参考文献\\n\\n- 《凤凰架构》 https://icyfenix.cn/architecture/architect-history/microservices.html\\n- 《微服务设计》\\n\\n> 作者正在找工作，在新的一年，希望能迎接更多的技术挑战，深入云原生领域学习，尤其是服务治理和可观测性，如有相关岗位可与我沟通~\\n\\n\\n",
        "tags": [
            "后端",
            "Go",
            "微服务"
        ]
    },
    {
        "article_id": "7167260129853702175",
        "cover_image": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ccbfcbe57fef43e5b63123d39cf7317a~tplv-k3u1fbpfcp-watermark.image?",
        "title": "“我要个六边形毛玻璃效果”",
        "brief": "毛玻璃质感（Glassmorphism）：本质上是模糊，上方是带有透明度的遮罩模糊，下方元素像有一层蒙层。通透轻盈，呼吸感强，具有虚实结合的美感。",
        "user_name": "tozero",
        "view_count": 3664,
        "collect_count": 60,
        "comment_count": 14,
        "avatar": "https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be3cfa3e78bf4d37af8095d044d22abd~tplv-k3u1fbpfcp-watermark.image?",
        "category": "前端",
        "content": "### 毛玻璃效果\\n---\\n毛玻璃质感（Glassmorphism）：本质上是模糊，上方是带有透明度的遮罩模糊，下方元素像有一层蒙层。通透轻盈，呼吸感强，具有虚实结合的美感。\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d6a277356fc2457897ae006331b875bb~tplv-k3u1fbpfcp-watermark.image?)\\n\\n那如何实现呢？简单，一行代码\\n```css\\n// CSS \\nbackdrop-filter:blur(12px);\\n```\\nCSS滤镜`backdrop-filter`属性\\n- `blur()`:模糊；\\n- `brightness()`:亮度；\\n- `contrast()`:对比度\\n- `drop-shadow()`:投影\\n- `grayscale()`:灰度；\\n- `hue-rotate()`:色调变化；\\n- `invert()`:反向；\\n- `opacity()`:透明度；\\n- `saturate()`:饱和度；\\n- `sepia()`:褐色；\\n\\n既然都是滤镜，那么`backdrop-filter`和`filter`有什么区别呢？\\n-   `filter`：该属性将模糊或颜色偏移等图形效果应用于元素。\\n-   `backdrop-filter`：该属性可以让你为一个元素后面区域添加图形效果（如模糊或颜色偏移）。它适用于元素背后的所有元素，为了看到效果，必须使元素或其背景至少部分透明。\\n\\n**`filter` 是作用于元素本身**，而 **`backdrop-filter` 是作用于元素背后的区域所覆盖的所有元素。**\\n\\n除此之外`filter`和`backdrop-filter`所支持的属性完全一致。\\n\\n因此，如果模糊效果使用`filter`中的`blur()`，则会使其子元素全部模糊。\\n\\n兼容性：\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0c1220ae3c34b7988b5bbe7d5768e31~tplv-k3u1fbpfcp-watermark.image?)\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b3df47b6660445fb2b47b566c624958~tplv-k3u1fbpfcp-watermark.image?)\\n\\n*UI：导航栏，卡片，小按钮，背景全部给我安排上！*\\n\\n\\n### 异形毛玻璃\\n--- \\nUI：把图片上的小玻璃统统加上毛玻璃！    \\n我：自己切去！\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ce310196eab41dda5bf235e346167e3~tplv-k3u1fbpfcp-watermark.image?)\\n由于有位移动画，无法让UI直接导出毛玻璃透视的图片，只能手工加了🤦‍♀️\\n\\n另辟蹊径：  \\n使用用**SVG绘制路径**，再利用clipPath剪切路径。**（如果边界超出，可用加一个透明边界`border: 1px solid transparent`）**\\n```html\\n//css\\n.ban2 {\\n      position: absolute;\\n      top: 107px;\\n      right: 139px;\\n      z-index: 17;\\n       border: 1px solid transparent;//不加边界毛玻璃效果是个方块\\n       -webkit-clip-path: url(#banGlass);\\n       clip-path: url(#banGlass);\\n       backdrop-filter: saturate(180%) blur(2px);//毛玻璃效果\\n       background: linear-gradient(\\n         45deg,\\n         rgba(64, 140, 253, 0.12),\\n         rgba(146, 202, 255, 0.12)\\n       );\\n      animation: banImgAnim 2.5s infinite alternate linear;//无聊的起伏动画\\n    }\\n//html\\n//svg引用\\n<div class=\\\"ban2\\\">\\n            <svg width=\\\"100%\\\" height=\\\"100%\\\" viewBox=\\\"0 0 228.64 220.15\\\">\\n              <use xlink:href=\\\"#glassImg\\\" />\\n            </svg>\\n</div>\\n//svg绘制\\n<svg width=\\\"100%\\\" height=\\\"100%\\\" viewBox=\\\"0 0 228.64 220.15\\\">\\n        <defs id=\\\"glassImg\\\">\\n          <clipPath id=\\\"banGlass\\\">\\n            <linearGradient\\n              id=\\\"路径_10_\\\"\\n              gradientUnits=\\\"userSpaceOnUse\\\"\\n              x1=\\\"-847.1108\\\"\\n              y1=\\\"651.968\\\"\\n              x2=\\\"-847.1904\\\"\\n              y2=\\\"651.165\\\"\\n              gradientTransform=\\\"matrix(228.6432 0 0 -220.15 193813.2344 143552.0938)\\\"\\n            >\\n              <stop offset=\\\"0\\\" style=\\\"stop-color: #92caff\\\" />\\n              <stop offset=\\\"1\\\" style=\\\"stop-color: #408cfd\\\" />\\n            </linearGradient>\\n\\n            <polygon\\n              id=\\\"路径_1_\\\"\\n              class=\\\"st5\\\"\\n              points=\\\"84,0 198.4,44.8 232.3,154.9 152,220.1 37.6,175.3 3.7,65.3 \\\"\\n            />\\n          </clipPath>\\n        </defs>\\n      </svg>\\n```\\n哦豁，完成！\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4fc28c2b1de24d56863dba51b8bc2650~tplv-k3u1fbpfcp-watermark.image?)",
        "tags": [
            "前端",
            "CSS",
            "SVG"
        ]
    },
    {
        "article_id": "7193979463921565755",
        "cover_image": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/afde037551f3459c8fc52b6aa2b9ea81~tplv-k3u1fbpfcp-watermark.image?",
        "title": "ORM哪家强？java，c#，php，python，go 逐一对比， 网友直呼：全面客观",
        "brief": "最近一段时间，我使用golang开发了一个新的ORM库。 为了让这个库更好用，我比较研究了各语言的主流ORM库，发现有一些语言的ORM库确实很好用，而有另外一些语言的库那不是一般的难用。于是...",
        "user_name": "程序员汤汤",
        "view_count": 2729,
        "collect_count": 27,
        "comment_count": 27,
        "avatar": "https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/27/16cd120eeeed063b~tplv-t2oaga2asx-image.image",
        "category": "后端",
        "content": "# 前言\\n最近一段时间，我使用`golang`开发了一个新的`ORM`库。\\n\\n为了让这个库更好用，我比较研究了各语言的主流`ORM`库，发现有一些语言的`ORM`库确实很好用，而有另外一些语言的库那不是一般的难用。\\n\\n然后我总结了他们呢的一些共性和差异点，于是形成了本文的主要内容。\\n\\n本文会先说明什么是SQL编写难题，以及探讨一下 `code first` 和 `database first` 的优缺点。\\n然后依据这两个问题的结论去审视目前主流后端语言`java`, `c#`, `php`, `python`, `go`各自的orm库，对比研究下他们的优缺点。最后给出总结和参考文档。\\n\\n如果你需要做技术选型，或者做技术研究，或者类似于我做框架开发，或者单纯地了解各语言的差异，或者就是想吹个牛，建议保存或收藏。如果本文所涉及到的内容有任何不正确，欢迎批评指正。\\n\\n温馨提示，本文会有一些戏谑或者调侃成分，并非对某些语言或者语言的使用者有任何歧视意见。\\n如果对你造成了某些伤害，请多包涵。\\n\\n![renzhen.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc61c2476c594edaa2fc110643042ebd~tplv-k3u1fbpfcp-watermark.image?)\\n\\n# 什么是SQL编写难题\\n如果你是做web开发，那么必然需要保存数据到数据库，这个时候你必须熟悉使用sql语句来读写数据库。\\n\\nsql本身不难，命令也就那几个，关键字也不算多，但是为什么编写sql会成为难题呢？\\n\\n比如下面的sql\\n```sql\\n    select * from user\\n    \\n    insert user (name,mobile) values ('tang','18600000000')\\n```\\n它有什么难题？ 简单的单表操作嘛，一点难题没有，但凡学过点`sql`的程序员都能写出来，并且保证正确。我估计比例能超过90%\\n\\n但是，如果你需要写下面的sql呢？\\n```sql\\n    SELECT \\n        article.*,\\n        person.name as person_name \\n    FROM article \\n    LEFT JOIN person ON person.id=article.person_id \\n    WHERE article.type = 0 \\n    AND article.age IN (18,20)\\n```\\n这个也不复杂，就是你在做查询列表的时候，会经常用到的联表查询。你是否还有勇气说，写出来的`sql`绝对正确。我估计比例不超过70%\\n\\n再稍微复杂点，如果是下面的sql？\\n```sql\\n    SELECT \\n        o.*,\\n        d.department_name,\\n        (SELECT Sum(so.goods_fee) AS task_detail_target_completed_tem \\n         FROM sale_order so \\n         WHERE so.merchant_id = '356469725829664768' \\n         AND so.create_date BETWEEN (20230127) AND (20230212) \\n         AND so.delete_state = 2 \\n         AND so.department_id = o.department_id\\n        ) AS task_detail_target_completed \\n    FROM task_detail o \\n    LEFT JOIN department d ON d.department_id=o.department_id \\n    WHERE o.merchant_id = '356469725829664768' \\n    AND o.task_id = '356469725972271104768'\\n```\\n这是我项目里真实的sql语句，目的是统计出所有部门在某时间段内各自的业绩。逻辑上也不太复杂，但你是否还有勇气说，写出来的`sql`绝对正确。我估计比例不超过40%\\n\\n如上面的sql所示，SQL编写难题在于以下几方面。\\n\\n**要保证字段正确**\\n\\n应该有的字段不能少，不应该有的字段不能多。\\n\\n比如你把`mobile`误打成`mobike`，这属于拼写错误，但是这个拼写错误只有在实际运行的时候才会告诉你字段名错了。  \\n\\n并且项目越大，表越多，字段越多，这种拼写错误发生的可能性越大。以至于可以肯定的说，100%的可能性会出现。\\n\\n**要特别注意sql语法**\\n\\n例如你在查询的时候必须写`from`，绝对不能误写成`form`，但是在实际开发过程中，很容易就打错了。\\n\\n这种错误，也只有运行的时候才会告诉你语法错了。并且`sql`越复杂，这种语法错误发生的可能性越大。\\n\\n**编辑器不会有sql的语法提示**\\n\\n常见的编码用的软件，对于sql相关的代码，不会有语法提示，也不会有表名提示，字段名提示。\\n\\n最终的代码质量如何全凭你的眼力,经验,能力。\\n\\n![下载.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c0394e76c7574fd1ace4f73d3513fcd3~tplv-k3u1fbpfcp-watermark.image?)\\n\\n**很显然，既然存在该难题，那么哪个ORM能解决该难题，就应该算得上好，如果不能解决，则不能称之为好。**\\n\\n# 什么是code first 和 database first\\n这俩概念并不是新概念，但是我估计大多数开发者并不熟悉。\\n\\n所谓 code first, 相近的词是 model fist, 意思是模型优先，指的是在设计和开发系统时，优先和重点做的工作是设计业务模型，然后根据业务模型去创建数据库。\\n\\n所谓 database first，意思是数据库优先，指的是在设计和开发系统时，优先和重点做的工作是创建数据库结构，然后去实现业务。\\n\\n这里我提到了几个词语，可能在不同的语言里叫法不一样，可能不同的人的叫法也不一样，为了下述方便，我们举例子来说。\\n\\n## code first 例子\\n假设我是一个对电商系统完全不懂的小白，手头上也没有如何设计电商系统的资料，我和我的伙伴只是模糊地知道电商系统主要业务就是处理订单。\\n\\n然后我大概会知道这个订单，主要的信息包括哪个用户下单，什么时间下单，有哪几种商品，数量分别是多少，根据这些已有的信息，我可以设计出来业务模型如下\\n\\n```java\\npublic class OrderModel {\\n    //订单编号\\n    Integer orderId;\\n    //用户编号\\n    Integer userId;\\n    //订单时间\\n    Integer createTime;\\n    //订单详情(包含商品编号，商品数量)\\n    String  orderDetail;\\n}\\n```\\n很简单，对吧，这个模型很匹配我目前对系统的认知。接下来会做各种业务逻辑，最后要做的是将订单模型的数据保存到数据库。但是在保存数据到数据库的时候，就有一些考虑了。\\n\\n我可以将上面`OrderModel`业务模型建立一张对应表，里面的4个属性，对应数据表里的4个字段，这完全可以。\\n但是我是电商小白，不是数据库小白啊，这样存储的话，肯定不利于统计订单商品的。\\n\\n所以我换一种策略，将`OrderModel`的信息进行拆分，将前三个属性 orderId, userId, createTime 放到一个新的类里。\\n然后将 orderDetail 的信息进行再次分解，放到另一个类里\\n```java\\npublic class OrderEntity {\\n    Integer orderId;\\n    Integer userId;\\n    Integer createTime;\\n}\\n\\npublic class OrderDetailEntity {\\n    Integer orderDetailId;\\n    Integer orderId;\\n    Integer goodsId;\\n    Integer goodsCount;\\n}\\n```\\n最后，在数据库建立两张表`order`,`order_detail`，表结构分别对应类`OrderEntity`,`OrderDetailEntity`的结构。\\n\\n至此，我们完成了从业务模型`OrderModel`到数据表`order`,`order_detail`的过程。\\n\\n这就是 code first ，注意这个过程的关键点，我优先考虑的是模型和业务实现，后面将业务模型数据进行分解和保存是次要的，非优先的。\\n\\n## database first 例子\\n假设我是一个对电商系统非常熟悉的老鸟，之前做过很多电商系统，那么我在做新的电商系统的时候，就完全可以先设计数据库。\\n\\n`order`表放订单主要数据，里面有xxx几个字段，分别有什么作用，有哪些状态值\\n\\n`order_detail`表放订单详情数据，，里面有xxx几个字段，分别有什么作用\\n\\n这些都可以很清楚和明确。然后根据表信息，生成`OrderEntity`,以及`OrderDetailEntity`即可开始接下来的编码工作。这种情况下`OrderModel`可能有，也可能没有。\\n\\n这就是 database first ，注意这个过程的关键点，我优先考虑的是数据库结构和数据表结构。\\n\\n## 两种方式对比\\n\\ncode first 模式下， 系统设计者优先考虑的是业务模型`OrderModel`， 它可以描述清楚一个完整业务，包括它的所有业务细节（什么人的订单，什么时候的订单，订单包含哪些商品，数量多少），有利于设计者对于系统的整体把控。\\n\\ndatabase first 模式下， 系统设计者优先考虑的是数据表`order`,`order_detail`，他们中任何一张表都不能完整的描述清楚一个完整业务，只能够描述局部细节，不利于设计者对于系统的整体把控。\\n\\n在这里，调皮的同学会问，在 database first 模式下， 我把`order`,`order_detail`的信息一起看，不就知道完整的业务细节了吗？\\n\\n确实是这样，但这里有一个前提，前提是你必须明确的知道`order`,`order_detail`是需要一起看的，而你知道他们需要一起看的前提是你了解电商系统。 如果你设计的不是电商系统，而是电路系统，你还了解吗？还知道哪些表需要一起看吗？\\n\\n至此，我们可以有以下粗浅的判断：\\n\\n**对于新项目，不熟悉的业务，code first 模式更适合一些**\\n\\n**对于老项目，熟悉的业务，database first 模式更合适一些**\\n\\n**如果两种模式都可以的话，优先使用 code first 模式，便于理解业务，把控项目**\\n\\n**如果哪个ORM支持 code first , 我们可以稍稍认为它更好一些**\\n\\n# Java体系的orm\\nJava语言是web开发领域处于领先地位，这一点无可置疑。它的优点很明显，但是缺点也不是没有。\\n\\n国内应用比较广泛的orm是Mybatis，以及衍生品Mybatis-plus等\\n\\n实际上Mybatis团队还出了另外一款产品，MyBatis Dynamic SQL，国内我见用的不多，讨论都较少。英文还可以的同学，可以看下面的文档。\\n\\n另外还有 jOOQ， 实际上跟 MyBatis Dynamic SQL 非常类似，有兴趣的可以去翻翻\\n\\n下面，我们举一些例子，来对比一下他们的基本操作\\n\\n## Java体系的Mybatis\\n单就orm这一块，国内用的最多的应该是Mybatis，说到它的使用体验吧，那简直是一言难尽。\\n\\n你需要先定义模型,然后编写`xml`文件用来映射数据,然后创建mapper文件，用来执行`xml`里定于的sql。\\n从这个流程可以看出，中间的`xml`文件起到核心作用，里面不光有数据类型转换，还有最核心的`sql`语句。\\n\\n典型的`xml`文件内容如下\\n```xml\\n<mapper namespace=\\\"xxx.mapper.UserMapper\\\">\\n    <insert id=\\\"insertUser\\\" parameterType=\\\"UserEntity\\\">\\n        insert into user (id,name,mobile)\\n        values (#{id},#{name},#{mobile})\\n    </insert>\\n\\n    <update id=\\\"updateUser\\\" parameterType=\\\"UserEntity\\\">\\n        update user set\\n        name = #{name},\\n        mobile = #{mobile}\\n        where id = #{id}\\n    </update>\\n\\n    <delete id=\\\"deleteUser\\\">\\n        delete from user where id = #{id}\\n    </delete>\\n\\n    <select id=\\\"selectUsers\\\" resultType=\\\"UserVO\\\">\\n        select u.*, (select count(*) from article a where a.uid=u.id) as article_count\\n        from user u\\n        where u.id = #{id}\\n    </select>\\n</mapper>\\n```\\n你在编写这个`xml`文件的时候，这个手写sql没有本质区别，一定会遇到刚才说到的`SQL编写难题`。\\n\\n## Java体系的Mybatis-plus\\n这里有必要提一下 Mybatis-plus，它是国内的团队开发出来的工具，算是对Mybatis的扩展吧，它减少了`xml`文件内容的编写，减少了一些开发的痛苦。比如，你可以使用如下的代码来完成以上相同的工作\\n```java\\n    userService.insert(user);\\n\\n    userService.update(user);\\n\\n    userService.deleteById(user);\\n\\n    List<UserEntity> userList = userService.selectList(queryWrapper);\\n```\\n完成这些工作，你不需要编写任何`xml`文件，也不需要编写`sql`语句，如之前所述，减少了一些开发的痛苦。\\n\\n但是，请你注意我的用词，是减少了一些。\\n\\n对于连表操作，嵌套查询等涉及到多表操作的事情，它就不行了，为啥不行，因为根本就不支持啊。\\n遇到这种情况，你就老老实实的去写`xml`吧，然后你还会遇到刚才说到的`SQL编写难题`。\\n\\n## Java体系的Mybatis3 Dynamic Sql\\n值得一提的是Mybatis3 Dynamic Sql，翻译一下就是动态sql。还是刚才说的国内我见用的不多，讨论都较少，但是评价看上去挺好。\\n\\n简单来说，可以根据不同条件拼接出sql语句。不同于上面的Mybatis，这些sql语句是程序运行时生成的，而不是提前写好的，或者定义好的。\\n\\n它的使用流程是，先在数据库里定义好数据表，然后创建模型文件，让然后通过命令行工具，将每一个表生成如下的支持文件\\n```java\\npublic final class PersonDynamicSqlSupport {\\n    public static final Person person = new Person();\\n    public static final SqlColumn<Integer> id = person.id;\\n    public static final SqlColumn<String> firstName = person.firstName;\\n    public static final SqlColumn<LastName> lastName = person.lastName;\\n    public static final SqlColumn<Date> birthDate = person.birthDate;\\n    public static final SqlColumn<Boolean> employed = person.employed;\\n    public static final SqlColumn<String> occupation = person.occupation;\\n    public static final SqlColumn<Integer> addressId = person.addressId;\\n\\n    public static final class Person extends SqlTable {\\n        public final SqlColumn<Integer> id = column(\\\"id\\\", JDBCType.INTEGER);\\n        public final SqlColumn<String> firstName = column(\\\"first_name\\\", JDBCType.VARCHAR);\\n        public final SqlColumn<LastName> lastName = column(\\\"last_name\\\", JDBCType.VARCHAR, \\\"examples.simple.LastNameTypeHandler\\\");\\n        public final SqlColumn<Date> birthDate = column(\\\"birth_date\\\", JDBCType.DATE);\\n        public final SqlColumn<Boolean> employed = column(\\\"employed\\\", JDBCType.VARCHAR, \\\"examples.simple.YesNoTypeHandler\\\");\\n        public final SqlColumn<String> occupation = column(\\\"occupation\\\", JDBCType.VARCHAR);\\n        public final SqlColumn<Integer> addressId = column(\\\"address_id\\\", JDBCType.INTEGER);\\n\\n        public Person() {\\n            super(\\\"Person\\\");\\n        }\\n    }\\n}\\n```\\n可以看出，这里的主要功能能是将表内的字段，与java项目里的类里面的属性，做了一一映射。\\n\\n接下来你在开发的时候，就不用关心表名，以及字段名了，直接使用刚才生成的类，以及类下面的那些属性。具体如下\\n\\n```java\\n        SelectStatementProvider selectStatement = select(id.as(\\\"A_ID\\\"), firstName, lastName, birthDate, employed,occupation, addressId)\\n        .from(person)\\n        .where(id, isEqualTo(1))\\n        .or(occupation, isNull())\\n        .build()\\n        .render(RenderingStrategies.MYBATIS3);\\n\\n        List<PersonRecord> rows = mapper.selectMany(selectStatement);\\n```\\n如上面的代码，好处有以下四点\\n\\n1. 你不再需要手写sql\\n2. 也不用在意字段名了，因为使用的都是类，或者属性，编写代码的时候编辑器会有提示，编译的时候如果有错误也会提示，实际运行的时候就不会有问题了。\\n3. 联表查询，嵌套查询啥的，也都支持\\n4. 完美避开了`SQL编写难题`\\n\\n当然带来了额外的事情，比如你要使用工具来生成`PersonDynamicSqlSupport`类，比如你要先建表。\\n\\n先建表这事儿，很明显就属于 `database first` 模式。\\n\\n![事情不大.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/06cbc082c3c24647a478198ac3fd9dac~tplv-k3u1fbpfcp-watermark.image?)\\n\\n# C#体系的orm\\nC# 在工业领域，游戏领域用的多一些，在web领域少一些。\\n\\n它也有自己的orm，名字叫 Entity Framework Core, 一直都是微软公司在维护。\\n\\n下面是一个典型的联表查询\\n\\n```c#\\n    var id = 1;\\n    var query = database.Posts\\n                .Join(database.Post_Metas,\\n                    post => post.ID,\\n                    meta => meta.Post_ID,\\n                    (post, meta) => new { Post = post, Meta = meta }\\n                )\\n                .Where(postAndMeta => postAndMeta.Post.ID == id);\\n```\\n这句代码的主要作用是，将数据库里的Posts表，与Post_Metas表做内联操作，然后取出Post.ID等于1的数据\\n\\n这里出现的Post，以及Meta都是提前定义好的模型，也就是类。 Post.ID 是 Post 的一个属性，也是提前定义好的。\\n\\n整个功能的优点很多，你不再需要手写sql，不需要关心字段名，不需要生成额外类，也不会有语法错误，你只需要提前定义好模型，完全没有`SQL编写难题`，很明显就属于 `code first` 模式。\\n\\n对比java的Mybatis以及Mybatis3 Dynamic Sql来说，你可以脑补一下下面的场景    \\n\\n![javavsc#.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c0475f2473534503b9555c7f56012158~tplv-k3u1fbpfcp-watermark.image?)\\n\\n# PHP体系的orm\\nphp体系内，框架也非常多，比如常见的`laravel`,`symfony`，这里我们就看这两个，比较有代表性\\n\\n## PHP体系的laravel\\n使用php语言开发web应用的也很多，其中比较出名的是`laravel`框架，比较典型的操作数据库的代码如下\\n```php\\n$user = DB::table('users')->where('name', 'John')->first();\\n```\\n这里没有使用模型(就算使用了也差不多)，代码里出现的 users 就是数据库表的名字， name 是 users 表里的字段名，他们是被直接写入代码的\\n\\n很明显它会产生`SQL编写难题`\\n\\n并且，因为是先设计数据库，肯定也属于 `database first` 模式\\n\\n## PHP体系的symfony\\n这个框架历史也比较悠久了，它使用了 Doctrine 找个类库作为orm\\n\\n使用它之前，也需要先定义模型，然后生成支持文件，然后建表，但是在实际使用的时候，还是和laravel一样，表名，字段名都需要硬编码\\n```php\\n$repository = $this->getDoctrine()->getRepository('AppBundle:Product');\\n \\n// query for a single product by its primary key (usually \\\"id\\\")\\n// 通过主键（通常是id）查询一件产品\\n$product = $repository->find($productId);\\n \\n// dynamic method names to find a single product based on a column value\\n// 动态方法名称，基于字段的值来找到一件产品\\n$product = $repository->findOneById($productId);\\n$product = $repository->findOneByName('Keyboard');\\n\\n// query for multiple products matching the given name, ordered by price\\n// 查询多件产品，要匹配给定的名称和价格\\n$products = $repository->findBy(\\n    array('name' => 'Keyboard'),\\n    array('price' => 'ASC')\\n);\\n```\\n很明显它也会产生`SQL编写难题`\\n\\n另外，并不是先设计表，属于 `code first` 模式\\n\\n\\n![下载.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/764abce80d6d4557825fab1b325c44c2~tplv-k3u1fbpfcp-watermark.image?)\\n\\n# python体系的orm\\n在python领域，有一个非常著名的框架，叫django, 另外一个比较出名的叫flask, 前者追求大而全，后者追求小而精\\n\\n## python体系的django\\ndjango推荐的开发方法，也是先建模型，但是在查询的时候，这建立的模型，基本上毫无用处\\n```python\\n    res=models.Author.objects.filter(name='jason').values('author_detail__phone','name')\\n    print(res)\\n    # 反向\\n    res = models.AuthorDetail.objects.filter(author__name='jason')  # 拿作者姓名是jason的作者详情\\n    res = models.AuthorDetail.objects.filter(author__name='jason').values('phone','author__name')\\n    print(res)\\n\\n\\n    # 2.查询书籍主键为1的出版社名称和书的名称\\n    res = models.Book.objects.filter(pk=1).values('title','publish__name')\\n    print(res)\\n    # 反向\\n    res = models.Publish.objects.filter(book__id=1).values('name','book__title')\\n    print(res)\\n```\\n如上连表查询的代码，values('title','publish__name') 这里面写的全都是字段名，硬编码进去，进而产生sql语句，查询出结果\\n\\n很显然，它也会产生`SQL编写难题`\\n\\n另外，并不是先设计表，属于 `code first` 模式\\n\\n## python体系的flask\\nflask本身没有orm，一般搭配 sqlalchemy 使用\\n\\n使用 sqlalchemy 的时候，一般也是先建模型，然后查询的时候，可以直接使用模型的属性，而无须硬编码\\n```python\\nresult = session.               \\nquery(User.username,func.count(Article.id)).\\njoin(Article,User.id==Article.uid).\\ngroup_by(User.id).\\norder_by(func.count(Article.id).desc()).\\nall()\\n```\\n如上 Article.id 即是 Article 模型下的 id 属性\\n\\n很显然，它不会产生`SQL编写难题`\\n\\n另外，并不是先设计表，属于 `code first` 模式\\n\\n\\n![下载 (1).png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b68e0f7e1e7e45519fa4334b10148f00~tplv-k3u1fbpfcp-watermark.image?)\\n\\n# go体系的orm\\n在go体系，orm比较多，属于百花齐放的形态，比如国内用的多得gorm以及gorm gen，国外比较多的ent, 当然还有我自己写的 arom\\n\\n## go体系下的gorm\\n使用gorm，一般的流程是你先建立模型，然后使用类似如下的代码进行操作\\n```go\\ntype User struct {\\n  Id  int\\n  Age int\\n}\\n\\ntype Order struct {\\n  UserId     int\\n  FinishedAt *time.Time\\n}\\n\\nquery := db.Table(\\\"order\\\").\\nSelect(\\\"MAX(order.finished_at) as latest\\\").\\nJoins(\\\"left join user user on order.user_id = user.id\\\").\\nWhere(\\\"user.age > ?\\\", 18).\\nGroup(\\\"order.user_id\\\")\\n\\ndb.Model(&Order{}).\\nJoins(\\\"join (?) q on order.finished_at = q.latest\\\", query).\\nScan(&results)\\n```\\n这是一个嵌套查询，虽然定义了模型，但是查询的时候并没有使用模型的属性，而是输入硬编码\\n\\n很显然，它会产生`SQL编写难题`\\n\\n另外，是先设计模型，属于 `code first` 模式\\n\\n## go体系下的gorm gen\\ngorm gen 是 gorm 团队开发的另一款产品，和mybaits下的Mybatis3 Dynamic Sql比较像\\n\\n它的流程是 先创建数据表，然后使用工具生成结构体(类)和支持代码, 然后再使用生成的结构体\\n\\n它生成的比较关键的代码如下\\n```go\\nfunc newUser(db *gorm.DB) user {\\n\\t_user := user{}\\n\\n\\t_user.userDo.UseDB(db)\\n\\t_user.userDo.UseModel(&model.User{})\\n\\n\\ttableName := _user.userDo.TableName()\\n\\t_user.ALL = field.NewAsterisk(tableName)\\n\\t_user.ID = field.NewInt64(tableName, \\\"id\\\")\\n\\t_user.Name = field.NewString(tableName, \\\"name\\\")\\n\\t_user.Age = field.NewInt64(tableName, \\\"age\\\")\\n\\t_user.Balance = field.NewFloat64(tableName, \\\"balance\\\")\\n\\t_user.UpdatedAt = field.NewTime(tableName, \\\"updated_at\\\")\\n\\t_user.CreatedAt = field.NewTime(tableName, \\\"created_at\\\")\\n\\t_user.DeletedAt = field.NewField(tableName, \\\"deleted_at\\\")\\n\\t_user.Address = userHasManyAddress{\\n\\t\\tdb: db.Session(&gorm.Session{}),\\n\\n\\t\\tRelationField: field.NewRelation(\\\"Address\\\", \\\"model.Address\\\"),\\n\\t}\\n\\n\\t_user.fillFieldMap()\\n\\n\\treturn _user\\n}\\n```\\n注意看，其中大多数代码的作用是啥？不意外，就是将结构体的属性与表字段做映射关系\\n\\n_user.Name 对应 name   \\n_user.Age 对应 age    \\n\\n如此，跟mybaits下的Mybatis3 Dynamic Sql的思路非常一致\\n\\n典型查询代码如下\\n```go\\nu := query.User\\nerr := u.WithContext(ctx).\\n    Select(u.Name, u.Age.Sum().As(\\\"total\\\")).\\n    Group(u.Name).\\n    Having(u.Name.Eq(\\\"group\\\")).\\n    Scan(&users)\\n\\n// SELECT name, sum(age) as total FROM `users` GROUP BY `name` HAVING name = \\\"group\\\"\\n```\\n这是一个分组查询，定义了模型，也使用了模型的属性。\\n\\n但是呢，它需要使用工具生成额外的支持代码，并且需要先定义数据表\\n\\n很显然，它不会产生`SQL编写难题`\\n\\n另外，它是先设计表，属于 `database first` 模式\\n\\n## go体系下的ent\\nent 是 facebook公司开发的Orm产品，与 gorm gen 有相通，也有不同\\n\\n相同点在于，都是利用工具生成实体与数据表字段的映射关系\\n\\n不同点在于gorm gen先有表和字段，然后生成实体\\n\\nent是没有表和字段，你自己手动配置，配置完了一起生成实体和建表\\n\\n接下来，看一眼ent生成的映射关系\\n```go\\nconst (\\n\\t// Label holds the string label denoting the user type in the database.\\n\\tLabel = \\\"user\\\"\\n\\t// FieldID holds the string denoting the id field in the database.\\n\\tFieldID = \\\"id\\\"\\n\\t// FieldName holds the string denoting the name field in the database.\\n\\tFieldName = \\\"name\\\"\\n\\t// FieldAge holds the string denoting the age field in the database.\\n\\tFieldAge = \\\"age\\\"\\n\\t// FieldAddress holds the string denoting the address field in the database.\\n\\tFieldAddress = \\\"address\\\"\\n\\t// Table holds the table name of the user in the database.\\n\\tTable = \\\"users\\\"\\n)\\n```\\n有了映射关系，使用起来就比较简单了\\n```go\\nu, err := client.User.\\n        Query().\\n        Where(user.Name(\\\"realcp\\\")).\\n        Only(ctx)\\n```\\n注意，这里没有硬编码\\n\\n它需要使用工具生成额外的支持代码，并且需要先配置表结构\\n\\n很显然，它不会产生`SQL编写难题`\\n\\n另外，它属于先设计表，属于 `database first` 模式\\n\\n## go体系下的aorm\\naorm 是我自己开发的orm库，吸取了ef core 的一些优点，比较核心的步骤如下\\n\\n和大多数orm一样，需要先建立模型，比如\\n```go\\n    type Person struct {\\n        Id         null.Int    `aorm:\\\"primary;auto_increment\\\" json:\\\"id\\\"`\\n        Name       null.String `aorm:\\\"size:100;not null;comment:名字\\\" json:\\\"name\\\"`\\n        Sex        null.Bool   `aorm:\\\"index;comment:性别\\\" json:\\\"sex\\\"`\\n        Age        null.Int    `aorm:\\\"index;comment:年龄\\\" json:\\\"age\\\"`\\n        Type       null.Int    `aorm:\\\"index;comment:类型\\\" json:\\\"type\\\"`\\n        CreateTime null.Time   `aorm:\\\"comment:创建时间\\\" json:\\\"createTime\\\"`\\n        Money      null.Float  `aorm:\\\"comment:金额\\\" json:\\\"money\\\"`\\n        Test       null.Float  `aorm:\\\"type:double;comment:测试\\\" json:\\\"test\\\"`\\n    }\\n\\t\\n```\\n然后实例化它，并且保存起来\\n```go\\n    //Instantiation the struct\\n    var person = Person{}\\n\\t\\n    //Store the struct object\\n    aorm.Store(&person)\\n```\\n然后即可使用\\n```go\\n    var personItem Person\\n    err := aorm.Db(db).Table(&person).WhereEq(&person.Id, 1).OrderBy(&person.Id, builder.Desc).GetOne(&personItem)\\n    if err != nil {\\n        fmt.Println(err.Error())\\n    }\\n```\\n\\n很显然，它不会产生`SQL编写难题`\\n\\n另外，它属于先设计模型，属于 `code first` 模式\\n\\n\\n![下载 (2).png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a15f6f776823411ebfa599111b796615~tplv-k3u1fbpfcp-watermark.image?)\\n\\n# 总结\\n本文，我们提出了两个衡量orm功能的原则，并且对比了几大主流后端语言的orm，汇总列表如下\\n\\n|  框架                | 语言       |  SQL编写难题  |  code first  | 额外创建文件  |\\n|  --------------      | ------    | ------------  | ----------  |------  |\\n| MyBatis 3            | java      | 有难度         |不是         | 需要 |\\n| MyBatis-Plus         | java      | 有难度         |不是         | 不需要 |\\n| MyBatis Dynamic SQL  | java      | 没有           |不是         | 需要 |\\n| jOOQ                 | java      | 没有           |不是         | 需要 |\\n| ef core              | c#        | 没有           |是           | 不需要 |\\n| laravel              | php       | 有难度         |不是         | 不需要 |\\n| symfony              | php       | 有难度         |不是         | 需要 |\\n| django               | python    | 有难度         |是           | 不需要 |\\n| sqlalchemy           | python    | 没有           |是           | 不需要 |\\n| grom                 | go        | 有难度         |是           | 不需要 |\\n| grom  gen            | go        | 没有           |不是         | 需要 |\\n| ent                  | go        | 没有           |不是         |需要 |\\n| aorm                 | go        | 没有           |是           |不需要 |\\n\\n单就从这张表来说，不考虑其他条件，在做orm技术选型时，\\n\\n如果你使用java语言，请选择 MyBatis Dynamic SQL 或者 jOOQ，因为选择他们不会有`SQL编写难题`    \\n\\n如果你使用c#语言，请选择 ef core, 这已经是最棒的orm了，不会有`SQL编写难题`，支持`code first`，并且不需要额外的工作   \\n\\n如果你使用php语言，请选择 laravel 而不是 symfony， 反正都有`SQL编写难题`，那就挑个容易使用的\\n\\n如果你使用python语言，请选择 sqlalchemy 库， 不会有`SQL编写难题`，支持`code first`，并且不需要额外的工作   \\n\\n如果你使用go语言，请选择 aorm 库， 不会有`SQL编写难题`，支持`code first`，并且不需要额外的工作   \\n\\n好了，文章写两天了，终于写完了。如果对你有帮助，记得点赞，收藏，转发。\\n\\n如果我有说的不合适，或者不对的地方，请在下面狠狠的批评我。\\n\\n![微信图片_20221226163643.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/892aab3b18554760953693f39e1b4fd0~tplv-k3u1fbpfcp-watermark.image?)\\n\\n# 参考文档  \\n[MyBatis 3](https://mybatis.org/mybatis-3/)    \\n[MyBatis-Plus](https://baomidou.com/pages/24112f/)     \\n[MyBatis Dynamic SQL](https://mybatis.org/mybatis-dynamic-sql/docs/introduction.html)     \\n[jOOQ: The easiest way to write SQL in Java](https://www.jooq.org/)      \\n[Entity Framework Core 概述 - EF Core | Microsoft Learn](https://learn.microsoft.com/zh-cn/ef/core/)     \\n[数据库和Doctrine ORM - Symfony开源 - Symfony中国 (symfonychina.com)](http://www.symfonychina.com/doc/current/doctrine.html)   \\n[Django（ORM查询、多表、跨表、子查询、联表查询） - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/144856668)    \\n[Sqlalchemy join连表查询_FightAlita的博客-CSDN博客_sqlalchemy 连表查询](https://blog.csdn.net/weixin_40123451/article/details/117252473)          \\n[Gorm + Gen自动生成数据库结构体_Onemorelight95的博客-CSDN博客_gorm 自动生成](https://blog.csdn.net/qq_49723651/article/details/127813262)     \\n[tangpanqing/aorm: Operate Database So Easy For GoLang Developer (github.com)](https://github.com/tangpanqing/aorm)  \\n \\n\\n",
        "tags": [
            "Java",
            "Python",
            "PHP"
        ]
    },
    {
        "article_id": "7163836963705847822",
        "cover_image": "https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2087f78fe2034f2488282c4829b2ef62~tplv-k3u1fbpfcp-watermark.image?",
        "title": "不使用JavaScript也能直接修改样式，这一波你学废了吗？",
        "brief": "不使用 JavaScript 也能直接修改样式？听起来有点不可思议，但是接下来我就带你一起来看看这个神奇的效果是如何实现的。 先来看效果，建议在 Chrome 浏览器中查看",
        "user_name": "田八",
        "view_count": 6209,
        "collect_count": 45,
        "comment_count": 36,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/6a646066de6c1376525669efb70295e9~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: juejin\\nhighlight: a11y-dark\\n---\\n不使用 JavaScript 也能直接修改样式？听起来有点不可思议，但是接下来我就带你一起来看看这个神奇的效果是如何实现的。\\n\\n先来看效果，建议在 Chrome 浏览器中查看：\\n\\n[代码片段](https://code.juejin.cn/pen/7163816135677181988)\\n\\n## 浏览器样式\\n\\n大家有没有思考过一个问题？为什么我们在写`html`代码的时候，例如`<h1>`标签，为什么它的字体就是那么大？为什么它会加粗？\\n\\n有的人心里可能已经有答案了，有的人可能还在等我给出答案，答案先不着急，我再问下一个问题。\\n\\n为啥我们在写`meta`、`head`、`title`、`style`、`link`、`script`等标签的时候，为什么它们会不显示？\\n\\nok，停止思考，打开浏览器控制台，找到样式面板，定位到我上面说的这些标签，看看它们的样式是什么？\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5daa6c6599cf48b2bf1ccbb5e5bf5401~tplv-k3u1fbpfcp-watermark.image?)\\n\\n来看看我上面的截图，定位到`<head>`标签，看看它拥有一个样式`display: none`。\\n\\n`display`大家都认识吧，`display: none`大家都知道是什么意思吧，就是不显示。\\n\\n这里只为引出`display`，接下来我们再看另一个属性。\\n\\n## contenteditable\\n\\n`contenteditable`是一个非常有意思的属性，它的作用是让元素变成可编辑的，也就是说，我们可以直接在浏览器中修改元素的样式。\\n\\n它是一个可枚举属性，它的值必须是`true`或者`false`，默认值是`false`。\\n\\n如果没有设置`contenteditable`的值，那么它的值就是空字符串，并且可编辑。\\n\\n为啥要说这个属性呢？因为它可以让我们直接在浏览器中修改元素的样式。\\n\\n## display 和 contenteditable 的碰撞\\n\\n上面说到`meta`、`head`、`title`、`style`、`link`、`script`等标签的样式都是`display: none`，那么我们现在将`style`修改为`display: block`，看看会发生什么？\\n\\n```html\\n<!DOCTYPE html>\\n<html>\\n<head style=\\\"display: block;\\\">\\n    <title>不用javascript修改样式</title>\\n    <style style=\\\"display: block;\\\">\\n        html {\\n            background: red;\\n            color: #fff;\\n        }\\n    </style>\\n</head>\\n<body>\\n</body>\\n</html>\\n```\\n\\n> 注意：这里同时将`<head>`和`<style>`标签的`display`属性修改为`block`，这样它们才能显示出来。\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e26bb5a71ea42698e72ebb597bfab14~tplv-k3u1fbpfcp-watermark.image?)\\n\\n哦豁，咱们写的样式显示出来了，接下来大家应该都知道该怎么做了吧？\\n\\n接下来修改一下空白符显示的样式，将`white-space`属性设置为`pre`，再加点过渡效果，接着我们就可以不使用`javascript`，直接修改样式了。\\n\\n```html\\n<!DOCTYPE html>\\n<html>\\n<head style=\\\"display: block;\\\">\\n    <title>不用javascript修改样式</title>\\n    <style style=\\\"display: block;white-space: pre;-webkit-user-modify: read-write-plaintext-only;\\\" contenteditable>\\n        * {\\n            transition: all .3s;\\n        }\\n\\n        html {\\n            background: red;\\n            color: #fff;\\n        }\\n    </style>\\n</head>\\n<body>\\n</body>\\n</html>\\n```\\n\\n> 注意：这里使用到了`-webkit-user-modify: read-write-plaintext-only;`，目前这个属性只能在`webkit`内核的浏览器中使用，其他浏览器均不支持；  \\n> 如果不加这个属性，那么换行符 和 空格符 等特殊字符都会被转义，这样样式会失效，所以在 Chrome 浏览器中使用最佳。\\n\\n***本文正在参加[「金石计划 . 瓜分6万现金大奖」](https://juejin.cn/post/7162096952883019783 \\\"https://juejin.cn/post/7162096952883019783\\\")***",
        "tags": [
            "前端",
            "CSS",
            "掘金·金石计划"
        ]
    },
    {
        "article_id": "7194964663283482685",
        "cover_image": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4286c5a6c84e458b88f67c0e51a9d99e~tplv-k3u1fbpfcp-watermark.image?",
        "title": "组件库从开发到维护全链路讲解（五）如何优雅的提交代码——规范化",
        "brief": "有人说：代码提交到 Git 仓库的目的不就是为了备份代码吗？能提交上去就行了，搞什么提交规范，不要没事找事啊，保证代码不丢失，能正常跑就行！ 既然如此，那费那么大劲搞提交规范到底是为啥呢？",
        "user_name": "HashTang",
        "view_count": 219,
        "collect_count": 4,
        "comment_count": 0,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/92e697851571083ae5158278563f2ac5~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: orange\\nhighlight: vs2015\\n---\\n\\n> 本篇文章为《[前端组件库的开发与维护](https://juejin.cn/column/7176570622242193468)》系列的第五篇文章。本文案例在线文档：[calendar.hxkj.vip](https://calendar.hxkj.vip)。GitHub 仓库：[github.com/TangSY/vue3-hash-calendar](https://github.com/TangSY/vue3-hash-calendar)。\\n\\n## 为什么需要提交规范\\n\\n有人说：代码提交到 Git 仓库的目的不就是为了备份代码吗？能提交上去就行了，搞什么提交规范，不要没事找事啊，保证代码不丢失，能正常跑就行！\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f8b6738e907b492488aad97f6cbb1e62~tplv-k3u1fbpfcp-watermark.image?)\\n\\n既然如此，那费那么大劲搞提交规范到底是为啥呢？\\n\\n其实呢，它的好处还真的不少。今天在这里给大伙简单的总结一下，对于开源组件库来说有以下五个方面的好处：\\n\\n-   有助于他人更好的理解你的变更意图，更容易贡献/修改代码；\\n-   清晰的历史记录，方便快速浏览查找，回溯之前的内容；\\n-   规范的提交记录可用于自动生成版本发布日志(CHANGELOG.MD)；\\n-   结构化的提交信息有助于自动化脚本的识别和 CI/CD；\\n-   最重要的一条，体现了一个程序员的自我修养。\\n\\n总的来讲就是有百利而无一害。\\n\\n## 规范介绍\\n\\n在众多规范当中，**`Conventional Commits`** 在市场上起主导地位，其主要来源于 [AngularJS规范](https://docs.google.com/document/d/1QrDFcIiPjSLDn3EL15IJygNPiHORgU1_OOAqWjiDU5Y/edit#heading=h.greljkmo14y0) 。这也是行业内使用最为广泛的 Git 提交信息规范，咱们今天就以该规范为例进行讲解：如何制定一套完整的代码提交规范。\\n\\n该规范的提交信息由 **Header**、 **Body** 、**Footer** 三部分组成，Header 又包含 Type、Scope 和 Subject 三部分。格式如下：\\n\\n```\\nType(Scope):Subject\\n\\nBody\\n\\nFooter\\n```\\n\\nHeader、Body、Footer 三者之间用一个空行分隔。咱们日常开发中主要用到的就是 **Header** 部分，其他的基本用不上，就不花时间细讲了。\\n\\n**Header** 包含 3 部分信息分别是：Type（必须）、Scope 和 Subject（必须）。格式如下：\\n\\n```\\nType(Scope):Subject\\n```\\n\\n1.  **Type** 用以说明提交的类别，建议的标识如下：\\n\\n-   `feat`：新功能开发\\n-   `fix`：修复 BUG\\n-   `docs`：文档更新\\n-   `style`：代码格式调整，不影响代码整体运行\\n-   `refactor`：代码重构（没有新功能，也没有修复 BUG）\\n-   `perf`：性能优化\\n-   `test`：更新测试内容（包括增加）\\n-   `chore`：影响构建系统或外部依赖项的更改、对 CI/CD 配置文件的修改\\n-   `revert`：撤销之前提交\\n\\n2.  **Scope** 用以说明本次提交的影响范围，一般根据具体项目进行填写，比如具体修改了哪个组件、哪个文件等，文字尽量简短\\n3.  **Subject** 用以对本次提交的概括说明，推荐以动词开头，如： 设置、修改、增加、删减、撤销等，一般不超过 50 个字符。\\n\\n例如下面这些提交信息，一眼就能看出每次提交都做了啥：\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52d6828abc434bdd958cd11d691e5464~tplv-k3u1fbpfcp-watermark.image?)\\n\\n还有个大幅度提高用户体验的小技巧。如果是对其他人提出的 issue 进行修复的提交，可以在提交信息后面添加上该 issue 的编号，编号前面别忘了加个 `#` 号。这样的话，提交上去之后该编号会自动链接至相应的 issue 详情。(如果按照上述 `Conventional Commits` 规范，这个编号应该放在提交信息的 Footer 部分，但是 Footer 部分已经被我们舍弃了，所以就直接写在 Subject 末尾了)\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc66fd1942884fdd97735d3b98a4e000~tplv-k3u1fbpfcp-watermark.image?)\\n\\n而且 issue 详情里面也会自动添加一条链接，可以跳转至本次提交详情。\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8c4118367344769bc4b7326117e4d04~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## 规范执行\\n\\n规范制订好之后，那怎么确保每个提交都能符合规范呢。最好的方式就是通过特定的工具来生成和校验。\\n\\n### 规范生成工具\\n\\n`commitizen` 是一个命令行工具，可以通过交互的方式，生成符合规范的 git commit 信息。除此之外, 我们还需要为 commitizen 指定一个适配器，比如: `cz-conventional-changelog`。让 commitizen 按照我们指定的规范帮助我们生成 commit 信息。\\n\\n咱们先来安装一下：\\n\\n```\\n# 安装 commitizen\\nyarn add commitizen -D \\n# 安装适配器\\nyarn add cz-conventional-changelog -D \\n```\\n\\n然后在 package.json 中添加一个 scripts：\\n\\n```\\n\\\"commit\\\": \\\"git add . && git cz\\\"\\n```\\n\\n这样的话，后续提交代码时，用 `yarn commit` 代替即可，效果图如下：\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b3f6ceff979244dea4ef300f177bdac2~tplv-k3u1fbpfcp-watermark.image?)\\n\\n如果不在 package.json 中添加 scripts 也不影响使用，但是执行命令得换成 `npx git cz`，执行效果是一样的：\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b69af43da90478aa06ccb9a9eb214b1~tplv-k3u1fbpfcp-watermark.image?)\\n\\n假如你觉得上述的默认提交模板不能入你的法眼、全英文的你不喜欢、你还想加入一些 emoji 表情，可不可以？那当然是可以的。\\n\\n这个时候，`cz-customizable` 就派上用场了，它允许咱们通过修改配置文件的方式自定义提交模板。\\n\\n首先安装 cz-customizable\\n\\n```\\n# 安装 cz-customizable\\nyarn add cz-customizable -D\\n```\\n\\n然后在 package.json 中添加如下 config 配置：\\n\\n```\\n···\\n\\\"config\\\": { \\n  \\\"commitizen\\\": {\\n    \\\"path\\\": \\\"node_modules/cz-customizable\\\"\\n  } \\n}\\n···\\n```\\n\\n最后在项目根目录下创建 .cz-config.js 文件, 在该文件中配置你想要的模板，如何配置可查阅文档：[传送门](https://github.com/leoforfree/cz-customizable)\\n\\n这里提供一下我的配置文件，可供参考：\\n\\n```js\\n'use strict';\\n\\nmodule.exports = {\\n  types: [\\n    {\\n      value: 'feat',\\n      name: '✨  feat:     新功能/特性',\\n    },\\n    {\\n      value: 'fix',\\n      name: '🐞  fix:      修复 BUG',\\n    },\\n    {\\n      value: 'refactor',\\n      name: '🛠   refactor: 代码重构',\\n    },\\n    {\\n      value: 'docs',\\n      name: '📚  docs:     只涉及文档变更',\\n    },\\n    {\\n      value: 'test',\\n      name: '🏁  test:     测试用例变更',\\n    },\\n    {\\n      value: 'chore',\\n      name: '🗯   chore:    只涉及依赖更新或构建工具配置的修改',\\n    },\\n    {\\n      value: 'style',\\n      name: '💅  style:    代码格式变更、样式变更等',\\n    },\\n    {\\n      value: 'revert',\\n      name: '⏪  revert:   撤销 commit 提交',\\n    },\\n  ],\\n  // 交互提示信息\\n  messages: {\\n    type: '确保本次提交遵循：前端代码提交规范！\\\\n选择你要提交的类型：',\\n    scope: '\\\\n选择一个 scope（可选）：',\\n    // 选择 scope: custom 时会出下面的提示\\n    customScope: '请输入自定义的 scope：',\\n    subject: '填写简短精炼的变更描述：\\\\n',\\n    body: '填写更加详细的变更描述（可选）。使用 \\\"|\\\" 换行：\\\\n',\\n    breaking: '列举非兼容性重大的变更（可选）：\\\\n',\\n    footer: '列举出所有变更的 ISSUES CLOSED（可选）。 例如: #31, #34：\\\\n',\\n    confirmCommit: '确认提交？',\\n  },\\n  scopes: [],\\n  allowCustomScopes: true,\\n  skipQuestions: ['body', 'breaking', 'footer'],\\n};\\n```\\n\\n改完之后，重新执行 `yarn commit` ，效果图如下：\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d5606d1c6164764bfd6a38fa1757bb8~tplv-k3u1fbpfcp-watermark.image?)\\n\\n### 规范校验工具\\n\\n`commitlint`: 可以帮助咱们校验 commit 信息, 如果我们提交的 commit 信息不符合指向的规范, 直接拒绝提交, 就是这么粗暴。\\n\\n`@commitlint/config-conventional`：为 commitlint 量身定制的校验配置，该配置同样符合 [AngularJS规范](https://docs.google.com/document/d/1QrDFcIiPjSLDn3EL15IJygNPiHORgU1_OOAqWjiDU5Y/edit#heading=h.greljkmo14y0)\\n\\n首先安装这两个家伙：\\n\\n```\\nyarn add @commitlint/config-conventional @commitlint/cli -D\\n```\\n\\n然后在 package.json 文件中添加如下配置：\\n\\n```json\\n···\\n\\\"commitlint\\\": {\\n  \\\"extends\\\": [\\n    \\\"@commitlint/config-conventional\\\"\\n  ]\\n}\\n···\\n```\\n\\n如果不想改 package.json 文件，在项目根目录新建 `.commitlintrc.js` 配置文件也是可以的，文件内容如下：\\n\\n```\\nmodule.exports = { \\n  extends: ['@commitlint/config-conventional'] \\n}\\n```\\n\\n校验工具安装完了并且已经配置好了，是不是意味着可以正常使用了？咱们来输入一些不规范的提交信息试试看：\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa504bc961ee4af99f027db833dad660~tplv-k3u1fbpfcp-watermark.image?)\\n\\n可以看到，还是可以正常提交，难道是配置没生效？还是安装失败了？其实是因为没有触发校验机制。那咱们怎么触发呢？在什么时机触发呢？\\n\\n由于 git 提供了`hook`机制，所以咱们可以在 commit-msg 阶段进行提交信息的校验，这里就需要请出 `Husky` 了。\\n\\n首先，安装 `Husky`：\\n\\n```\\nyarn add husky -D         \\n```\\n\\n同样的，需要在 package.json 文件中添加如下配置：\\n\\n```\\n···\\n\\\"husky\\\": {\\n  \\\"hooks\\\": {\\n    \\\"commit-msg\\\": \\\"commitlint -e $HUSKY_GIT_PARAMS\\\"\\n  }\\n}\\n···\\n```\\n\\n当然，如果你还是不想改 package.json 文件，在项目根目录新建 `.huskyrc` 配置文件也是可以的，文件内容如下：\\n\\n```\\n{\\n  \\\"hooks\\\": {\\n    \\\"commit-msg\\\": \\\"commitlint -e $HUSKY_GIT_PARAMS\\\"\\n  }\\n}\\n```\\n\\n接下来咱们还需要执行以下命令，在项目根目录下生成.husky文件夹：\\n\\n```\\nnpx husky install \\n```\\n\\n最后使用以下命令在 .husky 文件夹中创建 commit-message hook 执行校验脚本：\\n\\n```\\nnpx husky add .husky/commit-msg 'npx --no-install commitlint --edit \\\"$1\\\"'\\n```\\n\\n可以看到 .husky 目录已经生成了：\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0608542cdae148dea9d41b4c546c5d86~tplv-k3u1fbpfcp-watermark.image?)\\n\\n那现在是不是意味着成功了呢？再试试不就知道了，随便输入不规范的提交信息：\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/deec9c2a045c4437a3b5bd2cb7451ec6~tplv-k3u1fbpfcp-watermark.image?)\\n\\n完美，成功拦截！再来试试输入规范的提交信息：\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ef3f631059b4551b91a0201d04aac35~tplv-k3u1fbpfcp-watermark.image?)\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eef992abddf445c89cf6f2320cdb4679~tplv-k3u1fbpfcp-watermark.image?)\\n\\n# 总结\\n\\n看到这里，相信大家都学会了如何优雅的提交代码，下一篇咱们来看看如何自动生成changelog。\\n\\n对此系列感兴趣的，不妨一键三连（点赞 + 关注 + 收藏），方便跟进后续文章。\\n\\n欢迎大家在评论区留下宝贵的建议！\\n\\n# 本系列往期文章\\n\\n- [组件库从开发到维护全链路讲解（一）基础框架的搭建](https://juejin.cn/post/7189065824504643621)\\n\\n- [组件库从开发到维护全链路讲解（二）日历组件的核心逻辑与设计](https://juejin.cn/post/7189796735274156069)\\n\\n- [组件库从开发到维护全链路讲解（三）小型组件换肤的最佳实践](https://juejin.cn/post/7190563104990691389)\\n\\n- [组件库从开发到维护全链路讲解（四）覆盖单元测试的最佳实践](https://juejin.cn/post/7193857337059835961)\\n\\n\\n**开启掘金成长之旅！这是我参与「掘金日新计划 · 2 月更文挑战」的第 1 天，[点击查看活动详情](https://juejin.cn/post/7194721470063312933 \\\"https://juejin.cn/post/7194721470063312933\\\")”**",
        "tags": [
            "前端",
            "JavaScript",
            "掘金·日新计划"
        ]
    },
    {
        "article_id": "7161292246526984228",
        "cover_image": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f22a0a6b5f524f159c6e81cb9e39e965~tplv-k3u1fbpfcp-watermark.image?",
        "title": "2022年我的面试万字总结（Node、webpack、性能优化）",
        "brief": "又到了金九银十季，最近我也是奔波于各种面试。我自己总结整理了很多方向的前端面试题。把这些题目总结分享给大家，也祝正在面试的朋友们能够拿到满意的offer。",
        "user_name": "逍丶",
        "view_count": 8123,
        "collect_count": 442,
        "comment_count": 15,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/a87f08adcd0dad907726396180915552~300x300.image",
        "category": "前端",
        "content": "\\n# 往期文章\\n（1）[ 2022年我的面试万字总结（浏览器网络篇）](https://juejin.cn/post/7149438206419664927)\\n\\n（2）[ 2022年我的面试万字总结（CSS篇）](https://juejin.cn/post/7149716216167268366)\\n\\n（3）[  2022年我的面试万字总结（HTML篇）](https://juejin.cn/post/7150109570609152014)\\n\\n（4）[ 2022年我的面试万字总结（JS篇上） ](https://juejin.cn/post/7150462512817782815)\\n\\n（5）[ 2022年我的面试万字总结（JS篇下）](https://juejin.cn/editor/drafts/7150847615263834119)\\n\\n （6） [2022年我的面试万字总结（代码篇）](https://juejin.cn/post/7151221875224346637)\\n \\n （7） [2022年我的面试万字总结（Vue上）](https://juejin.cn/post/7151597651719356446)\\n \\n  （8）[ 2022年我的面试万字总结（Vue下）](https://juejin.cn/post/7151604799077613599)\\n  \\n  （9）[ 2022年我的面试万字总结（Vue3+TS）](https://juejin.cn/post/7160962909332307981)\\n  \\n（11）[ 2022年我的面试万字总结（小程序、git）](https://juejin.cn/post/7161584249898795045)\\n# 一、Node\\n## 1. Node是什么?\\n\\nNode.js是一个基于 Chrome V8 引擎的**JavaScript运行环境**，这个环境就好比是服务器上的浏览器（虽然不是很恰当），但正是因为有了它才使得 js 变成了一门后台语言。\\n\\n## 2. Node解决了哪些问题?\\n\\nNode在处理高并发,I/O密集场景有明显的性能优势\\n\\n-   高并发,是指在同一时间并发访问服务器\\n-   I/O密集指的是文件操作、网络操作、数据库,相对的有CPU密集,CPU密集指的是逻辑处理运算、压缩、解压、加密、解密\\n\\n> Web主要场景就是接收客户端的请求读取静态资源和渲染界面,所以Node非常适合Web应用的开发。\\n\\n## 3. Node 的应用场景\\n\\n一般来说，node 主要应用于以下几个方面：\\n\\n-   自动化构建等工具\\n-   中间层\\n-   小项目\\n\\n第一点对于前端同学来说应该是重中之重了，什么工程化、自动构建工具就是用 node 写出来的，它是前端的一大分水岭之一\\n\\n## 4. 请介绍一下Node事件循环的流程\\n\\n-   在进程启动时，Node便会创建一个类似于while(true)的循环，每执行一次循环体的过程我们成为Tick。\\n-   每个Tick的过程就是查看是否有事件待处理。如果有就取出事件及其相关的回调函数。然后进入下一个循环，如果不再有事件处理，就退出进程。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/324dacf44f0243c4b85845503f94af74~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n### 4.2 浏览器和 Node.js 中的事件循环机制有什么区别？\\n\\nNode.js中宏任务分成了几种类型，并且放在了不同的task queue(事件队列)里。不同的task queue在执行顺序上也有区别，微任务放在了每个task queue的末尾：\\n\\n-   `setTimeout/setInterval` 属于 timers 类型；\\n-   `setImmediate` 属于 check 类型；\\n-   socket 的 close 事件属于 close callbacks 类型；\\n-   其他 MacroTask 都属于 poll 类型。\\n-   `process.nextTick` 本质上属于 MicroTask，但是它先于所有其他 MicroTask 执行；\\n-   所有 MicroTask 的执行时机在不同类型的 MacroTask 切换后。\\n-   idle/prepare 仅供内部调用，我们可以忽略。\\n-   pending callbacks 不太常见，我们也可以忽略。\\n\\n## 5. 在每个tick的过程中，如何判断是否有事件需要处理呢？\\n\\n-   每个事件循环中有一个或者多个观察者，而判断是否有事件需要处理的过程就是向这些观察者询问是否有要处理的事件。\\n-   在Node中，事件主要来源于网络请求、文件的I/O等，这些事件对应的观察者有文件I/O观察者，网络I/O的观察者。\\n-   事件循环是一个典型的生产者/消费者模型。异步I/O，网络请求等则是事件的生产者，源源不断为Node提供不同类型的事件，这些事件被传递到对应的观察者那里，事件循环则从观察者那里取出事件并处理。\\n-   在windows下，这个循环基于IOCP创建，在*nix下则基于多线程创建\\n\\n## 6. 请描述一下整个异步I/O的流程\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f31bb3ab0e34b0a8fc27d9bf73a91e4~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n## 7. Express\\n\\n### 7.1 Express框架介绍\\n\\n1.Express是NodeJS开发中一个非常重量级的第三方框架，它对于NodeJS服务端就相当于Jquery对于HTML客户端。\\n\\n-   **如果连Express都不会用，基本上都不好意思跟别人说你会NodeJS**\\n\\n2.Express官网是这样介绍自己的:基于 Node.js 平台，快速、开放、极简的 web 开发框架。\\n\\n-   *Express一个非常重要的亮点就是它没有改变nodejs已有的特性，而是在它的基础上进行了拓展*\\n\\n    -   **也就是说，使用Express你既可以使用nodejs原生的任何API，也能使用Express的API**\\n\\n### 7.2 Express三大核心功能\\n\\n-   1.托管静态资源\\n\\n    -   第二天讲的nodejs实现静态服务器功能在express中只需要一行代码\\n\\n-   2.路由\\n\\n    -   express自带路由功能,让Node服务端开发变得极其简单\\n    -   express支持链式语法，可以让代码看起来更加简洁\\n\\n-   ==3.中间件==\\n\\n    -   Express最为核心的技术和思想，万物皆中间件\\n\\n        -   中间件虽然理解起来有点困难，但是使用起来非常方便，类似于`bootstrap插件`.\\n\\n## 8. Node模块化规范\\n\\n### 8.1 什么是模块化? 模块化有什么好处?\\n\\n-   1.什么叫模块化？（模块 == js文件）\\n\\n    -   `一个js文件`可以`引入另一个js文件中的数据`, 这种开发方式就叫做模块化开发\\n\\n-   2.模块化开发好处？\\n\\n    -   （1）将功能分离出来\\n\\n        -   一个js文件只负责处理一个功能，这样做的好处是业务逻辑清晰，便于维护\\n\\n    -   （2）按需导入\\n\\n        -   用到哪一个功能，就导入哪一个js文件。模块化开发是`渐进式框架`的共同特征。\\n\\n    -   （3）避免变量污染\\n\\n        -   一个js文件(模块),都是一个独立的作用域。 互不干扰，不用考虑变量名冲突问题。\\n\\n### 8.2 模块化语法规范介绍\\n\\n任何一个语法，都需要遵循一定的规范。不同的平台需要遵循的规范不同。一般情况下，模块化语法规范主要有三种。\\n\\n-   CommonJS 规范：nodejs 默认支持的\\n\\n    -   文档：<http://javascript.ruanyifeng.com/nodejs/module.html#toc1>\\n\\n-   ES6规范：前端的ES6语法支持的规范\\n\\n    -   文档：<https://es6.ruanyifeng.com/#docs/module>\\n\\n-   CMD 和 AMD 模块化规范 ： ES6语法之前的模块化语法规范，现在已经几乎不用了\\n\\n### 8.3 CommonJS规范实现模块化语法\\n\\n-   CommonJS规范只有两句话\\n\\n    -   1.模块必须要使用 `require()` 导入\\n\\n    -   2.模块必须要使用 `module.exports` 导出\\n\\n        -   这两个语法都是nodejs环境自带的全局语法\\n\\n<!---->\\n\\n-   exports与module.exports区别\\n\\n    -   (1)如果分不清两者区别,就使用 `module.exports`\\n\\n    -   (2)exports不能去修改堆地址，只能往堆地址里面加数据\\n\\n        -   错误写法： exports = { name:'张三' }\\n\\n            -   这样写是修改堆地址\\n\\n        -   正确写法: exports.name = '张三'\\n\\n            -   这样写没有修改堆地址，而是往堆地址中加数据\\n\\n### 8.4 模块缓存机制\\n\\n-   1.当一个模块第一次会加载时，nodejs会执行里面的js代码，并且导出模块\\n-   2.nodejs会将导出的模块放入缓存中\\n-   3.当重复导入一个模块的时候，nodejs会先从缓存中读取模块。 如果缓存中有，就从缓存读取。缓存没有重复步骤1\\n\\n### 8.5 nodejs三种模块及require()加载原理\\n\\n-   1.nodejs有三种模块\\n\\n    -   第一种： 核心模块、内置模块\\n\\n        -   nodejs作者写的，这些模块js文件会随着安装nodejs的时候一起安装。因此我们可以直接使用，而无需下载。\\n\\n            -   例如： fs 、path、http都是核心模块\\n\\n    -   第二种：第三方模块\\n\\n        -   npm官网上面的模块，这些都是大佬写的模块。需要下载后使用\\n\\n            -   例如： express、cors、bod-parser\\n\\n    -   第三种：自定义模块\\n\\n        -   我们自己写的js文件\\n\\n<!---->\\n\\n-   2.require('文件路径')加载原理\\n\\n    -   (1)自定义模块：必须要写文件路径， `require()`会得到这个模块里面的 `module.exports` 对象\\n\\n    -   (2)第三方模块 ：写模块名。 nodejs会自动从你的node_module文件夹里面去找这个模块的名字，然后执行模块里面的`index.js`代码，得到里面的`module.exports`\\n\\n        -   如果当前目录没有module.exports就会从上级目录找，以此类推。一直找到你的磁盘根目录。 还找不到就会报错提示 模块不存在（有点类似于变量作用域就近原则）\\n\\n    -   (3)核心模块：写模块名。 nodejs会自动从你的node安装包路径里面去找。\\n\\n### 8.6 require和import的区别\\n\\n1.  导入`require` 导出 `exports/module.exports` 是 `CommonJS` 的标准，通常适用范围如 `Node.js`\\n0.  import/export`是`ES6` 的标准，通常适用范围如 React\\n0.  `require` 是**赋值过程**并且是**运行时才执行**，也就是***同步加载***\\n0.  `require` 可以理解为一个全局方法，因为它是一个方法所以意味着可以在任何地方执行。\\n0.  `import` 是**解构过程**并且是**编译时执行**，理解为***异步加载***\\n0.  `import` 会提升到整个模块的头部，具有置顶性，但是建议写在文件的顶部。\\n\\n## 9. 说说前端渲染和后端渲染，以及他们的优缺点\\n\\n\\n**前端渲染**\\n\\n指的是后端返回JSON数据，前端利用预先写的html模板，循环读取JSON数据，拼接字符串（ES6的模板字符串特性大大减少了拼接字符串的的成本），并插入页面。\\n\\n**后端渲染**\\n\\n前端请求，后端用后台模板引擎直接生成html，前端接收到数据之后，直接插入页面。\\n\\n**区别**\\n\\n|        | 前端渲染                                                 | 后端渲染                |\\n| ------ | ---------------------------------------------------- | ------------------- |\\n| 页面呈现速度 | 主要受限于带宽和客户端机器的好坏，优化的好，可以逐步动态展开内容，感觉上会更快一点            | 快，受限于用户的带宽          |\\n| 流量消耗   | 多一点点（一个前端框架大概50KB）                                   | 少一点点（可以省去前端框架部分的代码） |\\n| 可维护性   | 好，前后端分离，各施其职，代码一目明了                                  | 差（前后端东西放一起，不利于维护）   |\\n| SEO友好度 | 差，大量使用Ajax，多数浏览器不能抓取Ajax数据                           | 好                   |\\n| 编码效率   | 高，前后端各自只做自己擅长的东西，后端最后只输出接口，不用管页面呈现，只要前后端人员能力不错，效率不会低 | 低（这个跟不同的团队不同，可能不对）  |\\n\\n# 二、性能优化\\n## 2. 什么是CND\\n\\n### 2.1 CDN的概念\\n\\nCDN（Content Delivery Network，**内容分发网络**）**是指一种通过互联网互相连接的电脑网络系统**，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、视频、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户。\\n\\n### 2.2 CDN的作用\\n\\nCDN一般会用来托管Web资源（包括文本、图片和脚本等），可供下载的资源（媒体文件、软件、文档等），应用程序（门户网站等）。**使用CDN来加速这些资源的访问。**\\n\\n### 2.3 CDN的使用场景\\n\\n**使用第三方的CDN服务：** 如果想要开源一些项目，可以使用第三方的CDN服务\\n\\n**使用CDN进行静态资源的缓存：** 将自己网站的静态资源放在CDN上，比如js、css、图片等。可以将整个项目放在CDN上，完成一键部署。\\n\\n**直播传送：** 直播本质上是使用流媒体进行传送，CDN也是支持流媒体传送的，所以直播完全可以使用CDN来提高访问速度。CDN在处理流媒体的时候与处理普通静态文件有所不同，普通文件如果在边缘节点没有找到的话，就会去上一层接着寻找，但是流媒体本身数据量就非常大，如果使用回源的方式，必然会带来性能问题，所以流媒体一般采用的都是主动推送的方式来进行。\\n\\n## 3.什么是 懒加载(图片)\\n\\n### 3.1 懒加载的概念\\n\\n懒加载也叫做延迟加载、按需加载，指的是在长网页中延迟加载图片数据，是一种较好的网页性能优化的方式。在比较长的网页或应用中，如果图片很多，所有的图片都被加载出来，而用户只能看到可视窗口的那一部分图片数据，这样就浪费了性能。\\n\\n如果使用图片的懒加载就可以解决以上问题。在滚动屏幕之前，可视化区域之外的图片不会进行加载，在滚动屏幕时才加载。这样使得网页的加载速度更快，减少了服务器的负载。懒加载适用于图片较多，页面列表较长（长列表）的场景中。\\n\\n### 3.2 懒加载的特点\\n\\n**减少无用资源的加载**：使用懒加载明显减少了服务器的压力和流量，同时也减小了浏览器的负担。\\n\\n**提升用户体验**: 如果同时加载较多图片，可能需要等待的时间较长，这样影响了用户体验，而使用懒加载就能大大的提高用户体验。\\n\\n**防止加载过多图片而影响其他资源文件的加载** ：会影响网站应用的正常使用。\\n\\n### 3.3 懒加载的实现原理\\n\\n图片的加载是由`src`引起的，当对`src`赋值时，浏览器就会请求图片资源。根据这个原理，我们使用HTML5 的`data-xxx`属性来储存图片的路径，在需要加载图片的时候，将`data-xxx`中图片的路径赋值给`src`，这样就实现了图片的按需加载，即懒加载。\\n\\n注意：`data-xxx` 中的`xxx`可以自定义，这里我们使用`data-src`来定义。\\n\\n懒加载的实现重点在于确定用户需要加载哪张图片，在浏览器中，可视区域内的资源就是用户需要的资源。所以当图片出现在可视区域时，获取图片的真实地址并赋值给图片即可。\\n\\n#### 3.32 Vue3实现图片懒加载\\n\\n导入vueuse插件，使用vueuse封装的useIntersectionObserver监听对应的DOM元素，通过里面的isIntersecting属性的布尔值判断来设置img的src\\n\\n可以封装一个v-lazy的自定义指令来控制img的src\\n\\n```\\napp.directive('lazy', {\\n      mounted: (el: HTMLImageElement, { value }) => {  \\n            // el:选中的元素,value:传过来的属性,这里是图片地址\\n        const { stop } = useIntersectionObserver(el, ([{ isIntersecting }]) => {\\n          if (isIntersecting) { // 判断元素是否在可视区域\\n            // 满足条件就停止监听\\n            stop()\\n            // 给el元素设置src属性\\n            el.src = value\\n            el.onerror = () => {\\n              // 如果图片加载失败就显示默认图片\\n              el.src = defaultImg  // 默认图片需要导入进来,不能直接写路径\\n            }\\n          }\\n        })\\n      }\\n    })\\n```\\n\\n#### 3.33 列表数据懒加载 (利用hooks抽取)\\n\\n在hooks里封装通用的数据懒加载api\\n\\n```\\nexport function useLazyData(callBack: () => void) {\\n  // 通过 ref 获得组件实例\\n  const target = ref(null)\\n  const { stop } = useIntersectionObserver(\\n    // target这个参数是观察的目标dom容器，必须是dom容器，而且是vue3.0方式绑定的dom对象\\n    target,\\n    // isIntersecting 是否进入可视区域，true是进入 false是移出\\n    // observerElement 被观察的dom\\n    ([{ isIntersecting }]) => {\\n      // 在此处可根据isIntersecting来判断，然后做业务\\n      if (isIntersecting) {\\n        stop()\\n        callBack()\\n      }\\n    }\\n  )\\n  return target  // 将响应对象作为返回值传递\\n}\\n```\\n\\n在组件中使用\\n\\n```\\nimport useStore from '@/store'\\nimport { useLazyData } from '@/utils/hooks';\\nconst { home } = useStore()\\nconst target = useLazyData(() => home.getHotList())\\n```\\n\\n### 3.4 懒加载与预加载的区别\\n\\n这两种方式都是提高网页性能的方式，两者主要区别是一个是提前加载，一个是迟缓甚至不加载。懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。\\n\\n-   **懒加载也叫延迟加载，指的是在长网页中延迟加载图片的时机，当用户需要访问时，再去加载**，这样可以提高网站的首屏加载速度，提升用户的体验，并且可以减少服务器的压力。它适用于图片很多，页面很长的电商网站的场景。\\n-   **预加载指的是将所需的资源提前请求加载到本地，这样后面在需要用到时就直接从缓存取资源。** 通过预加载能够减少用户的等待时间，提高用户的体验。我了解的预加载的最常用的方式是使用 js 中的 image 对象，通过为 image 对象来设置 scr 属性，来实现图片的预加载。\\n\\n## 4. 什么是回流(重排)与重绘\\n\\n### 4.1 什么是回流(重排)，哪些操作会导致回流\\n\\n当渲染树中部分或者全部元素的尺寸、结构或者属性发生变化时，浏览器会重新渲染部分或者全部文档的过程就称为**回流**。\\n\\n下面这些操作会导致回流：\\n\\n-   页面的首次渲染\\n-   浏览器的窗口大小发生变化\\n-   元素的内容发生变化\\n-   元素的尺寸或者位置发生变化\\n-   元素的字体大小发生变化\\n-   激活CSS伪类\\n-   查询某些属性或者调用某些方法\\n-   添加或者删除可见的DOM元素\\n\\n在触发回流（重排）的时候，由于浏览器渲染页面是基于流式布局的，所以当触发回流时，会导致周围的DOM元素重新排列，它的影响范围有两种：\\n\\n-   全局范围：从根节点开始，对整个渲染树进行重新布局\\n-   局部范围：对渲染树的某部分或者一个渲染对象进行重新布局\\n\\n### 4.2 什么是重绘，哪些操作会导致重绘\\n\\n当页面中某些元素的样式发生变化，但是不会影响其在文档流中的位置时，浏览器就会对元素进行重新绘制，这个过程就是**重绘**。\\n\\n下面这些操作会导致重绘：\\n\\n-   color、background 相关属性：background-color、background-image 等\\n-   outline 相关属性：outline-color、outline-width 、text-decoration\\n-   border-radius、visibility、box-shadow\\n\\n注意： **当触发回流时，一定会触发重绘，但是重绘不一定会引发回流。**\\n\\n### 4.3 如何避免回流与重绘？\\n\\n**减少回流与重绘的措施：**\\n\\n-   操作DOM时，尽量在低层级的DOM节点进行操作\\n-   不要使用`table`布局， 一个小的改动可能会使整个`table`进行重新布局\\n-   使用CSS的表达式\\n-   不要频繁操作元素的样式，对于静态页面，可以修改类名，而不是样式。\\n-   使用absolute或者fixed，使元素脱离文档流，这样他们发生变化就不会影响其他元素\\n-   避免频繁操作DOM，可以创建一个文档片段`documentFragment`，在它上面应用所有DOM操作，最后再把它添加到文档中\\n-   将元素先设置`display: none`，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。\\n-   将DOM的多个读操作（或者写操作）放在一起，而不是读写操作穿插着写。这得益于**浏览器的渲染队列机制**。\\n\\n#### 4.4 浏览器的渲染队列\\n\\n浏览器针对页面的回流与重绘，进行了自身的优化——**渲染队列**\\n\\n**浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批处理。这样就会让多次的回流、重绘变成一次回流重绘。**\\n\\n### 4.5 如何优化动画？\\n\\n对于如何优化动画，我们知道，一般情况下，动画需要频繁的操作DOM，就就会导致页面的性能问题，我们可以将动画的`position`属性设置为`absolute`或者`fixed`，将动画脱离文档流，这样他的回流就不会影响到页面了。\\n\\n### 4.6 documentFragment (文档碎片)是什么？用它跟直接操作 DOM 的区别是什么？\\n\\n当我们把一个 DocumentFragment 节点插入文档树时，插入的不是 DocumentFragment 自身，而是它的所有子孙节点。在频繁的DOM操作时，我们就可以将DOM元素插入DocumentFragment，之后一次性的将所有的子孙节点插入文档中。DocumentFragment不是真实 DOM 树的一部分，它的变化**不会触发 DOM 树的重新渲染**，这样就**大大提高了页面的性能**。\\n\\n##### 假如有 10000 个元素需要添加到页面上，你觉得怎么操作性能最好（考察`文档碎片`）\\n\\n```\\n<script>\\n     /* console.time('耗时')\\n    for (let i = 1; i <= 1000; i++) {\\n      document.body.innerHTML = document.body.innerHTML + `<div>${i}</div>`\\n    }\\n    console.timeEnd('耗时') // 1586.053955078125 ms */\\n​\\n    /* console.time('耗时')\\n    let str = ''\\n    for (let i = 1; i <= 1000; i++) {\\n      str += `<div>${i}</div>`\\n    }\\n    document.body.innerHTML = str\\n    console.timeEnd('耗时') // 2.5810546875 ms */\\n​\\n    /* console.time('耗时')\\n    const arr = []\\n    for (let i = 1; i <= 1000; i++) {\\n      arr.push(`<div>${i}</div>`)\\n    }\\n    document.body.innerHTML = arr.join('')\\n    console.timeEnd('耗时') // 2.883056640625 ms */\\n​\\n    /* console.time('耗时')\\n    for (let i = 1; i <= 1000; i++) {\\n      const oDiv = document.createElement('div')\\n      // 更灵活\\n      oDiv.innerHTML = i\\n      oDiv.onclick = function () { }\\n      oDiv.style.backgroundColor = 'red'\\n      document.body.appendChild(oDiv)\\n    }\\n    console.timeEnd('耗时') // 7.409912109375 ms */ \\n​\\n    console.time('耗时')\\n    // 篮子，“文档碎片”\\n    const oFrag = document.createDocumentFragment()\\n    for (let i = 1; i <= 1000; i++) {\\n      const oDiv = document.createElement('div')\\n      oDiv.innerHTML = i\\n      oFrag.appendChild(oDiv)\\n    }\\n    document.body.appendChild(oFrag)\\n    console.timeEnd('耗时') // 13.442138671875 ms\\n</script>\\n```\\n\\n## 5. 什么是节流与防抖\\n\\n### 5.1 对节流与防抖的理解\\n\\n-   函数防抖是指**事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。** 这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。\\n-   函数节流是指规定一个单位时间，**在这个单位时间内，只能有一次触发事件的回调函数执行**，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。\\n\\n### 5.2 适用场景\\n\\n**防抖函数的应用场景：**\\n\\n-   按钮提交场景：防⽌多次提交按钮，**只执⾏最后提交的⼀次**\\n-   服务端验证场景：表单验证需要服务端配合，只执⾏⼀段连续的输⼊事件的最后⼀次，还有搜索联想词功能类似⽣存环境请⽤lodash.debounce\\n\\n**节流函数的适⽤场景：**\\n\\n-   拖拽场景：**固定时间内只执⾏⼀次**，防⽌超⾼频次触发位置变动\\n-   缩放场景：监控浏览器resize\\n-   动画场景：避免短时间内多次触发动画引起性能问题\\n\\n### 5.3 代码实现\\n\\n```\\n// //防抖\\nfunction debounce(fn, date) {\\n  let timer  //声明接收定时器的变量\\n  return function (...arg) {  // 获取参数\\n    timer && clearTimeout(timer)  // 清空定时器\\n    timer = setTimeout(() => {  //  生成新的定时器\\n      //因为箭头函数里的this指向上层作用域的this,所以这里可以直接用this，不需要声明其他的变量来接收\\n      fn.apply(this, arg) // fn()\\n    }, date)\\n  }\\n}\\n//--------------------------------\\n// 节流\\nfunction debounce(fn, data) {\\n  let timer = +new Date()  // 声明初始时间\\n  return function (...arg) { // 获取参数\\n    let newTimer = +new Date()  // 获取触发事件的时间\\n    if (newTimer - timer >= data) {  // 时间判断,是否满足条件\\n      fn.apply(this, arg)  // 调用需要执行的函数,修改this值,并且传入参数\\n      timer = +new Date() // 重置初始时间\\n    }\\n  }\\n}\\n// --------------------------------\\nbox.addEventListener('click', debounce(function (e) {\\n  if (e.target.tagName === 'BUTTON') {\\n    console.log(111);\\n  }\\n}, 2000))\\n```\\n\\n## 6. 如何对项目中的图片进行优化？\\n\\n1.  不用图片。很多时候会使用到很多修饰类图片，其实这类修饰图片完全可以用 CSS 去代替。\\n\\n0.  对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。一般图片都用 CDN 加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片。\\n\\n0.  小图使用 base64 格式\\n\\n0.  将多个图标文件整合到一张图片中（雪碧图）\\n\\n0.  选择正确的图片格式：\\n\\n    -   对于能够显示 WebP 格式的浏览器尽量使用 WebP 格式。因为 WebP 格式具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，缺点就是兼容性并不好\\n    -   小图使用 PNG，其实对于大部分图标这类图片，完全可以使用 SVG 代替\\n    -   照片使用 JPEG\\n\\n## 7. webpack知识总结\\n\\n### 7.1.什么是webpack\\n\\n-   *静态模块打包工具*\\n\\n### 7.2.webpack作用\\n\\n-   分析、压缩、打包代码\\n\\n### 7.3.webpack好处\\n\\n-   减少文件体积、减少文件数量\\n-   提高网页加载速度\\n\\n### 7.4.webpack工作流程\\n\\n-   1.初始化参数：从配置文件读取与合并参数，得出最终的参数\\n-   2.开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，开始执行编译\\n-   3.确定入口：根据配置中的 entry 找出所有的入口文件\\n-   4.编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理\\n-   5.完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系\\n-   6.输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会\\n-   7。输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。\\n\\n### 7.5.什么是loader，什么是Plugin\\n\\n-   `loader`直译为\\\"加载器\\\"。webpack将一切文件视为模块，但是webpack原生是只能解析js文件，如果想将其他文件也打包的话，就会用到loader。 所以loader的作用是让webpack拥有了加载和解析非JavaScript文件的能力。\\n\\n    -   说人话： loader就是用于解析文件的 （类似War3的游戏地图）\\n\\n        -   例如：css-loader 、style-loader、image-loader\\n\\n-   `Plugin`直译为\\\"插件\\\"。Plugin可以扩展webpack的功能，让webpack具有更多的灵活性。 在 webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 webpack 提供的 API 改变输出结果。\\n\\n    -   说人话：插件就是拓展功能的 （类似游戏的作弊器）\\n\\n        -   例如：html-webpack-plugin,\\n\\n-   个人见解： 广义来说,loader属于插件的一种。\\n\\n    -   插件范围很广 ： 只要不是webapck原生的功能，都可以理解为插件\\n    -   loader ： 一种特殊的插件，主要是用在webpack编译环节，帮我们编译各种文件的\\n\\n### 7.6 有哪些常见的Loader？你用过哪些Loader？\\n\\n`raw-loader`：加载文件原始内容（utf-8）\\n\\n`file-loader`：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件 (处理图片和字体)\\n\\n`url-loader`：与 file-loader 类似，区别是用户可以设置一个阈值，大于阈值会交给 file-loader 处理，小于阈值时返回文件 base64 形式编码 (处理图片和字体)\\n\\n`source-map-loader`：加载额外的 Source Map 文件，以方便断点调试\\n\\n`svg-inline-loader`：将压缩后的 SVG 内容注入代码中\\n\\n`image-loader`：加载并且压缩图片文件\\n\\n`json-loader` 加载 JSON 文件（默认包含）\\n\\n`handlebars-loader`: 将 Handlebars 模版编译成函数并返回\\n\\n`babel-loader`：把 ES6 转换成 ES5\\n\\n`ts-loader`: 将 TypeScript 转换成 JavaScript\\n\\n`awesome-typescript-loader`：将 TypeScript 转换成 JavaScript，性能优于 ts-loader\\n\\n`sass-loader`：将SCSS/SASS代码转换成CSS\\n\\n`css-loader`：加载 CSS，支持模块化、压缩、文件导入等特性\\n\\n`style-loader`：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS\\n\\n`postcss-loader`：扩展 CSS 语法，使用下一代 CSS，可以配合 autoprefixer 插件自动补齐 CSS3 前缀\\n\\n`eslint-loader`：通过 ESLint 检查 JavaScript 代码\\n\\n`tslint-loader`：通过 TSLint检查 TypeScript 代码\\n\\n### 7.7 有哪些常见的Plugin？你用过哪些Plugin？\\n\\n`define-plugin`：定义环境变量 (Webpack4 之后指定 mode 会自动配置)\\n\\n`ignore-plugin`：忽略部分文件\\n\\n`html-webpack-plugin`：简化 HTML 文件创建 (依赖于 html-loader)\\n\\n`web-webpack-plugin`：可方便地为单页应用输出 HTML，比 html-webpack-plugin 好用\\n\\n`uglifyjs-webpack-plugin`：不支持 ES6 压缩 (Webpack4 以前)\\n\\n`terser-webpack-plugin`: 支持压缩 ES6 (Webpack4)\\n\\n`webpack-parallel-uglify-plugin`: 多进程执行代码压缩，提升构建速度\\n\\n`mini-css-extract-plugin`: 分离样式文件，CSS 提取为独立文件，支持按需加载 (替代extract-text-webpack-plugin)\\n\\n`serviceworker-webpack-plugin`：为网页应用增加离线缓存功能\\n\\n`clean-webpack-plugin`: 目录清理\\n\\n`ModuleConcatenationPlugin`: 开启 Scope Hoisting\\n\\n`speed-measure-webpack-plugin`: 可以看到每个 Loader 和 Plugin 执行耗时 (整个打包耗时、每个 Plugin 和 Loader 耗时)\\n\\n`webpack-bundle-analyzer`: 可视化 Webpack 输出文件的体积 (业务组件、依赖第三方模块)\\n\\n### 7.8 那你再说一说Loader和Plugin的区别？\\n\\n`Loader` 本质就是一个函数，在该函数中对接收到的内容进行转换，返回转换后的结果。 因为 Webpack 只认识 JavaScript，所以 Loader 就成了翻译官，对其他类型的资源进行转译的预处理工作。\\n\\n`Plugin` 就是插件，基于事件流框架 `Tapable`，插件可以扩展 Webpack 的功能，在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。\\n\\n`Loader` 在 module.rules 中配置，作为模块的解析规则，类型为数组。每一项都是一个 Object，内部包含了 test(类型文件)、loader、options (参数)等属性。\\n\\n`Plugin` 在 plugins 中单独配置，类型为数组，每一项是一个 Plugin 的实例，参数都通过构造函数传入\\n\\n### 7.9 说一下 Webpack 的热更新原理吧\\n\\n`Webpack` 的热更新又称热替换（`Hot Module Replacement`），缩写为 `HMR`。 这个机制可以做到不用刷新浏览器而将新变更的模块替换掉旧的模块。\\n\\nHMR的核心就是客户端从服务端拉去更新后的文件，准确的说是 chunk diff (chunk 需要更新的部分)，实际上 WDS 与浏览器之间维护了一个 `Websocket`，当本地资源发生变化时，WDS 会向浏览器推送更新，并带上构建时的 hash，让客户端与上一次资源进行对比。客户端对比出差异后会向 WDS 发起 `Ajax` 请求来获取更改内容(文件列表、hash)，这样客户端就可以再借助这些信息继续向 WDS 发起 `jsonp` 请求获取该chunk的增量更新。\\n\\n后续的部分(拿到增量更新之后如何处理？哪些状态该保留？哪些又需要更新？)由 `HotModulePlugin` 来完成，提供了相关 API 以供开发者针对自身场景进行处理，像`react-hot-loader` 和 `vue-loader` 都是借助这些 API 实现 HMR。\\n\\n### 7.10 代码分割的本质是什么？有什么意义呢？\\n\\n代码分割的本质其实就是在`源代码直接上线`和`打包成唯一脚本main.bundle.js`这两种极端方案之间的一种更适合实际场景的中间状态。\\n\\n**「用可接受的服务器性能压力增加来换取更好的用户体验。」**\\n\\n源代码直接上线：虽然过程可控，但是http请求多，性能开销大。\\n\\n打包成唯一脚本：一把梭完自己爽，服务器压力小，但是页面空白期长，用户体验不好。\\n\\n## 8. Webpack优化\\n\\n### 8.1 如何提⾼**webpack**的打包**速度**?\\n\\n**（1）优化 Loader**\\n\\n对于 Loader 来说，影响打包效率首当其冲必属 Babel 了。因为 Babel 会将代码转为字符串生成 AST，然后对 AST 继续进行转变最后再生成新的代码，项目越大，**转换代码越多，效率就越低**。\\n\\n**（2）HappyPack**\\n\\n受限于 Node 是单线程运行的，所以 Webpack 在打包的过程中也是单线程的，特别是在执行 Loader 的时候，长时间编译的任务很多，这样就会导致等待的情况。\\n\\n**HappyPack 可以将 Loader 的同步执行转换为并行的**，这样就能充分利用系统资源来加快打包效率了\\n\\n**（3）DllPlugin**\\n\\n**DllPlugin 可以将特定的类库提前打包然后引入**。这种方式可以极大的减少打包类库的次数，只有当类库更新版本才有需要重新打包，并且也实现了将公共代码抽离成单独文件的优化方案。\\n\\n**（4）代码压缩**\\n\\n在 Webpack3 中，一般使用 `UglifyJS` 来压缩代码，但是这个是单线程运行的，为了加快效率，可以使用 `webpack-parallel-uglify-plugin` 来并行运行 `UglifyJS`，从而提高效率。\\n\\n在 Webpack4 中，不需要以上这些操作了，只需要**将 `mode` 设置为 `production`** 就可以默认开启以上功能。代码压缩也是我们必做的性能优化方案，当然我们不止可以压缩 JS 代码，还可以压缩 HTML、CSS 代码，并且在压缩 JS 代码的过程中，我们还可以通过配置实现比如删除 `console.log` 这类代码的功能。\\n\\n### 8.2 如何减少 Webpack 打包**体积**\\n\\n**（1）按需加载**\\n\\n在开发 SPA 项目的时候，项目中都会存在很多路由页面。如果将这些页面全部打包进一个 JS 文件的话，虽然将多个请求合并了，但是同样也加载了很多并不需要的代码，耗费了更长的时间。那么为了首页能更快地呈现给用户，希望首页能加载的文件体积越小越好，**这时候就可以使用按需加载，将每个路由页面单独打包为一个文件**。当然不仅仅路由可以按需加载，对于 `loadash` 这种大型类库同样可以使用这个功能。\\n\\n**（2）Scope Hoisting**\\n\\n**Scope Hoisting 会分析出模块之间的依赖关系，尽可能的把打包出来的模块合并到一个函数中去。**\\n\\n **（3）Tree Shaking**\\n\\n**Tree Shaking 可以实现删除项目中未被引用的代码**。可以通过在启动webpack时追加参数 --optimize-minimize 来实现\\n\\n### 8.3 如何⽤**webpack**来优化前端**性能**？\\n\\n⽤webpack优化前端性能是指优化webpack的输出结果，让打包的最终结果在浏览器运⾏快速⾼效。\\n\\n-   **压缩代码**：删除多余的代码、注释、简化代码的写法等等⽅式。可以利⽤webpack的 UglifyJsPlugin 和 ParallelUglifyPlugin 来压缩JS⽂件， 利⽤ cssnano （css-loader?minimize）来压缩css\\n-   **利⽤CDN加速**: 在构建过程中，将引⽤的静态资源路径修改为CDN上对应的路径。可以利⽤webpack对于 output 参数和各loader的 publicPath 参数来修改资源路径\\n-   **Tree Shaking**: 将代码中永远不会⾛到的⽚段删除掉。可以通过在启动webpack时追加参数 --optimize-minimize 来实现\\n-   **Code Splitting (自动):** 将代码按路由维度或者组件分块(chunk),这样做到按需加载,同时可以充分利⽤浏览器缓存\\n-   **提取公共第三⽅库**: SplitChunksPlugin插件来进⾏公共模块抽取,利⽤浏览器缓存可以⻓期缓存这些⽆需频繁变动的公共代码\\n\\n### 8.4 如何提⾼**webpack**的构建速度？\\n\\n-   多⼊⼝情况下，使⽤ CommonsChunkPlugin 来提取公共代码\\n-   通过 **externals** 配置来提取常⽤库\\n-   利⽤ DllPlugin 和 DllReferencePlugin 预编译资源模块 通过 DllPlugin 来对那些我们引⽤但是绝对不会修改的npm包来进⾏预编译，再通过 DllReferencePlugin 将预编译的模块加载进来。\\n-   使⽤ Happypack 实现多线程加速编译\\n-   使⽤ webpack-uglify-parallel 来提升 uglifyPlugin 的压缩速度。 原理上 webpack-uglify-parallel 采⽤了多核并⾏压缩来提升压缩速度\\n-   使⽤ Tree-shaking 和 Scope Hoisting 来剔除多余代码\\n\\n### 8.5 什么是长缓存？在Webpack中如何做到长缓存优化？\\n\\n1、什么是长缓存 \\n\\n浏览器在用户访问页面的时候，为了加快加载速度，会对用户访问的静态资源进行存储，但是每一次代码升级或者更新，都需要浏览器去下载新的代码，最方便的更新方式就是引入新的文件名称，只下载新的代码块，不加载旧的代码块，这就是长缓存。 \\n\\n2、具体实现 \\n\\n在Webpack中，可以在output给出输出的文件制定chunkhash，并且分离经常更新的代码和框架代码，通NameModulesPlugin或者HashedModulesPlugin使再次打包文件名不变\\n\\n### 8.6 怎么实现Webpack的按需加载\\n\\n在Webpack中，import不仅仅是ES6module的模块导入方式，还是一个类似require的函数，我们可以通过import('module')的方式引入一个模块，import()返回的是一个Promise对象；使用import（）方式就可以实现 Webpack的按需加载\\n\\n### 8.7 什么是神奇注释？\\n\\n在import（）里可以添加一些注释，如定义该chunk的名称，要过滤的文件，指定引入的文件等等，这类带有特殊功能的注释被称为神器注释。\\n\\n## 9. 什么是虚拟列表\\n\\n`虚拟列表`其实是按需显示的一种实现，即**只对`可见区域`进行渲染，对`非可见区域`中的数据不渲染或部分渲染的技术，从而达到极高的渲染性能。**\\n\\n假设有1万条记录需要同时渲染，我们屏幕的`可见区域`的高度为`500px`,而列表项的高度为`50px`，则此时我们在屏幕中最多只能看到10个列表项，那么在首次渲染的时候，我们只需加载10条即可。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b5c02be2a1541e989b41455ba0b9eab~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n### 虚拟列表如何实现\\n\\n虚拟列表的实现，实际上就是在首屏加载的时候，只加载`可视区域`内需要的列表项，当滚动发生时，动态通过计算获得`可视区域`内的列表项，并将`非可视区域`内存在的列表项删除。\\n\\n-   计算当前`可视区域`起始数据索引(`startIndex`)\\n-   计算当前`可视区域`结束数据索引(`endIndex`)\\n-   计算当前`可视区域的`数据，并渲染到页面中\\n-   计算`startIndex`对应的数据在整个列表中的偏移位置`startOffset`并设置到列表上\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/196ce5b45fe9472e8993a3349a78e33f~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n由于只是对`可视区域`内的列表项进行渲染，所以为了保持列表容器的高度并可正常的触发滚动，将Html结构设计成如下结构：\\n\\n```\\n<div class=\\\"infinite-list-container\\\">\\n    <div class=\\\"infinite-list-phantom\\\"></div>\\n    <div class=\\\"infinite-list\\\">\\n      <!-- item-1 -->\\n      <!-- item-2 -->\\n      <!-- ...... -->\\n      <!-- item-n -->\\n    </div>\\n</div>\\n```\\n\\n-   `infinite-list-container` 为`可视区域`的容器\\n-   `infinite-list-phantom` 为容器内的占位，高度为总列表高度，用于形成滚动条\\n-   `infinite-list` 为列表项的`渲染区域`\\n\\n接着，监听`infinite-list-container`的`scroll`事件，获取滚动位置`scrollTop`\\n\\n-   假定`可视区域`高度固定，称之为`screenHeight`\\n-   假定`列表每项`高度固定，称之为`itemSize`\\n-   假定`列表数据`称之为`listData`\\n-   假定`当前滚动位置`称之为`scrollTop`\\n\\n则可推算出：\\n\\n-   列表总高度`listHeight` = listData.length * itemSize\\n-   可显示的列表项数`visibleCount` = Math.ceil(screenHeight / itemSize)\\n-   数据的起始索引`startIndex` = Math.floor(scrollTop / itemSize)\\n-   数据的结束索引`endIndex` = startIndex + visibleCount\\n-   列表显示数据为`visibleData` = listData.slice(startIndex,endIndex)\\n\\n当滚动后，由于`渲染区域`相对于`可视区域`已经发生了偏移，此时我需要获取一个偏移量`startOffset`，通过样式控制将`渲染区域`偏移至`可视区域`中。\\n\\n-   偏移量`startOffset` = scrollTop - (scrollTop % itemSize); 用来做transform的数据\\n\\n### 监听scoll事件的优化\\n\\n我们使用`监听scroll事件`的方式来触发可视区域中数据的更新，当滚动发生后，scroll事件会频繁触发，很多时候会造成`重复计算`的问题，从性能上来说无疑存在浪费的情况。\\n\\n可以使用`IntersectionObserver`替换监听scroll事件，`IntersectionObserver`可以监听目标元素是否出现在可视区域内，在监听的回调事件中执行可视区域数据的更新，并且`IntersectionObserver`的监听回调是异步触发，不随着目标元素的滚动而触发，性能消耗极低。\\n\\n## 10. 前端工程化\\n\\n#### Babel的原理是什么？\\n\\n**Babel 的主要工作是对代码进行转译。** (解决兼容, 解析执行一部分代码)\\n\\n```\\nlet a = 1 + 1    =>  var a = 2\\n```\\n\\n转译分为三阶段：\\n\\n-   解析（Parse），将代码解析⽣成抽象语法树 AST，也就是词法分析与语法分析的过程\\n-   转换（Transform），对语法树进⾏变换方面的⼀系列操作。通过 babel-traverse，进⾏遍历并作添加、更新、删除等操作\\n-   ⽣成（Generate），通过 babel-generator 将变换后的 AST 转换为 JS 代码\\n\\n我们可以通过 AST Explorer 工具来查看 Babel 具体生成的 AST 节点。\\n\\n## 11. 什么是单点登录？\\n\\n单点登录（Single Sign On），简称为 SSO，是目前比较流行的企业业务整合的解决方案之一\\n\\nSSO的定义是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统\\n\\nSSO 一般都需要一个独立的认证中心（passport），子系统的登录均得通过`passport`，子系统本身将不参与登录操作\\n\\n当一个系统成功登录以后，`passport`将会颁发一个令牌给各个子系统，子系统可以拿着令牌会获取各自的受保护资源，为了减少频繁认证，各个子系统在被`passport`授权以后，会建立一个局部会话，在一定时间内可以无需再次向`passport`发起认证\\n\\n## 12. 大文件上传如何做分片上传、断点继传？\\n\\n### 分片上传\\n\\n分片上传，就是将所要上传的文件，按照一定的大小，将整个文件分隔成多个数据块（Part）来进行分片上传\\n\\n如下图\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c63c2f9f5fca4708860bb7df241430a0~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n上传完之后再由服务端对所有上传的文件进行汇总整合成原始的文件\\n\\n大致流程如下：\\n\\n1.  将需要上传的文件按照一定的分割规则，分割成相同大小的数据块；\\n0.  初始化一个分片上传任务，返回本次分片上传唯一标识；\\n0.  然后借助 http 的可并发性，同时上传多个切片\\n0.  发送完成后，服务端根据判断数据上传是否完整，如果完整，则进行数据块合成得到原始文件\\n\\n### 断点续传\\n\\n断点续传指的是在下载或上传时，将下载或上传任务人为的划分为几个部分\\n\\n每一个部分采用一个线程进行上传或下载，如果碰到网络故障，可以从已经上传或下载的部分开始继续上传下载未完成的部分，而没有必要从头开始上传下载。用户可以节省时间，提高速度\\n\\n一般实现方式有两种：\\n\\n-   服务器端返回，告知从哪开始\\n-   浏览器端自行处理\\n\\n上传过程中将文件在服务器写为临时文件，等全部写完了（文件上传完），将此临时文件重命名为正式文件即可\\n\\n如果中途上传中断过，下次上传的时候根据当前临时文件大小，作为在客户端读取文件的偏移量，从此位置继续读取文件数据块，上传到服务器从此偏移量继续写入文件即可\\n\\n**使用场景**\\n\\n-   大文件加速上传：当文件大小超过预期大小时，使用分片上传可实现并行上传多个 Part， 以加快上传速度\\n-   网络环境较差：建议使用分片上传。当出现上传失败的时候，仅需重传失败的Part\\n-   流式上传：可以在需要上传的文件大小还不确定的情况下开始上传。这种场景在视频监控等行业应用中比较常见\\n\\n## 13. npm run dev的时候webpack做了什么事情\\n\\n执行**npm run dev**时候最先执行的**build/dev-server.js**文件，该文件主要完成下面几件事情：\\n\\n1、检查node和npm的**版本**、引入相关**插件**和**配置**\\n\\n2、webpack对源码进行**编译打包**并返回compiler对象\\n\\n3、**创建express服务器**\\n\\n4、**配置开发中间件**（webpack-dev-middleware）和**热重载中间件**（webpack-hot-middleware）\\n\\n5、**挂载代理服务和中间件**\\n\\n6、配置静态资源\\n\\n7、启动服务器监听特定端口（8080）\\n\\n8、自动打开浏览器并打开特定网址（localhost:8080）",
        "tags": [
            "前端",
            "Node.js",
            "Webpack"
        ]
    },
    {
        "article_id": "7184250130004967485",
        "cover_image": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87c46e01a3824e378170681bf5dfc09a~tplv-k3u1fbpfcp-watermark.image?",
        "title": "巧用视觉障眼法，还原 3D 文字特效",
        "brief": "最近群里有这样一个有意思的问题，大家在讨论，使用 CSS 3D 能否实现如下所示的效果： 这里的核心难点在于，如何利用 CSS 实现一个立体的数字？CSS 能做到吗？ 不是特别好实现，但是，如果仅仅只",
        "user_name": "chokcoco",
        "view_count": 7290,
        "collect_count": 40,
        "comment_count": 13,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/d5909b97177d58b77d02a83a620abd18~300x300.image",
        "category": "前端",
        "content": "最近群里有这样一个有意思的问题，大家在讨论，使用 CSS 3D 能否实现如下所示的效果：\\n\\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e7f8ef68b2b429f93186fbf70986ae0~tplv-k3u1fbpfcp-watermark.image?)\\n\\n这里的核心难点在于，如何利用 CSS 实现一个立体的数字？CSS 能做到吗？\\n\\n不是特别好实现，但是，如果仅仅只是在一定角度内，利用视觉障眼法，我们还是可以比较完美的还原上述效果的。\\n\\n## 利用距离、角度及光影构建不一样的 3D 效果\\n\\n这是一种很有意思的技巧，在 [奇思妙想 CSS 3D 动画 | 仅使用 CSS 能制作出多惊艳的动画？](https://github.com/chokcoco/iCSS/issues/132) 我们曾经介绍过，当然，制作的过程需要比较多的调试。\\n\\n合理的利用距离、角度及光影构建出不一样的 3D 效果。看看下面这个例子，只是简单是设置了三层字符，让它们在 Z 轴上相距一定的距离。\\n\\n简单的伪代码如下：\\n\\n```HTML\\n<div>\\n  <span class='C'>C</span>\\n  <span class='S'>S</span>\\n  <span class='S'>S</span>\\n  <span></span>\\n  <span class='3'>3</span>\\n  <span class='D'>D</span>\\n</div>\\n```\\n```CSS\\n$bright : #AFA695;\\n$gold : #867862;\\n$dark : #746853;\\n$duration : 10s;\\ndiv {\\n\\tperspective: 2000px;\\n\\ttransform-style: preserve-3d;\\n\\tanimation: fade $duration infinite;\\n}\\nspan {\\n\\ttransform-style: preserve-3d;\\n\\ttransform: rotateY(25deg);\\n\\tanimation: rotate $duration infinite ease-in;\\n\\t\\n\\t&:after, &:before {\\n\\t\\tcontent: attr(class);\\n\\t\\tcolor: $gold;\\n\\t\\tz-index: -1;\\n\\t\\tanimation: shadow $duration infinite;\\n\\t}\\n\\t&:after{\\n\\t\\ttransform: translateZ(-16px);\\n\\t}\\n\\t&:before {\\n\\t\\ttransform: translateZ(-8px);\\n\\t}\\n}\\n@keyframes fade {\\n\\t// 透明度变化\\n}\\n@keyframes rotate {\\n\\t// 字体旋转\\n}\\n@keyframes shadow {\\n       // 字体颜色变化\\n}\\n```\\n\\n简单捋一下，上述代码的核心就是：\\n\\n1. 父元素、子元素设置 `transform-style: preserve-3d`\\n2. 用 `span` 元素的两个伪元素复制两个相同的字，利用 `translateZ()` 让它们在 Z 轴间隔一定距离\\n3. 添加简单的旋转、透明度、字体颜色变化\\n\\n可以得到这样一种类似电影开片的标题 3D 动画，其实只有 3 层元素，但是由于角度恰当，视觉上的衔接比较完美，看上去就非常的 3D。\\n\\n![22.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9abec5ee9de246b7a601a42a844441d8~tplv-k3u1fbpfcp-watermark.image?)\\n\\n为什么上面说需要合理的利用距离、角度及光影呢？\\n\\n还是同一个动画效果，如果动画的初始旋转角度设置的稍微大一点，整个效果就会穿帮：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/21e2047401334574a2011cb352130562~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n可以看到，在前几帧，能看出来简单的分层结构。又或者，简单调整一下 `perspective`，设置父容器的 `perspective` 由 `2000px` 改为 `500px`，穿帮效果更为明显：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/229431ac68fd4d8abc9c973910f78bbb~tplv-k3u1fbpfcp-watermark.image?)\\n\\n也就是说，在恰当的距离，合适的角度，我们仅仅通过很少的元素，就能在视觉上形成比较不错的 3D 效果。\\n\\n上述的完整代码，你可以猛击这里：[CSS 灵感 -- 3D 文字出场动画](https://csscoco.com/inspiration/#/./3d/3d-text-debut)\\n\\n基于，这个技巧，我们简单的改造一下，我们首先替换一下文字效果：\\n\\n```HTML\\n<div>\\n  <span class='2'>2</span>\\n  <span class='0'>0</span>\\n  <span class='2'>2</span>\\n  <span class='3'>3</span>\\n</div>\\n```\\n\\n这样，我们就可以得到这样一种效果：\\n\\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e377d52faf764ebda5d7ee157358f19a~tplv-k3u1fbpfcp-watermark.image?)\\n\\nWow，有点那个意思了。接下来，我们需要换上喜庆的文字效果。首先，随便在网上找一找烟花 Gif 图，也许是这样：\\n\\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3aa4c44a1a542e9bde642b22cc20d33~tplv-k3u1fbpfcp-watermark.image?)\\n\\n我们通过 `background-clip: text`，给 3 层文字都加上类似这个效果，核心伪代码如下：\\n\\n```CSS\\nspan {\\n\\tposition: relative;\\n\\ttransform-style: preserve-3d;\\n\\tcolor: transparent;\\n\\tbackground: url(xxx.gif);\\n\\tbackground-clip: text;\\n\\t\\n\\t&:after, &:before {\\n\\t\\tposition: absolute;\\n\\t\\tcontent: attr(class);\\n\\t\\tcolor: transparent;\\n\\t\\tbackground: url(xxx.gif);\\n\\t        background-clip: text;\\n\\t}\\n\\t\\n\\t&:before {\\n\\t\\ttransform: translateZ(-12px);\\n\\t}\\n\\t&:after {\\n\\t\\ttransform: translateZ(-6px);\\n\\t}\\n}\\n```\\n\\n这样，我们就得到了带有烟花效果的文字，以及，一点 3D 效果：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/58837c2d940e4345ba72fed135901c3a~tplv-k3u1fbpfcp-watermark.image?)\\n\\n还剩下最后一步，倒影效果怎么制作呢？\\n\\n方法有很多种，比较便捷的是使用 `webkit-box-reflect` 元素。只需要一行代码即可：\\n\\n```CSS\\ndiv {\\n    //...\\n    -webkit-box-reflect: below -6vw linear-gradient(transparent 20%, rgba(255,255,255, .6));\\n}\\n```\\n\\n当然，如果对两个伪元素生成的字形成的 3D 文字视觉上的厚度不满意，也可以同步去调整两个伪元素的 `transform: translateZ(-6px)` 的值，经过一番调整后，我们就简单的复刻了如题图所示的 2023 3D 文字动画效果：\\n\\n![88.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/034141585d644a75aa8ed3e743eccaf7~tplv-k3u1fbpfcp-watermark.image?)\\n\\n完整的代码，你可以戳这里：\\n\\n[jcode](https://code.juejin.cn/pen/7184248016419684389)\\n\\n[CodePen Demo -- CSS 3D 2023](https://codepen.io/Chokcoco/pen/xxzvgqG)\\n\\n## 最后\\n\\n好了，本文到此结束，非常有意思的一个小技巧，希望本文对你有所帮助 :)\\n\\n更多精彩 CSS 技术文章汇总在我的 [Github -- iCSS](https://github.com/chokcoco/iCSS) ，持续更新，欢迎点个 star 订阅收藏。\\n\\n如果还有什么疑问或者建议，可以多多交流，原创文章，文笔有限，才疏学浅，文中若有不正之处，万望告知。\\n",
        "tags": [
            "前端",
            "CSS",
            "JavaScript"
        ]
    },
    {
        "article_id": "7194993602156560442",
        "cover_image": "https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e148af602f841e5a412536147081de1~tplv-k3u1fbpfcp-watermark.image?",
        "title": "hashmap的一些性能测试, Android 调试实战与原理详解| 酱酱的下午茶第161期",
        "brief": "搞不懂路由跳转？带你了解 history.js 实现原理,如何让Java编译器帮你写代码,基于Raft协议的分布式键值存储服务,Redis缓存的主要异常及解决方案, Android 调试实战与原理详解",
        "user_name": "酱酱们的下午茶",
        "view_count": 356,
        "collect_count": 1,
        "comment_count": 1,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/b72e991ee9b1c9bdca7b2bd4c8dc78a8~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: v-green\\n---\\n\\nHello，又到了每天一次的下午茶时间。酱酱们的下午茶新增优质作者介绍和码上掘金板块，专注于发掘站内优质创作者和优质内容，欢迎大家多提宝贵意见！\\n\\n\\n\\n\\n_本文字数 1800+，阅读时间大约需要 6 分钟。_\\n\\n> - 【掘金酱的下午茶】亮点：\\n> - 浅谈前端框架原理\\n> - 搞不懂路由跳转？带你了解 history.js 实现原理\\n> - TS类型写不好？一起来训练提升吧！\\n> - 如何让Java编译器帮你写代码\\n> - Redis缓存的主要异常及解决方案\\n> - Android Auto 开发指北\\n> - Swift 简单实现<可容纳多个浮窗视图的容器>\\n> - ……\\n>\\n> **筛选规则**：文章发布时间在本期「掘金酱的下午茶」发布时间的 1-3 天内，且符合社区推荐标准，也会同步发布在掘金相关技术社群。\\n\\n## 每日干货｜下午茶\\n\\n**主理人们会对近期（1-3 天）社区深度技术好文进行挖掘和筛选，优质的技术文章有机会出现在下方列表，排名不分先后。**\\n\\n### 『前端』\\n\\n- [浅谈前端框架原理](https://sourl.co/A7ACLW)\\n\\n> 本文讲述了现代前端框架实现原理公式 —— UI = f(state) ，然后讲述了 UI 描述和数据驱动两个部分\\n\\n- [React18 事件系统源码解析 ](https://sourl.co/hEZXnU)\\n\\n> React18 事件系统源码解析\\n\\n- [ 搞不懂路由跳转？带你了解 history.js 实现原理](https://sourl.co/vUjz5M)\\n\\n> 本系列作为 SPA 单页应用相关技术栈的探索与解析，路由管理在单页应用中的重要性不言而喻，而路由的跳转与拦截等操作都依赖于 history API。本系列对 react-router 方案中使用的 history.js 与相关技术进行解析。\\n\\n- [Vite4.0 依赖预构建源码浅析 ](https://nugit.cn/BXsgKP)\\n> Vite4.0 依赖预构建源码浅析 \\n\\n- [TS类型写不好？一起来训练提升吧！ ](https://sourl.co/v2wiDh)\\n\\n> 本篇文章的编写目的是为了提升TS类型的书写质量，高质量的类型可以提高项目的可维护性并避免一些潜在的漏洞;\\n\\n### 『后端』\\n\\n- [关于 sync.Pool 的分析 ](https://sourl.co/wuN5nN)\\n\\n> 关于 sync.Pool 的分析\\n\\n- [ 如何让Java编译器帮你写代码](https://sourl.co/ErPfyu)\\n\\n> 本文结合京东监控埋点场景，对解决样板代码的技术选型方案进行分析，给出最终解决方案后，结合理论和实践进一步展开。通过关注文中的技术分析过程和技术场景，读者可收获一种样板代码思想过程和解决思路，并对Java编译器底层有初步了解。\\n- [基于Raft协议的分布式键值存储服务](https://sourl.co/cfaDWC)\\n\\n> 基于Raft协议的分布式键值存储服务\\n\\n- [hashmap的一些性能测试 ](https://sourl.co/UbDZ8D)\\n\\n> 本文试着从相对少见的一个微小角度来重新审视一下hashmap.\\n\\n\\n- [Redis缓存的主要异常及解决方案 ](https://sourl.co/ECCaFV)\\n\\n> Redis 是当前最流行的 NoSQL数据库。Redis主要用来做缓存使用，在提高数据查询效率、保护数据库等方面起到了关键性的作用，很大程度上提高系统的性能。当然在使用过程中，也会出现一些异常情景，导致Redis失去缓存作用。\\n### 『移动端』\\n\\n- [ Android通知栏增加快捷开关的技术实现](https://sourl.co/DSpSHU)\\n\\n> 我们通常可以在通知栏上看到“飞行模式”、“移动数据”、“屏幕录制”等开关按钮，这些按钮都属于通知栏上的快捷开关，点击快捷开关可以轻易调用某种系统能力或打开某个应用程序的特定页面。那是否可以在通知栏上自定义一个快捷开关呢？答案是可以的，具体是通过TileService的方案实现。   \\n\\n\\n- [Android Auto 开发指北 ](https://sourl.co/FVSWfY)\\n\\n> Android Auto 支持多种类型的应用，包括导航、媒体、消息应用等。\\n\\n- [ Android 调试实战与原理详解](https://sourl.co/NZ5xDC)\\n\\n> 调试功能做为开发的必备神技，熟练掌握后能极大的提高开发效率，再也不必为频繁运行代码而苦恼了。文章同时还会详细介绍调试的原理以及一些调试过程中的常见问题，想知道为什么方法断点那么慢？\\n\\n- [Swift 简单实现<可容纳多个浮窗视图的容器> ](https://sourl.co/C76ptt)\\n\\n> 平时开发经常有一些视图会以浮窗形式呈现，但是如果这些浮窗都放在ViewController的view上，就会很难管理，所以最好使用专门的一个容器来管理这些浮窗。\\n\\n\\n## 趣味码上掘金分享｜下午茶\\n- 码上掘金精选，收集优秀的码上掘金项目，供大家一起学习：https://github.com/akira-cn/jcode-awesome\\n- 码上掘金游戏精选：https://g.jcode.pub/#/7161331535579185191\\n\\n| 作者       | 文章       | 简介                |\\n| ---------------------------------------------------- | ------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------- |\\n| [Mo_Rijiu](https://juejin.cn/user/2626077506929550) | 纯前端实现对话式气泡小说，走出每个人的浪浪山 | 困住我们的不是浪浪山，也不是僵化思维的熊教头，而是随着时间逐渐随波逐流的自己。最后，祝大家新年快乐，兔年兔然暴富，坐享其成！ |\\n\\n[jcode](https://code.juejin.cn/pen/7194244512472891448)\\n\\n| 作者       | 文章       | 简介                |\\n| ---------------------------------------------------- | ------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------- |\\n| [格斗家不爱在外太空沉思](https://juejin.cn/user/3488123150930775) | 「兔了个兔」创意投稿大赛——动若脱兔转换视差效果| 今天为大家制作一个动若脱兔的转换视差效果，当鼠标在目标上左右移动时除了背景产生的位移视差效果外，里面的兔子也会跟着鼠标的位置来作出不同的动作 |\\n\\n[jcode](https://code.juejin.cn/pen/7194629003369447439)\\n\\n## 📖 投稿专区｜下午茶\\n\\n> 大家可以在评论区推荐认为不错的文章，并附上链接和推荐理由，有机会登上下一期。文章创建日期必须在近 1-3 天内；可以推荐自己的文章、也可以推荐他人的文章。\\n\\n## 今日主理人｜下午茶\\n\\n本期每日掘金由 [**北洋**](https://juejin.cn/user/2163480089612877/posts) 负责制作。如有投稿文章，请私信👉 [**北洋**](https://juejin.cn/user/2163480089612877/posts) \\n\\nPS：主理人目前正在招募中，有感兴趣的掘友们可以联系[**Captain**](https://juejin.cn/user/3052665287739005)\\n",
        "tags": [
            "前端",
            "后端",
            "Android"
        ]
    },
    {
        "article_id": "7194340178939347000",
        "cover_image": "https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb8420d695504663bc4d9afb288fd3c4~tplv-k3u1fbpfcp-watermark.image?",
        "title": "【Node.js】ssh2.js+Shell一套组合拳下来，一年要花2080分钟做的工作竟然节省到52分钟～",
        "brief": "前言 这是【Node.js实战】专栏内的第6篇文章，专栏是分享使用Node.js技术编写实用脚本技巧。 专栏现有文章： 仿jsDoc写一个最简单的文档生成 50+行代码搞定一行命令更新Npm包 玩转n",
        "user_name": "凌览",
        "view_count": 1549,
        "collect_count": 23,
        "comment_count": 5,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/ed76ce42eed371494cacbf22bfb1d3c5~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: channing-cyan\\n---\\n## 前言\\n\\n这是[【Node.js实战】](https://juejin.cn/column/7125427604525416455)专栏内的第6篇文章，专栏是分享使用Node.js技术编写实用脚本技巧。\\n\\n专栏现有文章：\\n\\n1.  [仿jsDoc写一个最简单的文档生成](https://juejin.cn/post/7119105933661175838)\\n1.  [50+行代码搞定一行命令更新Npm包](https://juejin.cn/post/7068969844607189029)\\n1.  [玩转nodeJs文件模块](https://juejin.cn/post/7072972877628178440)\\n1.  [Node.js操作Dom ，轻松hold住简单爬虫](https://juejin.cn/post/7184260401139220536)\\n1.  [【Node.js】写一个数据自动整理成表格的脚本](https://juejin.cn/post/7188320646412107835)\\n\\n欢迎读者关注[【Node.js实战】](https://juejin.cn/column/7125427604525416455)专栏。\\n\\n进入了新的一年，团队被分配了新的工作内容——每周巡检。\\n\\n巡检工作简单，但需要人工重复性地登陆远程服务器、输入重复的命令，然后将命令的结果记录下来。每做一次估计花`40`分钟，但要每周做，一年52周，一年下来就要花`40*52=2080`分钟，这仅仅是团队一个人一年要花的时间。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b9cbece5601541958ad598809eb0adbe~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n不能这么玩呀，纯纯工具人，所以我一直在思考如何用程序帮我自动巡检掉。这篇文章的出现，说明我的想法方向是正确的，收益可观一年要花**2080分钟**，被我减到**52 分钟**。\\n\\n如果再扩展程序帮助到团队，这个公式将从`40*52*团队人数`变成`1*52*团队人数`，时间等于金钱。\\n\\n未自动巡检：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a14a84a7548406181296013b71ac1c0~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n手动连接登陆远程服务器，再输入相应的命令获取结果，然后人工依据结果判断是否异常，相当麻烦，而且我要执行的命令不止一条。\\n\\n自动巡检：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bcf6fc32b1f8476889802dcb1dbe05b8~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n运行macOS笔记本创建好的快捷指令，它会自动巡检服务器，并且巡检完成后直接打开巡检结果表格。当然没有macOS依然可以，但就是没有快捷指令这步，需要自己执行程序。\\n\\n完整源码：[blog/ssh](https://github.com/CatsAndMice/blog/tree/main/ssh)\\n\\n## 实现\\n\\n### 实现难点\\n\\n自动化巡检思路简单，思路如下：\\n\\n本地程序连接登陆远程服务器→本地shell命令远程执行→本地程序获取命令结果→结果数据整理成表格\\n\\n实现过程中主要有以下两个难点：\\n\\n-   Node.js本地运行程序如何连接登陆远程服务器\\n-   登陆远程服务器帐号权限不足，在使用`sudo`命令时，如何自动输入密码\\n\\n### 实现细节\\n\\n解决Node.js本地运行程序如何连接登陆远程服务器：\\n\\n社区已有的方案[ssh2](https://github.com/mscdex/ssh2)，它是用纯JavaScript为Node.js编写的SSH2客户端和服务器模块。可以使用它连接到远程服务器，并且[ssh2](https://github.com/mscdex/ssh2)提供了方法可以执行shell命令。\\n\\n[ssh2](https://github.com/mscdex/ssh2)官方案例：\\n\\n```\\n//...\\nconst { Client } = require('ssh2');\\nconst conn = new Client();\\nconn.on('ready', () => {\\n  console.log('Client :: ready');\\n  //执行uptime\\n  conn.exec('uptime', (err, stream) => {\\n    if (err) throw err;\\n    stream.on('close', (code, signal) => {\\n      console.log('Stream :: close :: code: ' + code + ', signal: ' + signal);\\n      conn.end();\\n    }).on('data', (data) => {\\n      //监听数据\\n      console.log('STDOUT: ' + data);\\n    }).stderr.on('data', (data) => {\\n      console.log('STDERR: ' + data);\\n    });\\n  });\\n})\\n//...\\n```\\n\\n官方案例仅执行一条shell命令，当按照顺序依次执行一条以上的命令，官方的这个写法会非常麻烦。例如：首先执行`docker ps -a -q`获取所有docker容器`id`，然后再`docker logs --tail 200 id`\\n\\n```\\n //...\\n // 获取docker所有容器ID\\n conn.exec('docker ps -a -q', (err, stream) => {\\n    if (err) throw err;\\n    stream.on('close', (code, signal) => {\\n      /**\\n        docker ps -a -q命令执行完成\\n        再执行docker logs -f --tail 200 id\\n      */\\n      conn.exec(`docker logs  --tail 200 ${id}`,(err,stream)=>{\\n         if (err) throw err;\\n          stream.on('close', () => {\\n          //如果命令再复杂点，还需要继续这样写下去\\n          \\n          }).on('data', (data) => {\\n            console.log( data);\\n          }).stderr.on('data', (data) => {\\n            console.log(data);\\n          });\\n      })\\n      \\n    }).on('data', (data) => {\\n      console.log('STDOUT: ' + data);\\n    }).stderr.on('data', (data) => {\\n      console.log('STDERR: ' + data);\\n    });\\n  });\\n //...\\n```\\n\\n要想写法整洁点，我们需要再给 `exec`方法用`Promise`包一层。\\n\\n`execFn.js:`\\n\\n```\\nmodule.exports = (c = conn) => {\\n    return (command) => {\\n        return new Promise((resolve, reject) => {\\n            c.exec(command, (err, stream) => {\\n                if (err) {\\n                    reject(err)\\n                    return\\n                }\\n                let result = ''\\n                stream.on('close', () => {\\n                    resolve(String(result))\\n                }).on('data', (data) => {\\n                    //data数据是Buffer类型，需要转化成字符串\\n                    result += data\\n                })\\n            })\\n        })\\n    }\\n}\\n```\\n\\n包一层后，再执行命令：\\n\\n```\\nconst execFn = require('./execFn.js')\\n\\nmodule.exports = (config, conn) => {\\n    conn.on('ready',async ()=>{\\n      const exec = execFn(conn)\\n      const result = await exec('docker ps -a -q')\\n      //...\\n      exec(`docker logs --tail 200 ${id}`)\\n    })\\n    //...\\n}\\n```\\n\\n这样代码会显得更整洁点，使用也更方便。\\n\\n解决登陆远程服务器帐号权限不足，在使用`sudo`命令时，如何自动输入密码，可行方案有两种：\\n\\n-   简单粗暴，直接使用`root`帐号密码进行登陆，这样即可不用考虑如何跳过密码输入的交互\\n-   使用shell管道命令`echo '密码' | sudo -S 命令`\\n\\n`root`帐号密码团队不能给到我，所以我采用了后者来解决。\\n\\nshell实现自动输入密码方法不只有使用管道命令`echo '密码' | sudo -S 命令`，还有其他的方法，但它在自动巡检的场景中是最合适的，它不需要额外要求服务器下载其他工具包，像`expect`指令它就需要安装expect包。巡检不只巡检一台服务器，如果每台都安装expect包，这工作量也烦人。\\n\\n未自动输入密码：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b28201ad07c4ddcbcb19053fb46bd98~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n自动输入密码：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f8714f7b2f984072991e6fcbc5d03d86~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n至此，自动化巡检难点之处已解决，下面的工作就是以执行shell命令返回的结果判断服务器状态是否正常，如：团队巡检文档规定当执行`  docker info |grep -A 5 \\\"WARNING\\\" `时，如果有返回结果则为异常。\\n\\n```\\n//...\\nconst before = `echo \\\"${config.password}\\\" | sudo -S `\\nexec(before + 'docker info |grep -A 5 \\\"WARNING\\\"').then((content) => {\\n    if (content) {\\n        rol[2] = '异常'\\n    }\\n})\\n//...\\n```\\n\\n该部分逻辑以团队巡检文档内容为准，不过多赘述，该部分代码在[sshServer.js](https://github.com/CatsAndMice/blog/blob/main/ssh/sshServer.js)文件。\\n\\n为了做到巡检多台服务器的目的，巡检相关的逻辑代码使用函数进行包裹并从`sshServer.js`文件中导出。\\n\\n`sshServer.js:`\\n\\n```\\nconst execFn = require('./execFn.js')\\n//...\\nmodule.exports = (config, conn) => {\\n    return new Promise((resolve, reject) => {\\n        const exec = execFn(conn)\\n        conn.on('ready', async (err) => {\\n            if (err) reject(err)\\n            console.log('连接成功');\\n            //省略\\n            \\n        }).connect({\\n            ...config,\\n            readyTimeout: 5000\\n        });\\n    })\\n\\n}\\n```\\n\\n所有的服务器帐号密码均放置在`config.json`文件中：\\n\\n```\\n[\\n    {\\n        \\\"host\\\": \\\"xx\\\",\\n        \\\"port\\\": \\\"xx\\\",\\n        \\\"username\\\": \\\"xx\\\",\\n        \\\"password\\\": \\\"xx\\\"\\n    }\\n    //...\\n]\\n```\\n\\n在`config.json`文件涉及到服务器信息需要保密，`config.json`文件不会被提交至仓库。\\n\\n目录结构如下：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/12efd4b3a6dd4856ba28c0be6869a7e8~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n最后，将巡检的结果数据整理成表格，如何将数据导出表格已有对应的文章实现说明[【Node.js】写一个数据自动整理成表格的脚本](https://github.com/CatsAndMice/blog/issues/41)\\n\\n思路是一样的。\\n\\n`index.js`\\n\\n```\\nconst { Client } = require('ssh2');\\nconst configs = require('./config.json')\\nconst sshServer = require('./sshServer.js');\\nconst fs = require('fs');\\nconst path = require('path');\\nconst nodeXlsx = require('node-xlsx')\\n\\nconst promises = []\\n\\n//表格数据 二维数组\\nconst tables = [\\n    ['服务器ip', 'docker是否正常运行', 'docker远程访问', 'Docker日志是否有报错信息']\\n]\\n\\nconfigs.forEach((config) => {\\n    const conn = new Client();\\n    promises.push(sshServer(config, conn))\\n})\\n\\nPromise.all(promises).then((data) => {\\n    data.forEach((d) => {\\n        if (Array.isArray(d)) {\\n            tables.push(d)\\n        }\\n    })\\n    //生成xlsx表格\\n    const buffer = nodeXlsx.build([{ name: '巡检', data: tables }])\\n    const file = path.join(__dirname, '/server.xlsx')\\n    fs.writeFileSync(file, buffer, 'utf-8')\\n})\\n```\\n\\n巡检结果统一暂存于`tables`数组中，以便导出。\\n\\n## 实现快捷指令巡检\\n\\n使用命令行巡检还是太累了。 最好是鼠标点下自动触发自动巡检。\\n\\n我们可以借助Mac快捷指令自定义再简化下。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/47ddc898b3044e548eb403c3f191e402~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n快捷指令可以运行Shell。这样只需要编写一个名字叫做【巡检服务器】的快捷指令。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f9bd3b37c9d414882e830084b905aac~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n运行Shell后，以WPS打开`server.xlsx`文件。\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9bc68d6f02e8486886aeae46859beb4a~tplv-k3u1fbpfcp-watermark.image?)\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8ad36c3e21745929717b42a77be7499~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n快捷指令添加至访达。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f5f8af3b99e4679a0e2299b36880d1e~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n这样就可以轻松实现自动巡检服务器功能了。\\n\\n## 总结\\n\\n文章灵感来源于工作，通过使用Node.js+Shell+ssh2做到自动连接登陆远程服务器，运行相关Shell命令，检查服务器程序运行是否正常等情况。\\n\\n对于程序员来说，懒，才是第一生产力！！！\\n\\n如果我的文章对你有帮助，你的👍就是对我的最大支持^_^。\\n",
        "tags": [
            "前端",
            "JavaScript",
            "Node.js"
        ]
    },
    {
        "article_id": "7178816031459115066",
        "cover_image": "https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/04c71a80b6b941949a26771a2fc0de72~tplv-k3u1fbpfcp-watermark.image?",
        "title": "24 岁技术人不太平凡的一年",
        "brief": "一年前，我整夜混迹于魔都淮海中路的酒吧迪厅，而白天，在外滩海景餐厅吃着四位数一顿的西餐。租住的洋房里陈列着各种奢侈品...... 一年后，我结婚了，并且买了套房子。",
        "user_name": "代码与野兽",
        "view_count": 11433,
        "collect_count": 50,
        "comment_count": 43,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/dac9f5ba3e7b6d8015a9b37536d4ef59~300x300.image",
        "category": "前端",
        "content": "一年前，我整夜混迹于魔都淮海中路的酒吧迪厅，而白天，在外滩海景餐厅吃着四位数一顿的西餐。租住的洋房里陈列着各种奢侈品……\\n\\n一年后，我结婚了，并且买了套房子。\\n\\n# 一、魔都\\n\\n2021 年，是我爸妈非常兴奋的一年。因为那年我去了上海，找了一份年薪 60 几万的工作。他们可以和邻居亲戚们炫耀他们的儿子了。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3fef39e5bfe4e3c91fc320a88aaba25~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n但我没什么感觉，对我而言，60 万只是手机上的一串数字。而且我知道，60 万并不多。因为那个整日听我汇报的、大腹便便的、看上去不怎么聪明的中年人拿着远比我高的薪水，我和他都一样，只是一条资本家的狗而已。\\n\\n我一向不打算结婚，也不打算要孩子，也就意味着我不需要存钱。\\n\\n我不会像我的领导那样为了在上海买一套 1200 万的房子而过得那样抠搜。我可以花一万多租一个小洋房，我可以在家里塞满那些昂贵的电器，我可以每周去国金、恒隆、新天地消费。我会买最新款的苹果全家桶，甚至连手机壳都要买 Lv 的。\\n\\n但即使这样，钱还是花不完。\\n\\n别人都因为没钱而烦恼，而我却因为钱花不完而烦恼。\\n\\n后来，在机缘巧合之下，我开始了绚丽多彩的夜生活。在夜店，只需要花 1 万块钱，就可以当一晚上的王。这种快感是难以描述的。我成了 Myst、LolaClub、Ak、wm、pops 们的常客。开始了一段纸醉金迷的日子。\\n\\n# 二、求职\\n\\n找工作是一件再容易不过的事，因为几乎所有人都有工作。人只要降低要求，就一定能够找到工作。找工作难，是因为你渴望的工作岗位所需要的能力与你当前的能力并不匹配。\\n\\n刚来到上海的时候，我非常自信，整天到处闲逛。朋友问我为什么不准备面试题？我说没有这种必要，他说不是很理解，我说那算了，不用理解。\\n\\n因为技术上的知识，就那么多。你有自己的理解，有自己的经验，完全不需要胆怯，也没必要胆怯。合适就去，不合适就再看看。\\n\\n能否找到好工作，更多的是你和面试官是否聊得来；你所做的事情，是否和这家公司的业务所匹配；你的经历、价值观和这家公司的愿景使命价值观是否契合。\\n\\n我清楚我的能力究竟如何，我知道我应该去哪种公司。\\n\\n但我需要了解这些公司的不同。于是我投了很多简历，大小公司都有。像携程、美团、得物、拼多多、小红书、微盟这些公司基本上都有去面试。跑了很多地方，徐家汇、北外滩、五角场、陆家嘴、奉贤岛、静安寺……。\\n\\n全职面试，一天四五场，很忙。\\n\\n但不到一周就确定好了 offer。\\n\\n朋友说我是一个果断的人，我只是觉得没必要消耗时间。\\n\\n明白自己的能力上限在哪，懂得在合适的环境最大化释放自己的价值。就一定可以收获一份合适的工作，或者说是一份事业。\\n\\n找到自己的使命，就可战无不胜。\\n\\n# 三、爱情\\n\\n人缺什么，就会去寻找什么。\\n\\n在 24 岁的年纪里，我缺少的不是梦想、金钱或者使命感，而是爱情。\\n\\n我遇到了 Emma，她带给我的滋味，与我所有的想象都不一样。\\n\\n我在上海，她在三亚。我们在相隔千里的城市，我坐着飞机去找她。结果因为晚了几分钟，于是我买了张全价票，硬是要在当天飞过去，因为我等这一天已经等了半个月了。\\n\\n我们住在三亚的希尔顿。在三亚有两个希尔顿，结果她找错了，去了另一个希尔顿，后来我们很庆幸幸亏没有人开门。\\n\\n虽然 Emma 笨笨的，但我喜欢她这样。\\n\\n我们去了亚龙湾、天涯海角和南海观音。\\n\\n三亚虽然是中国最南方的岛最南侧的城市，但有个外号是东北第四城。前三个是黑龙江、吉林和辽宁。一个城市的名字可能是错的，但外号绝对不会错。海南到处都是东北人。\\n\\n爱情刚开始都会轰轰烈烈，我会给 Emma 精心挑选手链，去国金帮她挑选面膜，亲手给她写情书，那些情书至今还在我们的衣柜里。后来去全上海只有两个店的 Graff 买了一对情侣对戒。\\n\\n我不介意给心爱的女人花钱。我觉得，一个男人把钱都花在哪儿了，就知道这个男人的心在哪儿。\\n\\n当然，认识久了，特别是同居之后，这种轰轰烈烈式的浪漫就会褪去，更多的是生活中的点点滴滴。\\n\\n有人说过一句话：\\n\\n和喜欢的人在一起的快乐有两种，一种是一起看电影旅行一起看星星月亮分享所有的浪漫。还有一种则是分吃一盒冰淇淋一起逛超市逛宜家把浪漫落地在所有和生活有关的细节里。\\n\\n但无论是前者还是后者，我都想和你一起，因为重要的是和你，而不是浪漫。\\n\\n往事历历在目，虽然现在很难再有当时的那种感觉，可我更享受当下的温馨。\\n\\n# 四、旅游\\n\\n认识 Emma 之后，我们开始养成了旅游的习惯，每个月都会留出两三天时间一起出去旅游。\\n\\n2 月，去了丽江。爬了玉龙雪山、逛了拉市海和木府。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4724f9dd120f40fe95309465a25107b6~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n玉龙雪山真的很神奇，在丽江市任何一个角落，都可以抬头看见白雪皑皑的雪山。\\n\\n2 月 14 号是情人节，我在丽江的街头给 Emma 买了一束玫瑰。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/774ea92019b448a38af885f5be2c4bad~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n3 月，我在上海，本来打算去北京，结果发生航变。然后再打算做高铁去杭州西湖，结果杭州顺丰出事了。哪都去不了，只能在上海本地旅游。去了陆家嘴的上海中心大厦。其实很早之前我就和朋友去过一次了，这次去的主要目的是和 Emma 锁同心锁。\\n\\n我记得我们去的时候，已经是晚上九点五十，工作人员说十点关门，因为疫情原因，明天开始将无限期关停，具体开放时间等通知。如果现在上去，我们只能玩十分钟。没有犹豫，花了四百多买了两张票上去上了把锁。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c04e17cdd6d245f2a67ac658ec87e0de~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n那时我还不知道，这种繁华将在不久后彻底归于死寂。\\n\\n后面几天，我们在上海很多地方溜达，外滩、豫园、迪士尼乐园。\\n\\n迪士尼乐园是上海人流量最大的游乐场，几乎全年都是爆满。但这次疫情期间的迪士尼乐园的游客很少，很多项目都不需要排队。\\n\\n但那天真的很冷，我们为了看烟花冻得瑟瑟发抖。夜晚的迪士尼城堡真的很美。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6daea61d978c4b0fa76479c046df1d7e~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n4-7 月上海封城，哪儿也没去。\\n\\n8 月去了博鳌亚洲论坛。如果不是去开会的话，真没什么好玩的。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52eab01aaada4954b8dbf7136f254c4d~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n9 月打算坐轮船去广州徐闻、再坐绿皮火车去拉萨，因为我们认为这样会很浪漫。结果因疫情原因，没办法离开海南，只去了骑驴老街和世纪大桥旁边的云洞书店。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b973fdb8dcb46b4a0d42e8ef6fbede2~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7928635f00884bddb99c0e9ff458684a~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n这座书店建在海边，进入看书要提前预约。\\n\\n实际上没几个看书的，全是美女在拍照。\\n\\n10 月去了济南大明湖和北京的天安门广场、八大胡同等地方。\\n\\n很没意思，图我都不想放。\\n\\n预约了故宫门票，并且打算去八达岭长城。但是在北京土生土长四十年的同事告诉我，他从来没去过故宫，并且不建议去八达岭长城。于是我把故宫的门票退了，并且把八达岭长城的计划也取消了。\\n\\n11 月一整个月都在忙着买房子的事情，天天跟着中介跑，哪儿也没去。\\n\\n# 五、封控、方舱、辞职与离沪\\n\\n上海疫情暴发，改变了很多事。\\n\\n这一部分我删掉了，涉及敏感话题。\\n\\n总结来说就是：封控，挨饿，感染奥密克戎，进方舱，出舱，继续封控。\\n\\n6 月 1 日，上海终于开放了。\\n\\n虽然可以离开小区，但离开上海还是很难。\\n\\n首先我需要收拾家里的东西，然后需要寄回我爸妈家，但当时所有的物流都处于瘫痪状态。当时我也想过直接丢掉，但我的东西真的很多，有二十多个箱子，差不多是我的全部家当了。\\n\\n再之后需要购买飞机票，但所有的航班都在无限期航变。我给飞机场的工作人员打了很多次电话，没事就问。后来她们有些不耐烦了，告诉我，现在没有一架飞机能从上海飞出去，让我不要再打了。\\n\\n可我不死心。\\n\\n最后我选择了乘坐火车。\\n\\n上海没有直达海口的火车，所以需要在南昌中转。由于我是上海来的，所以当地的政策是要隔离 7 天，除非你不出火车站。上海到南昌的火车是第一天下午到，而南昌到海口的火车是第二天的中午才出发。这也就意味着我要在南昌站睡一晚。而从上海到海口的整个路程，需要花费 3 天。这对以前的我来说是不可思议的。\\n\\n但爱情赋予我的力量是难以想象的。\\n\\n我在火车站旁边的超市买了一套被子就上了去南昌的火车，然后躺在按摩椅上睡了一晚。\\n\\n第四天一大早，我终于到了海南。\\n\\n# 六、求职\\n\\n2022 年，是非常难找工作的。\\n\\n特别是我准备搬到海南。海南是没有大型互联网公司的，连个月薪上万的工作都找不到。这样估计连自己都养不活。\\n\\n所以我准备找一份远程工作。相比较于国内，国外远程工作的机会明显更多，可惜我英语不好，连一场基本的面试所需要的词汇都不够。所以我只能找一些国内的远程机会。\\n\\n机缘巧合之下，终于找到了一家刚在美国融到资的创业公司。\\n\\n他们需要一位带有产品属性和创造力的前端架构师。前前后后面了大概一周，我成功拿到 offer。这是我第一次加入远程团队。\\n\\n印象中面试过程中技术相关的点聊了以下几点：\\n\\n-   WebSocket 的弊端。\\n-   Nodejs 的 Stream。\\n-   TLV 相比 JSON 的优劣势。\\n-   HTTP 1.1/2 和 HTTP3（QUIC）的优劣势。\\n-   对云的看法。\\n-   真正影响前端性能的点。\\n-   团队管理方面的一些问题。\\n\\n因为公司主要业务是做云，所以大多数时间都是在聊云相关的问题。老板是一个拥有 20 年技术背景的老技术人，还是腾讯云 TVP。在一些技术上的观点非常犀利，有自己的独到之处。这一点上我的感受是非常明显的。\\n\\n## 全球化边缘云怎么做？\\n\\n现代应用的性能瓶颈往往不再是渲染性能。但各大前端框架所关注的点却一直是渲染。以至于现代主流前端框架都采用 Island 架构。\\n\\n但另一个很影响性能的原因是时延。这不仅仅是前端性能的瓶颈，同时也是全球化分布式系统的性能瓶颈。\\n\\n设想一下，你是做全球化的业务，你的开发团队在芝加哥，所以你在芝加哥买了个机房部署了你们的系统，但你的用户在法兰克福。无论你的系统如何优化，你的用户总是感觉卡顿。因为你们相隔 4000 多英里的物理距离，就一定要遭受 4000 多英里的网络延迟。\\n\\n那该怎么办呢？很简单，在法兰克福也部署一套一模一样的系统就好了，用户连接距离自己最近的服务器就好了，这样就能避免高网络时延，这就是全球分布式。但如果你的用户也有来自印度的、来自新加坡、来自芬兰的。你该怎么办呢？难道全球 200 多个地区都逐一部署？那样明显不现实，因为成本太高了，99% 的公司都支付不起这笔费用。\\n\\n所以很多云服务商都提供了全球化的云服务托管，这样就可以以低成本实现上述目标。\\n\\n但大多数云服务商的做法也并不是在全球那么多地区部署那么多物理服务器。而是在全球主要的十几个地区买十几台 AWS 的裸机就够了。可以以大洲维度划分。有些做得比较好的云服务商可能已经部署了几十个节点，这样性能会更好。\\n\\n这类云服务商中的一些小而美的团队有 vercel、deno deploy。这也是我们竞争目标之一。\\n\\n## 招聘者到底在招什么人？\\n\\n当时由于各种裁员，大环境不好，面试者非常多，但合适的人又非常少。后来据老板透露，他面试了 48 个人，才找到我。起初我还不信，以为这是常规 PUA，后来我开始负责三面的时候，在面试登记表中发现确实有那么多面试记录。其中竟然有熟人，也有一个前端网红。\\n\\n后来我总结，很多人抱怨人难招，那他们到底在招什么人？\\n\\n抛开技术不谈，他们需要有创造力的人。\\n\\n爱因斯坦说：想象力比知识更重要。想象力是创造力的要素之一，也是创造力的前提。\\n\\n那些活得不是很实际的人，会比那些活得踏踏实实的人有更大的机会去完成创造。\\n\\n为什么要抛开技术不谈？因为职业生涯到了一定高度后，已经非唯技术论了。大家的技术都已经到了 80 分以上，单纯谈论技术，已经很难比较出明显差异，这时就要看你能用已有的技术，来做点什么，也就是创造力。这也是为什么我在文中没怎么谈技术面试的原因。\\n\\n如果将马斯洛需求理论转化为工程师需求理论，那么同样可以有五级：\\n\\n1. 独立完成系统设计与实现。\\n\\n2. 具有做产品的悟性，关注易用、性能与稳定。\\n\\n3. 做极致的产品。对技术、组织能力、市场、用户心理都有很全面深入的理解。代表人物张小龙。\\n\\n4. 能够给世界带来惊喜的人。代表人物沃兹尼亚克。\\n\\n5. 推动人类文明进步，开创一个全新行业的人。代表人物马斯克。\\n\\n绝大多数人都停留在前三个维度上，我也不例外。但我信奉尼采的超人主义，人是可以不断完善自我、超越自我、蜕变与进化的。既然沃兹尼亚克和马斯克能够做到的事情，我为什么不能去做呢？所以我会一直向着他们的方向前进。或许最终我并不能达到那种高度，但我相信我仍然可以做出一些不错的产品。\\n\\n# 七、创业\\n\\n搬到海南之后，时间明显多了起来。不需要上下班通勤，不去夜店酒吧，甚至连下楼都懒得去。三五天出去一次，去小区打一桶纯净水，再去京东超市买一大堆菜和食物，囤在冰箱。如果不好买到的东西，我都会选择网购。我一般会从山姆、网易严选、京东上面网购。\\n\\n九月份十月份，海南暴发疫情，一共举行了十几轮全员核酸检测，我一轮都没参加。主要是用不到，出不去小区没关系，外卖可以送到小区门口，小区内的京东超市也正常营业，丝毫不影响我的日常起居。\\n\\n所以我盘算着要做些事情。刚好之前手里经营着几个副业，虽然都没有赚到什么钱。但是局已经布好了。其中一个是互联网 IT 教育机构。是我和我的合伙人在 20 年就开始运营的，现在已经可以在知乎、B 站等渠道花一些营销费用进行招生。我们定价是 4200 一个月（后来涨价到 4800），一期教三个月左右。通过前几期的经验，我们预估，如果一期有十几个人到二十个人报名，就有大概将近 10 万多的收入，还是蛮可观的。所以我准备多花些精力做一下这个教育机构。\\n\\n培训的内容是前端，目标是零基础就业。因为我在前端这方面有很大的优势，而且当时前端招聘异常火热。初级前端工程师需要掌握的技能也不多，HTML、CSS、JavaScript、Git、Vue，就这么几块内容而已。相比较成型慢的后端，前端是可以速成的，所以我认为这条路非常可行。\\n\\n我负责的这一期，前期招了将近 20 人。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f28926ce5f5e49e2a29d3072ce593d8e~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n而下一期还没开课，已经招到了 5 个人。一切都向着好的方向发展。\\n\\n但很快，十月、十一月左右，招生突然变难了。连知乎上咨询的人都明显变少了。我们复盘了下原因，原来是网上疯传现在是前所未有的互联网寒冬，加上各种大厂裁员的消息频发，搞得人心惶惶。甚至有人扬言，22 年进 IT 行业还不如去养猪。\\n\\n因为我的合伙人是全职，他在北京生活花费很高，加上前期没有节制地投入营销费用，他已经开始负债了。但是营销费用是不能停的，一旦知+ 停掉，就很难继续招生。\\n\\n后来经过再三讨论，最终还是决定先停掉。虽然我们笃定 IT 培训是红海，但感觉短期的大环境不行，不适合继续硬撑下去。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/95a65320d17a4cf7986796da21cd0e7b~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n目前我带着这期学员即将毕业，而我们也会在 23 年停止招生。\\n\\n培训的这个过程很累，一边要产出营销内容，一边要完善和设计教材、备课、一边还要批改作业。同时每天完成两个小时的不间断直播授课，不仅仅是对精力的考验，也是对嗓子的考验。\\n\\n虽然创业未成，但失败是我们成长路上的垫脚石，而且这也谈不上什么失败。\\n\\n我把经验教训总结如下，希望对你有所启发。\\n\\n## 1. 市场和运营太重要了\\n\\n中国有句谚语叫“酒香不怕巷子深”。意思是如果酒真香，不怕藏于深巷，人们会闻香而至。除了酒，这句话也隐喻好产品自己会说话，真才子自有人赏识。\\n\\n但实际上，这是大错特错。\\n\\n随着我阅历、知识、认知的提升，我越发觉得，往往越是这种一说就明白、人人都信的大道理，越是错的。\\n\\n傅军老师讲过一句话：感受不等于经验、经验不等于知识、知识不等于定律、定律不等于真理。我深受启发。在这个快速发展的信息时代，必须保持独立思考的能力。\\n\\n我思考的结果是：酒香也怕巷子深。\\n\\n连可口可乐、路易威登、香奈儿这种世界顶级品牌每年都需要持续不断地花费大量的费用用于营销。由此可见营销的重要性，营销是一定有回报的。\\n\\n我们的酒要香，同时也不能藏在巷子里。而且，我们的酒不需要特别香，只要不至于苦得无法下咽，就能卖出去。畅销品不一定就是质量好，某些国产品牌的手机就是一个简单的例子。\\n\\n所以，只需要保证产品是 60 分以上就足够了，剩下的大部分精力都应该放在营销上面。绝大多数只懂得专注于打造 100 分产品的创业公司，基本上都死了。\\n\\n正确的路径应该是：Poc、Alpha、Beta、MVP。就像下图所示，造车的过程中，产品在任何一个时间点都是可用的。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ddce34fae6eb4175bca7b083128520ca~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n另外，决定一个公司成功的，一定是运营部或者市场部，绝对不是技术部。但是技术部有可能会让一个公司走向失败。如果一个公司要裁员，技术部门很可能首当其冲。当然这也要看公司文化，但大部分的 Boss 普遍更看重运营与市场。\\n\\n## 2. 不要等万事俱备再开始\\n\\n在创业早期，我们的主要招生渠道是 B 站，但我没有短视频经验。于是我买了暴漫 B 站 UP 主的课程。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/04edc857c08945b9a7196f57cca7d06a~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n本来以为买了课程就意味着学会了做视频，但实际上不是这样的。\\n\\n做好一个 UP 主需要掌握非常多的知识，选题、文案、表达、拍摄、剪辑、互动，各个环节都有大学问。我很快发现不可能把整个课程全部研究透再去做视频。我需要保持频率地更新视频才能有更多人的关注。\\n\\n随着业务的发展，后面主战场转到了知乎，工作内容也变成了软文和硬广。UP 主的很多技能还没来得及实践就被搁置了。\\n\\n知乎也有一个写作训练营，学费大概也要三四千的样子。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/92c19ff9dddd4aa5ac9d9b1c42e21848~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n我听了试听的三节课，感觉要学习的东西一样很多，所以我没有买这个课程。因为我知道我没有那么多精力。\\n\\n最重要的是，我发现即使我没有什么技巧和套路，我写的软文一样有很多浏览量和转化率。知+平台的数据可以直接告诉我这篇文章或者回答写得好不好。\\n\\n同时，很多相关的知识不是一成不变的，它们不是传统知识，需要从实际事物中脚踏实地地学习，我们没办法系统学习。\\n\\n我们不可能做好所有的准备，但需要先去做。人生也该如此，保持渐进式。\\n\\n## 3. 接受糟糕，不要完美主义\\n\\n初创公司很多东西都是混乱的，缺乏完善的系统和结构，一切似乎都是拍脑袋决定。\\n\\n报销很混乱、营销费用很混乱、内容管理很混乱、合同很混乱；甚至连招生清单都和实际上课的人对不上……\\n\\n但我发现这是一个必须接受的现状，如果一切都井井有条，那就不是初创公司了。所以必须要适应这种乱糟糟、混乱的环境。\\n\\n# 八、结婚与买房\\n\\n朋友说我是一个果断的人。\\n\\n因为从认识，到结婚、买房，一共用了不到一年时间。\\n\\n其实起初我是强烈不建议买房的，我不看好中国的楼市，而且我们一个月花几千块租房住得非常舒服。而且我的父母在北方的城市也已经有两套房子了。但 Emma 认为没有房子不像个家，没安全感。安全感对一个女人实在太重要了，我想以她对我的了解，她怕我哪天突然悄无声息地就离开她。想了想，确实是这样，所以我就买了。\\n\\n我们看了海口很多套房子，本来计划买个小两居，但看了几次，都觉得太紧凑了。我是要在家工作的，我有一张很大的双人桌，要单独留一个房间来放它。最后挑了一个三居室的房子。这种感觉和买电脑差不多，本来一台普通 Thinkpad 的预算，最终买了个 MacBookPro 顶配。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/121e641edf334a75ad0f10662f8cf038~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n房子很漂亮，我们也很喜欢。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9186fce37cbf4f7d8d03ba51f737a014~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n不过呢，同时也背负了两百万的贷款。不能再像以前那样随便花钱了。\\n\\n买房只需要挑房屋布局、装修和地段，其他不需要关心。\\n\\n买房贷款的注意事项：选择分期，选择还款周期最久的，不要提前还。今年由于疫情原因，房贷大概是 4.5 个点，比前几年要低。买房前保持一年流水，收入大于月供 3 倍。\\n\\n还需要注意，买完房，还要考虑装修费用和家电的费用。\\n\\n非刚需不建议买房，刚需的话不会考虑买房的弊端。\\n\\n至于为什么结婚？\\n\\n我和 Emma 都是不婚主义者。但是买房子如果不结婚，就只能写一个人的名字。但我们都不愿意写自己的名字。最后没办法，决定去办理结婚证。\\n\\n但我们没有举办传统的婚礼，我们都不喜欢熙熙攘攘、吵吵闹闹。我们只想过好我们自己的生活，不希望任何人来打扰我们。\\n\\n这辈子我搬了至少十次家，只有这次是搬进自己的家。\\n\\n# 九、学习\\n\\n今年在学习上主要有四个方面：\\n\\n-   Web3。\\n-   英语。\\n-   游戏开发。\\n-   自媒体。\\n\\n目前对我来说，Web3 是最重要的事情。虽然我还没有 All in web3，但也差不多了。有人说 Web3 是骗局，但我认为不是骗局。\\n\\n我承认 Web3 有非常多的漏洞，比如 NFT 的图片压根没上链，链上存储的只是一堆 URL。同时几乎所有用户都没有直接与区块链交互，而是与一堆中心化的平台交互。比如我们使用 MetaMask，其实数据流过了 MetaMask 和 Infura。目前的 Web3 并没有完全去中心化。\\n\\n没有一个新鲜事物在一诞生就是完美的。正是由于这些不完美的地方，所以才需要我们去完善它们。\\n\\n目前我已经加入了一个 Web3 团队。虽然团队不大，但是他们做的事情非常吸引我。Web3 是一个高速发展的火箭，对现在的人来说，你先上去再说，何必在乎坐在哪个位置上？\\n\\n我很期待 2030 年的 Web3。\\n\\n如果要进入 Web3，需要学习技术有很多，我把一些重要的技术栈列举如下：\\n\\n-   Web3.js or Ethers.js or Wgami：与区块链交互的前端 SDK。\\n-   Solidity：智能合约编程语言。\\n-   Hardhat：以太坊开发环境。\\n-   IPFS：Web3 文件存储系统。\\n\\n除了上述的技术之外，更多的是概念上的理解，比如 NFT、GameFi 相关的诸多概念等。\\n\\n学习英语是因为我打算出国，同时我现在的工作环境也有很多英语，我不想让语言成为我继续提升的障碍。\\n\\n至于游戏开发和自媒体，纯粹是想赚钱。\\n\\n游戏开发主要是微信小游戏，靠广告费就能赚钱。微信小游戏的制作成本很低，两个人的小型团队就可以开发数款微信小游戏。而且赚钱和游戏质量并不成正比。跳一跳、羊了个羊都是成功案例。当然我的目标不是做那么大，大概只需要做到它们几百分之一的体量就非常不错了，要知道微信有将近 10 亿用户，总有人会玩你的游戏。\\n\\n另外我学习自媒体和微信小游戏的原因差不多。自媒体的盘子越来越大。在 B 站、抖音这些短视频平台上，有着上千亿甚至更多的市场。这给更多人创造了创造收入的空间。\\n\\n只要去做，总会有所收获。\\n\\n在学习的过程中，我会记录大量笔记以及自我思考。但很少会更文。\\n\\n大概在 9 月份，我参加了掘金的两次更文活动，输出了一些内容。\\n\\n这个过程很累，但也有所收获。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/37221c5ccfd14616a6d6e6e2785e6039~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13c85eb967894298acdb031136fa34df~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/305d5f619f7f4913b2843b53e8729b53~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/75733fefec5c48aba73523eb6738f7c5~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n后来考虑到时间和精力问题，所以很少更文了。\\n\\n很遗憾，掘金目前只能依靠平台自身给创作者奖励，收入非常有限。如果掘金能够将变现程度发展成像 B 站、公众号或抖音那样，估计也会有更多的创作者加入。连 CSDN、博客园这些老牌产品都做不到。究其原因，还是这种性质的产品受众没有那么广泛，盘子太小了，体量自然无法涨上去。希望未来掘金能够找到属于自己的商业模式。\\n\\n最后还是很感谢掘金这个平台，给了技术人们一个分享交流的空间。\\n\\n# 十、未来\\n\\n未来三年的计划是出国读硕，并全面转入 Web3 领域。\\n\\n我不看好中国的经济，并且感觉在中国做生意会越来越难做。而且我更喜欢西方文化、氛围和环境。\\n\\n在经历了国内疫情反复封控之后，我更加坚定了出国的打算。我不想继续生活在大陆。\\n\\n我想看看外面的世界，同时系统化地提升一下自己的 CS 知识。\\n\\n目前出国的思路是申请混合制研究生，F1、OPT、H1B、Green Card。目标是一所在 Chicago QS TOP500 垫底的高校。\\n\\n另一条出国的路线是直接出国找一份美国的工作，但对目前的我来说是相当难，主要还是因为语言。\\n\\n之所以是未来三年的计划，也是因为我的英语实在太差，目前按照 CEFR 标准，只达到了 A2。\\n\\n按照 FSI 英语母语者学习外语的难度排名，中文这类语言是最难学习的。反过来，中文母语者学习英语，也是最难的。真正掌握大概需要 2200 小时，如果每天学习 3-4 小时的话，需要 88 周，将近两年。\\n\\nFSI 的图片我删掉了，因为那张图上的中国版图有争议。\\n\\n我的语言天赋很一般，甚至有些差。所以学习效果并不理想。我也不打算短时间内冲刺英语，因为那不太靠谱。我选择花更久的时间去磨它。\\n\\n之前也想过去 Helsinki，但那边收入不高，税收太高。纠结了很久，还是觉得现在还年轻，多少还是应该有些压力的，去那种地方实在太适合养老了。\\n\\n以上并不是故事，是我的亲身经历，分享出来的初衷是为大家提供更多职业和人生的思路与思考。希望对你有所帮助！\\n\\n「回顾2022，展望2023，我正在参与[2022年终总结征文大赛活动](https://juejin.cn/post/7172462429929111559 \\\"https://juejin.cn/post/7172462429929111559\\\")」\\n\\n",
        "tags": [
            "前端",
            "后端",
            "年终总结"
        ]
    },
    {
        "article_id": "7182494839873749048",
        "cover_image": "",
        "title": "普通人如何通过做游戏赚到钱",
        "brief": "之前写过《做游戏的盈利路径有很多》，其中谈到通过做游戏本身来赚钱其实是最难的，但是大部分的游戏开发者都只认准这条路，都希望能够通过自己创作的游戏本身来赚到钱。",
        "user_name": "小蚂蚁教你做游戏",
        "view_count": 8935,
        "collect_count": 67,
        "comment_count": 12,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/3786e45dfbe9cd17469fa0e171e96cf0~300x300.image",
        "category": "前端",
        "content": "> 嗨！大家好，我是会做游戏也会教你做游戏的小蚂蚁。欢迎关注微信公众号【小蚂蚁教你做游戏】，每天学点儿做游戏的知识。\\n\\n之前写过[《做游戏的盈利路径有很多》](https://mp.weixin.qq.com/s?__biz=MzIwODIwODM4MQ==&mid=2651296923&idx=1&sn=3a2c24fd655dd1f06b30f3cfe222bfa6&scene=21#wechat_redirect)，其中谈到通过做游戏本身来赚钱其实是最难的，但是大部分的游戏开发者都只认准这条路，都希望能够通过自己创作的游戏本身来赚到钱。\\n\\n小蚂蚁到目前为止一共是上线了 7 个小游戏，游戏本身给我带来的盈利并不多（大概每个月两千块），但是这放到个人游戏开发者群体里应该可以算是不错的结果了，因为 90% 的自己做游戏的人根本赚不到钱，更不用谈靠做游戏养活自己了。\\n\\n我认为自己之所以做出了一点点结果，是因为我做了一些相对正确的选择，以及使用了一些相对正确的方法。在此分享给大家，这些经验和方法不能帮助你赚很多钱（因为我自己也没有赚到嘛），但是应该能够帮助你赚到钱，要知道只要你做的游戏净赚哪怕是一块钱，你也超越了 90% 的做游戏的人（90%的人都赚不到钱或者在赔钱）。\\n\\n可能有的人觉得做游戏是因为自己喜欢和热爱，不应该谈及赚钱。其实大可不必，喜欢热爱跟赚钱盈利并不是互相对立，非此即彼的。如果做你喜欢的事，还能够赚到钱，那结果只能让你更加喜欢做这件事。另外，物质基础是能够长期做一件事情的保障，喜欢和热爱是无法填饱肚子的。\\n\\n虽然通过游戏本身赚钱挺难的，但是对于普通人来讲，并不是做不到的，比如说小蚂蚁的几个小游戏。\\n\\n![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96d883f2d1154e348e9ab28aae5ab528~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n注意这里是游戏的累积收入，不是每日收入（如果是的话，那就要上天了），虽然不多，但是有一个最大的好处就是，你只需要一次性的投入，之后基本上就是“躺赚”了。例如精致1010，这个游戏我前后大概投入了一个多月的时间，之后就不需要再投入了，而它现在基本上稳定带来每月一千左右的收入。如果把时间线拉长来看的话，这一个多月的投入所带来的回报还是很可观的。做小游戏很像是细水常流，每做一个游戏，就像是挖了一条小沟渠，之后便是等待小水流慢慢地积累。\\n\\n好了，如果你是个像我一样的普通人，喜欢做游戏，又希望能通过做游戏赚到钱，那下面的这些分享或许能够对你有启发或帮助。\\n\\n首先，有一个观念你需要理解和认可，那就是你的游戏不是给你自己做的。你想通过游戏赚钱，赚的是自己的钱吗？当然不是，想要游戏赚钱，需要有其他的玩家玩你的游戏，然后通过在游戏中展示广告来盈利。你这个想要赚钱的游戏其实并不是给自己做的，而是给其他的玩家做的。\\n\\n做对自己有用的东西，跟做对他人有用的东西，这两种观念最终导致的结果天差地别。你可能遇到这样的开发者，辛辛苦苦做了一个游戏，发布后没有达到自己预期结果的，然后就开始怨天怨地，怨平台不公，怨玩家没品味，怨市场为流量论.....总之我付出了这么多，最终没有得到这个世界的认可，就是这个世界的错。当然，你也可能遇到这样的开发者，他们在做了一款游戏没效果时，会总结经验调整方向，了解玩家的喜好和需求，然后再去尝试做下一款游戏，来满足玩家的需要。\\n\\n我们所有做游戏的人其实都是在给他人做游戏，这是事实，但是你可能并不接受。如果你的游戏完全是给自己做的，那其实不需要有第二个人知道你做的游戏，对吧？你自己知道就好了。如果你希望别人知道你做的游戏，希望别人来玩你做的游戏，那你的游戏就是在给别人做的。\\n\\n只有做出了他人爱玩的游戏，你才有可能赚到钱。这一点特别重要，应该记下来时刻提醒自己，它能够避免你沉迷于自己的想象之中，也能提醒你去观察那些你要为之做游戏的玩家。\\n\\n如果你接受了自己是在为他人做游戏，那接下来在选择做什么类型的游戏时，就会简单很多了。你想为哪类人群做游戏呢？男性，女性，小孩，老人，上班族，休闲族......选择一个人群，然后了解一下他们对于游戏的偏好，这个上网搜一下就能知道了，例如 20～30 岁的男性玩家更偏好动作射击游戏，30～40 岁以上的女性玩家更偏好休闲消除游戏。确定了人群和偏好，下面就可以进一步选择做什么样的游戏了。\\n\\n以小蚂蚁为例，在做第一个【精致1010】游戏时，我定位的就是休闲游戏人群，因为这个人群的数量最庞大，下到几岁的小孩，上到八旬老人，其实都属于休闲游戏的人群。我要做的游戏最好是学习成本低，规则简单，拿起来就能玩，有一定的趣味性，可以玩挺长时间。把这些条件都列出来，其实可选的游戏就不是很多了。\\n\\n我直接偷了个懒，因为我并没有想要自己去构思一个原创玩法，也并不认为自己可以想出绝妙的创意。我的方法是直接去找经典游戏，目标更精准一点儿，直接找经典的消除类休闲游戏。三消，点消，连线消，泡泡龙，俄罗斯方块，1010.....大概也就是这么几类。最终，我选择了 1010，因为它制作起来成本最低。\\n\\n很多人都以为做游戏需要的是创意，但事实是，对于绝大部分尤其是普通人来讲，根本就轮不到拼创意。你可能会说，这不是抄袭吗？或许对很多人来讲这就是抄袭，因为你不是最原始的那个 1010，按照这样的评判条件，那现在的 99% 以上的游戏都是抄袭，因为你不是最原始的 RPG，不是最原始的动作射击，不是最原始的消除......相比“抄袭”，更恰当的说法是站在前人的肩膀上继续创新。\\n\\n一个有着经典玩法的游戏，如果能再加上一点儿自己的东西，那就再好不过了。例如【精致1010】，后续我为其增加了闯关模式，效果就非常好，而且我也没见过其它 1010 游戏中有这种消除数字的闯关玩法，这也算是我的一点儿微创新了。\\n\\n如果你不知道自己要做什么游戏，也没什么想法，你可以直接拷贝我的思路，去把所有的经典消除游戏再做一遍，加上一点儿自己的东西。真的不需要太多东西，你可以去微信小游戏平台搜索一下某种类型的经典游戏，你会发现绝大部分的游戏体验都特别的差劲，你只要多注重一下玩家的体验，做的比它们好一点儿，就足够了。\\n\\n到目前为止，我仍然认为精致1010是所有1010类型游戏中整体体验最好的。希望你能做一个更好的。\\n\\n为什么要选择这些经典的游戏呢？因为这些经典游戏的玩法都经受过考验（你不用担心不好玩），它们有足够多的受众（不用担心没人玩），而且它们也有一定的盈利能力（好玩又有人玩自然就能盈利了）。\\n\\n好了，选择做什么样的游戏更容易赚到钱的方法你已经知道了，接下来是一些在游戏制作过程中的具体建议。\\n\\n**把游戏做成关卡制。** 如果游戏本身就是关卡制的，那最好了（例如泡泡龙）。如果不是的话（例如1010），那就想办法做成关卡制的。在用户留存上，关卡制游戏比非关卡制游戏有着更大的优势。想一下，无限模式你最多玩几次也就腻了，如果是关卡的话，你会想看下一关是什么样，再下一关是什么样......另外，关卡制游戏每关结束后都有个停顿的休息时间，也会让玩家体验更好。\\n\\n在我制作的游戏中，关卡制的游戏（精致1010，精致点点连线，疯狂泡泡龙射手，经典掌机罗斯方块）的留存率和用户时长，要明显的高于非关卡制的游戏（圆点守护者，经典宝石方块）。\\n\\n**提前想好游戏中的广告点。** 因为广告是目前个人小游戏的唯一盈利方式，可以说能不能赚到钱就看它了。如何设计广告点，如何让玩家愿意接受广告还不觉得烦人，这个需要下点儿功夫，而且需要提前就开始考虑。很多人都是游戏做完之后，硬插入一个广告的，这会显得很突兀。玩家其实能明显的感觉出一个游戏的广告和游戏结合的怎么样，只有玩家愿意看了，你才能赚到钱。游戏和广告只有结合地好，玩家才会愿意看，所以，这个决定游戏赚钱与否的关键点，你一定要下足了功夫。\\n\\n精致1010中的广告点就明显的好于俄罗斯方块中的广告点，因为俄罗斯方块中实在是找不到一个比较合适的广告点，这导致了两个游戏的收入差距很大。从赚钱的角度来讲，俄罗斯方块并不是一个能赚钱的游戏。\\n\\n**在游戏中凸显出你的标识。** 在游戏中放上你自己的标识，Logo 也好，启动图也好，或者其它的一些什么。它们的作用就是给玩家种下一个印象，当玩家下次打开一个游戏时，看到这个标识就知道这个游戏是你做的。\\n\\n比如，我的所有游戏打开后，都可以看到这样的一张白色的带有小蚂蚁头像的启动页。\\n\\n![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a0000a3f79c422fae35439c3f5658e6~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n再比如说，我会在每个游戏中给玩家写一封信，告诉玩家做这个游戏的一些想法。\\n\\n![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb7109c375e84cb99b9af82f532b14df~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n你会做很多的游戏，这些标识会给那些喜欢你游戏的玩家留下深刻的印象。当下次他们看到这些标识的时候，就知道这是你做的，是可以好好玩的了。\\n\\n**在游戏中增加跳转。** 当你制作的游戏超过一款之后，就可以着手在游戏中增加跳转了。你可以给喜欢你这个游戏的玩家，介绍或者推荐一下你的另一款游戏。例如，【精致1010】中的游戏推荐：\\n\\n![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96b07efe236346f18cd3874e1d6baee0~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n当你的游戏足够多的时候，通过游戏间的跳转增加的用户数量其实是蛮可观的。我的每个游戏目前每天通过其它的游戏跳转过来的新用户数量大概在 30 ～50，而且这些玩家大都是很精准的玩家。因为喜欢你某一款游戏的玩家，大概率的也会喜欢你的其它游戏。\\n\\n以上就是所有的分享了，总结一下：\\n\\n首先，要转变观念，我们是在为他人做游戏。\\n\\n其次，关于选择做什么游戏，如果你没有想法的话，大可直接从经典游戏下手，增加一点儿自己的东西，然后把用户体验尽可能的做的好一点儿。\\n\\n最后，做成关卡制，提前考虑广告点，增加自己的标识，如果游戏多了，在游戏中增加跳转。\\n\\n我认为如果你能做到这些的话，大概率是能赚到钱的，虽然可能赚的不多，但是却能让你成为通过做游戏赚到钱的少数人。而且更重要的是，当你通过自己做的游戏赚到钱的时候，你会更喜欢做游戏的。\\n\\n希望以上的这些分享能够对你有所帮助，希望所有的游戏开发者都能赚到钱。",
        "tags": [
            "游戏开发",
            "微信小程序",
            "游戏"
        ]
    },
    {
        "article_id": "7167177950465851406",
        "cover_image": "https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/73390ef006af4e7db9cac7f8d9191b39~tplv-k3u1fbpfcp-watermark.image?",
        "title": "个人博客小程序构建，这样还可以吧？",
        "brief": "本文原文地址; 一直有构建个人博客小程序的想法，但又不想自己开发后端接口，想做到无后端，人又懒，就没有动手开干。 最近公司原因使用了语雀文档，觉得编辑界面蛮不错，功能强大，思维导图、时序图、pdf都支",
        "user_name": "大流星",
        "view_count": 2007,
        "collect_count": 30,
        "comment_count": 29,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/2fa645188333863ce130edfd9c909032~300x300.image",
        "category": "前端",
        "content": "[本文原文地址](https://herrylo.github.io/front/2022-11-17.html);\\n\\n一直有构建个人博客小程序的想法，但又不想自己开发后端接口，想做到无后端，人又懒，就没有动手开干。\\n\\n最近公司原因使用了语雀文档，觉得编辑界面蛮不错，功能强大，`思维导图`、`时序图`、`pdf`都支持，顺便将个人文章都上传到了语雀上。后面在持续使用中，发现语雀文档有提供`API`接口，于是萌生想法，是否可以考虑用`语雀接口`构建小程序。在`Postman` 测试了一波，发现字段基本都有，那就开始动手干了。\\n\\n## uniapp&语雀API\\n\\n小程序构建框架选择[uniapp](https://uniapp.dcloud.net.cn/)，主要想尝试下不同的框架，之前有尝试使用 Taro 构建过下小程序：[垃圾分类小程序](https://github.com/HerryLo/wxSapp)，就想试试其他框架了。之前听过群友聊过[uniapp](https://uniapp.dcloud.net.cn/)，就决定试试。\\n\\n[uniapp](https://uniapp.dcloud.net.cn/)主要是`vue`的语法，开发的流程按照[uniapp 开发文档](https://uniapp.dcloud.net.cn/)就没有太大问题，平时尽管使用`React`开发，之前是接触和开发过`vue`项目，问题不太大。\\n\\n既然`uniapp`开发问题不大，那就看看接口`语雀API`怎么样呢？\\n\\n前期使用`Postman`调试以后，发现接口是可以调通的，不过语雀近期推出了**会员功能**，好像会和这个冲突，免费用户不知道后期是否可以调用[语雀 API](https://www.yuque.com/yuque/developer/api)接口，找语雀官方人员确认之后：\\n\\n> 语雀回复：\\n\\n> 你好，目前 api 已变更为会员权益功能\\n\\n。。。有点拉了，不过看在文档好用的份上，还是**开了99的专业会员**，不然[语雀 API](https://www.yuque.com/yuque/developer/api)接口没办法调用，整体来说还划算吧？吧？吧？\\n\\n## 小程序界面\\n\\n界面简单整洁，格调清新（功能简单）。不吹了，有兴趣自己构建的同学，底部附有项目源码地址。（主要是不知道怎么设计，就成这个样子了）\\n\\n<div align=\\\"center\\\"> \\n    <img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d26176d31a46407cb5e379a13d42552e~tplv-k3u1fbpfcp-zoom-1.image\\\" style=\\\"height: 60%; width: 60%;\\\" />\\n    <img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3bb1634be85b475d8fd6f30a24b28072~tplv-k3u1fbpfcp-zoom-1.image\\\" style=\\\"height: 60%; width: 60%;\\\" />\\n</div>\\n\\n目前只支持文章列表，文章总数等功能，后续应该会添加上评论、点赞功能。\\n\\n如果你也想开发自己的个人博客系小程序项目，希望以上可以帮助到你！\\n\\n## 更多\\n\\n附上我自己的小程序项目，希望可帮到大家，项目为开源状态，有兴趣可以看看！！\\n\\n项目地址：\\n\\n>   [uniapp 个人博客小程序 GitHub 地址](https://github.com/HerryLo/uniapp-wxapp)\\n\\n>   [Trao 垃圾分类小程序 GitHub 地址](https://github.com/HerryLo/wxSapp)\\n\\n博客二维码:\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/40c243975aab4f91a2d6d0643d5d02ae~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n**注意**： 框架使用的uniapp。文章是在语雀：[www.yuque.com](https://www.yuque.com/yopai/pp6bv5) 发布的，然后语雀有提供API接口，可获取到在语雀上发布的文档列表；不过之前问语雀官方，官方回复是需要会员才可访问语雀API调取文档数据，免费用户是无法调取；\\n\\n***本文正在参加[「金石计划 . 瓜分6万现金大奖」](https://juejin.cn/post/7162096952883019783 \\\"https://juejin.cn/post/7162096952883019783\\\")***",
        "tags": [
            "掘金·金石计划",
            "微信小程序",
            "前端"
        ]
    },
    {
        "article_id": "7168274276787683341",
        "cover_image": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/703473fcd80e4b5483b55c235e2a1a98~tplv-k3u1fbpfcp-watermark.image?",
        "title": "Vue3的响应式到底比Vue2优雅在哪",
        "brief": "Object.defineProperty 和Proxy本质差别是，defineProperty 只能对属性进行劫持，所以出现了需要递归遍历，新增属性需要手动 Observe的问题，有多达13种拦截方",
        "user_name": "Dignity_呱",
        "view_count": 3930,
        "collect_count": 146,
        "comment_count": 17,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/5c6084ef8bfcf6e37087a1455a905668~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: fancy\\nhighlight: arduino-light\\n\\n---\\n\\n***本文正在参加[「金石计划 . 瓜分6万现金大奖」](https://juejin.cn/post/7162096952883019783 \\\"https://juejin.cn/post/7162096952883019783\\\")*** \\n\\n\\n## 前言\\n\\n- [常网IT](http://zhengzemin.cn:3000)戳我呀！\\n- [常网IT源码](https://github.com/git-Dignity/vueAndTsAndKoa2)上线啦！\\n- 如果是海迷，**RED红发剧场版**有需要可关注我主页公众号回“海贼王red”领取。\\n- 本篇录入[吊打面试官](https://juejin.cn/column/7163273718213378055)专栏，希望能祝君拿下Offer一臂之力，各位看官感兴趣可移步🚶。\\n- 有人说面试造火箭，进去拧螺丝；其实个人觉得问的问题是项目中涉及的点 || 热门的技术栈都是很好的面试体验，不要是旁门左道冷门的知识，实际上并不会用到的。\\n- 请问Vue3的响应式到底比Vue2好在哪、以及双向绑定响应式原理是什么？\\n- 我相信这是面试Vue最经常被问到最多的一道题目。\\n\\n---\\n\\n> 星期六晚，**相亲相爱一家人群**拨通了第一次全员视频📹。<br />\\n> 哥哥进来的时候说，开家庭会议啊。<br />\\n> 父母总觉得我们在外面很忙，不想打扰麻烦我们，其实我们上班wx里当舔狗，下班刷短视频，熬夜通宵玩游戏样样精通，怎么可能会没时间呢。<br />\\n> 开了第一次视频，有感而发。\\n\\n\\n\\n![1.jpeg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe404e22138548a0b8c70e073afaace7~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n\\n> 正面试着急背的，我总结一下回答✍。\\n\\nVue2的响应式是基于`Object.defineProperty`的。但它只对初始对象的属性有监听作用，而对新增的属性无效。\\n\\n作者也知道有这个缺陷，提供了`$set`来帮助我们达到响应式。、\\n\\n\\n那么Vue3的响应式机制改为用`Proxy`。\\n\\n我觉得proxy比较好的点有：\\n\\n* Object.defineProperty 和 `Proxy` 本质差别是，defineProperty 只能对属性进行劫持，所以出现了需要递归遍历，新增属性需要手动 `Observe` 的问题。\\n\\n* Vue3.x 通过 Proxy 代理目标**对象**,且一开始只代理最外层对象,嵌套对象lazy by default（惰性监听） ,性能会更好（ Proxy可以直接监听对象而非属性）\\n\\n* 数据响应式系统全语言特性支持，添加数组索引修改监听，对象的属性增加和删除。（Proxy可以直接监听数组的变化）\\n\\n* Proxy有多达13种拦截方法,不限于apply、ownKeys、deleteProperty、has等等是Object.defineProperty不具备的。\\n\\n* Proxy搭配Reflect主要是为了语义化，而且方法都一一对应。\\n\\n其实响应式的原理根据 `Data` 变化更新 `View`。\\n\\n内部实现了四个步骤分别是：\\n\\n* 实现一个**监听器** `Observer` ，用来劫持并监听所有属性，如果属性发生变化，就通知订阅者；\\n\\n* 实现一个**订阅器** `Dep`，用来收集订阅者，对监听器 `Observer` 和 订阅者 `Watcher` 进行统一管理；\\n\\n* 实现一个**订阅者** `Watcher`，可以收到属性的变化通知并执行相应的方法，从而更新视图；\\n\\n* 实现一个**解析器** `Compile`，可以解析每个节点的相关指令，对模板数据和订阅器进行初始化。\\n\\n> 有空的老爷，呱哥更希望咱能啃下本文靠理解和面试官吹水😁~<br />\\n> 细品，我相信一定能助君一臂之力💪<br />\\n> 看不完的，可以先收藏一波。\\n\\n\\n![19.jpg](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/773dd19090b94f9994bd22ce9958e3f5~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## 一、问题剖析\\n\\nVue3的响应式到底比Vue2优雅在哪？\\n\\n在Vue中，响应式这个词在入门的时候就深受喜欢。\\n\\n我们在Vue项目实战中用得最爽的就是修改数据，模板更新，那面试中我们怎么去回答比较好，我个人觉得可以从以下五个方面去回答这个面试题。\\n\\n* 先说一下Vue2的响应式原理，以及其缺陷。\\n* Vue3如何解决Vue2的痛点？\\n* 扩展：阐述MVVM响应式原理？\\n* 扩展：自己对响应式的理解？\\n* 聊到响应式，可以再聊一下，其实v-model也绑定一个响应式数据到视图的操作。\\n\\n> 老子说过：道生一，一生二，二生三，三生万物。<br />\\n> 个人觉得回答一个问题，如果可以引申出问题不同角度或者与其相关的知识点，那面试官可能会觉得你这个人有广度，思维不局限在当前问题下，可能对你刮目相看。<br />\\n\\n\\n## 二、回：Vue2的响应式原理，以及其缺陷？\\n\\n我们先回答第一个小点，Vue2的响应式原理，以及他的缺陷是什么？\\n\\n大家都知道Vue2的响应式是基于`Object.defineProperty`的。\\n\\n我们举个`Object.defineProperty`的一个例子，更深入了解其弊端。\\n\\n```\\n// 响应式函数\\nfunction reactive(obj, key, value) {\\n  Object.defineProperty(obj, key, {\\n    get() {\\n      console.log(`输入${key}属性`)\\n      return value\\n    },\\n    set(val) {\\n      console.log(`${key}由->${value}->设置成->${val}`)\\n      if (value !== val) value = val\\n    }\\n  })\\n}\\n\\n\\nconst data = { name: '阿呱' }\\nObject.keys(data).forEach(key => reactive(data, key, data[key]))\\nconsole.log(data.name)\\n// 输入name属性\\n// 阿呱\\ndata.name = 'Dignity' // name由->阿呱->设置成->Dignity\\nconsole.log(data.name)\\n// 输入name属性\\n// Dignity\\n```\\n\\n可以看到，每次获取值都触发get方法，修改值则触发set方法。\\n\\n那么，他有何缺陷呢？\\n\\n```\\n// 接上\\n\\ndata.do = '打羽毛球'\\nconsole.log(data.do) // 打羽毛球\\n```\\n\\ndata新加`do`属性，访问、设置值，都不会触发get和set方法。\\n\\n所以缺陷是：`Object.defineProperty`只对初始对象的属性有监听作用，而对新增的属性无效。\\n\\n作者也知道有这个缺陷，为了让开发者能更好的响应式，对象新增的属性修改能有响应式，提供了`$set`来帮助我们达到响应式。\\n\\n![17.jpeg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a0009f84c2ce49699e2ef4dbc0e9c038~tplv-k3u1fbpfcp-watermark.image?)\\n\\n### 2.1 Object.defineProperty不能监控到数组下标的变化？\\n\\n这是一段小插曲。\\n\\n🙋面试官说：既然都聊到`Object.defineProperty`，那我问你，他本身能不能监控到数组下标的变化？\\n\\n🙋🏻‍♂️**Object.defineProperty是有监控数组下标变化的能力的，只是 Vue2.x 放弃了这个特性。**\\n\\n有人可能想：不是吧，我们不是无法监听到数组下标的变化，直接设置数组下标，不能响应式，所以Vue才重写了数组的七个方法（push、pop、shift、unshift、splice、sort、reverse）吗？\\n\\n事实上，**Object.defineProperty 本身是可以监控到数组下标的变化的**，只是在 Vue 的实现中，从性能 / 体验的性价比考虑，放弃了这个特性。\\n\\n不信是吧，上例子🌰。\\n\\n```\\nfunction defineReactive(data, key, value) {\\n  Object.defineProperty(data, key, {\\n    enumerable: true,\\n    configurable: true,\\n     get: function defineGet() {\\n      console.log(`get key: ${key} value: ${value}`)\\n      return value\\n    },\\n     set: function defineSet(newVal) {\\n      console.log(`set key: ${key} value: ${newVal}`)\\n      value = newVal\\n    }\\n  })\\n}\\nfunction observe(data) {\\n  Object.keys(data).forEach(function(key) {\\n    defineReactive(data, key, data[key])\\n  })\\n}\\nlet arr = [1, 2, 3]\\nobserve(arr)\\n```\\n\\n通过下标获取某个元素和修改某个元素的值。\\n\\n\\n![2.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45e88fc475894eb6b50bcd1b9acea689~tplv-k3u1fbpfcp-watermark.image?)\\n\\n可以看到，通过下标获取某个元素会触发 `getter` 方法, 设置某个值会触发 `setter` 方法。\\n\\n接下来，我们再试一下数组的一些操作方法，看看是否会触发。\\n\\n**数组的 push 方法**\\n\\n![3.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c0a2f81e013b4857a6ab9ae261fb9be8~tplv-k3u1fbpfcp-watermark.image?)\\n\\npush 并未触发 setter 和 getter方法，数组的下标可以看做是对象中的 key ，这里 push 之后相当于增加了下索引为 3 的元素，但是并未对新的下标进行 observe ，所以不会触发。\\n\\n> 我们的结论是：Object.defineProperty是有监控数组下标变化的能力的。<br />\\n> push是新增，我们的监控是原有数组下标的变化。所以push不会触发get、set。\\n\\n\\n**数组的 unshift 方法**\\n\\n\\n![6.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8fddf3f3b12e4728969dce42246fca48~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n![5.jpg](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a20323f5b424e25b2000c4562594653~tplv-k3u1fbpfcp-watermark.image?)\\n\\n发生了什么？\\n\\n🙋🏻‍♂️unshift 往数组前面添加操作会导致原来索引为 0、1、2、3 的值发生变化，这就需要将原来索引为 0、1、2、3 的值取出来，然后重新赋值，所以取值的过程触发了 getter ，赋值时触发了 setter。\\n\\n整个解析过程是这样子的：\\n\\n🍅结合上图好好看，可以理解的。\\n\\n```\\n原数组：[1, 2, 3]\\n1的索引是0；\\n2的索引是1；\\n3的索引是2；\\npush添加了4，他的索引是3；\\n\\nunshift往头添加0；\\n原本的索引0、1、2、3 的值发生变化，因为第一位的索引变了，影响第二个，类推\\n这就需要将原来索引为 0、1、2、3 的值取出来，然后重新赋值，期间触发get、set\\n\\n因为unshift头部添加了0，所以0的索引是0； -> key: 0, value：0\\n原本1的索引从0变成了1 -> key: 1, value：1\\n原本2的索引从1变成了2 -> key: 2, value：2\\n\\n我们可以看到符合上面的图set的输出。\\n\\n至于上图get的输出，是将值取出来触发。\\n```\\n\\n至于数组3的值怎么没有打印出来，因为`Object.defineProperty`监控是**原有**数组下标的变化。后面下标的变化与我无关。\\n\\n\\n下面我们尝试通过索引获取一下对应的元素：\\n\\n\\n![7.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d9cb7acc0d84ffd90859d285cbe919a~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n只有索引为 0、1、2 的属性才会触发 getter 。\\n\\n这里我们可以对比对象来看，arr 数组初始值为 [1, 2, 3]，即只对索引为 0，1，2 执行了 observe 方法，所以无论后来数组的长度发生怎样的变化，依然只有索引为 0、1、2 的元素发生变化才会触发。其他的新增索引，就相当于对象中新增的属性，需要再手动 `observe` 才可以。\\n\\n\\n\\n**数组的 pop 方法**\\n\\n当移除的元素为引用为 2 的元素时，会触发 getter 。\\n\\n![8.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5bf0b33aed31408cb4f4762ecb1edb1e~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n删除了索引为 2 的元素后，再去修改或获取它的值时，不会再触发 setter 和 getter 。\\n\\n![9.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/53efa0f8f7ce4ba1a58e7231bdda7160~tplv-k3u1fbpfcp-watermark.image?)\\n\\n这和对象的处理是同样的，数组的索引被删除后，就相当于对象的属性被删除一样，不会再去触发 `observe`。\\n\\n所以面试官问`Object.defineProperty`，他本身能不能监控到数组下标的变化？\\n\\n**答案是有监控数组下标变化的能力的，只是 Vue2.x 放弃了这个特性。**\\n\\n* 通过索引访问或设置对应元素的值时，可以触发 getter 和 setter 方法。\\n\\n* 通过 push 或 unshift 会增加索引，对于新增加的属性，需要再手动初始化才能被 observe。\\n\\n* 通过 pop 或 shift 删除元素，会删除并更新索引，也会触发 setter 和 getter 方法。\\n\\n\\n🍅`Object.defineProperty` 在数组中的表现和在对象中的表现是一致的，数组的索引就可以看做是对象中的 key。\\n\\n\\n![10.jpg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97443f0ed9914826bf40f3b8435b56da~tplv-k3u1fbpfcp-watermark.image?)\\n\\n可以哦，细狗。\\n\\n## 三、回：Vue3如何解决Vue2的痛点？\\n\\n小插曲细品，让我们回归正题。\\n\\n接着，说一下Vue3的性能更好，怎么解决无法监听数组变化问题？\\n\\n我们可以从以下几点回答：\\n\\n* Vue2.x 通过给每个对象添加`getter setter`属性去改变对象，实现对数据的观测；\\n\\n* Object.defineProperty 和 `Proxy` 本质差别是，defineProperty 只能对属性进行劫持，所以出现了需要递归遍历，新增属性需要手动 `Observe` 的问题。\\n\\n* Vue3.x 通过 Proxy 代理目标**对象**,且一开始只代理最外层对象,嵌套对象lazy by default（惰性监听） ,性能会更好（ Proxy可以直接监听对象而非属性）\\n\\n* 数据响应式系统全语言特性支持，添加数组索引修改监听，对象的属性增加和删除。（Proxy可以直接监听数组的变化）\\n\\n* Proxy有多达13种拦截方法,不限于apply、ownKeys、deleteProperty、has等等是Object.defineProperty不具备的。\\n\\n\\n### 3.1 Proxy只会代理对象的第一层，那么Vue3怎么对深层级进行监听呢？\\n\\n判断当前`Reflect.get`的返回值是否为`Object`，如果是则再通过reactive方法做代理， 这样就实现了深度观测。\\n\\n\\n\\n### 3.2 监测数组的时候可能触发多次get/set，那么如何防止触发多次呢？\\n\\n我们可以判断key是否为当前被代理对象target自身属性，也可以判断旧值与新值是否相等，只有满足以上两个条件之一时，才有可能执行触发。\\n\\n\\n### 3.3 Proxy属性讲解\\n\\n\\n```\\nconst person = { name: '阿呱' }\\n\\nconst proxyPerson = new Proxy(person, {\\n    get(target, key, receiver) {\\n        console.log(target) // 原来的person\\n        console.log(key) // 属性名\\n        console.log(receiver) // 代理后的proxyPerson\\n    },\\n    set(target, key, value, receiver) {\\n        console.log(target) // 原来的person\\n        console.log(key) // 属性名\\n        console.log(value) // 设置的值\\n        console.log(receiver) // 代理后的proxyPerson\\n    }\\n})\\n\\nproxyPerson.name // 访问属性触发get方法\\n\\nproxyPerson.name = 'Dignity' // 设置属性值触发set方法\\n```\\n\\n\\n![12.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/19fe65da69634944aee61cfad3ab4bea~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n\\n其实Proxy是搭配Reflect的。\\n\\n\\n来个例子🌰，感受下Proxy的强大吧。\\n\\n```\\nconst data = { name: '阿呱' }\\n\\nfunction reactive(target) {\\n  const handler = {\\n    get(target, key, receiver) {\\n      console.log(`访问了${key}属性`)\\n      return Reflect.get(target, key, receiver)\\n    },\\n    set(target, key, value, receiver) {\\n      console.log(`${key}由->${target[key]}->设置成->${value}`)\\n      Reflect.set(target, key, value, receiver)\\n    }\\n  }\\n\\n  return new Proxy(target, handler)\\n}\\n\\nconst proxyData = reactive(data)\\n\\nconsole.log(proxyData.name)\\n// 访问了name属性\\n// 阿呱\\nproxyData.name = 'Dignity'\\n// name由->阿呱->设置成->Dignity\\nconsole.log(proxyData.name)\\n// 访问了name属性\\n// Dignity\\n```\\n\\n关键的来了，那就是对象新增属性，来看看效果吧：\\n\\n```\\nproxyData.do = '打羽毛球'\\nconsole.log(proxyData.do)\\n// 访问了do属性\\n// 打羽毛球\\nproxyData.do = '打篮球'\\n// do由->打羽毛球->设置成->打篮球\\nconsole.log(proxyData.do)\\n// 访问了do属性\\n// 打篮球\\n```\\n\\n可以看到，Proxy对新增的do属性也进行监听管理，一视同仁。\\n\\n而`Object.defineProperty`新来的不管，管不了那么多。\\n\\n![11.jpg](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e7a561f8988a44bb91e0aad09f694125~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n### 3.4 Reflect属性讲解\\n\\n在这列举Reflect的两个方法：\\n\\n-   get(target, key, receiver)：访问target的key属性，但是this是指向receiver，所以实际是访问的值是receiver的key的值，但是这可不是直接访问receiver[key]属性\\n\\n-   set(target, key, value, receiver)：设置target的key属性为value\\n\\n\\n上面提到，不能直接receiver[key]或者receiver[key] = value，而是要通过Reflect.get和Reflect.set，绕个弯去访问属性或者设置属性，这是为啥呢？下面咱们举个反例\\n\\n```\\nconst person = { name: '阿呱' }\\n\\nconst proxyPerson = new Proxy(person, {\\n    get(target, key, receiver) {\\n        return Reflect.get(receiver, key) // 相当于 receiver[key]\\n    },\\n    set(target, key, value, receiver) {\\n        Reflect.set(receiver, key, value) // 相当于 receiver[key] = value\\n    }\\n})\\n\\nconsole.log(proxyPerson.name)\\n\\nproxyPerson.name = 'Dignity' \\n// 会直接报错，栈内存溢出 Maximum call stack size exceeded\\n```\\n\\n因为上面的get，返回`Reflect.get(receiver, key)`相当于`receiver[key]`，又触发到get方法，所以直接就死循环报错了。\\n\\n🍅Proxy搭配Reflect主要是为了语义化，而且方法都一一对应。\\n\\n-   Proxy的get对应Reflect.get\\n-   Proxy的set对应Reflect.set\\n\\n\\n🙋为啥尽量把this放在receiver上，而不放在target上？\\n\\n🙋🏻‍♂️因为原对象target有可能本来也是是另一个代理的代理对象，所以如果this一直放target上的话，出bug的概率会大大提高。\\n\\n> 其实回答到这里，已经回答得不错了。奖励兄弟们鸡腿🍗<br />\\n> 但如果可以再补充一下响应式原理，那将是锦上添花🌷呀~<br />\\n> 对面试官别紧张，就像好朋友，想到什么就聊什么，扩展题。<br />\\n> 相信面试官也是有朋自远方来，不亦乐乎的心态对待我们。\\n\\n\\n## 四、扩展：阐述MVVM响应式原理？\\n\\n这其实也是另外的一道面试题。\\n\\n只不过我们在回答到关于响应式的时候，顺便一提，我们要将自己掌握的东西全盘托出在面试中表现出来。（当然，要紧扣题，不要回答一些无关紧要的知识点）\\n\\n让面试官看，这就是我的实力。\\n\\n\\n![18.jpg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cee753cae9c9405a8fe3ce1a4b3c4579~tplv-k3u1fbpfcp-watermark.image?)\\n\\n### 4.1 原理\\n\\nVue 内部通过 `Object.defineProperty`方法属性拦截的方式，把`data` 对象里每个数据的读写转化成 `getter/setter`，当数据变化时通知视图更新。\\n\\n🙋那他是怎么进行依赖收集的呢？\\n\\n🙋🏻‍♂️其内部定义了一个依赖收集器叫`Dep`。\\n\\n-   vue将`data`初始化为一个`Observer`并对对象中的每个值，重写了其中的get、set，data中的每个`key`，都有一个独立的依赖收集器。\\n\\n-   在`get`中，向依赖收集器添加了监听。\\n\\n-   在`mount`时，实例了一个`Watcher`，将收集器的目标指向了当前`Watcher`。\\n\\n-   在`data`值发生变更时，触发`set`，触发了依赖收集器中的所有监听的更新，来触发`Watcher.update`。\\n\\n\\n\\n### 4.2 MVVM\\n\\nMVVM 数据双向绑定主要是指：数据变化更新视图，视图变化更新数据。\\n\\n![13.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5c40b4eecda48dd93fb8a179af15594~tplv-k3u1fbpfcp-watermark.image?)\\n\\n即：\\n\\n-   输入框内容变化时，`Data` 中的数据同步变化。即 `View => Data` 的变化。（通过事件监听的方式实现）\\n\\n-   `Data` 中的数据变化时，文本节点的内容同步变化。即 `Data => View` 的变化。\\n\\n本文主要讨论如何根据 `Data` 变化更新 `View`。\\n\\n我们会通过实现以下 4 个步骤，来实现数据的双向绑定：\\n\\n* 实现一个**监听器** `Observer` ，用来劫持并监听所有属性，如果属性发生变化，就通知订阅者；\\n\\n* 实现一个**订阅器** `Dep`，用来收集订阅者，对监听器 `Observer` 和 订阅者 `Watcher` 进行统一管理；\\n\\n* 实现一个**订阅者** `Watcher`，可以收到属性的变化通知并执行相应的方法，从而更新视图；\\n\\n* 实现一个**解析器** `Compile`，可以解析每个节点的相关指令，对模板数据和订阅器进行初始化。\\n\\n\\n![14.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/618cdf9ffb62459a9d0879cb4bb805d1~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n下面让我们详细讲解一下监听器Observer、订阅器Dep、订阅者Watcher、解析器Compile分别做了什么。\\n\\n### 4.3 监听器Observer\\n\\n监听器 `Observer` 的实现，主要是指让数据对象变得“可观测”，即每次数据读或写时，我们能感知到数据被读取了或数据被改写了。要使数据变得“可观测”，Vue 2.0 源码中用到 `Object.defineProperty()` 来劫持各个数据属性的 `setter / getter`。\\n\\n\\n> Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。\\n\\n```\\n/**\\n  * 循环遍历数据对象的每个属性\\n  */\\nfunction observable(obj) {\\n    if (!obj || typeof obj !== 'object') {\\n        return;\\n    }\\n    let keys = Object.keys(obj);\\n    keys.forEach((key) => {\\n        defineReactive(obj, key, obj[key])\\n    })\\n    return obj;\\n}\\n\\n/**\\n * 将对象的属性用 Object.defineProperty() 进行设置\\n */\\nfunction defineReactive(obj, key, val) {\\n    Object.defineProperty(obj, key, {\\n        get() {\\n            console.log(`${key}属性被读取了...`);\\n            return val;\\n        },\\n        set(newVal) {\\n            console.log(`${key}属性被修改了...`);\\n            val = newVal;\\n        }\\n    })\\n}\\n```\\n\\n### 4.4 订阅器 Dep\\n\\n发布-订阅模式又叫**观察者模式**，它定义对象间的一种一对多的依赖关系，当一个对象的状态改变时，所有依赖于它的对象都将得到通知。\\n\\n我们需要先将所有依赖收集起来，一旦数据发生变化，就统一通知更新。其实，这就是前一节所说的“发布订阅者”模式，数据变化为“发布者”，依赖对象为“订阅者”。\\n\\n> 曾经面试官问过我，**你知道哪些设计模式，Vue中有用到哪些设计模式**？<br />\\n> 我们可以回答：<br />\\n> Vue在响应式内，使用了**发布订阅模式**也就是观察者模式，用到这个模式主要是想将所有依赖收集起来，作为**订阅者**，数据变化就通知所有依赖者，数据变化这个过程称为**发布者**。\\n\\n现在，我们需要创建一个依赖收集容器，也就是消息订阅器 `Dep`，用来容纳所有的“订阅者”。订阅器 Dep 主要负责收集订阅者，然后当数据变化的时候后执行对应订阅者的更新函数。\\n\\n创建消息订阅器 `Dep`:\\n\\n```javascript\\nfunction Dep () {\\n    this.subs = [];\\n}\\nDep.prototype = {\\n    addSub: function(sub) {\\n        this.subs.push(sub);\\n    },\\n    notify: function() {\\n        this.subs.forEach(function(sub) {\\n            sub.update();\\n        });\\n    }\\n};\\nDep.target = null;  // 留下伏笔，下面回答为什么要设为null\\n```\\n\\n有了订阅器，我们再将 `defineReactive` 函数（上面【4.3 监听器Observer】的监听器一个方法）进行改造一下，向其植入订阅器：\\n\\n```javascript\\ndefineReactive: function(data, key, val) {\\n    var dep = new Dep();\\n    Object.defineProperty(data, key, {\\n        enumerable: true,\\n        configurable: true,\\n        get: function getter () {\\n            if (Dep.target) {\\n                dep.addSub(Dep.target);\\n            }\\n            return val;\\n        },\\n        set: function setter (newVal) {\\n            if (newVal === val) {\\n                return;\\n            }\\n            val = newVal;\\n            dep.notify();\\n        }\\n    });\\n}\\n```\\n\\n从代码上看，我们设计了一个订阅器 Dep 类，该类里面定义了一些属性和方法，这里需要特别注意的是它有一个静态属性 `Dep.target`，这是一个全局唯一 的`Watcher`，因为在同一时间只能有一个全局的 Watcher被计算，另外它的自身属性 `subs` 也是 Watcher 的数组。（请结合以上代码观看理解）\\n\\n**为什么在订阅器 `Dep`类后面还要设置`Dep.target = null`？**\\n\\n订阅者`watchs`会先将自身的`this`赋值给`Dep.target`，这样就会走进`get`往dep添加sub，即`dep.addSub()`\\n\\n想要添加到订阅器中，后面添加完记得将`Dep.target`设置为`null`，不然每次都会走进`get`往dep添加sub（因为Dep.target有值会进入）\\n\\n> 懂了吧，就是怕重复push。\\n\\n\\n\\n![15.jpeg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0999c8fa38bf41e9afe95ab1b86b2129~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n### 4.5 订阅者 Watcher\\n\\n订阅者 Watcher 在**初始化**的时候需要将自己添加进订阅器 `Dep` 中，那该如何添加呢？\\n\\n我们已经知道监听器Observer 是在 get 函数执行了添加订阅者 Wather 的操作的，所以我们只要在订阅者 Watcher 初始化的时候触发对应的 get 函数去执行添加订阅者操作即可。\\n\\n🙋那要如何触发 get 的函数？\\n\\n🙋🏻‍♂️再简单不过了，只要获取对应的属性值就可以触发了，核心原因就是因为我们使用了 `Object.defineProperty()` 进行数据监听。\\n\\n这里还有一个细节点需要处理，我们只要在订阅者 `Watcher` 初始化的时候才需要添加订阅者，所以需要做一个判断操作，因此可以在订阅器上做一下手脚：在 `Dep.target` 上缓存下订阅者，添加成功后再将其去掉就可以了。\\n\\n**订阅者** `Watcher` 的实现如下：\\n\\n```javascript\\nfunction Watcher(vm, exp, cb) {\\n    this.vm = vm;\\n    this.exp = exp;\\n    this.cb = cb;\\n    this.value = this.get();  // 将自己添加到订阅器的操作\\n}\\n\\nWatcher.prototype = {\\n    update: function() {\\n        this.run();\\n    },\\n    run: function() {\\n        var value = this.vm.data[this.exp];\\n        var oldVal = this.value;\\n        if (value !== oldVal) {\\n            this.value = value;\\n            this.cb.call(this.vm, value, oldVal);\\n        }\\n    },\\n    get: function() {\\n        Dep.target = this; // 全局变量 订阅者 赋值\\n        let value = this.vm.data[this.exp]  // 强制执行监听器里的get函数\\n        Dep.target = null; // 全局变量 订阅者 释放\\n        return value;\\n    }\\n};\\n```\\n\\n对以上订阅者 Watcher 代码分析：\\n\\n订阅者 Watcher 是一个 类，在它的**构造函数**中，定义了一些属性：\\n\\n-   `vm`：一个 Vue 的**实例对象**；\\n-   `exp`：是 node 节点的 v-model 等指令的属性值 或者插值符号中的**属性**。<br />如： `v-model=\\\"name\\\"`，exp 就是name;\\n-   `cb`：是 Watcher 绑定的**更新函数**;\\n\\n\\n当我们去实例化一个渲染 watcher 的时候，首先进入 watcher 的构造函数逻辑，就会执行它的 this.get() 方法，即构造函数中：`this.value = this.get()`。\\n\\n进入 get 函数，首先会执行：\\n\\n> Dep.target = this; // 将自己赋值为全局的订阅者\\n\\n实际上就是把 Dep.target 赋值为当前的渲染 watcher ,接着又执行了：\\n\\n> let value = this.vm.data[this.exp] <br >\\n> // 强制执行监听器里的get函数，因为你获取data的值了\\n\\n\\n在这个过程中会对 `vm` 上的数据访问，其实就是为了触发数据对象的 `getter`。\\n\\n每个对象值的 getter 都持有一个 `dep`，在触发 getter 的时候会调用 `dep.depend()` 方法，也就会执行`this.addSub(Dep.target)`，即把当前的 watcher订阅者 订阅到这个数据持有的 dep 的 watchers 中，这个目的是为后续数据变化时候能通知到哪些 watchers 做准备。\\n\\n> 简而言之，就是想把订阅者添加到订阅器中，方便到时候订阅器统一通知订阅者更新。\\n\\n\\n这样实际上已经完成了一个依赖收集的过程。那么到这里就结束了吗？其实并没有，完成依赖收集后，还需要把 Dep.target 恢复成上一个状态，即：\\n\\n> Dep.target = null; // 释放自己\\n\\n\\n而 `update()` 函数是用来当数据发生变化时调用 `Watcher`订阅者 自身的更新函数进行更新的操作。\\n\\n先通过Watcher订阅者的`run`方法中： `let value = this.vm.data[this.exp];` 获取到最新的数据，然后将其与之前 get() 获得的旧数据进行比较，如果不一样，则调用更新函数 `cb` 进行更新。\\n\\n\\n\\n\\n### 4.6 解析器 Compile\\n\\n通过监听器 Observer 订阅器 Dep 和订阅者 Watcher 的实现，其实就已经实现了一个双向数据绑定的例子。\\n\\n但是整个过程都没有去解析 `dom` 节点，而是直接固定某个节点进行替换数据的，所以接下来需要实现一个解析器 `Compile` 来做解析和绑定工作。解析器 Compile 实现步骤：\\n\\n-   解析模板指令，并替换模板数据，初始化视图；\\n-   将模板指令对应的节点绑定对应的更新函数，初始化相应的订阅器；\\n\\n我们下面对 `'{{变量}}'` 这种形式的指令处理的关键代码进行分析，感受解析器 Compile 的处理逻辑，关键代码如下：\\n\\n```\\ncompileText: function(node, exp) {\\n\\tvar self = this;\\n\\tvar initText = this.vm[exp]; // 获取属性值\\n\\tthis.updateText(node, initText); // dom 更新节点文本值\\n      // 将这个指令初始化为一个订阅者，后续 exp 改变时，就会触发这个更新回调，从而更新视图\\n\\tnew Watcher(this.vm, exp, function (value) { \\n\\t\\tself.updateText(node, value);\\n\\t});\\n}\\n```\\n\\n> 多看几遍，以咱超群的智商，是可以懂的👍。\\n\\n\\n\\n## 五、扩展：自己对响应式的理解？\\n\\n你都把响应式原理和面试官吹了，不得说一下自己的理解？\\n\\n我知道大家意犹未尽，那我们再说一下自己的理解吧。\\n\\n我个人觉得可以从以下五个方面去回答。\\n\\n* 响应式是什么？\\n\\n* 为什么需要响应式？\\n\\n* 它能给我们带来什么好处？\\n\\n* vue的响应式是怎么实现的？有哪些优缺点？\\n\\n* vue3中的响应式的新变化\\n\\n\\n### 回\\n\\n#### 第一：是什么\\n\\n所谓数据响应式就是**能够使数据变化可以被检测并对这种变化做出响应的机制**。\\n\\n#### 第二：为什么需要响应式\\n\\nMVVM框架中要解决的一个核心问题是连接数据层和视图层，通过**数据驱动**应用，数据变化，视图更新，要做到这点的就需要对数据做响应式处理，这样一旦数据发生变化就可以立即做出更新处理。\\n\\n#### 第三：有什么好处\\n\\n以vue为例说明，通过数据响应式加上虚拟DOM和`patch`算法，开发人员只需要操作数据，关心业务，完全不用接触繁琐的DOM操作，从而大大提升开发效率，降低开发难度。\\n\\n> 对于patch，后期会出一篇文章。\\n\\n#### 第四：实现、优缺点\\n\\nvue2中的数据响应式会根据数据类型来做不同处理。\\n\\n如果是**对象则采用Object.defineProperty()** **的方式定义数据拦截，当数据被访问或发生变化时，我们感知并作出响应；如果是** **数组则通过覆盖数组对象原型的7个变更方法**，使这些方法可以额外的做更新通知，从而作出响应。这种机制很好的解决了数据响应化的问题。\\n\\n但在实际使用中也存在一些缺点：比如初始化时的递归遍历会造成性能损失；新增或删除属性时需要用户使用`Vue.set/delete`这样特殊的api才能生效；对于es6中新产生的Map、Set这些数据结构不支持等问题。\\n\\n#### 第五：vue3变化\\n\\n为了解决这些问题，vue3重新编写了这一部分的实现：利用ES6的`Proxy`代理要响应化的数据，它有很多好处，编程体验是一致的，不需要使用特殊api，初始化性能和内存消耗都得到了大幅改善；另外由于响应化的实现代码抽取为独立的`reactivity`包，使得我们可以更灵活的使用它，第三方的扩展开发起来更加灵活了。\\n\\n\\n## 六、扩展：v-model其实响应式的一个实践\\n\\n聊到响应式，可以再聊一下，其实v-model也是绑定一个响应式数据到视图的操作。\\n\\ninput输入框监听`input`事件修改值，通过`Object.defineProperty`劫持数据发生的改变，如果数据发生改变了（在set进行赋值的），触发`update`方法进行更新节点的内容（{{str}}），从而实现了数据双向绑定的原理。\\n\\n详细问题回答在[实战v-model如何绑定多循环表达式(内含原理)](https://juejin.cn/post/7166786222419869732/#heading-11)\\n\\n\\n\\n![16.jpeg](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4b8a7d80d6f4f5b91fe7c083f42d19b~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n\\n\\n面试官摸了摸胡子，顺便摸了摸我那八块腹肌，明天来报道。\\n\\n\\n\\n\\n## 后记\\n\\n所以知道为什么同样的问题，有的人可以拿10k，有的可以拿20k，看你是敷衍的回答还是深层的回答，都是在面试过程中贴上标签了，中级还是高级。\\n\\n最后，祝君能拿下满意的offer。\\n\\n\\n\\n\\n\\n> 👍 如果对您有帮助，您的点赞是我前进的润滑剂。\\n\\n\\n\\n## 以往推荐\\n\\n [靓仔，说一下keep-alive缓存组件后怎么更新及原理？](https://juejin.cn/post/7165675789885636616)\\n\\n [面试官问我watch和computed的区别以及选择？](https://juejin.cn/post/7163447762053251109)\\n \\n [面试官问我new Vue阶段做了什么？](https://juejin.cn/post/7164563220714225695)\\n \\n [前端仔，快把dist部署到Nginx上](https://juejin.cn/post/7022812216848023560)\\n \\n [多图详解，一次性啃懂原型链（上万字）](https://juejin.cn/post/7010942653915201543)\\n\\n [Vue-Cli3搭建组件库](https://juejin.cn/post/6890116253449453575)\\n\\n [Vue实现动态路由（和面试官吹项目亮点）](https://juejin.cn/post/6872344841293037582)\\n\\n [项目中你不知道的Axios骚操作（手写核心原理、兼容性）](https://juejin.cn/post/6863745313711226887)\\n\\n [VuePress搭建项目组件文档](https://juejin.cn/post/6854573219773415437)\\n\\n \\n ## 相关文献\\n \\n [为什么Vue3.0不再使用defineProperty实现数据监听？](https://mp.weixin.qq.com/s/O8iL4o8oPpqTm4URRveOIA)\\n \\n [林三心画了8张图，最通俗易懂的Vue3响应式核心原理解析](https://juejin.cn/post/7001999813344493581)\\n\\n\\n## 原文链接\\n\\n[https://juejin.cn/post/7168274276787683341#heading-0](https://juejin.cn/post/7168274276787683341#heading-0)\\n\\n\\n\\n\\n",
        "tags": [
            "掘金·金石计划",
            "前端",
            "面试"
        ]
    },
    {
        "article_id": "7189499500925288504",
        "cover_image": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eca339aa3bdf4ec6a676162e07e43804~tplv-k3u1fbpfcp-watermark.image?",
        "title": "还在考虑要不要加入Web3？Web3求职全攻略",
        "brief": "因为在群里经常有人问我 Web3 工作相关的事情，我回答了一遍又一遍，可每次有新群友加入，又会把这个问题重新问我一遍。 所以我决定帮群友写一篇文章，这样可以帮助后面新入群的朋友指点迷津，同时又避免了重",
        "user_name": "代码与野兽",
        "view_count": 3124,
        "collect_count": 79,
        "comment_count": 10,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/dac9f5ba3e7b6d8015a9b37536d4ef59~300x300.image",
        "category": "前端",
        "content": "因为在群里经常有人问我 Web3 工作相关的事情，我回答了一遍又一遍，可每次有新群友加入，又会把这个问题重新问我一遍。\\n\\n所以我决定帮群友写一篇文章，这样可以帮助后面新入群的朋友指点迷津，同时又避免了重复回答相同的问题。提升人生效率。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ffdf5faf4f484c03abade94107fc1044~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n从有这个想法，到抽出时间专心写这篇文章，其实已经拖了一周左右了。\\n\\n下面是本文正文。\\n\\n# Web3 开发者需要学习哪些技能？\\n\\n因为看这篇文章的大部分都是技术型人才，那我就先讲下技术。\\n\\n首先澄清一下技术对 Web3 的重要性如何。Web3 并不像 Web2 那样，技术占比那么高。其实在 Web3 里面，技术没那么重要。这是一定要认清的一项原则。\\n\\n在之前我写了 N 篇介绍 Web3 技术的文章，这次我一切从简，只介绍必不可少的几项技术。\\n\\nWeb3 中的主要编程语言只有两种：solidity 和 javascript。\\n\\nsolidity 的作用是编写智能合约和区块链交互。\\n\\njavascript 的作用是为了编写各种脚本来测试、编译、部署智能合约。同时 javascript 也可以作为后端编写 API，也可以作为前端与 solidity 的 abi 进行交互。\\n\\n也就是说，web3 最小技术成本就只有这两门语言而已。其他像 Go、Rust 等等语言都不是必须的。\\n\\n学完了这两门语言，就是一些框架和开发工具。有很多选择可以选。我比较常用的一套技术栈是 openzeppelin、turffle、nextjs、ethersjs、wagmi 等。不过你可以选择其他的组合，它们都大同小异。\\n\\n学习完语言和框架之后，就是尝试实现一些小项目，比如如何发币；如何发 NFT；如何写空投合约、荷兰拍合约等等。\\n\\n你可能会说我遗忘了区块链。OK，区块链确实很重要，是智能合约的基础。但你要知道，在你工作中有 90% 的可能性都不会直接编写区块链的代码，除非你在开发区块链。快速搞懂区块链原理就可以了，不需要在这上面花费太多时间。\\n\\n我开发了一个网站，里面包含了一堆从零实现的项目，你可以学习一下。\\n\\n线上预览地址：[www.webnext.cloud/](https://link.juejin.cn/?target=https%3A%2F%2Fwww.webnext.cloud%2F)\\n\\nGitHub 地址：<https://github.com/luzhenqian/web3-examples>\\n\\n以防万一，你可以点个 star。或者这将会是你获得 10 万月薪的一次重要机会。\\n\\n如果你学完并精通了上述技能，那你算是一个初级 Web3 开发者了，可以尝试去找一些工作。但通常很难拿到 5 万以上的薪水，即使是在 other countries 的公司。\\n\\n那么一个中高级的 Web3 开发者应该具备什么样的能力呢？\\n\\n其实编程语言和框架还是上述的那些，更多的是经验。这些经验主要体现在两点上：合约安全和 gas 优化。\\n\\nWeb3 和 Web2 的一大区别是，合约一旦部署就几乎不能再修改。这样一份有漏洞的合约就非常危险了。有一帮人专门靠检查合约漏洞赚饭钱的。这就像 20 年前做网站入侵的黑客一样。所以合约安全至关重要。\\n\\n另一部分就是 gas 优化，如何合理地设计合约状态与函数非常重要。\\n\\n# Web3 公司有哪些职位？\\n\\nWeb3 中的职位与 Web2 类似，我尽量按照收入比例进行排序并介绍：\\n\\n-   VC：老板的老板，最容易赚钱的一帮人。什么都不干。\\n-   founder/co-founder：老板，最容易赚钱的一帮人。什么都干。\\n-   开发者：薪资几乎最高的一帮人。写代码。\\n-   运营：薪资几乎最高的一帮人。市场、营销之类的事情。\\n-   产品：薪资第二阶梯。画图、写文档。\\n-   数分：薪资第二阶梯。不干正事。\\n-   开发者关系：薪资第三阶梯。写写文章、聊聊天、偶尔写写代码。\\n-   设计：薪资第三阶梯。画图。\\n\\n具体做哪个岗位其实不是特别重要，能做到专家级别的话，钱都少不了。\\n\\n# Web3 公司都在做哪些业务？\\n\\n我按优先级分为以下几类：\\n\\n-   VC：VC 永远是神。新 VC 有 a16z、HashKey Capital、蜻蜓、分布式，老 VC 有红衫、启明、BAI 等等。最难进，但含金量也最高。\\n-   交易所：交易所是食物链最顶端。其中最好的是币安，币安目前的地位就像是云中的 Amazon、搜索引擎中的 Google；其次是 Coinbase 和 OK 这些。但像火币这种就有点坑了。如果能去交易所，那和互联网中曾经的 BAT 差不多，都属于大厂行列。\\n-   公链：公链属于基础设施，是仅次于交易所的存在。最大的公链有 ETH、TRON 和 EOS。国内也有一些大公链，比如 IOST、Steem 等。如果你能去上面提到的这些公司工作，那就像是在 Web2 中去阿里、京东、字节这些大厂工作差不多。\\n-   做市商：做市商和交易所生生相息，所以依托交易所的光明前途，做市商也是一个非常不错的领域。\\n-   NFT 交易所：其实和交易所类似，但交易的主体不是传统加密币，而是 NFT。虽然不如交易所规模大，但还是有相当不小的潜力。一些具有代表性的大公司有 Opensea、Nifty Gateway、VIV3 等。\\n-   钱包：作为每个人都需要的加密钱包，前途自然不差。具有代表性的有 paxos、ledger、metamask 等。\\n-   链游：链游虽然非常有前途，但从 2021 到 2022 的数据变化上看，用户增长比较乏力。所以我认为和上面的几个业务领域相比较，链游属于垫底了。\\n-   DID：如果未来 Web3 社交真正火起来的话，DID 绝对不可限量。但现在 DID 还没办法和上面这些相对成熟的领域去比。\\n-   创业：自己开盘子，或者给开盘子的老板打工。可能是上述业务领域中的一种，也可能是老板自称是他自创的模式。但无论如何都比不上上述的几个赛道。如果是给人打工，那就尽量谈现金，别谈期权。因为创业公司非常依赖项目，而 Web3 项目出了名的不稳定，指不定干几个月公司就凉了，而你的期权啥的估计都锁到 N 年后了，纯属画大饼。虽然这一类垫底，但这一类也是我们最容易接触的一类。\\n\\n# 怎么找 Web3 工作？\\n\\n英语不好的同学，去猎聘、Boss、朋友圈。但国内薪资优势没那么大。只能比同等要求的 Web2 多出 1/3 到 1/2 的样子。\\n\\n英语好的同学，可选择性太多了，比如 [remote3](https://remote3.co/)、[web3.career](https://web3.career/)、[cryptorecruit](https://www.cryptorecruit.com/) 等等。这里有很多年薪 100k 美刀+、甚至 200k 美刀+ 的岗位。如果你的要求更高，想要 300k、400k 的年薪，那只能去一些头部 VC 了。\\n\\n由此可见，英语是多么地重要，英语不好的同学赶紧加油学英语吧。\\n\\n# Web3 的工作模式是怎样的？\\n\\nweb3 的工作大部分都是 remote。打卡上班的真不多。不过国内一线城市（比如上海、北京、杭州）有一些打卡上班的公司。\\n\\n# Web3 项目怎么赚钱？\\n\\n其实我在之前的文章中有提到，Web3 实际上没有什么普遍意义上的价值。\\n\\n所以 Web3 的项目只有两个方向赚钱。一是向上赚投资人的钱，二是向下赚韭菜的钱。\\n\\n赛道就那么几条，每条赛道上存在的问题就那么几个。\\n\\n要么在原有赛道上继续卷，弄一些连自己都不知道逻辑通不通的商业模式糊弄投资人。\\n\\n要么就是开辟一个新的赛道，弄一些看上去很赚钱实际上什么都不是的破项目忽悠一堆韭菜。\\n\\n不过如果你不是创业者，那么不需要操心这些问题。这个产业存在，并且有如此庞大的市场，就有它自身的意义。尽管如今它还远远没达到我们预期的那个样子。\\n\\n投资人和韭菜们都不傻，他们赌的都是一个上限，增长就是他们共同的信仰。\\n\\n不过，这些都不重要，因为它们不影响你去打工赚钱。\\n\\n对，就是这样。与其整天吐槽它，不如加入它。\\n\\n# 在 Web3 公司上班会不会被抓？\\n\\n经常有人问我这个令我哭笑不得的问题。\\n\\n我不能保证，即使在 Web2 公司中该被抓一样会被抓。\\n\\n因为我也在大陆进行 Web3 领域创业，所以会格外关注一些法律和条例，目前主要的一些规定如下：\\n\\n-   2017 年中国人民银行、工信部联合多部门发布的《关于防范代币发行融资风险的公告》（94公告）\\n-   2021 年 3 月 19 日最高人民检察院、中国人民银行发布的《惩治洗钱犯罪典型案例》\\n-   2021 年 9 月 24 日，发改委等11部门联合印发了《关于整治虚拟货币“挖矿”活动的通知》（发改运行〔2021〕1283号）\\n\\n<!---->\\n\\n-   2021 年中国人民银行等《关于进一步防范和处置虚拟货币交易炒作风险的通知》（银发〔2021〕237号）\\n-   2022 年 4 月 13 日中国互联网金融协会、中国银行业协会和中国证券业协会共同发布《关于防范NFT相关金融风险的倡议》\\n\\n除了这些以外，还有一些地方政府颁布的相关条例需要注意。\\n\\n简单来说，只有两个级别，一是监管，二是禁止。\\n\\n监管的可以做，只要别违规。比如挖矿、NFT 交易等。\\n\\n禁止的不可以做，比如洗钱、金融诈骗等。\\n\\n如果是国内的公司，入职之前一定要搞清楚公司到底是做什么的。\\n\\n以上就是我整理完的想转入 Web3 的开发者常见问题。你还有什么问题呢？欢迎提问。\\n\\n我们是一群立志改变世界的人。而 Web3 是未来世界一大变数，我们想帮助更多人了解并加入 Web3，如果你对 Web3 感兴趣，可以添加我的微信：LZQ20130415，邀你入群，一起沉淀、一起成长、一起拥抱未来。",
        "tags": [
            "前端",
            "后端",
            "web3"
        ]
    },
    {
        "article_id": "7179638712035180605",
        "cover_image": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd4b2856364644aca19d105234f139c0~tplv-k3u1fbpfcp-watermark.image?",
        "title": "小城前端开发者的自我成长 「我的2022」",
        "brief": "旧的问题，豁然开朗；新的问题，雨后春笋；告别过去，迎接未来！ 小城前端开发者的自我成长路程......",
        "user_name": "Serenade",
        "view_count": 1359,
        "collect_count": 1,
        "comment_count": 8,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/c3cd5a77cbc032488627519cf3bfd492~300x300.image",
        "category": "前端",
        "content": "「回顾2022，展望2023，我正在参与[2022年终总结征文大赛活动](https://juejin.cn/post/7172462429929111559)」\\n\\n\\n**旧的问题，豁然开朗；新的问题，雨后春笋；告别过去，迎接未来**\\n\\n我是一名前端开发人员，生活在一座三线小城中，恬静安逸的生活让我消退了许多激情。但唯一不变的是我对编程的热爱。\\n\\n### 2022 我的课程\\n\\n- 疫情反复，潜心笃志\\n- 熬更守夜，技术研究\\n- 坚持跑步，矫正身姿\\n- 冥然兀坐，豁然开朗\\n\\n\\n### 上半年\\n\\n大概从三月份到六月份的时间段里，我基本每天都在熬夜。那段时间对我来说是特别充实的，在平静的生活里悄悄自我成长是一件特别幸福的事。我喜欢规划未来，但是更专注于当下。对于我来讲学习技术是目前最重的事情。\\n\\n到了七月份，我对当时的博客网站不是特别满意。于是我自己写了一套博客网站。耗时了一个月，包括了前端展示、后台管理、以及服务端数据处理。当时还想再开发一套Android和IOS，后来感觉精力有限，还需要再继续学习**前端**技术。于是就放弃了这个念想，转头去看书去学习源码了...\\n\\n我写博客的目的是为了自我总结，由于我经验尚浅，所以在学习的路程中，我会做一些记录，仅此而已。\\n\\n- 关于博客实现，主要涉及到了Vue3、TS、React、Express、Tailwindcss、Vite等技术... 在这一个月里，每天下班之后写到凌晨2点左右，虽然比较累但是也很享受。做技术的应该都有体会，就是那种完成之后可能会有小成就的感觉。\\n\\n- 关于UI样式，自己摸索设计的丑是丑了点，之后再升级吧。[博客地址](https://chetserenade.info/) \\n- 关于开源项目，上半年期间还参与了一下开源库的贡献，感觉还是蛮好玩的。一位年轻小哥做的Vue3的UI库。感兴趣的朋友可以看一下，做的很不错。[FightingUI](https://fighting.tianyuhao.cn/)\\n\\n\\n\\n### 下半年\\n\\n下半年，也是我最难熬的时间段，这期间我与相恋三年的伴侣分手了，在分手之后，我一直在自我否定再到自我肯定中渡过。\\n\\n我产生了迷茫焦虑，突然间有点不知所措。于是在接下来的那段时间里，我没有再去继续学习，我在不断给自己找事情做。\\n\\n跑步、看书、追剧、打篮球这些都是我的喜好，我把日程排的很满,让自己不去想这些事情。晚上我会坚持跑步，跑了大概几个月吧。越跑越爽，推荐不经常锻炼的朋友，也尝试一下跑步这项运动。\\n\\n关于感情，这大概是世界上最复杂的问题之一，不过多描述了。下半年也差不多就是这种状态度过的。\\n\\n\\n### 近况\\n\\n目前又回到了学习技术这条轨道上来了，打算年后离职，去一个新的城市。接触一些新项目，努力成为一位优秀的开发者。未来打算继续学习，比如：原理、算法、造一些有意思的小轮子等。我想**一个真正优秀的编程开发人员，应该对计算机科学抱有无限的热忱、无穷的兴趣。一个真正热爱生活的人，应该遵从自己的内心，去做那些真正属于你的事情。** \\n\\n\\n\\n\\n### 代码\\n\\n代码也是一种艺术形式的体现，\\n\\n让代码在机器上跑起来，是技术。\\n\\n让代码组织地清晰合理，易于人们理解，甚至精妙绝伦，是艺术。\\n\\n如果说《7天从入门到精通》是技术，则《Clean Code》就是艺术。\\n\\n形而下学是技术，形而上学是艺术。\\n\\n所以在我的博客签名上有这样一句话，\\n\\n形而上者谓之道，形而下者谓之器。\\n\\n### 终\\n\\n**以上就是我的年终总结，这一年没有太多惊艳，有的只是对技术的揣摩;没有太多奢望，有的只是平淡;岁月如流,长歌如故,保持初心，继续前行。让我们做一个终身学习的 “菜鸟” 吧。**\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
        "tags": [
            "前端",
            "程序员",
            "JavaScript"
        ]
    },
    {
        "article_id": "7174942254249803837",
        "cover_image": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a9fa4dc7460e4af2ae24b9bd4cada2fe~tplv-k3u1fbpfcp-watermark.image?",
        "title": "线框风大屏地图开发，手把手教学",
        "brief": "线框风地图也是大屏常客，线框是什么？线框从哪儿来？线框怎么渲？这是相关开发必须想明白的三个问题。一起看看吧",
        "user_name": "摸鱼的春哥",
        "view_count": 3526,
        "collect_count": 75,
        "comment_count": 14,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/848d36b5efa8e055ab080bff4f27e669~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: Chinese-red\\nhighlight: monokai\\n---\\n本文为稀土掘金技术社区首发签约文章，14天内禁止转载，14天后未获授权禁止转载，侵权必究！\\n\\n## 📖阅读本文，你将\\n\\n- 学会收集省市区各级别的地理数据（`GeoJSON`）\\n- 学会组织数据，并开发一款 **线框风** 大屏地图\\n- 提供源码\\n\\n> 需要注意的是，在任何公共场所展示中国地图，需要严格注意南海九段线、群岛、藏南地区等各种地图细节，容易踩坑。因此本文不进行全局中国地图的展示，会以 **湖北省** 作为用例展示 **线框风** 开发示例。\\n\\n（但是没问题，我会提供中国地图的开发注意事项，保证你开发出能实际生产使用的中国地图的 **线框风** 大屏地图）\\n\\n## 前情提要\\n\\n在本专栏的上一篇文章[《大屏地图：从瓦片到引擎，到手把手实战》](https://juejin.cn/post/7171275204801331214) 中，我们提到：\\n\\n> 在各种各样场景的大屏开发中，关于地图的展示，一般存在两种常见的玩法: **瓦片风** 和 **线框风**。\\n\\n上一篇文章也详细介绍了如何用 `maplibre-gl` 这个库进行瓦片风地图的开发，那么，本篇文章将引领你进行 **线框风** 地图的实战开发。\\n\\n## 一、分析：如何开发 **线框风** 地图\\n\\n让我们看一看，目前市面上常见的 **线框风** 地图大多长什么样子吧：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad48e4161e9b41f5be610b87dfd20285~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n当然，更多的是一整张中国地图。\\n\\n你会发现，线框风地图是 **没有瓦片细节** 的。\\n\\n对于它们而言，真正核心的是 **区域的形状**。\\n\\n而在之前课程里面，我们学习过，地图上形状表达的文件格式是：`GeoJSON`。\\n\\n> 是的，凡你所见的每一个多边形，都是 `GeoJSON` 所描述的点勾勒而成。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ef5aa189e3f4728894f8ee4be71cae1~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n每一个你能看到的多边形，把它转换为 `GeoJSON` 对象，都可以理解为是一个多边形 （`Polygon`） 类别或者 `MultiPolygon` 类别的 `Feature`。\\n\\n因此，这一张线框风地图，其实是一个  `FeatureCollection` 类别的 `GeoJson` 对象。\\n\\n有了这个认识，我们就可以从容梳理出，渲染一个基础版本的 **线框风** 的大屏地图，其实只需要这两部：\\n\\n1. 找到准确适合的 `GeoJSON` 。\\n2. 把 `GeoJSON` 渲染出来。\\n\\n## 二、找到准确适合的 `GeoJSON`\\n\\n### 2.1 统一行政区划代码\\n\\n在哪里能找到我国所有区域，**最新最准确最全面的** 统一行政区划代码？\\n\\n答案当然是：[《中华人民共和国民政部-2020年1月中华人民共和国县以上行政区划代码》](https://www.mca.gov.cn/article/sj/xzqh/2020/2020/202003061536.html)\\n\\n这是我找到的 `2020/01` 发布的标准；但在此之后，相关标准有过变动，作为生产使用时，需要参照这个页面的相关变更：\\n\\n[2021年中华人民共和国行政区划代码 变更参照](https://www.mca.gov.cn/article/sj/xzqh/1980/202203/20220300040708.shtml)\\n\\n但是，为了获取最新最准确的列表，我们也可以直接访问 `github` ，通过这个仓库获得全部数据：[https://github.com/modood/Administrative-divisions-of-China](https://github.com/modood/Administrative-divisions-of-China)\\n\\n因为本文我们以 **湖北省** 为例，我随手整理出了如下的 **行政区划代码列表**：\\n\\n```js\\n// code  name  parentCode\\n420000 湖北省 100000\\n420100 武汉市 420000\\n420200 黄石市 420000\\n420300 十堰市 420000\\n420500 宜昌市 420000\\n420600 襄阳市 420000\\n420700 鄂州市 420000\\n420800 荆门市 420000\\n420900 孝感市 420000\\n421000 荆州市 420000\\n421100 黄冈市 420000\\n421200 咸宁市 420000\\n421300 随州市 420000\\n422800 恩施土家族苗族自治州 420000\\n429004 仙桃市 420000\\n429005 潜江市 420000\\n429006 天门市 420000\\n429021 神农架林区 420000\\n```\\n\\n当然，这只是 **湖北省** 一级子区域（市、自治州）级区域。\\n\\n然后，每个 **市、自治州** 也拥有自己的 **县、地级市** 区域，比如武汉：\\n\\n```js\\n// code  name  parentCode\\n420102 江岸区 420100\\n420103 江汉区 420100\\n420104 硚口区 420100\\n420105 汉阳区 420100\\n420106 武昌区 420100\\n420107 青山区 420100\\n420111 洪山区 420100\\n420112 东西湖区 420100\\n420113 汉南区 420100\\n420114 蔡甸区 420100\\n420115 江夏区 420100\\n420116 黄陂区 420100\\n420117 新洲区 420100\\n```\\n\\n由于数据量过于庞大，不在此进行枚举。\\n\\n但基本能确定一个事实：\\n\\n> 通过这种方式，我们能遍历出湖北省区域树上的所有 **标准行政区划代码**。\\n\\n有了这个代码清单，我们才可以进行 **寻找GeoJSON** 的下一步。\\n\\n### 2.2 去哪儿找 `GeoJSON`？\\n\\n当然，你首先可以访问: `github`，通过搜索 `china geojson` 关键词，寻找相关开源分享。\\n\\n除此之外。\\n\\n难道还有比 **商用** 数据更香的吗？\\n\\n访问此链接：`https://geo.datav.aliyun.com/areas_v3/bound/100000.json` 你能看到由 `aliyun dataV` 团队提供的 **中国地理边界** `GeoJSON` 静态数据。\\n\\n> 同理，如果我们访问 `https://geo.datav.aliyun.com/areas_v3/bound/420000.json` 就能访问到 **湖北省地理边界** 的 `GeoJSON` 数据服务。\\n\\n而我们此前已经得到了 **湖北省** 所有子孙区域的行政区划代码清单，不难想象，我们可以：\\n\\n- 直接使用该源的 `GeoJSON`\\n- 或者手动 （或写脚本） 抓取相关信息完成私有化部署\\n\\n> 当然，爬取商用数据是有法律风险的，因此，我个人，以及本篇文章并不推荐和建议你去写爬取脚本。\\n\\n下面，我们只是出于代码学习探讨的目的，简单列举一个基于 `node.js`的 \\\"爬取脚本\\\" 应该如何实现：\\n\\n新建 `scripts/fetch-geojson.js`:\\n\\n```js\\nconst axios = require('axios');\\n\\n// 这个库需要 yarn add fs-extra 进行安装\\nconst fs = require('fs-extra');\\nconst path = require('path')\\n\\nconst codes = [\\n  420000,\\n  420102,\\n  420103\\n  // 这里是你要爬取的区域代码列表\\n]\\n\\n// 下载后的存储文件夹\\nconst ORIGIN_GEOJSON_DIR = path.resolve(__dirname, '../.temp/origin-geojson')\\n\\n// 请求实现\\nconst getGeojson = async (code) => {\\n  const res = await axios.get(`https://geo.datav.aliyun.com/areas_v3/bound/${code}.json`)\\n  return res.data\\n}\\n\\n// 写入实现\\nconst writeGeojson = async (code, geojson) => {\\n  const fileName = `${code}.json`\\n  const filePath = path.resolve(ORIGIN_GEOJSON_DIR, fileName)\\n  await fs.writeJSON(filePath, geojson)\\n}\\n\\n// 任务组织\\nconst begin = async () => {\\n  await fs.remove(ORIGIN_GEOJSON_DIR)\\n  await fs.ensureDir(ORIGIN_GEOJSON_DIR)\\n  const tasks = codes.map(t => getGeojson(t))\\n  const jsons = await Promise.all(tasks)\\n  const writeTasks = jsons.map((json, index) => writeGeojson(codes[index], json))\\n  await Promise.all(writeTasks)\\n}\\n\\n// 开始\\nbegin()\\n\\n```\\n\\n然后再在 `package.json` 中添加如下代码：\\n\\n```json\\n{\\n  \\\"scripts\\\": {\\n    \\\"fetch-geojson\\\": \\\"node scripts/fetch-geojson.js\\\"\\n  }\\n}\\n\\n```\\n\\n然后执行命令：\\n\\n```bash\\nyarn fetch-geojson\\n```\\n\\n就能完成相关 `GeoJSON` 的下载了。\\n\\n> 理论上：我很强。于是，按照自己这套方法论，我去拉了下 `antv` 的 `GeoJSON` 数据，结果却发现：\\n\\n`antv` 公开的数据里，`421088` 监利市的数据居然是缺失的。\\n\\n> 当然，正统的做法，是去找它轮廓的 `GeoJSON`。但本文是出于演示教学的目的，我直接偷懒给它注释掉了。\\n\\n\\n### 2.3 如何组织 `GeoJSON` 格式？\\n\\n有了 `GeoJSON` 其实并不足以完全支撑我们在业务上的开发，只有当 `GeoJSON` 被良好地组织起来之后，才能使用得更加顺手。\\n\\n前面我们获取到的诸多 `GeoJSON`，它们的格式长这样：\\n\\n```json\\n{\\n  \\\"type\\\": \\\"FeatureCollection\\\",\\n  \\\"features\\\": [\\n    {\\n      \\\"type\\\": \\\"Feature\\\",\\n      \\\"properties\\\": {\\n        \\\"adcode\\\": 420000,\\n        \\\"name\\\": \\\"湖北省\\\",\\n        \\\"center\\\": [\\n          114.298572,\\n          30.584355\\n        ],\\n        \\\"centroid\\\": [\\n          112.271301,\\n          30.987527\\n        ],\\n        \\\"childrenNum\\\": 17,\\n        \\\"level\\\": \\\"province\\\",\\n        \\\"acroutes\\\": [\\n          100000\\n        ],\\n        \\\"parent\\\": {\\n          \\\"adcode\\\": 100000\\n        }\\n      },\\n      \\\"geometry\\\": {\\n        \\\"type\\\": \\\"MultiPolygon\\\",\\n        \\\"coordinates\\\": [\\n          // 省略\\n        ]\\n      }\\n    }\\n  ]\\n}\\n```\\n\\n也就是说，虽然它是一个 `FeatureCollection`，但它只包含一个 `Feature`，能描述的也只是 **湖北省** 的外轮廓。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3668f4e89f1242f7afd2d71839dffc6d~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n如果要满足如上所示的效果，这个 `GeoJSON` 是不足够的。\\n\\n那如果要满足如上效果，最理想的 `GeoJSON` 应该是什么样的呢？\\n\\n```json\\n{\\n  \\\"type\\\": \\\"FeatureCollection\\\",\\n  \\\"features\\\": [\\n    {\\n      \\\"type\\\": \\\"Feature\\\",\\n      \\\"properties\\\": {\\n        \\\"name\\\": \\\"武汉市\\\"\\n        // 其他属性省略\\n      }\\n      // 其他属性省略\\n    },\\n    {\\n      \\\"type\\\": \\\"Feature\\\",\\n      \\\"properties\\\": {\\n        \\\"name\\\": \\\"宜昌市\\\"\\n        // 其他属性省略\\n      }\\n      // 其他属性省略\\n    },\\n    // ...以及其他所有市\\n  ]\\n}\\n```\\n\\n对的，我们要渲染 \\\"湖北省\\\" 的地图时，恰恰并不需要 \\\"湖北省\\\" 本身的轮廓，而是需要它所有子节点的轮廓，这样就能完成拼接，最终渲染出 \\\"湖北省\\\" 的轮廓，以及它各个区域的轮廓；\\n\\n因此，针对获取到的 **原始 `GeoJSON`**, 进行一些 `merge` 操作，就显得非常必要了。\\n\\n现在我们有了各个区域的结构树、有了各个区域本身轮廓的 `GeoJSON`，生成我们需要的结构并不困难，写一个脚本就能完成。\\n\\n> 文末会开源脚本代码，此处不赘述。\\n\\n到这一步，我们就已经获得了 **合适的 `GeoJSON`** 了。\\n\\n## 三、基础地渲染 `GeoJSON` 线框\\n\\n**“渲染 `GeoJSON`”** 是几乎所有地图引擎都具备的能力，因为上一篇文章是通过 `maplibre-gl` 进行的 **“瓦片风”地图** 开发，那么本文我们将继续使用 `maplibre-gl` 进行 **线框风** 地图开发。\\n\\n因此，轮廓的渲染，是简单的，还记得我们在上一篇文章[《大屏地图：从瓦片到引擎，到手把手实战》](https://juejin.cn/post/7171275204801331214) 中所做的总结吗？\\n\\n- 得到地图实例\\n- 先添加资源\\n- 再添加图层\\n\\n这一次，我们的思路，依旧如初。\\n\\n### 3.1 得到地图实例\\n\\n因为这一次，我们没有 **瓦片** 的需求，因此地图实例非常容易：\\n\\n> 我们无需任何初始的资源及图层。\\n\\n```js\\n<template>\\n  <div ref=\\\"mapEl\\\" class=\\\"map\\\"></div>\\n</template>\\n<script setup>\\nimport { onMounted, ref } from 'vue'\\nimport maplibregl from 'maplibre-gl'\\nconst mapEl = ref(null)\\nconst initOption = {\\n  style: {\\n    \\\"version\\\": 8,\\n    \\\"id\\\": \\\"43f36e14-e3f5-43c1-84c0-50a9c80dc5c7\\\",\\n    \\\"sources\\\": {},\\n    \\\"layers\\\": [\\n    ]\\n  },\\n}\\n\\nonMounted(() => {\\n  const map = new maplibregl.Map({\\n    container: mapEl.value,\\n    ...initOption,\\n  });\\n})\\n</script>\\n```\\n\\n这样，我们虽然得到了一个地图实例，但它依然不会显示任何内容。\\n\\n此时，我们要做的，就是 **获取到json、添加为资源，显示到图层**。\\n\\n先定义一个通过网络获取 `GeoJSON` 的方法： \\n```js\\nconst fetchGeoJSON = async (areaCode) => {\\n  // 嗯的，如你所见，这是我的个人CDN，你最好不要在生产上使用它\\n  const response = await fetch(`https://pic.zhangshichun.top/geojson/merged/${areaCode}.json`, {\\n    headers: {\\n      'Content-Type': 'application/json'\\n    }\\n  })\\n  return response.json()\\n}\\n```\\n\\n然后添加资源和图层：\\n\\n```js\\nconst hubeiGeoJSON = await fetchGeoJSON(420000)\\nmap.addSource('bound-source', {\\n  type: 'geojson',\\n  data: hubeiGeoJSON\\n})\\nmap.addLayer({\\n  id: 'areas-line',\\n  type: 'line',\\n  source: 'bound-source',\\n  paint: {\\n    'line-color': '#fff',\\n    'line-width': 2\\n  }\\n})\\n```\\n\\n就能看到如下效果了：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f837c908fb7941669637362b98c6ef8f~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n### 3.2 添加区域文本\\n\\n在上面组织 `GeoJSON` 的时候，除了得到各省市区的轮廓之外，我还手动组织了各市区的名称及定位。\\n\\n因此，通过 **获取到json、添加为资源，显示到图层** 三步走，我也能轻易地把地图标注显示出来：\\n\\n```js\\n  const areaNames = await fetchGeoJSON('420000-area-names')\\n  map.addSource('names-source', {\\n    type: 'geojson',\\n    data: areaNames\\n  })\\n  map.addLayer({\\n    id: 'areas-name',\\n    source: 'names-source',\\n    \\\"type\\\": \\\"symbol\\\",\\n    \\\"layout\\\": {\\n      \\\"text-field\\\": '{name}',\\n      \\\"text-size\\\": 8,\\n    },\\n    \\\"paint\\\": {\\n      \\\"text-color\\\": \\\"white\\\",\\n      \\\"text-halo-color\\\": \\\"rgba(0, 0, 0, 0)\\\"\\n    },\\n    filter: ['==', 'parentCode', 420000] // 这里的意思是，我只要湖北省地级市及自治区这一层的名称显示\\n  })\\n```\\n\\n看效果：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4bbae24ddba64526acb7a8ef31e70be4~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n当然，我也贴心地为了你准备了 **码上掘金** 的示例：\\n\\n[代码片段](https://code.juejin.cn/pen/7174196280493604867)\\n\\n在示例中，你可以轻松地旋转、放大、缩小，因为它的本质不是图片，而是在地图引擎上的矢量渲染。\\n\\n## 四、实现下钻\\n\\n以上代码虽然已经实现了基础线框的加载，但它既没有交互，也没有下钻。\\n\\n接下来，让我思考，如何做 **地图下钻** 这一功能：\\n- 监听某个区域的点击事件\\n- 获取到这个区域的 `Code`，获取到对应的 `GeoJSON` 数据\\n- 把新 `GeoJSON` 显示到地图上。\\n\\nok，先说 **点击事件**，这个属于 **框架API**，只要是个健全的地图引擎，一定就具备这种能力，查查文档就能查到，不赘述。\\n\\n再说 **通过 `Code` 请求数据**，这个上面一节已经实现了，也没啥好说的。\\n\\n那么，怎么 **更新GeoJSON到地图** 呢？\\n\\n在 `maplibre-gl` 或者 `mapbox-gl` 的 `API` 思路里，其实很简单：\\n\\n> 更新 **资源** （`Resource`）。\\n\\n因此，原来的三步走，其实可以稍微改变一下，变成四步走：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7007ada283c54683a5a47b518be6a176~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n这种代码组织方式的最大优势就在于：\\n\\n1. 获取 `GeoJSON` 这一异步操作不阻碍图层和资源的注册。\\n2. 第 `3/4` 这两步的操作是可以不停更新执行的，也就是：支持下钻了。\\n\\n因此，我们封装一个方法：`loadArea`，用来动态加载某个区域：\\n\\n```js\\nconst loadArea = async (code) => {\\n  const geoJSON = await fetchGeoJSON(code)\\n  map?.getSource('bound-source').setData(geoJSON)\\n  map?.on('click', fullLayerKey, eventFn);\\n}\\n```\\n\\n再给区域绑定点击事件，就实际上完成最粗糙的 **下钻**：\\n\\n```js\\nmap.on('click', 'areas-surface', (e) => {\\n  const feature = e.features?.[0];\\n  const code = feature?.properties?.adcode;\\n  loadArea(code)\\n})\\n```\\n到码上掘金看看效果：\\n\\n[代码片段](https://code.juejin.cn/pen/7174651610440663044)\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e0ab1b4f52d4de38ed02a7df5e9a862~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n粗糙吗？\\n\\n粗糙，但思路确定好之后，剩下的无非是缝缝补补。\\n\\n- 缝补点A：下钻后地图应该自动放大，到适应边框。\\n- 缝补点B：下钻后，地理信息标注应该更新到下面一级。\\n\\n都不难。\\n\\n**自动放大** 的核心代码：\\n\\n```js\\nconst fitBounds = (feature, options = {}) => {\\n  const bboxResult = turf.bbox(feature);\\n  const [a, b, c, d] = bboxResult;\\n  map?.fitBounds(\\n    [\\n      [a, b],\\n      [c, d],\\n    ],\\n    options,\\n  );\\n}\\n```\\n\\n> 上面用到了库 `turf.js`，本专栏的这篇文章介绍过了：[https://juejin.cn/post/7170866833015177247](https://juejin.cn/post/7170866833015177247)\\n\\n更新标注的核心代码：\\n\\n```js\\nmap?.setFilter('areas-name', ['==', 'parentCode', code]);\\n```\\n\\n看看缝补之后的效果？\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a87da69f42c4577a3f4b2b9743f2ed7~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n或者亲自动手试试：\\n\\n[代码片段](https://code.juejin.cn/pen/7174655846067437583)\\n\\n## 五、鼠标悬浮高亮？\\n\\n学会了下钻，**高亮** 实在容易：\\n\\n> 思路：新增一个高亮图层，通过筛选，让它显示出来即可。\\n\\n新增代码如下：\\n\\n```js\\nmap.addLayer({\\n  id: 'areas-surface-hight',\\n  type: 'fill',\\n  source: 'bound-source',\\n  layout: {},\\n  paint: {\\n    'fill-color': 'orange',\\n    'fill-opacity': 1,\\n  },\\n  filter: ['==', 'adcode', '']\\n})\\n\\nmap.on('mousemove', 'areas-surface', (e) => {\\n  const feature = e.features?.[0];\\n  const code = feature?.properties?.adcode;\\n  map?.setFilter('areas-surface-hight', ['==', 'adcode', Number(code)]);\\n})\\n```\\n就可以看到效果：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7644ff4356714161afd085f9d4834ce2~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n以及，亲自动手试试：\\n\\n[代码片段](https://code.juejin.cn/pen/7174665488495018042)\\n\\n## 六、总结\\n\\n至此，我们就一步步，完成了以下内容：\\n\\n- 分析如何做 **线框风地图**\\n- 如何收集并组织 `GeoJSON`\\n- 如何开始进行简单渲染\\n- 如何交互联动\\n- 如何下钻\\n- 如何高亮\\n\\n至此，你对框架及思路，都有了一个较为系统的体验，相信其他需求也一定难不倒你。\\n\\n## 七、源码\\n\\n以上内容，均提供源码：\\n\\n渲染相关的源码：[https://github.com/zhangshichun/windstorm-ui](https://github.com/zhangshichun/windstorm-ui)\\n\\n相关 `demo`: [https://zhangshichun.github.io/windstorm-ui/map-demo/](https://zhangshichun.github.io/windstorm-ui/map-demo/)\\n\\n`GeoJSON` 的获取和合并： [https://github.com/zhangshichun/windstorm-ui/tree/master/scripts](https://github.com/zhangshichun/windstorm-ui/tree/master/scripts)\\n\\n> 在项目中执行以下命令可自行抓取合并 `GeoJSON`:\\n\\n```bash\\nnpm run geojson:fetch\\nnpm run geojson:merge\\n```\\n",
        "tags": [
            "前端",
            "JavaScript",
            "Vue.js"
        ]
    },
    {
        "article_id": "7162039251071139876",
        "cover_image": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a472c1584fa4884abd9710520f3aaa2~tplv-k3u1fbpfcp-watermark.image?",
        "title": "深入理解闭包的形成过程及应用！",
        "brief": "闭包就好像从 JavaScript 中分离出来的一个充满神秘色彩的未开化世界,只有最勇敢的人才能够到达那里。",
        "user_name": "Moment",
        "view_count": 2550,
        "collect_count": 50,
        "comment_count": 11,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/4ae08cddb21bbb8e795235baef9a095e~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: nico\\nhighlight: atom-one-dark\\n---\\n\\n## 前言\\n- 首先引用书籍```你不知道的JavaScript``` 中的一段话:\\n> 回忆我前几年的时光,大量使用JavaScript但却完全不理解闭包是什么。总是感觉言有其隐的一面,如果能够掌握将 会功力大涨,但其讽刺的是我始终无法掌握其中的门道。还记得我曾经大量阅读早期框架的源码,试图能够理解闭包的工作原理,现在还能回忆起我的脑海中第一次浮现出关于 \\\"模块模式\\\" 相关概念时的激动心情。\\n\\n- 在理解闭包之前,你需要先了解的是执行上下文,当然了你了解V8执行过程就更好了。你可以通过上一篇的文章中学习相关知识,这里详细讲解了V8的执行过程以及执行上下文是如何创建的。[```跳转链接点击这里``` ](https://juejin.cn/post/7160477811239550989)\\n\\n## 什么是闭包?\\n- 首先看看维基百科对闭包的定义\\n1. ```闭包```（Closure），又称```词法闭包```（Lexical Closure）或```函数闭包```（function closures），是在支持头等函数的编程语言中实现词法绑定的一种技术。\\n2. 闭包在实现上是一个结构体，它存储了一个函数（通常是其入口地址）和一个关联的环境（相当于一个符号查找表）。\\n3. 闭包跟函数最大的不同在于，当捕捉闭包的时候，它的自由变量会在捕捉时被确定，这样即便脱离了捕捉时的上下文，它也能照常运行。\\n\\n- 再来看一下MDN对JavaScript闭包的解释\\n1. ```闭包```（closure）是一个函数以及其捆绑的周边环境状态（```lexical environment```，```词法环境```）的引用的组合\\n2. 闭包能让开发者可以从内部函数访问外部函数的作用域。\\n3. 。在 JavaScript 中，闭包会随着函数的创建而被同时创建。\\n\\n- 总的来说,闭包就是能够读取其他函数内部变量的函数。\\n\\n## LHS查询和RHS查询\\n- 在开始闭包之前,我们再来补充一下两个概念,就是什么是## LHS查询和RHS查询,待会要用到。\\n1. ```LSH查询```；LHS查询会在当前作用域链进行查询，如果当前作用域查询不到，就会沿着作用域链一层一层，找到的话就会将值赋值给这个变量，如果到达作用域顶端仍然找不到，就会在作用域链顶端创建这个变量。\\n2. ```RHS查询```；RHS查询会在当前作用域链进行查询，如果当前作用域查询不到，就会沿着作用域链一层一层，，找到的话就会取得这个值并返回，如果到达作用域顶端仍然找不到，就会抛出错误（比如```TypeError、ReferenceError```）。\\n\\n## 闭包的产生\\n- JavaScript三大特性,而闭包产生的原因也正是因为这些特性:\\n1. 可以在JavaScript函数内部定义新的函数;\\n2. 内部函数中访问函数中的定义;\\n3. 在JavaScript中,函数是一等公民,所以函数中既可以传入一个函数又可以作为参数返回一个函数。\\n\\n- 话不多说,先上代码:\\n```js\\nfunction foo() {\\n  var moment = 18;\\n  var test = 111;\\n\\n  function bar() {\\n    const may = moment + 777;\\n    return may;\\n  }\\n\\n  console.log(test);\\n\\n  return bar;\\n}\\n\\nvar baz = foo();\\n\\nbaz(); // 嗨,朋友,这就是闭包\\n\\n```\\n- 通过观察上面的代码,我们在foo函数中定义了bar函数,并返回bar函数,同时在bar函数中访问了foo函数中的变量moment。\\n\\n- 上面的代码大概的执行流程为:\\n1. 当调用 ```foo``` 函数时，```foo``` 函数会将它的内部函数 ```bar``` 返回给全局变量 ```baz```；\\n2. 等到 ```foo``` 函数执行结束时，执行上下文会被 ```V8``` 销毁；\\n\\n- 按照正常的情况来说,变量 ```moment``` 已经被 V8 销毁了,因为我们知道 V8 引擎有垃圾回收期用来释放不再使用的内存空间,但是由于存活的函数 ```bar``` 依然引用了 ```foo``` 函数作用域中的变量 ```moment```,这样就会带来两个问题:\\n1. 当 ```foo``` 执行结束时，变量 ```moment``` 该不该被销毁？如果不应该被销毁,那么他应该在什么时候销毁，而又应该采用什么策略？\\n2. 我们都知道 V8 引擎采用的是惰性解析的方案,那么当执行到 ```foo``` 函数时, V8 只会解析 ```foo``` 函数,并不会解析内部的 ```bar```函数,仅仅知识对 ```bar```函数进行了标记,在这时 V8 引擎并不知道 ```bar``` 函数中是否引用了 外层函数作用域中的变量 ```moment```;\\n\\n- 由于 ```JavaScript``` 是一门基于堆和栈的语言。在执行全局代码时当执行，```V8``` 会将全局执行上下文压入到调用栈中，然后进入执行 ```foo``` 函数的调用过程。\\n- 这时候 ```V8``` 引擎会为 ```foo``` 函数创建执行上下文，执行上下文中包括了变量 ```moment```，然后将 ```foo``` 函数的执行上下文压入栈中，foo 函数执行结束之后，foo 函数执行上下文从栈中弹出，这时候 ```foo``` 执行上下文中的变量 ```moment``` 也随之被销毁。\\n- 正常的处理方式应该是 ```foo``` 函数的执行上下文被销毁了,但是 ```bar``` 函数引用的 ```foo``` 函数中的变量却不能被销毁。\\n- 在执行 ```foo``` 函数的阶段,虽然采取了惰性解析,不会解析和执行 ```foo``` 函数中的的 ```bar``` 函数中的 ```bar``` 函数,但是 ```V8```还是需要判断 ```bar``` 函数是否引用了 ```foo``` 函数中的变量。\\n- ```V8``` 引擎引入了预解析器,当解析顶层代码的时候,遇到了一个函数,那么预解析器并不会直接跳过该函数,而是对该书做一次快速的预解析,其中主要的目的主要有两个:\\n1. 判断当前函数是否是不是存在一些语法上的错误,如果发现语法错误,那么就会向 V8 抛出语法错误;\\n2. 判断 ```foo``` 函数是否有被 ```bar``` 函数引用的变量,如果有,就会把该变量复制一份到堆内存中,同时 ```bar``` 函数本身也是一个对象,也会被存放到内存当中,这样即使 ```foo``` 函数即使执行完成,内存被释放以后,```bar``` 函数在执行的时候,依然可以从堆内存中访问复制过来的变量;\\n\\n- 第二点钟说的复制一个变量,实际上是复制了一个闭包函数(```Closure (foo)```),但是此函数只有被 ```bar``` 函数引用的值,```foo``` 函数中的 ```test``` 变量并没有被复制过去,如下图所示:\\n\\n![闭包.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e67e6bc2911a466f892e140b53f54645~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## Other Example\\n```js\\nfunction foo() {\\n  var moment = 777;\\n\\n  function baz() {\\n    console.log(moment);\\n  }\\n\\n  bar(baz);\\n}\\n\\nfunction bar(fn) {\\n  fn(); // 这也是一个闭包\\n}\\n\\nfoo();\\n```\\n- 把内部函数 ```baz``` 传递给 ```bar``` 函数,当调用这个内部函数时(这个时候叫作 ```fn```),它涵盖的 ```foo```()内部作用域的闭包就可以观察到了,因为他能够访问。\\n\\n```js\\nfunction wait(message) {\\n  setTimeout(function timer() {\\n    console.log(message);\\n  }, 1000);\\n}\\n\\nwait(\\\"hello world\\\");\\n```js\\nfunction wait(message) {\\n  setTimeout(function timer() {\\n    console.log(message);\\n  }, 1000);\\n}\\n\\nwait(\\\"hello world\\\"); // 这也是一个闭包\\n```\\n\\n- 将一个内部函数 ```timer``` 传递给```settimeout```(...)。timer函数依然保存有```wait```(...)作用域的闭包。\\n- 在引擎内部,内置的工具函数```settimeout```(...)持有对一个参数的引用,这个参数也许叫作fn或者func,又或者其他类型的名字。引擎会调用这个函数,在这个例子中就是内部的timer函数,而词法作用域在这个过程中保持完整。\\n\\n![timer.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca06cd63e43e4837971a2283d928893c~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## 经典永不过时\\n```js\\nfor (var i = 0; i <= 5; i++) {\\n  setTimeout(() => {\\n    console.log(i);\\n  }, i * 10000);\\n}\\n```\\n- 正常情况下,我们对这段代码行为的预期分别是输出1~5,每秒一次,每次一个。但实际上,这段代码在运行时会以每秒一次输出的频率输出五次6。因为这个循环的终止条件是 `i` 不再```<=5```,条件时 `i` 的值为6,因此输出显示的是循环结束时 `i` 的最终值。\\n- 这是因为 `setTimeout` 是异步的，而for循环是同步的，延迟函数的回调会在循环结束时才执行，当循环结束时 `i` 已经是 6了，所有的回调函数才会开始执行，因此会每次输出一个 `6` 来。\\n\\n- 那么有什么办法可以让这个循环一次输出数字呢? 用 `let` 关键字代替 `var`? 答案当然是可以的 , 你会看到 `0 1 2 3 4 5` 成功输出。\\n```js\\nfor (let i = 0; i <= 5; i++) {\\n  setTimeout(() => {\\n    console.log(i); // 0 1 2 3 4 5 成功输出\\n  }, 1000);\\n}\\n```\\n- 如果不用 `let`,用立即执行函数(`IIFE`)呢?\\n```js\\nfor (var i = 0; i <= 5; i++) {\\n  (function () {\\n    setTimeout(() => {\\n      console.log(i); // 输出 6 次 6\\n    }, 1000);\\n  })();\\n}\\n```\\n\\n- 这样明显是不行的,为什么呢?虽然我们拥有了跟多的词法作用域了,每个延迟函数都会将 `IIFE` 在每次迭代中创建的作用域封闭起来。但是该错用域是空的,所以 `IIFE`只是一个什么都没有的空作用域。\\n\\n```js\\nfor (var i = 0; i <= 5; i++) {\\n  (function (j) {\\n    setTimeout(() => {\\n      console.log(j); // 0 1 2 3 4 5 成功输出\\n    }, 1000);\\n  })(i);\\n}\\n```\\n- 在这里我们把 `i` 作为参数传递给 `立即执行函数` ,`j` 就是传进来的参数,这个时候 `立即执行函数` 就有自己的作用域变量 `j` 了,问题就迎刃而解了。这就是闭包的力量。\\n\\n## 用闭包模拟私有方法\\n```js\\nfunction Person() {\\n  var friends = 0;\\n\\n  this.getFriends = function () {\\n    return friends;\\n  };\\n\\n  this.friend = function () {\\n    friends++;\\n  };\\n}\\n\\nconst student = new Person();\\n\\nstudent.friend();\\nstudent.friend();\\nconsole.log(student.getFriends());\\n```\\n- 在上面的代码中,我们创建了一个构造函数 `Person` ,定义了一个变量 `friends` 用于保存状态。由于JavaScript的作用域规则的限制,因此只能在构造函数内部访问该变量。\\n- 我们可以通过方法读写私有变量,但是不能直接对 `friends` 变量直接进行读写,这就实现了私有变量了。\\n\\n## 闭包的优缺点\\n- 优点\\n1. 可以将一个变量长期储存在内存中，用于缓存;\\n2. 可以避免全局变量的污染;\\n3. 加强封装性，是实现了对变量的隐藏和封装,让 `JavaScript` 也能支持私有变量;\\n- 缺点\\n 1. 因为函数外部引用的变量不会被销毁，所以会导致内存消耗很大，增加了内存消耗量，影响网页性能出现问题;\\n 2. 而且过度的使用闭包可能会导致内存泄漏，或程序加载运行过慢卡顿等问题的出现。所以我们可以在退出函数之前将不使用的局部变量进行删除;\\n\\n> 虽然闭包带给我们一定的好处,但是处理不好,很可能给我们带来严重的灾害。如果不是某些特定任务需要使用闭包，在其它函数中创建函数是不明智的，因为闭包在处理速度和内存消耗方面对脚本性能具有负面影响。。所以在开发中应尽量避免使用闭包。正所谓代码千万条，规范第一条，代码不规范，开发两行泪。\\n\\n> 闭包就好像从 JavaScript 中分离出来的一个充满神秘色彩的未开化世界,只有最勇敢的人才能够到达那里。 \\n\\n## 参考文章 \\n- 书籍 你不知道的JavaScript\\n- 书籍 JavaScript忍者秘籍第二版\\n\\n## 结尾\\n- 如果文章对你有用,欢迎你留下一个宝贵的点赞。\\n- 如果你有疑问,欢迎评论区留下你的问题。\\n- 你也可以关注我,相信我,会给到你一个意想不到的惊喜!\\n\\n\\n\\n\\n",
        "tags": [
            "前端",
            "JavaScript",
            "面试"
        ]
    },
    {
        "article_id": "7154395040507232264",
        "cover_image": "",
        "title": "用 JS 解析 excel 文件需要分几步",
        "brief": "大家好，我是嘿嘿，今天来聊一聊如何使用 JS 来解析 excel 文件，当然不是直接使用 exceljs、sheetjs 之类的库，那就没意思了，而是主要说一下 JS 解析 excel 表格是如何实现",
        "user_name": "嘿嘿Z",
        "view_count": 2517,
        "collect_count": 86,
        "comment_count": 22,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/63dd7cf42f7b4ee928a20c7a8829fe93~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: cyanosis\\n---\\n持续创作，加速成长！这是我参与「掘金日新计划 · 10 月更文挑战」的第17天，[点击查看活动详情](https://juejin.cn/post/7147654075599978532 \\\"https://juejin.cn/post/7147654075599978532\\\")\\n\\n> 八月长江万里晴，千帆一道带风轻。\\n\\n大家好，我是嘿嘿，今天来聊一聊如何使用 `JS` 来解析 `excel` 文件，当然不是直接使用 `exceljs`、`sheetjs` 之类的库，那就没意思了，而是主要说一下 `JS` 解析 `excel` 表格是如何实现的。\\n\\n注意本文主要讨论 `xlsx` 格式的 `excel` 表格，其它格式未探究并不清楚。\\n\\n## excel 表格文件到底是什么\\n\\n首先要解析 `excel` 文件，得先了解他是如何存储数据的，经过我百般搜索，终于在 `GG` 中找到了答案：`excel` 文件其实是一个 `zip` 包！于是我赶紧新建了一个 `xlsx` 文件，在其中新建了两个 `sheet` 表，两个 `sheet` 表数据如下：\\n\\n此为 `sheet` 1：\\n\\n| A   | B   | C   |\\n| --- | --- | --- |\\n| 1   |     | 2   |\\n| 1   |     | 2   |\\n|     |     |     |\\n|     |     |     |\\n|     |     |     |\\n| 1   |     | 2   |\\n| 1   |     | 2   |\\n\\n此为 `sheet` 2：\\n\\n| A   | B   |\\n| --- | --- |\\n| q   | a   |\\n| q   | a   |\\n| q   | a   |\\n\\n然后使用 `zip` 进行解压：\\n\\n```sh\\nunzip test.xlsx -d test\\n```\\n\\n然后通过 `tree` 我们就拿到这样一个目录结构：\\n\\n```sh\\ntest\\n├── [Content_Types].xml\\n├── _rels\\n├── docProps\\n│   ├── app.xml\\n│   ├── core.xml\\n│   └── custom.xml\\n└── xl\\n    ├── _rels\\n    │   └── workbook.xml.rels\\n    ├── sharedStrings.xml\\n    ├── styles.xml\\n    ├── theme\\n    │   └── theme1.xml\\n    ├── workbook.xml\\n    └── worksheets\\n        ├── sheet1.xml\\n        └── sheet2.xml\\n```\\n\\n啊哈，干得漂亮，居然全都是 `xml` 文件。\\n\\n我们在打开 `xml` 一探究竟，可以看出有几个文件很显眼，就是 `worksheets` 下的 `sheet1.xml` 和 `sheet2.xml`，还有 `workbook.xml`，其他的 `styles`、`theme` 一看就是和样式有关系，`_rels` 感觉就是什么内部引用，我们先看看两个 `sheet` 的 `xml` 文件，看看猜测是否正确，贴下 `sheet1.xml`：\\n\\n```xml\\n<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" standalone=\\\"yes\\\"?>\\n<worksheet xmlns=\\\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\\\"\\n    xmlns:r=\\\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\\\"\\n    xmlns:xdr=\\\"http://schemas.openxmlformats.org/drawingml/2006/spreadsheetDrawing\\\"\\n    xmlns:x14=\\\"http://schemas.microsoft.com/office/spreadsheetml/2009/9/main\\\"\\n    xmlns:mc=\\\"http://schemas.openxmlformats.org/markup-compatibility/2006\\\"\\n    xmlns:etc=\\\"http://www.wps.cn/officeDocument/2017/etCustomData\\\">\\n    <sheetPr/>\\n    <dimension ref=\\\"A1:C7\\\"/>\\n    <sheetViews>\\n        <sheetView workbookViewId=\\\"0\\\">\\n            <selection activeCell=\\\"D5\\\" sqref=\\\"A3:D5\\\"/>\\n        </sheetView>\\n    </sheetViews>\\n    <sheetFormatPr defaultColWidth=\\\"9.23076923076923\\\" defaultRowHeight=\\\"16.8\\\" outlineLevelRow=\\\"6\\\" outlineLevelCol=\\\"2\\\"/>\\n    <sheetData>\\n        <row r=\\\"1\\\" spans=\\\"1:3\\\">\\n            <c r=\\\"A1\\\">\\n                <v>1</v>\\n            </c>\\n            <c r=\\\"C1\\\">\\n                <v>2</v>\\n            </c>\\n        </row>\\n        <row r=\\\"2\\\" spans=\\\"1:3\\\">\\n            <c r=\\\"A2\\\">\\n                <v>1</v>\\n            </c>\\n            <c r=\\\"C2\\\">\\n                <v>2</v>\\n            </c>\\n        </row>\\n        <row r=\\\"6\\\" spans=\\\"1:3\\\">\\n            <c r=\\\"A6\\\">\\n                <v>1</v>\\n            </c>\\n            <c r=\\\"C6\\\">\\n                <v>2</v>\\n            </c>\\n        </row>\\n        <row r=\\\"7\\\" spans=\\\"1:3\\\">\\n            <c r=\\\"A7\\\">\\n                <v>1</v>\\n            </c>\\n            <c r=\\\"C7\\\">\\n                <v>2</v>\\n            </c>\\n        </row>\\n    </sheetData>\\n    <pageMargins left=\\\"0.75\\\" right=\\\"0.75\\\" top=\\\"1\\\" bottom=\\\"1\\\" header=\\\"0.5\\\" footer=\\\"0.5\\\"/>\\n    <headerFooter/>\\n</worksheet>\\n```\\n\\n😂 相信大家已经看出来了，`sheetData` 就是 `excel` 表格中的数据了，`<row>` 代表行，其中的 `r` 则是行数索引，`row` 中的 `<c>` 应该是 `cell` 了，其中的 `<v>` 对应着 `cell` 中的值，而 `r` 则是 `cell` 的位置，如 `A7` 代表着在 `A` 列 7 行。\\n\\n此外还有几个很明显的属性如 `dimension` 可以看出是表格的大小范围，从 `A1 cell` 到 `C7 cell` 形成一个框。`<sheetViews>` 中存储的应该是页面中的信息，`<selection>` 代表的应该就是被选中的表格内容了。\\n\\n而 `workbook` 中存储的则是 `sheet` 的信息：\\n\\n```xml\\n<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" standalone=\\\"yes\\\"?>\\n<workbook xmlns=\\\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\\\"\\n    xmlns:r=\\\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\\\">\\n    <fileVersion appName=\\\"xl\\\" lastEdited=\\\"3\\\" lowestEdited=\\\"5\\\" rupBuild=\\\"9302\\\"/>\\n    <workbookPr/>\\n    <bookViews>\\n        <workbookView windowHeight=\\\"16360\\\" activeTab=\\\"1\\\"/>\\n    </bookViews>\\n    <sheets>\\n        <sheet name=\\\"Sheet1\\\" sheetId=\\\"1\\\" r:id=\\\"rId1\\\"/>\\n        <sheet name=\\\"Sheet2\\\" sheetId=\\\"2\\\" r:id=\\\"rId2\\\"/>\\n    </sheets>\\n    <calcPr calcId=\\\"144525\\\"/>\\n</workbook>\\n```\\n\\n剩下的几个 `xml`，大概看了一眼，存储的信息还算很清楚，比如：\\n\\n-   `app` 中存储了文件程序的信息，好像还有文件名\\n-   `core` 中保存了作者的信息和创建、修改时间\\n-   `rels` 文件也是 `xml` 格式，存储了一些其它 `xml` 的引用\\n-   `theme` 里存储了表格中定义的颜色、字体\\n-   `[Content_Types]` 里则是所有文件的引用，猜测估计为解析的入口文件\\n\\n## JS 实现步骤\\n\\n知道了 `excel` 文件是如何存储数据的，那我们如何用 `js` 来解析它就很清楚了，主要分三步：\\n\\n1. 使用 `js` 解压缩 `excel` 文件\\n2. 获取到其中的 `sheet` 文件内容，然后将 `xml` 数据解析出来\\n3. 将数据转换成我们想要的形状\\n\\n说干就干，那我们来实操一下：\\n\\n### ZIP 解压\\n\\n关于 `JS` 如何实现 `ZIP` 解压的，上一篇文章也有提到，这里我们就不细说，直接使用 `jszip` 搞定：\\n\\n```js\\ndocument.querySelector('#file').addEventListener('change', async e => {\\n    const file = e.target.files[0];\\n    if (!file) return;\\n    const zip = await JSZip.loadAsync(file);\\n    const sheetXML = await zip.files['xl/worksheets/sheet1.xml'].async('string');\\n});\\n```\\n\\n快速搞定，现在 `sheetXML` 就是我们刚刚看到的 `sheet1.xml` 中的数据了。\\n\\n### XML 解析\\n\\n然后我们即可解析 `XML` 内容将其中数据取出，`xml` 解析原理很简单，和 `html parse` 一样，了解原理咱就直接随便搞个开源库帮忙搞定：\\n\\n```js\\nimport convert from 'xml-js';\\n\\nconst result = convert.xml2json(sheetXML, { compact: true, spaces: 4 });\\n```\\n\\n然后我们就得到了这样一串 `JSON`（删除了部分内容）：\\n\\n```json\\n{\\n    \\\"_declaration\\\": {\\n        \\\"_attributes\\\": {}\\n    },\\n    \\\"worksheet\\\": {\\n        \\\"_attributes\\\": {},\\n        \\\"sheetPr\\\": {},\\n        \\\"dimension\\\": {\\n            \\\"_attributes\\\": {\\n                \\\"ref\\\": \\\"A1:C7\\\"\\n            }\\n        },\\n        \\\"sheetData\\\": {\\n            \\\"row\\\": [\\n                {\\n                    \\\"_attributes\\\": {\\n                        \\\"r\\\": \\\"1\\\",\\n                        \\\"spans\\\": \\\"1:3\\\"\\n                    },\\n                    \\\"c\\\": [\\n                        {\\n                            \\\"_attributes\\\": {\\n                                \\\"r\\\": \\\"A1\\\"\\n                            },\\n                            \\\"v\\\": {\\n                                \\\"_text\\\": \\\"1\\\"\\n                            }\\n                        },\\n                        {\\n                            \\\"_attributes\\\": {\\n                                \\\"r\\\": \\\"C1\\\"\\n                            },\\n                            \\\"v\\\": {\\n                                \\\"_text\\\": \\\"2\\\"\\n                            }\\n                        }\\n                    ]\\n                },\\n                {\\n                    \\\"_attributes\\\": {\\n                        \\\"r\\\": \\\"7\\\",\\n                        \\\"spans\\\": \\\"1:3\\\"\\n                    },\\n                    \\\"c\\\": [\\n                        {\\n                            \\\"_attributes\\\": {\\n                                \\\"r\\\": \\\"A7\\\"\\n                            },\\n                            \\\"v\\\": {\\n                                \\\"_text\\\": \\\"1\\\"\\n                            }\\n                        },\\n                        {\\n                            \\\"_attributes\\\": {\\n                                \\\"r\\\": \\\"C7\\\"\\n                            },\\n                            \\\"v\\\": {\\n                                \\\"_text\\\": \\\"2\\\"\\n                            }\\n                        }\\n                    ]\\n                }\\n            ]\\n        }\\n    }\\n}\\n```\\n\\n接下来，我们只需要将 `sheetData` 中的数据取出，然后按照内部的属性生成自己想要的数据格式即可。\\n\\n## 总结\\n\\n`excel` 文件本质就是一个 `zip` 包，我们只需要通过 `zip` 解压、`xml` 解析、数据处理这三个步骤，即可使用 `JS` 读取到其中的数据，当然其中的细节还是很多的，不过如果只是简单的 `excel` 模版，不妨自己尝试一下。\\n",
        "tags": [
            "前端",
            "JavaScript",
            "掘金·日新计划"
        ]
    },
    {
        "article_id": "7166624661491580941",
        "cover_image": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c9775aa8ca884b9b92c2f186f8a2673a~tplv-k3u1fbpfcp-watermark.image?",
        "title": "「微服务网关实战六」自学两小时前端搭建微服务网关控制后台",
        "brief": "三年 Java 自学两个小时前端，做了一个后台系统。请各位前端大佬来点评一下我的前端学习路线，想要全栈的后端老哥们也可以来看看我的个人自学经历。",
        "user_name": "和耳朵",
        "view_count": 31550,
        "collect_count": 115,
        "comment_count": 161,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/74b5be48428b9a96c4bab53a176d842a~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: vuepress\\n---\\n\\n> 本文为稀土掘金技术社区首发签约文章，14天内禁止转载，14天后未获授权禁止转载，侵权必究！\\n\\n又来给大家更文了，今天是微服务网关实战的第六篇。\\n\\n今天的内容比较偏前端一点，主要是给大家换换口味，毕竟学一个东西学久了就想学点新东西休息一点，俗称换换脑子。\\n\\n其实早就想学学前端看了，不过碍于工作繁忙，也可能是懒癌发作一直没有成行，直到在做OKR的时候有些东西需要前端的支持，而我们又没有多余前端的时候，我就知道，我需要开始学前端了~\\n\\n在往下讲之前，我忽然想起来我有一位前端网友，在我们之前都还特贫穷的时候（现在升级到贫穷），时常会在一块讨论问题，有时候我会说你们前端怎么怎么样，他就会非常反感，因为他觉得自己不是 **front** 而是 **developer**。\\n\\n虽然我被怼了，但是从心底我是同意他的说法的，开发者不应该给自己受限，我们大家都只是在做前端 or 后端这份工作而已，毕竟有的人招进来的时候是前端，现在连运维的活都干呢，你说是吧？@CookieBoty\\n\\n所以，本文的内容会夹杂前端和后端，前端的可以看看后端内容，后端的可以看看前端内容，换换脑子嘛~\\n\\n## 1. Vue\\n\\n我还依稀记得，三四年前刚学 Java 的时候还要学 CSS、HTML和JS三板斧，做后端工作三年后，我连怎么操作 DOM 都忘记了，可能许多后端小伙伴也和我一样，除了会 HTML 的一点标签，其他前端相关的知识早就忘完了，这也是很多后端迟迟不愿意接触前端的原因，太费心力了。\\n\\n所以在我决定开始学习前端的第一个问题就是，**我应该先学什么？**\\n\\n在我略微思考了三分钟之后，我得出一个结论：我应该先学一个前端框架。\\n\\n我知道任何一门语言的技术栈都是有一个庞大的生态在支撑的，前端所涉及的东西除了前端框架之外还有打包工具，依赖管理工具，ES6新特性（可能它已经老了，对我来说是新的），卷的狠的再来点拆入拆解浏览器等等等。\\n\\n这些八股文和 Java 有的一拼，但是我知道我不需要学这些的所有东西，我要学的时候只有一个：**用一个工具帮我做成一个东西。**\\n\\n所以，虽然我连解构赋值、和操作DOM都不会，但是这不妨碍我学前端，我要先选中一个前端框架进行熟悉，然后利用这个框架的生态帮我做东西。\\n\\n扯远了，说回正题，在两三年前的时候，前端还是 Vue、React 和 Angular 三足鼎立，但是到今年 Angular 除了外企似乎已经用的不多了，所以我的学习目标就放在 Vue 和 React 这两个身上了。\\n\\n怎么选，其实我是纠结的，最终我听从好大哥@CookieBoty和众多网友的建议，学了 Vue。\\n\\n网上很多人都说 Vue 上手好、文档全，我感觉完美符合我的预期，再加上火影完结之后我就开始追海贼王了，尤大的 onepiece 起名方式甚合我意，所以我就开始学起来了 Vue3。\\n\\n怎么学呢？我想到了程序员的梦工厂某课网，找了一个教程来看，上面先教了我模板语法，又教了我单页组件，最后又学了 Vue 路由系统，前后花费一个多小时，看了十几节视频，我觉得我行了，就开始实践了~\\n\\n**最终，三天没写完一个页面。**\\n\\n## 2. React\\n\\n`Vue3` 的难度让我有点触不及防，可能也是因为我没有抛弃后端的代码习惯。\\n\\n我习惯用 TS 定义好数据结构去接收值和处理值，但是我发现 Vue3 中的所有对象都是一个代理对象，当我尝试将一个 Map 数据直接转换为一个 JSON 字符串的时候我发现不行，我也无法理解一个 Map 为啥不能在转 JSON 的时候把里面的 KV 带上，还需要我手动转换成一个对象然后再转一次，我很苦恼。\\n\\n我更苦恼的是，当我尝试用一个数组对象循环生成某段模板的时候，我发现很麻烦，我感觉这不是我想要的前端，作为一个后端，我学了脚本语言，但是它却让我感觉到很多的枷锁在身上，这比我写 Java 还困难。\\n\\n此时我意识到，Vue3的上手难度和Vue2不是一样的，这是一个成熟的前端框架了，它需要一个成熟的前端来操作，而不是我这种玩完就扔的二流开发。\\n\\n当然，Vue 还是有很多好处的，从我可以看见的一点来说就是，**ele-plus** 这个组件库是真的漂亮。\\n\\nVue3 玩不转了，我就想换 React 了，再次来到某课网，找了个 React17 的视频来看，又花了我一个多小时，好在我已经有一些前置知识了，吸收起来还是蛮快的，学习的过程中，我觉得 React 给了我想要的东西：**自由**，脚本语言写起来的自由感。\\n\\n在 React 中我不再拘泥于单页组件，统统都是函数式组件，单向数据流也让我更容易理解数据运行的方式，而且会 React 据说B格要比会 Vue 的高一点，这一切都让我觉得转 React 是正确的。\\n\\n不过有利有弊，在我写 React 的过程中，我发现我在用 Vue3 写代码时候的问题就是 JS 独有的问题，比如我前面提到过的 Map 转 JSON 的问题，它不会因为某个框架就能让我更舒服。\\n\\n可能有的前端小伙伴会想：你为啥要用 Map？\\n\\n因为 Map 更符合我这个后端的认知，某些不确定的多选参数我装在一个容器里面，然后序列化后给后端我觉得这是一件极其合理的事情，它符合我的心智模式，但是 JS 或者 TS 都没有做到。\\n\\n在使用 TS 的过程中，我几乎没有感觉到好处，TS 的类型检查反而让我觉得更不像脚本语言了，这一点我觉得比后端 Kotlin 差很多。\\n\\n虽然有种种限制，但是好在 React 这个框架并没有让我感觉到有什么不适，反而是无缝衔接，我几乎是上手就写了。\\n\\n最后总结一下我 React 都学了哪些东西才开始写东西的：\\n\\n0.  使用脚手架安装 react with ts。\\n0.  `声明类组件和函数式组件`：函数式组件是主流，类组件稍微看看就行，主要就是写起来麻烦。\\n0.  `理解 render`：render 其实就是通过执行组件代码生成一个HTML片段，然后挂载到DOM上面。\\n0.  `CSS 模块化`：通过 CSS 模块化，加样式的时候会非常方便，懒癌患者直接在代码上加行内样式也没问题，玩的就是随心所欲。\\n0.  `State 和 props`：state 是重点，它代表了组件中状态，比如按钮是否显示之类的，props 则是不可变参数，由外部传递进来供组件使用。\\n0.  `Hooks`：Hooks 我一般只使用到 useState、useEffect、useContext这三个，它们分别代表了声明状态变量，声明副作用钩子和全局数据传递。\\n0.  `路由`：按照我的理解路由是通过占位符和浏览器的锚点来完成的，通过锚点定位到指定代码，通过占位符将组件代码生成到占位符占据的DOM处，当然这只是个人拙见，希望评论区大佬能给出更多细节。\\n\\n学完上面几项，我觉得你写一个小的管理系统也是没问题的，啊对了，说到管理系统，那必然要用到 http 相关的东西，虽然由 axios 珠玉在前，但是 fetch 用起来也还行。\\n\\n最后，我觉得 React 的文档比 Vue 的文档强上不少，这句话希望 JYM 别喷我。\\n\\n## 3. 组件库\\n\\n写前端的过程中，想要提效，组件库是必不可少的，我先后体验了 Ant Design、Material UI、Semi Design、Arco Design。\\n\\n最终在做项目的时候用了 `Semi Design`，因为它不用引入全局样式表就能按需加载，虽然我的好大哥告诉我 Ant Design 也可以做到这个效果，但是当时确实没有实践成功，还是我的功力太过薄弱。\\n\\n从目前看来，我用过最舒服最方便的还是 ele-plus 可惜没有 React 版本。\\n\\n虽然组件库是一个好东西，但是我觉得太过依赖组件库是一件很糟糕的事情，当你要做的功能组件库中有但是恰好达不到你要的效果时，就会很难受，怪不得很多人都要做一个自己的组件库了~\\n\\n比如 Semi Design，在我使用的过程中我其实很不喜欢它的按钮效果，按钮上面总要有一个底色：\\n\\n![image-20221109223738886](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1587851415a9405a82a1ada0c0919eef~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n我想要一个无底色的图标按钮，但是 Semi Design 的图标按钮全部都是这样的：\\n\\n![image-20221109224044778](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bcc16c38c5014750bf2cb4ed2d32a191~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n可能这就是它独有的设计风格问题吧，还有一些随时可能遇到会违反自己的直觉的事情，让我意识到，组件库虽然不错，但是过度依赖也为自己的扩展留下很多问题。\\n\\n写到这，突然就明白了为啥前端有时候会告诉我：” 这个效果我用的组件库做不了 “，我心想你的页面还不是你做主吗，居然能让组件库把开发者给拿捏了，等我也被拿捏的时候，我仿佛理解了他当时的情况，原来我的页面真不是我做主😟\\n\\n## 4. 页面效果\\n\\n虽然我学前端只花了几个小时，但是写页面却花了好久的时间，大部分时间都在调一些样式和排查错误，而且我还自己学了一手 Flex 布局，做了整体的页面布局。\\n\\n在有时候感觉组件效果不好的时候还自己写了一下鼠标悬浮的阴影之类的小效果：\\n\\n![image-20221109225102039](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4059444746b6429eb7fafff7bf55cd60~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n一套页面做下来整体感觉还是不错的，怪不得前端也被称为交互体验工程师了。\\n\\n接下来给大家看一下整体效果，这是主页面：\\n\\n![409866d6-104a-49d5-96fa-d06b14948022](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d19824ebbc80413c8bf75a7db0568be7~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n我的这个网关控制台总共分为两个页面：看板和路由表。\\n\\n路由表就是上图展示的这个，主要是把 Nacos 中的配置拉下来解析成数组对象展示在表格里面，然后在表格里面可以进行编辑和新增，然后通过 openApi 同步到 Nacos 远端去，这样就不用手动去在一堆配置里面改了。\\n\\n这里要小小的吐槽一下 Nacos 的 Api，它们的这种发布配置居然是 Get 接口的，导致我要现在后端做一层包装，不然数据量大了很容易被浏览器拦截掉，它们新版的 api 接口我也看了相关的代码，居然不是常用的 JSON 传参，就此还和相关开发者对了一次线。\\n\\n扯远了，说回正题，我的编辑和新增页面如下：\\n\\n![7bb8fc91-2926-4dd2-8eab-b64f598a30eb](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42bbbdbed97643ee9aa31c7aac9d68ac~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n看板则是使用网关做了一些流量指标的记录，比如请求总量、日活总量、每小时在线人数、每小时请求人数之类的基础指标，并且把它们做成了一个图表的形式，有饼状图和折线图：\\n\\n![4bfb2cdd-3c52-4711-af29-2d93d09908ed](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa5c950e14364843b1ffba91eeb78a3a~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n当然，对我来说最重要的还是路由表的查看页面和新增编辑页面，这几个页面花费了我最多的心力，而且页面的数据结构比较复杂，做起来对我这个新手来说是有点吃力的。\\n\\n值得一提的是，图表是我做的最轻松的一个页面，用的是蚂蚁的图标组件。\\n\\n## 5. 后端\\n\\n最后，简简单单说一下后端我都做了什么吧。\\n\\n由于这是后台系统，所以我将它和网关分开，新建了一个 admin 项目来处理相关请求，但是呢？加上前端那我的网关整体就要有三个部署的服务了：网关 API、网关控制台前端、网关控制台后端。\\n\\n为了节省资源，我通过插件的方式把前端输出的代码copy到网关后端这个应用里面来，这样网关后端和前端的代码就可以打包在一个应用里面了。\\n\\n其具体做法主要就是在后端应用编译打包的时候用插件先编译前端，然后对前端资源进行复制，具体插件如下：\\n\\n```\\n    <build>\\n        <plugins>\\n                 <!-- 调用npm命令插件  -->\\n                <plugin>\\n                    <groupId>org.codehaus.mojo</groupId>\\n                    <artifactId>exec-maven-plugin</artifactId>\\n                    <version>3.0.0</version>\\n                    <executions>\\n                        <!-- 先执行前端依赖下载 -->\\n                        <execution>\\n                            <id>exec-npm-install</id>\\n                            <phase>package</phase>\\n                            <goals>\\n                                <goal>exec</goal>\\n                            </goals>\\n                            <configuration>\\n                                <executable>npm</executable>\\n                                <arguments>\\n                                    <argumnet>install</argumnet>\\n                                </arguments>\\n                                <workingDirectory>../admin-ui/</workingDirectory>\\n                            </configuration>\\n                        </execution>\\n​\\n                        <!-- npm打包 -->\\n                        <execution>\\n                            <id>exec-npm-run-build</id>\\n                            <phase>package</phase>\\n                            <goals>\\n                                <goal>exec</goal>\\n                            </goals>\\n                            <configuration>\\n                                <executable>npm</executable>\\n                                <arguments>\\n                                    <argumnet>run</argumnet>\\n                                    <argumnet>build</argumnet>\\n                                </arguments>\\n                                <workingDirectory>../admin-ui/</workingDirectory>\\n                            </configuration>\\n                        </execution>\\n                    </executions>\\n                </plugin>\\n​\\n            <!-- 把 react 编译后的 dist目录下的所有文件拷贝到resource目录下 -->\\n            <plugin>\\n                <groupId>org.apache.maven.plugins</groupId>\\n                <artifactId>maven-resources-plugin</artifactId>\\n                <executions>\\n                    <execution>\\n                        <id>copy-static</id>\\n                        <phase>validate</phase>\\n                        <goals>\\n                            <goal>copy-resources</goal>\\n                        </goals>\\n                        <configuration>\\n                            <outputDirectory>src/main/resources/static</outputDirectory>\\n                            <overwrite>true</overwrite>\\n                            <resources>\\n                                <resource>\\n                                    <!-- 因为react打包目录在项目根目录，所以从这里复制 -->\\n                                    <directory>../admin-ui/build</directory>\\n                                </resource>\\n                            </resources>\\n                        </configuration>\\n                    </execution>\\n                </executions>\\n            </plugin>\\n        </plugins>\\n    </build>\\n```\\n\\n平时调试和开发的时候依然可以像前后端分离那样，启动一个后端服务和一个前端服务，只在最终打包的时候打包在一块，所以这种方式哪怕是让一个专职前端来帮你写页面，对他来说也是无感知的，不需要关心后端干了啥。\\n\\n## 6. 最后\\n\\n好了，今天的文章就是以上这些内容了，本篇主要内容没有涉及到太多技术（当然也分享了一个前后端联合打包技巧），主要是分享了我自己在为项目写一些前端代码的心路历程，相信现在有很多工程师都对全栈很有兴趣，我也是想借此告诉大家，其实前端并没有太难学，几个小时完全可以上手写页面了。\\n\\n**Just do it.**\\n\\n最后，如果大家觉得本文还不错的话就可以点赞以示支持，对前端这块内容有更好的建议和说法也可以在评论区留言，我会积极对线的，下篇见。\\n\\n本系列其他文章：\\n\\n[「微服务网关实战一」SCG 和 APISIX 该怎么选？](https://juejin.cn/post/7152042679549820941/)\\n\\n[「微服务网关实战二」SCG + Nacos 动态感知上下线](https://juejin.cn/post/7152044620015206407)\\n\\n[「微服务网关实战三」详细理解 SCG 路由、断言与过滤器](https://juejin.cn/post/7153854448798793735/)\\n\\n[「微服务网关实战四」随意扩展定制的分布式限流，看看我怎么做](https://juejin.cn/post/7155514445702103047)\\n\\n[「微服务网关实战五」做网关系统， 99% 会被问到这个功能](https://juejin.cn/post/7157728507752087560)\\n",
        "tags": [
            "前端",
            "后端",
            "Java"
        ]
    },
    {
        "article_id": "7177758883140599863",
        "cover_image": "",
        "title": "你不知道的 Git 技巧：如何实现核心代码保护",
        "brief": "一般人不知道的 Git 知识，学完立刻就可以用起来了！前段时间完成了一个核心代码保护的功能，目标在关键代码被修改及时同步给其他人，避免没经过 review 就上线导致问题，提示的效果图如下：",
        "user_name": "张拭心",
        "view_count": 13720,
        "collect_count": 52,
        "comment_count": 10,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/acde3e2b7d3dce7572b63310fbb73898~300x300.image",
        "category": "开发工具",
        "content": "---\\ntheme: smartblue\\n---\\n***本文正在参加[「金石计划 . 瓜分6万现金大奖」](https://juejin.cn/post/7162096952883019783 \\\"https://juejin.cn/post/7162096952883019783\\\")***\\n\\n大家好，我是 shixin。\\n\\n前段时间完成了一个核心代码保护的功能，目标在关键代码被修改及时同步给其他人，避免没经过 review 就上线导致问题，提示的效果图如下：\\n\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b2c99126a66d467b9f7d660bda37b0cc~tplv-k3u1fbpfcp-watermark.image?)\\n\\n在实现的过程中，用到一些平时使用不多的 Git 技巧，这篇文章来总结一下。\\n\\n# 如何获取当前提交用户信息\\n\\n这个比较简单，通过 ``git config user.name`` 即可：\\n\\n```\\n04318deMacBook-Pro % git config user.name\\nzhangshixin\\n```\\n\\ngit config 保存了很多配置信息，其中常用的有自定义快捷键、用户信息、项目地址、分支信息等：\\n\\n```\\n504318deMacBook-Pro % git config -l\\n\\n//快捷键 begin >>> 我们可以定义自己的 git 快捷键\\nalias.st=status          \\nalias.co=checkout\\nalias.cb=checkout\\nalias.p=pull\\nalias.pr=pull\\nalias.pu=push\\nalias.cm=commit\\nalias.br=branch\\nalias.cm=commit\\nalias.undo=reset\\nalias.rbc=rebase\\nalias.save=stash\\nalias.pop=stash\\n//快捷键 end <<< 我们可以定义自己的 git 快捷键\\n\\n//用户名称和邮箱 begin >>>\\nuser.name=zhangshixin\\nuser.email=shixin.zhang@xxx.com\\n//用户名称和邮箱 end <<<\\n\\n//项目和分支信息 begin >>>\\nremote.origin.url=git@gitlab.xxx:android/xxx.git\\nremote.origin.fetch=+refs/heads/*:refs/remotes/origin/*\\nbranch.master.remote=origin\\nbranch.master.merge=refs/heads/master\\nbranch.Canary.remote=origin\\nbranch.Canary.merge=refs/heads/Canary\\n//项目和分支信息 end <<<\\n\\npull.rebase=true    //默认 pull 是 merge 还是 rebase\\n```\\n\\n\\n# 如何获取当前分支\\n\\n为了减少提示频率，最好只检测核心的分支的提交（包括 merge commit）。如何获取当前分支呢？有一个简单的方式：\\n\\n```\\ngit symbolic-ref --short HEAD\\n```\\n\\n这句命令主要包括两个关键字：``symbolic-ref`` 和 ``HEAD``。\\n\\n``symbolic-ref`` 可以读取、修改和删除符号引用。\\n\\n什么是符号引用呢？它表示一个以 refs 开头的文件（比如 refs/heads/develop），这个文件保存着本地每个分支当前所处 commit。\\n\\n我们可以打开 git 项目的 .git 文件夹，在其中的 refs/heads 文件夹中会保存各个分支当前所指向的 commit:\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/181af65000284a2a9e5791044063d455~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n``HEAD`` 指的是 .git/HEAD，就是一个文件，保存着当前指向的符号引用：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0139139554614921978bfbd59cf8d3b9~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n因此 ``git symbolic-ref --short HEAD`` 的含义就是读取 .git/HEAD 文件的内容，我这里就是 refs/heads/develop 文件，因此就得出当前分支是 develop 分支。\\n  \\n\\n# 如何获取本地未 push 的所有 commit\\n\\n有时候我们会在本地提交多次后再 push，因此在拦截 push 时，需要获取到当前要 push 的所有 commit 信息，然后获取每个 commit 修改的文件。\\n\\n获取要 push 信息可以通过 ``git log @{u}.. --oneline``:\\n\\n```\\n504318deMacBook-Pro ShixinDemo % git log @{u}.. --oneline\\n4e4655b (HEAD -> master) 拦截跳转\\nf947180 修改文件\\n```\\n\\n``git log`` 非常强大，它可以有这些使用场景：\\n1. 获取本地和远端的 commit 差异\\n2. 获取指定时间内的提交记录，可以具体到谁、什么时候、修改了哪些\\n3. 获取具体某次提交修改的文件\\n\\n上面我们使用的参数 ``@{u}..`` 就是表示获取本地和远端的 commit 差异，然后 ``--oneline`` 表示不打印具体信息，只打印 short commit id 和 commit message。\\n\\n如果要获取指定时间内的提交记录，可以这样：\\n```\\ngit log --pretty=\\\"%an(%cd) %h - %s\\\" --since=\\\"2022-09-01\\\" --no-merges --name-status\\n```\\n\\n命令执行结果：\\n```\\n504318deMacBook-Pro ShixinDemo % git log --pretty=\\\"%an(%cd) %h - %s\\\" --since=\\\"2022-09-01\\\" --no-merges --name-status\\nzhangshixin(Fri Dec 16 22:34:49 2022 +0800) 4e4655b - 拦截跳转\\n\\nM       app/src/main/java/com/example/heicdemo/MainActivity.kt\\nzhangshixin(Fri Dec 16 22:34:30 2022 +0800) f947180 - 修改文件\\n\\nM       .idea/gradle.xml\\nM       .idea/misc.xml\\nD       .idea/runConfigurations.xml\\nA       android10_dem_heic_output.heic\\nA       app/src/main/assets/android10_dem_heic_output.heic\\nR100    app/src/main/res/drawable/mushroom.jpg  app/src/main/assets/mushroom.jpg\\nA       app/src/main/assets/mushroom.webp\\nM       app/src/main/java/com/example/heicdemo/MainActivity.kt\\nA       app/src/main/res/drawable/mushroom.webp\\nM       app/src/main/res/layout/activity_main.xml\\n\\n```\\n\\n``pretty`` 的参数用于指定打印的内容和格式；``since`` 参数用于指定查看时间范围；``no-merges`` 表示过滤掉 merge 时生成的额外 commit；``name-status`` 表示展示出文件的修改状态（M 表示修改；D 表示删除；A 表示增加；R 表示重命名）。\\n\\n\\n\\n# 如何获取每个 commit 修改的文件\\n\\n知道 commit ID 后，可以通过 ``git show --pretty=\\\"\\\" --name-only $commitId`` 获取这个 commit 影响的信息：\\n\\n```\\n04318deMacBook-Pro ShixinDemo % git show --pretty=\\\"\\\" --name-only 4e4655b  \\napp/src/main/java/com/example/shixindemo/MainActivity.kt\\n```\\n\\n``git show`` 可以用来查看 commit 的 commit message 和修改的文件、文件具体内容等信息。上面的代码中我们使用了 ``name-only`` 参数表示只要查看修改的文件即可。\\n\\n# 总结\\n\\n这篇文章介绍了通过拦截 git push 时，获取当前用户、当前分支、未 push 的 commit 和修改的文件等命令，通过组合这些命令，就可以实现一个核心代码保护功能了！",
        "tags": [
            "掘金·金石计划",
            "前端",
            "后端"
        ]
    },
    {
        "article_id": "7191281073517494332",
        "cover_image": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2aaa32df991949ba8b84f84b9cae6344~tplv-k3u1fbpfcp-watermark.image?",
        "title": "Fabric.js 元素选中状态的事件与样式",
        "brief": "🐵带尬猴！ 你是否在使用 Fabric.js 时希望能在选中元素后自定义元素样式或选框（控制角和辅助线）的样式？ 如果是的话，可以放心往下读。",
        "user_name": "德育处主任",
        "view_count": 2786,
        "collect_count": 23,
        "comment_count": 9,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/221976c6804d412aa876fdd5154129ae~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: smartblue\\n---\\n\\n# 本文简介\\n\\n带尬猴！\\n\\n你是否在使用 `Fabric.js` 时希望能在选中元素后自定义元素样式或选框（控制角和辅助线）的样式？\\n\\n\\n![01.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1c790ecd8ab47a999f67e491ac93d19~tplv-k3u1fbpfcp-watermark.image?)\\n\\n如果是的话，可以放心往下读。\\n\\n本文将手把脚和你一起过一遍 `Fabric.js` 在对象元素选中后常用的样式设置。\\n\\n我将对象元素选中后的设置分成3类进行讲解：\\n\\n- 控制角\\n- 辅助边\\n- 其他样式\\n- 状态\\n\\n<br>\\n<br>\\n\\n# 准备工作\\n\\n创建一个画布和一个圆形。为什么是圆形而不是矩形？等下你就知道了。\\n\\n\\n![02.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a085511b2074fe9ac2c7eee4d6197a0~tplv-k3u1fbpfcp-watermark.image?)\\n\\n```html\\n<canvas id=\\\"c\\\" style=\\\"border: 1px solid #ccc;\\\"></canvas>\\n\\n<script>\\n  const canvas = new fabric.Canvas('c', {\\n    width: 400,\\n    height: 400,\\n  })\\n\\n  let circle = new fabric.Circle({\\n    top: 80,\\n    left: 80,\\n    radius: 50,\\n    fill: '#ffde7d' // 淡黄色\\n  })\\n\\n  canvas.add(circle)\\n</script>\\n```\\n\\n一个蛋黄出现了。上面这段代码是 `Fabric.js` 的基础。如果不太了解或者忘记语法了，可以查看 [《Fabric.js 从入门到膨胀》](https://juejin.cn/post/7026941253845516324)。\\n\\n我最近也在整理 `Fabric.js` 的常用方法，有兴趣的可以看看 [《Fabric.js中文教程》](https://k21vin.gitee.io/fabric-js-doc/)\\n\\n<br>\\n<br>\\n\\n# 约定\\n\\n本文所说的控制角和辅助边请看下图。翻译能力有限，将就理解下吧~\\n\\n\\n![03.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab342bce456b4da48f76152e8c8f092f~tplv-k3u1fbpfcp-watermark.image?)\\n\\n<br><br>\\n\\n# 控制角\\n\\n控制角就是选中元素后周边出现的几个方形。\\n\\n<br>\\n\\n## 实心控制角\\n\\n默认情况下，控制角是空心的。也就是只有边框，没有填充色。\\n\\n如果想要做成实心的控制角，只需将元素的 `transparentCorners` 属性设置为 `true` 即可。\\n\\n\\n![04.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd45b502ea4b4fc0b904e1ff899f95f4~tplv-k3u1fbpfcp-watermark.image?)\\n\\n```js\\n// 省略部分代码\\nlet circle = new fabric.Circle({\\n  transparentCorners: false,\\n  // 其他配置...\\n})\\n```\\n\\n<br>\\n\\n## 控制角颜色\\n\\n元素的 `cornerColor` 属性可以控制控制角的颜色。\\n\\n\\n![05.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20d97a73d33049dc85ac0c47e801f18e~tplv-k3u1fbpfcp-watermark.image?)\\n\\n```js\\n// 省略部分代码\\nlet circle = new fabric.Circle({\\n  transparentCorners: false,\\n  cornerColor: 'pink',\\n  // 其他配置...\\n})\\n```\\n\\n此时控制角的边框颜色和填充颜色都变成了粉红色。\\n\\n<br>\\n\\n## 控制角边框颜色\\n\\n如果你想单独设置控制角的边框颜色也行！要设置的属性叫 `cornerStrokeColor`。\\n\\n![06.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b748536bec564682bac1acecd89dcc95~tplv-k3u1fbpfcp-watermark.image?)\\n\\n```js\\n// 省略部分代码\\nlet circle = new fabric.Circle({\\n  transparentCorners: false,\\n  cornerColor: 'pink',\\n  cornerStrokeColor: 'blue',\\n  // 其他配置...\\n})\\n```\\n\\n<br>\\n\\n## 控制角大小\\n\\n想修改控制角的大小，可以修改 `cornerSize` 的值。\\n\\n\\n![07.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/842d4162f1994f9f828c8615e38d9cd8~tplv-k3u1fbpfcp-watermark.image?)\\n\\n```js\\n// 省略部分代码\\nlet circle = new fabric.Circle({\\n  cornerSize: 30,\\n  // 其他配置...\\n})\\n```\\n\\n和前面的例子对比，将 `cornerSize` 设置成 `30` 之后，控制角明显大了很多。\\n\\n<br>\\n\\n## 控制角边框虚线规则\\n\\n控制角那几个小把手的边框是可以设置成虚线的。要调整的参数是 `cornerDashArray` ，该参数的值是一个数值型数组。\\n\\n虚线的规则主要分以下几种情况：\\n\\n- 数组只有1个元素：虚线和实现的长度相等。\\n- 数组有2个元素：第一个元素是实线长度，第二个元素是虚线长度。\\n- 数组有3个或3个以上的元素：实线、虚线、实线、虚线…… 一直轮回下去。\\n\\n为了方便演示，我先将控制角的尺寸设置得大一点。\\n\\n### 情况1：数组只有1个元素\\n\\n\\n![08.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c91e451d04c747e4b5eb8b73167cce8e~tplv-k3u1fbpfcp-watermark.image?)\\n\\n```js\\n// 省略部分代码\\nlet circle = new fabric.Circle({\\n  cornerSize: 30,\\n  cornerDashArray: [4],\\n  // 其他配置...\\n})\\n```\\n\\n### 情况2：数组有2个元素\\n\\n\\n![09.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99e30a17ccd94d7fa44de39966e7bb78~tplv-k3u1fbpfcp-watermark.image?)\\n\\n```js\\n// 省略部分代码\\nlet circle = new fabric.Circle({\\n  cornerSize: 30,\\n  cornerDashArray: [4, 10],\\n  // 其他配置...\\n})\\n```\\n\\n### 情况3：数组有3个或3个以上的元素\\n\\n\\n![10.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/752510a6c1ce4362bd1dadd047a6584a~tplv-k3u1fbpfcp-watermark.image?)\\n\\n```js\\n// 省略部分代码\\nlet circle = new fabric.Circle({\\n  cornerSize: 30,\\n  cornerDashArray: [4, 10, 20],\\n  // 其他配置...\\n})\\n```\\n\\n<br>\\n\\n## 控制角形状\\n\\n控制角除了是正方形外，还可以将它设置成圆形。只需将 `cornerStyle` 设置为 `circle` 即可。\\n\\n\\n![11.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/877d54cafcd54fb3addc9618316ff59b~tplv-k3u1fbpfcp-watermark.image?)\\n\\n```js\\n// 省略部分代码\\nlet circle = new fabric.Circle({\\n  cornerStyle: 'circle',\\n  // 其他配置...\\n})\\n```\\n\\n<br><br>\\n\\n# 辅助边\\n\\n前面说完控制角，接下来讲讲辅助边\\n\\n<br>\\n\\n## 辅助边颜色\\n\\n我们可以通过 `selectionBackgroundColor` 属性设置辅助边的颜色。\\n\\n\\n![12.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7144c61533a649c6b8297ff3af677675~tplv-k3u1fbpfcp-watermark.image?)\\n\\n```js\\n// 省略部分代码\\nlet circle = new fabric.Circle({\\n  borderColor: 'red',\\n  // 其他配置...\\n})\\n```\\n\\n<br>\\n\\n## 辅助边粗细\\n\\n设置辅助边粗细的属性名叫 `borderScaleFactor`。\\n\\n\\n![13.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f0a36344848344dea9f334f01b273a14~tplv-k3u1fbpfcp-watermark.image?)\\n\\n```js\\n// 省略部分代码\\nlet circle = new fabric.Circle({\\n  borderScaleFactor: 4,\\n  // 其他配置...\\n})\\n```\\n\\n<br>\\n\\n## 辅助边虚线规则\\n\\n设置辅助边虚线规则使用的属性是 `borderDashArray`。使用规则和 `cornerDashArray` 是一样的。\\n\\n\\n![14.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/53030f26296347c1b927d2853ccf7d94~tplv-k3u1fbpfcp-watermark.image?)\\n\\n```js\\n// 省略部分代码\\nlet circle = new fabric.Circle({\\n  borderDashArray: [10, 20, 30],\\n  // 其他配置...\\n})\\n```\\n\\n<br><br>\\n\\n# 其他样式\\n\\n## 内边距\\n\\n设置内边距的属性是 `padding`，这名字和 `css` 的内边距是一样的。\\n\\n在 `Fabric.js` 中，给元素设置了内边距，会影响控制角和辅助边到元素边缘的距离。\\n\\n`padding` 接受一个数值，不需要传入单位。\\n\\n\\n![15.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8e58955e8414a269686fd0bc0ac8e83~tplv-k3u1fbpfcp-watermark.image?)\\n\\n```js\\n// 省略部分代码\\nlet circle = new fabric.Circle({\\n  padding: 20,\\n  // 其他配置...\\n})\\n```\\n\\n和前面的例子对比一下，将 `padding` 设置为 `20` 后，辅助边和元素之间的距离明显增大了。\\n\\n<br>\\n\\n## 背景色\\n\\n这里所说的背景色和 `css` 里面的背景色不是同一回事。\\n\\n本文要介绍 `Fabric.js` 的背景色有2种。一种是元素自身的背景色，另一种是选中后的背景色。\\n\\n在 `Fabric.js` 里，背景色和填充色是两回事。\\n\\n- 填充色：`fill`\\n- 背景色：`backgroundColor`\\n- 选中后的背景色：`selectionBackgroundColor`\\n\\n填充色是基础，忘了的话可以查看  [《Fabric.js 从入门到膨胀》](https://juejin.cn/post/7026941253845516324) ，本文不再讲解。\\n\\n`Fabric.js` 是以矩形的方式去计算元素占位面积的，这也很好理解，比较方便嘛。所以使用 `backgroundColor` 设置背景颜色就能看到元素占据多大面积了。\\n\\n\\n![16.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b2746cf89fd48c88653974361d4c63d~tplv-k3u1fbpfcp-watermark.image?)\\n\\n```js\\n// 省略部分代码\\nlet circle = new fabric.Circle({\\n  fill: '#ffde7d',\\n  backgroundColor: '#f6416c',\\n  // 其他配置...\\n})\\n```\\n\\n<br>\\n\\n而 `selectionBackgroundColor` 属性是设置元素选中后的背景色。\\n\\n但需要注意，如果你同时设置了 `backgroundColor` 和 `selectionBackgroundColor`，重叠的部分 `backgroundColor` 的优先级更高。\\n\\n那什么地方才是不重叠的地方呢？那就是设置了 `padding` 的地方。\\n\\n\\n![17.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/19518ca35d754aea9e2b9a91dfcc4f08~tplv-k3u1fbpfcp-watermark.image?)\\n\\n```js\\n// 省略部分代码\\nlet circle = new fabric.Circle({\\n  fill: '#ffde7d',\\n  backgroundColor: '#f6416c',\\n  padding: 20,\\n  selectionBackgroundColor: '#00b8a9',\\n  // 其他配置...\\n})\\n```\\n\\n<br>\\n\\n## 移动元素时的透明度\\n\\n元素移动时会先进入选中状态。此时会产生控制角和辅助线。\\n\\n你可以使用 `borderOpacityWhenMoving` 设置控制角和辅助线的透明度。这个属性接受 `0 ~ 1` 的值。\\n\\n`0` 表示完全透明，`1` 表示完全不透明。\\n\\n**注意，borderOpacityWhenMoving 设置的是『移动时』控制角和辅助边的透明度。** 重点词是 **『移动时』**。\\n\\n\\n![18.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e5df3b63f82475f824d0383bf49a979~tplv-k3u1fbpfcp-watermark.image?)\\n\\n```js\\n// 省略部分代码\\nlet circle = new fabric.Circle({\\n  borderOpacityWhenMoving: 0.1,\\n  // 其他配置...\\n})\\n```\\n\\n本例将 `borderOpacityWhenMoving` 设置为 `0.1` ，所以移动时就只能隐隐约约看到控制角和辅助边了。\\n\\n<br><br>\\n\\n# 状态\\n\\n我把能否选中、局部控制操作等内容放在“状态”章节里。\\n\\n<br>\\n\\n## 禁止选中\\n\\n如果你不希望元素被选中，可以将元素的 `selectable` 属性设置为 `false`。\\n\\n\\n![19.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c52ded1e782a44d981b12ff72b572077~tplv-k3u1fbpfcp-watermark.image?)\\n\\n```js\\n// 省略部分代码\\nlet circle = new fabric.Circle({\\n  borderOpacityWhenMoving: 0.1,\\n  // 其他配置...\\n})\\n```\\n\\n<br>\\n\\n## 无法通过空白区域操作元素\\n\\n如果图形不是矩形，在选中元素后，辅助边和图形之间会有一个空白区。也就是前面用 `backgroundColor` 填充的那部分。\\n\\n\\n![20.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bbc9692df9cb49788f46b97d26fdd77e~tplv-k3u1fbpfcp-watermark.image?)\\n\\n箭头所指的4个地方都是空白区域。\\n\\n默认情况下，你可以点击空白区选中或者拖拽图形。\\n\\n但如果你希望只能点击图形区域才能选中图形的话，可以将图形的 `perPixelTargetFind` 属性设置为 `true`。\\n\\n\\n![21.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a574c79983b343f78cec9f6f1844f8e5~tplv-k3u1fbpfcp-watermark.image?)\\n\\n```js\\n// 省略部分代码\\nlet circle = new fabric.Circle({\\n  perPixelTargetFind: true,\\n  // 其他配置...\\n})\\n```\\n\\n<br>\\n\\n## 隐藏控制角\\n\\n可以通过 `hasControls` 属性设置控制角的显示和隐藏。\\n\\n如果将 `hasControls` 设置为 `false` ，就会将控制角隐藏起来，你也就无法通过控制角去缩放和旋转元素了。\\n\\n\\n![22.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9981f3ee75974c969829d6de8cb94ba8~tplv-k3u1fbpfcp-watermark.image?)\\n\\n```js\\n// 省略部分代码\\nlet circle = new fabric.Circle({\\n  hasControls: false,\\n  // 其他配置...\\n})\\n```\\n\\n<br>\\n\\n## 隐藏辅助边\\n\\n同样你也可以将辅助边隐藏起来，只需将 `hasBorders` 属性设置为 `false` 即可。\\n\\n\\n![23.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/676f597722424ccd856d8bde23b6246f~tplv-k3u1fbpfcp-watermark.image?)\\n\\n```js\\n// 省略部分代码\\nlet circle = new fabric.Circle({\\n  hasBorders: false,\\n  // 其他配置...\\n})\\n```\\n\\n<br>\\n\\n## 设置控制角的可见性\\n\\n前面将 `hasControls` 属性设置为 `false` 后就可以隐藏所有控制角。\\n\\n其实 `Fabric.js` 还提供了2个方法可以单独设置指定控制角的可见性：\\n\\n- `setControlsVisibility(optionsopt)`：批量设置控制角可见性\\n- `setControlVisible(controlKey, visible)`：单独设置控制角可见性\\n\\n这两个方法的作用是一样的，只是使用方式上有点不同。\\n\\n**需要注意的是，一旦把控制角隐藏起来，就意味着不能通过被隐藏的控制角去缩放和旋转元素了**。\\n\\n<br>\\n\\n在使用者两个方法之前，你需要了解一堆属性：`tl`, `tr`, `br`, `bl`, `ml`, `mt`, `mr`, `mb`, `mtr`，它们分别对应9个控制点，如下图所示。\\n\\n\\n![24.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0943c8a775604f52b9531120c69c650a~tplv-k3u1fbpfcp-watermark.image?)\\n\\n<br>\\n\\n### setControlsVisibility(optionsopt)\\n\\n`setControlsVisibility()` 方法接收一个对象参数，在这对象中可以描述要显示或者隐藏哪些控制角。\\n\\n比如我想把左上角和右下角隐藏。\\n\\n\\n![25.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/62484bc893b84cfbb400b0e5817c71af~tplv-k3u1fbpfcp-watermark.image?)\\n\\n```js\\n// 省略部分代码\\nlet circle = new fabric.Circle({\\n  // 其他配置...\\n})\\n\\ncircle.setControlsVisibility({\\n  tl: false,\\n  br: false\\n})\\n```\\n\\n<br>\\n\\n### setControlVisible(controlKey, visible)\\n\\n`setControlVisible()` 方法一次只能设置1个控制角的可见性，它接收2个参数。第一个参数是要操作的控制角，第二个参数是控制角的显示状态。\\n\\n比如我想将左下角的控制角隐藏起来。\\n\\n\\n![26.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d8c55c8513c47e2b1d0fa694b17839a~tplv-k3u1fbpfcp-watermark.image?)\\n\\n```js\\n// 省略部分代码\\nlet circle = new fabric.Circle({\\n  // 其他配置...\\n})\\n\\ncircle.setControlsVisibility('bl', false)\\n```\\n\\n<br>\\n\\n## 返回控制角的可见性\\n\\n可以使用 `isControlVisible(controlKey)` 方法获取控制角当前的可见性。\\n\\n```js\\n// 省略部分代码\\nlet circle = new fabric.Circle({\\n  // 其他配置...\\n})\\n\\ncircle.setControlsVisibility('bl', false)\\n\\nconsole.log(circle.isControlVisible('bl')) // 返回 false\\nconsole.log(circle.isControlVisible('br')) // 返回 true\\n```\\n\\n<br>\\n\\n## 获取当前被选中的对象\\n\\n`Fabric.js` 还提供了2个方法可以捕捉到当前被选中的对象。这2个方法分别叫 `getActiveObject()` 和 `getActiveObjects()` 。需要在 `canvas` 对象中调用的。\\n\\n<br>\\n\\n`getActiveObject()` 和 `getActiveObjects()` 从名字来看就已经知道，末尾没加 `s` 的就是返回当前选中的元素；末尾加了 `s` 的就是返回当前选中的所有元素（比如通过框选操作选择了一堆元素）。\\n\\n选中元素时，`getActiveObject()` 会返回的当前元素对象，而 `getActiveObjects()` 则返回一个数组集合。\\n\\n没选中元素时，`getActiveObject()` 会返回 `null`，而 `getActiveObjects()` 会返回一个空数组。\\n\\n<br>\\n\\n可以通过这两个方法获取当前选中的对象再做其他操作（比如修改填充颜色、描边颜色、描边粗细等）。\\n\\n<br><br>\\n\\n# 代码仓库\\n\\n⭐ [Fabric.js 元素选中状态的事件与样式](https://gitee.com/k21vin/fabricjs-demo/blob/master/tutorial/Object/selection.html)\\n\\n<br>\\n<br>\\n\\n# 推荐阅读\\n\\n我最近在整理 `Fabric.js` 常用方法，有兴趣的可以看看 [《Fabric.js中文教程》](https://k21vin.gitee.io/fabric-js-doc/)\\n\\n<br>\\n\\n👍[《Fabric.js 拖放元素进画布》](https://juejin.cn/post/7186836299209244733)\\n\\n👍[《Fabric.js 限制边框宽度缩放》](https://juejin.cn/post/7179894655524274234)\\n\\n👍[《Fabric.js 监听元素相交(重叠)》](https://juejin.cn/post/7169855784249983013)\\n\\n👍[《Fabric.js 橡皮擦的用法（包含恢复功能）》](https://juejin.cn/post/7097379869276766238)\\n\\n👍[《Fabric.js 喷雾笔刷 从入门到放肆》](https://juejin.cn/post/7146013798854295589)\\n\\n👍[《Fabric.js 设置容器类名要注意这几点》](https://juejin.cn/post/7144178650290585637)\\n\\n<br>\\n\\n**点赞 + 关注 + 收藏 = 学会了**",
        "tags": [
            "前端",
            "Canvas",
            "数据可视化"
        ]
    },
    {
        "article_id": "7165159142867337247",
        "cover_image": "https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f329b5464bd4493f8fbc49b331846eb2~tplv-k3u1fbpfcp-watermark.image?",
        "title": "手写一个埋点SDK吧~",
        "brief": "写在前面 博主最近半年的时间都在投入 concis react组件库的开发，最近阶段也是想要做一些市面组件库所没有的东西，concis 主要为业务平台开发提供了一系列组件，而埋点在业务中的实用性是很高",
        "user_name": "冯心心爱吃肉",
        "view_count": 3361,
        "collect_count": 75,
        "comment_count": 8,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/b8d0db11129c4cbfe51c6f5b9f7aa2b5~300x300.image",
        "category": "前端",
        "content": "# 写在前面\\n\\n博主最近半年的时间都在投入 `concis` react组件库的开发，最近阶段也是想要做一些市面组件库所没有的东西，`concis` 主要为业务平台开发提供了一系列组件，而埋点在业务中的实用性是很高的，搭配业务端埋点和后台监控，可以收集到很多信息，如性能参数、错误捕捉、请求响应过慢等一系列问题，因此本文记录了开发一个埋点SDK组件的全过程。\\n\\n# 效果\\n\\n先看使用方式吧，这是一个普通的`React` 项目中的 `App.jsx` 组件：\\n\\n```javascript\\nimport React from 'react'\\nimport { Route, Routes } from \\\"react-router-dom\\\";\\nimport A from './pages/A';\\nimport B from './pages/B'\\nimport { Track } from 'concis'\\n\\nfunction App() {\\n  const trackRef = React.useRef();\\n\\n  // 用在项目根目录，定时上报，如每隔一小时上报一次\\n  setInterval(() => {\\n    getTrackData();\\n  }, 60 * 60 * 1000)\\n\\n  function getTrackData() {\\n    const res = trackRef.current.callbackTrackData();\\n    //接口上报...\\n  }\\n\\n  return (\\n    <div>\\n      <Routes>\\n        <Route path=\\\"/\\\" element={<A />} />\\n        <Route path=\\\"/a\\\" element={<A />} />\\n        <Route path=\\\"/b\\\" element={<B />} />\\n      </Routes>\\n      <Track ref={trackRef} />\\n    </div>\\n  )\\n}\\n```\\n\\n`Track` 组件运行在项目根目录，做到每个页面信息收集的作用，并且向外暴露了 `callbackTrackData` api，可以结合业务中的场景，在指定时刻收集信息，并上报到后端。\\n\\n# 思路\\n\\n`Track` 组件本身并不复杂，其实就是将一系列数据采集、信息捕捉、请求拦截汇集在了组件内部，并记录在状态中，在需要的时候向外暴露。\\n\\n因此在组件中定义这些状态：\\n\\n```javascript\\nconst Track = (props, ref) => {\\n  const { children } = props;\\n\\n  const [performanceData, setPerformanceData] = useState({});\\n  const xhrRequestResList = useRef([]);\\n  const fetchRequestResList = useRef([]);\\n  const resourceList = useRef({});\\n  const userInfo = useRef({});\\n  const errorList = useRef([]);\\n  const clickEventList = useRef([]);\\n  \\n  //...\\n  \\n  return (\\n      //...\\n  )\\n  \\n}\\n```\\n\\n- `performanceData`用于收集页面性能相关参数，如FP、FCP、FMP、LCP、DOM Load、white time等一系列参数。\\n- `xhrRequestResList`用于捕获页面中所有`xhr` 请求，收集请求方式、响应完成时间。\\n- `fetchRequestResList`用于捕获页面中所有`fetch` 请求，收集请求方式、响应完成时间。\\n- `resourceList`用于收集页面中所有文件、静态资源的请求数据，如`js`、`css`、`img`。\\n- `userInfo`用于收集用户相关信息，如浏览器参数、用户IP、城市、语言等。\\n- `errorList`用于收集发生在生产环境下错误的捕获，包括`error`和`rejectError`。\\n- `clickEventList`用于收集用户在页面上的点击行为。\\n\\n# performanceData\\n\\n页面加载相关的性能参数代码如下：\\n\\n```javascript\\nconst collectPerformance = async () => {\\n    const fp = await collectFP();\\n    const fcp = await collectFCP();\\n    const lcp = await collectLCP();\\n    const loadTime = await collectLoadTime();\\n    const dnsQueryTime = collectDNSQueryTime();\\n    const tcpConnectTime = collectTCPConnectTime();\\n    const requestTime = collectRequestTime();\\n    const parseDOMTreeTime = collectParseDOMTree();\\n    const whiteTime = collectWhiteTime();\\n    setPerformanceData({\\n      fp,\\n      fcp,\\n      lcp,\\n      dnsQueryTime,\\n      tcpConnectTime,\\n      requestTime,\\n      parseDOMTreeTime,\\n      whiteTime,\\n      loadTime,\\n    });\\n  };\\n```\\n\\n这里以`fp`、`fcp`举例，主要用到了`PerformanceObserver` api，收集这些参数，代码如下：\\n\\n```javascript\\nconst collectFP = () => {\\n  return new Promise((resolve) => {\\n    const entryHandler = (list) => {\\n      for (const entry of list.getEntries()) {\\n        if (entry.name === 'first-paint') {\\n          resolve(entry);\\n          observer.disconnect();\\n        }\\n      }\\n    };\\n    const observer = new PerformanceObserver(entryHandler);\\n    observer.observe({ type: 'paint', buffered: true });\\n  });\\n};\\n\\nconst collectFCP = () => {\\n  return new Promise((resolve) => {\\n    const entryHandler = (list) => {\\n      for (const entry of list.getEntries()) {\\n        if (entry.name === 'first-contentful-paint') {\\n          resolve(entry);\\n          observer.disconnect();\\n        }\\n      }\\n    };\\n    const observer = new PerformanceObserver(entryHandler);\\n    observer.observe({ type: 'paint', buffered: true });\\n  });\\n};\\n```\\n\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d360de99e1e14e05afdf045d237119d0~tplv-k3u1fbpfcp-watermark.image?)\\n\\n而其他参数则是直接使用了 `window.performance.timing` 计算得来。\\n\\n# xhrRequestResList\\n\\n捕获`xhr`请求其实很简单，在原有的`XMLHttpRequest.prototype`上的`open`、`send`方法上记录我们所需要的参数，如`url`、`method`，同时在`send`方法中介入`loadend`方法，当请求完成，整理参数。\\n\\n```javascript\\n// 统计每个xhr网络请求的信息\\nconst monitorXHRRequest = (callback) => {\\n  const originOpen = XMLHttpRequest.prototype.open;\\n  const originSend = XMLHttpRequest.prototype.send;\\n  XMLHttpRequest.prototype.open = function newOpen(...args) {\\n    this.url = args[1];\\n    this.method = args[0];\\n    originOpen.apply(this, args);\\n  };\\n\\n  XMLHttpRequest.prototype.send = function newSend(...args) {\\n    this.startTime = Date.now();\\n\\n    const onLoadend = () => {\\n      this.endTime = Date.now();\\n      this.duration = this.endTime - this.startTime;\\n\\n      const { status, duration, startTime, endTime, url, method } = this;\\n      const reportData: xhrRequestType = {\\n        status,\\n        duration,\\n        startTime,\\n        endTime,\\n        url,\\n        method: (method || 'GET').toUpperCase(),\\n        success: status >= 200 && status < 300,\\n        subType: 'xhr',\\n        type: 'performance',\\n      };\\n      callback(reportData);\\n      this.removeEventListener('loadend', onLoadend, true);\\n    };\\n\\n    this.addEventListener('loadend', onLoadend, true);\\n    originSend.apply(this, args);\\n  };\\n};\\n\\n```\\n\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f475c448c10445987808a67347d3082~tplv-k3u1fbpfcp-watermark.image?)\\n\\n当状态码在200~300之间，则判定为success，最后通过异步回调函数的机制，回传到组件中，加入状态。\\n\\n# fetchRequestResList\\n\\n捕获 `fetch` 思路和 `xhr` 类似，只不过`fetch` 本身基于 `promise` 实现，在重写 `fetch` api的时候通过`promise`的形式去写就可以。\\n\\n```javascript\\n// 统计每个fetch请求的信息\\nconst monitorFetchRequest = (callback) => {\\n  const originalFetch = window.fetch;\\n\\n  function overwriteFetch() {\\n    window.fetch = function newFetch(url, config) {\\n      const startTime = Date.now();\\n      const reportData: fetchRequestType = {\\n        startTime,\\n        endTime: 0,\\n        duration: 0,\\n        success: false,\\n        status: 0,\\n        url,\\n        method: (config?.method || 'GET').toUpperCase(),\\n        subType: 'fetch',\\n        type: 'performance',\\n      };\\n      return originalFetch(url, config)\\n        .then((res) => {\\n          reportData.endTime = Date.now();\\n          reportData.duration = reportData.endTime - reportData.startTime;\\n          const data = res.clone();\\n          reportData.status = data.status;\\n          reportData.success = data.ok;\\n          callback(reportData);\\n          return res;\\n        })\\n        .catch((err) => {\\n          reportData.endTime = Date.now();\\n          reportData.duration = reportData.endTime - reportData.startTime;\\n          reportData.status = 0;\\n          reportData.success = false;\\n          callback(reportData);\\n          throw err;\\n        });\\n    };\\n  }\\n  overwriteFetch();\\n};\\n```\\n\\n和`xhr`一样，最后通过异步回调函数的形式回传到组件中。\\n\\n# resourceList\\n\\n获取页面中网络请求以外的其他资源，通过 `window.performance.getEntriesByType` api，整理出指定资源的信息，最后组装成一个`resource` 列表。\\n\\n```javascript\\nconst getResources = () => {\\n  if (!window.performance) return;\\n  const data = window.performance.getEntriesByType('resource');\\n  const resource = {\\n    xmlhttprequest: [],\\n    css: [],\\n    other: [],\\n    script: [],\\n    img: [],\\n    link: [],\\n    fetch: [],\\n    // 获取资源信息时当前时间\\n    time: new Date().getTime(),\\n  };\\n  data.forEach((item: resourceItemType<number> & PerformanceEntry) => {\\n    const arry = resource[item.initiatorType];\\n    arry &&\\n      arry.push({\\n        name: item.name, // 资源名称\\n        type: 'resource',\\n        sourceType: item.initiatorType, // 资源类型\\n        duration: +item.duration.toFixed(2), // 资源加载耗时\\n        dns: item.domainLookupEnd - item.domainLookupStart, // DNS 耗时\\n        tcp: item.connectEnd - item.connectStart, // 建立 tcp 连接耗时\\n        redirect: item.redirectEnd - item.redirectStart, // 重定向耗时\\n        ttfb: +item.responseStart.toFixed(2), // 首字节时间\\n        protocol: item.nextHopProtocol, // 请求协议\\n        responseBodySize: item.encodedBodySize, // 响应内容大小\\n        resourceSize: item.decodedBodySize, // 资源解压后的大小\\n        isCache: isCache(item), // 是否命中缓存\\n        startTime: performance.now(),\\n      });\\n  });\\n  function isCache(entry) {\\n    // 直接从缓存读取或 304\\n    return entry.transferSize === 0 || (entry.transferSize !== 0 && entry.encodedBodySize === 0);\\n  }\\n\\n  return resource;\\n};\\n```\\n\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d285d5710e4c4b3182cc2df91aaebc2d~tplv-k3u1fbpfcp-watermark.image?)\\n\\n# userInfo\\n\\n用户信息分为两类：\\n\\n- 浏览器(navigator)的信息；\\n- 用户本身的信息，如IP、所在位置；\\n\\n这里获取第二类的方式通过第三方接口接入：\\n\\n```javascript\\nconst getUserIp = () => {\\n  return new Promise((resolve, reject) => {\\n    const scriptElement = document.createElement('script');\\n    scriptElement.src = `https://pv.sohu.com/cityjson?ie=utf-8`;\\n    document.body.appendChild(scriptElement);\\n    scriptElement.onload = () => {\\n      try {\\n        document.body.removeChild(scriptElement);\\n        // @ts-ignore\\n        resolve(window.returnCitySN);\\n      } catch (e) {\\n        reject(e);\\n      }\\n    };\\n  });\\n};\\n```\\n\\n获取浏览器相关的参数代码如下：\\n\\n```javascript\\nconst getNativeBrowserInfo = () => {\\n  const res: nativeBrowserInfoType = {};\\n  if (document) {\\n    res.domain = document.domain || ''; // 获取域名\\n    // res.url = String(document.URL) || ''; //当前Url地址\\n    res.title = document.title || '';\\n    // res.referrer = String(document.referrer) || ''; //上一跳路径\\n  }\\n  // Window对象数据\\n  if (window && window.screen) {\\n    res.screenHeight = window.screen.height || 0; // 获取显示屏信息\\n    res.screenWidth = window.screen.width || 0;\\n    res.color = window.screen.colorDepth || 0;\\n  }\\n  // navigator对象数据\\n  if (navigator) {\\n    res.lang = navigator.language || ''; // 获取所用语言种类\\n    res.ua = navigator.userAgent.toLowerCase(); // 运行环境\\n  }\\n  return res;\\n};\\n```\\n\\n总体列表如图：\\n\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/59b3aa61a10d4b3aa48104563fadfcc4~tplv-k3u1fbpfcp-watermark.image?)\\n\\n# errorList\\n\\n捕捉错误分为了同步错误（console.aaa(123)）和异步错误（promise所遗漏未捕捉到的reject）\\n\\n因此在全局挂载两个通用事件，当捕获到错误时推入错误列表中即可。\\n\\n```javascript\\nconst getJavaScriptError = (callback) => {\\n  window.addEventListener('error', ({ message, filename, type }) => {\\n    callback({\\n      msg: message,\\n      url: filename,\\n      type,\\n      time: new Date().getTime(),\\n    });\\n  });\\n};\\n\\nconst getJavaScriptAsyncError = (callback) => {\\n  window.addEventListener('unhandledrejection', (e) => {\\n    callback({\\n      type: 'promise',\\n      msg: (e.reason && e.reason.msg) || e.reason || '',\\n      time: new Date().getTime(),\\n    });\\n  });\\n};\\n```\\n\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2fc852828ff44a129f14ba489e807806~tplv-k3u1fbpfcp-watermark.image?)\\n\\n# clickEventList\\n\\n收集点击行为信息原理是全局挂载`mouseDown`、`touchstart`事件，在触发事件时收集`DOM`事务相关信息，代码如下：\\n\\n```javascript\\nconst onClick = (callback) => {\\n  ['mousedown', 'touchstart'].forEach((eventType) => {\\n    let timer;\\n    window.addEventListener(eventType, (event) => {\\n      clearTimeout(timer);\\n      timer = setTimeout(() => {\\n        const target = event.target as eventDom & EventTarget;\\n        const { top, left } = (target as any).getBoundingClientRect();\\n        callback({\\n          top,\\n          left,\\n          eventType,\\n          pageHeight: document.documentElement.scrollHeight || document.body.scrollHeight,\\n          scrollTop: document.documentElement.scrollTop || document.body.scrollTop,\\n          type: 'behavior',\\n          subType: 'click',\\n          target: target.tagName,\\n          paths: (event as any).path?.map((item) => item.tagName).filter(Boolean),\\n          startTime: event.timeStamp,\\n          outerHTML: target.outerHTML,\\n          innerHTML: target.innerHTML,\\n          width: target.offsetWidth,\\n          height: target.offsetHeight,\\n          viewport: {\\n            width: window.innerWidth,\\n            height: window.innerHeight,\\n          },\\n        });\\n      }, 500);\\n    });\\n  });\\n};\\n```\\n\\n可以捕获到对应`DOM`节点的触发时机和位置信息，在后台分析数据时过滤出指定的`DOM`可以对于热门用户行为进行分析报告。\\n\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/779475ee4ed346ffbb3b142958145eb6~tplv-k3u1fbpfcp-watermark.image?)\\n\\n# 写在最后\\n\\n至此，`Track` 组件写完了，业务方可以结合`Track` 组件在需要上报的时机进行数据收集，这其实是 `concis` 给业务端做出的收集层的便捷，由于上报的业务场景太多，本来是想在组件内部一起做完的，最后还是决定组件层只做数据收集，分析和上报留给业务方。\\n\\n如果你对 `concis` 组件库感兴趣，欢迎点个`star`支持一下我们~\\n\\n[Github](https://github.com/fengxinhhh/Concis)\\n\\n[官方文档](http://concis.org.cn/)\\n\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/79088bbe96ac4ab2a4ef37b3a1868172~tplv-k3u1fbpfcp-watermark.image?)\\n\\n同时也欢迎一起参与共建，方式有`github issue`、我的个人联系方式。\\n\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/37cf72f153a642e4a28644dffe2d64e2~tplv-k3u1fbpfcp-watermark.image?)\\n\\n",
        "tags": [
            "JavaScript",
            "React.js",
            "前端"
        ]
    },
    {
        "article_id": "7181727245872922683",
        "cover_image": "https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76db2279d3fe4ac992c9272eaca45d10~tplv-k3u1fbpfcp-watermark.image?",
        "title": "事件循环机制（EventLoop）你真的玩明白了么",
        "brief": "事件循环机制是浏览器按照我们的期望执行任务的重要保障，也是我们前端面试过程中必考的一道题目，但其中涉及的东西真的太多了，很多细节容易被我们忽略，本节，我就和大家一起，聊一聊我对事件循环机制的理解",
        "user_name": "我的代码果然有问题",
        "view_count": 1883,
        "collect_count": 30,
        "comment_count": 10,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/d705cd5be02ec4a8197fd87d908a90a6~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: channing-cyan\\n---\\n开启掘金成长之旅！这是我参与「掘金日新计划 · 12 月更文挑战」的第33天，[点击查看活动详情](https://juejin.cn/post/7167294154827890702)\\n\\n# 前言\\n\\n事件循环机制是浏览器按照我们的期望有条不紊地执行任务的重要保障，也是我们前端面试过程中几乎必考的一道题目，但很多时候，我们提到事件循环，想到的只是`Promise，setTimeout`，哪些属于宏任务，哪些属于微任务，还有一大堆让你讲出输出顺序的题目，很少涉及背后的原由，为什么它要这么设计？以及什么情况下，事件循环机制会给我们意料之外的结果？本节，我就和大家一起，聊一聊我对`Javascript`事件循环机制的理解\\n\\n# 热身问题\\n\\n这里抛出第一个问题，同样是经典的考察输出顺序，看看有多少同学能够答对\\n\\n```\\nconst button = document.createElement('button')\\nbutton.addEventListener('click', () => {\\n  Promise.resolve().then(() => console.log('micro 1'))\\n  console.log('event 1');\\n})\\nbutton.addEventListener('click', () => {\\n  Promise.resolve().then(() => console.log('micro 2'))\\n  console.log('event 2');\\n})\\nbutton.innerText = 'test'\\ndocument.body.appendChild(button)\\n​\\nbutton.click()\\n```\\n\\n看完上面的代码，请回答以下两个问题\\n\\n-   执行代码控制台会输出什么？\\n-   如果我用鼠标点击按钮触发事件，输出结果一样吗？为什么？\\n\\n关于第一问，我想大部分同学都能轻松的回答上来，不就是先执行同步的任务，遇到微任务把任务推到微任务队列中，同步任务处理完了，再回来处理微任务，很简单嘛，所以答案是\\n\\n```\\nevent 1\\nevent 2\\nmicro 1\\nmicro 2\\n```\\n\\n没错这就是第一问的答案，这时看到第二问，可能有的同学就会有点疑问了，这不一样么？难道还有区别？我们先把代码放到浏览器中执行一下看看\\n\\n![loop](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c38b9df9011f4f8ca5316276be3a6140~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n可以看到，答案是\\n\\n```\\nevent 1\\nmicro 1\\nevent 2\\nmicro 2\\n```\\n\\n所以为什么会不一样呢？这就是我们今天想要探究的**事件循环机制**背后藏了多少东西\\n\\n# 关于含糊不清的宏任务\\n\\n其实对上面问题的理解出现偏差，很大程度是因为对宏任务没有理解好（实际上看了很多资料，官方似乎并没有哪个文档提及到宏任务这个词——macroTask）\\n\\n个人理解宏任务是为了理解方便所造的一个词，大部分资料将`setTimeout,setInterval等`视为产生宏任务的方法，但是关键点却很少提及\\n\\n**宏任务产生后，并不会那马上进入任务队列中，而是交给了相关的线程**（这里是容易忽视的一个点）\\n\\n很多案例在分析时，喜欢用`setTimeout(fn,0)`举例，产生宏任务后就直接丢到宏任务队列中，等待执行，这是有问题的，**实际上并没有什么宏任务队列，宏任务产生的回调方法本身也是一个普通的任务**\\n\\n一个简单的例子\\n\\n```\\nsetTimeout(() => {\\n    console.log(1);\\n}, 3000)\\n​\\nsetTimeout(() => {\\n    console.log(2);\\n}, 2000)\\n​\\nsetTimeout(() => {\\n    console.log(3);\\n}, 1000)\\n```\\n\\n输出的结果是`3,2,1`，如果宏任务产生后就直接将回调方法丢到任务队列中等待执行，那么结果就乱了！\\n\\n为什么它能正确的进行回调处理，是因为有另外的线程在正确的时机将回调任务推到任务队列中进行执行！\\n\\n# 关于微任务的诞生\\n\\n提到微任务，很多人会将它和`Promise`联系起来，但这不是微任务产生的初衷\\n\\n微任务的出现，最早是浏览器想提供给开发者一种监控DOM变化的方法（例如插入元素到页面中）\\n\\n如果没有微任务，像这种代码代码，浏览器将产生200个事件（插入一个，修改一个）\\n\\n```\\nfor (let i = 0; i <100; i++) {\\n  const span = document.createElement('span')\\n  span.textContent = 'Hello'\\n}\\n```\\n\\n我们的期望是类似上面的操作，只产生一个事件而不是200次，解决方案是使用DOM变化事件的观察者，于是浏览器创建了一个新的队列就叫做微任务队列，存在于当次的执行环境中\\n\\nui 渲染会等待所有微任务执行完成之后才能执行，之后才是宏任务（**这也是后面我为什么把浏览器渲染作为一个事件循环的起点的原因**）\\n\\n下面两个案例，有兴趣的同学可以自己浏览器试试，有助于理解任务执行的机制\\n\\n-   不会阻塞页面\\n\\n```\\nfunction loop() {\\n  setTimeout(() => {\\n    loop()\\n  }, 0)\\n}\\nloop()\\n```\\n\\n-   阻塞了页面\\n\\n```\\nfunction loop() {\\n  Promise.resolve().then(loop)\\n}\\nloop()\\n```\\n\\n**微任务如果不为空会一直执行**，并且阻塞后续的所有任务（UI渲染）\\n\\n这也就是为什么我们遇到的微任务，常常都是发生在一项任务之后\\n\\n并且任何`javascript`运行的时候都可能执行微任务\\n\\n# 浏览器是怎么工作的\\n\\n> 浏览器是一个**多进程，多线程**的状态在进行工作的\\n\\n上面说到，异步的**宏任务`JS`引擎会移交给浏览器的其它线程处理**，那么浏览器都有哪些线程，以及哪些和异步任务相关呢？\\n\\n具体到一个标签`tab`页面，就是一个进程，里面有五个主要的线程在一起工作\\n\\n![2022-12-25 10 20 44](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87f80b6a416b4d04ace2a756137d448b~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n简单说下它们主要负责做什么\\n\\n| 线程           | 作用                                                                                             |\\n| ------------ | ---------------------------------------------------------------------------------------------- |\\n| GUI渲染线程      | 页面绘制                                                                                           |\\n| `js`线程       | 执行 `js` 脚本（与GUI互斥，如果 `js` 执行时间过长会造成页面卡顿）                                                       |\\n| 定时触发器线程      | 定时器`setInterval`与`setTimeout`所在线程                                                              |\\n| 事件触发线程       | 用来控制事件轮询，异步事件，`JS`引擎自己忙不过来，需要浏览器另开线程协助                                                         |\\n| 异步`http`请求线程 | `XMLHttpRequest`在连接后是通过浏览器新开一个线程请求， 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到 JavaScript引擎的处理队列中等待处理 |\\n\\n看到这里就比较清晰，setTimeout 这个API会产生一个宏任务丢给浏览器的**定时触发器线程**，当时间到的时候，定时触发器线程会把回调任务推进`JS`任务队列中等待执行\\n\\n上面的那个点击输出顺序问题其实也与这相关，对于事件的处理，浏览器有相应的**事件触发线程**去做处理，你注册一个事件，点击时就会触发一个事件，把回调方法推到任务队列中执行，并且每一个事件都是相互独立的**任务**，彼此之间不会相互影响（也就是说它们其实不是在同一个事件循环周期中发生的）\\n\\n而如果你是`btn.click()`实际上是由`JS`引擎直接触发，不经过**事件触发线程**，也就没有了所谓的宏任务，只有在同一事件循环中的微任务被先后触发\\n\\n理解完这个点，我们就来一起完整的回顾下\\n\\n# 为什么要有事件循环机制\\n\\n老生常谈，`Javascript`是一门**单线程的语言**，同一时间只能做一件事，但是现实场景中，不管是用户交互，还是接口请求，或者是定时器，都是常见的异步场景，如果不引入其它机制，让`js`按顺序执行任务，那么页面就会失去响应，`js`线程被阻塞，于是，**为了让这些异步的任务不阻塞JS线程的执行**，浏览器提供了事件循环的机制，来实现异步事件的回调\\n\\n# 事件循环机制在做什么\\n\\n浏览器在`js`执行栈工作的过程中，还同时存在着`Task Queue`和`microtask Queue`这两个任务队列，里面就存放着我们**待执行的任务与微任务**，所谓循环机制，就是浏览器会在合适的时候，不断地查看这两个任务队列，有没有需要执行的任务，如果有，就把任务拿到执行栈中执行，执行完了之后后开始新一轮的询问查看，如此反复\\n\\n# 各种任务执行的时机是什么\\n\\n在分析执行时间前我们先来理解下各种任务的概念\\n\\n## 同步任务与异步任务\\n\\n我们使用同步的代码或是异步的代码会生成不同的任务，对此浏览器会有不同的执行策略\\n\\n-   同步代码\\n\\n任务立即放入`JS`线程引擎（执行栈），并原地等待结果\\n\\n-   异步代码\\n\\n先放入宿主环境中（相应的微任务队列或者线程），不等待结果，不阻塞主线程继续往下执行，等待`js`引擎执行栈中任务都完成时，会去任务队列中取出任务来执行，也就是异步结果在将来执行\\n\\n## 宏任务与微任务\\n\\n宏任务与微任务都属于异步任务，它们通过调用不同的`api`进人任务队列\\n\\n-   宏任务\\n\\n宏任务可通过**setTimeout**、**setInterval**、**setImmediate**、**event**等方式触发，并由相应的线程控制进入任务队列（着重关注`setTimeout和event`，很多题目场景会涉及）\\n\\n-   微任务\\n\\n微任务通过**process.nextTick**、**Promises**、**[MutationObserver](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver)**等方式进入微任务队列（着重关注`Promise,nextTick`，很多题目场景会涉及）\\n\\n这里需要注意，异步代码会产生异步任务，但是宏任务产生的回调不一定会进入任务队列，浏览器会有相应的线程去处理这些异步任务，并在合适的时候，把任务回调推入任务队列中\\n\\n## 时机\\n\\n接下来就是关键了，不同的异步任务的触发时机究竟是什么\\n\\n![image-20221227131902872](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad0821385a12415c9071c768987beb9d~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n### 定义循环的开始和结束\\n\\n首先，每一个 `eventLoop` 都是一个单独的循环只有当当前事件循环完成时，才会进入下一个循环\\n\\n这里我们把**浏览器完成渲染**的时候作为一个新的事件循环的开始\\n\\n### 事件循环流程\\n\\n-   浏览器完成渲染（开始）\\n\\n当界面渲染完成时，我们开启一个新的事件循环\\n\\n-   开始执行任务队列\\n\\n这里的任务不是指宏任务，而是正常的执行代码，`JS`遇到所谓的宏任务（`setTimeout，event事件等`）会将任务的回调交给相应的线程处理，线程处理完成后会将相关的回调事件推入任务队列，等待执行\\n\\n> 举个例子：\\n>\\n> `JS` 遇到 `setTimeout(fnA, 1000)`这个异步代码\\n>\\n> 会产生一个异步任务，给到浏览器对应的线程（这里是定时触发器线程）\\n>\\n> 等待 1 秒后，定时器触发线程会把相应的回调任务推进任务队列中\\n>\\n> `JS`通过事件循环机制，读取并执行任务队列中的任务\\n\\n-   清空任务队列中的任务\\n\\n<!---->\\n\\n-   开始执行微任务队列中的任务\\n\\n<!---->\\n\\n-   清空微任务队列中的任务\\n\\n注意：如果产生新的微任务，也属于同一循环周期，需要全部微任务完成才能进入下个阶段\\n\\n-   浏览器渲染（结束）\\n\\n到这里，一个事件循环结束，进入下一个循环\\n\\n# 总结\\n\\n个人关于宏任务与微任务的一点理解是：\\n\\n宏任务是交由浏览器或是当前宿主环境（node）进行处理的，它们会在合适的时机将宏任务的回调方法交给`js`引擎执行\\n\\n微任务则直接存在于`js`引擎的执行环境中，执行时机是在主函数执行结束之后，并且除非清空微任务，否则不会进入下一个事件循环中\\n\\n好了，本次分享到此告一段落，若有疑问或理解不准确的地方，欢迎留言指正，谢谢！",
        "tags": [
            "掘金·日新计划",
            "前端",
            "JavaScript"
        ]
    },
    {
        "article_id": "7162920825971015693",
        "cover_image": "",
        "title": "作为前端还在使用GIF动画吗？换一种更优雅的方案吧",
        "brief": "动画需求在业务开发中是很常见的功能，无论是客户端开发、Web 开发、还是桌面端开发，为了产品有更好的用户体验，UED 设计的视觉效果也愈发的复杂，一般些简单的淡入淡出，旋转效果开发花费些时间即可搞定，",
        "user_name": "残月公子",
        "view_count": 4071,
        "collect_count": 106,
        "comment_count": 10,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/4f5f8646f59917e9665b371bf005d000~300x300.image",
        "category": "前端",
        "content": "## 前言\\n\\n标题有些水了，今天来聊聊前端开发中对于动画的实现方式。\\n\\n动画需求在业务开发中是很常见的功能，无论是客户端开发、Web 开发、还是桌面端开发，为了产品有更好的用户体验，UED 设计的视觉效果也愈发的复杂，一般些简单的淡入淡出，旋转效果开发花费些时间即可搞定，甚至稍微复杂些的动画多花费些时间也能完成，但主要面临几个问题：\\n\\n1. 耗时成本太高：在开发工作量很多的情况下，对开发来说无疑是增加了一大波工作量，用身边的一些同事的说法就是，连正常的业务需求都开发不完，谁还去精雕细琢那些去；\\n2. 吃力不讨好：开发吭哧吭哧写完了动画交予 UED、PD 去验收时很多时候会反馈说这实现的和设计稿差距有些多，很高概率会有多次的反工。\\n\\n自己手写动画太费事，那就直接用一劳永逸的方法，UED 直接出 GIF 动画，开发直接贴 GIF 图片即可，对于开发开说几个小时的动画需求几分钟即可搞定，整体来说 GIF 是一种制作简单、来源广泛（很多软件都可以生成gif动画）、兼容性强（基本上所有浏览器都支持）的轻量级的方案。\\n\\n但从产品的视角、用户视角来说 GIF 的动画的弊端也是非常多的，诸如：\\n\\n1. GIF 图片保存了每一帧的内容，因此造成图片很大；为解决图片过大的问题，大多数情况下都会采用压缩的方式较小体积，但这也造成了动画模糊、失真；\\n2. 用户无法直接与动画本身做交互，如停止、开始、加速等交互，也无法直接修改动画元素的属性如背景色等；\\n\\n既如此，那就再引入一种新的技术方案 [Lottie](https://lottiefiles.com//) ， 感兴趣的可以先先睹为快 [Lottie-Example](https://lottiefiles.com/category/yoga/animations)  。\\n\\n## Lottie\\n\\n### 什么是 Lottie\\n\\n[Lottie](https://lottiefiles.com//) 是 Airbnb 发布的一款开源动画库，它适用于 Android、iOS、Web 和 Windows 的库。 它提供了一套从设计师使用 AE（Adobe After Effects）到各端开发者实现动画的工具流。\\n\\n简单来说就是 UED 和开发各司其职，UED 提供动画 json 文件即可， 开发者就可以直接运用在 iOS、Android、Web 和 React Native之上，无需其他额外操作。\\n\\n今天对如何设计动画不做详细介绍，只是从前端的视角出发看看如何使用 Lottie，实现精致的动画。\\n\\n### Lottie-Web\\n\\n[Lottie-Web](https://github.com/airbnb/lottie-web) 是 Lottie 在 web 端的技术方案。\\n\\n[Lottie-Web](https://github.com/airbnb/lottie-web) 提供了 SVG、Canvas 和 HTML 三种渲染模式，一般使用 Svg 或 Canvas 即可。\\n\\n1. SVG 渲染器支持的特性最多，也是使用最多的渲染方式。并且 SVG 是可伸缩的，任何分辨率下不会失真;\\n2. Canvas 渲染器就是根据动画的数据将每一帧的对象不断重绘出来;\\n3. HTML 渲染器受限于其功能，支持的特性最少，只能做一些很简单的图形或者文字，也不支持滤镜效果。\\n\\n![Lottie-Web-Image](https://static-cdn.canyuegongzi.xyz/lf20/104032-yoga.gif)\\n\\n### 使用\\n\\n#### 安装依赖\\n\\n```bash\\nnpm i lottie-web --save \\nor \\nyarn add lottie-web --save\\n\\n```\\n\\n#### 实例化\\n\\n以下方法提供了一个简单的初始化过程，其他参数可参考 [官网](https://github.com/airbnb/lottie-web) 。\\n\\n```ts\\nfunction init(){\\n    // 读取动画容器\\n    const lottieContainer = document.querySelector(\\\"#container\\\");\\n    if (!lottieContainer) return;\\n    // 实例化\\n    const lottieInstance = lottie.loadAnimation({\\n        // UED 提供的 动画的 json 文件\\n        path: 'https://static-cdn.canyuegongzi.xyz/lf20/lf20_jv0xz0qi.json',\\n        // 渲染方式\\n        renderer: \\\"svg\\\",\\n        // 是否循环\\n        loop: true,\\n        container: lottieContainer\\n    });\\n}\\n```\\n\\n![Lottie-Web-Image](https://static-cdn.canyuegongzi.xyz/lf20/98092-loading.gif)\\n\\n至此， 开发者设计师可直接还原动画效果了，再也不会出现买家秀卖家秀的情况，也避免了开发和设计之前的互相扯皮，而且 JSON 文件，可以多端复用（Web、Android、iOS、React Native）。\\n\\n#### 动画控制\\n\\n**开始、结束动画**\\n\\n```ts\\n// 开始动画\\nfunction onStart() {\\n    lottieInstance?.play();\\n}\\n\\n// 结束动画\\nfunction onStop() {\\n    lottieInstance?.stop();\\n}\\n```\\n\\n**速度修改**\\n\\n```ts\\n// 修改动画播放速度\\nfunction updateSpeed(val: number) {\\n    lottieInstance?.setSpeed(val);\\n}\\n```\\n\\n[Lottie-Web](https://github.com/airbnb/lottie-web) 提供了相当丰富的 Api 此处借花献佛从网络拷贝了一份常用的如下，其他的可参考官网。\\n\\n1. animation.play()：播放，从当前帧开始播放；\\n2. animation.stop()：停止，并回到第0帧；\\n3. animation.pause()：暂停，并保持当前帧；\\n4. animation.goToAndStop(value, isFrame)：跳到某个时刻/帧并停止（isFrame（可省略，默认false：毫秒；true：帧）指明value的单位是毫秒还是帧）；\\n5. animation.goToAndPlay(value, isFrame)：跳到某个时刻/帧并播放；\\n```ts\\nanimation.goToAndStop(30, true)     // 跳转到第30帧并停止\\nanimation.goToAndPlay(300)          // 跳转到第300毫秒并播放\\n```\\n6. animation.playSegments(arr, forceFlag)：以帧为单位，播放指定片段（arr可以包含两个数字或者两个数字组成的数组，forceFlag表示是否立即强制播放该片段）；\\n```ts\\nanimation.playSegments([10,20], false)          // 播放完之前的片段，播放10-20帧\\nanimation.playSegments([[0,5],[10,18]], true)   // 直接播放0-5帧和10-18帧\\n```\\n7. animation.setSpeed(speed)：设置播放速度，speed为1表示正常速度；\\n8. animation.setDirection(direction)： 设置播放方向，1表示正向播放，-1表示反向播放\\n9. animation.destroy()： 删除该动画，移除相应的元素标签等。\\n\\n\\n\\n#### 生命周期\\n\\n[Lottie-Web](https://github.com/airbnb/lottie-web) 提供了几个比较使用的生命周期钩子函数，开发者可根据需要做定制开发：\\n\\n1. data_ready：动画数据加载完毕；\\n2. config_ready：完成初始配置后；\\n3. data_failed：当无法加载动画的一部分时；\\n4. loaded_images：当所有图像加载成功或错误时；\\n5. DOMLoaded：将元素添加到DOM时。\\n\\n```ts\\nanimation.addEventListener('data_ready', () => { \\n    console.log(\\\"data_ready\\\")\\n});\\n```\\n\\n\\n## 进阶\\n\\n上述章节中已经可以完美的运行 Lottie 动画了，但每个动画都得手动实例化，是不是很繁琐，此处笔者通过 WebComponent 技术方案做了进一步封装，方便开发者更简洁的调用， [先睹为快，快速体验](https://wu.canyuegongzi.xyz/component-plus/Complex/Lottie.html) 。\\n\\n### WuLottie 封装\\n\\n```tsx\\nimport { extractClass } from '@wu-component/common';\\nimport { h, Component, WuComponent, Prop, OnConnected, OnDisConnected, Watch } from '@wu-component/web-core-plus';\\nimport lottie, { AnimationItem } from \\\"lottie-web\\\";\\nimport css from './index.scss';\\n\\n@Component({\\n    name: 'wu-plus-lottie',\\n    css: css,\\n})\\nexport class WuLottie extends WuComponent implements OnConnected, OnDisConnected {\\n    constructor() {\\n        super();\\n    }\\n\\n    public lottieInstance!: AnimationItem;\\n\\n    public lottieContainer!: HTMLDivElement;\\n\\n    @Prop({ type: Boolean, default: true })\\n    public loop: boolean;\\n\\n    @Prop({ type: String, default: undefined })\\n    public data: string;\\n\\n    @Prop({ type: Boolean, default: true })\\n    public autoplay: boolean;\\n\\n    @Prop({ type: String, default: 'svg' })\\n    public renderer: 'svg' | 'canvas' | 'html'\\n\\n    @Prop({ type: Object, default: {} })\\n    public config: Record<string, any>;\\n\\n    public override connected(shadowRoot: ShadowRoot): void {\\n        this.init();\\n    }\\n\\n    // 元素销毁时也同步销毁掉 lottie 动画\\n    public override disConnected(): void {\\n        this.lottieInstance.destroy();\\n    }\\n\\n    private init(){\\n        // 实例化动画\\n        this.lottieContainer = this.shadowRoot.querySelector('.lottieWrapper');\\n        if (!this.lottieContainer) return;\\n        this.lottieInstance = lottie.loadAnimation({\\n            // @ts-ignore\\n            ...this.$reactive || {},\\n            path: typeof this.data === 'string' ? this.data : undefined,\\n            animationData: typeof this.data === 'object' ? this.data : undefined,\\n            container: this.shadowRoot.querySelector('.lottieWrapper'),\\n        });\\n    }\\n\\n    @Watch('data')\\n    public dataChnage(val: string, old: string) {\\n        this.init();\\n    }\\n\\n    @Watch('loop')\\n    public loopChnage(val: boolean, old: boolean) {\\n        if (!this.lottieInstance) return;\\n        this.lottieInstance.loop = val;\\n\\n        if (val && this.lottieInstance.isPaused) {\\n            this.lottieInstance.play();\\n        }\\n    }\\n\\n    @Watch('autoplay')\\n    public lautoplayChnage(val: boolean, old: boolean) {\\n        if (!this.lottieInstance) return;\\n        this.lottieInstance.autoplay = val;\\n    }\\n\\n    public stop() {\\n        return this.lottieInstance && this.lottieInstance.stop();\\n    }\\n\\n    public play() {\\n        return this.lottieInstance && this.lottieInstance.play();\\n    }\\n\\n    public override render(_renderProps = {}, _store = {}) {\\n        return (\\n            <div {...extractClass({}, 'lottieWrapper', {})}> </div>\\n        );\\n    }\\n}\\n\\n\\n```\\n\\n\\n### 如何使用\\n\\n#### 安装依赖\\n\\n```bash\\nnpm i l@wu-component/wu-lottie --save \\nor \\nyarn add @wu-component/wu-lottie --save\\n\\n```\\n#### 使用\\n\\n开发者无需手动实例化 Lottie， 可如同普通 HTML 标签般接入。\\n\\n```html\\n<wu-plus-lottie data=\\\"https://cdn.canyuegongzi.xyz/wu-component-static/lf20_r6blppzq.json\\\"></wu-plus-lottie>\\n```\\n\\n## 思考\\n\\n了解了如何使用 Lottie ，但是在实际应用中也有一些优势和不足，要按照实际情况进行取舍。\\n\\n1. Lottie-web 文件本身仍然比较大，未压缩大小为 513k，轻量版压缩后也有 144k，经过 Gzip 后，大小为39k。所以，需要注意 Lottie-web 的加载；\\n2. 效果完全依赖设计师，结果需要开发把关，如最后的 json 文件大小；\\n3. 部分AE特效不支持。有少量的 AE 动画效果，Lottie 无法实现，需要格外注意  [supported-features](http://airbnb.io/lottie/#/supported-features) 。\\n\\n虽然如此，Lottie 还是相当优秀的动画方案，多种技术方案多条路嘛，大家在日常工作中都在使用什么技术方案欢迎在评论区讨论。\\n\\n方案中涉及的代码均可在 [github](https://github.com/wu-component/web-component-plus) 阅读，欢迎 Star。",
        "tags": [
            "前端",
            "JavaScript",
            "架构"
        ]
    },
    {
        "article_id": "7175520275843252280",
        "cover_image": "",
        "title": "奇妙的前端2022年终总结！！！",
        "brief": "回顾2022，展望2023，我正在参与2022年终总结征文大赛活动 前言 今年已经算是步入前端行业的第二年了，时间过得真快啊，转眼回望这两年感觉就像在做梦一样，这一年感觉是对自己视野和技术一个飞越的一",
        "user_name": "溪饱鱼",
        "view_count": 3090,
        "collect_count": 6,
        "comment_count": 26,
        "avatar": "https://p26-passport.byteacctimg.com/img/mosaic-legacy/3795/3033762272~300x300.image",
        "category": "代码人生",
        "content": "---\\ntheme: cyanosis\\nhighlight: default\\n---\\n回顾2022，展望2023，我正在参与[2022年终总结征文大赛活动](https://juejin.cn/post/7172462429929111559 \\\"https://juejin.cn/post/7172462429929111559\\\")\\n## 前言\\n今年已经算是步入前端行业的第二年了，时间过得真快啊，转眼回望这两年感觉就像在做梦一样，这一年感觉是对自己视野和技术一个飞越的一年。\\n## 奇妙的入行\\n大学嘛，就疯狂玩耍，那时候还做了一两年Lol的直播，突然有一天大四啦，其实我当时也不是特别慌（当时特别自信就心想反正工作不是随便找嘛，找不到就继续打游戏因为当时打游戏还是挺赚钱的可能业务能力强的话一个月1-2w之间把，还特别自由），然后有一天室友说有个公司来学校开`宣讲会（招人）`让我去帮他占个座位。\\n\\n我去了在那玩手机没等到我们室友来，然后突然上面就发`卷子了`！！！没错，笔试，紧接着就稀里糊涂一顿答，然后`竟然过了`？？？然后就面试也是在我们学校里面，面试等待区待了很多人，公司给你一张纸让你选前端还是后端，当时看到后端那页写了很多人，前端可能3个人都没有，我就心想`em选前端`把（`我要做不一样的烟火`，毕竟打游戏是打不了一辈子的，现在想想真不错啊！），然后我的前端路就开始了。\\n## 实习\\n在这之前我先描述一下我的状态，作为一个大学里基本没有吸取知识的小海绵，我是啥也不懂的，就是真正意义上的啥也不懂，`html`,`dom`,`js`,`vue`,`数据库`连这个概念都没有。\\n### 转折\\n但是让我意外的是，公司就让两个前辈前端大佬，来我们学校先开始了14天的培训。前三天先讲了一下概念基础的东西（就是比较实战那种不是八股文），然后剩余十天给你设计图，和一些JSON数据，接口，让你用`vue`搭建一个电商项目，没做完也没关系就是练手。\\n### 进入公司\\n我现在回想起那时候的状态自己都觉得自己挺厉害的，早上7.30 - 20.30都是培训时间，然后培训时间完了，我就拿着比站上的免费教程恶补基础，到什么程度就是走路吃饭看，睡觉想，每天都是学到睡着耳机里还是课程的声音第二天又反复循坏这个过程。\\n\\n可是当我进入真正去公司（是个`接外包项目的公司`，还比较大）实习之后，发现前面那种状态还只是`easy`模式。14天的时间根本不够就是把`js`、`css`、`vue`学到能实战的地步。实习交给你的任务根本都没法下手。\\n\\n### 转折\\n可能那14天，公司的大佬发现我比较菜嘛，然后我就是由一个`外包的同事`一对一带我。后来过了很长的时间有了概念之后我才意识到我的`运气是有多好`，因为那个外包的同事很`负责`、而且`很卷`、还`很强`，除了喜欢听我吹他就其他都没啥。\\n\\n可能听我这么说没什么感觉，因为我很菜嘛，经常可能`深夜一点钟`还能看到我的提交记录，我有时候`晚上12点`还会问他问题（现在因为自己也经常回答别人的问题了嘛，才知道当时他可能究竟有多烦，就像是你`这么菜能不能去看看基础`，这种问题为什么要问我啊之类的感觉）。这段`hard`模式的时光持续了两个月，基本都是自己写一点，他到我电脑前面写一些，缝缝补补，勉强完成任务的感觉，每天只睡4个小时。\\n\\n### 独立\\n然后我就变强了，我基本已经是一个合格的`api`使用者了，能自己独立的完成任务了。顺带提一嘴（带我那大哥也转正还加工资了），这时候我以为自己总算是可以`睡个好觉`了。\\n\\n有个晚上我准备美美的睡一觉，大哥突然在`深夜`打电话来骂我了：\\\"你xxx，你这么菜，睡你xxx，起来给我卷\\\"，然后发给我一本红宝书的pdf版和一些db课。......Em，行，我看还不行吗。就这样慢慢的到了`我要毕业（6个月又过去了）`，也是我要`结束实习转正`的时候了。\\n\\n其实那时候已经感觉不太好了（大概就是`一眼望到头`，每天都写`一样的东西`，然后下个项目还是`一样的东西`，对`自己没一点提高`），大哥跟我吃着烧烤喝着酒谈了一下心，大概内容就是：外包公司是不利于你以后的职业发展的，我很看好你我觉得你有成为`强者的潜质`（吹自己一下）,你可以这段时间去找一下我帮你盯着。md现在想想真是贵人啊!!!\\n\\n## 奇妙的面试\\n作为一个没经历过正儿八经面试的人，出去面试肯定是`碰壁的`，大概面了7-10家，都是碰壁的`问啥啥不会`，但我心态也特别好，就那种越挫越勇，我其实每次面试都会比上次好一点，然后我就遇到了现在这家公司(也不是什么大厂国企，但入职要签保密协议)。\\n\\n为啥我觉得很奇妙，`第一点`是因为现在这家福利特别好每一季度季度奖金,年底13大概就是14-17薪的样子，而且对比城市同等毕业生水平高了几乎快一倍，二线互联网城市毕业就11k左右。`第二点`是是真的闲啊，一周五天班可能每天就只用工作两个小时。`最重要的一点`就是自由，且同事友善。\\n\\n当然这个是后话，主要是那个`面试`我们这边分部的前端老大也不问你什么八股文，现在回忆起来他好像就问了你一些`基础`的东西就后面就是我们两个在`技术讨论`，我当时心里想你`boss`上开这么高的薪资就问我简单的问题，然后就理所当然的从那家外包跑路了，来到我第一家正式上班的地方。\\n\\n## 正式工作\\n我们分部这边只有两个前端，项目很多技术栈也特别丰富，随便说说把：`node,v2,v3,react,react-native,egg,nuxt,qiankun,trao,uniapp,mpvue,bi,echart`，要是vue为主，移动端react为主，但好在产品线业务线已经高度成熟了，可能就一期迭代写5，6个页面改几个参数。\\n<img src=\\\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/163ced43724d43698bc24d536b5e19e6~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"\\\" width=\\\"100%\\\" />\\n而且最好的一点就是`复杂不单一的问题`，举个简单的例子把：`Puppteer`高并发导致服务服务器内存拉满，`拖拽卡顿`，移动端`垃圾机型`适配、长轮询等，简单的说就是`搬砖的内容`变少了。\\n\\n这么爽我最开始肯定是放飞自我了一段时间，但后面实在是闲的太无聊了，恰逢其时这时候以前打游戏的一些老板就问：鱼鱼啊，你现在做程序员了哈，会做xxx什么不。\\n<img src=\\\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7fa3fe8e883e45dd95639203306a983e~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"\\\" width=\\\"100%\\\" />\\n\\n然后又开始了`写代码写到自然睡`的状态，然后就`有瘾`了，是的写代码写出`瘾`了，就那种类似打游戏的感觉，没有人会烦你（毕竟你是在工作嘿嘿嘿），自己`沉浸式写代码`，还顺便把生物钟管理了（如果白天精力过剩晚上睡不着，就一直写代码从早写到晚，包困）。\\n\\n然后现在就有意在把主技术栈切换成`react`，其实把这事没啥难度，`框架这东西在我理解起来只是一个工具`，只是说`掌握工具的程度`各有不同，有些人只会用工具，有些人知道工具是怎么搭的，更厉害的就知道工具内部解决了什么问题还有什么其实方式替代。\\n\\n## 学习\\n可能我现在的平衡是`学习`>`业务`（钱），因为没这么大的需求，房买了婚结了长辈身体健康老婆不缺钱别杠。主要的重心还是想变强，还是想去接触更厉害的东西，去提升自己的视野和补充前端拼图。\\n\\n但说实话，想去接触更厉害的东西是去大厂，但我又很抵触白天开会晚上写代码这事而且现在我们这边也没啥好的业务线，再加上我是真讨厌背八股文的。所以算了随缘把看明年有好点的业务线没，对于八股文把，`不如直接去看源码把源码读懂`，`再输出`，`再思考为什么要怎么做`，随便你问。算法每天刷保持一个敏感度就可以了，复杂的源码也总是伴随着算法的。\\n\\n`难道学习不是为了去更好的公司拿更多的钱吗`？这是很多人提到的一个问题，确实是这样的是对的。但我不行，`我觉得喜欢才是最重要的`，我因为喜欢写代码才去学习，写代码对于我自己的情绪是一个`正反馈`，才每当我看到优雅的代码我是发自内心的感觉很舒服，我也想这么优雅，我也想怎么强。而强所带来的收益只是附带的而已。\\n\\n## 输出\\n就是写博客，一方面是为了加深自己的一个对知识的`理解程度了`，另外一个方式就是`表达能力，组织能力的锻炼`，顺便还慢慢在学画图，还是挺好的一个方式的。\\n\\n## 关于工作之外\\n嘿嘿嘿，看到大家都写了一点，我也写一点把。\\n\\n老婆特好，就是每次可能她其实很带孩子很辛苦的还工作承担了特别多，悄悄说一句她比我收入还高，然后我就在旁边写代码，有时候可能自己写代码写沉浸了嘛然后人就是那种消失状态一天都不回消息（可能是因为她也很忙），她都不会抱怨什么 = - =，就只能说三生有幸了一点都不作，而且人好看，就不放照片了，互联网懂的都懂。\\n\\n长辈的话都身体健康，已经霍霍磨刀准备接手孩子的教育了。\\n\\n娱乐方式：写代码，看小姐姐跳舞（哈哈哈哈哈哈哈哈）。\\n\\n## 致谢\\n祝大家身体健康，事业顺利，感情不受挫折，其实上面说了很多都是报喜不报忧了，生活中那我们还是多看看开心的事情，糟心的早点忘了就行。\\n\\n",
        "tags": [
            "前端",
            "年终总结",
            "JavaScript"
        ]
    },
    {
        "article_id": "7179790901651177529",
        "cover_image": "",
        "title": "2022年终总结——从逆向转向Web开发",
        "brief": "今年主要总结我为何从逆向转向 Web 开发，并明确我未来所要走的方向，也是本文的主题。 希望我的一些经历对你有所帮助，尤其是对于一些不知如何抉择的伙伴。",
        "user_name": "愧怍",
        "view_count": 1857,
        "collect_count": 3,
        "comment_count": 3,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/7c128d02d5e840deaca25f5c494bb2ef~300x300.image",
        "category": "代码人生",
        "content": "---\\ntheme: smartblue\\n---\\n「回顾2022，展望2023，我正在参与[2022年终总结征文大赛活动](https://juejin.cn/post/7172462429929111559 \\\"https://juejin.cn/post/7172462429929111559\\\")」\\n\\n## 前言\\n\\n距离上一篇博文有一个月之久了，距离上次编写代码也有一周之久了，由于疫情的全面放开，加上福建省教育厅通知的提前返乡，反而让我感到有些不适。往常这个时间点我忙于期末考试，会把代码的事情放一边，等到彻底放假后，开始闭关潜心学习。然而剩余的半个月变成了线上形式，课还是要上，考试还是要考，虽说身在家乡，但心不在焉的 😂。\\n\\n12 月已过半，也是时候该写年终总结了。迄今为止，我已学习了 3 年半的编程。（还好不是两年半），当下的技术不再是当初只会易语言的小伙了。只是当下已没有当初如此强烈的热情与精力了，我称之为老了。\\n\\n现在回头回顾学习编程时间，用一个成语对自己做个评价——**差强人意**。在这些时间段，我其实荒废过一段时间，厌倦过，贪玩过，荒废过，从我的 [Github 热力图](https://github.com/kuizuo'Github热力图') 中其实就能看得出来。就导致欠下技术的，都需要后续花时间去弥补。\\n\\n要让自己保持每天都处于学习状态真的太难了 😩，生活总有源源不断的琐事打扰着你。在忙碌的时候总是感觉时间不够用，哪怕有时一天花费了数十个小时，也总感觉做的事情太少了；哪怕每天计划都规划得好好的，但总是有一半还未完成。生活中大量的碎片化时间，而编程学习最不需要的就是这些碎片化时间。\\n\\n回顾整个编程生涯有太多可感慨的，整个旅途几乎是一个人走完的，期间遇到的坎坷就只得依靠搜索引擎来解决，搜索引擎是我再生父母都不为过。没有人给我指引明确的道路，只依靠心中对技术的憧憬不断前行。走过低谷，登过山峰，而如今站稳身子就足矣。\\n\\n感叹的话语也就是说到这。今年主要总结我为何从逆向转 Web 开发，并明确我未来所要走的方向，也是本文的主题。**仅作为个人感悟，不作为建议参考。**\\n\\n## 为什么是 Web 开发？而不是逆向\\n\\n今年大部分的开发时间都花在 Web 开发上，在此期间也接触到许多技术，并通过博客笔记的方式记录下来。\\n\\n我很庆幸我的 Web 开发从一个 Beginner 到 Intermediate，现在回忆整个学习路程，一路学得都很野很随意，从未系统学习过，总是学到一半，就自认为已经掌握了，便开始进行实战项目，可以说很多知识都是在实战探索中了解的。\\n\\n虽然很多人都直称我为大佬，但我离 Advanced 还有一大段的路途要走，而这段路途是无比的艰难与漫长。不过好在路不歪，只要肯走终会到达终点 👨‍🦲。\\n\\n而带我入门的逆向技术，在今年没有丝毫的长进，说得过分点，就是弃坑了。也正如标题所说，至于缘由，细看下文。\\n\\n### 逆向\\n\\n熟悉我的人应该知道我之前是做爬虫与逆向分析，但是为何今年的技术栈彻底转型到 Web 开发上。\\n\\n我常常和别人说起我的技术栈转型（从逆向转到开发），不过比较多的都会比较好奇我为什么不继续深造下去。\\n\\n在此我也回顾了我**从逆向转变到 Web 开发**的过程，顺带也回答这个问题。不过在这里先说说我个人对逆向的看法：\\n\\n#### 逆向需要的技术知识面比较广。\\n\\n就我接触逆向的过程来说，接触了易语言，JavaScript，Python，Java，Php 等等编程语言。\\n\\n使用过了一堆的逆向工具，如 Frida、IDA、JEB、jadx 等等（我目前能想到比较有名的）。此外还有一堆知识，包括但不限于以下技术：自动化脚本、TCP/HTTP 协议、抓包、爬虫、加密学、图像识别（验证码、滑块位置）、汇编、反编译、AST 反混淆。\\n\\n**要我说我在逆向中学到的不是如何使用这些工具或掌握某个技能，而是锻炼出一定的阅读与分析代码能力。**工具与技能总是瞬息万变，但阅读与分析代码能力却是实实在在，一成不变的，也是逆向中最值得学习的。\\n\\n有接触过 [CTF](https://baike.baidu.com/item/ctf/9548546) 想必再熟悉不过逆向工程的技术面广了。\\n\\n#### 越来越多的网站或应用程序不断加强安全防护，未来只会越来越难逆向。\\n\\n逆向分析，说白话就是去看别人的代码，进行一些修改手段，达到自己想要的目的。比如修改某个软件的标题或作者信息、将别人的代码“偷”过来用、爬取某些网站或软件的数据。\\n\\n但是随着现在越来越多潜在的安全问题，很多框架底层，服务厂商，都会对一些可能有安全问题的代码进行警告或者底层处理。比如使用 ORM 框架能够有效防止 SQL 注入，前端框架中涉及 XSS 攻击也会有相应的错误提示与处理，再如浏览器跨域以及跨站点 cookie 不共享，都是为了用户的安全而去考虑的。这样的例子有太多了。\\n\\n简单说说安卓逆向的过程：拿到一个 Apk，发现有加壳（给代码加固让逆向者不易于看到源代码），这时候就需要通过脱壳才能查看到源代码；此时就算脱完了壳，接下来可能将面对经过混淆过的代码，这份代码难以用人眼去阅读，不调试运行，单靠静态分析很难分析出东西，这时候可能就要借助 AST 对代码进行还原；还原完了配合动静分析将代码给扣出来，而在分析的时候可能又有各种检测，比如抓包，反调试以阻碍逆向进度；最后就算逆向工作都做完了，代码也扣下来了，还要尝试运行扣完的代码，这时候极大可能还不一定能运行，然后又要回头看看到底那一步做错了。\\n\\n可以说逆向的工作就是不断地调试，不断分析，最终拿到想要的结果。整个过程可以说非常耗时且折磨人，心智如果不够强大，真的容易劝退（我当下耐心也早不如当初了）。但是得到最终的目的，将非常爽，成就感爆棚，相当于一个解了几小时的题，最终被攻克的感觉。\\n\\n前阵子在逆向圈中，看到过一张图，大致也把我的逆向学习流程也表达了出来，最终我的逆向学习也确实止步在 Flutter 上。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/214ba360113d4cfc9f293dc547904f0d~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n上面所说到的逆向技术中，例如加壳，代码混淆，反调试，风控等等，都是阻碍逆向手段。同样对于爬虫而已，通常会采取反爬措施，包括但不限于封 IP、封账号、JS 参数加密、代码混淆、浏览器指纹、TLS 指纹、验证等。而且防护手段可以说是越来越多，逆向的难度也就越来越大。并且在服务开发那边只需要修改一点东西，逆向可能就需要从头再来一遍。\\n\\n**未来逆向的难度只增不减，但薪资可不一定保证这趋势。**\\n\\n#### 风险\\n\\n从上面也不难看出逆向常常与安全挂钩，如果一个网站或软件不是那么好被逆向，那么间接说明安全性是比较高的。可一旦涉及到安全，同时又是互联网，就免不了网络安全与法律相关的风险。\\n\\n在大多数逆向的对象（网站，软件）中，多数都是他人的劳动产物，当你未经他人允许的情况下，去爬取他人的数据，或是修改一些版权信息再次发布出来，就属于非法行为。本质和未经他人允许，偷人家的东西性质是一个样的。并且在有防护措施的情况下，绕过网站防护措施获取数据属于违背权利人意愿读取、收集数据，将有较大可能被认定为对计算机信息系统的 “侵入”。\\n\\n要知道在逆向的行业中，有很多都是擦边灰产，至少我所在的逆向圈是这样的，抱着【仅供学习为参考，请勿用于非法用途】的想法做逆向工程。路子极易走歪，很少能够正常去走安全岗位的。相信你应该能看到许多类似的案件，如【某某程序员因非法侵入 xx 网站，获刑 x 年】。这不是危言耸听，目前国家对网络安全以及非法数据获取的打击力度，也将决定了这些案件将会越来越多，爬虫逆向也将会越来越邢。\\n\\n### 自身因素\\n\\n简单介绍完我认为爬虫和逆向的看法后，再来说说自身因素。\\n\\n#### 更想写代码，而不是看代码\\n\\n我是很享受写代码的过程，一份高质量的代码会让人赏心悦目。我为此特意学习下设计模式、重构技巧以及 TDD 测试。这些在逆向中基本难以涉及，但是这些对开发的体验和代码的健壮性都是非常重要的，也是让我个人觉得技术有所提升的技能点。\\n\\n在逆向分析中，大部分时间都不是在写代码而是在看（分析）代码，而反编译出来的代码，很有可能是带有混淆过的代码，而你想要分析这一块代码的作用，只能去一步步调试，将代码啃下来，从而推断运行时某变量的值，或是某个函数的作用。\\n\\n虽然说开发岗位中，有很多情况下也是在看代码的日子中度过的，但相比反编译阅读代码而言，至少不至于那么晦涩难懂。\\n\\n#### 更想碰新技术，而不是旧技术\\n\\n其次，在逆向分析中，遇到的网站或软件所用的技术一般都是较为稳定成熟的技术，而这些技术往往不是很新，因此需要去了解很多旧的技术，但这些旧技术仅仅只对逆向分析有用，甚至过段时间很有可能就会遗忘。并且要了解的旧技术还不少，学得将会特别杂。\\n\\n而我又是一个喜新厌旧的人，对任何新鲜事物都抱有好奇尝试的态度。我终将认为旧的技术被淘汰是迟早的问题，新技术的出现肯定不是无缘无故的出现，必然是为了解决某些问题而诞生的，如性能，开发体验，安全等等。\\n\\n这里有篇我对新技术的看法，推荐阅读一番。[深谈个人对新技术的看法 - 愧怍的小站](https://kuizuo.cn/talk-new-technologies-opinion)\\n\\n#### 更想开源，而不是闭源\\n\\n在逆向开发，不，是在灰产开发中，有很多代码是别指望开源出来的，这背后会涉及到商业利益或是版权等问题。一旦代码放出来，将意味着你的代码将有很大的可能被别人利用做坏事，最终甚至祸及到自己。所以大多数情况下，你多半只能将自己的应用发布出去，而不是将源码开源，通常也就带有商业化的性质。\\n\\n我想任何开发者肯定是希望自己的代码走的更远，走的正规，而不是被拿来做违背自身意愿的事情。\\n\\n开源不仅能为自己提升一些技术知名度，展现自身技术的一面，同时代码被他人使用与认可，这番成就感就足够继续坚持开源下去。因为我有很多技术都是通过开源项目中学到的，所以我能感受到开源带来的魅力，也是对于前人的崇拜，想走开源的原因。\\n\\n**因为淋过雨，所以很想为别人撑把伞**\\n\\n### 小结\\n\\n其实在今年出头我还特意复习了一波安卓逆向，为了更深入了解了更底层的知识与工具（当然现在忘得也差不多了），因一些特殊原因我的电子设备不在了，别问，问就是坏了到现在还没修好。就导致我的编程语言环境，逆向工具，虚拟机配置，代码等数据直接灰飞烟灭，也让我停滞了 1 个月的学习。\\n\\n我想这才是我从逆向转 Web 开发的最重要的理由了。\\n\\n逆向的学习对我开发有很大的帮助。例如开发中的安全问题，我在开发中都会时刻考虑去考虑该问题。如加壳、SQL 注入、代码混淆、接口限流、接口幂等性（Fiddle R 包）等等安全性问题。\\n\\n我庆幸我学过逆向，让我学到很多在开发中比较难学到的技能，如调试，阅读源码，而这些也是绝大多数 Web 开发者都欠缺的能力。\\n\\n逆向应该就暂以告终，未来会有很长的一段时间，甚至以后不再接触深入专研逆向。\\n\\n每当回想，【当时那么难的加密算法都能搞得定，开发一个功能还能有多难】，保持着这种心态，也让我保持着开发。\\n\\n也是逆向激起我对编程的兴趣，可以说没有接触逆向开发，我也不太可能会接触到 Web 开发。\\n\\n## 但 Web 开发就一定好吗？\\n\\n上面对逆向的看法仅个人分析而言，但是 Web 开发就一定好吗？我不敢下绝对的肯定，不同人不一定适合相同的技术，**但是我特别看好 Web 技术（尤其是 JavaScript，偏前端向）**，以下是我看好的点。\\n\\n### 应用性广\\n\\n目前仍有很多人还停留在 JavaScript 只能编写前端页面的水平，自从 Node.js 问世，目前绝大多数的应用都可以使用 JavaScript 进行编写。\\n\\n换句话说，只要你会 JavaScript 就可以编写很多应用了。有个在国外经常被应用的一条和 JavaScript 有关系的著名定律：\\n\\n**Atwood 定律：任何可以用 JavaScript 编写的应用程序，最终都会用 JavaScript 编写**\\n\\nWeb 前端开发不用多说，目前还得用 JavaScript 来编写。而后端开发通过 Node.js 也有一己之力。近几年特别流行跨平台开发，也就是一份代码，多端运行。\\n\\n使用 React Native 或是 Uniapp 这样的前端应用框架，顺带去了解一下相应平台的 API，就能够编写出安卓或 IOS 应用，做过小程序开发肯定知道小程序的技术栈就使用到前端开发的技术栈，如果你会前端开发，就能很轻松的上手小程序开发了。\\n\\n并且越来越多的软件都是网页版优先，然后再通过 Electron 这样的跨平台解决方案，实现不同平台间的程序。诸如 Vscode，Typeorm 等等便是其中的佼佼者。\\n\\n不过本质上都是在不同应用的平台上套浏览器的壳，然后接入一些该平台的接口，因此普遍应用的体积与内存都相对比较大，与原生相比自然是略逊与原生，不过这点性能上的差异在如今硬件升级如此普遍的物质生活也显得微不足道了。\\n\\n但借助浏览器自带的跨平台性，你所编写的应用能够非常轻松的让他人访问，只需要用户有个浏览器，并且通过上述跨平台的解决方案，也能够有效的将你的 web 应用转成其他平台的应用，而不是在耗费时间与精力去编写另一套代码。\\n\\n在一些技术文档上，会有 API/SDK 的支持，而绝大多数都支持使用 JavaScript/Node.js，也许该功能本身并不是使用 JavaScript 来编写的，但完全可以通过 JavaScript 来轻松调用该功能。并且如今 JavaScript 生态如此庞大，你不必担心库/包的问题，npm 作为世界上最大的开放源代码的生态系统（包管理器），在这里你几乎找得到你所想要的库/包。\\n\\n此外有越来越多的第三方服务平台（通常称 Fass，函数即服务），专门提供数据接口与用户鉴权，如 firebase/supabase 或是国产的云开发产品（如小程序）。前端程序员只需要专注与业务代码，借助第三方开发平台，就能够编写一个高可用的应用。反而也映衬了，Web 开发好像可以没有后端，但必须要有前端的观念。\\n\\n### 工作量将越来越多\\n\\n这句话的意思可能有点加班那味道，但我所要表明的是可以做的事情多了，意味着你的工作量增加了，同时你的编码价值也就提升了，不过实际价值（工资）的话不一定提升，因为这主要看老板和地区。\\n\\n怎么理解呢，我举几个例子。\\n\\n现在大部分的 web 应用都采用前后端分离的形式，但在曾经则是由后端通过模板语言渲染成 HTML 直接返回，通过前后端分离的形式，前端只需要专注页面交互的编写，而后端只需要保证接口可靠性。并且前后端分离也有一个特别显著的特点，能非常有效的节省服务器的资源，原本服务器的渲染动作迁移至客户端来做。也许有人会说，那这样 SEO 优化该怎么办，这不就有了 Next.js、Nuxt.js 这样的 SSR（服务端渲染） 框架，而这些工作，也是前端要做的。\\n\\n并且越到后面你越能感觉到客户端（前端）远比服务端（后端）做的东西来的多，比如开发阶段的数据 Mock，前端国际化，设计原型等等。之所以会有这种感觉，也许是因为我的大部分开发都是前端，这里你也可以回想当下的工作量与往年相比是多了还是不变。\\n\\n### 技术更新快\\n\\n前端真的是每隔一段时间，必定会出一些新的技术，也不由让不少前端学习者感叹真的学不动。但伴随着新的技术出现，必然会有新的岗位与机会，这也是我看好前端的一个点。\\n\\n**不过这种机会在国内不太多见，反而在国外特别普遍。** 多的不说，自行体会。\\n\\n忘记从哪看到的一句话：“前端工程师的一大焦虑：永远能（且必须要）看到大量前沿的技术，但自己手上的活儿跟不上，导致眼高手低。”\\n\\n不只是前端，做技术这行的，必须要跟着技术发展的角度，并且要时刻关注最新，主流的技术。\\n\\n---\\n\\n有关 Web 开发的一些想法与感悟就写到这，其实还有蛮多可写的，比如选择 Vue 与 React？为什么是 JavaScript？有太多自我审问的话题了，不过由于当下时间相对紧迫，有机会的话再续写吧。\\n\\n综上，也就是我看好 Web 技术的几个点，也回答了我未来的方向。希望这些能够帮助一些不知抉择方向的伙伴。\\n\\n## 在实践中学习\\n\\n回顾整个技术栈，基本都是在项目实践中不断学习。也许是因为逆向的缘故，因为逆向基本上都是靠实战出来的，导致我的学习路线也趋于实践。\\n\\n不过在我看来，写项目是最直接能体现出所想学的技术。我在学习一门新技术时，我通常会用项目或者博文的形式来总结我的学习过程。我也乐意花时间在这上面，并将其分享出来。当有其他人也在学习这门技术时，看到该项目或博文，我就认为非常有意义。\\n\\n**我在学任何一门技术，会使用该技术写点东西；换言之是为了写点东西，而去学点不一样技术。**\\n\\n## 技术心态的变化\\n\\n如今来看，确实没那么想写代码，尤其是那种工作量大，重复性强的代码，而编写这些代码，其实与搬砖无任何区别，本质也是重复性与劳动性的任务。\\n\\n曾经可能是因为接触得比较少，对于很多软件背后的原理及实现一概不知，所以看到啥就都想写写看，最终很多项目都成为半成品。\\n\\n而随着越深入的学习，反而自己所想实现的东西，前人都已经帮我们实现好了。完全可以借用前人的代码，在此基础上学习与使用，而不必从头再来，耗费很多不必要的时间。\\n\\n到最后为了实现一开始所想实现的东西，不用再费尽心思，去开源社区搜寻一番，总能找到与自己所要实现的类似的产品，此时只需要会看，会改，总能达到自己最终要实现的东西，有时候自己也称为了别人口中的 CV 工程师。\\n\\n也正因如此，写代码的欲望就不再那么强烈。很多自认为无意义的代码或者是以后都不一定用得上的代码就少写了许多。于是乎缺少了很多自我思考与专研的时间，虽说也确实节省了很多不必要的时间，加快最终功能的实现，但这就是自己想要的编程生活吗？或者说这就是绝大多数人的编程生活。\\n\\n## 结语\\n\\n今年的年终就告一段落，与之前的年终总结相比，篇幅缩减了许多，主要感觉之前写的挺多流水账的，废话挺多的。也有一点是因为时间相对紧迫，其实 12 月我还没放假，都处于线上上课，线上考试的状态，而线上考试的方式我就不得吐槽了，提前打印给定的答题纸，题目以电脑的方式展示，最终将答案手写到答题纸上并通过手机扫描（扫描全能王）成 PDF 的格式提交，当然摄像头必然也是有的。总之麻烦事还是有的，还没到彻底闲下来闭关学习的时候。\\n\\n按往常可能还有明年的规划，但我现在认为很多时候都难以依照自身意愿做事，而规划正好自己所设想美好的计划，很容易事与愿违。因为回顾过往的规划，有太多美好的计划，但在实际分析下也将变得不堪一击。不止项目需要可行性分析，人生计划同样需要，一些天马行空幻想，其实就不再有意义去记录了。\\n\\n**坚持做自己想做的事情，而不是逼自己做不愿做的事情**。这是我编程学习中座右铭，也是给予他人编程学习的建议。\\n\\n> 发布在掘金上的文章精简了一些内容，完整原文地址: [2022年终总结——逆向转Web开发 - 愧怍的小站](https://kuizuo.cn/2022-year-end-summary) ",
        "tags": [
            "逆向",
            "前端",
            "年终总结"
        ]
    },
    {
        "article_id": "7181078511401041980",
        "cover_image": "https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35f7225aee2d401c86de1e7ed9ecdb77~tplv-k3u1fbpfcp-watermark.image?",
        "title": "JS Promise 101：Promise基础",
        "brief": "面试官：你知道Promise的错误为啥不能通过try/catch捕获嘛？ 我：嗯？为什么要try/catch？",
        "user_name": "我不是小超人啊",
        "view_count": 37953,
        "collect_count": 360,
        "comment_count": 75,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/2648f775e98d0bdd45c93b6c279bf28d~300x300.image",
        "category": "前端",
        "content": "---\\nhighlight: arduino-light\\n---\\n# 前言\\n之前我写过一篇文章，讨论了为什么`async await`中的错误可以被`try catch`，而`setTimeout`等api不能，有小伙伴提出之前面试被面试官问过为什么`Promise`的错误不能`try catch`，为什么要这么设计。好吧，虽然`Promise`这个话题大家都聊烂了，今天我们再来展开聊聊🤭。\\n\\n# 什么是Promise\\n`Promise`是一个用来代表异步操作结果的对象，我们可以通过观察者模式观察异步操作的结果。在其它语言里面，我们多多少少接触过`future`，`deferred`这些概念,`Promise`其实就是`Javascript`的类似实现。\\n根据[MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)定义：\\n\\nA `Promise` is in one of these states:\\n\\n*   _pending_: initial state, neither fulfilled nor rejected.\\n*   _fulfilled_: meaning that the operation was completed successfully.\\n*   _rejected_: meaning that the operation failed.\\n\\n一个`fulfilled Promise`有一个`fulfillment`值，而`rejected Promise`则有一个`rejection reason`。\\n\\n# 为什么要引入Promise？\\n\\n异步处理在我们日常开发中是很常见的场景，在`Promise`出现之前，我们都是通过回调来处理异步代码的结果，但是出现了一些问题：\\n\\n* `回调地狱`，在有多个异步逻辑存在依赖关系时，我们只能在回调里嵌套，这些深度嵌套的代码让代码难以阅读和维护，业界称之为回调地狱\\n* 回调也没用标准的方式来处理错误，大家都凭自己的喜好来处理错误，可能我们使用的库跟api都定义了一套处理错误的方式，那我们把多个库一起搭配使用时，就需要花额外的精力去把他们处理皮实\\n* 有时候我们需要对一个已经完成的逻辑注册回调。这也没有统一的标准，对于大部分代码，我们根本就不能对这些已经执行完的代码注册回调，有些会同步执行回调，有些会异步执行回调，我们根本不可能记住所有api的机制，要么每次使用时我们都要研究这个api的实现机制，要么我们可能就在写bug\\n* 而且，如果我们想对一个异步逻辑注册多个回调，这也要看api提供方支不支持\\n* 最重要的，如果有统一的方式来处理错误跟正确结果的话，我们就有可能实现一套通用的逻辑来简化代码复杂度,这种自己发挥的情况就很难\\n\\n是的，`Promise`的出现就是为了解决这所有的问题。\\n\\n# 怎么创建Promise\\n## Promise构造函数\\n`Promise`有一个构造函数，接收一个函数作为参数，这个传入构造函数里的函数被称作`executor`。\\n`Promise`的构造函数会同步地调用`executor`，`executor`又接收`resolve`函数跟`reject`函数作为参数，然后我们就可以通过这两个函数俩决定当前`Promise`的状态（`resolve`进入`fulfilled`或者`reject`进入`rejected`）。\\n\\n我们在`resolve Promise`时，可以直接给它一个值，或者给它另外一个`Promise`，这样最终是`fulfilled`还是`rejected`将取决于我们给它的这个`Promise`最后的状态。\\n\\n假如我们现在有一个`promise a`：\\n\\n* 如果我们在`promise a`里面调用`resolve`，传入了另一个`promise b`，`promise a`的状态将取决于`promise b`的执行结果\\n* 如果我们直接传给`resolve`一个普通的值，则`promise a`带着这个值进入`fulfilled`状态\\n* 如果我们调用`reject`，则`promise a`带着我们传给`reject`的值进入`rejected`状态\\n\\n`Promise`在一开始都是`pending`状态，之后执行完逻辑之后变成`settled（fulfilled或者rejected）`，`settled`不能变成`pending`，`fulfilled`不能变成`rejected`，`rejected`也不能变成`fulfilled`。总之一旦变成`settled`状态，之后就不会再变了。\\n\\n我们也不能直接拿到`Promise`的状态，只能通过注册`handler`的方式，`Promise`会在恰当的时机调用这些`handler`，`JavaScript Promise`可以注册三种`handler`：\\n\\n* `then` 当`Promise`进入`fulfilled`状态时会调用此函数\\n* `catch` 当`Promise`进入`rejected`状态时会调用此函数\\n* `finally`当`Promnise`进入`settled`状态时会调用此函数（无论`fulfilled`还是`rejected`）\\n\\n这三个`handler`函数都会返回一个新的`Promise`，这个新的`Promise`跟前面的`Promise`关联在一起，他的状态取决于前面`Promise`状态以及当前`handler`的执行情况。\\n\\n我们先来看一段代码直观感受下：\\n```\\nfunction maybeNum() {\\n  // create a promise\\n  return new Promise((resolve, reject)=>{\\n    console.info('Promise Start')\\n    setTimeout(()=>{\\n      try{\\n        const num=Math.random();\\n        const isLessThanHalf=num<=0.5;\\n        if(isLessThanHalf){\\n          resolve(num)\\n        }else{\\n          throw new Error('num is grater than 0.5')\\n        }\\n      }catch (e) {\\n        reject(e)\\n      }\\n    },100)\\n    console.info('Promise End')\\n  })\\n}\\n\\nmaybeNum().then(value => {\\n  console.info('fulfilled',value)\\n}).catch(error=>{\\n  console.error('rejected',error)\\n}).finally(()=>{\\n  console.info('finally')\\n})\\nconsole.info('End')\\n```\\n\\n`maybeNum`函数返回了一个`Promise`，`Promise`里面我们调用了`setTimeout`做了一些异步操作，以及一些`console`打印。\\n\\n出现的结果类似这样：\\n```\\nPromise Start\\nPromise End\\nEnd\\nfulfilled 0.438256424793777\\nfinally\\n```\\n或者这样:\\n```\\nPromise Start\\nPromise End\\nEnd\\nrejected Error: num is grater than 0.5 ...\\nfinally\\n```\\n\\n我们可以发现，除了`setTimeout`里的部分，其它都是同步按顺序执行的，所以`Promise`本身并没有做什么骚操作，它只是提供了一种观察异步逻辑的途径，而不是让我们的逻辑变成异步，比如在这里我们自己实现异步逻辑时还是要通过调用`setTimeout`。\\n\\n此外，我们还可以通过`Promise.resolve`跟`Promise.reject`来创建`Promise`。\\n## Promise.resolve\\n`Promise.resolve(x)`等价于\\n```\\nx instanceof Promise?x:new Promise(resolve=>resolve(x))\\n```\\n如果我们传给它的参数是一个`Promise`，（而不是`thenable`，关于什么是`thenable`我们稍后会讲）它会立即返回这个`Promise`，否则它会创建一个新的`Promise`，`resolve`的结果为我们传给它的参数，如果参数是一个`thenable`，那会视这个`thenable`的情况而定，否则直接带着这个值进入`fulfilled`状态。\\n\\n这样我们就可以很轻松地把一个`thenable`转换为一个原生的`Promise`，而且更加方便的是如果有时候我们不确定我们接收到的对象是不是Promise，用它包裹一下就好了，这样我们拿到的肯定是一个`Promise`。\\n## Promise.reject\\n`Promise.reject`等价于\\n```\\nnew Promise((resolve,reject)=>reject(x))\\n```\\n也就是说，不管我们给它什么，它直接用它`reject`，哪怕我们给的是一个`Promise`。\\n\\n# Thenable\\n\\n`JavaScript Promise`的标准来自`Promise/A+`，，所以`JavaScript`的`Promise`符合`Promise/A+`标准，但是也增加了一些自己的特性，比如`catch`跟`finally`。（`Promise/A+`只定义了`then`）\\n\\n在`Promise/A+`里面有个`thenable`的概念，跟`Promise`有一丢丢区别：\\n\\n-   A “promise” is an object or function with a `then` method whose behavior conforms to [the Promises/A+ specification].\\n-   A “thenable” is an object or function that defines a `then` method.\\n\\n所以`Promise`是`thenable`，但是`thenable`不一定是`Promise`。之所以提到这个，是因为互操作性。`Promise/A+`是标准，有不少实现，我们刚刚说过，我们在`resolve`一个`Promise`时，有两种可能性，`Promise`实现需要知道我们给它的值是一个可以直接用的值还是`thenable`。如果是一个带有`thenable`方法的对象，就会调用它的`thenable`方法来`resolve`给当前`Promise`。这听起来很挫，万一我们恰好有个对象，它就带`thenable`方法，但是又跟`Promise`没啥关系呢？\\n这已经是目前最好的方案了，在`Promise`被添加进`JavaScript`之前，就已经存在很多`Promise`实现了，通过这种方式可以让多个`Promise`实现互相兼容，否则的话，所有的`Promise`实现都需要搞个`flag`来表示它的`Promise`是`Promise`。\\n\\n# 再具体谈谈使用Promise\\n\\n刚刚的例子里，我们已经粗略了解了一下`Promise`的创建使用，我们通过`then``catch``finally`来“hook”进`Promise`的`fulfillment`，`rejection`，`completion`阶段。大部分情况下，我们还是使用其它api返回的`Promise`，比如`fetch`的返回结果，只有我们自己提供api时或者封装一些老的api时（比如包装`xhr`），我们才会自己创建一个`Promise`。所以我们现在来进一步了解一下`Promise`的使用。\\n\\n## then\\n`then`的使用很简单，\\n```\\nconst p2=p1.then(result=>doSomethingWith(result))\\n```\\n我们注册了一个`fulfillment handler`，并且返回了一个新的`Promise（p2)`。`p2`是`fulfilled`还是`rejected`将取决于`p1`的状态以及`doSomethingWith`的执行结果。如果`p1`变成了`rejected`，我们注册的`handler`不会被调用，`p2`直接变成`rejected`，`rejection reason`就是`p1`的`rejection reason`。如果`p1`是`fulfilled`，那我们注册的`handler`就会被调用了。根据`handler`的执行情况，有这几种可能：\\n\\n* `doSomethingWith`返回一个`thenable`，`p2`将会被`resolve`到这个`thenable`（取决于这个`thenable`的执行情况，决定`p2`是`fulfilled`还是`rejected`）\\n* 如果返回了其它值，`p2`直接带着那个值进入`fulfilled`状态\\n* 如果`doSomethingWith`中途出现`throw`，`p2`进入`rejected`状态\\n\\n这词儿怎么看着这么眼熟？没错我们刚刚介绍`resolve`跟`reject`时就是这么说的，这些是一样的行为，在我们的`handler`里`throw`跟调用`reject`一个效果，`return`跟`resolve`一个效果。\\n\\n而且我们知道了我们可以在`then/catch/finally`里面返回`Promise`来`resolve`它们创建的`Promise`，那我们就可以串联一些依赖其它异步操作结果且返回`Promise`的api了。像这样：\\n```\\np1.then(result=>secondOperation(result))\\n  .then(result=>thirdOperation(result))\\n  .then(result=>fourthOperation(result))\\n  .then(result=>fifthOperation(result))\\n  .catch(error=>console.error(error))\\n```\\n其中任何一步出了差错都会调用`catch`。\\n\\n如果这些代码都改成回调的方式，就会形成`回调地狱`，每一步都要判断错误，一层一层嵌套，大大增加了代码的复杂度，而`Promise`的机制能够让代码扁平化，相比之下更容易理解。\\n\\n## catch\\n`catch`的作用我们刚刚也讨论过了，它会注册一个函数在`Promise`进入`rejected`状态时调用，除了这个，其他行为可以说跟then一模一样。\\n```\\nconst p2=p1.catch(error=>doSomethingWith(error))\\n```\\n这里我们在`p1`上注册了一个`rejection handler`，并返回了一个新的`Promise p2`，`p2`的状态将取决于`p1`跟我们在这个`catch`里面做的操作。如果`p1`是`fulfilled`，这边的`handler`不会被调用，`p2`就直接带着`p1`的`fulfillment value`进入`fulfilled`状态，如果`p1`进入`rejected`状态了，这个`handler`就会被调用。取决于我们的`handler`做了什么：\\n\\n* `doSomethingWith`返回一个`thenable`，`p2`将会被`resolve`到这个`thenable`\\n* 如果返回了其它值，`p2`直接带着那个值进入`fulfilled`状态\\n* 如果`doSomethingWith`中途出现`throw`，`p2`进入`rejected`状态\\n\\n没错，这个行为跟我们之前讲的`then`的行为一模一样，有了这种一致性的保障，我们就不需要针对不同的机制记不同的规则了。\\n\\n这边尤其需要注意的是，如果我们从`catch handler`里面返回了一个`non-thenable`，这个`Promise`就会带着这个值进入`fulfilled`状态。这将`p1`的`rejection`转换成了`p2`的`fulfillment`，这有点类似于`try/catch`机制里的`catch`，可以阻止错误继续向外传播。\\n\\n这是有一个小问题的，如果我们把`catch handler`放在错误的地方：\\n\\n```\\nsomeOperation()\\n    .catch(error => {\\n        reportError(error);\\n    })\\n    .then(result => {\\n        console.log(result.someProperty);\\n    });\\n```\\n这种情况如果`someOperation`失败了，`reportError`会报告错误，但是`catch handler`里什么都没返回，默认就返回了`undefined`，这会导致后面的`then`里面因为返回了`undefined`的`someProperty`而报错。\\n```\\nUncaught (in promise) TypeError: Cannot read property 'someProperty' of undefined\\n```\\n由于这时候的错误没有`catch`来处理，`JavaScript`引擎会报一个`Unhandled rejection`。\\n所以如果我们确实需要在链式调用的中间插入`catch handler`的话，我们一定要确保整个链路都有恰当的处理。\\n\\n## finally\\n我们已经知道，`finally`方法有点像`try/catch/finally`里面的`finally`块，`finally handler`到最后一定会被调用，不管当前`Promise`是`fulfilled`还是`rejected`。它也会返回一个新的`Promise`，然后它的状态也是根据之前的`Promise`以及`handler`的执行结果决定的。不过`finally handler`能做的事相比而言更有限。\\n```\\nfunction doStuff() {\\n    loading.show();\\n    return getSomething()\\n        .then(result => render(result.stuff))\\n        .finally(() => loading.hide());\\n}\\n```\\n我们可以在做某件耗时操作时展示一个加载中的组件，然后在最后结束时把它隐藏。我在这里没有去处理`finally handler`可能出现的错误，这样我代码的调用方既可以处理结果也可以处理错误，而我可以保证我打开的一些副作用被正确销毁（比如这里的隐藏loading）。\\n\\n\\n细心的同学可以发现，`Promise`的三种`handler`有点类似于传统的`try/catch/finally`:\\n```\\ntry{\\n  // xxx\\n}catch (e) {\\n  // xxx\\n}finally {\\n  \\n}\\n```\\n\\n正常情况下，`finally handler`不会影响它之前的`Promise`传过来的结果，就像`try/catch/finally`里面的`finally`一样。除了返回的`rejected`的`thenable`，其他的值都会被忽略。也就是说，如果`finally`里面产生了异常，或者返回的`thenable`进入`rejected`状态了，它会改变返回的`Promise`的结果。所以它即使返回了一个新的值，最后调用方拿到的也是它之前的`Promise`返回的值，但是它可以把`fulfillment`变成`rejection`，也可以延迟`fulfillment`（毕竟返回一个`thenable`的话，要等它执行完才行）。\\n\\n简单来说就是，它就像`finally`块一样，不能包含`return`，它可以抛出异常，但是不能返回新的值。\\n\\n```\\nfunction returnWithDelay(value, delay = 10) {\\n    return new Promise(resolve => setTimeout(resolve, delay, value));\\n}\\n \\n// The function doing the work\\nfunction work() {\\n    return returnWithDelay(\\\"original value\\\")\\n        .finally(() => {\\n            return \\\"value from finally\\\";\\n        });\\n}\\n \\nwork()\\n    .then(value => {\\n        console.log(\\\"value = \\\" + value); // \\\"value = original value\\\"\\n    });\\n```\\n这边我们可以看到最后返回的值并不是`finally`里面返回的值，主要有两方面：\\n* `finally`主要用来做一些清理操作，如果需要返回值应该使用`then`\\n* 没有`return`的函数、只有`return`的函数、以及`return undefined`的函数，从语法上来说都是返回`undefined`的函数，`Promise`机制无法区分这个`undefined`要不要替换最终返回的值\\n\\n## then其实有两个参数\\n我们目前为止看到的`then`都是接受一个`handler`，其实它可以接收两个参数，一个用于`fulfillment`，一个用于`rejection`。而且`Promise.catch`等价于`Promise.then(undefined,rejectionHadler)`。\\n\\n```\\np1.then(result=>{\\n  \\n},error=>{\\n  \\n})\\n```\\n\\n这个跟\\n\\n```\\np1.then(result=>{\\n\\n}).catch(error=>{\\n\\n})\\n```\\n\\n可不等价，前者两个`handler`都注册在同一个`Promise`上，而后者`catch`注册在`then`返回的`Promnise`上，这意味着如果前者里只有`p1`出错了才会被处理，而后者`p1`出错，以及`then`返回的`Promise`出错都能被处理。\\n\\n# 解答开头的问题\\n现在我们知道要提供`Promise`给外部使用，`Promise`设计成在外面是没有办法获取`resolve`函数的，也就改变不了一个已有`Promise`的状态，我们只能基于已有`Promise`去生成新的`Promise`。如果允许异常向外抛出，那我们该怎么恢复后续`Promise`的执行？比如`Promise a`出现异常了，异常向外抛出，外面是没办法改变`Promise a`的数据的。设计成在`Promise`里面发生任何错误时，都让当前`Promise`进入`rejected`状态，然后调用之后的`catch handler`，`catch handler`有能力返回新的`Promise`，提供`fallback`方案，可以大大简化这其中的复杂度。\\n\\n# 工具方法\\n`Promise`还提供了一些工具方法，我们可以使用它们来同时处理多个`Promise`，例如`Promise.all`，`Promise.race`，`Promise.allsettled`，`Promise.any`，今天我就不一一介绍了，大家感兴趣的可以自行了解一下。\\n\\n# 写在结尾\\n`Promise`的出现，让我们：\\n1. `Promise`提供了标准的方式来处理结果\\n2. `Promise`的`then`返回新的`Promise`，可以多个串联，达到注册多个回调的效果\\n3. 对于已经完成的异步操作，我们后来注册的`then`也能被调用\\n4. 我们只能通过`executor`函数提供的两个函数来改变`Promise`的状态，没有其他办法可以`resolve`或者`reject` `Promise`，而且这两个方法也不存在于`Promise`本身，所以我们可以把我们的`Promise`对象给其他人去使用，比如我们提供给外部一个api，以`Promise`返回，可以放心地让外部通过`Promise`来观察最终的结果，他们也没办法来改变`Promise`的状态。\\n5. 可以实现统一的同时处理多个`Promise`的逻辑\\n\\n而且，我在本文开头提到过，回调地狱有两个问题是：\\n* 向已经完成的操作添加回调并没有统一的标准\\n* 很难向某个操作添加多个回调\\n\\n这些都被`Promise`的标准解决了，标准确保了两件事：\\n* `handler`一定会被调用\\n* 调用是异步的\\n\\n也就是说，如果我们获取到了其它api提供的`Promise`，有了类似如下的代码：\\n```\\nconsole.log('before')\\np1.then(()=>{\\n  console.log('in')\\n})\\nconsole.log('after')\\n```\\n标准确保了，执行结果是`before`，然后是`after`，最后是（在`p1`变成`fulfilled`状态或者已经变成`fulfilled`状态时）`in`。如果`Promise`在经过一段时间之后才变成`fulfilled`，这个`handler`也会被往后调度。如果`Promise`已经变成`fulfilled`了，那`fulfillment handler`会被立即调度（不是立即执行），调度指的是被加入微任务队列，确保这些`handler`被异步调用大概是`Promise`唯一让同步代码被异步调用的情形了。\\n\\n`Promise`推出也好多年了，我们日常开发中已经离不开它了，即使是`async` `await`背地里还是在跟它打交道，希望本文带给大家对`Promise`更全面的认识，当然了，关于`Promise`还有一些最佳实践跟反模式，由于篇幅的原因下次再见啦，Happy coding~\\n\\n\\n",
        "tags": [
            "前端",
            "面试",
            "JavaScript"
        ]
    },
    {
        "article_id": "7178685520900259897",
        "cover_image": "",
        "title": "2022 疫情下谈何出路？",
        "brief": "「回顾2022，展望2023，我正在参与2022年终总结征文大赛活动」 很快，确实很快。 上周突然在掘金上又再次看到了年终活动，时间不经意间又到了 2022 年的年末。",
        "user_name": "Mondo",
        "view_count": 2359,
        "collect_count": 1,
        "comment_count": 2,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/78607cf47e1f64d96a596ed1007695ea~300x300.image",
        "category": "阅读",
        "content": "「回顾2022，展望2023，我正在参与[2022年终总结征文大赛活动](https://juejin.cn/post/7172462429929111559 \\\"https://juejin.cn/post/7172462429929111559\\\")」\\n\\n很快，确实很快。\\n\\n上周突然在掘金上又再次看到了年终活动，时间不经意间又到了 2022 年的年末。\\n\\n## 恭喜毕业？\\n\\n5月份的”毕业潮“确实是吓到我了，现在打工人真实现了在社会这所学校学习，不过以前是可以一直学；现在还有个”毕业证“。虽然现在我还没有“毕业”，但是对于我这种大龄人员来说，时刻保持警醒，是习惯也是无奈。\\n\\n进入公司后，提拔为小组长，从6月到10月就连续性的进行述职报告，这也是上面实行的一条规定，想让其他同事看看这些“小干部”的日常工作情况和管理能力。对于我这种“入行不久的新人”而言，我确实学到了一些“欺上瞒下”的技巧。管理规则的不确定，以及组织结构的不停变动，实际上我认为今年公司在沟通协作上并没有那么顺畅，但是我也不擅长这块，只能陪着一起“玩”了。\\n\\n就组内而言，年初进行了一次新人培训，新人进入组内需要对业务范围，组内和项目代码规则进行相应培训；很遗憾没有通过，被劝退了。这也引起了我对招人这块的一些思索，到底组内需要什么样的人员，招的人适不适合组内的氛围和节奏。只有招到合适的，才不会浪费彼此的时间。\\n\\n由于人员的基础知识掌握不牢以及对前端整个生态概念的缺失，年中对组内人员进行了 3 次分享，和以前在其他公司分享有所不同的是以在线形式分享，是初次以这种形式分享内容，我还每次都写下稿子：\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc77e0b6d68d4ea196dcd6418bbc95bb~tplv-k3u1fbpfcp-watermark.image?)\\n\\n有种直播的感觉，这是种新奇的体验。分享出来的东西必须自己吃透，如果传播一些不正确的内容给组员，反而还误导了别人，每次都要对分享的内容进行知识的查找和实际的运用，对于自己又是一种回顾和提升。\\n\\n期间也对公司的移动端 H5 和 小程序项目进行业务的梳理，带着组员实实在在的做一版功能开发，对代码的 code review 也比较严格，所以代码这块还算“干净”。随后抽离出适用于公司的项目模版，后续也做了自动化部署方案，实现多环境自动化部署。自己进入公司以来，其实主要负责的还是公司遗留项目，使用的还是 Java + JSP + AngularJS 的这套，对前端来说，开发环境极其不友好；直到 10 月份我还在陆续调研是否使用微前端来重构部分主要业务：\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae2a1ae8126a493b8e5159095fdc2a46~tplv-k3u1fbpfcp-watermark.image?)\\n\\n不过很遗憾，由于公司业务中心的转移，这部分事情也搁置了。所以有时候工作上的一些想法，还是需要早验证，需要实际结合公司业务需求来综合考虑。\\n\\n## 迷茫\\n\\n8 月份中旬早上被电话铃声叫醒，接通后需要我马上到公司处理问题，我看了下手机，其实在凌晨 3 点的时候就有未接电话了。由于业务的关系，通常需要在线 24 小时，可能在晚上 22 点的时候，还会被拉到线上开会，尤其是和同事一起吃饭的时候，听他们谈论有时已经在回家路上，QQ 被消息到时，需要回公司！这都没有任何想法的时候，我觉得他们已经被牢牢的困住了。\\n\\n其实这也是我迷茫的时候，说实话，公司的业务与其他的一些福利其实是比较可以的，不过相对于平衡家庭来说比较困难，有时我也迷惑，我的一些同事们，他们不需要家的吗？是否真的值的这样的付出？\\n\\n出于大环境不可靠的情况下，其实从去年就开始寻找自己的其他的一些可能性，以前做的一个[查车牌](https://imondo.cn/files/apps/car/)小程序实现了 APP 化，APP 利用 uni-app 开发完成，后续还是想用原生来做，所以现在慢慢的在接触 Swift。这也是一种新的尝试。对自己能力的一个提升，不只限于前端领域，还是想尝试一些其他可能。\\n\\n后半年，利用周末和下班后的时间，又上线了[地址管理](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e074e4c045654722a6f3a36c81fe3231~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)这款小程序。这个小程序其实是解决我自己的一个小痛点，由于在节假日尤其是过年走亲戚的时候，总是忘记了亲戚家的楼号房，每次都要打电话询问，这无疑是有点尴尬😅；所以就上线了这款小程序，推送给亲戚朋友们使用。\\n\\n\\n\\n## 疫情常态化\\n\\n疫情常态化下，每天都在口罩下工作，就怕自己被🐑，但好像我是所谓的天选打工人，家里都🐑了，我还是好好的。只是对于小孩而言有点难熬，每天都需要哄睡小孩到 23 点后，才会有部分时间来充实自己；所以也不知道自己还能坚持多久。\\n\\n在这几天内，也实实在在的体会到了家庭的责任；一家老小都需要我来照顾，买药，买菜，买其他一些日用品。当需要你承担起家庭责任的时候，你是否已经有足够的耐心和毅力来承担这一切。\\n\\n2022 年还是有些遗憾的。去年立的一些 flag 没有完成；没有很好的找到家庭与工作的平衡点；没有找到适合自己的一些可能性；所以来年**仍需要努力**，继续**寻找出路**。\\n\\n毕竟年龄已大，前路未知。\\n",
        "tags": [
            "前端",
            "程序员",
            "年终总结"
        ]
    },
    {
        "article_id": "7190389686240542780",
        "cover_image": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e4b0a32e0ee4a40a3c806d8d3760ace~tplv-k3u1fbpfcp-watermark.image?",
        "title": "关于2022年的流水账与碎碎念 | 逆风而行，向阳而生",
        "brief": "「回顾2022，展望2023，我正在参与[2022年终总结征文大赛活动](https://juejin.cn/post/7172462429929111559 \"https://juejin.cn/p",
        "user_name": "你要不要喝奶茶",
        "view_count": 2529,
        "collect_count": 4,
        "comment_count": 9,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/efd686e4370a58561b6eb9916168cd30~300x300.image",
        "category": "阅读",
        "content": "「回顾2022，展望2023，我正在参与[2022年终总结征文大赛活动](https://juejin.cn/post/7172462429929111559 \\\"https://juejin.cn/post/7172462429929111559\\\")」\\n\\n[本文首发于个人博客](https://itsuki.cn/blog/bye-2022)\\n\\n当这篇总结与大家见面的时候已经是快要过年了，一直没有写的原因是不知道从哪里下笔，对我来说，今年发生的大事情其实已经写过了，现在再写感觉就是炒冷饭，还有一个原因就是最近有点忙。\\n\\n> 所以这是一篇关于 2022 年的流水账。\\n\\n## 无聊的捣鼓：Nvim\\n\\n寒假在家的时候，没有事情做，就开始捣鼓了 Nvim，简单的学了下 lua，就开始了\\\"抄\\\"各种各样的配置(NvChad、AstroNvim、Neovide、Lunarvim 等)之旅，于是有了 SkCode 这个项目，虽然是 \\\"xxCode\\\"，属于我自己无聊时候捣鼓的一个 nvim 配置，所以代码写的并没有拓展性。\\n\\n比较让我惊喜的是这个项目从 0 -> 81 个 star，虽然看起来不多，但是有 81 个人喜欢这个仓库还是很开心的。\\n\\n![SkCode](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5680764ba4ee49abac31e13d4884ed0f~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n最近也变懒了，SkCode 添加了新的东西，README 没有及时更新，所以今年的一个小 TODO 就是好好的解决目前 SkCode 中的一些痛点以及完善文档。\\n\\n> 如果有小伙伴使用 nvim，不妨试试这个配置，链接在[这里](https://github.com/itsuki0927/SkCode)。\\n\\n## 网易实习和字节的相爱相杀\\n\\n放完寒假我就一直在家待到三月份，想着去网易提前实习两个月后回学校再玩一会准备毕业，刚在网易实习的那几天，字节有 hr 打电话给我约面试，那个时候已经被字节伤透了心，我说：已经在网易实习给拒绝了。\\n\\n![网易的夕阳](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb9ddcae895f4eea8f226dca8acbc242~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n那个时候对网易充满了期待，丰富的早餐、崭新的面孔、陌生的项目，对于一个刚入职场的校招生来说，什么都是新鲜的。\\n\\n但是在网易经历了一段时间之后，发现和自己想要的落差太大了，不喜欢的技术栈：Vue2.0、JQuery，没有完整的新人培养体系等等，在技术上帮助并不是很大，可能对我帮助大一点的是学会了简单的 PS 抠图（当然年末的我又忘记了）。\\n\\n那个时候就跟沙雕群友吐槽，然后一个朋友推荐字节跳动的人给我，简单把网易的实习经历添加到简历里面就投了他的部门：基础架构，当然毫不意外的简历挂了。\\n\\n在我实习的某一天，一个上海的电话，当我还在犹豫要不要接这个电话时，身体却出卖了我，走到楼梯间接起了这个电话，说是字节的 hr ，想要约面试，当时想的是反正干的不爽，不如试试吧。\\n\\n![字节面试](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/82c7518ce7de4a928d55d9b3cfe1b0c6~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n面试是约了两天以后的晚上六点半，还记得这是我下班最早的一次：六点下班，骗导师说：毕业论文老师指导是六点半的会议。\\n\\n也就是因为这一通电话，接上了我和字节的缘分。\\n\\n## 做一只奔涌的浪花\\n\\n从网易请假回来的时候已经是五月份了，这一次请假是和网易的离别，回到学校以后，续上了学生的生活，又开始了循环模式：寝室 -> 图书馆 -> 操场 -> 食堂。\\n\\n这一次再也不需要有任何的压力，再也不用被手机提示音搞得担惊受怕，再也不用担心错过一个约面试的电话而少一次面试机会，再也不用去背那些毫无意义的八股文了，再也不用每天在各个公司的招聘官网上查看进度了，我可以想玩就玩，想学就学（哎，就是玩），这种感觉真的很舒服。\\n\\n![拜拜👋🏻👋🏻](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cb548d802f1340f990d9988da528aa60~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n那一段时间和几个还在找工作的朋友一起呆在图书馆，他们讨论的内容就是今天投了多少份简历，boss 上有多少沟通、然后哪些有面试机会，我可能就显得格格不入了。\\n\\n往后就是参加了毕业典礼，和朋友拍了学士服的照片，我是一个没有什么仪式感的人，觉得有这些时间还不如多写写代码，但还是想要记录下来这唯一的学士服，也有可能是弥补之前大专的遗憾吧。\\n\\n![学士服](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d9f162466c06479b89f8c50ab34267c8~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n在学校待到最后那几天，和我一起去图书馆的朋友陆陆续续回家了，下次见面有可能是多年以后，希望他们能做一颗奔涌的浪花，我也如此。\\n\\n## 写了亿万年的博客\\n\\n[这个博客](https://itsuki.cn)我写了很久，真要追溯起来的话，从 19 年开始写博客这个项目，中间鸽了两年，域名也从`fivewoods.xyz`到现在的`itsuki.cn`，直到今年我才认认真真的重拾起博客这个项目。\\n\\n当我觉得一个博客能有什么技术难点的时候，现在发现我错了，麻雀虽小，五脏俱全。\\n\\n需要考虑 Seo、埋点、UI 设计、UE 交互、后台管理系统、数据库、后端、性能等一系列的东西，而正是因为这些东西，我去学习了 seo、figma 设计、SpringBoot JPA 、性能优化等相关知识。\\n\\n一个博客最重要的不是样式而是其内容，这一年我写了 12 篇文章，平均下来一个月一篇，其实写的并不是很多，但是对比之前的我来说，我是在进步的，只希望后面的日子里，可以多写写文章，生活也好、技术也罢。\\n\\n![2022年 文章统计](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99c03272a9a94a63909705ae2805b44b~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n> 别问我为啥一个博客可以写这么久，现在博客的代码都不敢说能够很自信的拿出来说，这个仓库代码写的不错，真的太菜啦 😭😭😭。\\n\\n## 字节的半年生活\\n\\n六月份之后就是在字节的工作之旅，因为当时上海疫情比较严重，刚入职的那一个月是在家里居家办公度过的。\\n\\n去到上海的那一天是老妈送我的，她走在前面，我看着背影，以前她的背没那么驼，走路也没那么蹒跚，当自己静下心来看的时候，发现父母已经老了，而我长大了。\\n\\n![希望我的成长，可以赶上父母老去的速度](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/643573fcc43647fd95a7e810b46933e4~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n上公交车的时候一个简单的拥抱和\\\"照顾好自己\\\"的寒暄就开始了新的旅程。\\n\\n到达上海之后立马就找中介看了公司附近的房子，上班走路只要几分钟，之前觉得房子还挺不错，直到有一段时间居家办公，才体会到早上装修、晚上狗叫是什么感觉，它的优点是近，缺点就不用说了，所以如果有小伙伴找房子一定要找安静一点的小区!!!\\n\\n字节并不像人们说的那么卷，\\\"字节一年、人间三年\\\"也不知道是谁说的，对于我现在这个部门来说就是纯纯的谣言（我最近就在赶需求，补充一个前提除非产品 push😭😭😭）。\\n\\n整体开发流程也比较规范，需要经历以下几步：\\n\\n- PM 侧进行需求调研\\n- PRD 粗评/细评\\n- UI 粗评/细评\\n- 技术评审\\n- 技术开发\\n- ShowCase\\n- UI 走查/测试\\n- Launch Review\\n- 上线/测试回归\\n\\n我之前也没想到一个需求能够有这么多步骤，整体的开发时间比较富裕（除非产品 push！！！)。\\n\\n从网易出来之后，我才发现为啥网易被叫 🐷 厂了，没有对比就没有伤害，发现字节的伙食和网易比起来还是有一定差距，网易的小碟子菜更加精致。\\n\\n字节好的地方在于有很多很多的饮料和零食还有下午茶，每天都可以拿到好多的饮料和零食，有时候在公司跑完步比较饿，就带点零食回家，过一段时间，家里就可以开小卖部了。\\n\\n![一顿午餐囤的饮料](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/74d875a9c12240a1af9a7997781dc309~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n字节给我的感觉就是自由，足够的自由，我很喜欢这种自由的感觉，很适合有拼劲的年轻小伙子 😁😁😁。\\n\\n## 生活需要跑跑步\\n\\n我感觉跑步状态就是目前的生活、学习节奏，三天打鱼两天晒网，每次一放假就开始摸鱼了，然后需要时间恢复，恢复的差不多了又放假了，然后又回到最初的起点甚至更差。\\n\\n去年买了一个佳明 255 的手表，想着要开始系统的训练了，但是上班之后，跑步的时间变少了，从之前的为了跑步而跑步变成了强身健体的跑步，每天花在跑步上的时间，可能就是固定 5 公里左右。\\n\\n当时想着参加一场马拉松，就和在杭州网易的同伴一起参加了一场马拉松，也算是有个照应。\\n\\n跑到五公里过后小腹开始隐隐作痛，但是不想就这么停下，我知道\\\"左脚在右脚前面，右脚在左脚前面\\\"，如此反复就可以跑到终点。\\n\\n![放弃很容易，但是坚持一定很酷！](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/451522b7df3e4535aa062e1399d215ff~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n当然我完赛了，跑得并不是很满意，但是我知道我付出了多少努力，这个结果似乎是在预期之中。\\n\\n**跑步就像做一件事情，投入了多少精力，它就会有多少反馈。**\\n\\n## 2023 年小目标\\n\\n像流水账一样讲到这里，也算是把 2022 年讲完了，回首 2022，好像没有给 2022 定一个目标，所以之前的年目标有没有达成，我也不清楚。\\n\\n那就在 2023 年定一个年目标，希望一步一个脚印，可以把这些事情都完成。\\n\\n1. 参与到开源社区。\\n2. 写 12+ 篇文章。\\n3. 看 6 本书。\\n4. 跑步 1000 KM。\\n",
        "tags": [
            "年终总结",
            "前端",
            "JavaScript"
        ]
    },
    {
        "article_id": "7195089927859044413",
        "cover_image": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf620f9654864c3784981131f868ed22~tplv-k3u1fbpfcp-watermark.image?",
        "title": "随机高并发查询结果一致性设计实践",
        "brief": "物流合约中心是京东物流合同管理的唯一入口。为商家提供合同的创建，盖章等能力，为不同业务条线提供合同的定制，归档，查询等功能。",
        "user_name": "京东云开发者",
        "view_count": 720,
        "collect_count": 1,
        "comment_count": 0,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/b9a366997037d998063135bd56302b85~300x300.image",
        "category": "开发工具",
        "content": "**作者：京东物流 赵帅 姚再毅 王旭东 孟伟杰 孔祥东**\\n\\n### 1 前言\\n物流合约中心是京东物流合同管理的唯一入口。为商家提供合同的创建，盖章等能力，为不同业务条线提供合同的定制，归档，查询等功能。由于各个业务条线众多，为各个业务条线提供高可用查询能力是物流合约中心重中之重。同时计费系统在每个物流单结算时，都需要查询合约中心，确保商家签署的合同内容来保证计费的准确性。\\n\\n### 2 业务场景\\n##### 1.查询维度分析\\n从业务调用的来源来看，合同的大部分是计费系统在每个物流单计费的时候，需要调用合约中心来判断，该商家是否签署合同。\\n\\n![31](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/74b8aae612f64b40be8fa78a8a8298fa~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n从业务调用的入参来看，绝大部分是多个条件来查询合同，但基本都是查询某个商家，或通过商家的某个属性（例如业务账号）来查询合同。\\n\\n从调用的结果来看，40%的查询是没有结果的，其中绝大部分是因为商家没有签署过合同，导致查询为空。其余的查询结果，每次返回的数量较少，一般一个商家只有3到5个合同。\\n\\n##### 2.调用量分析\\n调用量\\n目前合同的调用量，大概是在每天2000W次。\\n\\n一天的调用量统计：\\n![32](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/34cc23f499ab4d3f9e36a4b42d5b4a41~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n调用时间\\n每天高峰期为上班时间，最高峰为4W/min。\\n\\n一个月的调用量统计：\\n\\n![33.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f0761285e22f4e658b4f657928cd3a40~tplv-k3u1fbpfcp-watermark.image?)\\n\\n由上可以看出，合同每日的调用量比较平均，主要集中在9点到12点和13点到18点，也就是上班时间，整体调用量较高，基本不存在调用暴增的情况。\\n\\n\\n\\n总体分析来看，合约中心的查询，调用量较高，且较平均，基本都是随机查询，也并不存在热点数据，其中无效查询占比较多，每次查询条件较多，返回数据量比不大。\\n\\n\\n\\n### 3 方案设计\\n从整体业务场景分析来看，我们决定做三层防护来保证调用量的支撑，同时需要对数据一致性做好处理。第一层是布隆过滤器，来拦截绝大部分无效的请求。第二层是redis缓存数据，来保证各种查询条件的查询尽量命中redis。第三层是直接查询数据库的兜底方案。同时再保证数据一致性的问题，我们借助于广播mq来实现。\\n![35](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f22a5dce7ba4edc817c47d0542a8ad6~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n##### 1.第一层防护\\n由于近一半的查询都是空，我们首先这是缓存穿透的现象。\\n\\n**缓存穿透问题**\\n\\n缓存穿透（cache penetration）是用户访问的数据既不在缓存当中，也不在数据库中。出于容错的考虑，如果从底层数据库查询不到数据，则不写入缓存。这就导致每次请求都会到底层数据库进行查询，缓存也失去了意义。当高并发或有人利用不存在的Key频繁攻击时，数据库的压力骤增，甚至崩溃，这就是缓存穿透问题。\\n\\n**常规解决方案**\\n\\n缓存特定值\\n\\n一般对于缓存穿透我们比较常规的做法就是，将不存在的key 设置一个固定值，比如说NULL,&&等等，在查询返回这个值的时候，我们应用就可以认为这是一个不存在的key,那我们应用就可以决定是否继续等待，还是继续访问，还是直接放弃，如果继续等待访问的话，设置一个轮询时间，再次请求，如果取到的值不再是我们预设的，那就代表已经有值了，从而避免了透传到数据库，从而把大量的类似请求挡在了缓存之中。\\n\\n缓存特定值并同步更新\\n\\n特定值做了缓存，那就意味着需要更多的内存存储空间。当存储层数据变化了，缓存层与存储层的数据会不一致。有人会说，这个问题，给key 加上一个过期时间不就可以了，确实，这样是最简单的，也能在一定程度上解决这两个问题，但是当并发比较高的时候（缓存并发），其实我是不建议使用缓存过期这个策略的，我更希望缓存一直存在；通过后台系统来更新缓存中的数据一致性的目的。\\n\\n**布隆过滤器**\\n\\n布隆过滤器的核心思想是这样的，它不保存实际的数据，而是在内存中建立一个定长的位图用0,1来标记对应数据是否存在系统；过程是将数据经过多个哈希函数计算出不同的哈希值，然后用哈希值对位图的长度进行取模，最后得到位图的下标位，然后在对应的下标位上进行标记；找数的时候也是一样，先通过多个哈希函数得到哈希值，然后哈希值与位图的长度进行取模得到多个下标。如果多个下标都被标记成1了，那么说明数据存在于系统，不过只要有一个下标为0那么就说明该数据肯定不存在于系统中。\\n\\n在这里先通过一个示例介绍一下布隆过滤器的场景：\\n\\n以ID查询文章为例，如果我们要知道数据库是否存在对应的文章，那么最简单的方式就是我们把所有数据库存在的ID都保存到缓存去，这个时候当请求过进入系统，先从这个缓存数据里判断系统是否存在对应的数据ID，如果不存在的话直接返回出去，避免请求进入到数据库层，存在的话再从获取文章的信息。但是这个不是最好的方式，因为当文章的数量很多很多的时候，那缓存中就需要存大量的文档id而且只能持续增长，所以我们得想一种方式来节省内存资源当又能是请求都能命中缓存，这个就是布隆过滤器要做的。\\n\\n![36](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b3e9d5fe277d4ce897ed46adb08d1b48~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n我们分析布隆过滤器的优缺点\\n\\n**优点**\\n\\n1.不需要存储数据，只用比特表示，因此在空间占用率上有巨大的优势\\n2.检索效率高，插入和查询的时间复杂度都为 O(K)（K 表示哈希函数的个数）\\n3.哈希函数之间相互独立，可以在硬件指令层次并行计算，因此效率较高。\\n\\n**缺点**\\n\\n1.存在不确定的因素，无法判断一个元素是否一定存在，所以不适合要求 100% 准确率的场景\\n2.只能插入和查询元素，不能删除元素。\\n\\n布隆过滤器分析：面对优点，完全符合我们的诉求，针对缺点1，会有极少的数据穿透对系统来说并无压力。针对缺点2，合同的数据，本来就是不可删除的。如果合同过期，我们可以查出单个商家的所有合同，从合同的结束时间来判断合同是否有效，并不需要取删除布隆过滤器里的元素。\\n\\n考虑到调用redis布隆过滤器，会走一次网络，而我们的查询近一半都是无效查询，我们决定使用本地布隆过滤器，这样就可以减少一次网络请求。但是如果是本地布隆过滤器，在更新时，就需要对所有机器的本地布隆过滤器更新，我们监听合同的状态来更新，通过mq的广播模式，来对布隆过滤器插入元素，这样就做到了所有机器上的布隆过滤器统一元素插入。\\n\\n\\n\\n##### 2.第二层防护\\n面对高并发，我们首先想到的是缓存。\\n\\n引入缓存，我们就要考虑缓存穿透，缓存击穿，缓存雪崩的三大问题。\\n\\n其中缓存穿透，我们已再第一层防护中处理，这里只解决缓存击穿，缓存雪崩的问题。\\n\\n缓存击穿（Cache Breakdown）缓存雪崩是指只大量热点key同时失效的情况，如果是单个热点key，在不停的扛着大并发，在这个key失效的瞬间，持续的大并发请求就会击破缓存，直接请求到数据库，好像蛮力击穿一样。这种情况就是缓存击穿。\\n\\n常规解决方案\\n\\n缓存失效分散\\n\\n这个问题其实比较好解决，就是在设置缓存的时效时间的时候增加一个随机值，例如增加一个1-3分钟的随机，将失效时间分散开，降低集体失效的概率；把过期时间控制在系统低流量的时间段,比如凌晨三四点，避过流量的高峰期。\\n\\n加锁\\n\\n加锁，就是在查询请求未命中缓存时，查询数据库操作前进行加锁，加锁后后面的请求就会阻塞，避免了大量的请求集中进入到数据库查询数据了。\\n\\n永久不失效\\n\\n我们可以不设置过期时间来保证缓存永远不会失效，然后通过后台的线程来定时把最新的数据同步到缓存里去\\n\\n解决方案：使用分布式锁，针对同一个商家，只让一个线程构建缓存，其他线程等待构建缓存执行完毕，重新从缓存中获取数据。\\n\\n缓存雪崩（Cache Avalanche）当缓存中大量热点缓存采用了相同的实效时间，就会导致缓存在某一个时刻同时实效，请求全部转发到数据库，从而导致数据库压力骤增，甚至宕机。从而形成一系列的连锁反应，造成系统崩溃等情况，这就是缓存雪崩。\\n\\n解决方案：缓存雪崩的解决方案是将key的过期设置为固定时间范围内的一个随机数，让key均匀的失效即可。\\n\\n我们考虑使用redis缓存，因为每次查询的条件都不一样，返回的结果数据又比较少，我们考虑限制查询都必须有一个固定的查询条件，商家编码。如果查询条件中没有查商家编码，我们可以通过商家名称，商家业务账号这些条件来反查查商家编码。\\n\\n这样我们就可以缓存单个商家编码的所有合同，然后再通过代码使用filter对其他查询条件做支持，避免不同的查询条件都去缓存数据而引发的缓存数据更新，缓存数据淘汰已经缓存数据一致等问题。\\n\\n同时只缓存单个商家编码的所有合同，缓存的数据量也是可控，每个缓存的大小也可控，基本不会出现redis大key的问题。\\n\\n引入缓存，我们就要考虑缓存数据一致性的问题。\\n\\n有关缓存一致性问题，可自行百度，这个就不在叙述。\\n\\n如图所示 对于商家编码维度的缓存数据，我们通过监听合同的状态，使用mq广播来删除对应商家的缓存，从而避免出现缓存和数据一致性的相关问题。\\n\\n![38](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ff1b92ef70c450199df9d739bba10af~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n### 3.第三层防护\\n第三层防护，自然是数据库，如果有查询经过了第一层和第二层，那我们需要直接查询数据库来返回结果，同时，我们对直接调用到数据库的线程进行监控。\\n\\n![37](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/53a66aeb185e41a58b5b3591738634ce~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n为避免一些未知的查询大量查询涌入，导致数据库调用保证的问题，尤其是大促时，我们可以提前对数据库里的所有商家合同进行提前缓存。在缓存时，为避免缓存雪崩问题，我们对将key的过期设置为固定时间范围内的一个随机数，让key均匀的失效。\\n\\n同时，为避免依然存在意外的情况，有大量查询涌入。我们通过ducc开关控制数据库的查询，如调用量太高导致无法支撑，则直接关闭数据库的调用，保证数据库不会直接宕机导致整个业务不可用。\\n\\n\\n\\n### 4 总结\\n本文主要分析了面对高并发调用的调用场景设计及的技术方案，在引入缓存的同时，也要考虑实际的调用入参及结果，面对增加的网络请求，是否可以进一步减少。面对redis缓存，是否可以通过一些手段避免所有查询条件都需要缓存，带来的缓存爆炸，缓存淘汰策略等问题，以及解决缓存与数据一致等一系列问题。\\n\\n本方案是根据具体的查询业务场景设计具体的技术方案，针对不同的业务场景，对应的技术方案也是不一样的。",
        "tags": [
            "架构",
            "设计",
            "Redis"
        ]
    },
    {
        "article_id": "7190723758779269178",
        "cover_image": "",
        "title": "组件库实战基础篇",
        "brief": "命令 命令很多，建议看文档，给开发小伙伴讲讲常用的，以后慢慢补充。 pnpm 我说一下我们组件库会常用到的命令和一些基础的概念（因为有小伙伴老是写不对命令）。 工作空间的概念: 举个例子，我们的一个大",
        "user_name": "溪饱鱼",
        "view_count": 2408,
        "collect_count": 11,
        "comment_count": 0,
        "avatar": "https://p26-passport.byteacctimg.com/img/mosaic-legacy/3795/3033762272~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: smartblue\\nhighlight: an-old-hope\\n---\\n# 命令\\n命令很多，建议看文档，给开发小伙伴讲讲常用的，以后慢慢补充。\\n## pnpm\\n我说一下我们组件库会常用到的命令和一些基础的概念（因为有小伙伴老是写不对命令）。\\n\\n`工作空间的概念`: 举个例子，我们的一个大项目是一个大的`厂区`，厂区里面有很多的`厂房`也就是工作区，每个厂房都有一套自己的`流水线`，`厂房和流水线`之间也会相互借东西，最后拼装成一个完整的产品。而`Pnpm`的优势就在于，它既让你厂房之间隔离得很好，同时在`厂房之间的联动`也非常方便。\\n\\n`辅助语法的概念`: 既然上面已经说到了厂房，`pnpm`的提供了一系列的命令都是让你这个`厂长`去更好的管理你的流水线和产品。就一般就是一个`命令` + `哪个厂区`的模式（当然我们不要拘泥于这种形式目的都是为了帮你管理厂区），比如:`--filter -r -w -D等` \\n\\n\\n\\n[更多的参照官网](https://pnpm.io/zh/)。\\n### 工作区\\n`pnpm-workspace.yaml` 定义了 [工作空间](https://pnpm.io/zh/workspaces) 的根目录，并能够使您从工作空间中包含 / 排除目录 。 默认情况下，包含所有子目录。\\n\\nFor example:\\n```js\\npackages:\\n  # all packages in direct subdirs of packages/\\n  - 'packages/*'\\n  # all packages in subdirs of components/\\n  - 'components/**'\\n  # exclude packages that are inside test directories\\n  - '!**/test/**'\\n```\\n### CLI\\n·\\n`-C` 在src中启动pnpm\\n    \\n```js\\npnpm -C './src' <cmd>\\n```\\n\\n`-w`\\n在根目录启动pnpm,执行命令\\n\\n```js\\npnpm -w <cmd>\\n```\\n### --filter或-F\\n`pnpm的选择器`\\n```js\\n// 当我们要选择某个包的时候\\npnpm -F @fd/fd-components <cmd>\\npnpm -F @scopo/xxx <cmd>\\n// 当我们要选择一组包的时候\\npnpm -F \\\"*packages\\\" <cmd>\\n// 相对于当前工作目录匹配项目\\npnpm --filter \\\"./packages/**\\\" <cmd>\\n// 从某个目录中选择符合给定的通配符的所有包\\npnpm --filter \\\"@babel/*{components/**}\\\" <cmd>  \\npnpm --filter \\\"@babel/*{components/**}[origin/master]\\\" <cmd>\\n// 排除\\n// 这将在除 `foo` 以外的所有项目中运行一个命令\\npnpm --filter=!foo <cmd> -w\\n//这将在所有不在 `lib`目录下的项目中运行一个命令：\\npnpm --filter=!./lib <cmd> -w\\n// 当包被过滤时，每个都会被匹配到至少一个选择器。 你可以使用无限数量的过滤器：\\npnpm --filter ...foo --filter bar --filter baz... test\\n```\\n### 相互引用下载包\\n这里pnpm自动帮你处理了远程包还是本地\\n```js\\n// 会在dev依赖下，加载\\\"@fd/xxx1\\\": \\\"workspace:*\\\"，同理也可以直接写在package.json里，发布后会转换为常规名称\\npnpm -F @fd/xxx add @fd/xxx1 -D\\n// 远程包\\npnpm -F @fd/xxx add @babel/parse\\n```\\n### shell\\n`--recursive, -r`在工作区的每个项目中执行 shell 命令。\\n```js\\n// 为所有的软件包清理 `node_modules` 安装信息。\\npnpm -r exec rm -rf node_modules\\n// 发布packages下所有包\\npnpm -r publish -F packages\\n```\\n`--if-present`如果脚本未定义，那么您可以使用 `--if-present `标志以避免遇到用非零的退出代码从而导致退出。 这使您可以在不中断执行链的情况下运行可能未定义的脚本。\\n\\n`--parallel`完全忽略并发和拓扑排序，在所有匹配的包中立即运行给定的脚本。\\n\\n### pnpm之多组件实例问题\\n`严格依赖隔离`（包之间版本不同，会隔离处理放在.pnpm，子包分别软连对应的版本）造成的多实例问题：\\n\\n在开发的时候虽然`peerDependencies`可以帮我们解决组件内的核心依赖库(如Vue)被`重复下载和安装`的问题，也可以保证对于组件库的`单实例`。可是当对外使用发布后，因为`pnpm的依赖严格隔离`的会导致使用者拥有一个vue实例，组件库内又拥有一个vue实例，从而就造成了多实例的问题。\\n\\n我们要解决的话，就是保证唯一实例，有很多方案，一种是在主应用的打包配置内强制指定核心包。\\n\\n但其实我们应该从`组件库层面`就解决这个问题，`所以看文档`。\\n<img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f50ee70a12ed4391b19a57b558fb54d6~tplv-k3u1fbpfcp-zoom-1.image\\\" alt=\\\"\\\" width=\\\"100%\\\" />\\n在npm.rc内加入如下配置，强制提升vue到全局，在发包的时候存在`peerDependencies`,所以不管是主应用还是组件库都会去找上层的vue,就可以保证唯一实例。\\n```js\\npublic-hoist-pattern[]=vue\\npublic-hoist-pattern[]=*types*\\npublic-hoist-pattern[]=*eslint*\\npublic-hoist-pattern[]=@prettier/plugin-*\\npublic-hoist-pattern[]=*prettier-plugin-*\\n```\\n\\n## turborepo\\n还是先讲讲理论：\\n\\n这是什么东西？同样是以上面的厂房为例，每一个厂房的有`不同流水线，他们负责加工不同的零件`，可能你的B零件需要用到A零件，`turborepo`就是一个出色的管理者,它井井有条的帮你管理的厂区。\\n\\n对应到`menorepo仓库`中，就是各种包的打包构建和shell命令，在以往我们需要去`一个个包的命令去执行`或者去使用一些`自动化工具类glup`之类的，但是`turborepo`的出现，就相当于拥有了一个`大管家`，它会自动以一个优解帮助你处理整套上下游的依赖，以及还能通过缓存加快你下一次的构建速度。\\n\\n[文档](https://turbo.build/repo/docs)。\\n### 基础\\n`globalEnv`： 为了在不同环境下生成不同的哈希值，它会被加到哈希算法中。\\n\\n\\n`pipeline`：\\n\\n以我们现在的组件库为例\\n它的每个对象的`健名`都是为可执行命令的名称。\\n\\n我们看到`pipeline`的第一个`build`，它的意思是`pnpm turbo run build`会找到所有包中有`build`命令（scripts里）的开始执行(`^`build的意思是会按照一个拓扑顺序执行依赖)，然后开始执行`types`命令，执行完所有里选定的包的脚本后，才算执行完成。\\n\\n接下来我们看`types`，他会先找到有`types命令`的包，去执行`build`和`types`。\\n\\n这块其实最好的理解方式是去实操，文档和文章里讲的东西实在很有限。\\n\\n```json\\n{\\n  \\\"$schema\\\": \\\"https://turborepo.org/schema.json\\\",\\n  \\\"pipeline\\\": {\\n    \\\"build\\\": {\\n      \\\"dependsOn\\\": [\\\"^build\\\", \\\"types\\\"],\\n      \\\"outputs\\\": [\\\"dist/**\\\"]\\n    },\\n    \\\"types\\\": {\\n      \\\"dependsOn\\\": [\\\"^build\\\"],\\n      \\\"outputs\\\": [\\\"dist/**\\\"]\\n    },\\n    \\\"test\\\": {\\n      \\\"dependsOn\\\": [\\\"^build\\\"],\\n      \\\"outputs\\\": []\\n    },\\n    \\\"lint\\\": {\\n      \\\"outputs\\\": []\\n    },\\n    \\\"dev\\\": {\\n      \\\"dependsOn\\\": [\\\"^build\\\"],\\n      \\\"cache\\\": false\\n    },\\n    \\\"docs:build\\\": {\\n      \\\"dependsOn\\\": [\\\"^build\\\"],\\n      \\\"outputs\\\": [\\\"dist/**\\\"]\\n    }\\n  }\\n}\\n```\\n\\n```js\\n// 和前面介绍的pnpm的filter大致一致但有些遍历的语法\\npnpm turbo --filter xxx <task>\\n// task就是指的配置项里pipeline管道所配置的任务\\npnpm turbo <task>\\n```\\n\\n### 上下游依赖\\n假设我们有A,B,C,D这样的四个依赖，他们是一个`线性排列的构建顺序`。\\n\\n`A` -> `B` -> `C/D`\\n\\n`假设我们要只构建B`,这就是纯净构建。\\n```js\\npnpm turbo --filter B build\\n```\\n`假设我们要构建AB`,多加了`...`在`filter`之后，表示会定点构建，带动他的`上游也就是A也会构建`，`而C不会构建`，而这种带动上游的定点构建的方式是我们用得比较多的。\\n```js\\npnpm turbo --filter B...  build\\n```\\n而反之, `...`表示`B`的上游`C和D`也会被构建，也就是`ABCD`都会构建。\\n```js\\npnpm turbo --filter ...B build\\n```\\n### 缓存与强制构建\\n#### 1、缓存提升\\n指定`.turbo缓存到cwd`，方便操作,可以看到根据文件内容生成了`哈希值文件`，当下一次文件改动的时候，将通过`哈希值`进行对比，来确定`构建`的内容。\\n```js\\n// 缓存提升\\nturbo run build --cache-dir=\\\".turbo\\\"\\n```\\n<img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/92c5b89e5d27491f94725e6c189eb9a9~tplv-k3u1fbpfcp-zoom-1.image\\\" alt=\\\"\\\" width=\\\"100%\\\" />\\n\\n#### 2、强制构建\\n`--force` 强制\\n\\n`-no-cache`无缓存构建\\n\\n`无视 cache 构建需要带上 --force 参数`强制构建\\n\\n```js\\n// 构建不需要缓存\\npnpm turbo run build --no-cache\\n// 无缓存强制构建\\npnpm turbo run build --no-cache --force\\n```\\n\\n#### 3、效果\\n<img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c690ad4136134080ae6d3c6412d84ee0~tplv-k3u1fbpfcp-zoom-1.image\\\" alt=\\\"\\\" width=\\\"100%\\\" />\\n<img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f94b81ae098c42e78f26edc696c5ec2f~tplv-k3u1fbpfcp-zoom-1.image\\\" alt=\\\"\\\" width=\\\"100%\\\" />\\n\\n实战才是最好的导师,`tuborepo`还有更多优秀的内容，比如`远程缓存，持续CI/CD`，但这些我都想放在后期专门讲一篇CI/CD也就是 `github bot, github action，changeset，turborepo联动`。\\n\\n## changeset\\n`理论知识`：\\n当前我们的厂区已经有两个管理者`turborepo`和`pnpm`负责整个厂房的运转和构建，我们还需要一个产品发布的管理者，也就是`changeset`.\\n\\n`简单实操`：\\n执行`changeset`选择你要发布的包（注意一个问题在这之前，你需要把你不发布的包设为私有在`package.json`中设置为私有`\\\"private\\\": true,`），然后依据[sem](https://semver.org/lang/zh-CN/)规范，选择你的`MAJOR | MINOR | PATCH`和填写你的注释内容。\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6493895efc524160a4a20c1dd9c87cc4~tplv-k3u1fbpfcp-watermark.image?)\\n\\n紧接着就执行`changeset version`，去消耗掉上一步生成的`changeset文件`，生成`changelog文件`。\\n\\n最后执行`changeset publish`就会将你选择的包根据版本发布（这个过程它也会帮你检测远程的包的版本等一系列内置操作）。\\n\\n同样是最好的地方，就是changeset，对github工作流和CI/CD的支持。\\n\\n## 自定义CLI\\n因为`turborepo`的出现，这块真的太爽了，自定义命令的`CLI+Turborepo`查找命令这种模式。\\n\\n`pnpm fd gen`会同时为开发者生成`docs文档和组件模板`(里面包含打包的各种配置和packagejson)，让小伙伴们就可以更专注于开发组件的逻辑而不是去考虑更多的工程化的问题，就像是这样。\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b7bbea8e7074ba2963f99efedda11a5~tplv-k3u1fbpfcp-watermark.image?)\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/745abe523d12431ca899a735ddfdd845~tplv-k3u1fbpfcp-watermark.image?)\\n\\n`pnpm fd del <componentName>` 删除组件和文档内容。\\n\\n\\n后续的更多的构建打包基础命令，也会是这种模式。\\n\\n# 单组件打包\\n在每个组件内都会有一个由脚手架生成 `vite.config.ts` 文件，现在是通过这个文件处理打包内容，后续`vitest`单测也是在这个文件夹里。\\n```typescript\\n// vite.config.ts\\nimport { resolve } from 'path';\\nimport { defineConfig } from 'vite';\\nimport vue from '@vitejs/plugin-vue';\\nimport vueJsx from '@vitejs/plugin-vue-jsx';\\nimport vueTypes from 'vite-plugin-vue-type-imports';\\n\\nimport DefineOptions from 'unplugin-vue-define-options/vite';\\n\\n// https://vitejs.dev/config/\\nexport default defineConfig({\\n  resolve: {\\n    extensions: ['.ts', '.vue']\\n  },\\n  build: {\\n    minify: 'esbuild',\\n    emptyOutDir: false,\\n    lib: {\\n      formats: ['es', 'cjs', 'iife'],\\n      entry: resolve(__dirname, 'src/index.ts'),\\n      name: 'FdButton'\\n    },\\n    rollupOptions: {\\n      external: ['vue'],\\n      output: {\\n        dir: './dist',\\n        globals: {\\n          vue: 'Vue',\\n          '@fishdesign-ui/button': 'FdButton'\\n        }\\n      }\\n    }\\n  },\\n  plugins: [vue(), vueJsx(), vueTypes(), DefineOptions()]\\n});\\n```\\n还有一个生成`d.ts`的`tsconfig.json`，他的一些默认选项继承自跟目录，这里留下了一些可以自定义的选项，其实大伙想问为啥`d.ts`要单独用`tsc`打包，因为市面的插件都很慢。\\n\\n```typescript\\n{\\n  \\\"compilerOptions\\\": {\\n    \\\"preserveSymlinks\\\": true, //软连接解析\\n    \\\"outDir\\\": \\\"./tmp\\\",\\n    \\\"rootDir\\\": \\\"./src\\\",\\n    \\\"target\\\": \\\"es2015\\\",\\n    \\\"composite\\\": false,\\n    \\\"incremental\\\": false, //增量编译,开启后会生成一个文件对比\\n    \\\"skipLibCheck\\\": true, //跳过默认库声明文件的类型检查\\n    \\\"skipDefaultLibCheck\\\": true,\\n    \\\"declarationDir\\\": \\\"./dist\\\"\\n  },\\n  \\\"extends\\\": \\\"../../tsconfig.json\\\",\\n  \\\"include\\\": [\\\"./src\\\", \\\"typings/**/*.ts\\\"],\\n  \\\"exclude\\\": [\\\"node_modules\\\", \\\"dist\\\"]\\n}\\n\\n```\\n关于生成的package.json，大家可以自己去看看资料。\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1db24f5309814567b4740422069095ff~tplv-k3u1fbpfcp-watermark.image?)\\n\\n# 样式系统\\n这块整个的思路分为两部分，一部分是模版(其实vue3也可以写函数式组件了，写那种`jsx函数式的组件会在样式系统`上表现得更好)，一部分是scss文件。\\n\\n`模版`：\\n在模版上我们通过函数去生成`class名`，实现`bem的规范`。\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f087722509d84d98b9dac558fdaeff68~tplv-k3u1fbpfcp-watermark.image?)\\n\\n`样式表`：\\n样式表内我们通过，混入和样式函数完成一个`间距，颜色，宽度，长度`等的统一\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/49f10172884d4857be9ceaf096502912~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n# 招人啦\\n组件库的宗旨是：为摸鱼而生！\\n\\n目的：主要是一方面在为我们开发减负的同时，也能真正意义上的提升自己水平，这里有这几个方向的内容：`工程化，Vue3组件设计开发，样式体操，类型体操，git, 团队协作，CI/CD，，IDE`\\n\\n然后组件库因为刚刚起步，`样式系统和类型系统`小伙伴正在开发中，还有很多版块等待开发！\\n\\n欢迎小伙伴们的加入，积极性强的，想锻炼自己的小伙伴,可以私聊我，现在已经有一部分小伙伴啦，来就一定能学到东西，不是KPI项目也不是什么广告也没有商业性质，仅仅只是为爱发电的一群人罢了\\n\\n\\n\\n\\n",
        "tags": [
            "前端",
            "JavaScript",
            "Vue.js"
        ]
    },
    {
        "article_id": "7195084958866604069",
        "cover_image": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ad7061999b0435ab3807d014f589d4c~tplv-k3u1fbpfcp-watermark.image?",
        "title": "Java基础-构造方法",
        "brief": "构造方法 在初始化对象的时候，前面我们都是直接对每个变量赋值，有一个更简单的方式对实例变量赋初值，就是构造方法，我们先看下代码。在Point类定义中增加如下代码： public Point(){   ",
        "user_name": "爱敲代码的小杨同学",
        "view_count": 1136,
        "collect_count": 0,
        "comment_count": 0,
        "avatar": "https://p3-passport.byteacctimg.com/img/mosaic-legacy/3797/2889309425~300x300.image",
        "category": "后端",
        "content": "构造方法\\n\\n在初始化对象的时候，前面我们都是直接对每个变量赋值，有一个更简单的方式对实例变量赋初值，就是构造方法，我们先看下代码。在Point类定义中增加如下代码：\\n\\npublic Point(){\\n\\n    this(0,0);\\n\\n}\\n\\npublic Point(int x, int y){\\n\\n    this.x = x;\\n\\n    this.y = y;\\n\\n}\\n\\n这两个就是构造方法，构造方法可以有多个。不同于一般方法，构造方法有一些特殊的地方：\\n\\n1）名称是固定的，与类名相同。这也容易理解，靠这个用户和Java系统就都能容易地知道哪些是构造方法。\\n\\n2）没有返回值，也不能有返回值。构造方法隐含的返回值就是实例本身。\\n\\n与普通方法一样，构造方法也可以重载。第二个构造方法是比较容易理解的，使用this对实例变量赋值。\\n\\n我们解释下第一个构造方法，this（0，0）的意思是调用第二个构造方法，并传递参数“0，0”，我们前面解释说this表示当前实例，可以通过this访问实例变量，这是this的第二个用法，用于在构造方法中调用其他构造方法。\\n\\n这个this调用必须放在第一行，这个规定也是为了避免误操作。构造方法是用于初始化对象的，如果要调用别的构造方法，先调别的，然后根据情况自己再做调整，而如果自己先初始化了一部分，再调别的，自己的修改可能就被覆盖了。\\n\\n这个例子中，不带参数的构造方法通过this（0，0）又调用了第二个构造方法，这个调用是多余的，因为x和y的默认值就是0，不需要再单独赋值，我们这里主要是演示其语法。\\n\\n我们来看下如何使用构造方法，代码如下：\\n\\nPoint p = new Point(2,3);\\n\\n这个调用就可以将实例变量x和y的值设为2和3。前面我们介绍new Point（）的时候说，它至少做了两件事，一件是分配内存，另一件是给实例变量设置默认值，这里我们需要加上一件事，就是调用构造方法。调用构造方法是new操作的一部分。\\n\\n通过构造方法，可以更为简洁地对实例变量进行赋值。关于构造方法，下面我们讨论两个细节概念：一个是默认构造方法；另一个是私有构造方法。\\n\\n1.默认构造方法\\n\\n每个类都至少要有一个构造方法，在通过new创建对象的过程中会被调用。但构造方法如果没什么操作要做，可以省略。Java编译器会自动生成一个默认构造方法，也没有具体操作。但一旦定义了构造方法，Java就不会再自动生成默认的，具体什么意思呢？在这个例子中，如果我们只定义了第二个构造方法（带参数的），则下面语句：\\n\\nPoint p = new Point();\\n\\n就会报错，因为找不到不带参数的构造方法。\\n\\n为什么Java有时候自动生成，有时候不生成呢？在没有定义任何构造方法的时候，Java认为用户不需要，所以就生成一个空的以被new过程调用；定义了构造方法的时候，Java认为用户知道自己在干什么，认为用户是有意不想要不带参数的构造方法，所以不会自动生成。\\n\\n2.私有构造方法\\n\\n构造方法可以是私有方法，即修饰符可以为private，为什么需要私有构造方法呢？大致可能有这么几种场景：\\n\\n1）不能创建类的实例，类只能被静态访问，如Math和Arrays类，它们的构造方法就是私有的。\\n\\n2）能创建类的实例，但只能被类的静态方法调用。有一种常见的场景：类的对象有但是只能有一个，即单例（单个实例）。在这种场景中，对象是通过静态方法获取的，而静态方法调用私有构造方法创建一个对象，如果对象已经创建过了，就重用这个对象。\\n\\n3）只是用来被其他多个构造方法调用，用于减少重复代码。",
        "tags": [
            "后端",
            "Java",
            "程序员"
        ]
    },
    {
        "article_id": "7195112524520357943",
        "cover_image": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c6706180698e445c9f0b2cfe8976363f~tplv-k3u1fbpfcp-watermark.image?",
        "title": "Tongsuo｜铜锁再获 IOS 和 Linux 平台商用密码认证资质",
        "brief": "2023 兔年伊始，铜锁再次获得了两个商用密码认证证书，即《BabaSSL IOS 端软件密码模块》和《应用安全软件密码模块（Linux 版）》，分别对应 IOS 平台和 Linux 平台。",
        "user_name": "蚂蚁集团分布式架构",
        "view_count": 599,
        "collect_count": 0,
        "comment_count": 0,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/73cdd98b2f31a67067bf704358b70973~300x300.image",
        "category": "iOS",
        "content": "![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a7a63358c344e85b63e9ef7e1a90308~tplv-k3u1fbpfcp-zoom-1.image)  \\n\\n\\n  \\n\\n\\n文｜杨洋（花名：凯申 )\\n\\n铜锁开源密码库创始人蚂蚁集团高级技术专家  \\n\\n\\n文｜张成龙（花名：刻一)\\n\\n蚂蚁集团技术专家  \\n  \\n\\n\\n**本文 1657 字 阅读 5 分钟**\\n\\n***\\n点击查看原文《[Tongsuo｜铜锁再获 IOS 和 Linux 平台商用密码认证资质](https://mp.weixin.qq.com/s/9zzK4ZR9OEw4e-wskkGD9w)》\\n***\\n\\n2022 年底，我们借助文章[《Tongsuo | 全球首个商用密码产品认证的密码学开源项目》](http://mp.weixin.qq.com/s?__biz=MzUzMzU5Mjc1Nw==&mid=2247517434&idx=1&sn=aebee0bccbb84744cd43778e7548d051&chksm=faa36b20cdd4e236de98aa79a3302e636f0121e9965e3ed078756d5e9ea563c8a03d974d56c1&scene=21#wechat_redirect)，向外界公布铜锁密码库获得了软件密码模块安全一级的资质，也就是铜锁的 Android 平台一级资质。\\n\\n  \\n\\n\\n2023 兔年伊始，铜锁再次获得了两个商用密码认证证书，即《BabaSSL IOS 端软件密码模块》和《应用安全软件密码模块（Linux 版）》，分别对应 IOS 平台和 Linux 平台，同先前获得的 Android 平台资质一样，此次获得的两个国密资质也无偿开放给铜锁的用户使用。\\n\\n\\n自此，铜锁开源密码库集齐了 Android、IOS 两个移动客户端和更常用的 Linux 平台的商用密码/国密资质，用户可以集成铜锁密码模块于自己的产品和系统中，实现对商用密码技术使用的合规。\\n\\n![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d0f62197b4514c07aa03b275a06aa62c~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n  \\n\\n\\n全部资质 PDF 和高清图片版点击最下方“阅读原文”或输入下方链接即可下载。\\n\\n*https://www.yuque.com/tsdoc/misc/st247r05s8b5dtct*\\n\\n***\\n\\n**铜锁密码库的资质情况说明**\\n\\n\\n截止 2023 年 1 月底，铜锁密码库一共取得了国家密码管理局商用密码检测中心颁发的三个商用密码产品认证证书，也即俗称的国密资质。这三个资质均属于 GM/T 0028《密码模块安全技术要求》安全一级。\\n\\n\\n**BabaSSL 移动端软件密码模块**\\n\\n适用平台：Android\\n\\n产品名称和版本号：ANTGROUP-BabaSSL-MC 8.2.1\\n\\n持有单位：蚂蚁科技集团股份有限公司\\n\\n颁发日期：2022.11.30\\n\\n有效期至：2027.11.29\\n***\\n\\n**BabaSSL IOS 端软件密码模块**\\n\\n适用平台：IOS\\n\\n产品名称和版本号：ANTGROUP-BabaSSL-MIOSC 8.3.0\\n\\n持有单位：蚂蚁科技集团股份有限公司\\n\\n颁发日期：2023.1.17\\n\\n有效期至：2028.1.16\\n\\n***\\n\\n**应用安全软件密码模块（Linux 版）**  \\n\\n\\n适用平台：Linux\\n\\n产品名称和版本号：AS-TSCM 8.3.1\\n\\n持有单位：蚂蚁科技集团股份有限公司\\n\\n颁发日期：2023.1.16\\n\\n有效期至：2028.1.15\\n\\n\\n关于以上国密资质对应的铜锁产品开源代码的编译和使用，请加入铜锁用户交流群咨询，钉钉搜索群号：**44810299**。\\n\\n***\\n\\n**什么是铜锁/Tongsuo？**\\n\\n铜锁（Tongsuo）是一个提供现代密码学算法和安全通信协议的开源基础密码库，为存储、网络、密钥管理、隐私计算等诸多业务场景提供底层的密码学基础能力，实现数据在传输、使用、存储等过程中的私密性、完整性和可认证性，为数据生命周期中的隐私和安全提供保护能力。  \\n\\n铜锁诞生于蚂蚁集团并广泛的应用在蚂蚁集团内部以及外部的多种业务当中，提供了 TLS、数据存储、国密合规等关键的密码学相关能力，确保了各项业务平稳、安全、合规的运行。\\n\\n\\n铜锁同时还在前沿密码学领域进行了支持，包括隐私计算场景下所需的多种半同态加密算法以及为了应对量子计算而产生的后量子密码学算法等。\\n\\n![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bcd3c8d51c904038a3979cbc52fabc95~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n\\n铜锁做为国内稀缺的密码学开源项目，填补了相关领域产品的空白，是我国建设国产密码学开源大生态、解决密码学技术和产品供应“卡脖子”问题、发展前沿密码学技术的关键一环。同时基于支付宝海量的用户场景，其性能和稳定性也达到了互联网生产级别。  \\n\\n\\n\\n铜锁开源项目的前身是 BabaSSL 开源密码库。2022 年， BabaSSL 更名为铜锁，详见：\\n\\n《[你好，我的新名字叫“铜锁/Tongsuo”](http://mp.weixin.qq.com/s?__biz=MzUzMzU5Mjc1Nw==&mid=2247513818&idx=1&sn=e0884180a5401d4972bd9a8d3ed150be&chksm=faa35900cdd4d01669f732eb662e7c644caa663f6ae41dd3e3f8b28e77d72763e34c1935fe0d&scene=21#wechat_redirect)》。\\n\\n\\n铜锁项目于 2022 年通过开放原子开源基金会技术委员会 TOC 的答辩，目前正处于向开放原子开源基金会的捐赠流程中。\\n\\n\\n钉钉用户交流群群号：44810299\\n\\n钉钉交流群二维码👇\\n\\n\\n![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e34e69f87534c0b939792df6f7b510b~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n\\n**了解更多...**\\n\\n**铜锁/Tongsuo Star 一下✨：**  \\n*https://github.com/Tongsuo-Project/Tongsuo*",
        "tags": [
            "Android",
            "iOS",
            "Linux"
        ]
    },
    {
        "article_id": "7180977411633184823",
        "cover_image": "",
        "title": "2022, 6年技术路, 后疫情时代复盘",
        "brief": "又到了每年一度的复盘时间。 转眼一想, 做技术已经 6 年了。 说实话，有点疲惫了。今年整个互联网行业都不好过, 加上疫情的反复不断, 从耳边流出了很多裁员的信息, 股市也比较低迷, 身处底层的我们只",
        "user_name": "徐小夕",
        "view_count": 2218,
        "collect_count": 7,
        "comment_count": 4,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/d08df4df3fe80db668014b4b815390a5~300x300.image",
        "category": "前端",
        "content": "\\n> **专注** - **聚焦** - **反思** - **解决方案**\\n\\n又到了每年一度的复盘时间。\\n\\n转眼一想, 做技术已经 6 年了。\\n\\n说实话，有点疲惫了。今年整个互联网行业都不好过, 加上疫情的反复不断, 从耳边流出了很多裁员的信息, 股市也比较低迷, 身处底层的我们只能夹缝生存。\\n\\n但是, 我又是个信奉自由的人, 不, 严格意义上来说是个信奉自由的**程序猿**。所以**追求价值**才是我最关注的点, 每年总得做点有价值的事, 生活才算过的有价值。\\n\\n所以接下来还是要复盘一下这一整年的价值和思考感悟。\\n\\n### 工作上\\n\\n一年时间, 在工作上, 感觉自己还是那个兢兢业业的自己, 每天远程办公 8-10 小时, 基本 12 小时在线, 喜欢有挑战的任务, 积极解决工作上的问题。\\n\\n从**组件化**到**可视化**, 再到**原生实现可视化**, 在技术上经历了一定程度的蜕变, 也具备了百度搜索不到的解决问题的能力。\\n\\n这里分享几个工作的经验和技巧:\\n\\n1. 情绪永远不要过于激动, 即使是你没错, 也要理智应对\\n2. 效率优先, 永远不要觉得上班摸鱼能割公司韭菜, 这样只会让自己丧失竞争力和格局感\\n3. 有问题要主动沟通, 但不要过渡沟通\\n4. 尽量让自己远离无效加班的状态\\n5. 持续学习, 定期复盘\\n\\n以上是今年分享的一些提高职场竞争力的方法, 各位可以参考一下。\\n\\n今年也有很多朋友和我分享了他们的被裁经历, 消化了他们的部分焦虑, 但是我要说的是, 裁员迟早会来, 不如好好思考一下如何**利用这段时间, 提高自我的价值, 好好休养生息**。\\n\\n我曾经也经历过职场中的大起大落, 经历过裁员, 但是我觉得始终**把工作当成自己摆脱枯燥生活的一种方式, 就好了**。毕竟赚钱的方式有很多种, 顺从自己内心就好了。\\n\\n**做程序**是一件辛苦且不易的事情, 且行切珍惜, **工作再忙, 也要好好享受生活**。\\n\\n切记我们老祖宗的养生文化: **日出而作, 日落而息**。所以今年之后, 建议大家都制定一个健身计划~\\n\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/19c655f7f87045939d63ee1144b84a63~tplv-k3u1fbpfcp-watermark.image?)\\n\\n### 关于开源和产品\\n\\n在接触技术的第二个年头, 我就迷上了做开源, 一方面可以提升自己解决问题的能力和效率, 另一方面通过和一些技术爱好者的交流, 也锻炼了我对程序设计的全面性思考。几乎每年都会利用业余时间做一些实用的开源项目, 今年也不例外:\\n\\n#### react-slider-vertify\\n\\n基于react实现的滑动验证码组件。\\n\\ngithub: https://github.com/MrXujiang/react-slider-vertify\\n\\n#### react-cropper-pro\\n基于react开发的轻量级图片上传裁切组件。\\n\\ngithub: https://github.com/MrXujiang/react-cropper-pro\\n\\n#### xijs\\n\\n一款面向复杂业务场景的 js 类库。\\n\\ngithub: https://github.com/MrXujiang/xijs\\n\\n#### vue-slider-vertify\\n\\n基于Vue3的滑动验证码组件。\\n\\ngithub: https://github.com/MrXujiang/vue-slider-vertify\\n\\n#### blink\\n\\n一款自定义的生成故障艺术动画的组件库。\\n\\ngithub: https://github.com/MrXujiang/blink\\n\\n\\n同时, 对于前几年做的几个开源项目和产品, 我也在持续维护中, 比如大家最熟悉的 **H5-Dooring**, **V6.Dooring** 等, 后续也会更加站在产品设计的角度做一些高价值的产品, 来回馈这6年的技术生涯。\\n\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc153500e768466a8fd2a3798d99ffed~tplv-k3u1fbpfcp-watermark.image?)\\n\\n这里也分享一下我做开源或者产品的心得:\\n\\n1. 做产品或者开源, 需要有绝对的执行力, 没有执行力的团队是做不出好产品的\\n2. 永远只做小而精的产品或者开源项目\\n3. 不要沉迷于技术上的酷炫, 要从实际需求出发, 直击用户痛点\\n4. 做开源或者产品要有持续性, 坚持不了1年的开源或者产品, 是不长久的\\n5. 不要一开始就想着变现, 先用爱发电\\n\\n我之前做了一款开源产品, 坚持迭代了3年多, 才被市场慢慢认可。\\n\\n所以, **不卑不亢, 坚持去浮, 也许才是做产品或者开源最好的态度**。\\n\\n### 技术分享\\n\\n今年的技术分享比较贫瘠, 2021年写了100篇, 今年写了10篇, 但值得庆幸的是文章仍然都是慢满满的干货, 不水文, 这也许是作为技术人的我最后的倔强。\\n\\n感兴趣的朋友可以参考我往期的技术分享文章, 包括了很多组件化, 可视化, 低代码相关的技术好分享。\\n\\n那么今年为什么写这么少的文章呢? 这里和大家解释一下, 我都在**认真工作**。不管是公司上的工作, 还是开源上的任务。 \\n\\n成年人的烦恼有时候就是这么简单, 又枯燥。\\n\\n不过 2023年, 目标输出 **12篇** 干货满满的文章, 每月一篇, 绝不打烊。\\n\\n\\n### 疫情之下的生活\\n\\n他们都说疫情之下没有生活, 但是我觉得, 疫情之下不但没有生活, 还没有工作。\\n\\n哈哈, 当然是个玩笑话, 疫情确实打乱了很多人的出行计划, 新疆的3个月封锁, 让很多人成了自由职业者, 其他地方也打响了防疫的“保卫战”, 虽然最后都被“生活”妥协了, “阳”了你我他。\\n\\n但是, 这些都不是阻止我们不学习, 不锻炼身体的理由, 人为运动生, 2023年好好运动来增强抵抗力吧, 毕竟, 免疫系统也不是吃“素”的。\\n\\n\\n### 2023, 勇往直前\\n\\n除了上面说的学习, 运动之外, 2023年, 更多的还是学会聚焦, 专注于做小而美的事情, 让值得珍惜的日子, 彰显价值。\\n\\n2023, **我们**不见不散,\\n\\n2023, **趣谈前端**, **我**, 和**你们**不见不散。\\n\\n",
        "tags": [
            "前端",
            "开源",
            "GitHub"
        ]
    },
    {
        "article_id": "7127295203177676837",
        "cover_image": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cf3d180c6f14714befa6a842c101044~tplv-k3u1fbpfcp-watermark.image?",
        "title": "pnpm 是凭什么对 npm 和 yarn 降维打击的",
        "brief": "大家最近是不是经常听到 pnpm，我也一样。今天研究了一下它的机制，确实厉害，对 yarn 和 npm 可以说是降维打击。 那具体好在哪里呢？ 我们一起来看一下。 我们按照包管理工具的发展历史，从 n",
        "user_name": "zxg_神说要有光",
        "view_count": 65455,
        "collect_count": 1203,
        "comment_count": 250,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/4e9e751e2b32fb8afbbf559a296ccbf2~300x300.image",
        "category": "前端",
        "content": "大家最近是不是经常听到 pnpm，我也一样。今天研究了一下它的机制，确实厉害，对 yarn 和 npm 可以说是降维打击。\\n\\n那具体好在哪里呢？ 我们一起来看一下。\\n\\n我们按照包管理工具的发展历史，从 npm2 开始讲起：\\n\\n## npm2\\n\\n用 node 版本管理工具把 node 版本降到 4，那 npm 版本就是 2.x 了。\\n\\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b4eef39cebc949859ff12c8d51e747e0~tplv-k3u1fbpfcp-watermark.image?)\\n\\n然后找个目录，执行下 npm init -y，快速创建个 package.json。\\n\\n然后执行 npm install express，那么 express 包和它的依赖都会被下载下来：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8ad0f0e13d1404c93089bde5ae08112~tplv-k3u1fbpfcp-watermark.image?)\\n\\n展开 express，它也有 node_modules：\\n\\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ada5f744720c4cb7b4d846ee2d1bf81b~tplv-k3u1fbpfcp-watermark.image?)\\n\\n再展开几层，每个依赖都有自己的 node_modules：\\n\\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ff1d1c0cab14b65b905fe1e74db59a1~tplv-k3u1fbpfcp-watermark.image?)\\n\\n也就是说 npm2 的 node_modules 是嵌套的。\\n\\n这很正常呀？有什么不对么？\\n\\n这样其实是有问题的，多个包之间难免会有公共的依赖，这样嵌套的话，同样的依赖会复制很多次，会占据比较大的磁盘空间。\\n\\n这个还不是最大的问题，致命问题是 windows 的文件路径最长是 260 多个字符，这样嵌套是会超过 windows 路径的长度限制的。\\n\\n当时 npm 还没解决，社区就出来新的解决方案了，就是 yarn：\\n\\n## yarn\\n\\nyarn 是怎么解决依赖重复很多次，嵌套路径过长的问题的呢？\\n\\n铺平。所有的依赖不再一层层嵌套了，而是全部在同一层，这样也就没有依赖重复多次的问题了，也就没有路径过长的问题了。\\n\\n我们把 node_modules 删了，用 yarn 再重新安装下，执行 yarn add express：\\n\\n这时候 node_modules 就是这样了：\\n\\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71906633d465460183c3eb880391bf2e~tplv-k3u1fbpfcp-watermark.image?)\\n\\n全部铺平在了一层，展开下面的包大部分是没有二层 node_modules 的：\\n\\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52e6392c33f04f7a949c07fa7d65d358~tplv-k3u1fbpfcp-watermark.image?)\\n\\n当然也有的包还是有 node_modules 的，比如这样：\\n\\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd0a3971237445aea60f4de1c13250a7~tplv-k3u1fbpfcp-watermark.image?)\\n\\n为什么还有嵌套呢？\\n\\n因为一个包是可能有多个版本的，提升只能提升一个，所以后面再遇到相同包的不同版本，依然还是用嵌套的方式。\\n\\nnpm 后来升级到 3 之后，也是采用这种铺平的方案了，和 yarn 很类似：\\n\\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/79f93e2855514117bb73de52284d86fa~tplv-k3u1fbpfcp-watermark.image?)\\n\\n当然，yarn 还实现了 yarn.lock 来锁定依赖版本的功能，不过这个 npm 也实现了。\\n\\nyarn 和 npm 都采用了铺平的方案，这种方案就没有问题了么？\\n\\n并不是，扁平化的方案也有相应的问题。\\n\\n最主要的一个问题是幽灵依赖，也就是你明明没有声明在 dependencies 里的依赖，但在代码里却可以 require 进来。\\n\\n这个也很容易理解，因为都铺平了嘛，那依赖的依赖也是可以找到的。\\n\\n但是这样是有隐患的，因为没有显式依赖，万一有一天别的包不依赖这个包了，那你的代码也就不能跑了，因为你依赖这个包，但是现在不会被安装了。\\n\\n这就是幽灵依赖的问题。\\n\\n而且还有一个问题，就是上面提到的依赖包有多个版本的时候，只会提升一个，那其余版本的包不还是复制了很多次么，依然有浪费磁盘空间的问题。\\n\\n那社区有没有解决这俩问题的思路呢？\\n\\n当然有，这不是 pnpm 就出来了嘛。\\n\\n那 pnpm 是怎么解决这俩问题的呢？\\n\\n## pnpm\\n\\n回想下 npm3 和 yarn 为什么要做 node_modules 扁平化？不就是因为同样的依赖会复制多次，并且路径过长在 windows 下有问题么？\\n\\n那如果不复制呢，比如通过 link。\\n\\n首先介绍下 link，也就是软硬连接，这是操作系统提供的机制，硬连接就是同一个文件的不同引用，而软链接是新建一个文件，文件内容指向另一个路径。当然，这俩链接使用起来是差不多的。\\n\\n如果不复制文件，只在全局仓库保存一份 npm 包的内容，其余的地方都 link 过去呢？\\n\\n这样不会有复制多次的磁盘空间浪费，而且也不会有路径过长的问题。因为路径过长的限制本质上是不能有太深的目录层级，现在都是各个位置的目录的 link，并不是同一个目录，所以也不会有长度限制。\\n\\n没错，pnpm 就是通过这种思路来实现的。\\n\\n再把 node_modules 删掉，然后用 pnpm 重新装一遍，执行 pnpm install。\\n\\n你会发现它打印了这样一句话：\\n\\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b2d51d9a17743a4bafc42f1bbfd310c~tplv-k3u1fbpfcp-watermark.image?)\\n\\n包是从全局 store 硬连接到虚拟 store 的，这里的虚拟 store 就是 node_modules/.pnpm。\\n\\n我们打开 node_modules 看一下：\\n\\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b4dc807ca6e4ae7a955c8dd6385cb46~tplv-k3u1fbpfcp-watermark.image?)\\n\\n确实不是扁平化的了，依赖了 express，那 node_modules 下就只有 express，没有幽灵依赖。\\n\\n展开 .pnpm 看一下：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/65a69589bd534fdd97bdbeb6e3e1024c~tplv-k3u1fbpfcp-watermark.image?)\\n\\n所有的依赖都在这里铺平了，都是从全局 store 硬连接过来的，然后包和包之间的依赖关系是通过软链接组织的。\\n\\n比如 .pnpm 下的 expresss，这些都是软链接，\\n\\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c50d8dc8a2a4466ba9e5eccd5c15614e~tplv-k3u1fbpfcp-watermark.image?)\\n\\n也就是说，所有的依赖都是从全局 store 硬连接到了 node_modules/.pnpm 下，然后之间通过软链接来相互依赖。\\n\\n官方给了一张原理图，配合着看一下就明白了：\\n\\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/326a2090786e4d16b2d6fce25e876680~tplv-k3u1fbpfcp-watermark.image?)\\n\\n这就是 pnpm 的实现原理。\\n\\n那么回过头来看一下，pnpm 为什么优秀呢？\\n\\n首先，最大的优点是节省磁盘空间呀，一个包全局只保存一份，剩下的都是软硬连接，这得节省多少磁盘空间呀。\\n\\n其次就是快，因为通过链接的方式而不是复制，自然会快。\\n\\n这也是它所标榜的优点：\\n\\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ba8815b36b3498ea4a3c2248d192bd6~tplv-k3u1fbpfcp-watermark.image?)\\n\\n相比 npm2 的优点就是不会进行同样依赖的多次复制。\\n\\n相比 yarn 和 npm3+ 呢，那就是没有幽灵依赖，也不会有没有被提升的依赖依然复制多份的问题。\\n\\n这就已经足够优秀了，对 yarn 和 npm 可以说是降维打击。\\n\\n## 总结\\n\\npnpm 最近经常会听到，可以说是爆火。本文我们梳理了下它爆火的原因：\\n\\nnpm2 是通过嵌套的方式管理 node_modules 的，会有同样的依赖复制多次的问题。\\n\\nnpm3+ 和 yarn 是通过铺平的扁平化的方式来管理 node_modules，解决了嵌套方式的部分问题，但是引入了幽灵依赖的问题，并且同名的包只会提升一个版本的，其余的版本依然会复制多次。\\n\\npnpm 则是用了另一种方式，不再是复制了，而是都从全局 store 硬连接到 node_modules/.pnpm，然后之间通过软链接来组织依赖关系。\\n\\n这样不但节省磁盘空间，也没有幽灵依赖问题，安装速度还快，从机制上来说完胜 npm 和 yarn。\\n\\npnpm 就是凭借这个对 npm 和 yarn 降维打击的。\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
        "tags": [
            "前端",
            "JavaScript",
            "NPM"
        ]
    }
]