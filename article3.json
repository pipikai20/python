[
    {
        "article_id": "7185128318235541563",
        "cover_image": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e9705b784e04a60a2abd54ed86abe11~tplv-k3u1fbpfcp-watermark.image?",
        "title": "千万别让 console.log 上生产！用 Performance 和 Memory 告诉你为什么",
        "brief": "很多前端都喜欢用 console.log 调试，先不谈调试效率怎么样，首先 console.log 有个致命的问题：会导致内存泄漏。 为什么这么说呢？ 用 Performance 和 Memory 工",
        "user_name": "zxg_神说要有光",
        "view_count": 37033,
        "collect_count": 489,
        "comment_count": 80,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/4e9e751e2b32fb8afbbf559a296ccbf2~300x300.image",
        "category": "前端",
        "content": "很多前端都喜欢用 console.log 调试，先不谈调试效率怎么样，首先 **console.log 有个致命的问题：会导致内存泄漏。**\\n\\n为什么这么说呢？\\n\\n用 Performance 和 Memory 工具分析下就知道了。\\n\\n我们准备这样一段代码：\\n\\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6de7d6d5ed2f46e9bc4c9f809bceabe6~tplv-k3u1fbpfcp-watermark.image?)\\n\\n一个按钮，点击之后创建一个数组，执行一些计算。\\n\\n很常见的逻辑。\\n\\n我们最后加了一个 console.log 打印了下这个数组。\\n\\n起个静态服务：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/41f6ea92ded84e1eba22b4fdc3a94179~tplv-k3u1fbpfcp-watermark.image?)\\n\\n浏览器访问：\\n\\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1052d50626c4897a8dabb75ad7ae14b~tplv-k3u1fbpfcp-watermark.image?)\\n\\n点击 performance 下的垃圾回收按钮，手动触发一次 GC：\\n\\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b684736ed5e045c6b85bc764564b18d9~tplv-k3u1fbpfcp-watermark.image?)\\n\\n勾选 Memory，然后开始录制，点击 3 次按钮，再执行一次 GC：\\n\\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a97487c30ca6465db0c668e0b297998c~tplv-k3u1fbpfcp-watermark.image?)\\n\\n你会发现内存是这样的：\\n\\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c4f83f666e84d9fb4ef77c06a7b98f3~tplv-k3u1fbpfcp-watermark.image?)\\n\\n内存占用有三次增长，因为我们点击三次按钮的时候会创建 3 次大数组。\\n\\n但是最后我们手动 GC 之后并没有回落下去，也就是这个大数组没有被回收。\\n\\n按理来说，代码执行完，那用的内存就要被释放，然后再执行别的代码，结果这段代码执行完之后大数组依然占据着内存，这样别的代码再执行的时候可用内存就少了。\\n\\n这就是发生了**内存泄漏，也就是代码执行完了不释放内存的流氓行为。**\\n\\n有同学说，只是这么一点内存问题不大呀，反正可用内存还很多。\\n\\n但如果你的代码要跑很长时间，这段代码要执行很多次呢？\\n\\n每次执行都会占据一部分内存不释放，慢慢的内存就不够用了，甚至会导致程序崩溃。\\n\\n比如当这段代码执行个 9 次，内存占用就增长了 9 个大数组的内存：\\n\\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/46b4600005bf41c4981e9d9e44d98c20~tplv-k3u1fbpfcp-watermark.image?)\\n\\n再多执行几次呢？\\n\\n是不是就有崩溃的隐患了。\\n\\n那为啥说是 console.log 导致的呢？\\n\\n我们来看看不用 console.log 是什么样的：\\n\\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/415ca1dbec1e4b75bf12e516448c33ae~tplv-k3u1fbpfcp-watermark.image?)\\n\\n注释掉 console.log，重新跑。\\n\\n你会发现现在的内存分配情况是这样的：\\n\\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5451c547800344008bead118df14a509~tplv-k3u1fbpfcp-watermark.image?)\\n\\n分配了三次内存，但是 GC 后又会落下去了。\\n\\n这才是没有内存泄漏的好代码。\\n\\n那为啥 console.log 会导致内存泄漏呢？\\n\\n因为控制台打印的对象，你是不是有可能展开看？那如果这个对象在内存中没有了，是不是就看不到了？\\n\\n所以有这个引用在，浏览器不会把你打印的对象的内存释放掉。\\n\\n有的同学说，那我不打开控制台，是不是就没有这个引用了？\\n\\n答案是否定的：\\n\\n![2023-01-05 18.34.31.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/485eed998c7e4a04a57fafc8bfd0c314~tplv-k3u1fbpfcp-watermark.image?)\\n\\n我点击了几次之后，再打开控制台，依然是可以看到这个对象的，说明没有被 GC。\\n\\n也就是说**用 console.log 打印对象的代码一定是有内存泄漏的。**\\n\\n当然，也不只是 console.log 会导致内存泄漏，还有别的 4 种情况：\\n\\n- 定时器用完了没有清除，那每次执行都会多一个定时器的内存占用，这就是内存泄漏\\n- 元素从 dom 移除了，但是还有一个变量引用着他，这样的游离的 dom 元素也不会被回收。每执行一次代码，就会多出游离的 dom 元素的内存，这也是内存泄漏\\n- 闭包引用了某个变量，这个变量不会被回收，如果这样的闭包比较多，那每次执行都会多出这些被引用变量的内存占用。这样引用大对象的闭包多了之后，也会导致内存问题\\n- 全局变量，这个本来就不会被 GC，要注意全局变量的使用\\n\\n总之，**全局变量、闭包引用的变量、被移除的 dom 依然被引用、定时器用完了没清除、console.log 都会发生代码执行完了，但是还占用着一部分内存的流氓行为，也就是内存泄漏。**\\n\\n注意，这里指的是使用完毕后没有回收，在使用期间的内存增长是正常的。\\n\\n那怎么排查呢？\\n\\nperformance 工具就可以：\\n\\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c215d62874544888792618c05df078c~tplv-k3u1fbpfcp-watermark.image?)\\n\\n点击内存分配情况的某个点，就会定位到 performance 中的某个任务的代码，点击可以在下面看到详情：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/44a3f73e7fe849b4bdb8299f8421c1c1~tplv-k3u1fbpfcp-watermark.image?)\\n\\n这样就定位到了分配内存的代码，分析一下哪里会有问题即可。\\n\\n当然，前提还是要执行先 GC，再做一些操作，再 GC 的这个流程。\\n\\n这是从代码角度来分析内存泄漏，其实还可以从内存中对象的角度，这个是通过 Memory 工具：\\n\\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6fd6ad941bab4b5b8187a6c947aba15a~tplv-k3u1fbpfcp-watermark.image?)\\n\\n先 GC，录制一次内存快照，再点击几次按钮，然后 GC，再录制一次内存快照。\\n\\n流程和用 performance 分析的时候一样。\\n\\n拿到两次内存快照也是可以分析出有内存泄漏的：\\n\\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4acaf66591f94fbdaebb472af431116c~tplv-k3u1fbpfcp-watermark.image?)\\n\\n可以看到 GC 后内存占用依然增长了。\\n\\n快照记录着这个时刻内存中所有对象的状态：\\n\\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb2bdbfaa5ff4f9dae72bf6cf222b354~tplv-k3u1fbpfcp-watermark.image?)\\n\\n对比两次快照，就可以找到变化的部分：\\n\\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5863e3656f214f79b128f556d212b8af~tplv-k3u1fbpfcp-watermark.image?)\\n\\n比如这时候可以看到最大的内存增长是 array 对象：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf7ad5dbb2714b24835a25536f66edda~tplv-k3u1fbpfcp-watermark.image?)\\n\\n然后就可以从 array 的角度去思考是什么导致的内存泄漏了。\\n\\n此外，memory 还有实时分析的工具：\\n\\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/631adedd0b4a4c47b15f3a90803fdc16~tplv-k3u1fbpfcp-watermark.image?)\\n\\n选择第二个，然后点几次按钮：\\n\\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c6edf03347e34b839884dbd5943fe176~tplv-k3u1fbpfcp-watermark.image?)\\n\\n其实不用手动 GC，JS 引擎会做 GC。\\n\\n去掉 console.log 再录制是这样的：\\n\\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f910450bcec142f8997f20fbfdb2aee6~tplv-k3u1fbpfcp-watermark.image?)\\n\\n除了最开始全局变量会分配一些内存以外，点击按钮之后的内存变蓝后又变灰了，也就是被 GC 了。\\n\\n这样你点多少次按钮，内存占用都没有增长。\\n\\n这就是代码执行完，会回收所有用到的内存的好代码。\\n\\n而前面的那个是每次代码执行，都会占用一部分内存不释放的内存泄漏代码。\\n\\n你还可以看到每一次内存分配的对象是啥：\\n\\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d44aebcd20144228d73e3c4b1b5c47b~tplv-k3u1fbpfcp-watermark.image?)\\n\\n不管是用 Performance 工具还是 Memory 工具，都可以发现 console.log 有内存泄漏的问题。所以还是尽量不要用这个来调试了。\\n\\n那应该用什么呢？\\n\\n用 debugger 呀，不管是 vscode debugger 还是 chrome devtools 的都可以：\\n\\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/01fadee1bc1e49d5938e9d32e8c632d7~tplv-k3u1fbpfcp-watermark.image?)\\n\\n你可以添加一个 logpoint 来代替 console.log 打印：\\n\\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1dd4864cdec43548076eb874715b3e6~tplv-k3u1fbpfcp-watermark.image?)\\n\\n代码执行到这里就会打印：\\n\\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/50008e0930d54ccf8d45ef019fdecf8f~tplv-k3u1fbpfcp-watermark.image?)\\n\\n而你的代码里不需要写 console.log。\\n\\n\\n此外，很多地方可以用断点代替打印：\\n\\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f2e060768a34125a26bd51e8b7c7047~tplv-k3u1fbpfcp-watermark.image?)\\n\\n可以看到代码执行路线和作用域，岂不是更高效？\\n\\n## 总结\\n\\nconsole.log 会导致内存泄漏，也就是代码执行完了，但还占据着一部分内存的流氓行为。\\n\\n除了 console.log，游离的 dom 被变量引用、全局变量、变量被闭包引用、定时器没清除也会导致内存泄漏。\\n\\n我们可以用 Performance 工具和 Memory 工具分析内存泄漏。\\n\\n先手动 GC，然后执行一些操作，再 GC，如果内存没有回到执行前，就说明这段代码有内存泄漏，可以再用 Performance 定位到代码位置分析代码。\\n\\nMemory 工具是从内存对象的角度分析，可以对两次快照做 diff，看下是啥对象泄漏了。\\n\\n也可以实时检测内存占用情况，看看是否存在内存泄漏，对象是啥。\\n\\nconsole.log 调试效率也不高，可以换成 logpoint，或者打断点。\\n\\n千万不要把 console.log 上生产！不然这样有内存泄漏的代码，一旦执行时间长了就会有问题。\\n\\n其实普通项目也还好，不会长期跑，但是类似大屏项目这种长期跑的，一旦有内存泄漏，一定会崩溃，只有时间长短的区别。\\n\\n（这篇文章有点错误，在下篇更正了：[console.log 一定会导致内存泄漏？不打开 devtools 就不会](https://juejin.cn/post/7185501830040944698)）\\n\\n",
        "tags": [
            "前端",
            "JavaScript",
            "浏览器"
        ]
    },
    {
        "article_id": "7184801269226143805",
        "cover_image": "https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/28de9fb405134868b5afb706e5e938b3~tplv-k3u1fbpfcp-watermark.image?",
        "title": "低代码平台组件间通信方案复盘",
        "brief": "背景介绍 3年前我开发了一款零代码搭建平台 H5-Dooring, 主要目的是想用更低的成本, 更快的效率, 上线 web 页面(其实是不想写重复的代码了,写麻了). 好在陆陆续续折腾了3年...",
        "user_name": "徐小夕",
        "view_count": 4166,
        "collect_count": 67,
        "comment_count": 14,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/d08df4df3fe80db668014b4b815390a5~300x300.image",
        "category": "前端",
        "content": "## 背景介绍\\n\\n3年前我开发了一款零代码搭建平台 **H5-Dooring**, 主要目的是想用更低的成本, 更快的效率, 上线 **web** 页面(其实是不想写重复的代码了,写麻了). 好在陆陆续续折腾了3年, 目前已经可以满足基本的页面设计和搭建能力, 并能快速上线页面. \\n\\n之前也在社区分享了很多**低代码**和**零代码**的技术实现, 接下来继续和大家聊聊低代码平台中组件与组件之间的通信方案设计.\\n\\n### 可视化搭建平台的基本能力\\n\\n根据我自己设计可视化搭建平台的经验, 其需要具备最最基本的两个能力:\\n\\n- **静态页面设计能力**(也就是可以用可视化平台制作我们想要的页面的能力)\\n- **组件交互能力**(制作好静态页面之后, 页面元素能具备一定的交互, 比如跳转链接, 打开弹窗等)\\n\\n以上的能力可以让我们将页面通过拖拽的方式搭建出来:\\n\\n[![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da3a18328e7744f69f5320b1838f1553~tplv-k3u1fbpfcp-zoom-1.image)](http://h5.dooring.cn/h5_plus)\\n\\n虽然这已经可以满足很多展示型的需求, 但是仍然存在局限性, 比如可视化平台的组件与组件之间, 没办法相互通信.\\n\\n### 更灵活自主的可视化搭建平台\\n\\n这里给大家举一个实际的场景, 比如我们要做一个转盘H5页面, 它由转盘组件和按钮组件组成, 当点击按钮时, 转盘开始运动:\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2794723a289b48079e82d42bf36051ee~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n这种场景就需要转盘组件和按钮组件相互通信, 来实现交互功能. 所以在可视化搭建平台中, 如果能实现组件间的通信, 那将覆盖更多的业务场景, 从而为个人或者企业带来更大的价值.\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be174ee9719d4711b93dfdd109a52b08~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n\\n接下来我将和大家分享一下低代码平台中组件间通信的几种方案, 共大家学习参考.\\n\\n## 组件间通信的几种实现方案\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e72619c715242dcae83f8e2a393794a~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n说到组件通信我们也许并不陌生, 比如在 `vue` 或者 `React` 框架中, 经常会涉及到父子组件通信以及组件与组件间的通信, 常用的方案也有很多, 比如:\\n\\n1. `props/$emit`\\n2. 子组件向父组件传值\\n3. eventBus(`$emit/$on`)\\n4. vuex / redux\\n5. `$attrs/$listeners`\\n6. provide/inject\\n\\n当然还有很多方式能帮我们实现传统组件间的通信, 那我们在低代码组件中, 也可以参考类似的方式来实现, 但是唯一的区别是需要设计一套规则, 来保证组件间通信可以通过用户配置的方式来运转.\\n\\n接下来我们来分析几种低代码组件间的通信方案.\\n\\n### 1.websocket\\n\\n在设计组件通信方案前, 我们需全局维护一个公共的状态, 拿 **H5-Dooring可视化平台** 举例, 我们用 `redux` 管理公共状态, 组件间通信本质就是触发公共状态的更新:\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de9dd94399b345bf9e8e3fc47d0b1e6a~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n为了保证低代码组件库足够纯净, 比如不应该在组件里连接 `redux`, 所以我们需要把 `redux` 触发器 `dispatch` 放在页面的全局, 这里就可以用 `websocket`, 在组件里触发 `socket` 指令,  在页面全局来监听, 并触发 `dispatch` :\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c28ffc523e6346deb6db343d6fcd7400~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n当然使用 `socket` 的方式仍然会让低代码组件库负重前行(虽然能实现更自由的通信场景, 比如组件自更新, 生命周期回调, 控制业务钩子等), 因为我们不得不为其搭建 `socket` 服务, 并且需要为其设计稳定的通信桥梁, 比如 `socket` 心跳连接等.\\n\\n### 2.iframe通信 postmessage\\n\\n利用 `iframe` 的 `postmessage` 等 `API` 虽然也能实现组件间通信, 但是我们需要设计一套通信机制, 保证 `iframe` 能接受组件传送的指令, 并对外暴露共享状态:\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d9d7231361d44469bd8a9b9181185fd~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n我们从 `Iframe` 的通信模式可以发现它不仅可以作为中间桥梁起到通信作用, 有点类似于 eventBus的模式, 而且还可以实现页面间的通信, 比如目前很多**微前端架构**的底层支持也有采用 iframe 来设计的. 但是对于更细粒度的低代码组件来说, 有点小题大作了.\\n\\n接下来给大家分享一下 `iframe` 通信的基本代码实现:\\n\\n```js\\n// 父页面和子页面通信\\n// A.html （父）\\n<iframe src=\\\"http://h5.dooring.cn/h5_plus\\\" frameborder=\\\"1\\\" id=\\\"Bframe\\\"></iframe>\\nconst msg = {\\n    name: \\\"H5-Dooring\\\"\\n  }\\nwindow.onload = () => {\\n  // 自动调用必须放在onload中,通过事件调用则不用\\n  // let frame = document.querySelector(\\\"#Bframe\\\").contentWindow\\n  let frame = window.frames[0]\\n  frame.postMessage(msg, \\\"http://h5.dooring.cn/preview\\\")\\n}\\n\\n// B.html\\nwindow.addEventListener(\\\"message\\\", (e) => {\\n  console.log(e.data)\\n  console.log(e.origin)\\n  console.log(e.source)\\n})\\n\\n// 子页面和父页面通信\\n// A.html （父）\\n<iframe src=\\\"http://h5.dooring.cn/h5_plus\\\" frameborder=\\\"1\\\" id=\\\"Bframe\\\"></iframe>\\nwindow.addEventListener(\\\"message\\\", (e) => {\\n  console.log(e.data)\\n  console.log(e.origin)\\n  console.log(e.source)\\n})\\n\\n// B.html\\nconst msg = {\\n  name: \\\"Dooring H5\\\"\\n}\\nwindow.top.postMessage(msg, \\\"http://h5.dooring.cn/preview\\\")\\n```\\n\\n### 3.Event Emitters\\n\\n`Event Emitters` 的方式我觉得是最适合低代码组件间通信的方案, 类似于 `js` 里的事件监听机制, 我们可以给 `dom` 绑定监听, 并暴露事件给用户来实现手动触发机制. (虽然不一定是用户手动触发, 也有一种情况是逻辑触发, 比如当页面某个组件到达某一状态的时候, 后自动触发事件, 来改变其他组件的状态)\\n\\n`Event Emitters` 类似一种观察者模式, 我们可以利用 javascript 的设计模式来实现它, 并在组件内部来监听或者触发, 一个简单的实现如下:\\n\\n```js\\ninterface Events {\\n  [key: string]: Function[];\\n}\\n\\nexport class EventEmitter {\\n  public events: Events;\\n  constructor(events?: Events) {\\n    this.events = events || {};\\n  }\\n\\n  public subscribe(name: string, cb: Function) {\\n    (this.events[name] || (this.events[name] = [])).push(cb);\\n\\n    return {\\n      unsubscribe: () =>\\n        this.events[name] && this.events[name].splice(this.events[name].indexOf(cb) >>> 0, 1)\\n    };\\n  }\\n\\n  public emit(name: string, ...args: any[]): void {\\n    (this.events[name] || []).forEach(fn => fn(...args));\\n  }\\n}\\n```\\n\\n具体设计流程有点像我之前设计的 `iframe` 通信架构, 不过使用起来会更简单:\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fbc4c5fc866a410f98b43ae66f8b0559~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n\\n## 低代码组件事件队列设计\\n\\n以上只实现了组件的通信, 并没有将通信和实际的应用场景结合起来, 比如低代码用户需要如何操作,才能实现组件通信. 这里我之前也设计了一套模型:\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af7b9e4c4f294c8bb5502f76cf2b8db5~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n每个组件都有一套事件列表, 用户可以给一个组件添加多个交互事件, 在第代码内部通过循环遍历来依次触发事件队列:\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c6d01e8b6be4e219020599eeebd02cd~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n事件通信就可以用上面介绍的 **Event Emitters**来实现, 具体的低代码模式可以参考我之前的项目: \\n\\n[H5-Dooring可视化低代码平台](https://github.com/MrXujiang/h5-Dooring)\\n\\n## 总结\\n\\n后续我会继续和大家分享一下 **H5-Dooring** 低代码的更多实践和思考, 如果大家对可视化低代码感兴趣也可以参考我的**低代码可视化**专栏. \\n\\n下一篇文章我会和大家分享一下低代码印章组件的实现方案, 大家有更多好的建议也可以随时和我反馈.\\n\\n\\n:::: column\\n::: column-left\\n\\n**H5-dooring低代码**\\n\\n![H5-dooring低代码](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ffc8126231ad4ab8ac58b2116dce3cad~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n\\n:::\\n::: column-right\\n\\n**V6.Dooring可视化大屏搭建平台**\\n\\n![V6.Dooring可视化大屏搭建平台](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/47f34d1a4f764a0688543638fb7995ae~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n\\n\\n:::\\n::::\\n\\n\\n\\n\\n",
        "tags": [
            "前端",
            "JavaScript",
            "设计模式"
        ]
    },
    {
        "article_id": "7153080758964322312",
        "cover_image": "https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51553a22bf0748be863a950719913107~tplv-k3u1fbpfcp-watermark.image?",
        "title": "💕💕浪漫限定！CSS 实现爱心跟随鼠标效果！",
        "brief": "最近大降温，才意识到秋天是真的来了。古人有诗云：“眉如青山黛，眼似秋波横。”这足以说明秋天的水是多么的浪漫、多情、温柔。 秋天都懂得浪漫，你天天被人说木讷，何不做点改变？今天我来教大家属于程序员的浪",
        "user_name": "CatWatermelon",
        "view_count": 3524,
        "collect_count": 43,
        "comment_count": 19,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/c4cc67b8f834d8ffbd017a458ab83298~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: channing-cyan\\n---\\n\\n持续创作，加速成长！这是我参与「掘金日新计划 · 10 月更文挑战」的第14天，[点击查看活动详情](https://juejin.cn/post/7147654075599978532 \\\"https://juejin.cn/post/7147654075599978532\\\")\\n\\n# 前言\\n\\n最近大降温，才意识到秋天是真的来了。古人有诗云：“眉如青山黛，眼似秋波横。”这足以说明秋天的水是多么的浪漫、多情、温柔。\\n\\n秋天都懂得浪漫，你天天被人说木讷，何不做点改变？今天我来教大家属于程序员的浪漫——使用 CSS 搭配 JS 实现爱心跟随鼠标发散效果。\\n\\n# 添加文字\\n\\n首先当然要将我们的文字添加上去啦。\\n\\n```js\\n<body>\\n    <div id=\\\"text\\\">CatWatermelon</div>\\n</body>\\n```\\n很简单是不是，这才开始呢，我们接下来绘制背景先。\\n\\n# 绘制背景\\n\\n首先老规矩，我们将 **CSS 样式重置** ，方便各个浏览器统一展示效果。\\n\\n```js\\n* {\\n    margin: 0;\\n    padding: 0;\\n    box-sizing: border-box;\\n}\\n```\\nps：大家开发的时候可不敢这么写，要不代码是上午写的，桶是下午提的了。\\n\\n接下来通过添加 `min-height: 100vh` 属性，将 `body` 限制为 **视口大小** 且通过 `overflow: hidden` 来将 **超出部分隐藏** 。\\n\\n```js\\nbody {\\n    min-height: 100vh;\\n    background-color: #111;\\n    overflow: hidden;\\n    display: flex;\\n    justify-content: center;\\n    align-items: center;\\n}\\n```\\n注意这里用了 `flex` 布局实现了 **水平垂直居中**。小伙伴们平时喜欢什么方式来实现这个效果呢？\\n\\n我们开始正戏前，先看看目前的效果：\\n\\n![微信截图_20221010193239.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/77fae35c98684524b60ef1c4e37e5fb1~tplv-k3u1fbpfcp-watermark.image?)\\n\\n没啥问题，也不该有啥问题，可以接着走了。\\n\\n# 爱心生成并跟随\\n\\n这部分我们需要思考三个问题。\\n\\n## 三个问题\\n\\n1. 怎么生成爱心，什么时候生成？\\n2. 生成的爱心怎么跟随鼠标？\\n3. 怎么让爱心消失？\\n\\n## 爱心生成\\n\\n我们一个一个看，首先是生成爱心，爱心我们可以用一张 **透明爱心图片** 充当，这里之所以要透明图片是因为防止 `body` 背景色和图片产生色差，影响美观。具体的，我们可以用一个容器 `span` ，将其背景 `background` 设置为这个爱心图片。如下所示：\\n\\n```js\\nspan::before {\\n    content: \\\"\\\";\\n    position: absolute;\\n    width: 100px;\\n    height: 100px;\\n    background: url(./static/1.png);\\n    background-size: cover;\\n}\\n```\\n\\n那么承载爱心的容器 `span` 应该在什么时候生成呢？明显的，我们鼠标移动的时候，会不停的创建小心心，那么我们应该在鼠标移动事件 `mousemove` 触发时，在回调中不断的通过 `document.createElement` 创建 `span` 。\\n\\n## 跟随鼠标\\n\\n创建好爱心后，我们为了实现爱心跟随鼠标的效果，应该将新生成的爱心的位置和鼠标位置同步。在 `mousemove` 事件中，回调函数的入参 `e` 对象中包含了 `offsetX` 和 `offsetY` 两个属性，通过这两个属性，我们就可以知道当前鼠标的位置，此时将爱心的位置也设置为 (offsetX, offsetY)，就可以实现爱心跟随的效果了。\\n\\n## 爱心消失\\n\\n爱心消失我们可以设定一个时间，比如一秒，在上面创建 `span` 标签时，设置一个 `setTimeout` 定时器，指定一秒后通过实例调用 `remove` 方法，就可以实现爱心一秒后消失的效果啦。\\n\\n```js\\ndocument.addEventListener('mousemove', function(e) {\\n    let body = document.querySelector('body');\\n    let heart = document.createElement('span');\\n    let x = e.offsetX;\\n    let y = e.offsetY;\\n    heart.style.left = x + 'px';\\n    heart.style.top = y + 'px';\\n\\n    body.appendChild(heart);\\n\\n    setTimeout(() => {\\n        heart.remove();\\n    }, 1000)\\n})\\n```\\n\\n看看效果：\\n\\n![20221010_194749 (1).gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/48e890f6b80f4c06b178678c2637cbcf~tplv-k3u1fbpfcp-watermark.image?)\\n\\n可以发现稍微有点僵硬，我们尝试给爱心一个边向后偏移边旋转的动画试试：\\n\\n```js\\nspan::before {\\n    ...\\n    animation: moveShape 1s linear infinite;\\n}\\n@keyframes moveShape {\\n    0% {\\n        transform: translate(0) rotate(0deg);\\n    }\\n    100% {\\n        transform: translate(300px) rotate(360deg);\\n    }\\n}\\n```\\n\\n![20221010_195057.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2fd1a76cc7444d69a8b9ef87068c4fdb~tplv-k3u1fbpfcp-watermark.image?)\\n\\n效果好很多啦，让我们继续添砖加瓦。\\n\\n# 随机大小\\n\\n如果我们能将每个爱心都设置成不同大小就好了，随机的大小像冒泡泡一样，显得更可爱。\\n\\n我们可以通过一个随机数，来改变爱心容器 `span` 的大小。为了让每个 `span` 大小不会相差太多，我们可以用一个 **固定宽高** 作为基数，然后加上随机得到的一个数，作为最终的宽高。\\n\\n```js\\ndocument.addEventListener('mousemove', function(e) {\\n    ...\\n    let size = Math.random() * 80;\\n    heart.style.width = 20 + size + 'px';\\n    heart.style.height = 20 + size + 'px';\\n\\n    body.appendChild(heart);\\n})\\n```\\n\\n`Math.random` 方法返回的是 `[0, 1)` 之间的数，因此我们乘上一个系数放大 80，才更明显。\\n\\n我们来看看此时的效果：\\n\\n![20221010_200204.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/39adb00c6f764eaebba0ec6cba2423f2~tplv-k3u1fbpfcp-watermark.image?)\\n\\n不错，味道好极了，啊不，是效果好极了，如果能加点旋转就好了。\\n\\n# 让爱心转起来\\n\\n同样的，我们可以用刚刚的思路，通过 `rotate` 属性动态的改变每个爱心的角度。\\n\\n```js\\ndocument.addEventListener('mousemove', function(e) {\\n    ...\\n    let transformValue = Math.random() * 360;\\n    heart.style.transform = `rotate(${transformValue}deg)`;\\n    \\n    body.appendChild(heart);\\n})\\n```\\n\\n这里的系数我们要乘 360，表示有 360° 的角度可以随机到。此时我们再看看效果：\\n\\n![20221010_200125.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f75e7e9e39364114b4153177bd4fb569~tplv-k3u1fbpfcp-watermark.image?)\\n\\n# 让爱心散开\\n\\n为了让爱心能更浪漫点，我们需要将这些爱心在以鼠标坐标为中心，向四周散开。\\n\\n相信大家都知道套路，实际上就是改变每个爱心的偏移，那么就要用到动画了。\\n\\n```js\\n span::before {\\n    ...\\n    animation: moveShape 1s linear infinite;\\n}\\n@keyframes moveShape {\\n    0% {\\n        transform: translate(0) rotate(0deg);\\n    }\\n    100% {\\n        transform: translate(300px) rotate(360deg);\\n    }\\n}\\n```\\n\\n我们设置在动画开始到动画结束的过程中，偏移量从 0 至 300px，同时旋转 360°。\\n\\n让我们看看效果：\\n\\n![20221010_201603.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8065df3afa34a54a2a177ffd47ecd57~tplv-k3u1fbpfcp-watermark.image?)\\n\\n可以，已经很棒了。但是还不够，我们仔细看动图，可以发现爱心消失的很突然，所以我们接下来要淡化一下这么生硬的消失效果。\\n\\n# 消失动画\\n\\n为了让爱心消失的不那么突然，我们可以使用 `opacity` 搭配动画，从 1 到 0 的让爱心慢慢消失。\\n\\n```js\\nspan {\\n    ...\\n    animation: fadeInOut 1s linear infinite;\\n}\\n@keyframes fadeInOut {\\n    0%,100% {\\n        opacity: 0;\\n    }\\n    20%, 80% {\\n        opacity: 1;\\n    }\\n}\\n\\n```\\n\\n看看我们的最终效果：\\n\\n![20221010_201247.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/66e31f2784674e75841077e49bcf145b~tplv-k3u1fbpfcp-watermark.image?)\\n\\n# Github 源码地址\\n\\n[juejin-demo/heart-demo at main · catwatermelon/juejin-demo (github.com)](https://github.com/catwatermelon/juejin-demo/tree/main/heart-demo)\\n\\n# 结束语\\n\\n至此，本文就到此结束啦，不知道大家学废了吗？\\n\\n> 如果小伙伴们有别的想法，欢迎留言，让我们共同学习进步💪💪。\\n> \\n> 如果文中有不对的地方，或是大家有不同的见解，欢迎指出🙏🙏。\\n> \\n> 如果大家觉得所有收获，欢迎一键三连💕💕。\\n",
        "tags": [
            "CSS",
            "掘金·日新计划",
            "前端"
        ]
    },
    {
        "article_id": "7176963906844246074",
        "cover_image": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72f04a7dba5d4698ae5c663633f623e1~tplv-k3u1fbpfcp-watermark.image?",
        "title": "Webpack深度进阶：两张图彻底讲明白热更新原理！",
        "brief": "在现如今，热更新早已成为前端基建中不可或缺的一环，它可以在不刷新整个页面的情况下更新页面中的部分内容，从而提高开发效率，优化开发体验。然而，在实际面试的过程中，笔者发现 80% 的人并不清楚这其中的设",
        "user_name": "不要秃头啊",
        "view_count": 2927,
        "collect_count": 74,
        "comment_count": 17,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/5db9ef9c19e9f3cbbf4fb73e0e283a7a~300x300.image",
        "category": "前端",
        "content": "---\\nhighlight: zenburn\\ntheme: devui-blue\\n---\\n\\n## 一、前言\\n\\n> 本文是 [从零到亿系统性的建立前端构建知识体系✨](https://juejin.cn/post/7145855619096903717)\\n> 中的第九篇。\\n\\n在现如今，热更新早已成为前端基建中不可或缺的一环，它可以在不刷新整个页面的情况下更新页面中的部分内容，从而提高开发效率，优化开发体验。\\n\\n然而，在实际面试的过程中，笔者发现 80% 的人并不清楚这其中的设计原理，只有很少一部分人能够表达清楚，原因我认为可能有以下几点：\\n\\n\\n- 工作中不是必要：由于热更新通常是通过使用工具或框架来实现的，认为热更新的原理并不重要，只需要使用即可\\n- 学习成本高：热更新的原理涉及到较高级的技术知识，原理过于复杂\\n- ......\\n\\n总之，热更新对我们来说，就像是一块难啃的骨头。但在前端基建岗位中，它又是必备的知识体系之一。\\n\\n因此，本文将一改之前的文风，全文不会手写任何原理相关的代码，尽量通过图文的方式去讲解整个运作流程，旨在帮助大家理解其中的设计思想，以看懂为目的。\\n\\n> 回到正文：\\n\\n在 [HMR](https://webpack.js.org/guides/hot-module-replacement/#enabling-hmr) 之前，应用的加载、更新都是一种页面级别的操作，即使只是单个代码文件发生变更，都需要刷新整个页面，才能将最新代码映射到浏览器上，这会丢失之前在页面执行过的所有交互与状态，例如：\\n\\n- 对于复杂表单场景，这意味着你可能需要重新填充非常多字段信息\\n- 弹框消失，你必须重新执行交互动作才会重新弹出\\n\\n再小的改动，例如更新字体大小，改变备注信息都会需要整个页面重新加载执行，整体开发效率偏低。\\n\\n而引入 HMR 后，虽然无法覆盖所有场景，但大多数小改动都可以通过模块热替换方式更新到页面上，从而确保连续、顺畅的开发调试体验，极大提升开发效率。\\n\\n文中所涉及到的代码均放到个人 [github 仓库](https://github.com/noBaldAaa/hand-webpack-hmr)中。\\n\\n## 二、基本使用\\n\\n在正式讲原理之前，先简单过一下热更新的使用方式，照顾一下不太熟悉的同学。足够熟悉的同学可直接定位到第四节 —— 核心思想。\\n\\n> 初始化项目：\\n\\n```js\\nnpm init  //初始化一个项目\\nyarn add webpack webpack-cli webpack-dev-server html-webpack-plugin//安装项目依赖\\n```\\n简单说一下这几个依赖：\\n\\n- [webpack](https://webpack.js.org/)：这个不必说，核心库\\n- [webpack-cli](https://www.npmjs.com/package/webpack-cli)：主要用来处理命令行中的参数，并启动 `webpack` 编译\\n- [webpack-dev-server](https://www.npmjs.com/package/webpack-dev-server)：提供开发服务器，用来支持热更新\\n- [html-webpack-plugin](https://www.npmjs.com/package/html-webpack-plugin)：用于将打包后的 `css`、`js` 等代码插入到 `html` 模版中\\n\\n安装完依赖后，根据以下目录结构来添加对应的目录和文件： \\n```\\n├── node_modules\\n├── package.json\\n├── index.html # html模版代码\\n├── webpack.config.js #配置文件\\n└── src # 源码目录\\n     |── index.js\\n     └── name.js\\n```\\n\\n在 Webpack 生态下，只需两步即可启动 `HMR` 功能：\\n\\n1.  设置 `devServer.hot` 属性为 true\\n2.  在代码中调用 `module.hot.accept` 接口，声明模块变化时执行的回调函数\\n\\n\\n**webpack.config.js**\\n```js\\nconst HtmlWebpackPlugin = require(\\\"html-webpack-plugin\\\");\\n\\nmodule.exports = {\\n  mode: \\\"development\\\", //开发模式\\n  entry: \\\"./src/index.js\\\", //入口\\n  devServer: {\\n    hot: true, //开启热更新，这个是关键！！！\\n    port: 8000, //设置端口号\\n  },\\n  plugins: [\\n    new HtmlWebpackPlugin({\\n      template: \\\"./index.html\\\", //将打包后的代码插入到html模版中\\n    }),\\n  ],\\n};\\n```\\n\\n**index.html**\\n\\n```js\\n<!DOCTYPE html>\\n<html lang=\\\"en\\\">\\n  <head>\\n    <meta charset=\\\"UTF-8\\\" />\\n    <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" />\\n    <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" />\\n    <title>hmr</title>\\n  </head>\\n  <body>\\n    <div id=\\\"root\\\"></div>\\n    <!-- 可以在里面输入一些东西，方便我们观察热更新的效果 -->\\n    <input />\\n  </body>\\n</html>\\n```\\n\\n**src/index.js**\\n\\n```js\\nimport name from \\\"./name\\\";\\n\\nconst render = () => {\\n  const rootDom = document.getElementById(\\\"root\\\");\\n  rootDom.innerText = name;\\n};\\n\\nrender();\\n\\n//要实现热更新，这段代码并不可少，描述当模块被更新后做什么 \\nif (module.hot) {\\n  module.hot.accept(\\\"./name\\\", function () {\\n    console.log(\\\"name模块发生变化，处理热更新逻辑\\\");\\n    render();\\n  });\\n}\\n```\\n**src/name.js**\\n```\\nconst name = \\\"不要秃头啊\\\";\\nexport default name;\\n```\\n**package.json**\\n\\n```js\\n  \\\"scripts\\\": {\\n    \\\"start\\\": \\\"webpack serve\\\"\\n  },\\n```\\n\\n当我们执行 `yarn start` 命令时，`webpack-cli` 就会使用 [webpack-dev-server](https://www.npmjs.com/package/webpack-dev-server) 以 [watch 模式](https://webpack.js.org/configuration/watch/#watch) 来帮助我们启动编译。\\n\\n效果：当文件保存后，并没有刷新浏览器就自动更新了。\\n\\n![peo9u-59dwp.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ecca7ca1b2d4765a8dd4a9f0369172c~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## 三、框架中使用\\n\\n上面我们使用 HMR 有一个很大的痛点：在开发项目时，我们经常需要手动去修改 `module.hot.accpet` 相关的函数，这就比较反人类了。\\n\\n不过幸好，在社区中已经针对这些有很成熟的解决方案了：\\n\\n- 比如 [Vue](https://www.npmjs.com/package/vue) 开发中，我们使用 [vue-loader](https://www.npmjs.com/package/vue-loader)，此 loader 支持 Vue 组件的 HMR，提供开箱即用的体验\\n- 比如 [React](https://www.npmjs.com/package/react) 开发中，有 [React Hot Loader](https://www.npmjs.com/package/react-hot-loader)，实时调整 React 组件（目前 React 官方已经弃用了，改成使用 [react-refresh](https://www.npmjs.com/package/react-refresh))\\n\\n这里以 React 举例，先快速搭建 React 运行环境：\\n\\n### 3.1、搭建React开发环境\\n\\n安装 React 和相关依赖：\\n\\n```js\\n    \\\"react\\\": \\\"^18.2.0\\\",\\n    \\\"react-dom\\\": \\\"^18.2.0\\\",\\n    \\\"@babel/core\\\": \\\"^7.20.5\\\",\\n    \\\"@babel/preset-react\\\": \\\"^7.18.6\\\",\\n    \\\"babel-loader\\\": \\\"^9.1.0\\\",\\n```\\n\\n简单介绍一下这几个库：\\n\\n- [react](https://www.npmjs.com/package/react)：核心库，不必多说\\n- [react-dom](https://www.npmjs.com/package/react-dom)：核心库，不必多说\\n- [@babel/core](https://www.npmjs.com/package/@babel/core)：Babel 编译器的核心\\n- [@babel/preset-react](https://www.npmjs.com/package/@babel/preset-react)：所有 React 插件的 Babel 预设\\n- [babel-loader](https://www.npmjs.com/package/babel-loader)：在 Webpack 中转译 JavaScript 文件\\n\\n在根目录下新建 **babel.config.js** 文件，并配置：\\n\\n```js\\nmodule.exports = {\\n presets: [\\\"@babel/preset-react\\\"],\\n};\\n```\\n\\n修改 **webpack.config.js** 下配置：\\n\\n```js\\nconst HtmlWebpackPlugin = require(\\\"html-webpack-plugin\\\");\\nconst ReactRefreshWebpackPlugin = require(\\\"@pmmmwh/react-refresh-webpack-plugin\\\");\\n\\nmodule.exports = {\\n  //省略其他\\n  entry: \\\"./src/index.jsx\\\", //入口\\n+ module: {\\n+   rules: [\\n+     {\\n+       test: /\\\\.jsx?$/i,\\n+       exclude: /node_modules/,\\n+       use: \\\"babel-loader\\\", \\n+     },\\n+   ],\\n+ },\\n};\\n```\\n\\n入口文件 **src/index.jsx** ：\\n\\n```js\\nimport React, { StrictMode } from \\\"react\\\";\\nimport { createRoot } from \\\"react-dom/client\\\";\\n\\nimport App from \\\"./app.jsx\\\";\\n\\nconst rootElement = document.getElementById(\\\"root\\\");\\nconst root = createRoot(rootElement);\\n\\nroot.render(\\n  <StrictMode>\\n    <App />\\n  </StrictMode>\\n);\\n```\\n\\n**src/app.jsx** ：\\n\\n```js\\nimport React from \\\"react\\\";\\n\\nexport default function App() {\\n  return (\\n    <div>\\n      作者：不要秃头啊\\n      <input />\\n    </div>\\n  );\\n}\\n```\\n\\n### 3.2、React中启用HMR\\n\\n安装热更新相关依赖：\\n\\n```js\\nnpm install -D @pmmmwh/react-refresh-webpack-plugin react-refresh\\nor\\nyarn add -D @pmmmwh/react-refresh-webpack-plugin react-refresh\\n```\\n[react-refresh](https://www.npmjs.com/package/react-refresh) 是专门用来做 React 热更新的，[Redux](https://www.npmjs.com/package/redux) 作者 Dan 还曾专门讲解过如何使用`react-refresh` 去替代之前的 [React Hot Loader](https://www.npmjs.com/package/react-hot-loader)，有需求的自行查阅：https://github.com/facebook/react/issues/16604 。\\n\\n[@pmmmwh/react-refresh-webpack-plugin](https://www.npmjs.com/package/@pmmmwh/react-refresh-webpack-plugin) 则是 `react-refresh` 在 Webpack 中的插件。\\n\\n在React中启用HMR只需两步：\\n\\n1. **babel.config.js** 中配置相关插件：\\n\\n```js\\nmodule.exports = {\\n  presets: [\\\"@babel/preset-react\\\"],\\n+ plugins: [\\\"react-refresh/babel\\\"],\\n};\\n```\\n\\n2. 在 **webpack.config.js** 中配置相关插件：\\n\\n```js\\nconst HtmlWebpackPlugin = require(\\\"html-webpack-plugin\\\");\\n+ const ReactRefreshWebpackPlugin = require(\\\"@pmmmwh/react-refresh-webpack-plugin\\\");\\n\\nmodule.exports = {\\n  //省略其他\\n  plugins: [\\n    //省略其他\\n  + new ReactRefreshWebpackPlugin(),\\n  ],\\n};\\n```\\n\\n效果：可以看到，输入框中的值并没有被重置，说明热更新生效。\\n\\n![1t0zp-nwfiz.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a79185e1e4074722b479c3154c985ee5~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## 四、核心思想\\n\\n这里均以第二节中的案例来进行讲解。\\n\\n我们先来看看热更新的核心包 [webpack-dev-server](https://www.npmjs.com/package/webpack-dev-server) 做了哪些事：\\n\\n当我们运行 **webpack serve** 后，[webpack-dev-server](https://www.npmjs.com/package/webpack-dev-server)  会先往`客户端代码`中添加了两个文件，这两个文件的目的：\\n\\n1. [websocket](https://www.npmjs.com/package/websocket) 相关的代码，用来跟服务端通信\\n2. 客户端接收到最新代码后，更新代码\\n\\n接着还会帮我们启动两个服务：\\n\\n1. 一个本地 **`HTTP 服务`**：这个本地服务会给我们提供编译之后的结果，之后浏览器通过端口请求时，就会请求本地服务中编译之后的内容，默认端口号 8080。\\n2. 一个 **`websocket 双向通信服务器`**：如果有新的模块发生变化，编译成功会以消息的方式通知客户端，让客户端来请求最新代码，并进行客户端的热更新。\\n\\n然后会以 [watch 模式](https://webpack.js.org/configuration/watch/#watch) 开始编译，每次编译结束后会生成一个唯一的 hash 值。\\n\\n> watch 模式：使用监控模式开始启动 webpack 编译，在 webpack 的 watch 模式下，文件系统中某一个文件发生修改，webpack 监听到文件变化，根据配置文件对模块重新编译打包，每次编译都会产生一个唯一的 hash 值\\n\\n以上就是 [webpack-dev-server](https://www.npmjs.com/package/webpack-dev-server) 的大致的思路，接下来我们对照真实案例来看看。\\n\\n--------------------------------------\\n\\n### 4.1、首次启动\\n\\n> 先简单说一下`代码块（chunk）`和 `模块（module）`的概念：\\n> \\n> `chunk` 就是若干 `module` 打成的包，一个 `chunk` 包括多个 `module`，一般来说最终会形成一个 file。而 `module` 就是一个个代码模块。\\n> \\n> 拿本项目举例子：**src/index.js** 和 **src/name.js** 他们就组成了一个代码块（`chunk`），因为他们来自于同一个入口文件（`entry: \\\"src/index.js\\\"`），或者说他们被同一个入口文件所依赖，因此他们最后会被打包进一个代码块中。\\n> \\n> 而同样的， **src/index.js**、**src/name.js** 他们自己也是单独的模块（`module`）。\\n\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68663ce7c523421cb83f5236a4514fb5~tplv-k3u1fbpfcp-watermark.image?)\\n\\n在初次编译完成（启动项目）后，webpack 内部会生成一个 `hash = h1`，并将 `hash = h1`\\n通过 **websocket** 的方式通知给客户端，客户端上有两个变量：`lastHash`、`currentHash`。\\n\\n- lastHash：上一次接收到的 hash\\n- currentHash：这一次接收到的 hash\\n\\n在接收到服务端通知过来的 hash 时，客户端会进行保存：\\n\\n```js\\nlastHash= \\\"之前的hash值\\\"\\ncurrentHash = hash\\n```\\n如果是第一次接收到 hash 值，代表是第一次连接，则：\\n\\n```js\\nlastHash = currentHash = hash\\n```\\n\\n### 4.2、二次编译\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/74519d751863471bb877a68bd3a4644d~tplv-k3u1fbpfcp-watermark.image?)\\n\\n此时，如果源代码发生变化（`name=\\\"不要秃头啊123\\\"`），`webpack` 对源文件重新进行编译，在编译完成后生成 `hash = h2` ，并将 `hash = h2` 发送给客户端，客户端接收到消息后，修改自身的变量：\\n\\n```js\\n//客户端代码\\nlastHash = h1\\ncurrentHash = h2\\n```\\n接着客户端通过 `lastHash = h1` 向服务端请求 `json 数据`（**main.h1.json**），目的是为了获得 **变更的代码块**：\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dbd13228e0924d50a911c1e9fcabb0a5~tplv-k3u1fbpfcp-watermark.image?)\\n\\n服务端接收到请求后，将传过来的 `h1` 和 自身最新的 `hash = h2` 进行对比，找出 **变更的代码块（chunk：main）** 后返回给客户端。\\n\\n客户端在收到响应后，知道了哪些代码块（**chunk：main**）发生了变化，接着会继续通过 `lastHash = h1`（*`main.h1.js`*）向服务端去请求 **变更代码块（chunk：main）中的变动模块代码**：\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d87fa1c6a6c04e2c98ba1b3e560a8b4c~tplv-k3u1fbpfcp-watermark.image?)\\n\\n服务端接收到 js 请求（*`main.h1.js`*）后，将传过来的 `h1` 和 自身最新的 `hash = h2` 再次进行对比，找出具体 **变更的模块代码（src/name.js）** 后返回给客户端。\\n\\n最后，客户端拿到了变更模块的代码，重新去执行`依赖该模块的模块`（比如 **src/name.js** 被修改了，**src/index.js** 依赖 **src/name.js**，那就要重新执行 **src/index.js** 这个模块），达到更新的目的。\\n\\n> 这里可能有同学要问了：为什么客户端会有两个 hash 值？\\n\\n- lastHash：上一次接收到的 hash\\n- currentHash：这一次接收到的 hash\\n\\n这么设计的用意：服务端不知道现在客户端的 hash 是多少，万一此时又连接一个客户端（多窗口的场景）怎么办？\\n\\n所以这里需要客户端将上一次的 hash 返回给服务端，服务端通过比较后才返回变更的代码块。\\n\\n> 如果每次文件改变都重新编译，那性能跟得上吗？\\n\\n这里为了提升性能，[webpack-dev-server](https://www.npmjs.com/package/webpack-dev-server) 使用了一个库叫 [memfs](https://www.npmjs.com/package/memfs)，它是 Webpack 官方自己写的。\\n\\n这样每次打包之后的结果并不会进行输出（把文件写入到硬盘上会耗费很长的时间），而是将打包后的文件保留在内存中，以此来提升性能。\\n\\n## 五、总结\\n\\n读完本文，你会发现`热更新`的核心就是通过 **websocket 服务** 进行客户端和服务端的同步变更，并没有我们想象中那么复杂。\\n\\n尽管这篇文章并没有对 `Webpack HMR` 进行源码级别的解析，很多细节方面也没过多探讨，但它真正起到的是一个抛砖引玉的作用，会大大减少你对 HMR 的陌生感。\\n\\n如果对 webpack 感兴趣，想了解 Webpack HMR 更多的底层细节，相信阅读 webpack 源码将是一个不错的选择，也希望这篇文章能够对你阅读源码有所帮助，这才是我真正的写作目的。\\n\\n## 推荐阅读\\n\\n1. [从零到亿系统性的建立前端构建知识体系✨](https://juejin.cn/post/7145855619096903717)\\n2. [我是如何带领团队从零到一建立前端规范的？🎉🎉🎉](https://juejin.cn/post/7085257325165936648)\\n3. [线上崩了？一招教你快速定位问题！](https://juejin.cn/post/7166031357418668040)\\n4. [【中级/高级前端】为什么我建议你一定要读一读 Tapable 源码？](https://juejin.cn/post/7164175171358556173)\\n5. [前端工程化基石 -- AST（抽象语法树）以及AST的广泛应用🔥](https://juejin.cn/post/7155151377013047304)\\n6. [二十张图片彻底讲明白Webpack设计理念，以看懂为目的](https://juejin.cn/post/7170852747749621791)\\n7. [【万字长文｜趣味图解】彻底弄懂Webpack中的Loader机制](https://juejin.cn/post/7157739406835580965)\\n8. [学会这些自定义hooks，让你摸鱼时间再翻一倍🐟🐟](https://juejin.cn/post/7095396322643017742)\\n9. [浅析前端异常及降级处理](https://juejin.cn/post/6979564690787532814)\\n10. [前端重新部署后，领导跟我说页面崩溃了...](https://juejin.cn/post/6981718762483679239)",
        "tags": [
            "前端",
            "架构",
            "JavaScript"
        ]
    },
    {
        "article_id": "7162082467518611470",
        "cover_image": "https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ec9e0de16d54edfa9f66fdd97ed37a0~tplv-k3u1fbpfcp-watermark.image?",
        "title": "思维导图display:flex弹性盒子",
        "brief": "web开发中，弹性盒子是必备的基本知识，我做了一张思维导图，方便你来使用它。你可以收藏下来方便查找它",
        "user_name": "大熊G",
        "view_count": 2446,
        "collect_count": 46,
        "comment_count": 3,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/ba9c9a7367cc6ec923b61c5f0c3ecce9~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: channing-cyan\\n---\\n\\n\\n> web开发中，弹性盒子是必备的基本知识，我做了一张思维导图，方便你来使用它。你可以收藏下来方便查找\\n\\n![思维导图.jpg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ab96811726040dc8e14e0348024a5b9~tplv-k3u1fbpfcp-watermark.image?)\\n弹性盒子主要可以分为俩类，一个是给父元素添加的，一个是给子元素添加的，下面我用文字来描述他们\\n## 给父元素\\n一共6种类型的弹性容器\\n\\n\\n###  `flex-direction` 设置子元素排序是行或者列 \\n- flex-direction:row; 设置按照行进行排列\\n- flex-direction:column; 按照列进行排序\\n- flex-direction: column-reverse;按照列进行反向排序  severse反序\\n- flex-direction:row-reverse;按照行进行反向排序\\n\\n###   `flex-wrap` 浏览器溢出项 可以设置换行和不换行\\n- flex-wrap: nowrap; 默认值不换行\\n- flex-wrap: wrap;  在溢出换行或者换列\\n- flex-wrap: wrap-reverse  进行反序换行\\n\\n\\n###  `flex-flow` flex-direction:flex-wrap;的简写\\n- flex-direction: column; flex-wrap: wrap; （相当于）flex-flow: column wrap;\\n###  `justify-content` 沿弹性框的主轴灵活非配子元素\\n- justify-content: flex-start 默认值 位于弹性盒子的开头\\n- justify-content: flex-end 位于弹性盒子的末尾\\n- justify-content: center 位于弹性盒子的中间\\n- justify-content: space-between 位于各行之间留有空白的内容中  两边贴死\\n- justify-content: space-around  位于各行之间、之内、之外留有的空白 两边不贴死\\n###  `align-items` 沿着弹性盒子的十字轴进行定位 只能用作一行  用于元素对齐\\n- align-items: stretch 默认值 子元素被拉伸适应容器\\n- align-items: center 位于容器的中心\\n- align-items: flex-start  位于开头\\n- align-items: flex-end 位于结尾\\n- align-items: baseline 位于容器的基线上\\n###  `align-content` 适应多行的弹性盒子，对一行使用时无效\\n- align-content: stretch 默认值 子元素被拉伸适应容器\\n- align-content: center 位于容器的中心\\n- align-content: flex-start  位于开头\\n- align-content: flex-end 位于结尾\\n- align-content: space-between  位于各行之间留有空白的容器\\n- align-content: space-around  位于各行之前之后之间留有空白的容器\\n## 给子元素\\n### `align-self` 定义flex子项单独在侧轴（纵轴）方向上的对齐方式\\n- ​auto 默认值 元素继承它的父容器align-items属性 如果没有父容器则为stretch 拉伸\\n- ​stretch 元素被拉伸适应容器\\n- ​center 元素位于容器的中心\\n- ​flex-start 元素位于容器的开头\\n- ​flex-end  元素位于容器的结尾\\n### `order`   设置子元素的位置 放到前面可以设置-1\\n- number  默认是0\\n### `flex-grow ` 用于设置或检索弹性盒的扩展比率\\n- number  默认是0\\n- 设置为2的话相当于占两个元素的大小\\n### `​flex-shrink`  用于设置或检索弹性盒的收缩比率\\n- number  默认值是1\\n### `flex-basis` 用于设置或检索弹性盒伸缩基准值\\n- ​auto 默认值\\n- ​number  可以设置长度或者百分比\\n### ` flex` 用于简写上面的属性 \\n- flex: flex-grow flex-shrink flex-basis|auto|initial|inherit;\\n\\n我的博客即将同步至腾讯云开发者社区，邀请大家一同入驻：https://cloud.tencent.com/developer/support-plan?invite_code=2sjw6uhnhhesc\\n",
        "tags": [
            "前端",
            "CSS",
            "HTML"
        ]
    },
    {
        "article_id": "7190346663318257724",
        "cover_image": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35c143c5e63043b6a040a93dee8f5478~tplv-k3u1fbpfcp-watermark.image?",
        "title": "【vue3】原生Teleport不太好用？试试自己写一个",
        "brief": "新年快乐，我是背对疾风。 今天我们聊聊VUE3的新特性之一，Teleport。来看看怎么用hook实现一个自己的“Teleport”。",
        "user_name": "背对疾风",
        "view_count": 1294,
        "collect_count": 10,
        "comment_count": 1,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/1b4c7431245984fd1338c2594509cc8b~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: channing-cyan\\n---\\n新年快乐，我是背对疾风。\\n\\n`VUE3`发布距今已经差不多两年了，你所在的公司全面用上`VUE3`了吗？🤔\\n\\n今天我们聊聊`VUE3`的新特性之一，[Teleport](https://cn.vuejs.org/guide/built-ins/teleport.html)。\\n\\nVUE3官网描述：\\n> `<Teleport>` 是一个内置组件，它可以将一个组件内部的一部分模板“传送”到该组件的 DOM 结构外层的位置去。\\n\\n\\n## Teleport\\n有些同学可能没用过Teleport，所以可能也不了解我为啥会说这个Teleport不太好用。\\n来看一下我下面这个例子。\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e1b8da00b0142d6a14f1af43e4558c2~tplv-k3u1fbpfcp-watermark.image?)\\n\\n如上图所示，这个叫“关于”的页面，是一个项目中所有页面的列表，这个页面上面有一个标题栏，标题栏右边是一个按钮。\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/86cffece11764562abe64cf2143c89a5~tplv-k3u1fbpfcp-watermark.image?)\\n这一张图，这个叫做“Home”的页面，也有一个标题栏，标题栏右边也是一个按钮，只不过按钮文字不一样。\\n\\n移动端的项目，很多页面都有这种标题栏，我们在开发时基本上都要对这个标题栏封装一下。一般有两种思路：\\n1. 封装成一个组件，页面内需要标题栏的就写上组件，然后设置标题什么的，我个人感觉这种不太优雅，需要每次都要在页面里写一个这个东西，稍微有一点点繁琐，大概是这样👇。\\n```html\\n<template>\\n  <app-bar title=\\\"订单详情\\\">\\n      <template #right>\\n        <button>保存</button>\\n      </template>\\n    </app-bar>\\n  <div class=\\\"home col\\\">\\n    <span>测试测试测试</span>\\n    <button @click=\\\"ttt\\\">测试接口</button>\\n  </div>\\n</template>\\n```\\n2. 把标题栏封装在路由根页面里，然后把标题内容什么的设置在路由`meta`上，由根页面去维护这个标题栏，大概是这样👇。\\n- 路由文件\\n```ts\\nconst routes: RouteRecordRaw[] = [\\n  {\\n    path: '/',\\n    name: 'Index',\\n    redirect: '/home'\\n  },\\n  {\\n    path: '/home',\\n    name: 'Home',\\n    component: () => import('@/views/Home/index.vue'),\\n    meta: {\\n      title: 'Home',\\n    }\\n  },\\n  {\\n    path: '/test',\\n    name: 'Test',\\n    component: () => import('@/views/Test/index.vue'),\\n    meta: {\\n      title: '测试',\\n    }\\n  },\\n  {\\n    path: '/about',\\n    name: 'About',\\n    component: () => import('@/views/About/index.vue'),\\n    meta: {\\n      title: '关于',\\n    }\\n  }\\n]\\n```\\n- 路由根页面\\n```ts\\n<script setup lang=\\\"ts\\\">\\n  import { useRoute } from 'vue-router'\\n\\n  const currentRoute = useRoute()\\n</script>\\n\\n<template>\\n  <div class=\\\"col\\\">\\n    <app-bar :title=\\\"currentRoute.meta.title\\\" />\\n    <router-view />\\n  </div>\\n</template>\\n```\\n\\n我呢，本着优雅的原则，自然是选了第2种方式了，但是随着业务复杂起来，我发现第二种方法也没那么优雅了。\\n\\n## 问题\\n\\n问题，就出现在标题栏右边这个`button`上。大部分页面不需要这个`标题栏`右侧显示东西的，少部分页面需要显示一个`保存`、`新建`按钮，还有的页面要显示一个切换状态的`switch`组件，甚至还有要显示各种颜色表示状态的图标的。这样一来就很麻烦了，在`meta`上配置文字什么的，肯定满足不了设计的脑洞了。\\n\\n### 解决方案\\n\\n挠头之际，我想起来当时看`VUE2`升级`VUE3`指南时看到的`Teleport`组件了，寻思这玩意简直为这需求而生啊。\\n\\n页面需要什么`按钮、图标、switch`，直接用`Teleport`“传”到路由根页面去不就完事了么，看起来非常的简单便捷。\\n> `<Teleport>` 接收一个 `to` prop 来指定传送的目标。`to` 的值可以是一个 CSS 选择器字符串，也可以是一个 DOM 元素对象。这段代码的作用就是告诉 Vue“把以下模板片段**传送到 `body`** 标签下”。\\n\\n但是等我真正用到项目中的时候，发现并不是那么简单。我之前为了优化用户体验，给页面切换加了个前进后退的动画效果，这俩一组合，效果就不太符合预期了。\\n\\n- 页面结构长这样\\n```html\\n<template>\\n    <router-view v-slot=\\\"{ Component, route }\\\">\\n      <transition :name=\\\"transitionName\\\" @after-enter=\\\"afterEnter\\\">\\n        <!-- 没有key的话,vue的动画无法生效 -->\\n        <div :key=\\\"route.path\\\" class=\\\"col page-body\\\">\\n            <app-bar\\n              :title=\\\"route.meta.title\\\"\\n            />\\n              <div class=\\\"page-sc\\\">\\n                <component :is=\\\"Component\\\" ref=\\\"currentPageComponent\\\" />\\n              </div>\\n        </div>\\n      </transition>\\n    </router-view>\\n</template>\\n```\\n- 效果是这样\\n![test6.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a0e2f8104cf4a1d906ed674aaa52dc4~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n可以看到，在我点击“Home”页面的瞬间，右上方有一个按钮短暂出现了一帧，然后就消失了。\\n我用别的动画复现，发现结果也不一样，有的情况不带动画也不能正常显示。后来忙需求，也没精力一直去研究这个，就随便换个方法绕过去了，直到我前段时间发现了怎么在[VUE3的模板语法中渲染JSX](https://juejin.cn/post/7176563708288565305)。\\n\\n## 解法\\n众所周知，不管是`JSX`还是`Template模板语法`，最后都是生成的虚拟dom对象，既然是对象，那就可以传递，那在**A组件**中写`JSX`然后把结果传递**B组件**，然后在**B组件**中渲染，就可以做到将视图传递到指定位置渲染的目的了。\\n\\n我这里需求是**子组件**传递给**父组件**，就用`provide`+`inject`传递。用法看[这里](https://cn.vuejs.org/guide/components/provide-inject.html)。\\n思路有了，看看实现👇\\n- 父组件\\n```ts\\n<script setup name=\\\"Father\\\" lang=\\\"ts\\\">\\n  import { provide, ref } from 'vue'\\n  import Child from './child.vue'\\n\\n  const teleportView = ref(null)\\n\\n  provide('teleportViewCenter', {\\n    update(view: any) {\\n      teleportView.value = view\\n    }\\n  })\\n</script>\\n\\n<template>\\n  <div class=\\\"col\\\">\\n    <span>我是父组件</span>\\n    <component :is=\\\"teleportView\\\" />\\n    <Child />\\n  </div>\\n</template>\\n```\\n\\n- 子组件\\n```ts\\n<script setup name=\\\"Child\\\" lang=\\\"tsx\\\">\\n  import { inject } from 'vue'\\n\\n  const viewCenter = inject<any>('teleportViewCenter')\\n\\n  function renderJSX() {\\n    return <button>按钮A</button>\\n  }\\n\\n  viewCenter.update(renderJSX())\\n</script>\\n\\n<template>\\n  <div class=\\\"col\\\">我是子组件</div>\\n</template>\\n<style lang=\\\"less\\\" scoped></style>\\n```\\n\\n- 效果图\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a518f202ccb847a08e39d69d13e1cdf4~tplv-k3u1fbpfcp-watermark.image?)\\n\\n可以看到按钮能正常显示了🏄‍♀️，然后让我们做一点优化。\\n\\n## 优化\\n\\n### 视图更新\\n首先就是更新视图的问题，我们现在渲染的这个按钮是死的，不能动，这肯定不符合需求。所以要改造成活的。\\n- 子组件\\n```ts\\n<script setup lang=\\\"tsx\\\">\\n  import { inject, ref, watch } from 'vue'\\n\\n  const viewCenter = inject<any>('teleportViewCenter')\\n\\n  const loading = ref(false)\\n\\n  // 按钮点击事件，切换loading的值\\n  function triggerStatus() {\\n    loading.value = !loading.value\\n  }\\n\\n  function renderJSX() {\\n    return <button onClick={triggerStatus}>{loading.value ? '正在加载' : '按钮A'}</button>\\n  }\\n\\n  // 监听到loading变化时，通知父组件更新视图\\n  watch(\\n    loading,\\n    () => {\\n      viewCenter.update(renderJSX())\\n    },\\n    {\\n      immediate: true\\n    }\\n  )\\n</script>\\n\\n<template>\\n  <div class=\\\"col\\\">我是子组件</div>\\n</template>\\n```\\n- 效果\\n\\n![test4.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/07124ff378364835be22e9fe92dfd11a~tplv-k3u1fbpfcp-watermark.image?)\\n\\n不过这样写有点麻烦，你也可以这么写👇\\n```ts\\n\\n  // watch(\\n  //   loading,\\n  //   () => {\\n  //     viewCenter.update(renderJSX())\\n  //   },\\n  //   {\\n  //     immediate: true\\n  //   }\\n  // )\\n  \\n  // 监听到loading变化时，通知父组件更新视图\\n  watchEffect(() => {\\n    viewCenter.update(renderJSX())\\n  })\\n```\\n这样不仅用的代码更少，而且可以追踪`renderJSX()`中用到的所有依赖的变化。\\n\\n### 销毁视图\\n一般情况下，子组件在销毁时也要顺带销毁子组件传递出去的内容，我们这里在`onUnmounted`中通知父组件销毁自身。\\n- 父组件\\n```ts\\n<script setup name=\\\"Father\\\" lang=\\\"ts\\\">\\n  import { provide, ref } from 'vue'\\n  import Child from './child.vue'\\n\\n  const teleportView = ref(null)\\n\\n  // 控制子组件显示/隐藏的开关\\n  const showChild = ref(false)\\n\\n  provide('teleportViewCenter', {\\n    update(view: any) {\\n      teleportView.value = view\\n    },\\n    destroy() {\\n      teleportView.value = null\\n    }\\n  })\\n</script>\\n<template>\\n  <div class=\\\"col\\\">\\n    <span>我是父组件</span>\\n    <button @click=\\\"showChild = !showChild\\\">展示/隐藏子组件</button>\\n    <component :is=\\\"teleportView\\\" />\\n    <Child v-if=\\\"showChild\\\" />\\n  </div>\\n</template>\\n```\\n- 子组件\\n```ts\\n<script setup lang=\\\"tsx\\\">\\n  import { inject, ref, onUnmounted, watchEffect } from 'vue'\\n  \\n  const viewCenter = inject<any>('teleportViewCenter')\\n  const loading = ref(false)\\n\\n  // 按钮点击事件，切换loading的值\\n  function triggerStatus() {\\n    loading.value = !loading.value\\n  }\\n\\n  function renderJSX() {\\n    return <button onClick={triggerStatus}>{loading.value ? '正在加载' : '按钮A'}</button>\\n  }\\n\\n  // 监听到loading变化时，通知父组件更新视图\\n  watchEffect(() => {\\n    viewCenter.update(renderJSX())\\n  })\\n\\n  // 在自身被销毁时，通知父组件销毁传递的view\\n  onUnmounted(() => {\\n    viewCenter.destroy()\\n  })\\n</script>\\n\\n<template>\\n  <div class=\\\"col\\\">我是子组件</div>\\n</template>\\n```\\n- 效果图\\n![test5.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/412e4dfa169a438080ecd7cfb849fd70~tplv-k3u1fbpfcp-watermark.image?)\\n\\n### 性能优化\\n很简单，把`ref`换成`shallowRef`就好了，`shallowRef`使用文档看[这里](https://cn.vuejs.org/api/reactivity-advanced.html#shallowref)。\\n```ts\\n  import { provide, ref, shallowRef, triggerRef } from 'vue'\\n\\n  //const teleportView = ref(null)\\n  const teleportView = shallowRef(null)\\n  \\n  provide('teleportViewCenter', {\\n    update(view: any) {\\n      teleportView.value = view\\n      // view为null时，再更改view的value，不能正常触发更新，这里手动触发一下\\n      triggerRef(teleportView)\\n    },\\n    destroy() {\\n      teleportView.value = null\\n    }\\n  })\\n```\\n父组件中保存`view`并不需要把`view`对象递归转为响应式的，`view`变化时，我们是整个换掉的。（不过这也要求传递的视图最好不要搞得太复杂）\\n> `shallowRef()` 和 `ref()` 不同，浅层 ref 的内部值将会原样存储和暴露，并且不会被深层递归地转为响应式。只有对 `.value` 的访问是响应式的。\\n`shallowRef()` 常常用于对大型数据结构的性能优化或是与外部的状态管理系统集成。\\n\\n### 代码封装\\n效果还是ok的，就是用起来稍显繁琐，我们可以用`hook`来个极简封装👇\\n- useTeleportView.ts\\n```ts\\nimport { shallowRef, provide, inject, onUnmounted, watchEffect, triggerRef } from 'vue'\\n\\nexport interface TeleportViewCenter {\\n  update: (view: JSX.Element | null) => void\\n  destroy: () => void\\n}\\n\\nexport function useTeleportSite(name: string) {\\n  const view = shallowRef<JSX.Element | null>(null)\\n\\n  const siteInstance: TeleportViewCenter = {\\n    update(newView) {\\n      view.value = newView\\n      // view为null时，再更改view的value，不能触发更新\\n      triggerRef(view)\\n    },\\n    destroy() {\\n      view.value = null\\n    }\\n  }\\n\\n  provide(name, siteInstance)\\n\\n  return view\\n}\\n\\nexport function useTeleportView(name: string, viewRender: () => JSX.Element | null) {\\n  const siteInstance = inject<TeleportViewCenter>(name)\\n\\n  const stop = watchEffect(() => {\\n    const view = viewRender()\\n    siteInstance?.update(view)\\n  })\\n\\n  onUnmounted(() => {\\n    stop()\\n    siteInstance?.destroy()\\n  })\\n}\\n\\n```\\n- 父组件中使用\\n```ts\\n<script setup name=\\\"Father\\\" lang=\\\"ts\\\">\\n  import { ref } from 'vue'\\n  import Child from './child.vue'\\n  import { useTeleportSite } from '@/hooks/useTeleportView'\\n\\n  const showChild = ref(false)\\n\\n  const teleportView = useTeleportSite('teleportViewCenter')\\n</script>\\n\\n<template>\\n  <div class=\\\"col\\\">\\n    <span>我是父组件</span>\\n    <button @click=\\\"showChild = !showChild\\\">展示/隐藏子组件</button>\\n    <component :is=\\\"teleportView\\\" />\\n    <Child v-if=\\\"showChild\\\" />\\n  </div>\\n</template>\\n```\\n- 子组件中使用\\n```ts\\n<script setup lang=\\\"tsx\\\">\\n  import { ref } from 'vue'\\n  import { useTeleportView } from '@/hooks/useTeleportView'\\n\\n  const loading = ref(false)\\n\\n  // 按钮点击事件，切换loading的值\\n  function triggerStatus() {\\n    loading.value = !loading.value\\n  }\\n\\n  useTeleportView('teleportViewCenter', () => {\\n    return <button onClick={triggerStatus}>{loading.value ? '正在加载' : '按钮A'}</button>\\n  })\\n</script>\\n\\n<template>\\n  <div class=\\\"col\\\">我是子组件</div>\\n</template>\\n```\\n\\n## 总结\\n\\n🎉这次的分享到这里就结束啦，俗话说没有最好的技术，只有最合适的技术，这种写法比较适用于原生`Teleport`不太好用的时候，希望你能用的开心。\\n\\n-------------------------\\n哦，对了，来看看我最后的效果\\n\\n![test6.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76e46078ec6a4c999aed3511dedfa833~tplv-k3u1fbpfcp-watermark.image?)\\n\\n-----------------------\\n封装`hook`能很大程度解放程序员的双手，我猜你也会想看看这个👇\\n- [【VUE3】写hook三天，治好了我的组件封装强迫症。 - 掘金 (juejin.cn)](https://juejin.cn/post/7181712900094951483)",
        "tags": [
            "Vue.js",
            "TypeScript",
            "前端"
        ]
    },
    {
        "article_id": "7184615120708829221",
        "cover_image": "https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9affedaa0ba04793923184b4d879e928~tplv-k3u1fbpfcp-watermark.image?",
        "title": "身处井隅，心向璀璨，2022年终总结",
        "brief": "「回顾2022，展望2023，我正在参与2022年终总结征文大赛活动」 开始之前 现在时间是2023年1月1日 10时29分， 今年写年终总结的时间比以往都晚了些。",
        "user_name": "IamZJT_",
        "view_count": 1978,
        "collect_count": 3,
        "comment_count": 24,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/988fa2d1bc57bf0f378256489e5ef369~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: channing-cyan\\n---\\n\\n「回顾2022，展望2023，我正在参与[2022年终总结征文大赛活动](https://juejin.cn/post/7172462429929111559 \\\"https://juejin.cn/post/7172462429929111559\\\")」\\n\\n### 开始之前\\n\\n现在时间是**2023年1月1日 10时29分**，  \\n今年写年终总结的时间比以往都晚了些，  \\n自从🐏了以后就没啥状态，  \\n可能也是给自己找借口。  \\n\\n各种 *“摸鱼（没学习）”*，打游戏，  \\n持续了得有十来天了。  \\n朋友笑称说：可能是前段时间太规律了吧，  \\n确实，还记得上一次早起还是🐏了的第一天。  \\n\\n从来没觉得熬夜这么爽过，  \\n**元旦**第一天，  \\n熬夜看完了 **《回家的女儿》**，  \\n别看，烂剧。  \\n也不知道怎么的，  \\n就给熬夜看完了，  \\n可能就是报复性熬夜吧。  \\n也可能潜意识里觉得：  \\n**人生苦短，及时行乐**\\n\\n经过*元旦三天躺*，  \\n也该起来了，  \\n自从上次手肘受伤，  \\n加上🐏了。  \\n已经差不多一个多月，  \\n没怎么健身了，  \\n今晚想着怎么也得去浅练个背。\\n\\n疫情，只是路过。  \\n生活，还要继续。  \\n不过这 *“兵荒马乱”* 的一年也是结束了啊！  \\n最起码过的比我想象的快很多。  \\n\\n大家都调侃，    \\n疫情三年：我没阳。  \\n三年后：我大抵是阳了。  \\n不过疫情无情人有情，  \\n大家伙也都是有趣的，  \\n还有各种搞笑的文案：  \\n*“天是阴的，我是阳的。”*  \\n*“头不是头，是旋转的地球。”*  \\n*“抗原两道杠，一道是我的，另一道也是我的。”*  \\n\\n### 交作业\\n\\n#### 1. 学习\\n\\n[去年](https://juejin.cn/post/7045273126426394637)定的2022年学习目标是*300小时*。\\n\\n今年的总学习时长：**381个小时**，  \\n比起去年是有进步的，  \\n倒不是说今年工作不忙，  \\n而是今年的规划更加合理，  \\n也更愿意去挤时间。  \\n说到这个，  \\n还得益于**早起**。  \\n\\n<img width=\\\"90%\\\" src=\\\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3099b488c3ad4f8e83f421b8894d4db7~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"2022年学习时长\\\" />\\n\\n记得之前，  \\n总是平衡不了**学习与锻炼**。  \\n现在，  \\n早起5点学习，  \\n晚上锻炼。  \\n甚至早上没那么冷的时候，  \\n还能爬楼梯大半个小时，  \\n一百多层，  \\n有氧唤醒身体，  \\n真的很不错。  \\n\\n早起持续了**49天**，  \\n🐏了以后就中断了，  \\n现在继续冲...\\n\\n<img width=\\\"90%\\\" src=\\\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a3c57168b904b06908afa1dad8526a5~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"5点起床\\\" />\\n\\n今年 *微信读书* 读完**8本书**，  \\n目前正在看的有两本实体书：  \\n*《Vue.js设计与实现》*  \\n*《Vue.js技术内幕》*  \\n非常不错的两本**vue源码**书籍，强烈推荐！！  \\n\\n<img width=\\\"90%\\\" src=\\\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5f0244ee2eb04f6686d3b842d99b2efe~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"微信读书\\\" />\\n\\n喜马拉雅听了**83.5小时**，  \\n听完了**5本书**。  \\n收获最大的应该是 **《4点起床：晨型人时间管理术》**，  \\n比起其他听起来觉得超级有道理的书，  \\n这本书真的实实在在的带来了收益。  \\n直接就是实践。  \\n\\n早起学习，  \\n精神状态真的非常好，  \\n但是前期会有几天的适应期，  \\n也就是*痛苦期*。  \\n自我感觉良好以后，  \\n才建了一个[早起俱乐部](https://juejin.cn/pin/7173512204149325861)。  \\n有一起的小伙伴，  \\n可以跟我一起冲...\\n\\n<img width=\\\"90%\\\" src=\\\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a17c390465184256a441ca09443b5590~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"喜马拉雅\\\" />\\n\\n今年还学习了**node**和**vim**，  \\n现在用的是**ideavim**，  \\n如愿以偿成为了 *“键盘侠”*，  \\n全键盘工作者，  \\n虽然还不太熟练，  \\n但是已经好很多了。  \\n\\n目前正在写**mini-vue**，  \\n掘金也建了专栏，  \\n[# 手写mini-vue3，打造自己的Vue3框架](https://juejin.cn/column/7168612212133593095)，  \\n同步更新的系列文章也写了 *14* 篇了，  \\n🐏了以后，有好多天没更新了，  \\n现在继续。  \\n\\n还建了另外一个专栏：  \\n[# Vue3源码共读，逐行注释源码](https://juejin.cn/column/7168965555922141215)，  \\n也是个需要付出大量时间挖掘的 *“深坑”*，  \\n还未开始更新，  \\n当然这也是给**2023**计划的。\\n\\n<img width=\\\"90%\\\" src=\\\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da920188e81c473ebade89fe35174389~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"2022年github 提交记录\\\" />\\n\\n#### 2. 锻炼\\n\\n今年的总健身时长：**99个小时**。  \\n\\n<img width=\\\"90%\\\" src=\\\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/958e3b3988b7433292432a692b7f078e~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"2022年健身时长\\\" />\\n\\n8月8号，  \\n全民健身节，  \\n办了健身卡，  \\n在媳妇儿的指导下，  \\n开始了菜鸟健身。  \\n\\n[去年](https://juejin.cn/post/7045273126426394637)计划是健身**60h**，  \\n9月份就完成了，  \\n然后临时把目标翻了个倍**120h**，  \\n结果11月中手肘还受伤了，  \\n目标没完成。  \\n不过按照原定的计划，  \\n也是完成了健身目标的。  \\n逻辑鬼才...🤣\\n\\n#### 3. 立flag\\n\\n1. 学习时长：**500h**\\n2. 健身时长：**200h**\\n\\n<img width=\\\"90%\\\" src=\\\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da15a297359d40558b6c593c258c190e~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"2023年健身目标\\\" />\\n\\n对我来说，  \\n按照现有的节奏，  \\n并不是特别难的目标，  \\n只希望，  \\n明年别被打脸。😅  \\n\\n### 重要的事\\n其实今年这篇年终总结，  \\n对我自己而言，  \\n最重要的就是这个小章节。  \\n我准备跟**两年后的自己**来一场对话。  \\n\\n两年时间，  \\n说长不长，  \\n说短，也绝对不短，  \\n够做些什么，  \\n也足够实现些什么了。\\n\\n我们先闲聊两句吧！  \\n最近过的好吗？（记得[展开说说](https://jikipedia.com/definition/403661771?ref=toutiao_qa)，哈哈哈😂）  \\n现在在哪工作啊？  \\n是自己喜欢的城市吗？🏙️  \\n这两年去哪玩了啊？  \\n\\n下面开始死亡话题了，  \\n千万别烦现在的我啊，  \\n可能有点唠叨。  \\n\\n年薪多少啊？💰  \\n上来就是劲爆话题啊。  \\n\\n前端的技术，  \\n学习的怎么样啊？  \\n也不知道现在是什么技术栈了，  \\n记得报备一下啊。\\n\\n最近有没有继续看书啊？📚  \\n说说书单瞧瞧。  \\n喜马拉雅有没有听到好的书啊？  \\n偷偷问问你，  \\n两年后梁博出新歌了吗？👨‍🎤  \\n听了没，好听不？\\n\\n家庭怎么样啊？  \\n有没有常回家和丈母娘家看看啊？\\n这里多唠叨两句，  \\n你也老大不小了，  \\n两边家长也都年龄大了，  \\n没事多回家看看，🚗  \\n两天时间还抽不出来吗？对吧。  \\n\\n媳妇儿怎么样啊？    \\n我这里再唠两句哈，  \\n我跟你说哦，  \\n人生最大的投资就是：善待妻子。  \\n有句话说：“父母决定了你的起点，而妻子决定了你的终点。”  \\n两个人一起，  \\n好好生活，  \\n生活不仅仅是**一日三餐，一年四季**，  \\n记得偶尔来点**小惊喜**🌼哦。  \\n有心才能同行，  \\n有爱才能共鸣。  \\n好好对待彼此啊！\\n\\n其他的，  \\n暂时也不知道问些啥了。  \\n你还有啥好消息，  \\n记得跟我分享一下啊！  \\n两年后的自己。  \\n两年前的你，  \\n此时此时，  \\n也正在努力前行呢，  \\n*初心如磐，奋楫笃行。*  \\n\\n### 要做的事\\n\\n先来汇报一下今年的吧。\\n\\n去年说今年要去**迪士尼**，  \\n结果还是没去成，  \\n圣诞前还打算去**滑雪**，  \\n结果🐏了。  \\n\\n6月，  \\n见了一下狗辉，  \\n咖啡馆畅谈了一下午，  \\n大家都长大了啊。  \\n\\n10月，  \\n参加了小坤坤的婚礼，  \\n祝*99*啊！   \\n中间还叫远哥出来玩了一下滑板。  \\n\\n中秋，  \\n和没回家的朋友，  \\n一起打了羽毛球，  \\n一起聚了聚，  \\n喝了点精酿。  \\n\\n今年：  \\n\\n1. 一定要去一次**迪士尼**，疫情结束，此时不去，更待何时。  \\n2. 说走就走的**旅行**，这个哪能少。  \\n3. 朋友嘛，多聚聚。**愿岁并谢，与长友兮**。\\n\\n### 结语\\n\\n两年后的你，  \\n希望你很有力量。  \\n能够允许一切发生。  \\n真正的强大不是对抗，  \\n而是允许和接受，  \\n允许世事无常，  \\n允许遗憾，  \\n允许短浅的存在，  \\n允许不被喜欢。\\n\\n等你允许一切发生后，  \\n会逐渐变成一个放松而柔软的人，  \\n不会再因为某件事或某个人左右情绪。  \\n\\n生活不过是*见招拆招*，  \\n你害怕或者担心的事如果发生了，  \\n就坦然面对它吧。  \\n这是一种松弛感思维，  \\n也是一种反脆弱的思维。  \\n\\n渐渐把 *“为什么这件事会发生在我身上”*，  \\n变成了 *“这件事的发生会带给我怎样的成长”*，  \\n境随心变，  \\n当我们的心变强了，  \\n困难也就弱了。  \\n\\n最后的最后：  \\n我的 *“好伙伴”*，  \\n你要加油哦。🥳  \\n\\n别偷懒！  \\n我们好像正值八九点钟的太阳一样闪耀。🌞  \\n**东隅已逝，桑榆非晚。**  \\n别着急！  \\n步伐虽小，但不要放弃。      \\n余味苦涩，也要勤恳付出。  \\n**开在废墟里的玫瑰依然浪漫，我们走的每一步都有意义。**  \\n别气馁！  \\n哪怕现在乌云密布，  \\n向上爬就是晴空万里。  \\n**虽身处井隅，但我们，心向璀璨。**  ",
        "tags": [
            "年终总结",
            "程序员",
            "前端"
        ]
    },
    {
        "article_id": "7191357386139893817",
        "cover_image": "https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1fe103e27fe44aafa9d8177c8c6089cd~tplv-k3u1fbpfcp-watermark.image?",
        "title": "如何使用 TS  快速编写一个自己的 Github Action",
        "brief": "前言 在工程化大行其道的当下，travis、jenkins、vercel 等 CICD 平台或工具的兴起有效简化了我们原有的一些手动网站部署的工作，我们只需要将代码推送到远端就能自动帮我们进行网站的构",
        "user_name": "陌小路",
        "view_count": 3863,
        "collect_count": 22,
        "comment_count": 2,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/6b860be6d245b178e0c8e9f8998e9fd5~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: qklhk-chocolate\\n---\\n## 前言\\n\\n> 如果你的某项工作流程出现了多次重复性机械操作，那么你就该思考更好的优化手段了。\\n\\n在工程化大行其道的当下，travis、jenkins、vercel 等 CICD 平台或工具的兴起有效简化了我们原有的一些手动网站部署的工作，我们只需要将代码推送到远端就能自动帮我们进行网站的构建与部署，非常方便。\\n\\n笔者最开始使用的是 travis，只需要进行简单的几项配置之后，就能满足笔者更新完文档之后，自动构建并部署到 github-pages了。但其实用过 github-pages 的同学应该也感受过它那可叹的访问速度，所以笔者把目光投向了 vercel，它支持将你的项目构建并发布到 vercel 的服务上，相比于 github-pages，它的速度还是稍微快点的。\\n\\n不过后来似乎 vercel 的站点开始被墙了，所以为了访问的考虑，笔者还是准备将网站部署到自己的服务器上，这样速度会更快点；不过这次笔者选择了更加方便的 github actions，能非常方便的定制自己的 pipeline，不用外接其他服务，同时还有很多好用的现成 action 可以直接集成，说干就干！\\n\\n## 快速上手\\n\\nGitHub Actions 是一种持续集成和持续交付(CI/CD) 平台，可用于自动执行生成、测试和部署管道。\\n\\n这里放了一句官网给出的基础的介绍，大致知道下是个什么东西，更详细的概述可以 Google 一下，这里就不过多赘述了。\\n\\n用白话文介绍下就是可以监听一些操作比如 push 或者 pr 之类的事件，然后给一个临时容器帮你跑一些命令进行构建部署之类的。\\n\\n官方文档：[传送门](https://docs.github.com/zh/actions/quickstart)\\n\\n### 创建一个基础的 workflow\\n\\n首先你随便找一个自己的 github 仓库，在仓库下新建一个 .github 文件夹，然后再建一个 workflows 文件夹，再在这个 workflows 建一个 deploy.yml 文件，文件内容可大致如下：\\n\\n```yml\\nname: GitHub Actions Demo\\nrun-name: Github Actions\\non: [push] # 监听事件\\njobs:\\n  Explore-GitHub-Actions:\\n    runs-on: ubuntu-latest # 运行的镜像\\n    steps:\\n      - run: echo \\\"冲！\\\" # 执行的命令\\n      - name: Check out repository code\\n        uses: actions/checkout@v3 # 拉取当前仓库代码到容器中\\n```\\n\\n这里简单设置了一下什么时候该执行该 workflow，然后声明了一下执行的容器为 ubuntu，也是比较常用的，然后你就能在 steps 下编写需要执行的具体步骤了，这里主要做了两件事，第一个 run 就是打印了一个 `冲！` 的日志，然后第二部就是借助了官方提供的 checkout action 来进行仓库的拉取，可以非常方便的把你当前仓库的代码拉到容器当前执行目录下，当然你也设置一些参数进行更精细化的控制，这里你直接翻阅他的文档就好了。\\n\\ncheckout actions 文档：[传送门](https://github.com/actions/checkout)\\n\\n当然了，这里只是给大家一个基本的使用，具体的 workflow 的使用倒不是本文的重点，详细的介绍可以翻看官方给出的文档，后面笔者也会具体聊一些常用配置。\\n\\n下面就让我们开始编写一个自己的 github action 吧。\\n\\n### 创建一个 Action 仓库\\n\\n第一步，打开你的 github，然后创建一个 git 仓库，接着拉到本地。\\n\\n#### 基于模板仓库创建（推荐）\\n\\n直接使用笔者提供的 action 仓库模板创建。\\n\\n1. 打开模板仓库：[传送门](https://github.com/STDSuperman/action-template)\\n2. 如图点击使用模板创建仓库\\n![模板仓库创建](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/25f15a3237284a698769edb1b728cadc~tplv-k3u1fbpfcp-zoom-1.image)\\n3. 将创建好的代码拉到本地\\n\\n#### 手动初始化\\n\\n1. 打开笔者的模板仓库：[传送门](https://github.com/STDSuperman/action-template)\\n2. 复制仓库代码配置文件到你的仓库中\\n\\n### 使用自己的 Action\\n\\n如果你按照笔者上述初始化完成之后，项目根目录应该会有一个 `.github/workflow/test.yml` 文件，那么打开它可以看到如下代码：\\n\\n```yml\\non: [push]\\n\\njobs:\\n  DeployTest:\\n    runs-on: ubuntu-latest\\n    name: TestJob\\n    steps:\\n      - uses: actions/checkout@v2 # 第一步，下载代码仓库\\n      \\n      - name: TestStep\\n        id: Test\\n        uses: STDSuperman/action-template@master # 运行你自己的 action\\n        with: # 给你的 action 传参\\n          host: 'aa.bb.cc.dd'\\n```\\n\\n这里主要看几个配置：\\n\\n- `on`: 指定在什么阶段运行你的 action\\n- `runs-on`: 指定你运行的容器镜像，最终你的后续步骤会在这个容器里运行\\n- `uses`: 该指令可以让你直接使用已有的 action 功能，如`actions/checkout@v2` 这个上文已经介绍过了，用来拉取当前项目仓库的。\\n- `with`: 该指令可以用来给指定 action 进行传参，后面也会介绍，这里配了之后运行时可以通过 github 官方提供的工具库直接读取到。\\n\\n好了，知道了如何使用已有的 action 之后，我们就可以配置下让他使用我们自己现在正在开发的 action 进行测试了，也就是下面那个 `uses: STDSuperman/action-template@master`，这里你需要改一下，把 `STDSuperman/action-template` 改成你自己的 github 用户名和你当前自定义 action 的仓库名，后面的 `@master` 表示的是直接用 master 分支的代码来运行，当然你也可以指定成你自己的打的 tag，比如 v1 啥的。\\n\\n这里笔者直接用 master 分支来进行测试了，本地配置完之后，我们就可以直接 push 到远端仓库了，然后再打开你的 github 仓库，找到 Actions 这个 tab，下面就可以看到你的 action 在运行了，你可以点开查看你的日志，如果你用的是笔者的默认模板代码的话，应该可以看到打印出你传入的 host 参数值。\\n\\n![Actions](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/341ce38dd126495db2fd6b201ece0dac~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n### 配置 Action Secret\\n\\n#### 为什么需要 Action Secret\\n在一些情况下，你需要给你自己的 action 或者是官方提供的 action 进行传参，但是又不想暴露自己的这部分私密数据，那么你就需要新建一个自己的 Secret ，并把传参方式改成从运行环境中读取，举个🌰：\\n\\n```yml\\non: [push]\\n\\njobs:\\n  DeployTest:\\n    runs-on: ubuntu-latest\\n    name: TestJob\\n    steps:\\n      - uses: actions/checkout@v2 # 第一步，下载代码仓库\\n      \\n      - name: TestStep\\n        id: Test\\n        uses: STDSuperman/action-template@master # 运行你自己的 action\\n        with: # 给你的 action 传参\\n          host: ${{ secrets.SERVER_HOST }}\\n```\\n\\n还是以上面笔者提供的例子来改一下，上面我们是以明文传递的这个 host 参数，现在我们不想让别人看到我们的服务器地址，那么我就需要使用 Secret 这个功能了，读取方式就直接按上述示例 host 的取值方式，这里的 `SERVER_HOST` 就是你创建的 secret 名。\\n\\n那么如何新建一个 secret 呢？往下走。\\n\\n#### 新建新的 Action Secret\\n\\n![创建 Secret](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d40c51b211294b618e22a749f1a830b3~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n如图所示，找到需要使用该 secret 的仓库，然后 新建一个 secret，name 就写你后续需要在 action 中读取的变量名，下方的内容就写你需要加密的值。\\n\\n比如上面笔者的例子，笔者新建了一个名叫 `SERVER_HOST` 的 secret，然后把我的服务器 IP 放进去，然后再在 Action 中用 `secrets.SERVER_HOST` 访问就好了，这个 `secrets` 是运行时的环境变量，它会读取你创建的 Secret 然后放到这个对象中供你访问。\\n\\n> 记住，这个 secret 是创建在你要用的那个仓库里的，也就是你编写 yml 文件的那个仓库，别创建到你开发的 action 仓库里了。\\n\\n## 实战\\n### 使用 Action 进行网站部署\\n\\n这里笔者将以一个简单的实战案例来带你玩转 github action。这个 action 其实也是笔者前段时间需要把自己的个人博客迁移到自己的服务器进行部署的时候写的一个工具，顺便也熟悉一下如何编写一个 github action。\\n\\n同样的，你可以先基于上述创建好的模板仓库进行后续的代码开发。\\n\\n### 基础功能\\n\\n一个网站自动部署的 workflow 应该至少具备一下几种能力：\\n\\n1. 拉取目标仓库代码\\n2. node 环境准备 & 项目依赖安装\\n3. 代码构建\\n4. 产物推送到服务器\\n5. 在服务端执行一些命令\\n\\n对于前三点，因为都是非常通用的能力，所以直接采用了官方提供的 action 或 workflow 的能力就能完成，所以自定义的 action 就主要实现后面两点。\\n\\n前三点对应的 workflow 大致如下：\\n\\n```yml\\nname: Deploy Doc Site\\n\\non:\\n  push:\\n    branches:\\n      - master # 只在master上push触发部署\\n    paths-ignore: # 下列文件的变更不触发部署，可以自行添加\\n      - README.md\\n      - LICENSE\\n\\njobs:\\n  deploy:\\n    runs-on: ubuntu-latest # 使用ubuntu系统镜像运行自动化脚本\\n\\n    steps: # 自动化步骤\\n      - uses: actions/checkout@v2 # 第一步，下载代码仓库\\n\\n      - name: Set node version 16 # 第二步安装 node 环境\\n        uses: actions/setup-node@v3\\n        with:\\n          node-version: 16\\n\\n      - name: Install Deps # 安装项目依赖\\n        run: npm install\\n\\n      - name: Build # 项目构建\\n        run: npm run build\\n\\n      - name: Deploy to Server # 推文件\\n        id: DeployServer\\n        uses: STDSuperman/deploy-files@master\\n        with:\\n          host: ${{ secrets.SERVER_HOST }}\\n          user: ${{ secrets.SERVER_USER }}\\n          port: '22'\\n          password: ${{ secrets.SERVER_PASSWORD }}\\n          targetPath: '/home/website/docs'\\n          sourcePath: './dist'\\n\\n```\\n\\n如上所示，笔者给出的示例项目是自己的个人博客，一个纯前端的项目，故构建需要 node 环境，这里就直接使用了官方的 action 进行 node 环境安装，同时直接使用 steps run 的方式直接执行命令安装依赖和构建；最后就是执行笔者自己编写的 action 了。\\n\\n### 构建产物推送\\n\\n```ts\\n// src/index.ts\\nimport * as core from '@actions/core'\\nimport { ScpClient } from './lib/scp-client'\\nimport { logger } from './lib/logger'\\nimport { parseCommandStr } from './utils'\\n\\nexport async function run(): Promise<boolean> {\\n  try {\\n    const host: string = core.getInput('host')\\n    const username: string = core.getInput('user')\\n    const password: string = core.getInput('password')\\n    const sourcePath: string = core.getInput('sourcePath')\\n    const targetPath: string = core.getInput('targetPath')\\n\\n    const scpClient = new ScpClient({\\n      host,\\n      port: 22,\\n      username,\\n      password,\\n    })\\n\\n    await scpClient.waitForReady()\\n    await scpClient.uploadDirectory(sourcePath, targetPath)\\n\\n    await scpClient.close()\\n    return true\\n  } catch (error) {\\n    if (error instanceof Error) {\\n      console.error(error)\\n      core.setFailed(error.message)\\n    }\\n  }\\n  return false\\n}\\n\\nrun()\\n\\n```\\n\\n这里大致介绍下代码构建，首先从读取你在 yml 文件中定义的入参，读取方式为调用官方提供的包：`core.getInput` 方法，具体的值对应的也就是上述 yml 文件中 with 指令下面传的参数，这里以入参接入的方式的好处就是你的 action 可以给不同的仓库或者别人直接使用，只需要修改入参就好了。\\n\\n参数解析：\\n\\n- `host`: 服务器 ip 地址\\n- `user`: 服务器用户名\\n- `port`: 服务器 ssh 的 服务端口，一般是 22\\n- `password`: 服务器密码\\n- `targetPath`: 需要推送到的服务器文件路径\\n- `sourcePath`: 待推送的当前构建后的产物路径，相对于容器运行的根目录，笔者这里是当前容器运行目录下的 dist 目录\\n\\n好了，这里通过 `core.getInput` 方法可以轻松拿到入参数据，然后就可以基于这些入参进行服务器的连接和推送了。\\n\\n```ts\\nconst scpClient = new ScpClient({\\n  host,\\n  port: Number(port || 22),\\n  username,\\n  password,\\n})\\n```\\n\\n这里就实例化了一个 ScpClient 实例，主要是借用了 `ssh2` 这个 npm 包做了一层文件上传和检测的封装方法，感兴趣可以看笔者的源码：[传送门](https://github.com/STDSuperman/deploy-files/blob/master/src/lib/scp-client.ts)。\\n\\n这块的具体核心逻辑如下\\n\\n```ts\\nimport { Client as SSHClient, SFTPWrapper } from 'ssh2'\\n\\nconst ssh = new SSHClient()\\n\\nssh.on('ready', () => {\\n  ssh.sftp((err, sftp: SFTPWrapper) => {\\n    this.sftpWrapper = sftp\\n\\n    // 读取笔者传入的 dist 目录下的所有文件\\n    const dirEntries = fs.readdirSync(src, {\\n      encoding: 'utf8',\\n      withFileTypes: true,\\n    })\\n\\n    // 遍历所有文件，这里笔者把对文件夹的递归逻辑先干掉了，简化了一下\\n    for (const e of dirEntries) {\\n      const newSrc = path.join(src, e.name)\\n      const newDst = this.normalizeFilePath(dest, e.name)\\n      // 拼接后上传给服务器指定目录\\n      this.sftpWrapper.fastPut(sourcePath, targetPath, options || {})\\n    }\\n  })\\n})\\n```\\n\\n这里的代码进行了大量的简化，详细逻辑见笔者仓库源码。主流程就是读取要上传的所有文件，然后拼接路径，最终利用 ssh 的连接传给服务器。\\n\\n\\n### 服务端命令执行\\n\\n为了每次新的构建都能完美替换掉旧的逻辑，或许你可能需要在推送新的文件前，把之前的产物都清理掉（不考虑清理之后和新的文件上传之前的访问  404 问题），那么就得提供一个可以执行命令的能力。\\n\\n```ts\\nconst preCommandStr: string = core.getInput('preCommands')\\nconst preCommands: string[] = preCommandStr?.split(/\\\\n+/)\\n```\\n\\n这里首先读取一下在 yml 中设置的命令参数（`preCommands`），如下示例：\\n\\n```yml\\n- name: Deploy to Server # 第二步，rsync推文件\\n  id: DeployServer\\n  uses: STDSuperman/deploy-files@master\\n  with:\\n    host: ${{ secrets.SERVER_HOST }}\\n    user: ${{ secrets.SERVER_USER }}\\n    port: '22'\\n    password: ${{ secrets.SERVER_PASSWORD }}\\n    targetPath: '/home/website/docs'\\n    sourcePath: './dist'\\n    preCommands:\\n      rm -rf /home/website/docs # clear old assets\\n      echo 'success'\\n```\\n\\n主要关注这个 `preCommands` 参数，传的值是以换行符分割的多个命令，所以上面给出的 action 使用示例里就需要 split 一下把多个命令解析出来运行。\\n\\n这里的 `preCommands` 会在上传文件之前执行，所以你可以在这里做一些清理操作。\\n\\n\\n```ts\\n// 调用 exec 函数\\nscpClient.exec(preCommands.join(' && '), '/home/test-dir')\\n\\n// exec 方法主逻辑\\nconst exec = (command: string, cwd: string): Promise<void> => {\\n  return new Promise<void>((resolve, reject) => {\\n    this.sshClient?.exec(`cd ${cwd} && ${command}`, {}, (err, channel) => {\\n      if (err) {\\n        reject(err)\\n        console.error('exec: ', err)\\n      }\\n\\n      channel.on('exit', (...args) => {\\n        resolve()\\n      })\\n    })\\n  })\\n}\\n```\\n\\n拿到需要执行的命令之后，我们就可以使用上述介绍过的 scpClient 实例来进行服务器命令执行了，这个实例也是 `ssh2` 包提供的一系列与服务器交互的工具集提供的。\\n\\n这里似乎笔者没找到它提供的 cwd 参数怎么传，也就是服务器命令执行的上下文路径，所以封装的 exec 方法你如果指定了 cwd 那么笔者就会给你的命令前面加一个 cd 到指定上下文的操作。\\n\\n当然笔者也提供了上传完文件之后的后置命令执行参数，参数名为`commands`，用法同上 `preCommands`，具体代码实现就是等上传命令执行完之后再执行。\\n\\n主流程完整代码如下\\n\\n```ts\\nimport * as core from '@actions/core'\\nimport { ScpClient } from './lib/scp-client'\\nimport { logger } from './lib/logger'\\nimport { parseCommandStr } from './utils'\\n\\nexport async function run(): Promise<boolean> {\\n  try {\\n    const host: string = core.getInput('host')\\n    const username: string = core.getInput('user')\\n    const password: string = core.getInput('password')\\n    const sourcePath: string = core.getInput('sourcePath')\\n    const port: string = core.getInput('port')\\n    const targetPath: string = core.getInput('targetPath')\\n    const commandStr: string = core.getInput('commands')\\n    const serverCwd: string = core.getInput('serverCwd') || '~'\\n    const preCommandStr: string = core.getInput('preCommands')\\n    const postCommands: string[] = parseCommandStr(commandStr)\\n    const preCommands: string[] = parseCommandStr(preCommandStr)\\n\\n    const scpClient = new ScpClient({\\n      host,\\n      port: Number(port || 22),\\n      username,\\n      password,\\n    })\\n\\n    await scpClient.waitForReady()\\n\\n    if (preCommands?.length) {\\n      logger.log('start exec pre commands...')\\n      await Promise.all(\\n        preCommands.map((command) => scpClient.exec(command, serverCwd))\\n      )\\n      logger.log('pre command exec success!')\\n    }\\n\\n    logger.log('start upload files...')\\n    await scpClient.uploadDirectory(sourcePath, targetPath)\\n    logger.log('upload success!')\\n\\n    if (postCommands?.length) {\\n      logger.log('start exec commands...')\\n      await Promise.all(\\n        postCommands.map((command) => scpClient.exec(command, serverCwd))\\n      )\\n      logger.log('command exec success!')\\n    }\\n\\n    await scpClient.close()\\n\\n    return true\\n  } catch (error) {\\n    if (error instanceof Error) {\\n      console.error(error)\\n      core.setFailed(error.message)\\n    }\\n  }\\n  return false\\n}\\n\\n!process.env.TEST && run()\\n\\n```\\n\\n完整网站部署 Action 源码地址：[传送门](https://github.com/STDSuperman/deploy-files)\\n\\n\\n### 自定义 Action 的项目配置文件解析\\n\\n#### action.yml\\n\\n```yml\\nname: 'Deploy Files And Execute Command For Github Actions'\\ndescription: 'An action that deploys the files to the server and executes some commands.'\\nauthor: 'STDSuperman'\\nbranding:\\n  icon: 'upload-cloud'\\n  color: 'orange'\\nruns:\\n  using: 'node16'\\n  main: 'dist/index.js'\\n```\\n\\n以笔者示例的项目为例，这里主要需要配置下name、description、 runs 指令，branding 这个主要是给你投到 github 的 action 市场的时候需要配的 icon 和颜色。\\n\\n- `name`: action 名字，跟用 action 的时候的那个 yml 里配置的 use 没关系，就是给你投到市场的 action 命名\\n- `description`: 描述\\n- `using`: 表示用什么环境来执行你的 action\\n- `main`: 指定运行的入口文件路径\\n\\n他这里有个注意点就是，他需要你指定的入口文件是一个完全 bundle 的也就是不依赖 node_modules 的构建好的提交上去的单文件，所以说，你的 .gitignore 就不能忽略 dist 目录，需要把他提交上去，作为最终容器运行的文件。\\n\\n所以说你就需要有个能打成单文件的构建工具。\\n\\n### Action 构建\\n官方文档倒是推荐了 ncc 这个工具来做单文件打包，笔者由于用 esbuild 用习惯了，所以项目配置了 esbuild 进行了打包能力，同时使用 husky 配置了提交之前自动执行构建的逻辑，避免你忘记构建提交上去发现改动的代码在运行时不生效问题。\\n\\n具体的构建逻辑可参考下笔者示例项目下的 scripts/build.ts 文件。\\n\\n核心逻辑如下：\\n\\n```ts\\nimport esbuild from 'esbuild'\\nimport path from 'path'\\nimport NativeModulePlugin from './plugins/native-module-plugin'\\n\\nesbuild.build({\\n  entryPoints: [path.resolve('src')],\\n  bundle: true,\\n  platform: 'node',\\n  outfile: 'dist/index.js',\\n  plugins: [NativeModulePlugin],\\n})\\n\\n```\\n\\n主要就是使用了 esbuild 的 api 进行单文件打包，同时为了处理 .node 类型的原生模块，所以写了一个简单的插件进行打包，有兴趣可以参考下示例项目的实现，这里就不过多赘述了。\\n\\n[传送门](https://github.com/STDSuperman/deploy-files)\\n\\n## 总结\\n\\n笔者这里完整的介绍了一下如何使用 ts 开发一个实用的 action 流程，如果你更喜欢 js 的话，估计需要自行调整下 lint 配置和删除 tsconfig.json，或者直接删掉有关 lint 相关的文件或代码即可，然后 src 目录下新建一个 index.js 就好了。\\n\\n如果文中存在尚不明确或错误的地方，感谢指正。\\n",
        "tags": [
            "前端",
            "GitHub",
            "JavaScript"
        ]
    },
    {
        "article_id": "7165486611361169422",
        "cover_image": "",
        "title": "全网唯一能够秒回粉丝的博主, 是如何做到的?",
        "brief": "使用Electron + React开发了一款自媒体小助手, 不仅可以看数据大屏, 还可以在粉丝留言时像微信一样给我发消息提醒. 支持B站、掘金、知乎.",
        "user_name": "前夕",
        "view_count": 3999,
        "collect_count": 74,
        "comment_count": 47,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/de262bce69b6747c689ee4c579430b78~300x300.image",
        "category": "前端",
        "content": "## 站内信, 满足的了他们, 可满足不了我\\n\\n> 视频版: https://www.bilibili.com/video/BV1At4y1N7Kq/\\n\\nB站、掘金、知乎, 几乎所有的自媒体平台, 他们的系统通知都是站内信模式.\\n\\n![image-20221107170556668](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78647986a1c74af68e37129cf936632e~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n对于点赞、关注等消息, 站内信通知其实没什么问题, 因为早知道晚知道没什么区别. 但是对于留言、私信之类的功能, 站内信则有点差强人意了. 因为互动消息, 很多都是行业交流、职业生涯讨论等, 其中不乏有些蛮着急的问题. **而我如果不登录站点, 就永远不知道是否有人给我发消息了. 作为一个良心博主, 我非常想秒回他们.** \\n\\n可能有人会想, 那为什么不一直开着站点呢? 一直开着站点倒没什么问题, 问题是我难道一直看着站点吗? 我不上班吗? 而且对于自媒体人来说, 需要关注好几个平台, 一直切来切去也太麻烦了. \\n\\n如果要是能和微信一样, 有消息就主动给我来个系统通知就好了. 于是乎, 自媒体小助手腾空出世了! (We Media Hepler, 后文简称WMH)\\n\\n<img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/60a03bf8db4a46bdb47020bb40b7b529~tplv-k3u1fbpfcp-zoom-1.image\\\" alt=\\\"image-20221107172651421\\\" style=\\\"zoom:50%;\\\" />\\n\\n这款小助手主要有两方面的功能, 第一个方面是数据大屏. 在业务上, 我将其命名为监听器. 我们可以先对监听器进行设置.\\n\\n![image-20221107192439124](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb80d3450b134139990c47a82e68a222~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n<img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e788b352f794b46880e0b0479406008~tplv-k3u1fbpfcp-zoom-1.image\\\" alt=\\\"image-20221107192526842\\\" style=\\\"zoom:50%;\\\" />\\n\\n首先需要在你设置的监听器当中填入`cookie`. 因为从本质上来说, WMH也就是发了个网络请求拿到数据并展示. 其他的都有默认的配置, 你可以对他进行修改. 每个监听器都有一个分组的概念, 每个分组可以设置多个卡片. \\n\\n<img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5b1b7d9f3494b728a03f7f630150816~tplv-k3u1fbpfcp-zoom-1.image\\\" alt=\\\"image-20221107192631182\\\" style=\\\"zoom:50%;\\\" />\\n\\n在设置完毕后, 我们可以开启对应的监听器.\\n\\n<img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8d3987317d2245ccad5ea92329333e75~tplv-k3u1fbpfcp-zoom-1.image\\\" alt=\\\"image-20221107194538864\\\" style=\\\"zoom:50%;\\\" />\\n\\n<img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db80b6ab9c134f62b560a7cee75c32c3~tplv-k3u1fbpfcp-zoom-1.image\\\" alt=\\\"image-20221107194634000\\\" style=\\\"zoom:50%;\\\" />\\n\\n除了数据展示之外, 正上方还有个倒计时, 默认是每隔30s更新一次数据. 当然, 你也可以在设置中隐藏该UI部分.\\n\\n<img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/740f1c3946214a46b4a117f66a943c92~tplv-k3u1fbpfcp-zoom-1.image\\\" alt=\\\"image-20221107194744168\\\" style=\\\"zoom:50%;\\\" />\\n\\n可能有同学会问\\\"你挂羊头卖狗肉呢? 这玩意和站内信有半毛钱关系?\\\". 问的好! 不知道是否有同学注意到卡片上的绿灯?\\n\\n<img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aff306d3911b49668a24da3326b69775~tplv-k3u1fbpfcp-zoom-1.image\\\" alt=\\\"image-20221107194158603\\\" style=\\\"zoom:50%;\\\" />\\n\\n当这个绿灯开启的时候, 就说明WMH对这个卡片进行了数据监听. 当这个卡片的数据发生新增时, 将会进行桌面系统通知. 我建议只开启那些需要交互的卡片即可. 对于积累型数据, 如粉丝总量等则不建议开启.\\n\\n![image-20221025145200686](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/53331bf04c4e42d388f3632d05842e91~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n在系统通知之后, 你就可以到站点进行回复了. 看! 点题了吧! 这就是我心心念念的消息即时通知呀! 不过我需要讲下他背后的逻辑. 当你对卡片开启了通知后, 每次拉取请求时都会先将该卡片的数据存储到本地, 在下一次拉取数据时进行比对. 如`回复我的`字段第一次拉取回来是1, 第二次拉取回来是2时, 因为2>1, 所以就进行了系统通知. 不过这里也有个逻辑bug, 比如第一次拉取回来是1, 于是我去回复私信了, 回完我就关了窗口, 这时候对方又发了一条消息, 那么我的未读消息则还是1. 当WMH再次拉取数据时会发现 1 === 1, 则不进行系统通知. 不过没关系, 这都小概率事件.\\n\\n## 单屏模式\\n\\n在前文中我只是展示了一个B站的数据大屏. 但其实我一共实现了三个监听器, 他们都是可以开启的.\\n\\n![image-20221107202330187](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/432a0ab602a64dd0b4992956c76e4bc1~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n可能有同学会问\\\"假如不开启数据大屏, 就无法进行系统通知了. 但是全开, 又太多了, 我这屏幕塞不下了怎么办?\\\" 问的好! 所以我提供了`单屏模式`, 能够在一个窗体当中让你直接开启多监听器.\\n\\n<img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8cd1522559fd475a8bd4a7ef9437fa61~tplv-k3u1fbpfcp-zoom-1.image\\\" alt=\\\"image-20221107203722394\\\" style=\\\"zoom:50%;\\\" />\\n\\n只需要开启`单屏模式`, 就会发现监听全部都是在同一个窗口中的, 对于tab的切换, 除了鼠标点击之外, 你还可以通过键盘进行切换.\\n\\n<img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ed121580c3a40e2b8048b341b6d6396~tplv-k3u1fbpfcp-zoom-1.image\\\" alt=\\\"image-20221107203935312\\\" style=\\\"zoom:50%;\\\" />\\n\\n那么问题来了, 到底按什么键位能够切换下一个tab呢? 如果这个问题抛给各位同学, 可能众说纷纭. 有人认为应该是方向右键, 因为比较直观. 还有人认为应该是字母D或者S, 因为很多游戏里的走位都是WASD. 这么想其实也挺合理的, 毕竟右手一般都握着鼠标. 于是乎我设置了所有大家有可能想到的合理的答案...\\n\\n```ts\\nconst doLast = ['w', 'a', 'up', 'left'].includes(hotkey);\\nconst doNext = ['s', 'd', 'down', 'right'].includes(hotkey);\\n```\\n\\n## 开发趣事\\n\\n接下来, 我想聊一聊我开发过程当中遇到的一些感受(吐槽). 接下来我开始点名!\\n\\n![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96c29d1fa22e409e897b5a5268f6dd4d~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n### 哔哩哔哩\\n\\n首先, 我们来聊一聊B站. WMH的数据大屏的页面, 其实是参考(抄袭)了B站的创作中心的. \\n\\n![image-20221107205951796](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c40062cb95440dba7cb1b5643ac7458~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n我觉得这个UI还是蛮好看的, 给B站设计师一个好评! 大家觉得这种两行的卡片布局, B站会如何实现呢? \\n\\n<img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cdb1461760ea499497125da2b280374c~tplv-k3u1fbpfcp-zoom-1.image\\\" alt=\\\"image-20221107210554613\\\" style=\\\"zoom:50%;\\\" />\\n\\n我怎么也没想到, 他居然写了两份一毛一样的代码. 只不过在第一个容器上+了个下边距. 按理这种布局需求使用网格布局会很方便. 可能有人说会不会是考虑了兼容性? 我觉得不是这个原因. 看到最后你就知道为什么我说不是这个原因了.\\n\\n接下来我们看看这部分卡片涉及的接口请求格式\\n\\n<img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce6dcb8538cf48f48e66d5e242cdb676~tplv-k3u1fbpfcp-zoom-1.image\\\" alt=\\\"image-20221107211310824\\\" style=\\\"zoom:50%;\\\" />\\n\\n里面的字段, `fans`, `reply`啥的看起来还是比较好理解的. 但是这个`dm`, 我想了好久也不知道这到底是个什么玩意. 于是我和一张张卡片对比, 推导出他是弹幕...\\n\\n其实我是能理解弹幕的关键词他用`dm`, 因为这是亚洲文化, 西方是没有的, 所以确实不太好翻译, 但是我不提倡那么做. 因为这个叫**上下文同频**. 举个例子, 我说我明天有个PR要弄, 你们会怎么理解? 我一定是说代码的pull request吗? 在开发圈子里, 这肯定是pull request了. 但是我也有可能是说有篇宣传文要写(public relation). 也可能是说我做了视频还没剪辑(Premier, 专业的剪辑软件). 因此, 当我们在交流的时候, 上下文同频很重要. 这也是为什么我死活想不到这是弹幕, 因为我思考的方向是哪2个单词的缩写, 而不是哪2个汉字的拼音.\\n\\n我们继续分析这个接口格式, 还会发现对于新增的数据字段, 他有些是`inc`开头, 有些是`incr`开头. 这是非常奇怪的,  虽然也没什么大影响, 但是强迫症看了是真难受啊.\\n\\n<img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/07dfa42825e440c68be1d49a8e623aeb~tplv-k3u1fbpfcp-zoom-1.image\\\" alt=\\\"image-20221107212518747\\\" style=\\\"zoom:50%;\\\" />\\n\\n随后, 我们在对这些字段与卡片对应后会发现, **所有`inc`开头的, 都是第二排卡片的, 所有`incr`开头的都是第一排卡片的......**\\n\\n当我发现这个规律以后, 我一下子穿越到了几年前, 看到了一个B站前端接到任务要新增一行卡片. 他发现现成就有一排的卡片. 于是直接拷贝粘贴, 新的一行出现了. 和之前的区别就是读取的数据字段不同. 这还不简单, 直接按照自己的理解起几个名字的字段名即可. 完事儿.\\n\\n于是乎, 在2022年的11月, 我看到了现在的表现. 所以, 这里的双行布局没有使用网格布局, 还是考虑兼容性吗? 不, 单纯是因为复制粘贴比较快罢了. \\n\\n以上均是我的猜想, 可能对也可能不对, 毕竟我不是写这块儿业务的人, 确实不太了解相关情况. 随手乱分析的. 如果不对还请谅解. \\n\\n### 掘金\\n\\n掘金板块, 我主要是监听了他的消息中心.\\n\\n<img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/476b18a839c64e36989d38c4a6f2c774~tplv-k3u1fbpfcp-zoom-1.image\\\" alt=\\\"image-20221107214028174\\\" style=\\\"zoom:50%;\\\" />\\n\\n相对应的接口是这样的\\n\\n<img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/456136f0c1ac45bba95186600343ff12~tplv-k3u1fbpfcp-zoom-1.image\\\" alt=\\\"image-20221107214052151\\\" style=\\\"zoom:50%;\\\" />\\n\\n好家伙, 加密接口! 我能看的出来这谁是谁? 不过我相信各位同学都能有办法测出来哪个数字应对着哪个tab. 但是, **我相信没有人知道为什么这里面没有数字5和6**. 嘿嘿, 我知道!\\n\\n在早期的时候, 掘金是有5号字段, 当时这个字段对应着`职位沟通`, 不知道有没有同学记得之前是有这个版本的. 当然, 这个板块我从来没用过, 只是顺便写的. 后来移除了这个字段, 新增了`私信`. 那么我是怎么知道的呢? 因为最近一个月的时间, 基本上除了上班和玩剑网三, 其余时间都在开发WMH. 所以在一个月前5号字段还在的, 我把他放进了掘金监听器的接口分析当中, 后来字段无效了, 调试才发现官方把这个字段删了. 这一点, 可以在WMH的历史commit中找到. \\n\\n<img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/60150b1049e0438e9928d1660b8b58ed~tplv-k3u1fbpfcp-zoom-1.image\\\" alt=\\\"image-20221107221309390\\\" style=\\\"zoom:50%;\\\" />\\n\\n至于为什么没有6号, 这我就真不知道了. 有掘金的同学吗? 可以在留言区给大家揭晓一下不? 另外, 可能因为我才疏学浅, 我不太理解为什么接口的字段名要用数字代替? 这是什么标准吗? 我确实是不太了解这块儿, 希望有同学可以给我科普下.\\n\\n## 技术栈介绍\\n\\nElectron + React 18 + TypeScript + Axios + Antd\\n\\n在原生应用的解决方案上, 选择了Electron, 这点没什么好说的, 因为我就是个页面仔. 那么在web上, 我选择了**最不擅长的React18**. 如果这里有我的老粉的话, 应该知道, 我从19年毕业到现在, 一直用的Angular技术栈. 也很想拓宽下自己的技术栈. 但是看看文档啥的, 我认为那不叫学习, 不过是纸上谈兵罢了. 学习一门技术, 一定要在实际的业务中去使用, 遇到问题然后解决, 在场景中不断吸收. 在使用React的过程中, 我的几个狐朋狗友们给了我很多帮助.\\n\\n第一位朋友, **我愿称之为React之王**. 此人拥有6年工作经验, 对React有着非常深的理解, 目前从事架构、脚手架方向的工作. 他的博客: https://blog.hyyar.com/ 当中有好多我每次读都有新感受的文章.\\n\\n第二位朋友, **我愿称之为TypeScript之王**, 此人拥有3年工作经验. 体操熟练程度极其变态. 技术栈同样是React, 对代码的架构、实现优雅度等有极高的追求. 最近正在找工作, base 广州. 有需要招人的请联系我, 我帮你们牵个线. 他的主页: https://github.com/xlboy\\n\\n目前WMH已经支持了**Windows(32bit、64bit) + Mac(intel、m1)**. 大家可以在[Release](https://github.com/Eve-Sama/we-media-helper/releases)当中挑选适配自己的版本即可. 至于Linux, 可以支持, 但是我懒得, 有兴趣的同学可以来个PR.\\n\\n## 新增一个监听器\\n\\n目前只支持了B站、掘金、知乎的监听器. 可能你需要的监听器并不在此列当中. 你完全可以提交PR来新增一个监听器. 可能你会想\\\"我又没开发过你这个app, 完全不熟悉你的实现逻辑, 我还得看你的代码, 这也太麻烦了吧?\\\" 问的好! 在监听器的设计上, 我尽可能考虑了代码复用, 以保证各个监听器之间保持一致的逻辑. 因此, 我敢说, 新增一个监听器, 真正涉及到WMH的部分只有半小时!\\n\\n因为这部分更多的还是实操, 我在视频版本当中会介绍, 文字版的就算了吧, 各种图片贴来贴去, 我贴的累你看的也累, 对这部分感兴趣的请跳转视频版.\\n\\n## 隐私声明\\n\\n因为软件的使用需要你贴入自己的cookie. 可能有同学会担心我会不会写了后门把你的cookie发到我的服务器了. 郑重说明, 软件的所有存储均在本地, 没有任何上传行为. 代码是完全开放的, 欢迎审查. 其次, 各位的cookie对我毫无价值. 拿大家的cookie图啥呢, 看你平时在B站看黑丝还是看JK吗? 我有那么闲吗?\\n\\n所以请放心, WMH不会造成任何数据泄露.\\n\\n## 总结\\n\\n其实WMH可以优化的地方还很多\\n\\n- css隔离方案选择的是css module. 其实应该使用css in js的\\n- 打包体积优化, 目前是node_modules都打进去了, 所以体积比较大\\n- Electron使用的js文件, 可以转为TypeScript文件\\n- ...\\n但是我毕竟还要上班, 并没有太多时间去做这个东西. 只能先将就着用. 打造WMH的过程中我还蛮享受自己创作的过程. 并且这个结果也为我提供了极高的价值. 无论是B站还是掘金, 再也不会错过关键信息了. 对这个工具感兴趣的同学可以点个Star: https://github.com/Eve-Sama/we-media-helper\\n\\n",
        "tags": [
            "前端",
            "GitHub",
            "开源"
        ]
    },
    {
        "article_id": "7150462512817782815",
        "cover_image": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/814125ef31c44750887a56982b7fbb52~tplv-k3u1fbpfcp-watermark.image?",
        "title": "2022年我的面试万字总结（JS篇上）",
        "brief": "本篇总结了JS基础、闭包作用域、函数编程的题目。借着国庆这个假期，也把这些题目总结分享给大家，也祝正在面试的朋友们能够拿到满意的offer。",
        "user_name": "逍丶",
        "view_count": 40748,
        "collect_count": 1704,
        "comment_count": 52,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/a87f08adcd0dad907726396180915552~300x300.image",
        "category": "前端",
        "content": "持续创作，加速成长！这是我参与「掘金日新计划 · 10 月更文挑战」的第4天，[点击查看活动详情](https://juejin.cn/post/7147654075599978532 \\\"https://juejin.cn/post/7147654075599978532\\\")\\n\\n# 前言\\n\\n又到了金九银十季，最近我也是奔波于各种面试。我自己总结整理了很多方向的前端面试题。借着国庆这个假期，也把这些题目总结分享给大家，也祝正在面试的朋友们能够拿到满意的offer。\\n# 往期文章\\n（1）[2022年我的面试万字总结（浏览器网络篇）](https://juejin.cn/post/7149438206419664927)\\n\\n（2）[ 2022年我的面试万字总结（CSS篇）](https://juejin.cn/post/7149716216167268366)\\n\\n（3）[  2022年我的面试万字总结（HTML篇）](https://juejin.cn/post/7150109570609152014)\\n\\n（5）[ 2022年我的面试万字总结（JS篇下） ](https://juejin.cn/post/7150861842888261668)\\n\\n（6）[  2022年我的面试万字总结（代码篇）](https://juejin.cn/post/7151221875224346637)\\n\\n（7）[ 2022年我的面试万字总结（Vue上）](https://juejin.cn/post/7151597651719356446)\\n\\n（8）[ 2022年我的面试万字总结（Vue下）](https://juejin.cn/post/7151604799077613599)\\n\\n（9）[ 2022年我的面试万字总结（Vue3+TS）](https://juejin.cn/post/7160962909332307981)\\n \\n （10）[ 2022年我的面试万字总结（Node、webpack、性能优化）](https://juejin.cn/post/7161292246526984228)\\n  \\n（11）[ 2022年我的面试万字总结（小程序、git）](https://juejin.cn/post/7161584249898795045)\\n\\n# 一、JS基础\\n### 1.1 Js有哪些数据类型\\n\\nJavaScript共有八种数据类型\\n\\n基本数据类型： Undefined、Null、Boolean、Number、String、Symbol、BigInt。\\n\\n引用数据类型：Object\\n\\n其中 Symbol 和 BigInt 是ES6 中新增的数据类型：\\n\\n-   Symbol 代表创建后独一无二且不可变的数据类型，它主要是为了解决可能出现的全局变量冲突的问题。\\n-   BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围。\\n\\n### 1.2 说说你对堆区和栈区的理解\\n\\n**在操作系统中，内存被分为栈区和堆区**\\n\\n-   栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。\\n-   堆区内存一般由开发着分配释放，若开发者不释放，程序结束时可能由垃圾回收机制回收。\\n\\n**在数据结构中：**\\n\\n-   在数据结构中，栈中数据的存取方式为先进后出。\\n-   堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大小来规定。\\n\\n**数据的储存方式**\\n\\n-   原始数据类型直接存储在栈（stack）中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；\\n-   引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。\\n\\n### 1.3 数据类型检测的方式有哪些\\n\\n然后判断数据类型的方法一般可以通过：**typeof**、**instanceof**、**constructor**、**toString**四种常用方法\\n\\n| 不同类型的优缺点 | typeof                              | instanceof           | constructor                  | Object.prototype.toString.call |\\n| -------- | ----------------------------------- | -------------------- | ---------------------------- | ------------------------------ |\\n| 优点       | 使用简单                                | 能检测出`引用类型`           | 基本能检测所有的类型（除了null和undefined） | 检测出所有的类型                       |\\n| 缺点       | 只能检测出除null外的基本数据类型和引用数据类型中的function | 不能检测出基本类型，且不能跨iframe | constructor易被修改，也不能跨iframe   | IE6下，undefined和null均为Object    |\\n\\n### 1.4 判断数组的方式有哪些\\n\\n-   通过Object.prototype.toString.call()做判断\\n-   通过原型链做判断\\n-   通过ES6的Array.isArray()做判断\\n-   通过instanceof做判断\\n-   通过Array.prototype.isPrototypeOf\\n\\n### 1.5 null和undefined区别\\n\\n-   首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。\\n-   undefined 代表的含义是**未定义**，null 代表的含义是**空对象**。一般变量声明了但还没有定义的时候会返回 undefined，null主要用于赋值给一些可能会返回对象的变量，作为初始化。\\n-   undefined 在 JavaScript 中不是一个保留字，这意味着可以使用 undefined 来作为一个变量名，但是这样的做法是非常危险的，它会影响对 undefined 值的判断。我们可以通过一些方法获得安全的 undefined 值，比如说 void 0。\\n-   当对这两种类型使用 typeof 进行判断时，Null 类型化会返回 “object”，这是一个历史遗留的问题。当使用双等号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。\\n\\n### 1.6 typeof null 的结果是什么，为什么？\\n\\ntypeof null 的结果是Object。\\n\\n在 JavaScript 第一个版本中，所有值都存储在 32 位的单元中，每个单元包含一个小的 **类型标签(1-3 bits)** 以及当前要存储值的真实数据。类型标签存储在每个单元的低位中，共有五种数据类型：\\n\\n```\\n000: object   - 当前存储的数据指向一个对象。\\n  1: int      - 当前存储的数据是一个 31 位的有符号整数。\\n010: double   - 当前存储的数据指向一个双精度的浮点数。\\n100: string   - 当前存储的数据指向一个字符串。\\n110: boolean  - 当前存储的数据是布尔值。\\n```\\n\\n如果最低位是 1，则类型标签标志位的长度只有一位；如果最低位是 0，则类型标签标志位的长度占三位，为存储其他四种数据类型提供了额外两个 bit 的长度。\\n\\n有两种特殊数据类型：\\n\\n-   undefined的值是 (-2)30(一个超出整数范围的数字)；\\n-   null 的值是机器码 NULL 指针(null 指针的值全是 0)\\n\\n那也就是说null的类型标签也是000，和Object的类型标签一样，所以会被判定为Object。\\n\\n### 1.7 为什么0.1+0.2 ! == 0.3，如何让其相等 (精度丢失)\\n\\n计算机是通过二进制的方式存储数据的，所以计算机计算0.1+0.2的时候，实际上是计算的两个数的二进制的和。\\n\\n在 Js中只有一种数字类型：Number，它的实现遵循IEEE 754标准，使用64位固定长度来表示，也就是标准的double双精度浮点数。在二进制科学表示法中，双精度浮点数的小数部分最多只能保留52位，再加上前面的1，其实就是保留53位有效数字，剩余的需要舍去，遵从“0舍1入”的原则。\\n\\n根据这个原则，0.1和0.2的二进制数相加，再转化为十进制数就是：`0.30000000000000004`。所以不相等\\n\\n解决方法就是设置一个误差范围，通常称为“机器精度”。对JavaScript来说，这个值通常为2-52，在ES6中，提供了`Number.EPSILON`属性，而它的值就是2-52，只要判断`0.1+0.2-0.3`是否小于`Number.EPSILON`，如果小于，就可以判断为0.1+0.2 ===0.3\\n\\n```\\nfunction numberepsilon(arg1,arg2){                   \\n  return Math.abs(arg1 - arg2) < Number.EPSILON;        \\n}        \\n​\\nconsole.log(numberepsilon(0.1 + 0.2, 0.3)); // true\\n```\\n\\n### 1.8 如何获取安全的 undefined 值？\\n\\n因为 undefined 是一个标识符，所以可以被当作变量来使用和赋值，但是这样会影响 undefined 的正常判断。表达式 void ___ 没有返回值，因此返回结果是 undefined。void 并不改变表达式的结果，只是让表达式不返回值。因此可以用 void 0 来获得 undefined。\\n\\n### 1.9 typeof NaN 的结果是什么？\\n\\nNaN 指“不是一个数字”（not a number），NaN 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。\\n\\n```\\ntypeof NaN; // \\\"number\\\"\\n```\\n\\nNaN 是一个特殊值，它和自身不相等，是唯一一个非自反的值。所谓的非自反就是说，NaN 与谁都不相等，包括它本身，但在 NaN ！= NaN 下会返回true\\n\\n\\n\\n### 1.10 isNaN 和 Number.isNaN 函数的区别？\\n\\n-   函数 isNaN 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 true，因此非数字值传入也会返回 true ，会影响 NaN 的判断。\\n-   函数 Number.isNaN 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，不会进行数据类型的转换，这种方法对于 NaN 的判断更为准确。\\n\\n### 1.11 == 操作符的强制类型转换规则是什么？\\n\\n对于 `==` 来说，如果对比双方的类型**不一样**，就会进行**类型转换**。假如对比 `x` 和 `y` 是否相同，就会进行如下判断流程：\\n\\n0.  首先会判断两者类型是否**相同，** 相同的话就比较两者的大小；\\n0.  类型不相同的话，就会进行类型转换；\\n0.  会先判断是否在对比 `null` 和 `undefined`，是的话就会返回 `true`\\n0.  判断两者类型是否为 `string` 和 `number`，是的话就会将字符串转换为 `number`\\n\\n```\\n1 == '1'\\n      ↓\\n1 ==  1\\n```\\n\\n0.  判断其中一方是否为 `boolean`，是的话就会把 `boolean` 转为 `number` 再进行判断\\n\\n```\\n'1' == true\\n        ↓\\n'1' ==  1\\n        ↓\\n 1  ==  1\\n```\\n\\n0.  判断其中一方是否为 `object` 且另一方为 `string`、`number` 或者 `symbol`，是的话就会把 `object` 转为原始类型再进行判断\\n\\n```\\n'1' == { name: 'js' }        ↓'1' == '[object Object]'\\n```\\n\\n其流程图如下： \\n\\n![微信截图_20221004091412.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/446f656981cc4acb92f92ef6c57c3686~tplv-k3u1fbpfcp-watermark.image?)\\n### 1.12 其他值类型转成字符串的转换规则？\\n\\n-   Null 和 Undefined 类型 ，null 转换为 \\\"null\\\"，undefined 转换为 \\\"undefined\\\"，\\n-   Boolean 类型，true 转换为 \\\"true\\\"，false 转换为 \\\"false\\\"。\\n-   Number 类型的值直接转换，不过那些极小和极大的数字会使用指数形式。\\n-   Symbol 类型的值直接转换，但是只允许显式强制类型转换，使用隐式强制类型转换会产生错误。\\n-   对普通对象来说，除非自行定义 toString() 方法，否则会调用 toString()（Object.prototype.toString()）来返回内部属性 [[Class]] 的值，如\\\"[object Object]\\\"。如果对象有自己的 toString() 方法，字符串化时就会调用该方法并使用其返回值。\\n\\n### 1.13. 其他值类型转成数字的转换规则？\\n\\n-   Undefined 类型的值转换为 NaN。\\n-   Null 类型的值转换为 0。\\n-   Boolean 类型的值，true 转换为 1，false 转换为 0。\\n-   String 类型的值转换如同使用 Number() 函数进行转换，如果包含非数字值则转换为 NaN，空字符串为 0。\\n-   Symbol 类型的值不能转换为数字，会报错。\\n-   对象（包括数组）会首先被转换为相应的基本类型值，如果返回的是非数字的基本类型值，则再遵循以上规则将其强制转换为数字。\\n\\n为了将值转换为相应的基本类型值， 隐式转换会首先检查该值是否有valueOf()方法。如果有并且返回基本类型值，就使用该值进行强制类型转换。如果没有就使用 toString() 的返回值（如果存在）来进行强制类型转换。\\n\\n如果 valueOf() 和 toString() 均不返回基本类型值，会产生 TypeError 错误。\\n\\n### 1.14 其他值类型转成布尔类型的转换规则？\\n\\n以下这些是假值： undefined 、 null 、 false 、 +0、-0 和 NaN 、 \\\"\\\"\\n\\n假值的布尔强制类型转换结果为 false。从逻辑上说，假值列表以外的都应该是真值。\\n\\n### 1.15. || 和 && 操作符的返回值？\\n\\n|| 和 && 首先会对第一个操作数执行条件判断，如果其不是布尔值就先强制转换为布尔类型，然后再执行条件判断。\\n\\n-   对于 || 来说，如果条件判断结果为 true 就返回第一个操作数的值，如果为 false 就返回第二个操作数的值。\\n-   && 则相反，如果条件判断结果为 true 就返回第二个操作数的值，如果为 false 就返回第一个操作数的值。\\n\\n|| 和 && 返回它们其中一个操作数的值，而非条件判断的结果\\n\\n### 1.16. Object.is() 与比较操作符 “===”、“==” 的区别？\\n\\n-   使用双等号（==）进行相等判断时，如果两边的类型不一致，则会进行强制类型转化后再进行比较。\\n-   使用三等号（===）进行相等判断时，如果两边的类型不一致时，不会做强制类型准换，直接返回 false。\\n-   使用 Object.is 来进行相等判断时，一般情况下和三等号的判断相同，它处理了一些特殊的情况，比如 -0 和 +0 不再相等，两个 NaN 是相等的。\\n\\n### 1.17. 什么是 JavaScript 中的包装类型？\\n\\n在 JavaScript 中，基本类型是没有属性和方法的，但是为了便于操作基本类型的值，在调用基本类型的属性或方法时 JavaScript 会在后台隐式地将基本类型的值转换为对象。如：\\n\\n```\\nconst a = \\\"abc\\\";\\na.length; // 3\\n```\\n\\n在访问`'abc'.length`时，JavaScript 将`'abc'`在后台转换成`String('abc')`，然后再访问其`length`属性。\\n\\n### 1.18 Js中隐式转换规则\\n\\n在 if 语句、逻辑语句、数学运算逻辑、== 等情况下都可能出现隐式类型转换。\\n\\n\\n![微信截图_20221004091517.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8249e191d95c46a8b66effb504b3de93~tplv-k3u1fbpfcp-watermark.image?)\\n\\n坑: 判断时, 尽量不要用 `= =` , 要用 `= = =` ( 两个等号判断, 如果类型不同, 默认会进行隐式类型转换再比较)\\n\\n### 1.19 说说你对this的理解\\n\\nthis`是一个在运行时才进行绑定的引用`，在不同的情况下它可能会被绑定不同的对象。\\n\\n### 1.20 如何判断 this 的指向\\n\\n-   第一种是**函数调用模式**，当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象。\\n-   第二种是**方法调用模式**，如果一个函数作为一个对象的方法来调用时，this 指向这个对象。\\n-   第三种是**构造器调用模式**，如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象。\\n-   第四种是 **apply 、 call 和 bind 调用模式**，这三个方法都可以显示的指定调用函数的 this 指向。其中 apply 方法接收两个参数：一个是 this 绑定的对象，一个是参数数组。call 方法接收的参数，第一个是 this 绑定的对象，后面的其余参数是传入函数执行的参数。也就是说，在使用 call() 方法时，传递给函数的参数必须逐个列举出来。bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this 指向除了使用 new 时会被改变，其他情况下都不会改变。\\n\\n#### **this绑定的优先级**\\n\\nnew绑定优先级 > 显示绑定优先级 > 隐式绑定优先级 > 默认绑定优先级\\n\\n### 1.21 Map和Object的区别\\n\\n|      | Map                                          | Object                                     |\\n| ---- | -------------------------------------------- | ------------------------------------------ |\\n| 意外的键 | Map默认情况不包含任何键，只包含显式插入的键。                     | Object 有一个原型, 原型链上的键名有可能和自己在对象上的设置的键名产生冲突。 |\\n| 键的类型 | Map的键可以是任意值，包括函数、对象或任意基本类型。                  | Object 的键必须是 String 或是Symbol。              |\\n| 键的顺序 | Map 中的 key 是有序的。因此，当迭代的时候， Map 对象以插入的顺序返回键值。 | Object 的键是无序的                              |\\n| Size | Map 的键值对个数可以轻易地通过size 属性获取                   | Object 的键值对个数只能手动计算                        |\\n| 迭代   | Map 是 iterable 的，所以可以直接被迭代。                  | 迭代Object需要以某种方式获取它的键然后才能迭代。                |\\n| 性能   | 在频繁增删键值对的场景下表现更好。                            | 在频繁添加和删除键值对的场景下未作出优化。                      |\\n\\n### 1.22 说说你对JSON的理解\\n\\nJSON 是一种基于文本的轻量级的数据交换格式。它可以被任何的编程语言读取和作为数据格式来传递。\\n\\n在项目开发中，使用 JSON 作为前后端数据交换的方式。在前端通过将一个符合 JSON 格式的数据结构序列化为 JSON 字符串，然后将它传递到后端，后端通过 JSON 格式的字符串解析后生成对应的数据结构，以此来实现前后端数据的一个传递。\\n\\n因为 JSON 的语法是基于 js 的，因此很容易将 JSON 和 js 中的对象弄混，但是应该注意的是 JSON 和 js 中的对象不是一回事，JSON 中对象格式更加严格，比如说在 JSON 中属性值不能为函数，不能出现 NaN 这样的属性值等，因此大多数的 js 对象是不符合 JSON 对象的格式的。\\n\\n在 js 中提供了两个函数来实现 js 数据结构和 JSON 格式的转换处理，\\n\\n-   **JSON.stringify** 函数，通过传入一个符合 JSON 格式的数据结构，将其转换为一个 JSON 字符串。如果传入的数据结构不符合 JSON 格式，那么在序列化的时候会对这些值进行对应的特殊处理，使其符合规范。在前端向后端发送数据时，可以调用这个函数将数据对象转化为 JSON 格式的字符串。\\n-   **JSON.parse()** 函数，这个函数用来将 JSON 格式的字符串转换为一个 js 数据结构，如果传入的字符串不是标准的 JSON 格式的字符串的话，将会抛出错误。当从后端接收到 JSON 格式的字符串时，可以通过这个方法来将其解析为一个 js 数据结构，以此来进行数据的访问。\\n\\n### 1.222 String和JSON.stringify的区别\\n\\n```\\nconsole.log(String(\\\"abc\\\")); // abc\\nconsole.log(JSON.stringify(\\\"abc\\\")); // \\\"abc\\\"\\n​\\nconsole.log(String({ key: \\\"value\\\" })); // [object Object]\\nconsole.log(JSON.stringify({ key: \\\"value\\\" })); // {\\\"key\\\":\\\"value\\\"}\\n​\\nconsole.log(String([1, 2, 3])); // 1,2,3\\nconsole.log(JSON.stringify([1, 2, 3])); // [1,2,3]\\n​\\nconst obj = {\\n    title: \\\"devpoint\\\",\\n    toString() {\\n        return \\\"obj\\\";\\n    },\\n};\\nconsole.log(String(obj)); // obj\\nconsole.log(JSON.stringify(obj)); // {\\\"title\\\":\\\"devpoint\\\"}\\n```\\n\\n-   当需要将一个数组和一个普通对象转换为字符串时，经常使用`JSON.stringify`。\\n-   如果需要对象的`toString`方法被重写，则需要使用String()。\\n-   在其他情况下，使用`String()`将变量转换为字符串。\\n\\n### 1.23 什么是伪数组(类数组)\\n\\n一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。\\n\\n常见的类数组对象有 arguments 和 DOM 方法的返回结果，还有一个函数也可以被看作是类数组对象，因为它含有 length 属性值，代表可接收的参数个数。\\n\\n### 1.24 类数组转换成数组的方法有哪些\\n\\n常见的类数组转换为数组的方法有这样几种：\\n\\n-   通过 call 调用数组的 slice 方法来实现转换\\n\\n```\\nArray.prototype.slice.call(arrayLike);\\n```\\n\\n-   通过 call 调用数组的 splice 方法来实现转换\\n\\n```\\nArray.prototype.splice.call(arrayLike, 0);\\n```\\n\\n-   通过 apply 调用数组的 concat 方法来实现转换\\n\\n```\\nArray.prototype.concat.apply([], arrayLike);\\n```\\n\\n-   通过 Array.from 方法来实现转换\\n\\n```\\nArray.from(arrayLike);\\n```\\n\\n### 1.25 **Unicode、UTF-8、UTF-16、UTF-32的区别？**\\n\\n-   `Unicode` 是编码字符集（字符集），而`UTF-8`、`UTF-16`、`UTF-32`是字符集编码（编码规则）；\\n-   `UTF-16` 使用变长码元序列的编码方式，相较于定长码元序列的`UTF-32`算法更复杂，甚至比同样是变长码元序列的`UTF-8`也更为复杂，因为其引入了独特的**代理对**这样的代理机制；\\n-   `UTF-8`需要判断每个字节中的开头标志信息，所以如果某个字节在传送过程中出错了，就会导致后面的字节也会解析出错；而`UTF-16`不会判断开头标志，即使错也只会错一个字符，所以容错能力教强；\\n-   如果字符内容全部英文或英文与其他文字混合，但英文占绝大部分，那么用`UTF-8`就比`UTF-16`节省了很多空间；而如果字符内容全部是中文这样类似的字符或者混合字符中中文占绝大多数，那么`UTF-16`就占优势了，可以节省很多空间；\\n\\n### 1.26 常见的位运算符有哪些？其计算规则是什么？\\n\\n现代计算机中数据都是以二进制的形式存储的，即0、1两种状态，计算机对二进制数据进行的运算加减乘除等都是叫位运算，即将符号位共同参与运算的运算。\\n\\n常见的位运算有以下几种：\\n\\n| 运算符  | 描述 | 运算规则                          |   |\\n| ---- | -- | ----------------------------- | - |\\n| `&`  | 与  | 两个位都为1时，结果才为1                 |   |\\n| `    | 或  | 两个位都为0时，结果才为0                 |   |\\n| `^`  | 异或 | 两个位相同为0，相异为1                  |   |\\n| `~`  | 取反 | 0变1，1变0                       |   |\\n| `<<` | 左移 | 各二进制位全部左移若干位，高位丢弃，低位补0        |   |\\n| `>>` | 右移 | 各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃 |   |\\n\\n### 1.27 为什么函数的 arguments 参数是类数组而不是数组？如何遍历类数组?\\n\\n`arguments`是一个对象，它的属性是从 0 开始依次递增的数字，还有`callee`和`length`等属性，与数组相似；但是它却没有数组常见的方法属性，如`forEach`, `reduce`等，所以叫它们类数组。\\n\\n要遍历类数组，有三个方法：\\n\\n（1）将数组的方法应用到类数组上，这时候就可以使用`call`和`apply`方法，如：\\n\\n```\\nfunction foo(){ \\n  Array.prototype.forEach.call(arguments, a => console.log(a))\\n}\\n```\\n\\n（2）使用Array.from方法将类数组转化成数组：‌\\n\\n```\\nfunction foo(){ \\n  const arrArgs = Array.from(arguments) \\n  arrArgs.forEach(a => console.log(a))\\n}\\n```\\n\\n（3）使用展开运算符将类数组转化成数组\\n\\n```\\nfunction foo(){ \\n    const arrArgs = [...arguments] \\n    arrArgs.forEach(a => console.log(a)) \\n}\\n```\\n\\n### 1.28 escape、encodeURI、encodeURIComponent 的区别\\n\\n-   encodeURI 是对整个 URI 进行转义，将 URI 中的非法字符转换为合法字符，所以对于一些在 URI 中有特殊意义的字符不会进行转义。\\n-   encodeURIComponent 是对 URI 的组成部分进行转义，所以一些特殊字符也会得到转义。\\n-   escape 和 encodeURI 的作用相同，不过它们对于 unicode 编码为 0xff 之外字符的时候会有区别，escape 是直接在字符的 unicode 编码前加上 %u，而 encodeURI 首先会将字符转换为 UTF-8 的格式，再在每个字节前加上 %。\\n\\n### 1.29 什么是尾调用，使用尾调用有什么好处？\\n\\n尾调用指的是函数的最后一步调用另一个函数。代码执行是基于执行栈的，所以当在一个函数里调用另一个函数时，会保留当前的执行上下文，然后再新建另外一个执行上下文加入栈中。使用尾调用的话，因为已经是函数的最后一步，所以这时可以不必再保留当前的执行上下文，从而节省了内存，这就是尾调用优化。\\n\\n**但是 ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。**\\n\\n### 1.30 use strict是什么? 它有什么用？\\n\\nuse strict 是一种 ECMAscript5 添加的（严格模式）运行模式，这种模式使得 Javascript 在更严格的条件下运行。设立严格模式的目的如下：\\n\\n-   消除 Javascript 语法的不合理、不严谨之处，减少怪异行为;\\n-   消除代码运行的不安全之处，保证代码运行的安全；\\n-   提高编译器效率，增加运行速度；\\n-   为未来新版本的 Javascript 做好铺垫。\\n\\n区别：\\n\\n-   禁止使用 with 语句。\\n-   禁止 this 关键字指向全局对象。\\n-   对象不能有重名的属性。\\n\\n### 1.31 如何判断一个对象是否属于某个类？\\n\\n-   第一种方式，使用 instanceof 运算符来判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。\\n-   第二种方式，通过对象的 constructor 属性来判断，对象的 constructor 属性指向该对象的构造函数，但是这种方式不是很安全，因为 constructor 属性可以被改写。\\n-   第三种方式，如果需要判断的是某个内置的引用类型的话，可以使用 Object.prototype.toString() 方法来打印对象的[[Class]] 属性来进行判断。\\n\\n### 1.32 强类型语言和弱类型语言的区别\\n\\n-   **强类型语言**：强类型语言也称为强类型定义语言，是一种总是强制类型定义的语言，要求变量的使用要严格符合定义，所有变量都必须先定义后使用。Java和C++等语言都是强制类型定义的，也就是说，一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型了。例如你有一个整数，如果不显式地进行转换，你不能将其视为一个字符串。\\n-   **弱类型语言**：弱类型语言也称为弱类型定义语言，与强类型定义相反。JavaScript语言就属于弱类型语言。简单理解就是一种变量类型可以被忽略的语言。比如JavaScript是弱类型定义的，在JavaScript中就可以将字符串'12'和整数3进行连接得到字符串'123'，在相加的时候会进行强制类型转换。\\n\\n两者对比：强类型语言在速度上可能略逊色于弱类型语言，但是强类型语言带来的严谨性可以有效地帮助避免许多错误。\\n\\n### 1.33 解释性语言和编译型语言的区别\\n\\n（1）解释型语言 使用专门的解释器对源程序逐行解释成特定平台的机器码并立即执行。是代码在执行时才被解释器一行行动态翻译和执行，而不是在执行之前就完成翻译。解释型语言不需要事先编译，其直接将源代码解释成机器码并立即执行，所以只要某一平台提供了相应的解释器即可运行该程序。其特点总结如下\\n\\n-   解释型语言每次运行都需要将源代码解释称机器码并执行，效率较低；\\n-   只要平台提供相应的解释器，就可以运行源代码，所以可以方便源程序移植；\\n-   JavaScript、Python等属于解释型语言。\\n\\n（2）编译型语言 使用专门的编译器，针对特定的平台，将高级语言源代码一次性的编译成可被该平台硬件执行的机器码，并包装成该平台所能识别的可执行性程序的格式。在编译型语言写的程序执行之前，需要一个专门的编译过程，把源代码编译成机器语言的文件，如exe格式的文件，以后要再运行时，直接使用编译结果即可，如直接运行exe文件。因为只需编译一次，以后运行时不需要编译，所以编译型语言执行效率高。其特点总结如下：\\n\\n-   一次性的编译成平台相关的机器语言文件，运行时脱离开发环境，运行效率高；\\n-   与特定平台相关，一般无法移植到其他平台；\\n-   C、C++等属于编译型语言。\\n\\n**两者主要区别在于：** 后者源程序编译后即可在该平台运行，前者是在运行期间才编译。所以后者运行速度快，前者跨平台性好。\\n\\n### 1.34 for...in和for...of的区别\\n\\nfor…of 是ES6新增的遍历方式，允许遍历一个含有iterator接口的数据结构（数组、对象等）并且返回各项的值，和ES3中的for…in的区别如下\\n\\n-   for…of 遍历获取的是对象的键值，for…in 获取的是对象的键名；\\n-   for… in 会遍历对象的整个原型链，性能非常差不推荐使用，而 for … of 只遍历当前对象不会遍历原型链；\\n-   对于数组的遍历，for…in 会返回数组中所有可枚举的属性(包括原型链上可枚举的属性)，for…of 只返回数组的下标对应的属性值；\\n\\n**总结：** for...in 循环主要是为了遍历对象而生，不适用于遍历数组；for...of 循环可以用来遍历数组、类数组对象，字符串、Set、Map 以及 Generator 对象。\\n\\n### 1.35 ajax、axios、fetch的区别\\n\\n**（1）AJAX** Ajax 即“AsynchronousJavascriptAndXML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。它是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。其缺点如下：\\n\\n-   本身是针对MVC编程，不符合前端MVVM的浪潮\\n-   基于原生XHR开发，XHR本身的架构不清晰\\n-   不符合关注分离（Separation of Concerns）的原则\\n-   配置和调用方式非常混乱，而且基于事件的异步模型不友好。\\n\\n**（2）Fetch** fetch号称是AJAX的替代品，是在ES6出现的，使用了ES6中的promise对象。Fetch是基于promise设计的。Fetch的代码结构比起ajax简单多。**fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象**。\\n\\nfetch的优点：\\n\\n-   语法简洁，更加语义化\\n-   基于标准 Promise 实现，支持 async/await\\n-   更加底层，提供的API丰富（request, response）\\n-   脱离了XHR，是ES规范里新的实现方式\\n\\nfetch的缺点：\\n\\n-   fetch只对网络请求报错，对400，500都当做成功的请求，服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。\\n-   fetch默认不会带cookie，需要添加配置项： fetch(url, {credentials: 'include'})\\n-   fetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费\\n-   fetch没有办法原生监测请求的进度，而XHR可以\\n\\n**（3）Axios** Axios 是一种基于Promise封装的HTTP客户端，其特点如下：\\n\\n-   浏览器端发起XMLHttpRequests请求\\n-   node端发起http请求\\n-   支持Promise API\\n-   监听请求和返回\\n-   对请求和返回进行转化\\n-   取消请求\\n-   自动转换json数据\\n-   客户端支持抵御XSRF攻击\\n\\n### 1.36 数组的遍历方法有哪些\\n\\n| **方法**                   | **是否改变原数组** | **特点**                                                                  |\\n| ------------------------ | ----------- | ----------------------------------------------------------------------- |\\n| forEach()                | 否           | 数组方法，不改变原数组的长度，没有返回值                                                       |\\n| map()                    | 否           | 数组方法，不改变原数组的长度，有返回值，可链式调用                                                  |\\n| filter()                 | 否           | 数组方法，过滤数组，返回包含符合条件的元素的数组，可链式调用                                          |\\n| for...of                 | 否           | for...of遍历具有Iterator迭代器的对象的属性，返回的是数组的元素、对象的属性值，不能遍历普通的obj对象，将异步循环变成同步循环 |\\n| every() 和 some()         | 否           | 数组方法，some()只要有一个是true，便返回true；而every()只要有一个是false，便返回false.             |\\n| find() 和 findIndex()     | 否           | 数组方法，find()返回的是第一个符合条件的值；findIndex()返回的是第一个返回条件的值的索引值                   |\\n| reduce() 和 reduceRight() | 否           | 数组方法，reduce()对数组正序操作；reduceRight()对数组逆序操作                               |\\n\\n### 1.37 forEach和map方法有什么区别\\n\\n这方法都是用来遍历数组的，两者区别如下：\\n\\n-   forEach()方法会针对每一个元素执行提供的函数，如果遍历的元素是引用数据类型，则可以改变指针指向的堆内存里的值，该方法没有返回值；\\n-   map()方法返回一个新数组，新数组中的值为原数组调用函数处理之后的值，如果遍历的元素是引用数据类型，则可以改变指针指向的堆内存里的值\\n\\n### 1.38 说说你对浅拷贝和深拷贝的理解\\n\\n**浅拷贝**\\n\\n-   浅拷贝，指的是创建新的数据，这个数据有着原始数据属性值的一份精确拷贝\\n-   如果属性是基本类型，拷贝的就是基本类型的值。如果属性是引用类型，拷贝的就是内存地址\\n-   即浅拷贝是拷贝一层，深层次的引用类型则共享内存地址\\n\\n常见的浅拷贝：\\n\\n-   Object.assign\\n-   Object.create\\n-   slice\\n-   concat()\\n-   展开运算符\\n\\n**深拷贝**\\n\\n深拷贝开辟一个新的栈，两个对象属完成相同，但是对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性\\n\\n常见的深拷贝方式有：\\n\\n-   _.cloneDeep()\\n-   jQuery.extend()\\n-   JSON.stringify()\\n-   手写循环递归\\n\\n### 1.39 JSON.stringify深拷贝的缺点\\n\\n-   如果obj里面有时间对象，则JSON.stringify后再JSON.parse的结果，时间将只是字符串的形式，而不是对象的形式\\n-   如果obj里面有RegExp，则打印出来是空对象\\n-   如果对象中有函数或者undefined，则会直接被丢掉\\n-   如果json里有对象是由构造函数生成的，则会丢掉对象的constructon\\n\\n### 1.40 知道lodash吗？它有哪些常见的API ？\\n\\nLodash是一个一致性、模块化、高性能的 JavaScript 实用工具库。\\n\\n-   _.cloneDeep 深度拷贝\\n-   _.reject 根据条件去除某个元素。\\n-   _.drop(array, [n=1] ) 作用：将 `array` 中的前 `n` 个元素去掉，然后返回剩余的部分.\\n\\n### 1.41 LHS 和 RHS 查询\\n\\n`LHS (Left-hand Side)` 和 `RHS (Right-hand Side)` ，是在代码执行阶段 JS 引擎操作变量的两种方式，二者区别就是对变量的查询目的是 **变量赋值** 还是 **查询** 。\\n\\n**LHS** 可以理解为变量在赋值操作符`(=)`的左侧，例如 `a = 1`，当前引擎对变量 `a` 查找的目的是**变量赋值**。这种情况下，引擎不关心变量 `a` 原始值是什么，只管将值 `1` 赋给 `a` 变量。\\n\\n**RHS** 可以理解为变量在赋值操作符`(=)`的右侧，例如：`console.log(a)`，其中引擎对变量`a`的查找目的就是 **查询**，它需要找到变量 `a` 对应的实际值是什么，然后才能将它打印出来。\\n\\n### 1.42 includes 比 indexOf好在哪？\\n\\nincludes可以检测`NaN`，indexOf不能检测`NaN`，includes内部使用了`Number.isNaN`对`NaN`进行了匹配\\n\\n### 1.43 AMD 和 CMD 的区别？\\n\\n| 模块化 | 代表应用       | 特点                                    |\\n| --- | ---------- | ------------------------------------- |\\n| AMD | require.js | 1、AMD的api默认一个当多个用 2、依赖前置，异步执行         |\\n| CMD | sea.js     | 1、CMD的api严格区分，推崇职责单一 2、依赖就近，按需加载，同步执行 |\\n\\n### 1.44 (a == 1 && a == 2 && a == 3) 有可能是 true 吗？\\n **方案一：重写toString()或valueOf()**\\n\\n```\\nlet a = {  \\n    i: 1,  \\n    toString: function () {    \\n        return a.i++;  \\n    }\\n}\\nconsole.log(a == 1 && a == 2 && a == 3); // true\\n```\\n **方案二：数组**\\n\\n数组的toString接口默认调用数组的join方法，重写join方法。定义a为数字，每次比较时就会调用 toString()方法，我们把数组的shift方法覆盖toString即可：\\n\\n```\\nlet a = [1,2,3];\\na.toString = a.shift;\\nconsole.log(a == 1 && a == 2 && a == 3); // true\\n```\\n\\n当然把toString改为valueOf也是一样效果：\\n\\n```\\nlet a = [1,2,3];\\na. valueOf  = a.shift;\\nconsole.log(a == 1 && a == 2 && a == 3); // true\\n```\\n **方案三：使用Object.defineProperty()**\\n\\nObject.defineProperty()用于定义对象中的属性，接收三个参数：object对象、对象中的属性，属性描述符。属性描述符中get:访问该属性时自动调用。\\n\\n```\\nvar  _a = 1;\\nObject.defineProperty(this,'a',{  \\n    get:function(){    \\n        return _a++  \\n    }\\n})\\nconsole.log(a===1 && a===2 && a===3)//true\\n```\\n### 1.45 JS中的 MUL 函数\\n\\nMUL表示数的简单乘法。在这种技术中，将一个值作为参数传递给一个函数，而该函数将返回另一个函数，将第二个值传递给该函数，然后重复继续。例如:x*y*z可以表示为\\n\\n```\\nconst mul = x => y => z => x * y * z\\n​\\nconsole.log(mul(1)(2)(3)) // 6\\n```\\n\\n### 1.46 深度遍历广度遍历的区别？\\n\\n对于算法来说 无非就是时间换空间 空间换时间\\n\\n-   1、深度优先不需要记住所有的节点, 所以占用空间小, 而广度优先需要先记录所有的节点占用空间大\\n-   2、深度优先有回溯的操作(没有路走了需要回头)所以相对而言时间会长一点\\n-   3、深度优先采用的是**堆栈**的形式, 即先进后出\\n-   4、广度优先则采用的是**队列**的形式, 即先进先出\\n\\n### 1.47 JS中的设计模式有哪些？\\n\\n#### **单例模式**\\n\\n保证一个类仅有一个实例，并提供一个访问它的全局访问点。实现的方法为先判断实例存在与否，如果存在则直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。\\n\\n#### **策略模式**\\n\\n定义一系列的算法，把他们一个个封装起来，并且使他们可以相互替换。\\n\\n#### **代理模式**\\n\\n为一个对象提供一个代用品或占位符，以便控制对它的访问。\\n\\n#### **中介者模式**\\n\\n通过一个中介者对象，其他所有的相关对象都通过该中介者对象来通信，而不是相互引用，当其中的一个对象发生改变时，只需要通知中介者对象即可。通过中介者模式可以解除对象与对象之间的紧耦合关系。\\n\\n#### **装饰者模式**\\n\\n在不改变对象自身的基础上，在程序运行期间给对象动态地添加方法。\\n\\n### 1.48 forEach如何跳出循环？\\n\\nforEach是不能通过`break`或者`return`来实现跳出循环的，为什么呢？实现过forEach的同学应该都知道，forEach的的回调函数形成了一个作用域，在里面使用`return`并不会跳出，只会被当做`continue`\\n\\n可以利用`try catch`\\n\\n```\\n　　function getItemById(arr, id) {\\n        var item = null;\\n        try {\\n            arr.forEach(function (curItem, i) {\\n                if (curItem.id == id) {\\n                    item = curItem;\\n                    throw Error();\\n                }\\n            })\\n        } catch (e) {\\n        }\\n        return item;\\n    }\\n```\\n\\n### 1.49 JS中如何将页面重定向到另一个页面？\\n\\n1、使用 location.href：window.location.href =\\\"url\\\"\\n\\n2、使用 location.replace： window.location.replace(\\\"url\\\");\\n\\n### 1.50 移动端如何实现上拉加载，下拉刷新？\\n\\n**上拉加载**\\n\\n上拉加载的本质是页面触底，或者快要触底时的动作\\n\\n判断页面触底我们需要先了解一下下面几个属性\\n\\n-   `scrollTop`：滚动视窗的高度距离`window`顶部的距离，它会随着往上滚动而不断增加，初始值是0，它是一个变化的值\\n-   `clientHeight`:它是一个定值，表示屏幕可视区域的高度；\\n-   `scrollHeight`：页面不能滚动时也是存在的,此时scrollHeight等于clientHeight。scrollHeight表示`body`所有元素的总长度(包括body元素自身的padding)\\n\\n综上我们得出一个触底公式：\\n\\n```\\nscrollTop + clientHeight >= scrollHeight\\n```\\n\\n**下拉刷新**\\n\\n下拉刷新的本质是页面本身置于顶部时，用户下拉时需要触发的动作\\n\\n关于下拉刷新的原生实现，主要分成三步：\\n\\n-   监听原生`touchstart`事件，记录其初始位置的值，`e.touches[0].pageY`；\\n-   监听原生`touchmove`事件，记录并计算当前滑动的位置值与初始位置值的差值，大于`0`表示向下拉动，并借助CSS3的`translateY`属性使元素跟随手势向下滑动对应的差值，同时也应设置一个允许滑动的最大值；\\n-   监听原生`touchend`事件，若此时元素滑动达到最大值，则触发`callback`，同时将`translateY`重设为`0`，元素回到初始位置\\n\\n### 1.51 JS 中的数组和函数在内存中是如何存储的？\\n\\nJavaScript 中的数组存储大致需要分为两种情况：\\n\\n-   同种类型数据的数组分配连续的内存空间\\n-   存在非同种类型数据的数组使用哈希映射分配内存空间\\n\\n> 温馨提示：可以想象一下连续的内存空间只需要根据索引（指针）直接计算存储位置即可。如果是哈希映射那么首先需要计算索引值，然后如果索引值有冲突的场景下还需要进行二次查找（需要知道哈希的存储方式）。\\n\\n# 二、闭包与作用域\\n### 2.1 什么是闭包？\\n\\n-   ✅ 官方说法：闭包就是指有权访问另一个函数作用域中的变量的函数。\\n-   ✅ MDN说法：闭包是一种特殊的对象。它由两部分构成：函数，以及创建该函数的环境。环境由闭包创建时在作用域中的任何局部变量组成。\\n\\n**深度回答**\\n\\n浏览器在加载页面会把代码放在栈内存（ ECStack ）中执行，函数进栈执行会产生一个私有上下文（ EC ），此上下文能保护里面的使用变量（ AO ）不受外界干扰，并且如果当前执行上下文中的某些内容，被上下文以外的内容占用，当前上下文不会出栈释放，这样可以保存里面的变量和变量值，所以我认为闭包是一种保存和保护内部私有变量的机制。\\n\\n### 2.2 闭包的作用\\n\\n闭包有两个常用的用途；\\n\\n-   闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来**创建私有变量**。\\n-   闭包的另一个用途是使已经运行结束的函数上下文中的**变量对象继续留在内存中**，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。\\n\\n### 2.3 闭包在项目中的引用场景，以及带来的问题\\n\\n在实际的项目中，会基于闭包把自己编写的模块内容包裹起来，这样编写就可以保护自己的代码是私有的，防止和全局变量或者是其他的代码冲突，这一点是利用保护机制。\\n\\n但是不建议过多的使用闭包，因为使用不被释放的上下文，是占用栈内存空间的，过多的使用会导致导致内存泄漏。\\n\\n解决闭包带来的内存泄漏问题的方法是：使用完闭包函数后手动释放。\\n\\n### 2.4 闭包的使用场景\\n\\n1.   `return` 回一个函数\\n2.   函数作为参数\\n3.   IIFE（自执行函数）\\n4.   循环赋值\\n5.   使用回调函数就是在使用闭包\\n6.   节流防抖\\n7.   函数柯里化\\n\\n### 2.5 闭包的执行过程\\n\\n1.  形成私有上下文\\n\\n2.  进栈执行\\n\\n3.  一系列操作\\n\\n    (1).  初始化作用域链（两头<当前作用域，上级作用域>）\\n\\n    (2).  初始化this\\n\\n    (3).  初始化arguments\\n\\n    (4).  赋值形参\\n\\n    (5).  变量提升\\n\\n    (6).  代码执行\\n\\n    -    遇到变量就先看是否是自己私有的，不是自己私有的按照作用域链上查找，如果不是上级的就继续线上查找，，直到 EC(G)，变量的查找其实就是一个作用域链的拼接过程，拼接查询的链式就是作用域链。\\n\\n4.  正常情况下，代码执行完成之后，私有上下文出栈被回收。但是遇到特殊情况，如果当前私有上下文执行完成之后中的某个东西被执行上下文以外的东西占用，则当前私有上下文就不会出栈释放，也就是形成了不被销毁的上下文，闭包。\\n\\n### 2.6 执行上下文的类型\\n\\n**（1）全局执行上下文**\\n\\n任何不在函数内部的都是全局执行上下文，它首先会创建一个全局的window对象，并且设置this的值等于这个全局对象，一个程序中只有一个全局执行上下文。\\n\\n**（2）函数执行上下文**\\n\\n当一个函数被调用时，就会为该函数创建一个新的执行上下文，函数的上下文可以有任意多个。\\n\\n**（3）** `eval`**函数执行上下文**\\n\\n执行在eval函数中的代码会有属于他自己的执行上下文，不过eval函数不常使用，不做介绍。\\n\\n### 2.7 执行上下文栈是什么\\n\\n-   JavaScript引擎使用执行上下文栈来管理执行上下文\\n-   当JavaScript执行代码时，首先遇到全局代码，会创建一个全局执行上下文并且压入执行栈中，每当遇到一个函数调用，就会为该函数创建一个新的执行上下文并压入栈顶，引擎会执行位于执行上下文栈顶的函数，当函数执行完成之后，执行上下文从栈中弹出，继续执行下一个上下文。当所有的代码都执行完毕之后，从栈中弹出全局执行上下文。\\n\\n### 2.8 执行上下文的三个阶段\\n\\n**创建阶段 → 执行阶段 → 回收阶段**\\n\\n***\\n\\n**创建阶段**\\n\\n（1）this绑定\\n\\n-   在全局执行上下文中，this指向全局对象（window对象）\\n-   在函数执行上下文中，this指向取决于函数如何调用。如果它被一个引用对象调用，那么 this 会被设置成那个对象，否则 this 的值被设置为全局对象或者 undefined\\n\\n（2）创建词法环境组件\\n\\n-   词法环境是一种有**标识符——变量映射**的数据结构，标识符是指变量/函数名，变量是对实际对象或原始数据的引用。\\n-   词法环境的内部有两个组件：**加粗样式**：环境记录器:用来储存变量个函数声明的实际位置**外部环境的引用**：可以访问父级作用域\\n\\n（3）创建变量环境组件\\n\\n-   变量环境也是一个词法环境，其环境记录器持有变量声明语句在执行上下文中创建的绑定关系。\\n\\n**执行阶段**\\n\\n在这阶段，执行变量赋值、代码执行\\n\\n如果 `Javascript` 引擎在源代码中声明的实际位置找不到变量的值，那么将为其分配 `undefined` 值\\n\\n**回收阶段**\\n\\n执行上下文出栈等待虚拟机回收执行上下文\\n\\n### 2.9 谈谈你对作用域的理解\\n\\n-   作用域可以视为一套规则，这套规则用来管理引擎如何在当前作用域以及嵌套的子作用域根据标识符名称进行变量查找。\\n-   简单来说作用域就是变量的有效范围。在一定的空间里可以对变量数据进行读写操作，这个空间就是变量的作用域。\\n\\n#### （1）全局作用域\\n\\n-   直接写在script标签的JS代码，都在全局作用域。在全局作用域下声明的变量叫做全局变量（在块级外部定义的变量）。\\n\\n-   全局变量在全局的任何位置下都可以使用；全局作用域中无法访问到局部作用域的中的变量。\\n\\n-   全局作用域在页面打开的时候创建，在页面关闭时销毁。\\n\\n-   **所有 window 对象的属性拥有全局作用域**\\n\\n    *var和function命令声明的全局变量和函数是window对象的属性和方法*\\n\\n    let命令、const命令、class命令声明的全局变量，不属于window对象的属性\\n\\n#### （2）函数作用域(局部作用域)\\n\\n-   调用函数时会创建函数作用域，函数执行完毕以后，作用域销毁。每调用一次函数就会创建一个新的函数作用域，他们之间是相互独立的。\\n-   在函数作用域中可以访问全局变量，在函数的外面无法访问函数内的变量。\\n-   当在函数作用域操作一个变量时，它会先在自身作用域中寻找，如果有就直接使用，如果没有就向上一作用域中寻找，直到找到全局作用域，如果全局作用域中仍然没有找到，则会报错。\\n\\n#### （3）块级作用域\\n\\n-   ES6之前JavaScript采用的是函数作用域+词法作用域，ES6引入了块级作用域。\\n-   任何一对花括号{}中的语句集都属于一个块,**在块中使用let和const声明的变量**，外部是访问不到的，这种作用域的规则就叫块级作用域。\\n-   通过var声明的变量或者非严格模式下创建的函数声明没有块级作用域。\\n\\n#### （4）词法作用域\\n\\n-   词法作用域是静态的作用域，无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由**函数被声明时所处的位置**决定。\\n-   编译的词法分析阶段基本能够知道全部标识符在哪里以及是如何声明的，从而能够预测在执行过中如何对它们进行查找。\\n-   换句话说，词法作用域就是你在写代码的时候就已经决定了变量的作用域。\\n\\n### 2.10 什么是作用域链\\n\\n当在`js`中使用一个变量的时候，首先`js`引擎会尝试在当前作用域下去寻找该变量，如果没找到，再到它的上层作用域寻找，以此类推直到找到该变量或是已经到了全局作用域，这样的变量作用域访问的链式结构, 被称之为作用域链\\n\\n**深度回答**\\n\\n作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。\\n\\n### 2.11 作用域链的作用\\n\\n作用域链的作用是**保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，可以访问到外层环境的变量和函数。**\\n\\n### 2.12 作用域的常见应用场景\\n\\n作用域的一个常见运用场景之一，就是 **模块化**。\\n\\n由于 javascript 并未原生支持模块化导致了很多令人口吐芬芳的问题，比如全局作用域污染和变量名冲突，代码结构臃肿且复用性不高。在正式的模块化方案出台之前，开发者为了解决这类问题，想到了使用函数作用域来创建模块的方案。\\n\\n\\n### 2.13 说说Js中的预解析？\\n\\nJS 引擎在运行一份代码的时候，会按照下面的步骤进行工作：\\n\\n1.把变量的声明提升到当前作用域的最前面，只会提升声明，不会提升赋值\\n\\n2.把函数的声明提升到当前作用域的最前面，只会提升声明，不会提升调用\\n\\n3.先提升 function，在提升 var\\n\\n### 2.14 变量提升与函数提升的区别？\\n\\n**变量提升**\\n\\n简单说就是在 JavaScript 代码执行前引擎会先进行预编译，预编译期间会将`变量声明与函数声明`提升至其`对应作用域的最顶端`，`函数内声明的变量`只会提升至`该函数作用域最顶层`，`当函数内部定义的一个变量与外部相同时`，那么`函数体内的这个变量就会被上升到最顶端`。\\n\\n**函数提升**\\n\\n函数提升只会提升函数声明式写法，函数表达式的写法不存在函数提升\\n\\n函数提升的优先级大于变量提升的优先级，即函数提升在变量提升之上\\n\\n### 2.14 如何延长作用域链？\\n\\n作用域链是可以延长的。\\n\\n延长作用域链： 执行环境的类型只有两种，全局和局部（函数）。但是有些语句可以在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后被移除。\\n\\n具体来说就是执行这两个语句时，作用域链都会得到加强\\n\\n0.  try - catch 语句的 catch 块：会创建一个新的变量对象，包含的是被抛出的错误对 象的声明。\\n0.  with 语句：with 语句会将指定的对象添加到作用域链中。\\n\\n### 2.15 浏览器的垃圾回收机制\\n\\n#### （1）内存的生命周期\\n\\nJS 环境中分配的内存, 一般有如下生命周期：\\n\\n0.  内存分配：当我们声明变量、函数、对象的时候，系统会自动为他们分配内存\\n\\n0.  内存使用：即读写内存，也就是使用变量、函数等\\n\\n0.  内存回收：使用完毕，由垃圾回收自动回收不再使用的内存\\n\\n    全局变量一般不会回收, 一般局部变量的的值, 不用了, 会被自动回收掉\\n\\n#### （2）垃圾回收的概念\\n\\n**垃圾回收**：JavaScript代码运行时，需要分配内存空间来储存变量和值。当变量不在参与运行时，就需要系统收回被占用的内存空间，这就是垃圾回收。\\n\\n**回收机制**：\\n\\n-   Javascript 具有自动垃圾回收机制，会定期对那些不再使用的变量、对象所占用的内存进行释放，原理就是找到不再使用的变量，然后释放掉其占用的内存。\\n-   JavaScript中存在两种变量：局部变量和全局变量。全局变量的生命周期会持续要页面卸载；而局部变量声明在函数中，它的生命周期从函数执行开始，直到函数执行结束，在这个过程中，局部变量会在堆或栈中存储它们的值，当函数执行结束后，这些局部变量不再被使用，它们所占有的空间就会被释放。\\n-   不过，当局部变量被外部函数使用时，其中一种情况就是闭包，在函数执行结束后，函数外部的变量依然指向函数内部的局部变量，此时局部变量依然在被使用，所以不会回收。\\n\\n#### （3）垃圾回收的方式\\n\\n**1.引用计数法**\\n\\n-   这个用的相对较少，IE采用的引用计数算法。引用计数就是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1。当这个引用次数变为0时，说明这个变量已经没有价值，因此，在在机回收期下次再运行时，这个变量所占有的内存空间就会被释放出来。\\n-   这种方法会引起**循环引用**的问题：例如：`obj1`和`obj2`通过属性进行相互引用，两个对象的引用次数都是2。当使用循环计数时，由于函数执行完后，两个对象都离开作用域，函数执行结束，`obj1`和`obj2`还将会继续存在，因此它们的引用次数永远不会是0，就会引起循环引用。\\n\\n**2.标记清除法**\\n\\n现代的浏览器已经不再使用引用计数算法了。\\n\\n现代浏览器通用的大多是基于标记清除算法的某些改进算法，总体思想都是一致的。\\n\\n-   标记清除是浏览器常见的垃圾回收方式，当变量进入执行环境时，就标记这个变量“进入环境”，被标记为“进入环境”的变量是不能被回收的，因为他们正在被使用。当变量离开环境时，就会被标记为“离开环境”，被标记为“离开环境”的变量会被内存释放。\\n-   垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。\\n\\n#### （4）如何减少垃圾回收\\n\\n虽然浏览器可以进行垃圾自动回收，但是当代码比较复杂时，垃圾回收所带来的代价比较大，所以应该尽量减少垃圾回收。\\n\\n-   **对数组进行优化：** 在清空一个数组时，最简单的方法就是给其赋值为[ ]，但是与此同时会创建一个新的空对象，可以将数组的长度设置为0，以此来达到清空数组的目的。\\n-   **对**`object`**进行优化：** 对象尽量复用，对于不再使用的对象，就将其设置为null，尽快被回收。\\n-   **对函数进行优化：** 在循环中的函数表达式，如果可以复用，尽量放在函数的外面。\\n\\n#### （5）内存泄漏是什么\\n\\n是指由于疏忽或错误造成程序未能释放已经不再使用的内存\\n\\n#### （6）哪些情况会导致内存泄漏\\n\\n以下四种情况会造成内存的泄漏：\\n\\n-   **意外的全局变量：** 由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。\\n-   **被遗忘的计时器或回调函数：** 设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。\\n-   **脱离 DOM 的引用：** 获取一个 DOM 元素的引用，而后面这个元素被删除，由于一直保留了对这个元素的引用，所以它也无法被回收。\\n-   **闭包：** 不合理的使用闭包，从而导致某些变量一直被留在内存当中。\\n\\n# 三、 函数与函数式编程\\n### 3.1 什么是函数式编程\\n\\n函数式编程是一种\\\"编程范式\\\"（programming paradigm），一种编写程序的方法论\\n\\n主要的编程范式有三种：命令式编程，声明式编程和函数式编程\\n\\n相比命令式编程，函数式编程更加强调程序执行的结果而非执行的过程，倡导利用若干简单的执行单元让计算结果不断渐进，逐层推导复杂的运算，而非设计一个复杂的执行过程\\n\\n### 3.2 函数式编程的优缺点\\n\\n**优点**\\n\\n-   更好的管理状态：因为它的宗旨是无状态，或者说更少的状态，能最大化的减少这些未知、优化代码、减少出错情况\\n-   更简单的复用：固定输入->固定输出，没有其他外部变量影响，并且无副作用。这样代码复用时，完全不需要考虑它的内部实现和外部影响\\n-   更优雅的组合：往大的说，网页是由各个组件组成的。往小的说，一个函数也可能是由多个小函数组成的。更强的复用性，带来更强大的组合性\\n-   隐性好处。减少代码量，提高维护性\\n\\n**缺点**\\n\\n-   性能：函数式编程相对于指令式编程，性能绝对是一个短板，因为它往往会对一个方法进行过度包装，从而产生上下文切换的性能开销\\n-   资源占用：在 JS 中为了实现对象状态的不可变，往往会创建新的对象，因此，它对垃圾回收所产生的压力远远超过其他编程方式\\n-   递归陷阱：在函数式编程中，为了实现迭代，通常会采用递归操作\\n\\n### 3.3 什么是纯函数，它有什么优点\\n\\n纯函数是对给定的输入返还相同输出的函数，并且要求你所有的数据都是不可变的，即纯函数=无状态+数据不可变\\n\\n特性：\\n\\n-   函数内部传入指定的值，就会返回确定唯一的值\\n-   不会造成超出作用域的变化，例如修改全局变量或引用传递的参数\\n\\n优势：\\n\\n-   使用纯函数，我们可以产生可测试的代码\\n-   不依赖外部环境计算，不会产生副作用，提高函数的复用性\\n-   可读性更强 ，函数不管是否是纯函数 都会有一个语义化的名称，更便于阅读\\n-   可以组装成复杂任务的可能性。符合模块化概念及单一职责原则\\n\\n### 3.4 什么是组合函数 (compose)\\n\\n在函数式编程中，有一个很重要的概念就是函数组合，实际上就是把处理的函数数据像管道一样连接起来，然后让数据穿过管道连接起来，得到最终的结果。\\n\\n组合函数，其实大致思想就是将 多个函数组合成一个函数，c(b(a(a(1)))) 这种写法简写为 compose(c, b, a, a)(x) 。但是注意这里如果一个函数都没有传入，那就是传入的是什么就返回什么，并且函数的执行顺序是和传入的顺序相反的。\\n\\n```\\nvar compose = (...funcs) => {\\n  // funcs(数组)：记录的是所有的函数\\n  // 这里其实也是利用了柯里化的思想，函数执行，生成一个闭包，预先把一些信息存储，供下级上下文使用\\n  return (x) => {\\n    var len = funcs.length;\\n    // 如果没有函数执行，直接返回结果\\n    if (len === 0) return x;\\n    if (len === 1) funcs[0](x);\\n    return funcs.reduceRight((res, func) => {\\n      return func(res);\\n    }, x);\\n  };\\n};\\nvar resFn = compose(c, b, a, a);\\nresFn(1);\\n```\\n\\n组合函数的思想，在很多框架中也被使用，例如：redux，实现效果来说是其实和上面的代码等价。\\n\\n### 3.5 什么是惰性函数\\n\\n惰性载入表示函数执行的分支只会在函数第一次掉用的时候执行，在第一次调用过程中，该函数会被覆盖为另一个按照合适方式执行的函数，这样任何对原函数的调用就不用再经过执行的分支了\\n\\n**惰性函数相当于有记忆的功能一样，当它已经判断了一遍的话，第二遍就不会再判断了。**\\n\\n比如现在要求写一个test函数，这个函数返回首次调用时的new Date().getTime()，注意是首次，而且不允许有全局变量的污染\\n\\n```\\n//一般会这样实现\\nvar test = (function () {\\n    var t = null;\\n    return function () {\\n        if (t) {\\n            return t;\\n        }\\n        t = new Date().getTime();\\n        return t;\\n    }\\n})();\\n// 用惰性函数实现\\nvar test = function () {\\n    var t = new Date().getTime();\\n    test = function () {\\n        return t;\\n    }\\n    return test();\\n}\\nconsole.log(test());\\nconsole.log(test());\\nconsole.log(test());\\n```\\n\\n### 3.6 什么是高阶函数\\n\\n高阶函数是指使用其他函数作为参数、或者返回一个函数作为结果的函数。\\n\\n### 3.7 说说你对函数柯里化的理解\\n\\n柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数且返回结果的新函数的技术。\\n\\n函数柯里化的好处：\\n\\n（1）参数复用：需要输入多个参数，最终只需输入一个，其余通过 arguments 来获取\\n\\n（2）提前确认：避免重复去判断某一条件是否符合，不符合则 return 不再继续执行下面的操作\\n\\n（3）延迟运行：避免重复的去执行程序，等真正需要结果的时候再执行\\n\\n### 3.8 什么是箭头函数，有什么特征\\n\\n使用 \\\"箭头\\\" ( => ) 来定义函数. 箭头函数相当于匿名函数, 并且简化了函数定义\\n\\n**箭头函数的特征:**\\n\\n-   箭头函数没有this, this指向定义箭头函数所处的外部环境\\n-   箭头函数的this永远不会变，call、apply、bind也无法改变\\n-   箭头函数只能声明成**匿名函数**，但可以通过表达式的方式让箭头函数具名\\n-   箭头函数没有原型prototype\\n-   箭头函数不能当做一个构造函数 因为 this 的指向问题\\n-   箭头函数没有 arguments 在箭头函数内部访问这个变量访问的是外部环境的arguments, 可以使用 ...代替\\n\\n### 3.9 说说你对递归函数的理解\\n\\n如果一个函数在内部调用自身本身，这个函数就是递归函数\\n\\n其核心思想是把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解\\n\\n一般来说，递归需要有边界条件、递归前进阶段和递归返回阶段。当边界条件不满足时，递归前进；当边界条件满足时，递归返回\\n\\n**优点**：结构清晰、可读性强\\n\\n**缺点**：效率低、调用栈可能会溢出，其实每一次函数调用会在内存栈中分配空间，而每个进程的栈的容量是有限的，当调用的层次太多时，就会超出栈的容量，从而导致栈溢出。\\n\\n### 3.10 什么是尾递归\\n\\n尾递归，即在函数尾位置调用自身（或是一个尾调用本身的其他函数等等）。\\n\\n在递归调用的过程当中系统为每一层的返回点、局部量等开辟了栈来存储，递归次数过多容易造成栈溢出\\n\\n这时候，我们就可以使用尾递归，即一个函数中所有递归形式的调用都出现在函数的末尾，对于尾递归来说，由于只存在一个调用记录，所以永远不会发生\\\"栈溢出\\\"错误\\n\\n### 3.11 函数传参，传递复杂数据类型和简单数据类型有什么区别\\n\\n传递复杂数据类型传递的是引用的地址，修改会改变\\n\\n简单数据类型传递的是具体的值，不会相互影响\\n\\n```\\n/* let a = 8\\n    function fn(a) {\\n      a = 9\\n    }\\n    fn(a)\\n    console.log(a) // 8 */\\n​\\n    let a = { age: 8 }\\n    function fn(a) {\\n      a.age = 9\\n    }\\n    fn(a)\\n    console.log(a.age) // 9\\n```\\n\\n### 3.12 函数声明与函数表达式的区别\\n\\n**函数声明：** funtion开头，有函数提升\\n\\n**函数表达式**: 不是funtion开头，没有函数提升\\n\\n### 3.13 什么是函数缓存，如何实现？\\n\\n**概念**\\n\\n函数缓存，就是将函数运算过的结果进行缓存\\n\\n本质上就是用空间（缓存存储）换时间（计算过程）\\n\\n常用于缓存数据计算结果和缓存对象\\n\\n**如何实现**\\n\\n实现函数缓存主要依靠闭包、柯里化、高阶函数\\n\\n**应用场景**\\n\\n-   对于昂贵的函数调用，执行复杂计算的函数\\n-   对于具有有限且高度重复输入范围的函数\\n-   对于具有重复输入值的递归函数\\n-   对于纯函数，即每次使用特定输入调用时返回相同输出的函数\\n\\n### 3.14 call、apply、bind三者的异同\\n\\n**共同点** :\\n\\n-   都可以改变this指向;\\n-   三者第一个参数都是`this`要指向的对象，如果如果没有这个参数或参数为`undefined`或`null`，则默认指向全局`window`\\n\\n**不同点**:\\n\\n-   call 和 apply 会调用函数, 并且改变函数内部this指向.\\n-   call 和 apply传递的参数不一样,call传递参数使用逗号隔开,apply使用数组传递，且`apply`和`call`是一次性传入参数，而`bind`可以分为多次传入\\n-   `bind`是返回绑定this之后的函数\\n\\n**应用场景**\\n\\n0.  call 经常做继承.\\n0.  apply经常跟数组有关系. 比如借助于数学对象实现数组最大值最小值\\n0.  bind 不调用函数,但是还想改变this指向. 比如改变定时器内部的this指向",
        "tags": [
            "前端",
            "JavaScript",
            "面试"
        ]
    },
    {
        "article_id": "7161020844372656135",
        "cover_image": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f4529f019114ff49e267430b808259a~tplv-k3u1fbpfcp-watermark.image?",
        "title": "用真心打造一个沉淀知识的工具，为学渣如我的道友们，提供助力",
        "brief": "学的快，忘得快，我要总结原因： 1. 没有第一时间的沉淀经验 2. 学的多，但是不成系统 4. 学习漫无目的，没有方向",
        "user_name": "闲D阿强",
        "view_count": 5649,
        "collect_count": 138,
        "comment_count": 34,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/8247dae1f9049f76b6839fc6c98d162e~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: smartblue\\n---\\n\\n>**本文为稀土掘金技术社区首发签约文章，14天内禁止转载，14天后未获授权禁止转载，侵权必究！**\\n# 学的快，忘得快，我要总结原因\\n## 没有第一时间的沉淀经验\\n编程是个经验活，搬砖能有多难么？但是不运用经验，那会相当累，这是肯定的，就算你曾经做过的功能，过一阵不用再捡起来，可能跟没做过差不多，而且往往还不如没做过，零星的记忆反而会让你麻痹大意，放弃了思考，从而陷入泥潭，所以经验的沉淀是相当重要的，对于我们这个工种。\\n\\n## 学的多，但是不成系统\\n见到啥学啥，本身没什么错，这是一种积累能量的办法，只不过，这些零散的能量如果不能及时内化形成自身实力，那么就会原模原样的还回去，风过无痕，所以一定要构筑自己的知识体系，这样便可以将知识网住。\\n\\n## 学习漫无目的，没有方向\\n学习没有目标，学一个东西，没坚持几天，又去学别的了，总是东一榔头西一棒槌，最后到头来一场空，样样学，样样瘟，问题出在哪？就出在你没有方向，你迷了，要“正”过来，所以需要时刻提醒自己，你的方向是啥，结硬寨打呆仗。\\n\\n# 说说我的解决方案\\n\\n## 要有文章，但不能全是文章\\n\\n首先肯定要有文章，但要全是文章的话，那直接做个静态Blog得了，不能是静止的东西，要“活”的，而且文章太线性了，知识是存在脑子里的，是线性的？我觉得更应该是立体发散的知识网才对。\\n\\n**成果展示：**\\n\\n<img src=\\\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e3a770a39c8419fa8a68c55b9dc8612~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"ezgif.com-gif-maker (7).gif\\\" width=\\\"70%\\\" />\\n\\n## 要有知识体系，并且是自动生成的\\n要有一个知识体系，一个基于众多经验文章生成的，具象化的网，文章目录将脑海里发散的知识点串成了线，而知识体系需要采用一种非线性的方式，来把知识网表达出来。\\n\\n**成果展示：**\\n\\n<img src=\\\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/959b0095fafb423497a99c8b13c2b503~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"ezgif.com-gif-maker (9).gif\\\" width=\\\"70%\\\" />\\n\\nem～～～这不是我心里的样子，我就是在antv上的多看了一眼，就选ta试试，颜值真不错。\\n\\n## 文章和知识体系进行关联\\n众多文章就如同物质，生发出来了知识体系，二者互为表里，相互关联，通过不断更新调整这个知识体系，不断的将脑海里的知识投射出来并具像化，方便推敲，又利于记忆。\\n\\n\\n**成果展示：**\\n\\n<img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51ee66b504b14744b9d9d8879d6a6260~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"ezgif.com-gif-maker (10).gif\\\" width=\\\"70%\\\" />\\n\\n## 可以在线编写代码块，并且可以预览\\n在描述一段代码的功用时，光用文字就会显得很苍白，相比之下，直接可以运行并能预览效果就显得更直观，整一个可以在线代码预览工具，就变得很有必要。\\n\\n**成果展示：**\\n\\n<img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1fd2e3834f9d452c852568563c06d7f7~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"ezgif.com-gif-maker (8).gif\\\" width=\\\"70%\\\" />\\n\\n## 要有成果展示，要学以致用\\n光学不出成果，肯定不行，要知行合一，真刀真枪的干，同时又能加强成就感，也是一个正向反馈，激励自己继续努力。\\n\\n**成果展示：**\\n\\n<img src=\\\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/030681e3a5e349ff9bc4ac96bd4ec846~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\" width=\\\"70%\\\" />\\n\\n## 制定计划，并记录进步情况\\n我们在修行的时候，需要制定目标，在实现这个目标的时候，可能还需要制定其他目标，这样时间跨度就会拉长，那么初心可能真就容易忘了，所以你需要知道自己从哪来，这样你才能知道你接下来要去哪，可能有些豪言壮语没做成，也许就是忘了你要干嘛了，所以我们需要把目标管理起来。\\n\\n**效果图：**\\n\\n<img src=\\\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a480b1e9fa7849598dde23fb6f1a9267~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\" width=\\\"70%\\\" />\\n\\n还在开发中，构思怎么做好～～～\\n\\n# 技术栈\\n首先项目是用**Reac**t写的，组件库用的**Mui**。\\n\\n选**React**的原因：我喜欢React，JS浓度大，不用总翻api，现有的api组合就能搞大部分的业务，越写越灵活。\\n\\n选**Mui**的原因：首先我有调整样式的需求，`Mui`本身就推崇`css in js`，主题设置这块相当强，能够很轻松的把控方方面面的表现细节，这对于一个有视觉需求的项目，非常有用。\\n\\n**接下来，概览一下，项目关键功能都是咋做的，具体实现细节后续我会单写文章深入说。**\\n\\n## 文章呈现\\n文章要采用**markdown**格式，所以我选择了`react-markdown`这个库，这个库超强的。\\n\\n### 使用方式\\n\\n大体如下\\n```js\\nimport ReactMarkdown from 'react-markdown'\\nimport rehypeRaw from 'rehype-raw'\\nimport rehypeComponents from './plugins/rehype-components'\\nimport codeBlock from \\\"./codeBlock\\\";\\n\\n...\\n<ReactMarkdown\\n    children={md} // md就是你传入的md文档内容\\n    rehypePlugins={[rehypeRaw]}\\n    remarkPlugins={[gfm]}\\n    components={{ ...codeBlock(rest) }}\\n/>\\n...\\n```\\n\\n### `react-markdown`用下来，我最钟意的几点就是：\\n- **有插件系统**：对应了上面的`rehypePlugins`和`remarkPlugins`参数。\\n    - rehype？是啥：有了ta，你在Markdown里就**能写html了**\\n    - remark？是啥：有了ta，你就能用**更多的标签**。\\n    - 有了rehype，remark才能生效。\\n\\n- **可以定制组件**：对应了**components**参数。\\n    - 比如你在Markdown文档中写了一个\\n        ```md\\n        # 测试文档\\n        <dddd></dddd>\\n        ```\\n    - 然后在`components`配置一下`dddd`\\n\\n        <img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/326ab1197eed45d38c58bb3f06edc3d6~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\" width=\\\"70%\\\" />\\n\\n    - 效果：\\n\\n        <img src=\\\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1075024d8d294e68aa5ba58466e9b20a~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\" width=\\\"70%\\\" />\\n\\n\\n所以说，靠`react-markdown`这两手儿，能玩出花儿～\\n\\n这块非常有趣，我会写一篇好好说说～～～\\n\\n## 生成知识体系\\n### 知识体系的呈现\\n使用的是Antv中一个示例，由于颜值高，而且还比较符合我的需求，就直接拿来用了，这里不展开说，先聊聊驱动显示的数据结构吧。\\n\\n<img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ac978d8c33b485e8ec82cddbb0339d2~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\" width=\\\"70%\\\" />\\n\\n能够看出，存在`edges`和`nodes`两个数据，顾名思义，一个是边一个是节点。\\n\\n<img src=\\\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05917758338648a2ad1a16ce7547449d~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\" width=\\\"70%\\\" />\\n\\n但是这么多数据，如果考手敲，那可有的维护了，文章有变动，我就得同步修改知识体系，这简直无法接受，如果能够根据众多文章本身，分析出来知识体系，岂不是妙哉～\\n\\n### 根据现有文章，生成知识体系数据\\n- 在文章中，我加入自定义标签\\n    <img src=\\\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6bf4d0125ade4eb7b2aa55a6d2ce07be~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\" width=\\\"70%\\\" />\\n\\n    参数分别是：\\n    - title：文章标题\\n    - cover：文章封面\\n    - subhead：副标题\\n    - date：文章创建日期\\n    - tags：分类，这个可是生成知识体系的关键\\n\\n- 然后，在服务端，对文章内容进行解析，用正则表达式取得相关信息\\n    ```js\\n    const parseDoc = async (path, id) => {\\n      var text = \\\"\\\";\\n      let toReadFile = () => {\\n        return new Promise((res, req) => {\\n          fs.readFile(path, (err, data) => {\\n            text = data.toString();\\n            res(\\\"异步\\\");\\n          });\\n        });\\n      };\\n\\n      await toReadFile();\\n      // 先截取  describe 优化后面 匹配性能\\n      let describe = text.match(/<describe>([\\\\d\\\\D]*?)<\\\\/describe>/)[1];\\n      let title = describe.match(/title:\\\\s*(.*?)\\\\s*\\\\n/)[1];\\n      let subhead = describe.match(/subhead:\\\\s*(.*?)\\\\s*\\\\n/)[1];\\n      let cover = describe.match(/cover:\\\\s*(\\\\S*?)\\\\s*\\\\n/)[1];\\n      let date = describe.match(/date:\\\\s*(.*?)\\\\n/)[1];\\n      let tags0 = describe.match(/tags:\\\\s*(\\\\S*?)\\\\s*\\\\n/)?.[1];\\n\\n      let desJson = {\\n        title,\\n        subhead,\\n        cover,\\n        date,\\n        tags: [tags0],\\n      };\\n      return desJson;\\n    };\\n    ```\\n\\n然后就会根据这些信息，去生成知识体系，这块设计了不少环节，非常值得拿出来好好讲，这里先不展开说。\\n\\n## 在线代码块预览\\n在线代码开发，比如掘金的“码上掘金”这样的，一直以来，都是我觉得非常秀的功能，我非常的好奇怎么实现，于是我开始在掘金研习，最后我看了一个大佬的文章，深受启发。\\n\\n<img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3abfb5544d5422086864cfa1828b4cf~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\" width=\\\"70%\\\" />\\n\\n（*心里话：在掘金上技术好的大佬很多，但既有想法又有实力才实属珍贵，这样的人是会发光的，掘金确实是一个好地方，感激～）*\\n\\n跟着大佬的思路，做出了我的版本：\\n- **一个可以后台动态配置代码块的。**\\n    <details>\\n    <summary>配置数据，如下</summary>\\n\\n    ```jsx\\n\\n    const describe = {\\n      title: \\\"React Router v6 demo\\\",\\n      cover: \\\"r6.png\\\",\\n      subhead: \\\"辅助强化 React-router v6 的功能\\\",\\n      date: \\\"2022/4/2\\\",\\n      tags: \\\"react\\\"\\n    }\\n\\n    const getReactCode = () => {\\n      let a = `const {\\n        useRoutes,\\n        useNavigate,\\n        MemoryRouter: Rouer\\n      } = ReactRouterDOM\\n      const { Button } = antd\\n      const LoginPage = () => {\\n        const navigateTo = useNavigate()\\n        return (\\n          <div>\\n            <div >React Router v6 Demo</div>\\n            <div>\\n              <Button\\n                type=\\\"primary\\\"  \\n                onClick={() => {\\n                  navigateTo('center')\\n                }}\\n              >\\n                跳回\\n              </Button>\\n            </div>\\n          </div>\\n        )\\n      }\\n      const CenterPage = () => {\\n        const navigateTo = useNavigate()\\n        return (\\n          <div>\\n            <div>includes useRoutes and useNavigate api</div>\\n            <div>\\n              <Button\\n                type=\\\"primary\\\"  \\n                onClick={() => {\\n                  navigateTo('/')\\n                }}\\n              >\\n                跳转\\n              </Button>\\n            </div>\\n          </div>\\n        )\\n      }\\n      const App = () => {\\n        const Routes = () => {\\n          return useRoutes([\\n            {\\n              path: '/',\\n              element: <LoginPage />\\n            },\\n            {\\n              path: '/center',\\n              element: <CenterPage />\\n            }\\n          ])\\n        }\\n        return <Routes></Routes>\\n      }\\n      const Index = () => {\\n        return (\\n          <Rouer>\\n            <App />\\n          </Rouer>\\n        )\\n      }\\n      ReactDOM.render(\\n        <h1>\\n          <div className={'title'} >Hello Moderate, let's play!</div>\\n          <Index />\\n        </h1>,\\n        document.getElementById('root')\\n      )`;\\n      return a;\\n    };\\n    const config = {\\n      describe,\\n      template: {\\n        js: getReactCode(),\\n        css: `.title{\\n            color: red;\\n            font-weight:bold;\\n            font-size:50px;\\n        }`,\\n        html: `<div id=\\\"root\\\"></div>`,\\n      },\\n      resources: {\\n        css: [\\n          {\\n            name: \\\"antd-css\\\",\\n            url: \\\"https://cdn.bootcdn.net/ajax/libs/antd/4.19.4/antd.css\\\",\\n          },\\n        ],\\n        js: [\\n          {\\n            name: \\\"React\\\",\\n            url: \\\"https://cdnjs.cloudflare.com/ajax/libs/react/16.13.1/umd/react.production.min.js\\\",\\n          },\\n          {\\n            name: \\\"react-dom\\\",\\n            url: \\\"https://cdnjs.cloudflare.com/ajax/libs/react-dom/16.13.1/umd/react-dom.production.min.js\\\",\\n          },\\n          {\\n            name: \\\"history\\\",\\n            url: \\\"https://cdnjs.cloudflare.com/ajax/libs/history/5.3.0/history.production.min.js\\\",\\n          },\\n          {\\n            name: \\\"react-router\\\",\\n            url: \\\"https://cdnjs.cloudflare.com/ajax/libs/react-router/6.0.1/react-router.production.min.js\\\",\\n          },\\n          {\\n            name: \\\"react-router-dom\\\",\\n            url: \\\"https://cdnjs.cloudflare.com/ajax/libs/react-router-dom/6.0.1/react-router-dom.production.min.js\\\",\\n          },\\n          {\\n            name: \\\"antd\\\",\\n            url: \\\"https://cdnjs.cloudflare.com/ajax/libs/antd/4.23.5/antd.min.js\\\",\\n          },\\n        ],\\n      },\\n    };\\n\\n    module.exports = config\\n\\n    ```\\n\\n    </details>\\n    \\n- **一个可以前端展示所有代码块的。**\\n\\n    <img src=\\\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca5fc380f6b84e1e92d65476b25b84dc~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\" width=\\\"70%\\\" />\\n- **一个可以良好显示，兼容手机和pc两端的。**\\n\\n    <img src=\\\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/23ae602eb30646c6b1c4dfffcbd107dd~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\" width=\\\"30%\\\" />\\n\\n\\n    <img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2ed49f67609459d9c881c5ee9da4440~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\" width=\\\"30%\\\" />\\n\\n而且更有趣的是，我可以在md文档插入代码块，这样就可以在阅读文章的同时，还能直观的预览代码的效果，这样对代码的意图会有更直观的理解。\\n\\n而且自己实现的代码编辑工具，虽然在技术力不足以跟专业的比较，但是在满足基本的功能之外，可以很大程度上根据自己的想法去做演化，这块是可以玩出花儿的～，这块非常值得细说，这里就先不展开讲。\\n\\n## 运维devops和自动化ci/cd\\n### 有必要学学运维了\\n首先这个项目是需要部署到服务器上的，而且还是前后端分离的项目，为此就需要有一些运维的知识，笔者不才，略懂皮毛，仅仅是为了实现我的几个需求：\\n- 部署我的服务端项目，用**Nodejs**写的，框架是koa，数据是mongodb。\\n- 部署我的前端项目\\n- 前后端分离，解决跨域问题\\n- https\\n- 域名\\n- 服务器\\n- ....\\n\\n**运维真的好多事，经过一系列的折腾，我整理出了一套非常适合新手如我的运维解决方案：**\\n\\n- **docker启动服务程序**，并配置`docker-compose`，串联起项目及数据库等相关服务的部署流程。（不会？我也不咋会，面向百度，主要能实现功能就好了，先跑起来再说）\\n    - <details>\\n            <summary>配置docker，简单理解根据这个文件就能把项目构建成一个镜像。\\n            </summary>\\n            \\n            FROM node:14\\n            WORKDIR /app\\n            COPY . /app\\n\\n            # 构建镜像时，一般用于做一些系统配置，安装必备的软件。可以多个run\\n            RUN ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime && echo 'Asia/Shanghai' >/etc/timezone\\n            #安装\\n            RUN npm set registry https://registry.npm.taobao.org\\n            RUN npm install\\n            RUN npm install pm2 -g\\n\\n\\n            # CMD 启动容器 只能有一个 CMD (阻塞控制台)\\n            CMD echo $SERVER_NAME && echo $AUTHOR_NAME && npm run prd && pm2 log\\n\\n            # 环境变量\\n\\n            ENV SERVER_NAME=\\\"moderate-server\\\"\\n            ENV AUTHOR_NAME=\\\"qanglee\\\"\\n      </details>\\n         \\n         \\n    - <details>\\n            <summary>配置docker-compose，可以简单理解为，一个个镜像代表了对应的服务程序，docker-compose把这些镜像加载过程串联了起来。\\n            </summary>\\n    \\n            version: '3'\\n            services:\\n              moderate-server:\\n                build: \\n                    context: .\\n                    dockerfile: dockerfile\\n                image: moderate-server\\n                container_name: moderate-server\\n                volumes:\\n                      - '/home/play/projects/myUniverse:/myUniverse' # 数据持久化\\n                      - '/home/play/projects/myUniverse/docs:/docs' # 数据持久化\\n                ports:\\n                  - 3061:3060\\n              moderate-redis:\\n                image: redis\\n                container_name: moderate-redis\\n                ports:\\n                  - 6378:6379\\n                environment:\\n                  - TZ=Asia/Shanghai\\n              moderate-mongo:\\n                  image: mongo # 引用官网 mongo 镜像\\n                  container_name: moderate-mongo\\n                  restart: always\\n                  volumes:\\n                      - '.docker-volumes/mongo/data:/data/db' # 数据持久化\\n                  environment:\\n                      - MONGO_INITDB_ROOT_USERNAME=。。。\\n                      - MONGO_INITDB_ROOT_PASSWORD=。。。\\n                      - TZ=Asia/Shanghai # 设置时区\\n                  ports:\\n                      - '27016:27017' # 宿主机可以用 127.0.0.1:27016 即可连接容器中的数据库\\n      \\n\\n      \\n\\n    </details>\\n        \\n    - 执行`docker-compose up -d --build`，这就启动了整个部署过程了。\\n- **宝塔**，你懂的，贼好用\\n    \\n    <img src=\\\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f2fcd8d50aa844d3978e4a7d7a4ee308~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\" width=\\\"50%\\\" />\\n    \\n    可以很方便整很多事儿，比如：\\n    - **部署网站**\\n    - **https证书**\\n    - 通过`nginx`反向代理解决**跨域问题**\\n    - **域名绑定**\\n    - ...\\n\\n### github actions实现自动化部署，这功能可是相当重要\\n首先我们构建的知识体系，如果无法实现全自动的去演化，而是通过手动的去增增减减，修修补补，那么积极性很容易在如此枯燥的过程中消磨掉，所以：\\n\\n**一个可以把主要精力关注在沉淀经验知识上，省去枯燥费神的维护过程的方法，就变得非常关键。**\\n\\n那么github actions就可以轻松办到，仅仅通过配置一个文件，就能实现仅仅push文件内容到github，就能全自动的服务构建，非常的方便。\\n\\n <details>\\n        <summary>配置如下，有兴趣可以看看。\\n        </summary>\\n\\n    \\n    # This workflow will do a clean install of node dependencies, build the source code and run tests across different versions of node\\n        # For more information see: https://help.github.com/actions/language-and-framework-guides/using-nodejs-with-github-actions\\n        # github actions 中文文档 https://docs.github.com/cn/actions/getting-started-with-github-actions\\n\\n        name: deploy for main\\n\\n        on:\\n            push:\\n                branches:\\n                    - 'main' # 只针对 dev 分支\\n                paths:\\n                    - '.github/workflows/*'\\n                    - 'src/**'\\n                    - 'Dockerfile'\\n                    - 'docker-compose.yml'\\n                    - 'bin/*'\\n                    - 'docs/*'\\n                    - 'config/*'\\n                    - 'records/*'\\n\\n        jobs:\\n            deploy-dev:\\n                runs-on: ubuntu-latest\\n\\n                steps:\\n                    - uses: actions/checkout@v2\\n                    - name: set ssh key # 临时设置 ssh key\\n                      run: |\\n                          mkdir -p ~/.ssh/\\n                          echo \\\"${{secrets.MODERATE_SSH_KEY_PC}}\\\" > ~/.ssh/id_rsa # secret 在这里配置 https://github.com/imooc-lego/biz-editor-server/settings/secrets\\n                          chmod 600 ~/.ssh/id_rsa\\n                          ssh-keyscan \\\"你的服务ip\\\" >> ~/.ssh/known_hosts\\n                    - name: deploy # 部署\\n                      run: |\\n                          ssh root@你的服务ip \\\"\\n                            cd /projects/moderate-server;\\n                            git checkout dev\\n                            git pull;\\n                            yarn;\\n                            docker-compose up -d --build\\n                            \\\"\\n                    - name: delete ssh key # 删除 ssh key\\n                      run: rm -rf ~/.ssh/id_rsa\\n\\n</details>\\n\\n**这样提交完之后，就会触发github actions**\\n\\n\\n<img src=\\\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d0c1c8c2fb8c416ebc5806d34770d78f~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\" width=\\\"70%\\\" />\\n\\n搞运维遇到的坑可老多了，这一块实际上还有很多值得探索和分享的经验，以后可以单读写一下排坑记录，在此就先不展开说了～～～\\n    \\n##  成果展示\\n目前成果这块，我就把我之前在掘金游戏投稿大赛获奖的项目放上了，我排倒第一，实至名归。\\n\\n<img src=\\\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ca86d0e34454edfb7cb09e61106269b~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\" width=\\\"70%\\\" />\\n\\n效果图：\\n\\n<img src=\\\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eabb72ae65364019a9de971f708ccc31~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\" width=\\\"70%\\\" />\\n\\n\\n## 制定作战计划，记录成长点滴\\n这个是我当下在思考的功能模块，哈哈哈，苦于自己的想法太多，很多点子没想好怎么组织起来，但大体的思路，就是记录自己的成长轨迹，因为我觉得：\\n\\n**不念过去，不见未来**\\n\\n不记住自己的过往，不反思，不总结，不接受，那么你又怎么看的见自己的未来，找到前进的方向。\\n\\n所以，基于我的感悟，我觉得人应该制定目标，并把目标裱起来，时刻的提醒自己，我在做什么，我做完了什么，我要做什么。\\n\\n所以，我画出了这个原型图。\\n\\n\\n<img src=\\\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c59385e999854fdd89744c9466e328ab~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\" width=\\\"70%\\\" />\\n\\n上方的点图跟github类似，记录自己进步的情况，很好的感知自己的学习周期。\\n\\n**任务分为：**\\n- **主题任务**：当下的奋斗目标，可以适机切换，一点一点前进。\\n- **持续任务**：天天都要做的，不能间断的，比如修身齐家，学英语啥的。\\n- **娱乐任务**：非功利的，兴趣使然的，不求回报的。\\n\\n\\n# 结尾\\n[工具在线预览地址](https://moderate.run)\\n\\n\\n\\n至此，**用真心**打造的**知识沉淀工具**，就差不多介绍到这里了，之后我会挑出几个我觉得有价值，能帮到别人的功能点进行深入分享，敬请期待。\\n\\n有问题可以随时咨询我，或者留言，我有个群叫**闲D岛**，群号是551406017，结识一帮志同道合的伙伴，交流技术，欢迎水群，共同进步。\\n\\n\\n# 题外话\\n虽然总是保持上进，但却时常患得患失，感觉自己会的多了，就越发的觉得自己弱爆了，虽然这很合理，但这不应是停止进步的理由，停下来可以有很多种理由，但不应该是因为见识到了大，就因自己的小而停下来，如果一个人发出的光，让你睁不开眼睛，无法正视前方的路，那就别看，正经儿的光是会让你振奋，会给予你能量，而且也不妨再天真一点，这样也许你就可以做你自己了，而只有自己能让自己放光，至少我是这么觉得的。\\n\\n\\n\\n",
        "tags": [
            "前端",
            "React.js",
            "Node.js"
        ]
    },
    {
        "article_id": "7163575262653710373",
        "cover_image": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e126becdc1fe448892ee719eadcb1a8d~tplv-k3u1fbpfcp-watermark.image?",
        "title": "蚂蚁互动图形引擎 Oasis Engine v0.9 发布",
        "brief": "Oasis Engine v0.9 正式发布，本次里程碑后 Oasis Engine 正式成为蚂蚁互动技术品牌 Ant Galaxy 旗下核心基础引擎",
        "user_name": "蚂蚁RichLab前端团队",
        "view_count": 3855,
        "collect_count": 44,
        "comment_count": 16,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/502d33054568621784df2c3dd823f6dc~300x300.image",
        "category": "前端",
        "content": "Oasis Engine v0.9 正式发布，本次里程碑后 Oasis Engine 正式成为蚂蚁互动技术品牌 **Ant Galaxy** 旗下核心基础引擎，原 Github 官方组织名 oasis-engine 已修改为 ant-galaxy。未来 Ant Galaxy 旗下会孵化诞生更多基于 Oasis Engine 的图形互动类产品，敬请期待。\\n\\n[**Engine**](https://github.com/ant-galaxy/oasis-engine) 在渲染方面**阴影支持了 CSSM** ，可支持中大场景渲染，并带来了更好的性能和渲染效果。文字新增了**自定义字体加载**。**Shader 支持了多 pass**，编写多 pass 效果更简单。动画方面 Animator 支持了**任意目标属性动画**，进一步加强了动画管理和驱动能力。Input 支持了**多 Pointer 事件回调，**编写多点触控逻辑更简单。另外**天空**、**Mesh**、**资产加载**等功能均有不同程度的加强。\\n\\n[**Engine Toolkit**](https://github.com/ant-galaxy/oasis-engine-toolkit) 新增 **Navigation Gizmo** 支持高效控制相机运动，**Infinity Grid** 材质绘制无限大小的网格平面，**Sketch Geometry** 绘制模型线框，法线，切线和副法线。**Auxiliary Lines** 支持渲染包围盒辅助线绘制，原有的 **Gizmo** 和 **Control** 组件均进行了重构。\\n\\n官网（[https://oasisengine.cn/](https://oasisengine.cn/)）从 github pages 静态网站升级为动态网站，降低了引擎各版本的文档的维护成本，更好地支持了内容搜索。开发者可以通过 github 的文档仓库贡献 PR，合并后将自动更新网站内容。\\n<a name=\\\"KnZ4h\\\"></a>\\n# Engine\\n\\n- **仓库地址：**[https://github.com/ant-galaxy/oasis-engine](https://github.com/ant-galaxy/oasis-engine)\\n- **0.9 里程碑完整日志：**[https://github.com/ant-galaxy/oasis-engine/releases/tag/v0.9.0-beta.9](https://github.com/ant-galaxy/oasis-engine/releases/tag/v0.9.0-beta.9)\\n<a name=\\\"oMGgs\\\"></a>\\n## 阴影更新\\n完整重新设计了引擎原有的阴影系统，调整为 Cascaded Statble Shadow Map (CSSM) 稳定性级联阴影，大幅提升了中大型场景的阴影渲染质量和性能，并且还提供了多种质量配置，方便开发者针对性做剃度降级。同时该阴影系统还会自动根据 WebGL2 或 WebGL1 选择最佳的系统实现。<br />![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8a00c898b684d369732a4c1f35febd0~tplv-k3u1fbpfcp-zoom-1.image \\\"左：四级联阴影，右：无级联阴影\\\")<br />对于追求物理真实的场景，结合 PBR 材质和物理模拟可以获得非常逼真的交互效果：<br />![Nov-04-2022 08-36-07.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0813224ffa1e4cd5ba82575a78865b1d~tplv-k3u1fbpfcp-zoom-1.image)<br />但在上述场景下，材质如果是透明的则无法接收任何阴影。有时候会希望增加一个透明的阴影接受物，例如在  AR 场景中嵌入一个实时渲染的模型。在这种情况下，可以复用经过重构后的阴影着色器模块，从而实现自定义阴影渲染。如下图背景图由离线渲染得到，加入一块透明平面接受阴影，可以使得实时渲染的物体更好加入到场景中：<br />![Oct-31-2022 13-47-49.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a14cb7ca622497a904976b809e33a32~tplv-k3u1fbpfcp-zoom-1.image)\\n<a name=\\\"D2r7j\\\"></a>\\n## 文字更新 \\n`Font` 字体新增了 ttf、otf 和 woff 自定义字体格式的支持，通过自定义字体抹平系统字体在不同平台下的显示差异，也可以给项目提供更酷炫丰富的文字样式。<br />![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ee81bb4f3064ae5ada7e431b30b7167~tplv-k3u1fbpfcp-zoom-1.image)\\n<a name=\\\"hZuoI\\\"></a>\\n## 着色器更新\\nShader 新增多 pass 能力，一个 Shader 可包含多个着色 pass ，方便开发者编写多 pass shader 效果，无需像之前新增额外的 `Renderer`，更专注于 Shader 本身的创作。未来还会投入更多能力帮助开发者提升开发者创作 Shader 效率。\\n<a name=\\\"eIGP2\\\"></a>\\n## 网格更新 \\n`ModelMesh` 新增 `calculateTangents` 方法，对于没有切线数据的模型，可以通过该方法计算切线信息，以此在着色器中支持使用 TBN 矩阵结合法线贴图计算法线方向。目前引擎内置的 `PrimitiveMesh` 均已增加切线数据。另外，修复了线数据上传时丢失 `w` 数据的问题，使得着色器中可以正确的计算出副法线的值。\\n<a name=\\\"IfiQz\\\"></a>\\n## 天空更新\\n重新整理了天空相关的渲染逻辑，修复了在正交相机下天空盒的渲染问题。同时规避了在某些机型上，因为计算精度造成的天空盒被剔除的问题。另外对于天空 Shader 编写，用户可以更加自然的编写天空着色器，不需要在着色器中做任何特殊的处理。\\n<a name=\\\"ZvaGY\\\"></a>\\n## 动画更新\\n`Animator` 新增自定义 `AnimationClip` 目标属性的能力，以前只能使用 glTF 模型内置的动画，如蒙皮动画和 Blend Shape 动画。现在可以通过 `AnimationClip` 自定义任意组件属性的动画，比如灯光的位置、材质颜色、相机位置和视角等。`Animator` 对动画的管理和驱动能力也从定制化变为通用化。<br />![customAnimationClip.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ffee6bd6d8bf463cbf3d1d10c076429e~tplv-k3u1fbpfcp-zoom-1.image)<br />`SkinnedMeshRenderer`新增 `localBounds` 和 `rootBone` 属性，为开发者提供了更精准的蒙皮模型渲染包围盒更新机制，当默认包围盒不满足时还可以手动调整局部包围盒和其跟随根骨骼。<br />![198267094-5431deee-5e3d-4f55-990c-16477b498523.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b6b43efba534122b34cf9e52fc84fc9~tplv-k3u1fbpfcp-zoom-1.image)![198264197-f06817d3-287a-4199-9586-5bb292500d52.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f37be1da108419e8f8471ae5cd24b09~tplv-k3u1fbpfcp-zoom-1.image)\\n<a name=\\\"x7Aey\\\"></a>\\n## 物理更新\\n物理的 `Collidershape` 支持设置旋转属性，可以更加自由的组合基础几何碰撞器构造复合碰撞盒，例如以下通过胶囊组成的圆环碰撞器案例：<br />![Oct-31-2022 15-10-20.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f921ef930f9c4e688d40ce01b22fda2f~tplv-k3u1fbpfcp-zoom-1.image \\\"利用胶囊体复合环状碰撞器\\\")\\n<a name=\\\"G2ZtN\\\"></a>\\n## 交互更新\\n更新后每个 Pointer 保持独立逻辑，并单独处理各自的触控事件，同时在 Pointer 的回调函数中可以直接拿到触发此动作的 Pointer，因此我们可以使用更简单的逻辑实现多点触控能力。<br />![merge.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/49b24197384141dc95d0369669e7f10d~tplv-k3u1fbpfcp-zoom-1.image)\\n<a name=\\\"QcnCU\\\"></a>\\n## 其他更新\\n\\n- `Loader` 加载 `Texture` 支持 `format` 和 `mipmap` 配置参数。\\n- `Loader` 加载 `glTF` 支持 `keepMeshData` 配置参数，可保留 CPU 模型数据。\\n- `Entity` 新增 `siblingIndex` 属性，可快捷调整和获取其在父 entity 子队列中的位置。\\n- `Texture` 新增 `depthCompareFunction`属性，当纹理为深度纹理时可设置其采样比较模式，通常用于 ShadowMap 等阴影效果实现。\\n- `ShaderData` 新增 `getProperties` 和 `getPropertyValue`方法，开发者可获取其所有已设置的着色属性和值。\\n- `glTF` 解析新增了子资产模式。\\n- `glTF` 解析新增了纹理过滤模式。\\n- `Animator` 新增默认动画配置。\\n<a name=\\\"aFdE3\\\"></a>\\n# Toolkit\\n\\n- **仓库地址：**[https://github.com/ant-galaxy/oasis-engine-toolkit](https://github.com/ant-galaxy/oasis-engine-toolkit)\\n- **0.9 里程碑完整日志：**[https://github.com/ant-galaxy/oasis-engine-toolkit/releases/tag/v0.9.0-beta.0](https://github.com/ant-galaxy/oasis-engine-toolkit/releases/tag/v0.9.0-beta.0)\\n<a name=\\\"fhd2T\\\"></a>\\n## Transform Gizmo \\nGizmo 进行了完整的重构，并且优化开发者调用的API，操作更跟手。整体样式调整，便于选择。新增锚点选项（center/pivot），和坐标系选项（world/local），支持同时选中多个实体。并且增加了复合模式，集位移、旋转、拖拽为一体。<br />![gizmoooo.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/288eb33fce14479eaa3d7d79ca356580~tplv-k3u1fbpfcp-zoom-1.image)\\n<a name=\\\"nn8lL\\\"></a>\\n## Navigation gizmo\\n和 Gizmo 不同，新增 Navigation gizmo 可以在可视化、无键盘操作的场景中更加方便地调度相机相。它提供切换三视图功能，简单拖拽即可使得场景相机绕特定点移动。并且实时同步场景相机在空间中的方位，方便用户观察。 <br />![navigationGizmo.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d83d83c734b41faa7a2a6f5e2960f0a~tplv-k3u1fbpfcp-zoom-1.image)\\n<a name=\\\"u9WEa\\\"></a>\\n## 无穷网格材质\\n该材质在直接在屏幕空间中渲染无穷大的网格，同时该材质同时支持2D空间（x-y平面）和3D空间（x-z平面）中的网格。支持两种网格之间的切换。<br />![Oct-31-2022 14-13-14.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f7a9605525c4873bffdc5196d17fb8f~tplv-k3u1fbpfcp-zoom-1.image)\\n<a name=\\\"hq6yw\\\"></a>\\n## 线框渲染模式与法线，切线，副法线渲染\\n由于 WebGL 没有几何着色器，因此渲染网格线框，法线，切线，副法线等辅助视图比较困难。用户常需要可视化这些模型数据以检查模型资产和着色器的准确性。0.9 版本的 Toolkit 新增这些数据的渲染，并且支持引擎当中的 GPU 蒙皮动画，GPU 顶点动画。实现的方法基于将整个 Mesh 转换成一张纹理，由此着色器可以很容易得到模型的全局数据，由此将顶点着色器转换成通用的 GPGPU 计算单元。<br />![Oct-31-2022 14-23-48.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f7375cbabd4644f181d2564ace4c22cf~tplv-k3u1fbpfcp-zoom-1.image)\\n<a name=\\\"rVfic\\\"></a>\\n# 文档更新\\nOasis 官网文档与 API 支持了关键词搜索功能，我们将持续投入精力优化开发者的开发体验。\\n\\n| 文档 | 更新内容 |\\n| --- | --- |\\n| 引擎 | 修正初始化错误描述，补充对初始化参数的描述 |\\n| 文字渲染器 | 补充支持自定义字体格式 |\\n| 材质总览 | 补充动态替换材质贴图代码 |\\n| 资源加载 | 补充资产加载透传参数<br />调整环境光相关描述 |\\n| 物理管理器 | 修正配图错误（右手坐标系） |\\n| 动画组件 | 新增动画暂停/恢复描述<br />优化运动状态描述<br />新增自定义动画状态描述<br />新增默认播放描述<br />新增数据复用描述 |\\n\\n<a name=\\\"IRouF\\\"></a>\\n# 示例更新\\n| 案例 | 缩略图 |\\n| --- | --- |\\n| CSS 跟随 3D 移动 | ![css-dom.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b10210f2d1b4352ba550d0365bf2fb8~tplv-k3u1fbpfcp-zoom-1.image) |\\n| 自定义透明阴影 | ![Oct-31-2022 13-47-49.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e1b3fd07f3544beb8f9fa02351646f5~tplv-k3u1fbpfcp-zoom-1.image) |\\n| 新阴影系统 | ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b47a27cb1c7456ba9d063cbea99b45a~tplv-k3u1fbpfcp-zoom-1.image) |\\n| 级联阴影 | ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/40fdf7a0af984fc3ba7c7c39095ec61d~tplv-k3u1fbpfcp-zoom-1.image) |\\n| 线框渲染器 | ![Oct-31-2022 14-23-48.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d6c8a9910c04eeaa2077fa2f6cc5775~tplv-k3u1fbpfcp-zoom-1.image) |\\n| 无穷网格 | ![Oct-31-2022 14-13-14.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3eebd663fcce4ceb9fb4975fd3cdf31f~tplv-k3u1fbpfcp-zoom-1.image) |\\n| Gizmo | ![gizmo.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a667eff363e545458917730af7eb749d~tplv-k3u1fbpfcp-zoom-1.image) |\\n| 自定义动画片段 | ![customAnimationClip.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4e1cfa7fbde845a298be633a958e0913~tplv-k3u1fbpfcp-zoom-1.image) |\\n\\n<a name=\\\"p6CB1\\\"></a>\\n# 如何联系我们\\n<a name=\\\"iI27f\\\"></a>\\n## Oasis 开源社区群管理员 (微信)：zengxinxin2010\\n\\n## 网站\\n官网地址<br />[https://oasisengine.cn](https://oasisengine.cn/)<br />Engine 源码地址<br />[https://github.com/oasis-engine/engine](https://github.com/oasis-engine/engine)<br />Engine Toolkit 源码地址<br />[https://github.com/oasis-engine/engine-toolkit](https://github.com/oasis-engine/engine-toolkit)",
        "tags": [
            "前端",
            "WebGL",
            "图形学"
        ]
    },
    {
        "article_id": "7194055745376092218",
        "cover_image": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb0286fe36fc40338d39ed6fcf48795a~tplv-k3u1fbpfcp-watermark.image?",
        "title": "实战案例！用1行Python代码识别身份证信息，准确率超过99%，YYDS",
        "brief": "大家好，这里是程序员晚枫。 录入身份证信息是一件繁琐的工作，如果可以自动识别并且录入系统，那可真是太好了。 今天我们就来学习一下，如何自动识别身份证信息并且录入系统~ 识别身份证信息 识别身份证信息的",
        "user_name": "程序员晚枫",
        "view_count": 1419,
        "collect_count": 3,
        "comment_count": 4,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/8e68d1a4bc2a5782bf2717dca54f52cd~300x300.image",
        "category": "人工智能",
        "content": "---\\ntheme: smartblue\\n---\\n\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/26475d9f5303437e9af428dce3fe8d87~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n大家好，这里是程序员晚枫。\\n\\n录入身份证信息是一件繁琐的工作，如果可以自动识别并且录入系统，那可真是太好了。\\n\\n今天我们就来学习一下，如何自动识别身份证信息并且录入系统~\\n\\n\\n\\n## 识别身份证信息\\n\\n识别身份证信息的代码最简单，只需要1行代码，如下所示。👇\\n\\n```python\\n# pip install potencent\\nimport potencent\\n\\n# 可以填写本地图片的地址：img_path，也可以填写在线图片的地址：img_url\\n# 如果2个都填，则只用在线图片\\nres = potencent.ocr.IDCardOCR(\\n    img_path=r'C:\\\\Users\\\\Lenovo\\\\Desktop\\\\temp\\\\反面.jpg',\\n    img_url='https://python-office-1300615378.cos.ap-chongqing.myqcloud.com/2-free-group.jpg',\\n    configPath=r'配置文件的信息，可以不填')\\n\\nprint(res)\\n```\\n\\n本接口支持中国大陆居民二代身份证正反面所有字段的识别，包括姓名、性别、民族、出生日期、住址、公民身份证号、签发机关、有效期限，识别准确度达到99%以上。\\n\\n另外，本接口还支持多种增值能力，满足不同场景的需求。如身份证照片、人像照片的裁剪功能，同时具备9种告警功能，如下表所示。👇\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/053fa50b3489441ab2ebec922446dd73~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n\\n\\n## 注意事项\\n\\n该功能的实现，依托于腾讯云的文字识别，所以如果是小白用户，请在同级目录下配置一个``potencent-config.toml``文件。文件位置和内容如下图所示。👇\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af33812abe374414934252f021448237~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n```python\\n[tencent-ai]\\nTENCENTCLOUD_SECRET_ID = '你的 SecretId'     # 建议使用子账号密钥，授权遵循最小权限指引，降低使用风险。子账号密钥获取可参考：https://cloud.tencent.com/act/cps/redirect?redirect=36394&cps_key=ca76be5a2293ba3906d6d5407aea15ee\\nTENCENTCLOUD_SECRET_KEY = '你的 SecretKey'   # 建议使用子账号密钥，授权遵循最小权限指引，降低使用风险。子账号密钥获取可参考：https://cloud.tencent.com/act/cps/redirect?redirect=36394&cps_key=ca76be5a2293ba3906d6d5407aea15ee\\n```\\n\\n另外，如果需要自定义配置文件名称和位置，可以使用``configPath``参数，具体使用请看GitHub源码。\\n- GitHub源码地址：https://github.com/CoderWanFeng/potencent\\n\\n大家在阅读本文和使用代码中有任何问题，欢迎在评论区进行交流~\\n\\n---\\n",
        "tags": [
            "Python",
            "NLP",
            "人工智能"
        ]
    },
    {
        "article_id": "7163249902909128711",
        "cover_image": "https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a268dde7ac984b2abf311d5d337273f9~tplv-k3u1fbpfcp-watermark.image?",
        "title": "H5完美实现淘宝物理返回键关闭弹窗",
        "brief": "前言 物理返回键通常是指手机左滑、右滑和机身自带的返回键。在安卓/IOS 端可以通过监听物理返回事件去关闭弹窗，但是在H5是没有这一事件，那应该如何去实现物理返回键关闭弹窗呢？接下来说说我的方案。 淘",
        "user_name": "香芋好好吃",
        "view_count": 3539,
        "collect_count": 98,
        "comment_count": 18,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/badfb54dd3bba368928c3927a83883ba~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: fancy\\n---\\n## 前言\\n\\n物理返回键通常是指手机左滑、右滑和机身自带的返回键。在安卓/IOS 端可以通过监听物理返回事件去关闭弹窗，但是在H5是没有这一事件，那应该如何去实现物理返回键关闭弹窗呢？接下来说说我的方案。\\n\\n## 淘宝效果\\n\\n![tb.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c4c70630f0f42a4b8cb8cda7aefb629~tplv-k3u1fbpfcp-watermark.image?)\\n\\n操作：商品详情 -->点击购物车进入 购买弹窗 -->点击图片进入 图片预览弹窗\\n\\n返回操作：-->物理键返回 关闭图片预览弹窗 -->物理键再返回 关闭购买弹窗 --> 回到 商品详情\\n\\n## h5实现效果\\n\\n![1.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c5d783bbd4d4e5a918656a2c2ac84ee~tplv-k3u1fbpfcp-watermark.image?)\\n\\nvue3预览：[https://xiaocheng555.github.io/physical-button-close-popup](https://xiaocheng555.github.io/physical-button-close-popup)\\n\\nvue2预览：[https://xiaocheng555.github.io/physical-button-close-popup/v2](https://xiaocheng555.github.io/physical-button-close-popup/v2)\\n\\n源码（拿来吧你）：[https://github.com/xiaocheng555/physical-button-close-popup](https://github.com/xiaocheng555/physical-button-close-popup)\\n\\n## 实现原理\\n\\n物理返回键在H5实际上只是返回上一页的功能，也就是回退上个历史记录。因此我们可以在弹窗打开时，添加一个不会改变当前页面的历史记录，如 `?popyp=true`（或 `#popup`），在触发物理返回键后，浏览器会后退一个历史记录并且自动清除`?popyp=true`（或 `#popup`），而页面不会发生跳转和刷新，最后通过监听url变化，识别出url中 `?popyp=true` 被清除则关闭弹窗。\\n\\n## 组件实现(Vue3)\\n\\n将物理返回键关闭弹窗逻辑封装成弹窗组件：HistoryPopup.vue。\\n\\n### 组件基础结构\\n\\n``` js\\n<template>\\n  <!-- van-popup 如果不设置 :lock-scroll=\\\"false\\\"，自动打开弹窗会出现页面锁住不能滚动（vue2版本不会） -->\\n  <van-popup v-model:show=\\\"dialogVisible\\\" v-bind=\\\"$attrs\\\" :lock-scroll=\\\"false\\\">\\n    <slot></slot>\\n  </van-popup>\\n</template> \\n\\n<script setup lang=\\\"ts\\\">\\nimport { Popup as VanPopup } from 'vant'\\nimport { computed } from 'vue'\\n\\nconst props = defineProps({\\n  modelValue: {\\n    type: Boolean,\\n    default: false\\n  }\\n})\\nconst emit = defineEmits([\\n  'update:modelValue'\\n])\\n\\nconst dialogVisible = computed({\\n  get () {\\n    return props.modelValue\\n  },\\n  set (val) {\\n    emit('update:modelValue', val)\\n  }\\n})\\n</script>\\n```\\n\\n通过 `v-model` 来控制弹窗显示隐藏\\n\\n### 添加/删除历史记录\\n\\n弹窗打开时，添加 `?key=value` 记录；弹窗关闭时，移除 `?key=value` 记录\\n\\n```ts\\nconst props = defineProps({\\n  ...\\n  // query参数的key值\\n  queryKey: {\\n    type: String\\n  },\\n  // query参数的value值，弹窗打开会URL上显示`?queryValue=queryValue`\\n  queryValue: {\\n    type: [Number, String, Boolean],\\n    default: true\\n  }\\n})\\n\\nwatch(dialogVisible, (val) => {\\n  if (val) {\\n    onOpen()\\n  } else {\\n    onClose()\\n  }\\n})\\n\\n// 弹窗打开事件\\nfunction onOpen () {\\n  addQuery()\\n}\\n\\n// 弹窗关闭事件\\nfunction onClose () {\\n  removeQuery()\\n}\\n\\n// 添加query参数\\nfunction addQuery () {\\n  if (!existQueryKey()) {\\n    const newQuery = { ... route.query }\\n    if (props.queryKey) newQuery[props.queryKey] = props.queryValue\\n    router.push({\\n      query: newQuery\\n    })\\n  }\\n}\\n\\n// 移除query参数\\nfunction removeQuery () {\\n  if (props.queryKey && existQueryKey()) {\\n    const newQuery = { ... route.query }\\n    delete newQuery[props.queryKey]\\n    router.replace({\\n      query: newQuery\\n    })\\n  }\\n}\\n\\n// 判断路由query上是否存在queryKey\\nfunction existQueryKey () {\\n  const { query } = route \\n  return props.queryKey && props.queryKey in query\\n}\\n```\\n\\n### 自动打开/关闭弹窗\\n\\n* 弹窗处于打开时，点击浏览器的后退键，则主动关闭弹窗\\n\\n* 弹窗处于关闭时，点击浏览器的前进键，则主动打开弹窗\\n\\n``` ts\\nwatch(() => route.query, () => {\\n  if (!props.queryKey) return\\n  \\n  const exist = existQueryKey()\\n  // 主动关闭弹窗\\n  if (!exist && dialogVisible.value) {\\n    dialogVisible.value = false\\n  }\\n  // 主动打开弹窗\\n  if (exist && !dialogVisible.value) {\\n    dialogVisible.value = true\\n  }\\n})\\n```\\n\\n效果如图：\\n\\n![2.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d0ebddc932a4d6a8f7ac637fd7665f4~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n### 多了一条历史记录的bug\\n\\n当手动打开弹窗时，url添加 `?popup=true` 参数，同时也增加了一条历史记录；然后手动关闭弹窗，是通过 `router.repalce()` 来移除 `?popup=true` 参数的，而 `router.repalce()` 是不会移除历史记录，那么一开始添加的历史纪录还存在，这就导致打开并关闭弹窗会多了一条历史纪录。那么如果用户打开关闭弹窗10次，就会多产生10条历史记录，用户在详情页返回首页时，就需要点11次返回按钮才能回到首页。\\n\\n#### 解决方案\\n\\n用户打开弹窗时，url的变化过程是：`/detail` => `/detail?popup=true`，打开弹窗后如果能知道上一页是 `/detail`的话，那么在弹窗关闭时调用 `router.back()` 就能移除 `?popup=true` 参数和多出的历史纪录了。\\n\\n恰好，vue3 的 `vue-router` 会将上一页的地址记录在 `window.history.state.back` 上。实现如下：\\n\\n``` ts\\n// 弹窗关闭事件\\nfunction onClose () {\\n  if (hasBackRecord()) {\\n    router.back()\\n  } else {\\n    removeQuery()\\n  }\\n}\\n\\n// 判断弹窗是否有返回记录\\nfunction hasBackRecord () {\\n  const state = window.history?.state\\n  if (state && props.queryKey) {\\n    if (!state.back) return false\\n    \\n    const backRoute = router.resolve(state.back || '') // 解析出返回的路由\\n    if (backRoute.path === route.path) {\\n      const backQuery = backRoute.query // 上一页的query参数\\n      const curQuery = route.query // 当前页query参数\\n      return (props.queryKey in curQuery) && !(props.queryKey in backQuery)\\n    }\\n    return false\\n  } else {\\n    return false\\n  }\\n}\\n```\\n\\n### 完整代码\\n\\n``` js\\n// HistoryPopup.vue\\n<template>\\n  <!-- van-popup 如果不设置 :lock-scroll=\\\"false\\\"，自动打开弹窗会出现页面锁住不能滚动（vue2版本不会） -->\\n  <van-popup v-model:show=\\\"dialogVisible\\\" v-bind=\\\"$attrs\\\" :lock-scroll=\\\"false\\\">\\n    <slot></slot>\\n  </van-popup>\\n</template>\\n\\n<script setup lang=\\\"ts\\\">\\nimport { Popup as VanPopup, Overlay as VanOverlay } from 'vant'\\nimport { computed, watch } from 'vue'\\nimport { useRouter, useRoute } from 'vue-router'\\n\\nconst props = defineProps({\\n  modelValue: {\\n    type: Boolean,\\n    default: false\\n  },\\n  queryKey: {\\n    type: String\\n  },\\n  queryValue: {\\n    type: [Number, String, Boolean],\\n    default: true\\n  }\\n})\\nconst emit = defineEmits([\\n  'update:modelValue'\\n])\\n\\nconst router = useRouter()\\nconst route = useRoute()\\n\\n// 控制弹窗显示\\nconst dialogVisible = computed({\\n  get () {\\n    return props.modelValue\\n  },\\n  set (val) {\\n    emit('update:modelValue', val)\\n  }\\n})\\n\\n// 弹窗打开事件\\nfunction onOpen () {\\n  addQuery()\\n}\\n\\n// 弹窗关闭事件\\nfunction onClose () {\\n  if (hasBackRecord()) {\\n    router.back()\\n  } else {\\n    removeQuery()\\n  }\\n}\\n\\n// 判断弹窗是否有返回记录\\nfunction hasBackRecord () {\\n  const state = window.history?.state\\n  if (state && props.queryKey) {\\n    if (!state.back) return false\\n    \\n    const backRoute = router.resolve(state.back || '') // 解析出返回路由\\n    if (backRoute.path === route.path) {\\n      \\n      const backQuery = backRoute.query // 上一页的query参数\\n      const curQuery = route.query // 当前页query参数\\n      return (props.queryKey in curQuery) && !(props.queryKey in backQuery)\\n    }\\n    return false\\n  } else {\\n    return false\\n  }\\n}\\n\\n// 添加query参数\\nfunction addQuery () {\\n  if (!existQueryKey()) {\\n    const newQuery: any = { ... route.query }\\n    if (props.queryKey) newQuery[props.queryKey] = props.queryValue\\n    router.push({\\n      query: newQuery\\n    })\\n  }\\n}\\n\\n// 移除query参数\\nfunction removeQuery () {\\n  if (props.queryKey && existQueryKey()) {\\n    const newQuery: any = { ... route.query }\\n    delete newQuery[props.queryKey]\\n    router.replace({\\n      query: newQuery\\n    })\\n  }\\n}\\n\\n// url上是否存在queryKey\\nfunction existQueryKey () {\\n  const { query } = route \\n  return props.queryKey && props.queryKey in query\\n}\\n\\nwatch(dialogVisible, (val) => {\\n  val ? onOpen() : onClose()\\n})\\n\\nwatch(() => route.query, () => {\\n  if (!props.queryKey) return\\n  \\n  const exist = existQueryKey()\\n  // 自动关闭弹窗\\n  if (!exist && dialogVisible.value) {\\n    dialogVisible.value = false\\n  }\\n  // 自动打开弹窗\\n  if (exist && !dialogVisible.value) {\\n    dialogVisible.value = true\\n  }\\n}, {\\n  immediate: true\\n})\\n</script>\\n```\\n\\n### 组件用法\\n\\n``` js\\n<HistoryPopup v-model.show=\\\"visible\\\" queryKey=\\\"popup\\\">\\n  ...\\n</HistoryPopup>\\n```\\n\\n### 优化\\n\\n#### 优化多了一条历史记录的解决方案\\n\\n前面提过，可以通过 `history.state.back` 来解决多了一条历史记录的问题，但是`history.state.back` 是vue3才有的，有些强关联了，是不是还有更优的解决方案呢？如下：\\n\\n原来解决方案是：上一个url和当前url做对比就能知道弹窗多了 `?popup=true` 历史记录，从而使用 `router.back()` 去关闭弹窗并消除多出的历史记录，否则使用 `router.replace()` 去关闭弹窗并消除 `?popup=true` 参数。\\n\\n优化方案：弹窗打开并添加 `?popup=true` 参数时，记录 `history.state.popupKey` 为 `popup`, 那么关闭弹窗就使用 `router.back()`；如果在新页签打开地址 `/#/detail?popup=true`，弹窗会自动打开，此时关闭弹窗，可以得知 `history.state.popupKey` 为 `undefined`，那么关闭弹窗就使用 `router.replace()` 去消除 `?popup=true` 参数。\\n\\n``` js\\n// ⚠️更改处：设置 history.state 的值 \\nfunction setHistoryState (state: any) {\\n  history.replaceState({\\n    ...history.state,\\n    ...state\\n  }, '')\\n}\\n\\n  // 弹窗打开事件\\n  function onOpen () {\\n    addQuery()\\n  }\\n\\n  // 弹窗关闭事件\\n  function onClose () {\\n    if (hasBackRecord()) {\\n      router.back()\\n    } else {\\n      removeQuery()\\n    }\\n  }\\n\\n  // 判断弹窗是否有返回记录\\n  function hasBackRecord () {\\n    // ⚠️更改处：\\n    return window.history.state?.popupKey === props.queryKey\\n  }\\n\\n  // 添加query参数\\n  async function addQuery () {\\n    if (!existQueryKey()) {\\n      const newQuery = { ... route.query }\\n      if (props.queryKey) newQuery[props.queryKey] = props.queryValue?.toString?.() || ''\\n      await router.push({\\n        query: newQuery\\n      })\\n      // ⚠️更改处：\\n      setHistoryState({\\n        popupKey: props.queryKey\\n      })\\n    }\\n  }\\n\\n  // 移除query参数\\n  function removeQuery () {\\n    if (props.queryKey && existQueryKey()) {\\n      const newQuery = { ... route.query }\\n      delete newQuery[props.queryKey]\\n      \\n      router.replace({\\n        query: newQuery\\n      })\\n    }\\n  }\\n```\\n\\n\\n#### 写成hook\\n\\n返回键关闭弹窗逻辑都写在 `HistoryPopup.vue` 组件的话，如果还有其他弹窗如侧边栏弹窗，actionsheet弹窗等组件的话，有需要封装重复逻辑，所以返回键关闭弹窗逻辑写成hook，方便复用，详细见源码 `src/hooks/useHistoryPopup.js`，组件使用如下：\\n\\n``` js\\n<template>\\n  <!-- van-popup 如果不设置 :lock-scroll=\\\"false\\\"，自动打开弹窗会出现页面锁住不能滚动（vue2版本不会） -->\\n  <van-popup v-model:show=\\\"dialogVisible\\\" v-bind=\\\"$attrs\\\" :lock-scroll=\\\"false\\\">\\n    <slot></slot>\\n  </van-popup>\\n</template>\\n\\n<script setup lang=\\\"ts\\\">\\nimport { Popup as VanPopup } from 'vant'\\nimport useHistoryPopup, { historyPopupProps } from '@/hooks/useHistoryPopup'\\n\\ndefineProps({\\n  ...historyPopupProps\\n})\\nconst { dialogVisible } = useHistoryPopup()\\n</script>\\n```\\n\\n## Vue2实现\\n\\nvue2 实现跟 vue3 实现差不多，唯一的区别就是vue2的 `vue-route` 不会将上一页信息记录在 `window.history.state.back` 中，这就需要自己去扩展 `vue-router`，手动实现`window.history.state.back`。\\n\\n### 扩展路由\\n\\n首先重写 `$router.push()`, `$router.replace` 方法，并在跳转后给 `window.history.state` 对象添加 `back`, `current`, `forward` 等信息。除此之外，还需在首次加载、手动输入地址并跳转时，设置 `window.history.state` 信息。\\n\\n``` js\\n// router-extend.js\\n// 扩展路由历史记录的状态信息【支持版本vue-router@3.6.4，版本不能太低】\\nexport function extendHistoryState (router) {\\n  // 设置history.state的值\\n  function setHistoryState (state) {\\n    history.replaceState({\\n      ...history.state,\\n      ...state\\n    }, '')\\n  }\\n  \\n  // 首次进入页面记录当前路由信息\\n  let once = true\\n  function setRouteStateAtFirst () {\\n    // 此处不能销毁afterEach，如果销毁了，在其他地方使用afterEach勾子，首次不会触发改勾子回调\\n    router.afterEach((route) => {\\n      if (!once) return\\n      once = false\\n      setHistoryState({\\n        back: history.state?.back || null,\\n        current: route.fullPath,\\n        forward: history.state?.forward || null\\n      })\\n    })\\n  }\\n  \\n  // 监听popstate，当手动输入地址跳转其他页面时，记录路由信息\\n  function handlePopstate () {\\n    if (history.state?.current) return\\n    \\n    const from = router.currentRoute\\n    // 记录跳转后的路由信息\\n    const destroy = router.afterEach((to) => {\\n      setHistoryState({\\n        back: from.fullPath,\\n        current: to.fullPath,\\n        forward: null\\n      })\\n      destroy()\\n    })\\n  }\\n    \\n  const { push, replace  } = router\\n  \\n  // 重写router.push\\n  function routerPush (location, onComplete, ...rest) {\\n    const to = router.resolve(location)\\n    const fromPath = router.currentRoute.fullPath\\n    // 记录跳转前的路由信息\\n    if (to) {\\n      setHistoryState({\\n        back: history.state?.back || null,\\n        current: fromPath,\\n        forward: to.route.fullPath\\n      })\\n    }\\n    // 记录跳转后的路由信息\\n    const complete = (...args) => {\\n      const curPath = router.currentRoute.fullPath\\n      setHistoryState({\\n        back: fromPath,\\n        current: curPath,\\n        forward: null\\n      })\\n      onComplete && onComplete.apply(router, args)\\n    }\\n    return push.apply(router, [location, complete, ...rest])\\n  }\\n  \\n  // 重写router.replace\\n  function routerReplace (location, onComplete, ...rest) {\\n    // 记录跳转后的路由信息\\n    const complete = (...args) => {\\n      const curPath = router.currentRoute.fullPath\\n      setHistoryState({\\n        back: history.state?.back || null,\\n        current: curPath,\\n        forward: history.state?.forward || null\\n      })\\n      onComplete && onComplete.apply(router, args)\\n    }\\n    return replace.apply(router, [location, complete, ...rest])\\n  }\\n  \\n  setRouteStateAtFirst()\\n  window.addEventListener('popstate', handlePopstate)\\n  router.push = routerPush\\n  router.replace = routerReplace\\n}\\n```\\n\\n使用 `extendHistoryState`:\\n\\n``` js\\nimport Router from 'vue-router'\\nimport { extendHistoryState } from './router-extend'\\n\\nconst router = new Router(...)\\nextendHistoryState(router)\\n```\\n\\n### 组件\\n\\n``` js\\n<template>\\n  <van-popup v-model=\\\"dialogVisible\\\" v-bind=\\\"$attrs\\\">\\n    <slot></slot>\\n  </van-popup>\\n</template>\\n\\n<script>\\nexport default {\\n  name: 'HistoryPopup',\\n  props: {\\n    modelValue: {\\n      type: Boolean,\\n      default: false\\n    },\\n    queryKey: {\\n      type: String\\n    },\\n    queryValue: {\\n      type: [Number, String, Boolean],\\n      default: true\\n    }\\n  },\\n  model: {\\n    prop: 'modelValue',\\n    event: 'modelValueChange'\\n  },\\n  computed: {\\n    dialogVisible: {\\n      get () {\\n        return this.modelValue\\n      },\\n      set (val) {\\n        this.$emit('modelValueChange', val)\\n      }\\n    }\\n  },\\n  methods: {\\n    // 弹窗打开事件\\n    onOpen () {\\n      this.addQuery()\\n    },\\n\\n    // 弹窗关闭事件\\n    onClose () {\\n      if (this.hasBackRecord()) {\\n        this.$router.back()\\n      } else {\\n        this.removeQuery()\\n      }\\n    },\\n\\n    // 判断弹窗是否有返回记录\\n    hasBackRecord () {\\n      const state = window.history?.state\\n      if (state && this.queryKey) {\\n        if (!state.back) return false\\n        \\n        const backRoute = this.$router.resolve(state.back || '') // 解析出返回路由\\n        if (backRoute.path === this.$routepath) {\\n          \\n          const backQuery = backRoute.query || {} // 上一页的query参数\\n          const curQuery = this.$route.query || {} // 当前页query参数\\n          return (this.queryKey in curQuery) && !(this.queryKey in backQuery)\\n        }\\n        return false\\n      } else {\\n        return false\\n      }\\n    },\\n\\n    // 添加query参数\\n    addQuery () {\\n      if (!this.existQueryKey()) {\\n        const newQuery = { ... this.$route.query }\\n        if (this.queryKey) newQuery[this.queryKey] = this.queryValue?.toString?.()\\n        this.$router.push({\\n          query: newQuery\\n        })\\n      }\\n    },\\n\\n    // 移除query参数\\n    removeQuery () {\\n      if (this.queryKey && this.existQueryKey()) {\\n        const newQuery = { ... this.$route.query }\\n        delete newQuery[this.queryKey]\\n        this.$router.replace({\\n          query: newQuery\\n        })\\n      }\\n    },\\n\\n    // url上是否存在queryKey\\n    existQueryKey () {\\n      const { query } = this.$route \\n      return this.queryKey && this.queryKey in query\\n    }\\n  },\\n  watch: {\\n    dialogVisible (val) {\\n      val ? this.onOpen() : this.onClose()\\n    },\\n    '$route.query': {\\n      immediate: true,\\n      handler () {\\n        if (!this.queryKey) return\\n  \\n        const exist = this.existQueryKey()\\n        // 自动关闭弹窗\\n        if (!exist && this.dialogVisible) {\\n          this.dialogVisible = false\\n        }\\n        // 自动打开弹窗\\n        if (exist && !this.dialogVisible) {\\n          this.dialogVisible = true\\n        }\\n      }\\n    }\\n  }\\n}\\n</script>\\n\\n<style lang='less' scoped>\\n\\n</style>\\n```\\n\\n#### 优化\\n\\nvue2优化跟vue3优化同理，详见源码 `根目录/vue2/`：\\n\\n1、无需采用扩展路由写法\\n2、返回键关闭弹窗逻辑写为mixin，方便复用\\n\\n## 结尾\\n\\n至此，H5实现物理返回键关闭弹窗完成，功能包括：\\n\\n* 物理返回键关闭弹窗\\n\\n* 支持多级弹窗嵌套\\n\\n* 支持弹窗跳转\\n\\n* 无多余历史记录\\n\\n## 最后附上地址\\n\\n\\nvue3预览：[https://xiaocheng555.github.io/physical-button-close-popup](https://xiaocheng555.github.io/physical-button-close-popup)\\n\\nvue2预览：[https://xiaocheng555.github.io/physical-button-close-popup/v2](https://xiaocheng555.github.io/physical-button-close-popup/v2)\\n\\n源码：[https://github.com/xiaocheng555/physical-button-close-popup](https://github.com/xiaocheng555/physical-button-close-popup)",
        "tags": [
            "Vue.js",
            "vue-router",
            "前端"
        ]
    },
    {
        "article_id": "7181047724320489509",
        "cover_image": "https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c20d7777c5844b8b6457d8a5b8c15d9~tplv-k3u1fbpfcp-watermark.image?",
        "title": "2022年终总结，展望规划2023",
        "brief": "「回顾2022，展望2023，我正在参与2022年终总结征文大赛活动」 2022年我经历了哪些事？ 蓦然回首，2022年竟就这般的过去了，再过几日，我也将迈入25岁的行列，在2023年我会继续砥砺前行",
        "user_name": "我搁这敲代码呢",
        "view_count": 1091,
        "collect_count": 7,
        "comment_count": 2,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/391d40807b41532f55fa239916661189~300x300.image",
        "category": "代码人生",
        "content": "---\\ntheme: smartblue\\n---\\n\\n「回顾2022，展望2023，我正在参与[2022年终总结征文大赛活动](https://juejin.cn/post/7172462429929111559 \\\"https://juejin.cn/post/7172462429929111559\\\")」 |\\n| -------------------------------------------------------------------------------------------------------------------------------\\n\\n## 2022年我经历了哪些事？\\n\\n`蓦然回首，2022年竟就这般的过去了，再过几日，我也将迈入25岁的行列，在2023年我会继续砥砺前行；`\\n\\n### 我自己\\n\\n这一年年初时，我还是在一家小的外包公司混日子，每天都是得过且过，因为家中做一些小生意，在广州也有房子，家中也有些小钱，故而一直以来都没有啥特别大的奋斗激情；\\n\\n确实人的成长总都是来自于痛苦，年初家中来了几名不速之客，是银行的工作人员，前两年疫情知道父亲的生意不是那么好，但是没想到会这么差，以前的积蓄赔光了不说，还欠下银行一笔不少的贷款，确实我的安逸梦也随之慢慢破碎，家中的气息也一日比一日凝重，我的心境也跟随着慢慢的变化着；\\n\\n### 改变我\\n\\n在年中五月份时候，我下定决心改变自己，第一份工作从毕业后便进来了，公司小小的，工作也不是很忙，但是薪资同样也是很一般；\\n\\n我知道未来的日子，我需要成长，扛起自己的责任，我需要成长，我需要赚更多的钱；所以我选择离开了第一家公司，背了个把月的面试题，也是幸运在5月份的时候，广州的行情还没有像现在这般严峻，最终我成功进入到了一家做新能源相关的公司，工资12k，对比以前也算是有了提升；\\n\\n### 规划我\\n\\n年中的时候也做了些规划，现在看来里面也有许多不合理的地方，学的杂，对知识点大多是停留在广度上面，许多知识点需要的深度掌握都没有去做，我自己也感觉到自己的知识点很多都是能写业务，但是完成写深层次的东西，我自己就明显感觉力不从心，抓瞎，所以接下来2023年着重提升自己的知识深度层面；\\n\\n### 我做了\\n\\n\\n**技术方面：**\\n\\n1. 完成掘金文章 29 篇，其中也有一些获得了推荐，自己也比较开心，自己用心写的文章受到了认可！\\n\\n- [微前端（qiankun）最直白Demo带你轻松入门](https://juejin.cn/post/7177255753701392442)\\n\\n- [无感刷新token怎样实现？前后端案例代码手把手带你实现！](https://juejin.cn/post/7158750013709877285)\\n\\n- [自定义图表--随意拖拽拉伸功能的实现](https://juejin.cn/post/7151692971430117390)\\n\\n2. 看了些书籍\\n\\n- 算法图解\\n- JavaScript 设计模式与开发实践\\n- JavaScript 权威指南看了一半，后面没看下去了😂\\n\\n3. 学习了哪些新技术\\n\\n- 学习了 nodejs（koa，express）\\n- B站 看了MySQL数据库入门到精通，从mysql安装到mysql高级、mysql优化全囊括（算是学习到了一些数据库的皮毛，起码能够操作数据库了）\\n- 工作原因学习了 微前端 qiankun\\n- 学习了在 阿里云布置项目上线（后面有时间总结出一篇文章哈！）\\n- 重新拾起了 react 从头到尾学习了一遍\\n\\n4. 刷题\\n\\n- 乐扣刷了一些题，大概十几道，不多，感觉还是个人懒惰了些，明年需要提升自己的刷题数，练习下自己的算法思维；\\n\\n5. 开源\\n\\n- 利用了些闲暇时间，自己从头配置了一个后台项目基本模板，也算是对webpack加深了些认识；\\n\\n- [Leno-Admin-template](https://gitee.com/zhao-wenchao110/leno-admin-template)\\n\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d31d820c4f17466cb95ba70f2dde7a4b~tplv-k3u1fbpfcp-watermark.image?)\\n\\n自己的一些学习时间统计，软件是 iHour 个人感觉还挺好用的；\\n\\n**生活方面：**\\n\\n1. 健身方面\\n\\n今年年中自己的体重也一度逼近了180斤，自己先是在家锻炼了一阵子，最后到健身房去了，暂时来说也是减肥到了157斤，这段时间疫情🐏了，健身差不多停了一个星期；\\n\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d997f131cdb4d8b873f569afeaedf21~tplv-k3u1fbpfcp-watermark.image?)\\n\\n2. 理财方面\\n\\n因为现在囊中羞涩，也没啥理财的欲望，就闲暇换换口味看了一本《穷爸爸富爸爸》，我相信大多数想学习理财的人第一步都是看这本书了~\\n\\n3. 英语方面\\n\\n英语方面一直是我的痛点，今年想学习的，但是背单词坚持了一段时间，发现收效甚微，明年看下找些课程学习，单词也要继续坚持背诵；\\n\\n**自我总结：**\\n\\n技术方面还是需要继续学习，往深度钻研，吃透js，webpack，vue（react）框架，后端继续钻研，重视算法与设计模式，提升自己的代码质量等等；\\n\\n生活方面，继续坚持健身，争取明年瘦到145左右，理财等其他方面也可以多看看，陶冶一下自己的情操，丰富自己的知识面；\\n\\n## 2023年我应该做哪些事？\\n\\n### 技术方面\\n\\n技术方面的提升，我参考了一位大神的文章，把链接放在这里，有需要的小伙伴可以去看看：\\n[写给初中级前端的高级进阶指南](https://juejin.cn/post/6844904103504527374)\\n\\n**1、JavaScript基础能力的提升**\\n\\n- 完全熟练的掌握 eventLoop 事件循环\\n- Promise 的掌握，需达到能够自己手写出来\\n- async await 的深度学习\\n- 插件机制的学习与掌握，需达到自己能够写插件\\n- 对自己的代码规范进行高要求，提高自己的整体代码规范\\n- 异常处理的了解\\n- 了解设计模式，尝试在项目中使用\\n- 了解开发思想\\n\\n**2、熟练算法**\\n\\n- 多刷乐扣，2023年需最低完成200道乐扣题\\n\\n**3、框架学习**\\n\\nVue方面\\n\\n- 熟练应用\\n- 学习了解源码；\\n- 了解vue3\\n\\nReact方面\\n\\n- 熟练应用,全面接受hook开发模式\\n- React性能优化\\n- React 和 TypeScript 结合使用\\n- 了解 React 源码\\n\\n**4、TypeScript**\\n\\n- 在日常自己的开源项目中，全面使用 typescript，并且熟悉 typescript 的入门与进阶方面知识点；\\n\\n**5、代码质量**\\n\\n- 代码风格（项目中集成：prettier+ESlint）\\n- 学习一些高质量架构的项目\\n- 规范 git 提交信息（严格规范）\\n\\n**6、构建工具 webpack**\\n\\n- 深入了解 webpack 的原理，并且尝试自己写一些 plugin 与 loader；\\n\\n**7、性能优化**\\n\\n- 在日常项目中，更加注重性能优化，并且看一些性能优化的文章；\\n\\n**8、尝试阅读英文资料**\\n\\n- 开始接收并尝试阅读一些英文的资料；\\n\\n**9、学习新技术**\\n\\n- 学习 Linux\\n- 学习 nginx\\n- 学习 react native\\n\\n### 开源项目方面\\n\\n**1、基于vue-ruoyi重新自己构建 react + koa 版本的ruoyi**\\n- 前端用 React18 + webpack5 + mobx + react-router + typescript； \\n- 后端用 koa2 + typescript + mysql；\\n\\n**2、用 React Native 写一个高质量app**\\n\\n- 软件需要兼容 安卓端 与 苹果端\\n\\n### 生活方面\\n\\n**1、健身方面：**\\n\\n- 需要将体重减到145斤；\\n- 练肌肉，体重达标后，需要保持每周3~4天的健身量；\\n\\n**2、理财方面：**\\n\\n- 尝试多看一些理财的书；\\n\\n2022年下半年的目标我个人感觉只能给自己打65分，又很多地方做的不到位，很多目标经常更换，在即将到来的2023年，要要求自己目标清晰，一路钻研到底，将自己今年立的任务，一个个的完成，加油自己！",
        "tags": [
            "前端",
            "JavaScript",
            "程序员"
        ]
    },
    {
        "article_id": "7157229673301147656",
        "cover_image": "https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af73b90d33604e8c99fbb4f6df872628~tplv-k3u1fbpfcp-watermark.image?",
        "title": "使用Vue3.2新指令v-memo提升性能(含源码浅析)",
        "brief": "使用vue3.2 新指令 v-memo提升性能，简单的说, 就是 v-memo中依赖的值若不发生变化，当前DOM及整个子树DOM都不会重新渲染, 会使用最后一次缓存的结果。",
        "user_name": "浏览器API调用工程师",
        "view_count": 8534,
        "collect_count": 71,
        "comment_count": 40,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/3a7164e8729a54bf8a5e51a7c2bb6157~300x300.image",
        "category": "前端",
        "content": "持续创作，加速成长！这是我参与「掘金日新计划 · 10 月更文挑战」的第7天，[点击查看活动详情](https://juejin.cn/post/7147654075599978532 \\\"https://juejin.cn/post/7147654075599978532\\\")\\n\\n# 前言\\n> 大家好，我是 [Taylor](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fzhangbowy \\\"https://github.com/zhangbowy\\\")，一个有趣且乐于分享的人，目前专注前端、Node.js技术栈分享，如果你对 前端、Node.js 学习感兴趣的话（后续有计划也可以)，可以关注我掘金.\\n# 背景\\n看vue3.2的CHANGELOG 发现新增了一个指令 v-memo\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4d363a9f0b648b496b03d10dc2d4a9b~tplv-k3u1fbpfcp-watermark.image?)\\n\\n一听这名字, 用过react的同学肯定想到了`useMemo`, 没错，这是`一个性能优化的指令`, 一起来学习一下吧。\\n\\n\\n# v-memo定义\\n\\n官方文档里是这样描述的: \\n\\n> 缓存一个模板的子树。在元素和组件上都可以使用。为了实现缓存，该指令需要传入一个固定长度的依赖值数组进行比较。如果数组里的每个值都与最后一次的渲染相同，那么整个子树的更新将被跳过.\\n\\n毕竟是官方文档，肯定不那么通俗易懂。\\n\\n**简单的说, 就是 v-memo中依赖的值若不发生变化，当前DOM及整个子树DOM都不会重新渲染, 会使用最后一次缓存的结果。**\\n\\n**它存储先前渲染的结果以加速未来的渲染。**\\n\\n\\n听到这, 心想, 呀 这不就是`computed`嘛,  我的理解, 干的事差不多，不过是一个缓存dom, 一个缓存数据。\\n\\n> 事实上，v-memo 可以看作是模板部分的计算属性！\\n\\n\\n# 使用\\n`v-memo`接受一个数组\\n## 1、示例一 空的依赖项数组\\n\\n如果传入一个空的依赖项数组, 他将永远不会重新渲染，永远使用第一次渲染的缓存结果, 和`v-once`类似\\n```\\n<template>  \\n    <div v-memo=\\\"[]\\\">{{ data }}</div>\\n    <!-- 等同 -->\\n    <div v-once>{{ data }}</div>\\n/template>\\n````\\n\\n## 2、 示例二 控制更新、控制(大)DOM重新渲染时间\\n\\n看接下来这个例子， 我设置了2个计数器, 但只有在被依赖的 `subscribers` 变化时, 子节点才会重新渲染。\\n\\n### 代码\\n```\\n<script setup>\\nimport { ref } from 'vue'\\n// v-memo依赖项\\nconst subscribers = ref(10000);\\n// v-memo子节点依赖项\\nconst inner = ref(500);\\n</script>\\n<template>\\n  <div>\\n    <p>视图状态</p>\\n    <div v-memo=\\\"[subscribers]\\\">\\n      <p>Subscribers: {{ subscribers }}</p>\\n      <p>inner: {{ inner }}</p>\\n    </div>\\n    <button @click=\\\"subscribers++\\\">v-memo依赖项(Subscribers)++</button>\\n    <!-- 这里改变内部依赖 视图不会更新 -->\\n    <button @click=\\\"inner++\\\">子节点依赖项(inner)++</button>\\n    <div>\\n      <p>当前状态</p>\\n      <p>Subscribers: {{ subscribers }}</p>\\n      <p>inner: {{ inner }}</p>\\n    </div>\\n  </div>\\n</template>    \\n```\\n如果我们修改了子节点依赖的inner，我们的 div 将不会重新渲染，但只要我们更新`subscribers`的值即会重新渲染, 发现没\\n\\n**我们可以控制dom的重新渲染**\\n\\n### 案例效果展示\\n\\n![v-memo.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0fa6a89949a4bdab8a991ab6440a4fc~tplv-k3u1fbpfcp-watermark.image?)\\n\\n### 结论\\n在某些情况，业务逻辑复杂的时候，手动控制整体的更新来提高性能。\\n\\n**如果我们需要准确控制大型组件的重新渲染时间，这将非常滴好用。**\\n\\n## 3、示例三 配合v-for优化列表\\n\\n\\n> 当搭配 `v-for` 使用 `v-memo`，确保两者都绑定在同一个元素上。**`v-memo` 不能用在 `v-for` 内部。**\\n\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/995ce658b64f436e87c2510b56d30cc9~tplv-k3u1fbpfcp-watermark.image?)\\n\\n我仅仅从渲染时间评判了一下。\\n\\n关于子组件渲染的v-memo优化问题可以看这篇 \\nhttps://learnvue.co/tutorials/v-once-v-memo\\n\\n\\n### 列表测试代码\\n官方文档说的过于简略， 于是我,完善了一个测试demo, 大家也可以复制去测试\\n\\n#### 方法及变量释意\\n\\n- `selected` 被选中的值，我们这里只做一个选中\\n\\n- `list` 列表数据，根据array from 造的数据\\n\\n- `onClickSelect` 点击选中方法， 选中数据、计算渲染时间\\n\\n#### 完整代码\\n当组件的 `selected` 状态改变，默认会重新创建大量的 vnode，尽管绝大部分都跟之前是一模一样的。`v-memo` 用在这里本质上是在说“只有当该项的被选中状态改变时才需要更新”。接下来我们来对比看看吧\\n```\\n\\n<script setup>\\nimport { ref } from 'vue'\\n   // 被选中的值\\n  const selected = ref(0);\\n  // 造的列表数据\\n  const list = ref(\\n    Array.from({ length: 1001 }, (_, index) => {\\n      return {\\n        id: index,\\n        name: `test${index}`,\\n      };\\n    }),\\n  );\\n  // 选中点击方法\\n  const onClickSelect = (id) => {\\n    selected.value = id;\\n    // 记录开始时间\\n    console.time()\\n    nextTick(()=> {\\n      // 记录结束时间\\n      console.timeEnd()\\n    })\\n  }\\n</script>\\n<template>\\n  <div>\\n    <div v-for=\\\"item in list\\\" @click=\\\"onClickSelect(item.id)\\\">\\n      <p>ID: {{ item.id }} - selected: {{ item.id === selected }}</p>\\n    </div>\\n  </div>\\n</template>\\n```\\n\\n### 长度1000的列表\\n#### 造1000条数据\\n```\\nconst list = ref(\\nArray.from({ length: 1000}, (_, index) => {\\n  return {\\n    id: index,\\n    name: `test${index}`,\\n  };\\n}),\\n);\\n```\\n#### 改变slected值触发更新\\n点击列表项\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f8359ad5511d4b5fbdc0b8d81c6c040f~tplv-k3u1fbpfcp-watermark.image?)\\n\\n#### 控制台查看渲染时间\\n加上 `v-memo=\\\"[item.id == selected]\\\"`\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e8d510dee35480b8e1f2d9ce30a7985~tplv-k3u1fbpfcp-watermark.image?)\\n\\n不加\\n \\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/066c0ebb2f464bc0896e0fb47757b335~tplv-k3u1fbpfcp-watermark.image?)\\n**没有很大差别**\\n\\n### 长度2w的列表\\n1000的对比不出来，我们把数据量增加到两万看看\\n\\n#### 改变slected值触发更新\\n点击列表项\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f8359ad5511d4b5fbdc0b8d81c6c040f~tplv-k3u1fbpfcp-watermark.image?)\\n\\n#### 控制台查看渲染时间\\n加上 `v-memo=\\\"[item.id == selected]\\\"`\\n\\n平均DOM更新时间 `30ms+`\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b66d1b3e725a478c89eb04c5d684d6bb~tplv-k3u1fbpfcp-watermark.image?)\\n\\n不加\\n\\n平均DOM更新时间 `55ms+`\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2601603228664f319a1820fae087724c~tplv-k3u1fbpfcp-watermark.image?)\\n30ms和50多ms, 差了快一倍， 但2w数据...., 其实感觉差的也不多。\\n\\n\\n### 结论\\n确实如官方文档所说是用于微小优化， 长度1000的list经过我的测试, 渲染时间几乎没有太大差别。\\n\\n**本节实验可得:  用于性能至上场景中的微小优化**\\n\\n# 源码浅读\\n> 我们这里只看了运行时的代码\\n## 查找\\n因本人未系统了解vue3主仓库源码, 所以想到了从以下几个方面快速查找。\\n> 希望能给你带来一些日后找源码的思路。\\n### vue/core主仓库COMMIT记录\\n发现了 尤大的一条  `feat: v-memo` 的提交记录\\n\\n[feat: v-memo commit链接](https://github.com/vuejs/core/commit/3b64508e3b2d648e346cbf34e1641f4022be61b6#diff-26926f2d1320b7bedabccff3652dca5a6cff961edaff8aeee427c4d630dd4b38)\\n    \\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/037999f450e34b1483db44cb454ca3b5~tplv-k3u1fbpfcp-watermark.image?)\\n\\n看新增和修改了那儿些文件, 发现 新增了 好几个memo相关的文件\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/11564e1d8c5a4f4f9180b433a516d3cb~tplv-k3u1fbpfcp-watermark.image?)\\n\\n这个tab先别关，打开一个新tab我们进行下一步\\n\\n### vue在线的模板编译工具\\n> 查看v-memo被编译成了什么样子\\n    \\n链接[ https://template-explorer.vuejs.org   ](https://template-explorer.vuejs.org/#eyJzcmMiOiJcbjxkaXYgdi1tZW1vPVwiWzIsMl1cIj5IZWxsbyBXb3JsZDwvZGl2PlxuPGRpdiB2LW1lbW89JzEnPkhlbGxvIFdvcmxkITwvZGl2PlxuXG48ZGl2IHYtbWVtbz0nMSc+e3t0cnVlID8gJzEnOiAnMicgfX17e3RydWUgPyAnMSc6ICcyJyB9fTwvZGl2PlxuXG5cblxuXG5cblxuIiwic3NyIjpmYWxzZSwib3B0aW9ucyI6eyJjYWNoZUhhbmRsZXJzIjp0cnVlfX0=)\\n\\n于是我在里面写了一个`v-memo=\\\"[]\\\"`, 发现vue编译成了如下。\\n```\\nimport { createTextVNode as _createTextVNode, openBlock as _openBlock, createElementBlock as _createElementBlock, withMemo as _withMemo } from \\\"vue\\\"\\n\\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\\n  return _withMemo([], () => (_openBlock(), _createElementBlock(\\\"div\\\", null, [\\n    _createTextVNode(\\\"Hello World!\\\")\\n  ])), _cache, 0)\\n}\\n```\\n\\n查找关键词`memo`, 发现有一个`_withMemo` 的方法把生成dom的方法包裹了起来, 我分析\\n\\n    \\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/65b092dd793e471b96a6f02892b5fc28~tplv-k3u1fbpfcp-watermark.image?)\\n\\n- 包了一层, 首先这是`面向切换的思想`\\n- 包了一层处理, 我猜测在这个_withMemo方法里，如果数据没变，就返回缓存，变了就生成一份并缓存, 再返回。\\n\\n **那我下一步就需要找这个withMemo方法看他怎么写的**。\\n\\n\\n### withMemo方法\\n用第一步看的commit记录 很快定位到了runtime里的withMemo方法,\\n\\nwithMemo代码链接\\nhttps://github1s.com/zhangbowy/core/blob/main/packages/runtime-core/src/helpers/withMemo.ts#L1-L39\\n\\n#### 运行时 withMemo方法解读\\n##### 参数 \\n - `memo` v-memo里传的数据数组\\n - `render` dom渲染方法\\n - `cache` 缓存\\n - `index` 下标\\n\\n##### 1、有缓存无数据变化、返回缓存\\n```\\n// 获取缓存\\nconst cached = cache[index] as VNode | undefined\\n// 如果存在缓存或者数据没变\\nif (cached && isMemoSame(cached, memo)) {\\n// 返回缓存\\n    return cached\\n}\\n```\\n##### 2、执行渲染方法、缓存一份、然后返回\\n走到这一步说明没有命中缓存, 就生成一份、缓存下来， 然后返回，下次进来，如果数据没有变化，那就走第一步，直接返回缓存。\\n\\n```\\n// 执行渲染方法生成DOM\\nconst ret = render()\\n// 克隆一份依赖数据\\n// shallow clone\\nret.memo = memo.slice()\\n// 返回DOM 并缓存。\\nreturn (cache[index] = ret)\\n```\\n##### 完整代码\\nwithMemo方法完整代码及解读\\n```\\n// https://github1s.com/zhangbowy/core/blob/main/packages/runtime-core/src/helpers/withMemo.ts#L1-L39\\nimport { hasChanged } from '@vue/shared'\\nimport { currentBlock, isBlockTreeEnabled, VNode } from '../vnode'\\nexport function withMemo(\\n  memo: any[],\\n  render: () => VNode<any, any>,\\n  cache: any[],\\n  index: number\\n) {\\n    // 获取缓存\\n    const cached = cache[index] as VNode | undefined\\n    // 如果存在缓存或者数据没变\\n    if (cached && isMemoSame(cached, memo)) {\\n    // 返回缓存\\n        return cached\\n    }\\n    // 执行渲染方法生成DOM\\n    const ret = render()\\n    // 克隆一份依赖数据\\n    // shallow clone\\n    ret.memo = memo.slice()\\n    // 返回DOM 并缓存。\\n    return (cache[index] = ret)\\n}\\nexport function isMemoSame(cached: VNode, memo: any[]) {\\n    ...\\n}\\n\\n```\\n## 源码总结\\n### 1、`v-memo`代码被编译成了withMemo方法包起来. \\nv-memo在模版编译阶段被处理成了withMemo包了一层\\n> 模板转换的源码有兴趣的小伙伴可以自己去研究\\n\\ntemplate里书写\\n```js\\n<div v-memo=\\\"[]\\\">Hello World</div>\\n```\\n模板编译后\\n```js\\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\\n  return _withMemo([], () => (_openBlock(), _createElementBlock(\\\"div\\\", null, [\\n    _createTextVNode(\\\"Hello World!\\\")\\n  ])), _cache, 0)\\n}\\n```\\n### 2、withMemo方法\\n withmemo方法, 先是判断有缓存和数据无变化，就返回上一次生成的DOM\\n \\n 否则就执行渲染方法，生成一份，缓存后并返回。 \\n\\n    \\n# 总结\\nv-memo的使用总结如下:\\n    \\n- 如果v-memo依赖一个空list, 不推荐使用.\\n- 在某些情况，业务逻辑复杂的时候，手动控制整体的更新来提高性能。\\n- **如果我们需要控制大型组件的重新渲染时间，这很有帮助。**\\n- 大list渲染优化\\n\\n如果有问题， 欢迎大佬们评论区Q我！\\n    \\n",
        "tags": [
            "前端",
            "Vue.js",
            "掘金·日新计划"
        ]
    },
    {
        "article_id": "7190601914734608444",
        "cover_image": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/177b3569b7ca484293e8895cfa6036eb~tplv-k3u1fbpfcp-watermark.image?",
        "title": "多篇SQL性能优化文章、仿贝壳App全景看房 | 酱酱的下午茶第158期",
        "brief": "聊一聊我对跨域的理解和最佳实践 这样的优化对 MySQL 来说作用微乎其微 SQL为什么动不动就N百行以K计 一次偶然机会发现的MySQL“负优化”",
        "user_name": "酱酱们的下午茶",
        "view_count": 2485,
        "collect_count": 7,
        "comment_count": 0,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/b72e991ee9b1c9bdca7b2bd4c8dc78a8~300x300.image",
        "category": "阅读",
        "content": "---\\ntheme: Chinese-red\\n---\\n\\n> **『掘金酱的下午茶』团队全体成员预祝各位掘友新春快乐，岁岁平安，生活美满，兔年大吉！** 🧧🧧🧧\\n> \\n> **来年我们将继续努力，为大家带来更多优质的内容，让我们共同努力，共同进步！**\\n\\nHello，又到了每天一次的下午茶时间。酱酱们的下午茶新增优质作者介绍和码上掘金板块，专注于发掘站内优质创作者和优质内容，欢迎大家多提宝贵意见！\\n\\n\\n> - 【本期掘金酱的下午茶】亮点：\\n> -  聊一聊我对跨域的理解和最佳实践\\n> - 这样的优化对 MySQL 来说作用微乎其微\\n> - SQL为什么动不动就N百行以K计\\n> - 一次偶然机会发现的MySQL“负优化”\\n> - ……\\n>\\n> **筛选规则**：文章发布时间在本期「掘金酱的下午茶」发布时间的 1-3 天内，且符合社区推荐标准，也会同步发布在掘金相关技术社群。\\n\\n\\n### 今日主理人｜下午茶\\n本期每日掘金由 [ 丘山子 ](https://juejin.cn/user/3008695929418318) 负责制作，需要投稿下午茶请私信我的助理[ 小岳 ](https://juejin.cn/user/3008695929418318)。\\n\\nPS：主理人目前正在招募中，有感兴趣的掘友们可以联系[**Captain**](https://juejin.cn/user/3052665287739005)\\n\\n\\n### 每日干货｜下午茶\\n\\n**主理人们会对近期（1-3 天）社区深度技术好文进行挖掘和筛选，优质的技术文章有机会出现在下方列表，排名不分先后。**\\n\\n\\n### 『前端』\\n\\n - [【源码阅读】omit.js｜omit的实现与库的快速搭建](https://sourl.co/yhYcJq) \\n\\n > # omit的实现与库的快速搭建\\n\\n- [用js实现一个网页版节拍器](https://sourl.co/8BD2dF) \\n\\n > # 用js实现一个网页版节拍器\\n\\n- [2023 过春年，烟花依然了无缘；这能难倒程序猿？一键三连过大年！](https://sourl.co/z67vFC) \\n\\n > # 用前端三剑客实现烟花\\n\\n- [聊一聊我对跨域的理解和最佳实践](https://sourl.co/U2P3fh) \\n\\n > 跨域是前端开发中一个非常常见的问题，尤其是随着单页应用（Single Page Application, SPA）的兴起，前后端分离开发和部署，前端在本地开发和部署的过程中都会面临着跨域问题。我们再次聊聊跨域这个话题，以及项目中对跨域的一些实践经验，希望带来一些新的收获。\\n\\n\\n- [仿贝壳app全景看房（React+Mobx+Egg+Three.js入门级全栈实战项目）](https://sourl.co/dXEbem) \\n\\n > 首先就是对贝壳看房app进行分析。进来 app 首页点击下方的 Tabber 标签栏就能实现页面的切换；于是就决定将这五个页面写成五个不同的路由，将这些路由进行集中的管理。每个页面里面的内容进行组件式的封装用不同的路由地址展示组件的内容，再引用到该页面上，大致思路就是这样。\\n\\n\\n### 『后端』\\n\\n - [SQL为什么动不动就N百行以K计？](https://sourl.co/99fD7f) \\n\\n > 发明SQL的初衷之一显然是为了降低人们实施数据查询计算的难度。SQL中用了不少类英语的词汇和语法，这是希望非技术人员也能掌握。确实，简单的SQL可以当作英语阅读，即使没有程序设计经验的人也能运用。\\n > \\n > 然而，面对稍稍复杂的查询计算需求，SQL就会显得力不从心，经常写出几百行有多层嵌套的语句。这种SQL，不要说非技术人员难以完成，即使对于专业程序员也不是件容易的事，常常成为很多软件企业应聘考试的重头戏。三行五行的SQL仅存在教科书和培训班，现实中用于报表查询的SQL通常是以“K”计的。\\n\\n\\n- [这样的优化对 MySQL 来说作用微乎其微](https://sourl.co/xBaVqd) \\n\\n > 今天，我们在这里不展开说明这些问题，而是跟大家介绍在这些优化的层面中，有哪些是优化对 MySQL 数据库来说作用微乎其微，以便我们在产生环境中调优 MySQL 数据库时，避免一些不必要的优化。\\n\\n- [MySQL性能优化浅析及线上案例](https://sourl.co/JSFekA) \\n\\n > 业务发展初期，数据库中量一般都不高，也不太容易出一些性能问题或者出的问题也不大，但是当数据库的量级达到一定规模之后，如果缺失有效的预警、监控、处理等手段则会对用户的使用体验造成影响，严重的则会直接导致订单、金额直接受损，因而就需要时刻关注数据库的性能问题。\\n\\n\\n\\n- [RPC框架泛化调用原理及转转的实践](https://sourl.co/faaUWd) \\n\\n > RPC框架泛化调用功能在网关、接口测试等场景下有着广泛的需求，本文给各位读者介绍一下主流的泛化调用实现方式及原理，比较各种实现方案的优缺点，并分享泛化调用在转转的实践。一方面有助于RPC框架使用方理解泛化调用，更好地使用泛化调用；另一方面对于有自研RPC框架需求的开发者在选择泛化调用实现方案上有一定参考意义。\\n\\n\\n- [一次偶然机会发现的MySQL“负优化”](https://sourl.co/wKh27Z) \\n\\n > 文章最开始先给大家两条sql，请猜猜他们执行会有什么区别？\\n```sql\\nSELECT * from student s where age < 17 and name ='zhangsan12' and create_time < '2023-01-17 10:23:08' order by age LIMIT 1\\n```\\n```sql\\nSELECT * from student s where age < 17 and name ='zhangsan12' and create_time < '2023-01-17 10:23:08' order by age LIMIT 2\\n```\\n> 这两条sql看似只是limit的数值不同，但是第一个执行耗时3ms，第二个执行耗时66s，**相差2000多倍**。\\n\\n> 今天要讲的这件事和上述的两个sql有关，是数年前遇到的一个关于`MySQL`查询性能的问题。主要是最近刷到了一些关于`MySQL`查询性能的文章，大部分文章中讲到的都只是一些常见的索引失效场合，于是我回想起了当初被那个离奇的“索引失效”支配的恐惧。\\n\\n\\n\\n### 📖 投稿专区｜下午茶\\n\\n> 大家可以在评论区推荐认为不错的文章，并附上链接和推荐理由，有机会登上下一期。文章创建日期必须在近 1-3 天内；可以推荐自己的文章、也可以推荐他人的文章。\\n",
        "tags": [
            "前端",
            "后端",
            "程序员"
        ]
    },
    {
        "article_id": "7194066245447057464",
        "cover_image": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe1158fe417243eca41c6cb6a7ecbdc0~tplv-k3u1fbpfcp-watermark.image?",
        "title": "行走缓慢 | 2022年终总结&2023年度计划",
        "brief": "2022年已翻篇一个月，我才来写总结，本想过年在家写来着，结果电脑都没打开过——这也是我2022年个人状态的一个写照——持续的低执行力。 在去年年中也时常查看计划完成度，但每每要行动时，却有各种借口和",
        "user_name": "胡飞洋",
        "view_count": 2117,
        "collect_count": 1,
        "comment_count": 6,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/b25564fafc5363cd9416f59bd2205487~300x300.image",
        "category": "阅读",
        "content": "2022年已翻篇一个月，我才来写总结，本想过年在家写来着，结果电脑都没打开过——这也是我2022年个人状态的一个写照——持续的低执行力。\\n\\n在去年年中也时常查看计划完成度，但每每要行动时，却有各种借口和拖延。回想来原因有三：\\n- 一是丧失了以往的热情和坚持；\\n- 二是个人问题的处理所占用的时间较多；\\n- 三是出现了不少时间黑洞，很多个周末未能充分利用，丢失了空杯心态\\n\\n缓慢行走了一年，需要重新出发，找回20年和21年的劲头！\\n\\n> 去年年终总结：\\n> [人生节点|2021年终总结&2022年度计划](https://juejin.cn/post/7048976026658930702)\\n>\\n# 一、2022复盘\\n## 1.1 目标完成情况\\n**技术目标**\\n\\n| 月份 | 内容 | 完成情况|复盘|\\n| --- | --- | --- | --- |\\n| 一月 |1.ARouter原理分析，输出文章1篇；2.非技术文章-5.5年之路，输出1篇|输出两篇ARouter文章|延后了半年|\\n| 二月 |1.[AppLifeCycle插件](https://github.com/hufeiyang/Android-AppLifecycleMgr)原理分析，输出1篇（从实例认知AOP）;|未完成|/|\\n| 三月 |1.ClassLoader，输出文章1篇|未完成|/|\\n| 四月 |1.Hook技术，输出文章1篇|未完成|/|\\n| 五月 |1.重新理解四大组件、Context、AMS|未完成|/|\\n| 六月 |1.插件化系列-认识/预备知识/现状，输出1篇|未完成|/|\\n| 七月 |1.插件化系列-Activity，输出1篇|未完成|/|\\n| 八月 |1.插件化系列-其他三个组件，输出1篇|未完成|/|\\n| 九月 |1.插件化系列-资源/so，输出1篇|未完成|/|\\n| 十月 |1.性能优化（包体积、内存、布局）-依据工作总结，输出1篇|未完成|/|\\n| 十一月 |1.性能优化（包体积、内存、布局）-依据工作总结，输出1篇|未完成|/|\\n| 十二月 |1.性能优化-（包体积、内存、布局）依据工作总结，输出1篇|未完成|/|\\n\\n**公众号**\\n\\n| 标题 | 完成情况 |复盘|\\n| --- | --- | --- |\\n| 公众号**每周**发一篇文章，目标关注数达**3000**人。 | 未完成 | 连开始都没开始 |\\n\\n**学习成长**\\n\\n| 季度 | 成长点 |输入|完成情况|复盘|\\n| --- | --- | --- | --- | --- |\\n|一季度| 掌握高效工作的方法 |阅读思考实践《小强升职记》、《认知觉醒》|完成阅读|未完全内化，需复习|\\n|二季度|学习财务理财知识|阅读实践《教你读财报》、《投资新手课》、《投资指南》|未完成|去年判断为非优先事项|\\n|三季度|了解通识|阅读《字节跳动》、《激荡三十年》，输出观点/书评|完成70%|/|\\n|四季度|了解通识|阅读《置身事内》、《政治学通识》，输出观点/书评|未完成|/|\\n\\n## 1.2 总结\\n目标整体 **达成率5%**\\n\\n**原因分析**：\\n1. 根因主要是心态问题，空闲时间未能行动，出现时间黑洞\\n2. 缺乏紧迫感，内心驱动力不足\\n3. 加入了个人事项的处理，优先级更高\\n\\n**修正方法**：\\n\\n应该认识到，随着年龄增长，外部对个人能力的要求变得更高，尤其是技术深度/广度、个人效率、做事系统性；还有个人身上肩负的东西会变得更多，需要变得更加强大来支持这一切进而美好地生活\\n1. 调整心态，从此篇开始，从头开始，坚持按目标计划执行\\n2. 生于忧患，保持紧迫感，脚踏实地\\n3. 计划制定的具体性，保留时间缓冲\\n4. 目标事项优先，**避免无意义的时间浪费**！\\n\\n# 二、2023计划\\n\\n**1. 技术目标**\\n\\n目标与工作内容强相关\\n月份| 内容 | 完成情况 | 复盘|\\n---|---|---|---\\n1月 | 完成季度计划| 完成|延迟了一个月\\n2月 | 1.学完性能优化课程；2.输出ARouter第三篇| | \\n3月 |输出文章：流畅度优化 | | \\n4月 |输出文章：包体积优化| | \\n5月 |输出文章：内存优化（含线程收敛/cpu） | | \\n6月 |输出文章：动态策略（页面打开速度/耗电/流量/温度）| | \\n7月 |输出文章：性能优化思维/降本增效思维/AB实验数据收益思维| | \\n8月 |输出文章：插件化基础知（历史/hook/代理/dex）| | \\n9月 |输出文章：朴素的插件化-dex/res/lib | | \\n10月 | 输出文章：Activity插件化| | \\n11月|输出文章：资源插件化 | |\\n12月| 预留缓冲 | | \\n        \\n即深入学习并实践性能优化，完成插件化的系统学习。此过程 **输出10篇文章、公众号粉丝过3k**。\\n\\n**2. 学习目标**\\n\\n月份 | 内容 | 完成情况 |复盘\\n---|---|---|---\\n一季度| 《激荡三十年》、《中国通史》||\\n二季度| 《激荡十年》、《世界通史》||\\n三季度| 《置身事内》||\\n四季度| 《政治学通识》||\\n\\n# 三、总结\\n修正心态，开个好头，保持劲头，持续前进，完成目标！预期下次总结时做到100%完成率！\\n\\n.\\n\\n>**你的 点赞、评论，是对我的巨大鼓励！**\\n\\n>\\n>欢迎关注我的 **公众号** [**胡飞洋**](https://link.juejin.cn/?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2Fi0eE6YraZjlJoulbagMoyw \\\"https://mp.weixin.qq.com/s/i0eE6YraZjlJoulbagMoyw\\\") ，文章更新可第一时间收到；如果**有问题**或者**想进群**，号内有加我微信的入口，我拉你进**技术讨论群**。在技术学习、个人成长的道路上，我们一起前进！",
        "tags": [
            "Android",
            "程序员",
            "年终总结"
        ]
    },
    {
        "article_id": "7194257890893365308",
        "cover_image": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3611f9e1fdf84af9ae4cb3bb13507484~tplv-k3u1fbpfcp-watermark.image?",
        "title": "5K字 由浅入深聊聊Promise实现原理",
        "brief": "这几天再回顾基础知识时，对Promise有了较为深入的理解，那今天就来分享下怎么由浅入深的掌握Promise并且学会手写Promise",
        "user_name": "梁木由",
        "view_count": 510,
        "collect_count": 9,
        "comment_count": 3,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/bda64942fb9146b39558f8809f3b04cb~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: juejin\\nhighlight: github\\n---\\n## 前言\\n\\n`大家好，我是梁木由，是一个有想头的前端。这几天再回顾基础知识时，对Promise有了较为深入的理解，那今天就来分享下怎么由浅入深的掌握Promise并且学会手写Promise`\\n\\n## 概念\\n\\nPromise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了`Promise`对象。\\n\\n所谓`Promise`，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。\\n\\n## Promise 拉出来单练\\n\\n那我们先把Promise拉出来练练，看看是什么玩意，在控制台中打印看下\\n![image-20230112101134170.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a06f55452624b2fa459b200848c1774~tplv-k3u1fbpfcp-watermark.image?)\\n在上图可以看出什么信息呢，那我们罗列下\\n\\n-   首先我们看出在`new Promise`时，需要传入一个回调函数\\n-   它是一个类，并且会返回一个Promise对象\\n-   那还可以看出它有`constructor`构造函数，还有`catch`、`finally`、`then`三个方法\\n\\n那我们根据上述分析出的信息，简单实现一下\\n\\n```javascript\\nclass CustomPromise {\\n  constructor(callBack) {\\n  }\\n  catch() {\\n  }\\n  then() {\\n  }\\n  finally() {\\n  }\\n}\\nconst customPromise = new CustomPromise()\\nconsole.log(customPromis)\\n```\\n\\n看下我们自己简单实现的输出结果\\n![image-20230112103322764.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05d708c68c984663a738efca30a0eaf1~tplv-k3u1fbpfcp-watermark.image?)\\n那我们再写一个Promise的常规用法\\n\\n```javascript\\nconst promise = new Promise((resolve, reject) => {\\n  console.log(\\\"hellow Promise\\\");\\n});\\nconsole.log(promise);\\n```\\n\\n![image-20230112104207892.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3aa98f90a22c48169d3188452127841f~tplv-k3u1fbpfcp-watermark.image?)\\n\\n那我们来看看打印结果，能分析出什么结果\\n\\n-   hellow promise 在控制台被输出了，那是不是说我们传入的回调函数被立即执行了，那说明传入的是一个执行器\\n\\n那再改进一下我们的CustomPromise\\n\\n```javascript\\nclass CustomPromise {\\n  constructor(executor) {\\n      executor()\\n  }\\n  catch() { }\\n  then() { }\\n  finally() { }\\n}\\nconst customPromise = new CustomPromise((resolve, reject) => {\\n  console.log('hellow Promise')\\n})\\nconsole.log(customPromise)\\n```\\n\\n## Promise基本原理与基本特征\\n\\n**那我们来看看我们所熟知的`Promise`的基本原理**\\n\\n-   首先我们在调用Promise时，会返回一个Promise对象。\\n-   构建Promise对象时，需要传入一个executor函数，Promise的主要业务流程都在executor函数中执行。\\n-   如果运行在excutor函数中的业务执行成功了，会调用resolve函数；如果执行失败了，则调用reject函数。\\n-   Promise的状态不可逆，同时调用resolve函数和reject函数，默认会采取第一次调用的结果。\\n\\n**结合Promise/A+规范，我们还可以分析出哪些基本特征**\\n\\nPromise/A+的规范比较多，在这列出一下核心的规范。[Promise/A+规范](https://link.juejin.cn/?target=https%3A%2F%2Fpromisesaplus.com%2F)\\n\\n-   promise有三个状态：pending，fulfilled，rejected，默认状态是pending。\\n-   promise有一个value保存成功状态的值，有一个reason保存失败状态的值，可以是undefined/thenable/promise。\\n-   promise只能从pending到rejected, 或者从pending到fulfilled，状态一旦确认，就不会再改变。\\n-   promise 必须有一个then方法，then接收两个参数，分别是promise成功的回调onFulfilled, 和promise失败的回调onRejected。\\n-   如果then中抛出了异常，那么就会把这个异常作为参数，传递给下一个then的失败的回调onRejected。\\n\\n那`CustomPromise`，还实现不了基本原理的3，4两条，那我们来根据基本原理与Promise/A+分析下，还缺少什么\\n\\n-   promise有三个状态：pending，fulfilled，rejected。\\n-   executor执行器调用reject与resolve两个方法\\n-   还需要有保存成功或失败两个值的变量\\n-   then接收两个参数，分别是成功的回调onFulfilled,失败的回调onRejected\\n\\n那再来改进下`CustomPromise`\\n\\n```javascript\\n// 定义三个常量表示状态\\nconst PENDING = 'pending';\\nconst FULFILLED = 'fulfilled';\\nconst REJECTED = 'rejected';\\n​\\nclass CustomPromise {\\n  constructor(executor) {\\n    executor(this.resolve, this.reject);\\n  }\\n  // resolve和reject为什么要用箭头函数？\\n  // 如果直接调用的话，普通函数this指向的是window或者undefined\\n  // 用箭头函数就可以让this指向当前实例对象\\n  resolve = (value) => {\\n    this.value = value;\\n  };\\n  reject = (value) => {\\n    this.reason = value;\\n  };\\n  // 成功之后的值\\n  value = undefined;\\n  // 失败之后的值\\n  reason = undefined;\\n​\\n  then(onFulfilled,onRejected) {\\n  }\\n  catch() {\\n  }\\n  finally() {}\\n}\\n```\\n\\n那我们根据Promise基本原理看看它原生Promise的效果\\n\\n```javascript\\nnew Promise(function (resolve, reject) {\\n  resolve(\\\"成功\\\");\\n  reject(\\\"失败\\\");\\n}).then(\\n  (value) => {\\n    console.log(value); // 结果为‘成功’\\n  },\\n  (err) => {\\n    console.log(err);\\n  }\\n);\\n​\\nnew Promise(function (resolve, reject) {\\n  reject(\\\"失败\\\");\\n  resolve(\\\"成功\\\");\\n}).then(\\n  (value) => {\\n    console.log(value);\\n  },\\n  (err) => {\\n    console.log(err); // 结果为‘失败’\\n  }\\n);\\n```\\n\\n可以看出与基本原理一样的效果，那我们分析下如何实现这种效果\\n\\n-   需要控制promise状态\\n-   在then方法里要调用成功或失败的回调函数\\n\\n```javascript\\nconst PENDING = \\\"pending\\\";\\nconst FULFILLED = \\\"fulfilled\\\";\\nconst REJECTED = \\\"rejected\\\";\\n​\\nclass CustomPromise {\\n  constructor(executor) {\\n    executor(this.resolve, this.reject);\\n  }\\n  // resolve和reject为什么要用箭头函数？\\n  // 如果直接调用的话，普通函数this指向的是window或者undefined\\n  // 用箭头函数就可以让this指向当前实例对象\\n  resolve = (value) => {\\n    // promise只能从pending到rejected, 或者从pending到fulfilled\\n    if (this.status == PENDING) {\\n      this.status = FULFILLED;\\n      this.value = value;\\n    }\\n  };\\n  reject = (err) => {\\n    // promise只能从pending到rejected, 或者从pending到fulfilled\\n    if (this.status == PENDING) {\\n      this.status = REJECTED;\\n      this.reason = err;\\n    }\\n  };\\n  status = PENDING;\\n  // 成功之后的值\\n  value = undefined;\\n  // 失败之后的值\\n  reason = undefined;\\n​\\n  then(onFulfilled, onRejected) {\\n    // 需要判断状态，根据状态选择处理回调函数\\n    if (this.status == FULFILLED) {\\n      onFulfilled(this.value);\\n    } else if (this.status == REJECTED) {\\n      onRejected(this.reason);\\n    }\\n  }\\n  catch() {\\n  }\\n  finally() {}\\n}\\n```\\n\\n来测试下`CustomPromise`\\n\\n```javascript\\nnew CustomPromise(function (resolve, reject) {\\n  resolve(\\\"成功\\\");\\n  reject(\\\"失败\\\");\\n}).then(\\n  (value) => {\\n    console.log(value);// 结果为‘成功’\\n  },\\n  (err) => {\\n    console.log(err);\\n  }\\n);\\n​\\nnew CustomPromise(function (resolve, reject) {\\n  reject(\\\"失败\\\");\\n  resolve(\\\"成功\\\");\\n}).then(\\n  (value) => {\\n    console.log(value);\\n  },\\n  (err) => {\\n    console.log(err);// 结果为‘失败’\\n  }\\n);\\n​\\n```\\n\\n## Promise.then链式调用\\n\\n我们都知到Primose.then是可以链式调用的，那我们先看看原生效果\\n\\n```javascript\\nconst promise = new Promise((resolve, reject) => {\\n  resolve(\\\"start\\\");\\n});\\npromise\\n  .then((res) => {\\n    console.log(res);\\n    return new Promise((resolve, reject) => {\\n     setTimeout(() => {\\n        resolve(\\\"hellow\\\");\\n     },3000)\\n    });\\n  })\\n  .then((res) => {\\n    console.log(res);\\n    return \\\"promise\\\";\\n  })\\n  .then((res) => {\\n    console.log(res);\\n  });\\n```\\n\\n输出结果\\n\\n```\\nstart\\nhellow\\npromise\\n```\\n\\n那我们来分析实现一下\\n\\n-   首先.then 是需要返回一个Promise\\n-   下一个.then 需要拿到上一个.then的返回值\\n-   有异步操作的话，后一个回调函数，会等待该`Promise`对象的状态发生变化，在被调用\\n-   有异步操作的话，那就是说有任务队列，需要有收集回调函数的队列\\n\\n```javascript\\nconst PENDING = \\\"pending\\\";\\nconst FULFILLED = \\\"fulfilled\\\";\\nconst REJECTED = \\\"rejected\\\";\\n​\\nclass CustomPromise {\\n  constructor(executor) {\\n    executor(this.resolve, this.reject);\\n  }\\n  // resolve和reject为什么要用箭头函数？\\n  // 如果直接调用的话，普通函数this指向的是window或者undefined\\n  // 用箭头函数就可以让this指向当前实例对象\\n  resolve = (value) => {\\n    // promise只能从pending到rejected, 或者从pending到fulfilled\\n    if (this.status == PENDING) {\\n      this.status = FULFILLED;\\n      this.value = value;\\n​\\n      // resolve里面将所有成功的回调拿出来执行\\n      if (this.onResolvedCallbacks.length) {\\n        this.onResolvedCallbacks.forEach((fn) => fn());\\n      }\\n    }\\n  };\\n  reject = (err) => {\\n    // promise只能从pending到rejected, 或者从pending到fulfilled\\n    if (this.status == PENDING) {\\n      this.status = REJECTED;\\n      this.reason = err;\\n      // reject里面将所有失败的回调拿出来执行\\n      if (this.onFulfilledCallbacks.length) {\\n        this.onFulfilledCallbacks.forEach((fn) => fn());\\n      }\\n    }\\n  };\\n  // 存储成功回调函数\\n  onResolvedCallbacks = [];\\n  // 存储失败回调函数\\n  onFulfilledCallbacks = [];\\n​\\n  status = PENDING;\\n  // 成功之后的值\\n  value = undefined;\\n  // 失败之后的值\\n  reason = undefined;\\n​\\n  then(onFulfilled, onRejected) {\\n    // 如果不传，就使用默认函数,确保是函数类型\\n    onFulfilled =\\n      typeof onFulfilled === \\\"function\\\" ? onFulfilled : (value) => value;\\n    onRejected =\\n      typeof onRejected === \\\"function\\\"\\n        ? onRejected\\n        : (reason) => {\\n            throw reason;\\n          };\\n​\\n    const thenCustomPromise = new CustomPromise((resolve, reject) => {\\n      const resolveCustomPromise = (callBack, value) => {\\n        try {\\n          const x = callBack(value);\\n          // 如果相等了，说明return的是自己，抛出类型错误并返回\\n          if (resolveCustomPromise === x) {\\n            return reject(new TypeError(\\\"类型错误\\\"));\\n          }\\n          // 判断x是不是 CustomPromise 实例对象\\n          if (x instanceof CustomPromise) {\\n            // 执行 x，调用 then 方法，目的是将其状态变为 fulfilled 或者 rejected\\n            // x.then(value => resolve(value), error => reject(reason))\\n            // 简化之后\\n            x.then(resolve, reject);\\n          } else {\\n            // 普通值\\n            resolve(x);\\n          }\\n        } catch (error) {\\n          reject(error);\\n        }\\n      };\\n      // 需要判断状态，根据状态选择处理回调函数\\n      if (this.status == FULFILLED) {\\n        resolveCustomPromise(onFulfilled, this.value);\\n      } else if (this.status == REJECTED) {\\n        resolveCustomPromise(onRejected, this.reason);\\n      } else if (this.status == PENDING) {\\n        // 当状态为pending时,把then回调push进resolve/reject执行队列,等待执行\\n        this.onResolvedCallbacks.push(() =>\\n          resolveCustomPromise(onFulfilled, this.value)\\n        );\\n        this.onFulfilledCallbacks.push(() =>\\n          resolveCustomPromise(onRejected, this.reason)\\n        );\\n      }\\n    });\\n    return thenCustomPromise;\\n  }\\n  catch() {}\\n  finally() {}\\n}\\n​\\n```\\n\\n来验证下.then的链式调用\\n\\n```javascript\\nconst promise = new CustomPromise((resolve, reject) => {\\n  resolve(\\\"start\\\");\\n});\\npromise\\n  .then((res) => {\\n    console.log(res);\\n    return new CustomPromise((resolve, reject) => {\\n      setTimeout(() => {\\n        resolve(\\\"hellow\\\");\\n      }, 1000);\\n    });\\n  })\\n  .then((res) => {\\n    console.log(res);\\n    return \\\"promise\\\";\\n  })\\n  .then((res) => {\\n    console.log(res);\\n  });\\n// 输出结果 start->hellow->promise\\n```\\n\\n## Promise.prototype.catch()\\n\\n**是 .then(null, rejection) 或是 .then(undefined, rejection)的别名，用于指定发生错误时的回调函数**\\n\\n看下原生promise效果\\n\\n```javascript\\nconst promise = new Promise((resolve, reject) => {\\n  resolve(\\\"start\\\");\\n});\\npromise\\n  .then((res) => {\\n    console.log(res);\\n    return new Promise((resolve, reject) => {\\n      reject(\\\"hellow\\\");\\n    });\\n  })\\n  .catch(err => {console.log(err); return 'promise'})\\n  .then(res => console.log(res))\\n```\\n\\n输出结果\\n\\n```\\nstart\\nhellow\\npromise\\n```\\n\\n根据上述原生catch我们来分析下结果\\n\\n-   执行.then的onRejected回调函数\\n-   并且可以继续链式调用\\n\\n```javascript\\ncatch(onFulfilled) {\\n   return this.then(null, onFulfilled)\\n}\\n```\\n\\n那我们来验证下\\n\\n```javascript\\nconst promise = new CustomPromise((resolve, reject) => {\\n  resolve(\\\"start\\\");\\n});\\npromise\\n  .then((res) => {\\n    console.log(res);\\n    return new CustomPromise((resolve, reject) => {\\n      reject(\\\"hellow\\\");\\n    });\\n  })\\n  .catch((err) => {\\n    console.log(err);\\n    return \\\"promise\\\";\\n  })\\n  .then((res) => console.log(res));\\n​\\n// 输出结果\\nstart\\nhellow\\npromise\\n```\\n\\n## Promise.resolve()\\n\\n**Promise.resolve(value)返回一个解析过的Promise对象，用法有一个value参数**\\n\\n-   如果参数是 Promise 实例，那么`Promise.resolve`将不做任何修改、原封不动地返回这个实例。\\n\\n    -   ```javascript\\n        const promise = new Promise((resolve, reject) => {\\n          resolve(\\\"start\\\");\\n        });\\n        ​\\n        const resolvePromise = Promise.resolve(promise);\\n        resolvePromise.then((res) => console.log(res)); \\n        // start\\n        ```\\n\\n-   如果参数是 具有`then`方法的对象`Promise.resolve()`方法会将这个对象转为 Promise 对象，然后就立即执行`thenable`对象的`then()`方法\\n\\n    -   ```javascript\\n        let thenable = {\\n          then: function(resolve, reject) {\\n            resolve('promise');\\n          }\\n        };\\n        ​\\n        let p1 = Promise.resolve(thenable);\\n        p1.then(function (res) {\\n          console.log(res);  // promise\\n        });\\n        ```\\n\\n-   如果参数是一个原始值，或者是一个不具有`then()`方法的对象，则`Promise.resolve()`方法返回一个新的 Promise 对象，状态为`resolved`\\n\\n    -   ```javascript\\n        const p1 = Promise.resolve('promise');\\n        ​\\n        p1.then(function (res) {\\n          console.log(res)\\n        });\\n        // promise\\n        ```\\n\\n-   `Promise.resolve()`方法允许调用时不带参数，直接返回一个`resolved`状态的 Promise 对象\\n\\n    -   ```javascript\\n        const p = Promise.resolve();\\n        ​\\n        p.then(function () {\\n          // ...\\n        });\\n        ```\\n\\n> 参考资料：[ECMAScript 入门](<https://es6.ruanyifeng.com/#docs/promise#Promise-resolve>\\n\\n来`CustomPromise`添加静态resolve方法\\n\\n```javascript\\n//静态的resolve方法\\n  static resolve(value) {\\n    if (value instanceof CustomPromise) return value;\\n    return new CustomPromise((resolve) => resolve(value));\\n  }\\n```\\n\\n## Promise.reject()\\n\\n**Promise.reject(reason)** 返回一个Promise实例，并且携带reason\\n\\n```javascript\\nconst promise = Promise.reject(\\\"rejected message\\\")\\n// 相当于\\n// const promise2 = new Promsie((resolve, reject) => {\\n//   reject(\\\"rejected message\\\")\\n// })\\n```\\n\\n根据上述例子我们来分析下结果\\n\\n-   可以看出无论reason传入什么内容，都是经过reject()方法，那是不是可以理解为就是捕获错误信息\\n\\n来`CustomPromise`添加静态reject方法\\n\\n```javascript\\n//静态的reject方法\\nstatic reject(reason) {\\n   return new CustomPromise((resolve, reject) => reject(reason));\\n}\\n```\\n\\n## Promise.prototype.finally()\\n\\n**finally()不接收参数，并且在.then或.catch回调函数执行完以后，再执行finally中的方法**\\n\\n看下原生promise效果\\n\\n```javascript\\nconst promise = new Promise((resolve, reject) => {\\n  resolve(\\\"start\\\");\\n});\\npromise\\n  .then((res) => {\\n    console.log(res);\\n    return new Promise((resolve, reject) => {\\n      resolve(\\\"hellow\\\");\\n    });\\n  })\\n  .then((res) => {\\n    console.log(res);\\n    return new Promise((resolve, reject) => {\\n      resolve(\\\"promise\\\");\\n    });\\n  })\\n  .finally(() => {\\n    console.log(\\\"finally\\\");\\n    return \\\"is finally\\\";\\n  })\\n  .then((res) => console.log(res));\\n​\\n```\\n\\n输出结果\\n\\n```\\nstart\\nhellow\\nfinally\\npromise\\n```\\n\\n根据上述原生finally我们来分析下结果\\n\\n-   finally方法和then以及catch一样，都可以返回一个新的Promise\\n-   finally并不会影响之前返回的Promise对象\\n-   可以继续链式调用并且获取之前Promise的值\\n\\n来`CustomPromise`添加静态finally方法\\n\\n```javascript\\nfinally(callback) {\\n    return this.then(\\n      (value) => CustomPromise.resolve(callback()).then(() => value),\\n      (reason) => CustomPromise.resolve(callback()).then(() => reason)\\n    );\\n}\\n```\\n\\n那我们来验证下\\n\\n```javascript\\nconst promise = new CustomPromise((resolve, reject) => {\\n  resolve(\\\"start\\\");\\n});\\npromise\\n  .then((res) => {\\n    console.log(res);\\n    return new CustomPromise((resolve, reject) => {\\n      resolve(\\\"hellow\\\");\\n    });\\n  })\\n  .then((res) => {\\n    console.log(res);\\n    return new CustomPromise((resolve, reject) => {\\n      resolve(\\\"promise\\\");\\n    });\\n  })\\n  .finally(() => {\\n    console.log(\\\"finally\\\");\\n    return \\\"is finally\\\";\\n  })\\n  .then((res) => console.log(res));\\n​\\n// 输出结果\\nstart\\nhellow\\nfinally\\npromise\\n```\\n\\n## Promise.all()\\n\\n**Promise.all() 方法接收一个 promise 的 iterable 类型(Array，Map，Set 都属于 ES6 的 iterable 类型)并返回一个新的Promise实例**\\n\\n看下原生`Promise.all()`效果\\n\\n```javascript\\nlet p1 = new Promise((resolve, reject) => {\\n  resolve(\\\"start\\\");\\n}).then((res) => res);\\nlet p2 = new Promise((resolve, reject) => {\\n  resolve(\\\"hellow\\\");\\n}).then((res) => res);\\nlet p3 = new Promise((resolve, reject) => {\\n  resolve(\\\"promise\\\");\\n}).then((res) => res);\\n​\\nPromise.all([p1, p2, p3])\\n  .then((res) => console.log(\\\"success:\\\", res))\\n  .catch((err) => console.log(\\\"error:\\\", err));\\n// 输出结果 success:['start', 'hellow', 'promise']\\n```\\n\\n```javascript\\nlet p1 = new Promise((resolve, reject) => {\\n  resolve(\\\"start\\\");\\n}).then((res) => res);\\nlet p2 = new Promise((resolve, reject) => {\\n  reject(\\\"报错了\\\");\\n}).then((res) => res);\\nlet p3 = new Promise((resolve, reject) => {\\n  reject(\\\"报错了2\\\");\\n}).then((res) => res);\\n​\\nPromise.all([p1, p2, p3])\\n  .then((res) => console.log(\\\"success:\\\", res))\\n  .catch((err) => console.log(\\\"error:\\\", err));\\n//输出结果 error:报错了\\n```\\n\\n那我们来根据输出结果分析下\\n\\n-   成功的时候返回的是一个结果数组\\n-   失败的时候则返回最先被reject失败状态的值\\n\\n来`CustomPromise`添加静态all()方法\\n\\n```javascript\\n  //静态的all方法\\n  static all(values){\\n    let result = [];\\n    let index = 0;\\n    return new CustomPromise((resolve,reject) => {\\n      function addPromise(key, value) {\\n        result[key] = value\\n        index++\\n        if (index === values.length) {\\n          resolve(result)\\n        }\\n      }\\n      \\n      for(let i = 0; i < values.length; i++){\\n        let item = values[i];\\n        if(item instanceof CustomPromise){\\n          // 参数为Promise\\n          item.then(value => addPromise(i,value), error => reject(reason))\\n        }else{\\n          // 参数为普通值\\n          addPromise(i,item)\\n        }\\n      }\\n    })\\n  }\\n```\\n\\n那我们来验证下\\n\\n```javascript\\nlet p1 = new CustomPromise((resolve, reject) => {\\n  resolve(\\\"start\\\");\\n});\\nlet p2 = new CustomPromise((resolve, reject) => {\\n  resolve(\\\"hellow\\\");\\n});\\nlet p3 = new CustomPromise((resolve, reject) => {\\n  resolve(\\\"promise\\\");\\n});\\n​\\nCustomPromise.all([p1, p2, p3])\\n  .then((res) => console.log(\\\"success:\\\", res))\\n  .catch((err) => console.log(\\\"error:\\\", err));\\n// 输出结果 success:['start', 'hellow', 'promise']\\n```\\n\\n```javascript\\nlet p1 = new CustomPromise((resolve, reject) => {\\n  resolve(\\\"start\\\");\\n}).then((res) => res);\\nlet p2 = new CustomPromise((resolve, reject) => {\\n  reject(\\\"报错了\\\");\\n}).then((res) => res);\\nlet p3 = new CustomPromise((resolve, reject) => {\\n  reject(\\\"报错了2\\\");\\n}).then((res) => res);\\n​\\nCustomPromise.all([p1, p2, p3])\\n  .then((res) => console.log(\\\"success:\\\", res))\\n  .catch((err) => console.log(\\\"error:\\\", err));\\n//输出结果 error:报错了\\n```\\n\\n## Promise.race()\\n\\n**`Promise.race()`方法返回一个 promise，一旦迭代器中的某个 promise 解决或拒绝，返回的 promise 就会解决或拒绝。**\\n\\n```javascript\\nvar p1 = new Promise(function(resolve, reject) {\\n    setTimeout(resolve, 300, \\\"start\\\");\\n});\\nvar p2 = new Promise(function(resolve, reject) {\\n    setTimeout(resolve, 100, \\\"hellow\\\");\\n});\\n​\\nconst p = Promise.race([p1, p2]).then(function(value) {\\n  console.log(value); // \\\"hellow\\\"\\n});\\n```\\n\\n来分析下那就是有一个实例先改变状态，p的状态就跟着改变\\n\\n来`CustomPromise`添加静态race()方法\\n\\n```javascript\\n//静态race方法\\n  static race(values) {\\n    return new CustomPromise((resolve, reject) => {\\n      for (const p of values) {\\n        p.then(resolve, reject);\\n      }\\n    });\\n  }\\n```\\n\\n那我们来验证下\\n\\n```javascript\\nvar p1 = new CustomPromise(function(resolve, reject) {\\n    setTimeout(resolve, 300, \\\"start\\\");\\n});\\nvar p2 = new CustomPromise(function(resolve, reject) {\\n    setTimeout(resolve, 100, \\\"hellow\\\");\\n});\\n​\\nconst p = CustomPromise.race([p1, p2]).then(function(value) {\\n  console.log(value); // \\\"hellow\\\"\\n});\\n```\\n\\n## Promise.allSettled()\\n\\n**`Promise.allSettled()` 方法**不依赖于彼此成功完成的异步任务，不管每一个操作是成功还是失败，再进行下一步操作。\\n\\n```javascript\\nPromise.allSettled([\\n  Promise.resolve('start'),\\n  Promise.reject(new Error(\\\"error\\\")),\\n  new Promise((resolve) => setTimeout(() => resolve('hellow'), 0)),\\n  'promise',\\n]).then((values) => console.log(values));\\n​\\n// [\\n//   { status: 'fulfilled', value: start },\\n//   { status: 'rejected', reason: Error: error },\\n//   { status: 'fulfilled', value: hellow },\\n//   { status: 'fulfilled', value: promise }\\n// ]\\n```\\n\\n来分析下结果\\n\\n-   status一个字符串，要么是 `\\\"fulfilled\\\"`，要么是 `\\\"rejected\\\"`，表示 promise 的最终状态。\\n-   value当 `status` 为 `\\\"fulfilled\\\"`，在 promise 解决时才有 value\\n-   reason当 `status` 为 `\\\"rejected\\\"`，在 promsie 拒绝时才有 reason\\n\\n来`CustomPromise`添加静态allSettled()方法\\n\\n```javascript\\n//静态allSettled方法\\n  static allSettled(values) {\\n    return new Promise((resolve, reject) => {\\n      let resolveDataList = [],\\n        resolveCount = 0;\\n      const addPromise = (status, value, i) => {\\n        resolveDataList[i] = {\\n          status,\\n          value,\\n        };\\n        resolveCount++;\\n        if (resolveCount === values.length) {\\n          resolve(resolveDataList);\\n        }\\n      };\\n      values.forEach((value, i) => {\\n        if (value instanceof CustomPromise) {\\n          value.then(\\n            (res) => {\\n              addPromise(\\\"fulfilled\\\", res, i);\\n            },\\n            (err) => {\\n              addPromise(\\\"rejected\\\", err, i);\\n            }\\n          );\\n        } else {\\n          addPromise(\\\"fulfilled\\\", value, i);\\n        }\\n      });\\n    });\\n  }\\n```\\n\\n来验证下\\n\\n```javascript\\nCustomPromise.allSettled([\\n  CustomPromise.resolve('start'),\\n  CustomPromise.reject(new Error(\\\"error\\\")),\\n  new CustomPromise((resolve) => setTimeout(() => resolve('hellow'), 0)),\\n  'promise',\\n]).then((values) => console.log(values));\\n​\\n// [\\n//   { status: 'fulfilled', value: start },\\n//   { status: 'rejected', reason: Error: error },\\n//   { status: 'fulfilled', value: hellow },\\n//   { status: 'fulfilled', value: promise }\\n// ]\\n```\\n\\n## Promise.any()\\n\\n**Promise.any()`接收一个由`Promise`所组成的可迭代对象，返回一个新的`promise**\\n\\n```javascript\\nconst p1 = new Promise((resolve, reject) => {\\n  setTimeout(resolve, 100, \\\"start\\\");\\n});\\n​\\nconst p2 = new Promise((resolve, reject) => {\\n  reject(\\\"报错了\\\");\\n});\\n​\\nconst p3 = new Promise((resolve, reject) => {\\n  setTimeout(resolve, 500, \\\"promise\\\");\\n});\\n​\\nPromise.any([p1, p2, p3]).then((value) => {\\n  console.log(value);\\n  // start\\n})\\n```\\n\\n```javascript\\nconst p1 = new Promise((resolve, reject) => {\\n  setTimeout(reject, 100, \\\"start\\\");\\n});\\n​\\nconst p2 = new Promise((resolve, reject) => {\\n  reject(\\\"报错了\\\");\\n});\\n​\\nconst p3 = new Promise((resolve, reject) => {\\n  setTimeout(reject, 500, \\\"promise\\\");\\n});\\n​\\nPromise.any([p1, p2, p3])\\n  .then((value) => {\\n    console.log(\\\"value:\\\", value);\\n  })\\n  .catch((err) => {\\n    console.log(\\\"err:\\\", err); //err: AggregateError: All promises were rejected\\n  });\\n​\\n```\\n\\n那我们来分析下\\n\\n-   与all()不同，只要有一个 `promise` 成功，会返回首个成功的 `promise` 的值，方法提前结束\\n-   如果所有Promise都失败，则报错All promises were\\n\\n来`CustomPromise`添加静态any()方法\\n\\n```javascript\\n//静态any方法\\n  static any(values) {\\n    return new CustomPromise((resolve, reject) => {\\n      let rejectCount = 0;\\n      values.forEach((value) => {\\n        value.then(\\n          (val) => resolve(val),\\n          (err) => {\\n            rejectCount++;\\n            if (rejectCount === value.length) {\\n              reject(\\\"All promises were rejected\\\");\\n            }\\n          }\\n        );\\n      });\\n    });\\n  }\\n```\\n\\n我们来验证下\\n\\n```javascript\\nconst p1 = new CustomPromise((resolve, reject) => {\\n  setTimeout(resolve, 100, \\\"start\\\");\\n});\\n​\\nconst p2 = new CustomPromise((resolve, reject) => {\\n  reject(\\\"报错了\\\");\\n});\\n​\\nconst p3 = new CustomPromise((resolve, reject) => {\\n  setTimeout(resolve, 500, \\\"promise\\\");\\n});\\n​\\nCustomPromise.any([p1, p2, p3])\\n  .then((value) => {\\n    console.log(\\\"value:\\\", value); //value: start\\n  })\\n  .catch((err) => {\\n    console.log(\\\"err:\\\", err);\\n  });\\n```\\n\\n```javascript\\nconst p1 = new CustomPromise((resolve, reject) => {\\n  setTimeout(reject, 100, \\\"start\\\");\\n});\\n​\\nconst p2 = new CustomPromise((resolve, reject) => {\\n  reject(\\\"报错了\\\");\\n});\\n​\\nconst p3 = new CustomPromise((resolve, reject) => {\\n  setTimeout(reject, 500, \\\"promise\\\");\\n});\\n​\\nCustomPromise.any([p1, p2, p3])\\n  .then((value) => {\\n    console.log(\\\"value:\\\", value);\\n  })\\n  .catch((err) => {\\n    console.log(\\\"err:\\\", err); //err: All promises were rejected\\n  });\\n```\\n\\n## 完整代码\\n\\n```javascript\\nconst PENDING = \\\"pending\\\";\\nconst FULFILLED = \\\"fulfilled\\\";\\nconst REJECTED = \\\"rejected\\\";\\n​\\nclass CustomPromise {\\n  constructor(executor) {\\n    try {\\n      executor(this.resolve, this.reject);\\n    } catch (error) {\\n      // 如果有错误，就直接执行 reject\\n      this.reject(error);\\n    }\\n  }\\n  // resolve和reject为什么要用箭头函数？\\n  // 如果直接调用的话，普通函数this指向的是window或者undefined\\n  // 用箭头函数就可以让this指向当前实例对象\\n  resolve = (value) => {\\n    // promise只能从pending到rejected, 或者从pending到fulfilled\\n    if (this.status == PENDING) {\\n      this.status = FULFILLED;\\n      this.value = value;\\n​\\n      // resolve里面将所有成功的回调拿出来执行\\n      if (this.onResolvedCallbacks.length) {\\n        this.onResolvedCallbacks.forEach((fn) => fn());\\n      }\\n    }\\n  };\\n  reject = (err) => {\\n    // promise只能从pending到rejected, 或者从pending到fulfilled\\n    if (this.status == PENDING) {\\n      this.status = REJECTED;\\n      this.reason = err;\\n      // reject里面将所有失败的回调拿出来执行\\n      if (this.onFulfilledCallbacks.length) {\\n        this.onFulfilledCallbacks.forEach((fn) => fn());\\n      }\\n    }\\n  };\\n  // 存储成功回调函数\\n  onResolvedCallbacks = [];\\n  // 存储失败回调函数\\n  onFulfilledCallbacks = [];\\n​\\n  status = PENDING;\\n  // 成功之后的值\\n  value = undefined;\\n  // 失败之后的值\\n  reason = undefined;\\n​\\n  then(onFulfilled, onRejected) {\\n    // 如果不传，就使用默认函数,确保是函数类型\\n    onFulfilled =\\n      typeof onFulfilled === \\\"function\\\" ? onFulfilled : (value) => value;\\n    onRejected =\\n      typeof onRejected === \\\"function\\\"\\n        ? onRejected\\n        : (reason) => {\\n            throw reason;\\n          };\\n​\\n    const thenCustomPromise = new CustomPromise((resolve, reject) => {\\n      const resolveCustomPromise = (callBack, value) => {\\n        try {\\n          const x = callBack(value);\\n          // 如果相等了，说明return的是自己，抛出类型错误并返回\\n          if (resolveCustomPromise === x) {\\n            return reject(new TypeError(\\\"类型错误\\\"));\\n          }\\n          // 判断x是不是 CustomPromise 实例对象\\n          if (x instanceof CustomPromise) {\\n            // 执行 x，调用 then 方法，目的是将其状态变为 fulfilled 或者 rejected\\n            // x.then(value => resolve(value), error => reject(reason))\\n            // 简化之后\\n            x.then(resolve, reject);\\n          } else {\\n            // 普通值\\n            resolve(x);\\n          }\\n        } catch (error) {\\n          reject(error);\\n        }\\n      };\\n      // 需要判断状态，根据状态选择处理回调函数\\n      if (this.status == FULFILLED) {\\n        resolveCustomPromise(onFulfilled, this.value);\\n      } else if (this.status == REJECTED) {\\n        resolveCustomPromise(onRejected, this.reason);\\n      } else if (this.status == PENDING) {\\n        // 当状态为pending时,把then回调push进resolve/reject执行队列,等待执行\\n        this.onResolvedCallbacks.push(() =>\\n          resolveCustomPromise(onFulfilled, this.value)\\n        );\\n        this.onFulfilledCallbacks.push(() =>\\n          resolveCustomPromise(onRejected, this.reason)\\n        );\\n      }\\n    });\\n    return thenCustomPromise;\\n  }\\n  catch(onFulfilled) {\\n    return this.then(null, onFulfilled);\\n  }\\n  finally(callback) {\\n    return this.then(\\n      (value) => CustomPromise.resolve(callback()).then(() => value),\\n      (reason) => CustomPromise.resolve(callback()).then(() => reason)\\n    );\\n  }\\n  //静态的resolve方法\\n  static resolve(value) {\\n    if (value instanceof CustomPromise) return value;\\n    return new CustomPromise((resolve) => resolve(value));\\n  }\\n  //静态的reject方法\\n  static reject(reason) {\\n    return new CustomPromise((resolve, reject) => reject(reason));\\n  }\\n  //静态的all方法\\n  static all(values) {\\n    // 用来记录Promise成功的次数\\n    let resolveCount = 0,\\n      // 用来保存Promise成功的结果\\n      resolveDataList = [];\\n    return new CustomPromise((resolve, reject) => {\\n      function addPromise(key, value) {\\n        resolveDataList[key] = value;\\n        resolveCount++;\\n        if (resolveCount === values.length) {\\n          resolve(resolveDataList);\\n        }\\n      }\\n​\\n      for (let i = 0; i < values.length; i++) {\\n        let item = values[i];\\n        if (item instanceof CustomPromise) {\\n          // 参数为Promise\\n          item.then(\\n            (value) => addPromise(i, value),\\n            (error) => reject(error)\\n          );\\n        } else {\\n          // 参数为普通值\\n          addPromise(i, item);\\n        }\\n      }\\n    });\\n  }\\n  //静态race方法\\n  static race(values) {\\n    return new CustomPromise((resolve, reject) => {\\n      for (const p of values) {\\n        p.then(resolve, reject);\\n      }\\n    });\\n  }\\n  //静态allSettled方法\\n  static allSettled(values) {\\n    return new Promise((resolve, reject) => {\\n      let resolveDataList = [],\\n        resolveCount = 0;\\n      const addPromise = (status, value, i) => {\\n        resolveDataList[i] = {\\n          status,\\n          value,\\n        };\\n        resolveCount++;\\n        if (resolveCount === values.length) {\\n          resolve(resolveDataList);\\n        }\\n      };\\n      values.forEach((value, i) => {\\n        if (value instanceof CustomPromise) {\\n          value.then(\\n            (res) => {\\n              addPromise(\\\"fulfilled\\\", res, i);\\n            },\\n            (err) => {\\n              addPromise(\\\"rejected\\\", err, i);\\n            }\\n          );\\n        } else {\\n          addPromise(\\\"fulfilled\\\", value, i);\\n        }\\n      });\\n    });\\n  }\\n  //静态any方法\\n  static any(values) {\\n    return new CustomPromise((resolve, reject) => {\\n      let rejectCount = 0;\\n      values.forEach((value) => {\\n        value.then(\\n          (val) => resolve(val),\\n          (err) => {\\n            rejectCount++;\\n            if (rejectCount === value.length) {\\n              reject(\\\"All promises were rejected\\\");\\n            }\\n          }\\n        );\\n      });\\n    });\\n  }\\n}\\n```\\n\\n## 结语\\n\\n关于Promise的实现就到这里了，希望能跟大家一起进步⛽️⛽️⛽️\\n\\n如果写的有问题，欢迎大家指出问题，一起讨论，让我再打磨打磨\\n\\n最后呢，**希望大家支持一下**，**长文不易**，**记得给点个赞**👍👍👍\\n\\n**搞了一个前端学习（摸鱼）交流群，想加入的去[沸点](https://juejin.cn/user/1583757900135464/pins)**\\n\\n![pexels-king-siberia-2277978.jpg](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/91363bb09e744d41b4bc164bc529db38~tplv-k3u1fbpfcp-watermark.image?)",
        "tags": [
            "前端",
            "JavaScript",
            "面试"
        ]
    },
    {
        "article_id": "7158730050718662687",
        "cover_image": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c2701e6ddc62422983e9693c8ba47c6f~tplv-k3u1fbpfcp-watermark.image?",
        "title": "20个常见的前端算法题，你全都会吗？",
        "brief": "现在面试中，算法出现频率越来越高了，大厂基本必考，不卷不行啊 今天给大家带来的是20个常见的前端算法题，快来看看，你是不是全都掌握了呢？",
        "user_name": "海阔_天空",
        "view_count": 16276,
        "collect_count": 904,
        "comment_count": 56,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/855a56c7c01cfae34279302336d4cf15~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: channing-cyan\\nhighlight: atom-one-light\\n---\\n\\n现在面试中，算法出现的频率越来越高了，大厂基本必考\\n\\n今天给大家带来20个常见的前端算法题，重要的地方已添加注释，如有不正确的地方，欢迎多多指正💕\\n\\n### 1、两数之和\\n\\n**题目**： 给定一个数组 nums 和一个目标值 target，在该数组中找出和为目标值的两个数\\n\\n**输入**： nums: [8, 2, 6, 5, 4, 1, 3] ； target:7\\n\\n**输出**： [2, 5]\\n\\n```\\n// 时间复杂度O(n)、 空间复杂度O(n)\\nfunction twoNumAdd(arr, target) {\\n  if (Array.isArray(arr)) {\\n    // 使用map将遍历过的数字存起来，空间换时间\\n    let map = {};\\n    for (let i = 0; i < arr.length; i++) {\\n      // 从map中查找是否有key 等于 target-nums[i]，如果有，则条件成立，返回结果\\n      if (map[target - arr[i]] !== undefined) {\\n        return [target - arr[i], arr[i]];\\n      } else {\\n        // 条件不成立，将该值存起来\\n        map[arr[i]] = i;\\n      }\\n    }\\n  }\\n  return [];\\n}\\n```\\n\\n### 2、三数之和\\n\\n**题目**： 给定一个数组nums，判断 nums 中是否存在三个元素`a，b，c`，使得 `a + b + c = target`，找出所有满足条件且不重复的三元组合\\n\\n**输入**： nums: [5, 2, 1, 1, 3, 4, 6] ；target:8\\n\\n**输出**： [[1, 1, 6], [1, 2, 5], [1, 3, 4]]\\n\\n```\\n// 用`双端指针`的方式，将三数之和转化为两数之和\\nfunction findThree(arr, target) {\\n  // 先将数组从小到大排序\\n  arr.sort((a, b) => a - b))\\n  let result = [];\\n  for (let i = 0; i < arr.length; i++) {\\n    // 跳过重复的arr[i]值, 比如[2, 1, 1],跳过第二个1\\n    if (i && arr[i] === arr[i - 1]) continue;\\n    let left = i + 1;\\n    let right = arr.length - 1;\\n    \\n    // 双端指针left、right\\n    while (left < right) {\\n      let sum = arr[i] + arr[left] + arr[right];\\n      if (sum > target) {\\n        right--;\\n      } else if (sum < target) {\\n        left++;\\n      } else {\\n        // 先取arr[left]，然后left++, 两步合成一步；arr[right--]同样的逻辑\\n        result.push([arr[i], arr[left++], arr[right--]]);\\n        while (arr[left] === arr[left - 1]) {\\n          // 跳过重复的arr[left]值,\\n          left++;\\n        }\\n        while (arr[right] === arr[right + 1]) {\\n          // 跳过重复的arr[right]值\\n          right--;\\n        }\\n      }\\n    }\\n  }\\n  return result;\\n}\\n```\\n\\n### 3、版本号排序\\n\\n**题目**： 输入一组版本号，输出从大到小的排序\\n\\n**输入**： ['2.1.0.1', '0.402.1', '10.2.1', '5.1.2', '1.0.4.5']\\n\\n**输出**： ['10.2.1', '5.1.2', '2.1.0.1', '1.0.4.5', '0.402.1']\\n\\n```\\nfunction versionSort(arr) {\\n  return arr.sort((a, b) => {\\n    let i = 0;\\n    const arr1 = a.split(\\\".\\\");\\n    const arr2 = b.split(\\\".\\\");\\n    while (true) {\\n      // 取出相同位置的数字\\n      const s1 = arr1[i];\\n      const s2 = arr2[i];\\n      i++;\\n      // 若s1 或 s2 不存在，说明相同的位置已比较完成，接下来比较arr1 与 arr2的长度，长的版本号大\\n      if (s1 === undefined || s2 === undefined) {\\n        return arr2.length - arr1.length;\\n      }\\n      if (s1 === s2) continue;\\n      // 比较相同位置的数字大小\\n      return s2 - s1;\\n    }\\n  });\\n}\\n```\\n\\n### 4、第一个不重复的字符\\n\\n**题目**： 输入一个字符串，找到第一个不重复字符的下标\\n\\n**输入**： 'abcabcde'\\n\\n**输出**： 6\\n\\n```\\n// 时间复杂度O(n)、 空间复杂度O(n)\\nfunction findOneStr(str) {\\n  if (!str) return -1;\\n  // 使用map存储每个字符出现的次数\\n  let map = {};\\n  let arr = str.split(\\\"\\\");\\n  arr.forEach(item => {\\n    let val = map[item];\\n    // val为undefined时，表示未存储，map[item] = 1；否则map[item] = val + 1\\n    map[item] = val ? val + 1 : 1;\\n  });\\n  // 再遍历一遍找到出现1次的下标\\n  for (let i = 0; i < arr.length; i++) {\\n    if (map[arr[i]] == 1) {\\n      return i;\\n    }\\n  }\\n  return -1;\\n}\\n```\\n\\n### 5、字符串所有排列组合\\n\\n**题目**： 输入一个字符串，打印出该字符串中，所有字符的排列组合\\n\\n**输入**： 'abc'\\n\\n**输出**： ['abc', 'acb', 'bca', 'bac', 'cab', 'cba']\\n\\n```\\n/**\\n * 利用回溯算法，计算所有字符串的组合\\n * @param {array} list - 字符串列表\\n * @param {array} result - 最终的结果\\n * @param {string} current - 当前的字符串\\n * @param {string} temp - 当前固定的字符\\n*/\\nfunction stringGroup(list = [], result = [], current = \\\"\\\", temp = \\\"\\\") {\\n  current += temp;\\n  if (list.length === 0) {\\n    // 递归的出口，将对应结果添加到list中\\n    return result.push(current);\\n  }\\n  for (let i = 0; i < list.length; i++) {\\n    // 每次递归 固定第一个字符\\n    temp = list.shift();\\n    stringGroup(list, result, current, temp);\\n    // 将删除的temp重新添加到queue尾部，实现将数组反转的效果，如[a,b,c]反转为[c,b,a]\\n    list.push(temp);\\n  }\\n  // 这里去重是解决str中有重复的字母，比如str为'aacd'\\n  return [...new Set(result)];\\n}\\n```\\n### 6、冒泡排序\\n\\n时间复杂度为`O(n²)`，稳定排序算法\\n\\n![bubble.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/27344db14090473b830c647058fad84d~tplv-k3u1fbpfcp-watermark.image?)\\n\\n```\\nfunction bubbleSort(arr) {\\n  let length = arr.length;\\n  // 外层循环用控制 排序进行多少轮\\n  for (let i = 0; i < length; i++) {\\n    // 内层循环用于每一轮的数据比较\\n    // 注意j的长度范围 length - i - 1\\n    for (let j = 0; j < length - i - 1; j++) {\\n      // 相邻元素，大的放到后面\\n      if (arr[j] > arr[j + 1]) {\\n        // 交换位置\\n        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\\n      }\\n    }\\n  }\\n  return arr;\\n}\\n```\\n\\n### 7、选择排序\\n\\n时间复杂度为`O(n²)`，不稳定\\n\\n![selectSort.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f397150299de491aa239b625f1be5a1e~tplv-k3u1fbpfcp-watermark.image?)\\n\\n```\\nfunction selectSort(arr) {\\n  // 定义index存储最小值的下标\\n  let index;\\n  // 外层循环用控制 排序进行多少轮\\n  for (let i = 0; i < arr.length - 1; i++) {\\n    index = i;\\n    // 内层循环用于每一轮的数据比较\\n    // 注意j的起始范围是 i + 1\\n    for (let j = i + 1; j < arr.length; j++) {\\n      // 寻找最小值\\n      if (arr[j] < arr[index]) {\\n        // 保存最小值的下标\\n        index = j;\\n      }\\n    }\\n    // 如果 index 不是目前的头部元素，则交换两者\\n    if (index !== i) {\\n      [arr[i], arr[index]] = [arr[index], arr[i]];\\n    }\\n  }\\n  return arr;\\n}\\n```\\n\\n### 8、插入排序\\n\\n时间复杂度为`O(n²)`，稳定\\n\\n![insert.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c73c966c21d4fb4a7cc50f44293d35e~tplv-k3u1fbpfcp-watermark.image?)\\n\\n```\\nfunction insertSort(arr) {\\n  // 从第 2 个元素开始遍历序列\\n  for (let i = 1; i < arr.length; i++) {\\n    let j = i;\\n    //记录要插入的目标元素\\n    let target = arr[j];\\n    //从 target 所在位置向前遍历，直至找到一个比目标元素小的元素，目标元素插入到该元素之后的位置\\n    while (j > 0 && arr[j - 1] > target) {\\n      //移动前一个元素的位置，将其向后移动一个位置\\n      arr[j] = arr[j - 1];\\n      j--;\\n    }\\n    arr[j] = target;\\n  }\\n  return arr;\\n}\\n```\\n\\n### 9、快速排序\\n\\n时间复杂度为`O(nlogn)`，不稳定\\n\\n![sort.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d3ff2d4edbf4485581c389b391a8c46b~tplv-k3u1fbpfcp-watermark.image?)\\n\\n```\\nfunction quickSort(list) {\\n  // 当list.length <= 1时，退出递归\\n  if (list.length <= 1) return list;\\n  // 找到中间节点\\n  let mid = Math.floor(list.length / 2);\\n  // 以中间节点为基准点，比该节点大的值放到right数组中，否则放到left数组中\\n  let base = list.splice(mid, 1)[0];\\n  let left = [];\\n  let right = [];\\n  list.forEach(item => {\\n    if (item > base) {\\n      right.push(item);\\n    } else {\\n      left.push(item);\\n    }\\n  });\\n  // 重新组合数组\\n  return quickSort(left).concat(base, quickSort(right));\\n}\\n```\\n### 10、归并排序\\n\\n时间复杂度为`O(nlogn)`，稳定\\n\\n![merge.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/105ab2c48c4a41c2ab360d2764c96e65~tplv-k3u1fbpfcp-watermark.image?)\\n\\n```\\nfunction MergeSort(array) {\\n  let len = array.length;\\n\\n  // 当每个子序列中仅有1个元素时返回\\n  if (len <= 1) {\\n    return array;\\n  }\\n  // 将给定的列表分为两半\\n  let num = Math.floor(len / 2);\\n  let left = MergeSort(array.slice(0, num));\\n  let right = MergeSort(array.slice(num, array.length));\\n  return merge(left, right);\\n\\n  function merge(left, right) {\\n    let [l, r] = [0, 0];\\n    let result = [];\\n    // 从 left 和 right 区域中各个取出第一个元素，比较它们的大小\\n    while (l < left.length && r < right.length) {\\n      // 将较小的元素添加到result中，然后从较小元素所在的区域内取出下一个元素，继续进行比较；\\n      if (left[l] < right[r]) {\\n        result.push(left[l]);\\n        l++;\\n      } else {\\n        result.push(right[r]);\\n        r++;\\n      }\\n    }\\n    // 如果 left 或者 right 有一方为空，则直接将另一方的所有元素依次添加到result中\\n    result = result.concat(left.slice(l, left.length));\\n    result = result.concat(right.slice(r, right.length));\\n    return result;\\n  }\\n}\\n```\\n### 11、列表转成树\\n\\n**题目**： 输入一组列表如下，转化成树形结构\\n\\n**输入**： \\n```\\n[\\n  { id: 1, title: \\\"child1\\\", parentId: 0 },\\n  { id: 2, title: \\\"child2\\\", parentId: 0 },\\n  { id: 3, title: \\\"child1_1\\\", parentId: 1 },\\n  { id: 4, title: \\\"child1_2\\\", parentId: 1 },\\n  { id: 5, title: \\\"child2_1\\\", parentId: 2 }\\n]\\n```\\n**输出**：\\n\\n```\\ntree=[\\n  {\\n    \\\"id\\\": 1,\\n    \\\"title\\\": \\\"child1\\\",\\n    \\\"parentId\\\": 0,\\n    \\\"children\\\": [\\n      {\\n        \\\"id\\\": 3,\\n        \\\"title\\\": \\\"child1_1\\\",\\n        \\\"parentId\\\": 1\\n      },\\n      {\\n        \\\"id\\\": 4,\\n        \\\"title\\\": \\\"child1_2\\\",\\n        \\\"parentId\\\": 1\\n      }\\n    ]\\n  },\\n  {\\n    \\\"id\\\": 2,\\n    \\\"title\\\": \\\"child2\\\",\\n    \\\"parentId\\\": 0,\\n    \\\"children\\\": [\\n      {\\n        \\\"id\\\": 5,\\n        \\\"title\\\": \\\"child2_1\\\",\\n        \\\"parentId\\\": 2\\n      }\\n    ]\\n  }\\n]\\n```\\n\\n```\\nfunction listToTree(data) {\\n  // 使用对象重新存储数据, 空间换时间\\n  let map = {};\\n  // treeData存储最后结果\\n  let treeData = [];\\n  // 遍历原始数据data，存到map中，id为key，值为数据\\n  for (let i = 0; i < data.length; i++) {\\n    map[data[i].id] = data[i];\\n  }\\n  // 遍历对象\\n  for (let i in map) {\\n    // 根据 parentId 找到的是父节点\\n    if (map[i].parentId) {\\n      if (!map[map[i].parentId].children) {\\n        map[map[i].parentId].children = [];\\n      }\\n      // 将子节点放到父节点的 children中\\n      map[map[i].parentId].children.push(map[i]);\\n    } else {\\n      // parentId 找不到对应值，说明是根结点，直接插到根数组中\\n      treeData.push(map[i]);\\n    }\\n  }\\n  return treeData;\\n}\\n```\\n\\n### 12、深度优先遍历\\n\\n**题目**： 对树进行遍历，从第一个节点开始，遍历其子节点，直到它的所有子节点都被遍历完毕，然后再遍历它的兄弟节点\\n\\n**输入**： 上文第11题生成的tree\\n\\n**输出**： [1, 3, 4, 2, 5]\\n\\n```\\n// 递归版本\\nfunction deepTree(tree, arr = []) {\\n  if (!tree || !tree.length) return arr;\\n  tree.forEach(data => {\\n    arr.push(data.id);\\n    // 遍历子树\\n    data.children && deepTree(data.children, arr);\\n  });\\n  return arr;\\n}\\n\\n// 非递归版本\\nfunction deepTree(tree) {\\n  if (!tree || !tree.length) return;\\n  let arr = [];\\n  let stack = [];\\n  //先将第一层节点放入栈\\n  for (let i = 0, len = tree.length; i < len; i++) {\\n    stack.push(tree[i]);\\n  }\\n  let node;\\n  while (stack.length) {\\n    // 获取当前第一个节点\\n    node = stack.shift();\\n    arr.push(node.id);\\n    //如果该节点有子节点，继续添加进入栈顶\\n    if (node.children && node.children.length) {\\n      stack = node.children.concat(stack);\\n    }\\n  }\\n  return arr;\\n}\\n```\\n\\n### 13、广度优先遍历\\n\\n**题目**： 以横向的维度对树进行遍历，从第一个节点开始，依次遍历其所有的兄弟节点，再遍历第一个节点的子节点，一层层向下遍历\\n\\n**输入**： 上文第11题生成的tree\\n\\n**输出**： [1, 2, 3, 4, 5]\\n\\n```\\nfunction rangeTree(tree) {\\n  if (!tree || !tree.length) return;\\n  let arr = [];\\n  let node, list = [...tree];\\n  // 取出当前节点\\n  while ((node = list.shift())) {\\n    arr.push(node.id);\\n    node.children && list.push(...node.children);\\n  }\\n  return arr;\\n}\\n```\\n### 14、树形结构查找节点\\n\\n**题目**： 查找树形结构中符合要求的节点\\n\\n**输入**：   \\ntree： 上文第11题生成的tree  \\nfunc： data => data.title === \\\"child2_1\\\"\\n\\n**输出**：{ id: 5, parentId: 2, title: \\\"child2_1\\\" }  \\n\\n```\\n/**\\n* 查找节点\\n* @param {array} tree - 树\\n* @param {function} func - 查找条件\\n* */\\nfunction findTreeNode(tree, func) {\\n  for (const data of tree) {\\n    // 条件成立 直接返回\\n    if (func(data)) return data;\\n    if (data.children) {\\n      const res = findTreeNode(data.children, func);\\n      // 结果存在再返回\\n      if (res) return res;\\n    }\\n  }\\n  return null;\\n}\\n// 测试\\nfindTreeNode(tree, data => data.title === \\\"child2_1\\\")\\n```\\n\\n### 15、二叉查找树\\n\\n**题目**： 判断一个数组，是否为某二叉查找树的前序遍历结果，二叉查找树特点是所有的左节点比父节点的值小，所有的右节点比父节点的值大\\n\\n**输入**： [5, 3, 2, 1, 4, 6, 7, 8, 9]\\n\\n**输出**： true \\n\\n```\\nfunction preOrderOfBST(list) {\\n  if (list && list.length > 0) {\\n    // 前序遍历，第一个值为根节点\\n    var root = list[0];\\n    // 找到数组中，第一个比根节点大的节点，即为右子树的节点\\n    for (var i = 0; i < list.length; i++) {\\n      if (list[i] > root) {\\n        break;\\n      }\\n    }\\n    // 遍历右子树的节点，要求所有右子树的节点都比根节点大\\n    for (let j = i; j < list.length; j++) {\\n      if (list[j] < root) {\\n        return false;\\n      }\\n    }\\n    var left = true;\\n    // 同理，递归判断左子树是否符合二叉查找树的规则\\n    if (i > 1) {\\n      left = preOrderOfBST(list.slice(1, i + 1));\\n    }\\n    var right = true;\\n    // 递归判断右子树是否符合二叉查找树的规则\\n    if (i < list.length) {\\n      right = preOrderOfBST(list.slice(i, list.length));\\n    }\\n    // 左、右子树都符合要求，则是一个二叉查找树\\n    return left && right;\\n  }\\n}\\n```\\n\\n### 16、查找二叉树的路径\\n\\n**题目**： 查找二叉树和为某一值的路径\\n\\n**输入**： 二叉树结构如下，找到和为 11 的所有路径\\n\\n<img src=\\\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a8d2c094ebd84d87855877250fc9a51e~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"findTree.png\\\" width=\\\"60%\\\" />\\n\\n**输出**： [[5, 3, 2, 1], [5, 6]]\\n\\n```\\n/**\\n* 利用回溯算法，找到和为某一值的路径\\n* @param {object} node - 二叉树\\n* @param {number} num - 目标值\\n* @param {array} stack - 栈\\n* @param {number} sum - 当前路径的和\\n* @param {array} result - 存储所有的结果\\n* */\\nfunction findPath(node, num, stack = [], sum = 0, result = []) {\\n  stack.push(node.data);\\n  sum += node.data;\\n\\n  // 找到所有的节点路径(包含叶子节点和子节点的所有情况之和)\\n  if (sum === num) {\\n    // if (!node.left && !node.right && sum === num) {  // 找到所有的叶子节点路径\\n    result.push(stack.slice());\\n  }\\n  if (node.left) {\\n    findPath(node.left, num, stack, sum, result);\\n  }\\n  if (node.right) {\\n    findPath(node.right, num, stack, sum, result);\\n  }\\n  // 回溯算法：不符合要求，退回来，换一条路再试\\n  // 叶子节点直接pop；子节点中的所有的节点递归完成后再pop\\n  stack.pop();\\n  return result;\\n}\\n```\\n\\n### 17、买卖股票问题\\n\\n**题目**： 给定一个整数数组，其中第 `i` 个元素代表了第 `i`天的股票价格；  \\n非负整数 `fee` 代表了交易股票的手续费用，求返回获得利润的最大值\\n\\n**输入**： arr: [1, 12, 13, 9, 15, 8, 6, 16]； fee: 2\\n\\n**输出**： 22\\n\\n```\\n/**\\n * 贪心算法求解\\n * @param {array} list - 股票每天的价格列表\\n * @param {number} fee - 手续费\\n * */\\nfunction buyStock(list, fee) {\\n  // min为当前的最小值，即买入点\\n  let min = list[0],\\n    sum = 0;\\n  for (let i = 1; i < list.length; i++) {\\n    // 从1开始，依次判断\\n    if (list[i] < min) {\\n      // 寻找数组的最小值\\n      min = list[i];\\n    } else {\\n      // 计算如果当天卖出是否赚钱\\n      let temp = list[i] - min - fee;\\n      if (temp > 0) {\\n        // 赚钱 存数据\\n        sum += temp;\\n        // 关键代码：重新计算min，分两种情况，如果后面继续涨，则默认继续持有；若后面跌，则以后面的价格重新买入\\n        min = list[i] - fee;\\n      }\\n    }\\n  }\\n  return sum;\\n}\\n```\\n\\n### 18、斐波那契数列\\n\\n**题目**： 从第3项开始，当前项等于前两项之和： `1 1 2 3 5 8 13 21 ……`，计算第n项的值\\n\\n**输入**： 10\\n\\n**输出**： 89\\n\\n```\\n// 使用动态规划，将复杂的问题拆分，也就是：`F(N) = F(N - 1) + F(N - 2)`，用数组将已经计算过的值存起来\\nfunction fib(n) {\\n  // 使用dp数组，将之前计算的结果存起来，防止栈溢出\\n  if (n < 2) return 1;\\n  let dp = [1, 1];\\n  for (let i = 2; i <= n; i++) {\\n    dp[i] = dp[i - 1] + dp[i - 2];\\n  }\\n  return dp[n - 1];\\n}\\n```\\n\\n### 19、滑动窗口最大值\\n\\n**题目**： 给定一个数组 `nums`，有一个大小为 `k` 的滑动窗口，从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口中的k个数字。滑动窗口每次只向右移动一位，求返回滑动窗口最大值\\n\\n**输入**： nums: [1,3,-1,-3,5,3,6,7]； k: 3\\n\\n**输出**： [3, 3, 5, 5, 6, 7]\\n\\n![window.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b7ee188ecf7a4a86900eb42530d7ec34~tplv-k3u1fbpfcp-watermark.image?)\\n\\n```\\nfunction maxSlidingWindow(nums, k) {\\n  // window存储当前窗口中数据的下标\\n  const window = [];\\n  // result存储窗口中的最大值\\n  const result = [];\\n  for (let i = 0; i < nums.length; i++) {\\n    if (i - window[0] > k - 1) {\\n      // 剔除窗口长度超出范围时左侧的最大值\\n      window.shift(); \\n    }\\n    for (let j = window.length - 1; j >= 0; j--) {\\n      // 当前窗口的值依次和要插入的值做比较，如果小于要插入的值，剔除掉该值，直到window为空为止（保证window中最左侧的值为最大值）\\n      if (nums[window[j]] <= nums[i]) {\\n        window.pop();\\n      }\\n    }\\n    // 添加右侧新加入的值，插入新值时有两种情况：\\n    // 1、新值为最大值时，则window此时为空；\\n    // 2、新值不为最大值时，window已剔除掉比新值小的值\\n    window.push(i);\\n    if (i >= k - 1) {\\n      // 窗口是从0开始移动，当移动的距离大于等于目标范围后，以后再往后移动一次，就要写入当前窗口的最大值\\n      result.push(nums[window[0]]);\\n    }\\n  }\\n  return result;\\n}\\n```\\n\\n### 20、最长递增子序列\\n\\n**题目**： 一个整数数组 nums，找到其中一组最长递增子序列的值\\n\\n**输入**： [3,5,7,1,2,8]\\n\\n**输出**： [3,5,7,8]\\n\\n```\\nfunction lengthOfLIS(nums) {\\n  if (!nums.length) return 0;\\n  // 创建一个和原数组等长的数组dp，用来存储每一项的最长递增子序列\\n  // 比如[1,2,2] 表示第二项和第三项的最长递增子序列都为2\\n  let dp = new Array(nums.length).fill(1);\\n  // 双层for循环，每一项都和之前的所有项一一进行比较，计算出该项的最长递增子序列个数，存储到dp中\\n  for (let i = 0; i < nums.length; i++) {\\n    // 当前项依次和之前的每一项进行比较，累加出当前项的最长递增子序列\\n    for (let j = 0; j < i; j++) {\\n      if (nums[j] < nums[i]) {\\n        // 比较当前项已有的最大值和之前项最大值，比如当比较到第三项[1,2,2]时，如第三项比第二项大，所以第三项的计算结果为[1,2,3]\\n        dp[i] = Math.max(dp[i], dp[j] + 1);\\n      }\\n    }\\n  }\\n  // 取出一组最长递增子序列的具体值（注意：最长递增子序列有可能有多组值，这里是只取出其中一组值）\\n  // 找到dp中的最大值，该值就是nums的最长递增子序列的个数\\n  let max = Math.max(...dp);\\n  let result = [];\\n  for (let i = max; i >= 1; i--) {\\n    // 倒序遍历，根据长度获取对应的值\\n    findArrNode(dp, i, result, nums);\\n  }\\n  return result;\\n}\\nfunction findArrNode(dp, value, result, arr) {\\n  // 找到符合条件最后一项的下标，这样才能保证数组的顺序是正确的\\n  let index = dp.lastIndexOf(value);\\n  // 存储对应的值\\n  result.unshift(arr[index]);\\n  // 对dp进行截取，保证只取最大项之前的数据\\n  dp.length = index + 1;\\n}\\n```\\n\\n[github代码仓库](https://github.com/xy-sea/blog/blob/dev/%E7%AE%97%E6%B3%95/20%E4%B8%AA%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E9%A2%98.md)\\n\\n以上就是工作或面试中最常见的算法题，小伙伴是不是全都掌握了呢，欢迎在评论区交流\\n\\n如果文章对你有所帮助，不要忘了点上宝贵的👍！\\n\\n[「历时8个月」10万字前端知识体系总结（算法篇）🔥](https://juejin.cn/post/7146975493278367752)里还有很多经典的题目噢\\n\\n\\n<img src=\\\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88e5b597616d4b39ac8ecfa71d9e8201~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"face.png\\\" width=\\\"45%\\\" />\\n\\n",
        "tags": [
            "前端",
            "算法",
            "面试"
        ]
    },
    {
        "article_id": "7158107080585379877",
        "cover_image": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/460603aecfa448b4bce1ed5d3c9ba167~tplv-k3u1fbpfcp-watermark.image?",
        "title": "Turn.js实现超奈斯的翻书效果",
        "brief": "最近有些事情，断更了几天，朝着连续更文14天继续努力 今天分享一个用Turn.js 实现的移动端电子书翻页项目。 先来看一下效果： 关于Turn.js 它是一个轻量级的 (15kb) jQuery/h",
        "user_name": "晴天蜗牛不一般",
        "view_count": 8195,
        "collect_count": 172,
        "comment_count": 33,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/883440482645bc6e4a38d26ef1a7ec4a~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: channing-cyan\\n---\\n> 持续创作，加速成长！这是我参与「掘金日新计划 · 10 月更文挑战」的第11天，[点击查看活动详情](https://juejin.cn/post/7147654075599978532 \\\"https://juejin.cn/post/7147654075599978532\\\")\\n\\n\\n最近有些事情，断更了几天，朝着连续更文14天继续努力\\n\\n今天分享一个用Turn.js 实现的移动端电子书翻页项目。\\n\\n先来看一下效果：\\n\\n![tutieshi_356x768_1s.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a0daf3d9b09431f88b1c7fc6798de28~tplv-k3u1fbpfcp-watermark.image?)\\n\\n### 关于Turn.js \\n它是一个轻量级的 (15kb) jQuery/html5 插件用来创建类似书本和杂志翻页效果，支持触摸屏设备。Turn.js 支持硬件加速来让翻页效果更加平滑。\\n\\n特征：\\n-    适用于 iPad 和 iPhone。\\n-    简单、美观且功能强大的 API。\\n-    允许通过 Ajax 请求动态加载页面。\\n-    纯 HTML5/CSS3 内容。\\n-    两种过渡效果。\\n-    适用于旧浏览器，例如带有 turn.html4.js 的 IE 8\\n\\n## turn.js的基本使用\\n\\n\\n### 1 引入turn.js\\nTurn.js依赖于jQuery,首先script标签引入jQuery，和turn.js，jQuery 要求 1.3 或更高版本。\\n\\nturn.js 可前往[官网](http://www.turnjs.com/)下载\\n\\n```\\n<script type=\\\"text/javascript\\\" src=\\\"js/jquery.js\\\"></script>\\n<script type=\\\"text/javascript\\\" src=\\\"js/turn.js\\\"></script>\\n```\\n\\n### 2 创建html和css\\n\\n创建一个容器元素和一些代表页码的子元素，为其设置合适的宽高，随便输入一点内容\\n\\n\\n```\\n<div id=\\\"flipbook\\\">\\n    <div class=\\\"page\\\"></div>\\n    <div class=\\\"page\\\"></div>\\n    <div class=\\\"page\\\"></div>\\n    <div class=\\\"page\\\"></div>\\n</div>\\n```\\n### 3 基本用法\\n\\n```\\n$('#flipbook').turn({\\n    acceleration: true, // 是否启动硬件加速 如果为触摸设备必须为true\\n    pages: 11, // 页码总数\\n    elevation: 50, // 转换期间页面的高度\\n    width: 300, // 宽度 单位 px\\n    height: 800, // 高度 单位 px\\n    gradients: true, // 是否显示翻页阴影效果\\n    display: 'single', //设置单页还是双页\\n    when: {\\n\\t// 翻页前触发\\n\\tturning: function (e, page, view) {\\n\\t                    \\n\\t},\\n\\t// 翻页后触发\\n\\tturned: function (e, page) {\\n\\t\\t\\t\\t\\n        }\\n    }\\n});\\n\\n```\\n这样就可以实现基本的翻页效果了\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eca8389b018d41f6acbca4bf286447c8~tplv-k3u1fbpfcp-watermark.image?)\\n\\n#### 3.1 turn常用配置项\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/511716c3d0374ef1afa061cc71bf464f~tplv-k3u1fbpfcp-watermark.image?)\\n\\n#### 3.2 when 常用监听事件\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea4c3cb2754b4aefa3682cc8379d86ba~tplv-k3u1fbpfcp-watermark.image?)\\n\\n#### 3.3 turn 常用方法\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/74b0091ba5b3475ab130955d4c171058~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## 项目实现\\n\\n项目有30p，每一p都对应一张图片，一页一页搭建实在太慢了，用js创建\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0db4c44af954bbfbd7076610075fe1b~tplv-k3u1fbpfcp-watermark.image?)\\n\\n封装一个turn.js基本配置的函数，根据api实现自己的翻页效果\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93d2f9b904304e2983796bd8fe40ee87~tplv-k3u1fbpfcp-watermark.image?)\\n\\n一进来调用创建函数，构建页面，判断当前浏览器环境是否支持 csstransforms 特性，支持 调用 turn.js 调用完毕后 执行 turn.js 基本配置函数\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3debb74f07544dcac0b511fc5888968~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## 拓展\\n\\n项目中用到两个js插件 简单介绍一下\\n\\n### Modernizr.js\\n\\n传统浏览器目前不会被完全取代，令你难以将最新的 CSS3 或 HTML5 功能嵌入你的网站。 [Modernizr](http://modernizr.cn/) 正是为解决这一难题应运而生，作为一个开源的 JavaScript 库，Modernizr 检测浏览器对 CSS3 或 HTML5 功能支持情况。\\n\\n### yeponpe.js\\n\\n[yepnope.js](http://yepnopejs.com/)是一个能够根据输入条件来选择性异步加载资源文件的js脚本，可以在页面上仅加载用户需要的js/css。\\n\\n\\n",
        "tags": [
            "掘金·日新计划",
            "jQuery",
            "前端"
        ]
    },
    {
        "article_id": "7187654656368050235",
        "cover_image": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be5f1f1233414076b2a27fe96449f670~tplv-k3u1fbpfcp-watermark.image?",
        "title": "如何快速创建一个稳定的开发环境",
        "brief": "现状 现在的开发模式基本是微服务开发模式，一个服务依赖N个其它服务，一个前端依赖一个N个后端，如果本地要debug的话，将会是一件非常头疼的事，常见的debug模式有以下几种： 好像也没什么问题，也可",
        "user_name": "LiuBin",
        "view_count": 10452,
        "collect_count": 21,
        "comment_count": 1,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/f2e5d2bbb52cb799312aa9c7474ecad0~300x300.image",
        "category": "开发工具",
        "content": "# 现状\\n\\n  现在的开发模式基本是`微服务`开发模式，一个服务依赖`N`个其它服务，一个`前端`依赖一个`N`个后端，如果本地要`debug`的话，将会是一件非常头疼的事，常见的`debug`模式有以下几种：\\n\\n    1. 叫相关开发人员将服务运行起来，然后连接调试\\n    2. 自己将所有代码clone下来，自己在本地运行相关服务\\n    \\n好像也没什么问题，也可以调试，但是弊端也很明显\\n\\n先说`方案1`的弊端\\n\\n> 1. 如果开发某天请假了，你没调试环境了，你还能调试吗？\\n> 2. 如果开发又加了新功能，因为功能是个半成品，不稳定，导致你依赖的接口访问不了，你还能调试吗？\\n    \\n`方案2`的弊端\\n    \\n> 1. 这个要求所有开发要熟悉整个技术栈的环境创建、编译构建相关的知识，比如：前端用的是 vue ，后端开发要安装 nodejs ，要懂一些 npm，vue 啥的，后端用的是 go，前端要安装 go ，要懂 go 的依赖安装，go 编译啥的\\n> 2. 因为有多个服务，服务间如果用了相同端口，就会有端口冲突，改了端口后，相关依赖的服务都要修改，这就要求相关开发要对整个架构、服务依赖非常了解，不然肯定非常折腾\\n\\n上述方案都只是用一些成本比较大的方式提供了一个不太稳定的开发环境\\n\\n# 几个工具\\n## docker\\n\\n要保证开发环境的稳定，就需要一个不可变的基础设施，说到不可变基础设施，肯定就要说一下`docker`了，`docker`用`镜像`解决了`PaaS`标准化的问题，将`PaaS`变成了一个不可变基础设施，这样无论我们在什么操作系统上，创建出来的实例都可以运行起来，配置一样的情况下，提供的服务也是一样的，但`docker`只保证单实例的一致性，我们的服务有N多个，如何将它们建立关联关系并运行起来呢\\n\\n## docker-compose\\n\\n`docker-compose` 可以声明一组服务，指定启动镜像、启动命令、暴露服务端口，可以很好的解决服务编排的问题\\n\\n\\n我们用以下这种服务架构为例子，为每个应用创建一个开发环境\\n\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1eae8874d60f49689c43683429edba9f~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n用 `docker` 镜像来解决服务运行环境问题，每个项目有一个`Dockerfile`、`build-dev-image.sh`文件，用`build-dev-image.sh`来构建当前分支下的代码，并`push`到`docker registry`，依赖项目只需要引用相关版本的镜像就好了\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff9088928ee247d794129a2ebab05711~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n用`docker-compose`来解决服务依赖问题，每个项目都要有一个`docker-compose.yml`文件，声明依赖服务的镜像版本，服务的端口\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/540b799e73e4454fae7276261bfbe685~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n\\n# 构建开发环境 docker 镜像\\n\\n---\\n## 前端\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d89f4ba7150e4ec1bf45232a9a0fd482~tplv-k3u1fbpfcp-watermark.image?)\\n\\n`Dockerfile` 如下：\\n\\n```Dockerfile\\nFROM nginx:1.19.2-alpine\\nCOPY ./dist /usr/share/nginx/html\\n```\\n\\n`build-dev-image.sh` 如下：\\n\\n```shell\\n#!/bin/bash\\npwdStr=`pwd`\\ndirName=${pwdStr##*/}\\nbuildTime=`date '+%Y%m%d%H%M'`\\nharborHost=\\\"docker registry domain\\\"\\nlatestTag=$harborHost/dev/${dirName}:latest\\nbuildTimeTag=$harborHost/dev/${dirName}:${buildTime}\\nharborUser=\\\"dev\\\"\\nharborPasswd=\\\"xxxx\\\"\\n\\nnpm run build\\ndocker build -t $latestTag -t $buildTimeTag .\\ndocker login $harborHost -u\\\"$harborUser\\\" -p\\\"$harborPasswd\\\"\\ndocker push $latestTag\\ndocker push $buildTimeTag\\n\\necho \\\"docker镜像名称： $latestTag\\\"\\necho \\\"docker镜像名称： $buildTimeTag\\\"\\n\\n```\\n\\n`build-dev-image.sh` 主要做了：\\n> 1. 构建 `docker` 镜像\\n> 2. `push` 到 `docker registry`\\n\\n功能开发完了，要联调了，执行一下`build-dev-image.sh`，镜像就构建好了，并 `push` 到镜像仓库了，需要的项目按需取\\n\\n这里输出了两个`tag`，一个是`latest`，一个是用`年月日`的，具体用哪个，看变更频繁度，如果很频繁就用`年月日`的，否则就用`latest`的，这样就不用老是修改`docker-compose.yml`了\\n\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93d8b915d395454db030f88311f95362~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n\\n## 后端\\n\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/488a48e593ae4148bf003a6995ec7052~tplv-k3u1fbpfcp-watermark.image?)\\n\\n`Dockerfile`\\n\\n```Dockerfile\\nFROM alpine:3.11.6\\nCOPY main /app/\\nEXPOSE 8000\\nWORKDIR /app\\nCMD [\\\"/app/main\\\"]\\n```\\n\\n`build-dev-image.sh`\\n\\n```shell\\n#!/bin/bash\\npwdStr=$(pwd)\\ndirName=${pwdStr##*/}\\nbuildTime=$(date '+%Y%m%d%H%M')\\nharborHost=\\\"docker registry domain\\\"\\nlatestTag=$harborHost/dev/${dirName}:latest\\nbuildTimeTag=$harborHost/dev/${dirName}:${buildTime}\\nharborUser=\\\"dev\\\"\\nharborPasswd=\\\"xxxx\\\"\\n\\nGOOS=linux CGO_ENABLED=0 go build -o main main.go\\ndocker build -t $latestTag -t $buildTimeTag .\\ndocker login $harborHost -u\\\"$harborUser\\\" -p\\\"$harborPasswd\\\"\\ndocker push $latestTag\\ndocker push $buildTimeTag\\n\\necho \\\"docker镜像名称： $latestTag\\\"\\necho \\\"docker镜像名称： $buildTimeTag\\\"\\n\\nrm -f main\\n```\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f8df293d77947d880a7d9634edbeb29~tplv-k3u1fbpfcp-watermark.image?)\\n\\n# 服务信息\\n\\n先看下项目信息\\n\\n```mermaid\\ngraph TD\\nexample-front --> examplea --> exampleb\\n```\\n---\\n## exampleb\\n\\n只是简单的输出一个字符串\\n\\n```\\npackage main\\n\\nimport (\\n \\\"log\\\"\\n \\\"net/http\\\"\\n)\\n\\nfunc main() {\\n http.HandleFunc(\\\"/b/api\\\", func(writer http.ResponseWriter, request *http.Request) {\\n  log.Println(request.URL.Path)\\n  writer.Write([]byte(\\\"project b\\\"))\\n })\\n http.ListenAndServe(\\\":8000\\\", nil)\\n}\\n```\\n---\\n## examplea\\n\\n调用`examplab`，并输出一个字符串\\n\\n```\\nconst (\\n // 从配置服务中取\\n PROJECT_B_DOMAIN = \\\"http://exampleb:8000\\\"\\n)\\n\\nfunc main() {\\n http.HandleFunc(\\\"/a/api\\\", func(writer http.ResponseWriter, request *http.Request) {\\n  log.Println(request.URL.Path)\\n  resp, _ := http.Get(PROJECT_B_DOMAIN + \\\"/b/api\\\")\\n  defer resp.Body.Close()\\n  result, _ := io.ReadAll(resp.Body)\\n  writer.Header().Set(\\\"Access-Control-Allow-Origin\\\", \\\"*\\\")\\n  \\n  writer.Write([]byte(\\\"project a<br/>\\\"))\\n  writer.Write(result)\\n })\\n http.ListenAndServe(\\\":8000\\\", nil)\\n}\\n```\\n\\n## example-front\\n\\n调用`examplea`\\n\\n```vue\\n<template>\\n  <div id=\\\"app\\\">\\n    <h1>\\n      Server Response: <br /><span v-html=\\\"resp\\\" style=\\\"color: red\\\"></span>\\n    </h1>\\n  </div>\\n</template>\\n<script>\\nimport axios from \\\"axios\\\";\\nexport default {\\n  name: \\\"App\\\",\\n  data() {\\n    return {\\n      resp: \\\"\\\",\\n    };\\n  },\\n  mounted() {\\n    axios.get(\\\"http://localhost:8000/a/api\\\").then((resp) => {\\n      this.resp = resp.data;\\n    });\\n  },\\n};\\n</script>\\n\\n```\\n\\n\\n# 创建开发环境\\n\\n## example-front\\n\\n`example-front`依赖`examplea`，`examplea`又依赖`exampleb`，所以我们需要两个服务，并暴露`examplea`的端口到宿主机上，供前端调用\\n\\n`docker-compose.yml` 如下：\\n\\n```docker-compose\\nversion: '3'\\nservices:\\n  examplea:\\n    image: {{docker registry domain}}/dev/examplea:latest\\n    ports:\\n      - 8000:8000\\n      \\n  exampleb:\\n    image: {{docker registry domain}}/dev/exampleb:latest\\n```\\n\\n然后运行`docker-compose up`，再执行`npm run serve`，然后打开浏览器就可以看到\\n\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/186c1833cf4b4b1ca3d1ece5ca5f0993~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n为了方便一些，我们可以直接修改 `package.json`的`scripts`，将`docker-compose up -d`加到`serve`上，这样我们直接`npm run serve` 也可以有一个开发环境\\n\\n```package.json\\n\\\"scripts\\\": {\\n    \\\"serve\\\": \\\"docker-compose up -d && vue-cli-service serve\\\",\\n    \\\"build\\\": \\\"vue-cli-service build\\\",\\n    \\\"lint\\\": \\\"vue-cli-service lint\\\"\\n  }\\n```\\n\\n## examplea \\n\\n`docker-compose.yml` 如下：\\n\\n```docker-compose\\nversion: '3'\\nservices:\\n  exampleb:\\n    image: {{docker registry domain}}/dev/exampleb:latest\\n  example-front:\\n    image: {{docker registry domain}}/dev/example-front:latest\\n    ports:\\n      - \\\"8080:80\\\"\\n  examplea:\\n    image: golang:1.19.5\\n    working_dir: \\\"/go/src/examplea\\\"\\n    # 调试模式，请制作一个包含go和delve的镜像\\n#    command: [ \\\"dlv\\\", \\\"debug\\\", \\\"--headless\\\", \\\"--listen=:2345\\\", \\\"--api-version=2\\\", \\\"--accept-multiclient\\\", \\\"main.go\\\" ]\\n    command: [ \\\"go\\\",\\\"run\\\",\\\"main.go\\\" ]\\n    volumes:\\n      - .:/go/src/examplea\\n    depends_on:\\n      - exampleb\\n      - example-front\\n    ports:\\n      - \\\"8000:8000\\\"\\n      - \\\"2345:2345\\\"\\n```\\n\\n这里为了有点区别，输出改成了`debug project a<br/>`\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4727e1ce2f4640fc83b9057114000cb7~tplv-k3u1fbpfcp-watermark.image?)\\n直接 `docker-compose up`，`example-front`将`80`映射成`8080`了，打开浏览器输入`http://localhost:8080`，\\n\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61d0e293ff9740b094cabe9003f512e0~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## exampleb\\n\\n`docker-compose.yml`如下：\\n\\n```docker-compose\\nversion: '3'\\nservices:\\n  examplea:\\n    image: {{docker registry domain}}/dev/examplea:latest\\n    ports:\\n      - \\\"8000:8000\\\"\\n  example-front:\\n    image: {{docker registry domain}}/dev/example-front:latest\\n    ports:\\n      - \\\"8080:80\\\"\\n  exampleb:\\n    image: golang:1.19.5\\n    working_dir: \\\"/go/src/exampleb\\\"\\n    # 调试模式，请制作一个包含go和delve的镜像\\n#    command: [ \\\"dlv\\\", \\\"debug\\\", \\\"--headless\\\", \\\"--listen=:2345\\\", \\\"--api-version=2\\\", \\\"--accept-multiclient\\\", \\\"main.go\\\" ]\\n    command: [ \\\"go\\\",\\\"run\\\",\\\"main.go\\\" ]\\n    volumes:\\n      - .:/go/src/exampleb\\n    depends_on:\\n      - examplea\\n      - example-front\\n    ports:\\n      - \\\"2345:2345\\\"\\n```\\n\\n这里为了有点区别，输出改成了`debug project b<br/>`\\n\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa97788bfcfa45f5a49ef727a89280bf~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63ec6464fef342eea7b217e7ec79cd80~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n# 总结\\n\\n现在各项目只需要执行一下`docker-compose up`或者`npm run serve`就可以有一个稳定的开发环境了，再也不用因为环境的问题，折腾大半天，结果还不一定能折腾出来\\n\\n---\\n\\n`go` 项目也是可以启用 `debug` 模式，只需要找一个或者自己制作一下包含`go`和`delve`的镜像，然后把`command`改成`[ \\\"dlv\\\", \\\"debug\\\", \\\"--headless\\\", \\\"--listen=:2345\\\", \\\"--api-version=2\\\", \\\"--accept-multiclient\\\", \\\"main.go\\\" ]`，并将端口用`ports`映射一下就好了 \\n\\n\\n`goland`用`Go Remote`\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a5b861d3e794a508081e5ee555e87e0~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n看到` API server listening at: [::]:2345`，点击`dubug`就OK了\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac91c78428c74260a0ad33b8548b5c1f~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/860f3ddedb19436b989018d46469319c~tplv-k3u1fbpfcp-watermark.image?)\\n\\n# 事例代码\\n[examplea](https://github.com/iroben/examplea)\\n\\n[exampleb](https://github.com/iroben/exampleb)\\n\\n[example-front](https://github.com/iroben/example-front)\\n\\n`clone`记得替换`docker-compose.yml`的`{{docker registry}}`，修改`build-dev-image.sh`中的`registry`信息",
        "tags": [
            "Docker",
            "前端",
            "后端"
        ]
    },
    {
        "article_id": "7163522138698153997",
        "cover_image": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f9ef80e8835d4c8cbbf24f054e05e5ec~tplv-k3u1fbpfcp-watermark.image?",
        "title": "关于前端：如何实现并发请求数量控制？",
        "brief": "嗨呀，又是将近一个月没有更文了，想死你们了！今天又来继续我的更文事业，技术的道路注定是要将卷进行到底的！",
        "user_name": "黑土豆",
        "view_count": 6795,
        "collect_count": 185,
        "comment_count": 44,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/b9384713bd4378646551ea1be0295286~300x300.image",
        "category": "前端",
        "content": "---\\nhighlight: a11y-dark\\ntheme: channing-cyan\\n---\\n\\n本文正在参加[「金石计划 . 瓜分6万现金大奖」](https://juejin.cn/post/7162096952883019783)\\n\\n# 前言\\n\\n嗨呀，又是将近一个月没有更文了，想死你们了！今天又来继续我的更文事业，技术的道路注定是要将卷进行到底的！至于这么久才来更文的原因，那自然是没有好的羊毛值得去薅，一旦有好羊毛那当然是也不会缺席的，所以今天我来了！\\n\\n这次要分享的主题就是前久饭后在和同事讨论时无意间发现的，那就是**前端如何实现并发请求数量控制**。如果你在实际项目中有过类似的需求，应该不会陌生，反之如果你还没有且还不了解的话，那你就有必要耐心地看完这篇文章，保证你一定会有所收获的！\\n\\n# 场景\\n\\n假设有这么一个场景：现在有`20`个异步请求需要发送，但是由于某些原因，要求我们必须将同一时刻的并发请求数量控制在`3`个以内，并且还要尽可能快速的拿到响应结果。其实这个场景在一些大厂的面试题中也有过提及，如下：\\n\\n```\\n实现一个并发请求函数concurrencyRequest(urls, maxNum)，要求如下：\\n• 要求最大并发数 maxNum\\n• 每当有一个请求返回，就留下一个空位，可以增加新的请求\\n• 所有请求完成后，结果按照 urls 里面的顺序依次打出（发送请求的函数可以直接使用fetch即可）\\n```\\n\\n遇到到这个问题时你会怎么来做？\\n\\n遇到这个问题还是先来分析一下这个问题的设计思路→。\\n\\n# 设计思路\\n\\n首先来看将上面的文字转化为图之后的效果：\\n\\n<p align=center><img src=\\\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/07bbe7e8bd9641d58569fdc2526d1a12~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\"  /></p>\\n\\n这样就直观的看到，有一个最大并发数`maxNum`，`20`个异步请求的`urls`集合和并发返回之后的`results`集合。\\n\\n下面就开始演示这个思路是如何开始的，如下：\\n\\n<p align=center><img src=\\\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c7e9910c36ea44b8a8048ba2f61bc910~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\"  /></p>\\n\\n首先按照每次只能并发`3`个请求的要求，这里就对应`A、B、C`，当其中有一个请求完之后就会再从`urls`里面再取出一个进行请求，这样依次类推，直到`urls`里面的`20`个请求都执行完才终止请求。\\n\\n<p align=center><img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e34080a4e7a4b3a99ae2a81489ef85d~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\"  /></p>\\n\\n主要思路就是上面所述，但是在开发时我们要考虑一些特殊情况，如下：\\n\\n- `urls`的长度为`0`时，`results`就没有值，此时应该返回空数组\\n- `maxNum`大于`urls`的长度时，应该取的是`urls`的长度，否则则是取`maxNum`\\n- 需要定义一个`count`计数器来判断是否已全部请求完成\\n- 因为没有考虑请求是否请求成功，所以请求成功或报错都应把结果保存在`results`集合中\\n- `results`中的顺序需和`urls`中的保持一致\\n\\n好，我的设计思路就是这样的，下面就要来开始开发工作啦~\\n\\n# 开发\\n\\n具体代码如下（代码中已备注有注释）：\\n\\n```\\n// 并发请求函数\\nconst concurrencyRequest = (urls, maxNum) => {\\n    return new Promise((resolve) => {\\n        if (urls.length === 0) {\\n            resolve([]);\\n            return;\\n        }\\n        const results = [];\\n        let index = 0; // 下一个请求的下标\\n        let count = 0; // 当前请求完成的数量\\n\\n        // 发送请求\\n        async function request() {\\n            if (index === urls.length) return;\\n            const i = index; // 保存序号，使result和urls相对应\\n            const url = urls[index];\\n            index++;\\n            console.log(url);\\n            try {\\n                const resp = await fetch(url);\\n                // resp 加入到results\\n                results[i] = resp;\\n            } catch (err) {\\n                // err 加入到results\\n                results[i] = err;\\n            } finally {\\n                count++;\\n                // 判断是否所有的请求都已完成\\n                if (count === urls.length) {\\n                    console.log('完成了');\\n                    resolve(results);\\n                }\\n                request();\\n            }\\n        }\\n\\n        // maxNum和urls.length取最小进行调用\\n        const times = Math.min(maxNum, urls.length);\\n        for(let i = 0; i < times; i++) {\\n            request();\\n        }\\n    })\\n}\\n```\\n\\n# 测试\\n\\n测试代码如下：\\n\\n```\\nconst urls = [];\\nfor (let i = 1; i <= 20; i++) {\\n    urls.push(`https://jsonplaceholder.typicode.com/todos/${i}`);\\n}\\nconcurrencyRequest(urls, 3).then(res => {\\n    console.log(res);\\n})\\n```\\n\\n# 结果\\n\\n下面通过运行代码来看看效果：\\n\\n首先来看看控制台输出的结果，如下：\\n\\n<p align=center><img src=\\\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c8ea31912dc453da2b40aa1a8a87a7e~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\"  /></p>\\n\\n<p align=center><img src=\\\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d0b8c31dff2d403d9db7c7263412dcf5~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\"  /></p>\\n\\n可以看到`20`个请求都请求完成，`results`里面也是按顺序打印出了结果。\\n\\n然后再看看请求时请求数量是否每次都是`3`个，如下：\\n\\n<p align=center><img src=\\\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ed226dce0674af09bdbac1617aac8ab~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"test1.gif\\\"  /></p>\\n\\n通过上面这个`gif`图可以很直观的看到，每次请求的数量都是`3`个，证明写的代码没有毛病，搞定！\\n\\n至此，这个在实际开发中会遇见的前端控制并发请求的需求就实现完成了。代码相对来说没有太大的难度，只要把一些特殊情况给考虑完全，最后的实现也就没什么太大问题。最后，希望看完这篇文章之后你也能轻松掌握前端控制并发数量的问题，栓Q~\\n\\n# 后语\\n\\n小伙伴们，如果觉得本文对你有些许帮助，点个👍或者➕个关注再走呗^_^ 。另外如果本文章有问题或有不理解的部分，欢迎大家在评论区评论指出，我们一起讨论共勉。\\n\\n<p align=center><img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fccbeaad2fee45c495f4b6968e88b558~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"src=http___p6.itc.cn_q_70_images03_20210104_70f8545500034a5bae5f1695a7ce3da0.jpeg&refer=http___p6.itc.webp\\\"  /></p>",
        "tags": [
            "掘金·金石计划",
            "JavaScript",
            "前端"
        ]
    },
    {
        "article_id": "7161695238988234788",
        "cover_image": "https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/77a602c8a2e1491da2c70bae718d40c0~tplv-k3u1fbpfcp-watermark.image?",
        "title": "套娃：用低代码搭建低代码",
        "brief": "通常一门编程语言只要支持条件分支判定，变量赋值，循环或递归结构以及四则运算，就能认为是图灵完备的了。假如一个低代码平台支持...",
        "user_name": "iofod",
        "view_count": 2161,
        "collect_count": 22,
        "comment_count": 5,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/ce8956b19f1e1fb0f5a07cbea5097fdb~300x300.image",
        "category": "前端",
        "content": "## 前言\\n\\n通常一门编程语言只要支持条件分支判定，变量赋值，循环或递归结构以及四则运算，就能认为是图灵完备的了。假如一个低代码平台支持嵌入执行图灵完备的自定义代码（如 Javascript）并与低代码系统内部联动，即是说完备性传递给了低代码平台，或者这个低代码系统本身就图灵完备，那么理论上凡是传统编程能实现的任务，低代码平台也能实现（图灵等价）。根据此逻辑，用这类低代码平台去搭建低代码平台本身理论上是可行的，本文仅探讨此类低代码。\\n\\n## 实现自身？\\n\\n我们通常不会因为一门编程语言是图灵完备的就选择它，比如用 Brainfuck 打印下 \\\"Hello World!\\\"\\n\\n```brainfuck\\n++++++++++[>+++++++>++++++++++>+++>+<<<<-]\\n>++.>+.+++++++..+++.>++.<<+++++++++++++++.\\n>.+++.------.--------.>+.>.\\n```\\n\\n现实阻止了你这么做，科学“理论上可行”但脱离现实因素就是在耍流氓，理论上可行但现实几乎不可行便是不行。\\n\\n图灵完备的编程语言理论上都能实现自举，很多通用编程语言往往为了彰显自身强大去实现自举，而不仅仅停留在理论可行上。\\n\\n> 手上没有剑和有剑不用，不是一回事。\\n> —— 钱学森\\n\\n人们发明很多编程语言来应对不同领域的可计算问题，让底层语言解决底层的问题，高级语言解决上层问题，各司其职。底层语言自举往往是必须的，由于底层语言的产物很多是在解决同层面的问题，而高级语言却少数这样，基本在解决更高层的问题（如应用层），因而实现自举则成为可选项。\\n\\n低代码可以看作一种位于高级语言之后的可视化开发语言，低代码与高级语言的一个不同点在于，低代码的产物和低代码属于同一层面，都可以称之为应用，低代码同底层语言一样在解决同层问题，那么自举便不能视为可有可无了。因此若一低代码平台无法自举，那么它所宣传的通用和强大犹如儿戏，应该称之为领域特定低代码（DSL, Domain Specific Lowcode :）才恰当。\\n\\n## 里程碑\\n\\n通用性不妨碍 SQL 成为世界上最为成功的 DSL（虽拓展后可图灵完备），同样地，通用性不是衡量一个低代码平台价值的唯一因素。笔者认为，好用才是低代码最最需要的，我们开发 iofod 低码平台前便设定了几个里程碑，它们呈递进关系，就是说只有前一个达成了，才有必要去完成下一个：\\n\\n- **自己会用**\\n\\n作为日常必备工具，自己真心离不开它，“就是连自己也骗进去了”（手动狗头）\\n\\n- **自指**\\n\\n即前文的“自举”，为了区别于传统编程的定义，后文称自指，具体实施指用 iofod 编辑器搭建出 iofod 编辑器自身。\\n\\n- **少部分人离不开它**\\n\\n让 iofod 拥有一批忠诚的粉丝用户。\\n\\n（PS：截止至本文发表时，前三个目标基本达成，未来的里程碑还找不到准确的词语来概括，以后有机会再分享。）\\n\\n## 周末的成果\\n\\n第二个目标早在半年前就有着手实现的欲望了，它虽有重要意义但整体而言对产品实际贡献不大，属于重要不紧急的事情，因此就被无限搁置了，眼看今年时间所剩无几，趁着 iofod 正式版发布之际，了此夙愿。\\n\\n自指的实现，必须给出可度量的，准确的定义，直面它，不允许采用掩耳盗铃的方式敷衍过去，像通过 iofod 编辑生成生态周边的内容，如项目的主页，双端官网，甚至编辑器自身的部分实现，如工作台用户主页，再者像引入外部组件的方式，即把 pro code 实现的 iofod 编辑器打包成一个组件引入等等。这部分工作确实能用文字概括为实现自身，跟自指沾边，然而严格来讲这根本就不算自指，**用 iofod 低代码编辑器内部能力搭建出一个一样的 iofod 低代码编辑器** 才是真正意义上的自指，搭建周边生态等情况只能归属于“自己会用”实践的范畴。\\n\\n实现目标已定，实现程度呢？\\n\\n我们知道低代码编辑器的核心在于它的搭建能力，核心能力一实现，其余的部分理论上只剩人力和时间资源的问题，因此不必追求 100% 实现编辑器的所有细节，我们只做概念证明，只需实现 iofod 编辑器核心的搭建能力：\\n\\n- 基本的可视化编辑界面\\n- 组件的拖放，解析预览，嵌套，添加到编辑区目标对象上\\n- 组件的选中，元状态的解析，状态属性表单生成\\n- 状态属性表单的增删改查\\n- 编辑器状态与组件状态的联动，结构管理\\n- 可编辑模型变量表单的生成\\n\\n目标和任务详情具备，脑海里再演绎 N 遍扫除所有先验问题，接着按部就班地执行便得了，经过约 16 个钟的搬砖终于搞定！\\n\\n![show1.jpg](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/028b8655aef54741b6d594995bf7db24~tplv-k3u1fbpfcp-watermark.image?)\\n\\n根据 TalkCheapShowCode 原则，执行过程的流水账不再赘述，各位看官自行请前往[【项目主页】](https://www.iofod.cn/app/cfbb87d7aba96d0eda63bb627d14153a/index.html#/index)查看实现细节。\\n\\n![data.jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/377c2840809e45ccb5c5228d6a7b6d52~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## 套娃套娃\\n\\n若只计算 IFstruct 结构的代码行数，此次概念证明约用 1.3 万行代码，约为完整实现的二十五分之一，耗时不足其百分之一，此波可谓血赚不亏！当然这种成本计算只能作为特例，设计和思路是照搬的，套娃不过是利用后来者优势。\\n\\n那么问题来了，继续套娃呢，可否叠加优势？\\n\\n答案是肯定的。我们在套娃这个过程习得套娃的技能经验，可用于下一次套娃，工程师 DRY 被动技能发动！接下来，**我们在低代码平台搭建的低代码平台里搭建低代码平台**：\\n\\n![show2.jpg](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b9032298d744d7ea4da6fc9508e552a~tplv-k3u1fbpfcp-watermark.image?)\\n\\n虽说是套娃，但每一层套娃渲染能力是复用的，也就是说**套娃的套娃可以直接复用套娃的结构**，当然你也可以复制一份出来放到项目内作为自定义函数/服务去调用，渲染能力部分代码不包含在项目结构内而是内置于 iofod 的工程模板里，对这部分感兴趣的小伙伴请参阅 [IFstruct 解析器](https://github.com/iofod/IFstruct-parser)。\\n\\n## 结语\\n\\n> 我看到了它，却不敢相信它。\\n> —— 康托尔\\n\\n笔者野心不大，副本打完提裤走人绝不恋战，为避免套娃宇宙下的 iofod 功高盖主，低代码的套娃故事便就此搁浅。希望本文在低代码自举方面能达抛砖引玉之效，给同路人带来一点启发。\\n\\n--------------\\n\\nAD: 双十一活动前50名企业版私有部署免费，支持 SDK 接入，有需要的企业请私信我或者加微信：qkorbit\\n\\n如果使用过程有任何问题，可以公众号搜索【iofod】或【数字围猎】，点【联系我们】可在线提问，或者添加小助手微信：iofod_beta 进群交流。\\n\\n相关链接：\\n\\n- [iofod - 为攻城师们打造的低代码平台](https://juejin.cn/post/7129401262566539301)\\n- [康托尔、哥德尔、图灵——永恒的金色对角线](https://blog.csdn.net/pongba/article/details/1336028)\\n- [Brainfuck](https://en.wikipedia.org/wiki/Brainfuck)\\n- [Bootstrapping (compilers)](https://en.wikipedia.org/wiki/Bootstrapping_(compilers))\\n- [手动实现一门图灵完备的编程语言——Brainfuck](https://blog.csdn.net/dafei1288/article/details/119884564)\\n\\n",
        "tags": [
            "前端",
            "低代码",
            "编程语言"
        ]
    },
    {
        "article_id": "7151961741776125989",
        "cover_image": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/65f39fde12ad4476ad0cf5d78f862228~tplv-k3u1fbpfcp-watermark.image?",
        "title": "开篇：探索前端工程化、从零到一打造一个前端组件库！",
        "brief": "前端的一整套东西覆盖也非常广泛，从开发、规范、测试、lint、构建部署、监控、集成、微服务、等等链路都隶属于前端工程化，我们需要尽量将其简化，来逐个击破。逐渐完善我们对工程化的认知。",
        "user_name": "_小九",
        "view_count": 6378,
        "collect_count": 254,
        "comment_count": 8,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/f33f119e4329ac67d7212512fd95d6b4~300x300.image",
        "category": "前端",
        "content": "---\\nhighlight: hopscotch\\ntheme: nico\\n---\\n\\n> 本文为稀土掘金技术社区首发签约文章，14天内禁止转载，14天后未获授权禁止转载，侵权必究！\\n\\n### 开篇\\n\\n随着这些年互联网的高速发展，前端岗位所需要最基础的技术栈也从最开始的只需要熟悉，html、css、js，的三驾马车，变成了熟悉前端的主流三大框架：vue、react、angular。那么首先我们要考虑的是为什么这些框架会火，其次我们要了解这些框架的演变过程以及在这些项目火了之后我们又需要如何的去很好的与其协作配合上来，来适配不同的技术选型下最适合团队所需要的场景，这是一个**Leader**所需要考虑、同时也是需要去执行的事情，本期专栏围绕前端工程化，来讲讲如果作为一个团队**Leader**，可以怎么做，去从工程化的角度上，帮助你和你的团队得到一些帮助与发展。\\n\\n前端从最开始的刀耕火种，通过类似**script** 引 **cdn** 的开发方式的时代已经过去了，在全面前端工程化的时候，我们需要先对工程化有个大概的概念，这个时候，我们先暂停一下，花上十秒钟，在你的脑海中想想，你认为的**前端工程化**应该是什么样的，你是如何理解**前端工程化**的？\\n\\n---\\n\\n这是我初入前端岗位的时候，一位面试官询问我得问题，这个问题其实看似简单却又是发现似乎自己无从开口，因为这个问题太广了，这即是对你的综合实力的检验，也是对你总结知识的考量，没有一定的积累是很难可以将这个问题回答的很好，同时当你身处不同岗位的情况下，这种差异就又会变大，如果日常工作中只是接触重复的工作，便更难有机会深入其中了，但是这却是你升职加薪的必备条件，所以我认为这是你值得学习并且可以花费经历学习的方向，当你身处繁重的业务工作而丢失掉学习方向迷茫的时候，我觉得**前端工程化**的学习是完全值得且必要的。\\n\\n近些年来看，前端的项目随着项目的复杂度越来越高，**前端工程化**的这个概念也就变的越来越被重视，但从业务或者团队的范围来看，**前端工程化**俨然已经成为一个前端团队的标配，稍具规模的团队都会根据自身业务设计出一套符合当前业务需求的前端架构出来，同时其也是区分**初级前端**和**高级前端**的分界线，普通开发日常中接触不到这些场景，只需要负责编写业务代码，但是当机会真正出现的时候，又苦于没有能力接手下来而错失良机，而高级或者资深前端则可以使用**前端工程化**解决问题问题，从而去接触更为高层次的**前端架构设计**，从而向技术管理晋升。\\n\\n当很多开发者已经对**vue**、**react**，**angular**等这些主流框架非常熟练的时候也无法实现升职加薪的时候，就是因为缺少了这种全面的工程化知识，无法实现真正的独当一面，不能真正的实现带领团队一起发展，共同进步，所以现在我们开始走入工程化的学习吧！\\n\\n### 什么是前端工程化？\\n\\n在上面的思考你是否已经有了答案了呢，这个问题不管怎么说其实都有理有据，就像一道语文的问道题，怎么回答都行，都有分，所以这个问题本身就是仁者见仁，智者见智，而且我认为这个问题，在不同的人身上必然会不一样，他也是每个人在不同的公司，不同的岗位和其身边的经历所决定的，所以我们只需要学习自己觉得适合自己的，自己觉得对的即可，很多东西即使再好，不适合自己团队公司的场景也只能是纸上谈兵，并不是好的对于目前的我们就一定是对的，我们可以了解、学习，而不是必须的。\\n\\n前端的一整套东西覆盖也非常广泛，从**开发**、**规范**、**测试**、**lint**、**构建**、**部署**、**监控**、**集成**、**微服务**等等链路都隶属于**前端工程化**，所以一看这么长的链路再去考虑如何总结这个问题就显得**务虚**了，我们需要尽量将其简化，来逐个击破。逐渐完善我们对工程化的认知。\\n\\n>  简单来讲：前端工程化指的是:在企业级的前端项目开发中，把前端开发所需的工具、技术、流程、经验等进行规范化、标准化。最终落实到细节上，从而实现前端的4 个现代化:**模块化**、**组件化**、**规范化**、**自动化**\\n\\n这段话也是在不同的文章下面经常看到的一句总结，我们可以对这句话进行一些记忆，然后呢，在后续的学习中自我去理解，然后加深印象吧:\\n\\n\\n![001.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/44271c9548064551b2fafd09e1249f3d~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n\\n前端工程化就是通过各种工具和技术，提升前端开发效率的过程。我们通过这句话可以更好理解，突出了两点\\n\\n1. 前端工程化的内容：各种工具和技术\\n\\n2. 前端工程化的作用：通过使用工具，提升开发效率\\n\\n这样来看似乎更加容易理解了，但凡日常中你觉得方便的，提升了自己效率的事情，小到书写了几行注释，我们都认为其是**前端工程化**中的重要组成部分，但是这似乎过于单一，我们需要将其组织起来，形成一些约定，将这些我们利索当然的事情加入大家共同制定通过的准则，便能成功成为工程化中的一角。\\n\\n那么首先我们看看，我们日常中可能哪些场景会让你觉得开发并不愉快，或者说，下面的这些问题，你遇到了多少。\\n\\n### 你遇到了哪些问题？\\n\\n1. 构建配置、打包配置等等涉及项目的配置文件每次新开项目都需要去复制粘贴。\\n\\n2. 公共工具函数，代码片段、等等复用成本较高，需要自己在不同项目反复寻找已经使用过的东西。\\n\\n3. 团队公共组件没有办法方便引入，版本升级迭代对不用业务的影响无法评估，组件维护升级提心吊胆。\\n\\n4. 团队编码风格大相捷径，新拉下的代码一篇爆红，不敢随便更改团队其他成员代码，害怕承担责任，屎山代码越积越大，越积越多。\\n\\n5. 团队开发环境、 开发编辑器、开发习惯、格式化格式不同，每次格式化变化巨大，**codeReview**代码难度变大。\\n\\n6. 成员不敢主动让团队其他人**CodeReview**代码，会觉得不好意思，不敢让别人主动指出自己错误，也就导致团队没法定期互相**code review**，诸如此类的流程就很难继续下去。\\n\\n7. 团队协作的规范、模块、环境、仓库、文档、各类基建轮子过多，新同学进入团队无从下手，不易快速融入团队。\\n\\n8. 随着需求日益增加复杂，很多小的问题逐渐被放大，项目被迫走上重构的道路！\\n\\n\\n\\n随着迭代需求的增多，我们会越到各种的问题，这些问题逐渐被放大之后，上述的这些问题就会不可避免的出现，所以，上述的问题其实都因为工程化不够完善所导致的，如果我们一开始未对项目做一些必要的工程化措施，项目维护就会变的逐渐复杂且难以控制，到最后难免走向重构的道路。\\n\\n然而这些问题实际上并没有特别复杂，如果我们在项目初期就做了一些必要措施，我们完全可以防患于未然，利用**前端工程化**的开发思维和实际一些案例运用到项目当中去，我们就可以在实现业务的基础上，为业务**降本增效**。\\n\\n总而言之，**前端工程化**不是特指某个阶段，某个场景，而是从项目立项的时候就已经发生，不论是前期准备工作还是开发还是到上线部署，到上线后业务监控等等全方位，全链路，我们都一直处在工程化的道路上。所以，我们需要合理运用前端工程化的知识，保证项目的发展发向在自己的可控范围之内，学习前端工程化可以让你更加全面的全链路了解一个业务的整个生命周期，遇到困难也能在复杂的流程中快速定位并解决问题，提高自己的知识储备，发现一些不足，提出一些完善建议，执行一些更优的流程，甚至可以预见项目的未来发展发向，这些都是一些宝贵的经验知识。\\n\\n\\n\\n### 如何系统化学习前端工程化\\n\\n想要系统化的学习前端工程化并非易事，很多错学在初入前端不久的时间中会因为某个技术栈日常使用频率较高就错误的认为，这一个技术栈就是工程化，会觉得**webpack**就是工程化，会觉得我会封装组件就是工程化，但是前端可不仅仅只是会封装个组建就算是工程化了。\\n\\n首先，目前公司主流都是基于前后端分离而进行开发业务，那么你得非常清楚，什么当前任务属于前端还是属于后端，完好的任务分工可以让你在接入前端工程化的时候更加得心应手，这就是解决很多前端问题的基础，而不是在分不清任务的前提下对着某一个自己不擅长的领域死磕，这样的意义是不大且浪费时间的。\\n\\n其次我们需要对项目的全链路方方面面的了解加实践，好记性不如烂笔头，在程序员的世界同样如此，多练习实践便是最快进步的道路。\\n\\n虽然现在各类前端社区都有很多**前端工程化**的知识，但是总是零零散散的，断层式的学习没有办法帮我们建议一张完整的脉络，无法帮我们体系化学习知识，所以本期专栏以实践为基础，将**前端组件库作为一个项目**，从零开始开发同时接入前端工程化，让大家不仅学会前端工程化，也能熟悉一整个项目的生命周期，加深自己的印象。\\n\\n\\n![002.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc16a075c1274d25ab974cad244876c7~tplv-k3u1fbpfcp-watermark.image?)\\n\\n上图就是本次实践的全部内容了，我们会基于**vue**框架开发一个完整的**组件库**，在这个过程中，我们会接触到完整的链路流程，带大家从0到1开发出这样一个完整的项目实践，其次，目前一直备受欢迎的**element**组件库，其工程化的实现特点尤其繁多，我们会借鉴其经验，并分析其源码，看看这类优秀的开源组件库的工程化都是如何实践的，体验真正的前端工程化的魅力。\\n\\n### 你可以从本期专栏学到什么？\\n\\n1. 从 0 到 1 完成一套组件库工程化的搭建，了解其所涉及的全部知识。\\n\\n2. 学会制定项目规范和代码风格，帮助团队完善统一代码质量风格检测。\\n\\n3. 学会分支管理，提交审核，等前期校验检测。\\n\\n4. 学会TDD测试驱动开发思维。\\n\\n5. 学会使用 Github Action 完成 CI/CD\\n\\n6. 学会monorepo风格代码管理，学会发布自己的工具包到**npmjs**市场。\\n\\n总而言之，认真阅读完本期专栏，会通过对一个**组件库的开发**来全面认识熟悉前端工程化的配置，系统的理解工程化中各个工具所起到的作用，并且将其最终可以应用到你的团队当中去，真正的实现工程化的价值，帮助你的团队提效，实现作为前端工程师的价值。\\n\\n好了，到此为止，我们就开始准备进入本期专栏的代码演示环节了，如果你对这个专栏也感兴趣，欢迎订阅。\\n\\n\\n",
        "tags": [
            "前端",
            "架构",
            "JavaScript"
        ]
    },
    {
        "article_id": "7177580397847380028",
        "cover_image": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc412294dd474760ab5ffdf23660796e~tplv-k3u1fbpfcp-watermark.image?",
        "title": "iOS老司机的2022年回顾, 聊聊寒冬下的实用<<谈判力>>",
        "brief": "回顾2022年, 确实有点冷, 行业寒冬对从事互联网行业的每一个人都产生了或多或少的影响. 不抱怨经济寒冬, 我们谈一些生活职场上接地气的实用技巧, 这个技巧就是\"谈判\".",
        "user_name": "JackLee666",
        "view_count": 2137,
        "collect_count": 2,
        "comment_count": 2,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/7cd9ed67feb31cfde4da833439f391b2~300x300.image",
        "category": "阅读",
        "content": "「回顾2022，展望2023，我正在参与[2022年终总结征文大赛活动](https://juejin.cn/post/7172462429929111559 \\\"https://juejin.cn/post/7172462429929111559\\\")」\\n\\n## 前言\\n- 回顾2022年, 确实有点冷, 行业寒冬对从事互联网行业的每一个人都产生了或多或少的影响.\\n- 不抱怨经济寒冬, 我们谈一些生活职场上接地气的实用技巧, 这个技巧就是\\\"谈判\\\".\\n- 不论你是否愿意, 谈判每天都伴随着我们, 我们每个人都是一位谈判者.\\n- 有这么一本书帮助笔者在寒冷的2022年, 得到了一些生活中的小收获, 这本书就是<<谈判力>>.\\n- 文章纯手打, 抛砖引玉, 如有错误还请评论区指正, 先行谢过了:)\\n\\n\\n\\n\\n## 回顾2022年\\n- 2022年，对互联网人显得确实不那么友好，开局的一、二月就是各种大厂毕业的消息。一时间人人自危，原本到点下班的也不由自主的选择下班后多在公司卷一会~\\n- 原本已经有点寒意了，谁知三、四、五月，疫情再度反扑，上海更是直接来了个王炸，这几个月份，在上海从事互联网相关行业的同仁们，想必绝大多数是在居家办公中度过。\\n- 居家办公过后的六、七。八月就是各个公司资金链断裂带来的各种大裁员，没办法，公司不是家，企业也只能在入不敷出的情况下选择断臂求生。\\n- 九、十、十一月，本来的求职旺季**金九银十**也变得不再火热。很多优秀的小伙伴找工作都会面临着一个实际问题，那就是**谈判**。有没有什么技巧是在这种寒冬下普适且能为大家带来一些切实可用的收获呢？\\n- 在读《谈判力》这本书的过程中，我们会发现一些看似针锋相对的谈判，其实可能存在着更优的双赢的解。\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61f088d6b88745ed868432e21c3b05c2~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## 关于《谈判力》的接地气实用技巧\\n不论你是否愿意，谈判每天都伴随着我们，我们每个人都是一位谈判者。大到买房小到买菜，谈判是一个讨价还价的过程，我们都希望谈判结果符合我们的预期，但要谈出好结果却并不容易。如果你想取得相对更好的谈判结果，我建议你读一读这本《谈判力》。\\n\\n本书的作者共有三人，其中两人是哈佛大学的“哈佛谈判项目”的主任罗杰•费希尔和副主任布鲁斯•巴顿，另一人则是国际谈判协作组织顾问威廉•尤里。三人都是谈判专家，在本书中告诉了我们什么是“原则谈判”。本书鱼渔兼授，不但有很多具体的谈判场景解析还有背后所蕴含的规律，让人们更好的理解谈判的本质。\\n\\n谈判是零和博弈吗？其实很多情况下，谈判并不是零和博弈。打颗栗子，我和你都想要同一个橘子，但是我的目的是吃橘子的果肉，你的目的却是橘子皮做陈皮调料。但是如果我们没有提前把大家的需求弄清楚，就很容易为了一个橘子据理力争，这样原本是双赢的结果，最终却可能让谈判双方不欢而散。以小见大，其实我们日常的谈判中，很容易陷入这种谈判立场上的对立，如果我们能耐心的分析好大家的利益诉求，做好利益分配，就很容易达成一个双赢的结果，我吃到了橘子肉，你拿到了橘子皮。这颗栗子就是《谈判力》第一、二部分的核心内容。在谈判中，我们不应该在立场上讨价还价，尽量做到把人和事分开，把主要精力放在双方的利益上，为共同利益创造方案，在使用客观标准的情况下原来感觉难以进行的谈判可能就会变得容易一些。\\n\\n情绪的把控在在谈判中也能起到重要的作用，如果对方情绪激动，我们就可以使用谈判柔术，先让对方把不利于谈判的情绪发泄出来。人在极端情绪下是很难有理性的，当情绪出现，我们要做的就是知道自己或对方已经陷入到了情绪中，切莫操之过急。就像有时候沟通的氛围可能比沟通的内容更重要，谈判的氛围也对谈判影响很大。在饥肠辘辘冷的发抖的时候，跟人谈判，往往不会取得什么太好的结果，谈判前把控好环境、身体的舒适性会对谈判的结果更有利。\\n\\n我们可以通过技术面让一次谈判更有利于我们，但是我们控制不了谈判的结果。如何能让你在一场谈判中充满底气？那就是你已经准备好了备选方案。有了一个备选方案，你就会在一场谈判中取得一定的主动权，谈判过程中更加从容。在寻找探索备选方案的时候，你可能会发现一个问题更好的解决方案。\\n\\n如果你近期也有一个困扰自己的需要谈判的问题，不妨读读这本《谈判力》。需求驱动读书可能会让你对书本有更深刻的理解。我们不怕跟我们谈判的人也读过这本《谈判力》，因为如果大家都认可原则谈判，那这次谈判肯定会是一个比较愉快的谈判。\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/83e1ca172dc246e68b8d9a50f8b82fcd~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## 结语，展望2023\\n- 如果你也因为2022年的行业寒冬焦虑不已，不妨读点书，能使人平静:)\\n- 开卷有益，大家可以在评论区分享一下2022年的阅读书单👍🏻\\n- 希望半个月后的2023年大家都有一个更温暖的开始🙏🏻~\\n\\n\\n\\n#### 发文不易, 喜欢点赞的人更有好运气👍 :), 定期更新+关注不迷路~\\n\\nps：欢迎加入笔者18年建立的研究iOS审核及前沿技术的三千人扣群：662339934，坑位有限，备注“掘金网友”可被群管通过~\\n\\n「回顾2022，展望2023，我正在参与[2022年终总结征文大赛活动](https://juejin.cn/post/7172462429929111559 \\\"https://juejin.cn/post/7172462429929111559\\\")」\\n\\n",
        "tags": [
            "iOS",
            "Android",
            "前端"
        ]
    },
    {
        "article_id": "7179886787706224695",
        "cover_image": "",
        "title": "java实现每日给女友微信发送早安等微信信息",
        "brief": "开启掘金成长之旅！这是我参与「掘金日新计划 · 12 月更文挑战」的第22天，点击查看活动详情 前言 据说这个功能最近在抖音上很火，我没有抖音，没有看到。 但是我在掘金和CSDN上看了，相关案例确实很",
        "user_name": "穆雄雄",
        "view_count": 10173,
        "collect_count": 183,
        "comment_count": 99,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/ae52a0698e043a57af37660bfe5c9970~300x300.image",
        "category": "后端",
        "content": "开启掘金成长之旅！这是我参与「掘金日新计划 · 12 月更文挑战」的第22天，[点击查看活动详情](https://juejin.cn/post/7167294154827890702 \\\"https://juejin.cn/post/7167294154827890702\\\")\\n\\n>大家好，我是雄雄。\\n\\n![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9fabca4996b64b5aa451ffadeeb66caf~tplv-k3u1fbpfcp-zoom-1.image)\\n## 前言\\n\\n据说这个功能最近在抖音上很火，我没有抖音，没有看到。\\n但是我在掘金和CSDN上看了，相关案例确实很多，但是大家都是借助于了微信服务号，在我看来，效果很不佳。\\n\\n其实我原来的初衷是这样的，每天定时给群里推送新闻，这个原因在之前的文章中也提到过，这边就不在细说了，然后实现了给群中推送之后，就想着，能不能每天给指定人发送消息，网上搜了搜，果然有，各种实现方式五花八门，但是都没看上，于是就自己找了个，自己写。\\n\\n## 网上案例\\n网上最多的可能就是利用微信服务号给推送信息，如图所示：\\n![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af8247a7194b46c9b45d521206cb16e3~tplv-k3u1fbpfcp-zoom-1.image)\\n![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a36bff665bd04b948b4804738c6a934d~tplv-k3u1fbpfcp-zoom-1.image)\\n缺点如下：\\n+ 需要点进去订阅号才能看到，没哟起到吸引的作用\\n+ 申请的测试服务号，也不知道多久过期，说停就给你停掉了\\n+ 定制化的需求有的达不到\\n\\n介于此，我就自己找了一个路子去做，昨晚刚写完，测了测，效果还是比较不错的。如下图所示：\\n![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1d3708d5f8d49689eadeadf69a15d18~tplv-k3u1fbpfcp-zoom-1.image)\\n（有点肉麻~）\\n\\n## 实现方式\\n下面我们来看看是如何实现的。\\n\\n### 准备工作\\n1. 注册智能微秘书账号，花`20`块钱开个会员(20块钱一点都不多)\\n2. 注册天行数据的账号，申请三个接口（早安寄语、每日新闻、土味情话），也可以自己加入别的有意义的内容，直接申请接口就行。\\n3. 准备一个微信号，可以用你现在自己的，也可以在申请一个。\\n4. 准备一个服务器\\n5. 准备一个java项目，放服务器上跑就可以\\n\\n假使你的准备工作除4、5之外，都已经做完了，下面我们来看看如何从代码层面来实现。\\n### 实现原理\\n\\n - [ ]  调用天行数据的`api`，获取自己想要的数据,封装起来\\n - [ ] 调用只能微秘书的接口，实现给微信好友发送消息\\n - [ ] 给控制器`controller`类中添加定时任务，实现定时发送\\n\\n关键代码如下所示：\\n\\n1. 调用天行数据接口，获取早安寄语：\\n```java\\n/**\\n     * 获取每日早安寄语\\n     *\\n     */\\n    public static String getGoodMorning() {\\n        String path = \\\"zaoan/index\\\";\\n        //调用每日简报的接口\\n        String body = HttpUtil\\n                .createGet(Constants.TIAN_XING_API + path + \\\"?key=\\\" + TIAN_KEY)\\n                .execute()\\n                .body();\\n        JSONObject jsonObjectResult = JSON.parseObject(body);\\n        Integer code = jsonObjectResult.getInteger(\\\"code\\\");\\n        if (code != 200) {\\n            log.error(\\\"请求每日新闻的接口出错，出错信息：\\\" + body);\\n            return \\\"一切都是最好的安排~\\\";\\n        }\\n        log.info(\\\"请求每日新闻的接口成功：\\\" + body);\\n        JSONObject resultObject = jsonObjectResult.getJSONObject(\\\"result\\\");\\n        return resultObject.getString(\\\"content\\\");\\n    }\\n```\\n2. 调用天行数据接口，获取土味情话：\\n```java\\n/**\\n     * 获取每日土味情话\\n     *\\n     */\\n    public static String getLoveWords(){\\n        String path = \\\"saylove/index\\\";\\n        //调用每日简报的接口\\n        String body = HttpUtil\\n                .createGet(Constants.TIAN_XING_API + path + \\\"?key=\\\" + TIAN_KEY)\\n                .execute()\\n                .body();\\n        JSONObject jsonObjectResult = JSON.parseObject(body);\\n        Integer code = jsonObjectResult.getInteger(\\\"code\\\");\\n        if(code!=200){\\n            log.error(\\\"请求每日新闻的接口出错，出错信息：\\\"+body);\\n            return \\\"一切都是最好的安排~\\\";\\n        }\\n        JSONObject resultObject = jsonObjectResult.getJSONObject(\\\"result\\\");\\n        log.info(\\\"请求每日新闻的接口成功：\\\"+resultObject);\\n        return resultObject.getString(\\\"content\\\");\\n    }\\n```\\n\\n3. 调用天行数据接口，获取天气预报：\\n```java\\n\\n    /**\\n     * 获取天气预报\\n     *\\n     */\\n    public static JSONObject getWeather(){\\n        String path = \\\"tianqi/index\\\";\\n        //调用每日简报的接口\\n        String body = HttpUtil\\n                .createGet(Constants.TIAN_XING_API + path + \\\"?key=\\\" + TIAN_KEY+\\\"&type=1&city=370100\\\")\\n                .execute()\\n                .body();\\n        JSONObject jsonObjectResult = JSON.parseObject(body);\\n        Integer code = jsonObjectResult.getInteger(\\\"code\\\");\\n        if(code!=200){\\n            log.error(\\\"请求每日新闻的接口出错，出错信息：\\\"+body);\\n            return null;\\n        }\\n\\n        return jsonObjectResult.getJSONObject(\\\"result\\\");\\n        /*\\n        * {\\n          \\\"code\\\": 200,\\n          \\\"msg\\\": \\\"success\\\",\\n          \\\"result\\\": {\\n            \\\"date\\\": \\\"2022-12-19\\\",\\n            \\\"week\\\": \\\"星期一\\\",\\n            \\\"province\\\": \\\"上海\\\",\\n            \\\"area\\\": \\\"上海\\\",\\n            \\\"areaid\\\": \\\"101020100\\\",\\n            \\\"weather\\\": \\\"晴\\\",\\n            \\\"weatherimg\\\": \\\"qing.png\\\",\\n            \\\"weathercode\\\": \\\"qing\\\",\\n            \\\"real\\\": \\\"3℃\\\",\\n            \\\"lowest\\\": \\\"2℃\\\",\\n            \\\"highest\\\": \\\"9℃\\\",\\n            \\\"wind\\\": \\\"北风\\\",\\n            \\\"windspeed\\\": \\\"0\\\",\\n            \\\"windsc\\\": \\\"0级\\\",\\n            \\\"sunrise\\\": \\\"06:47\\\",\\n            \\\"sunset\\\": \\\"16:54\\\",\\n            \\\"moonrise\\\": \\\"\\\",\\n            \\\"moondown\\\": \\\"\\\",\\n            \\\"pcpn\\\": \\\"0\\\",\\n            \\\"uv_index\\\": \\\"0\\\",\\n            \\\"aqi\\\": \\\"54\\\",\\n            \\\"quality\\\": \\\"良\\\",\\n            \\\"vis\\\": \\\"18\\\",\\n            \\\"humidity\\\": \\\"48\\\",\\n            \\\"alarmlist\\\": [\\n\\n            ],\\n            \\\"tips\\\": \\\"晴天紫外线等级较高，外出注意补水防晒。天气凉，适宜着一到两件羊毛衫、大衣、毛套装、皮夹克等春秋着装；年老体弱者宜着风衣加羊毛衫等厚型春秋着装。空气质量较好，可以参与各类户外活动。疫情防控不松懈，出门请佩戴口罩。\\\"\\n              }\\n            }\\n        * */\\n    }\\n```\\n\\n### 日期处理关键代码\\n1. 获取今天是周几\\n```java\\n /**\\n     * 获取汉字的今天周几\\n     * @param dateTime\\n     * @return\\n     * @throws ParseException\\n     */\\n    public static String getDaysByWeekChina(String dateTime) throws ParseException {\\n        Calendar cal = Calendar.getInstance();\\n        SimpleDateFormat dateFormat = new SimpleDateFormat(\\\"yyyy-MM-dd\\\");\\n        Date date = dateFormat.parse(dateTime);\\n        cal.setTime(date);\\n        int day = cal.get(Calendar.DAY_OF_WEEK);\\n        day = day - 1;\\n        //周的汉字\\n        String week = \\\"\\\";\\n        switch (day) {\\n            case 0:\\n                week = \\\"日\\\";\\n                break;\\n            case 1:\\n                week = \\\"一\\\";\\n                break;\\n            case 2:\\n                week = \\\"二\\\";\\n                break;\\n            case 3:\\n                week = \\\"三\\\";\\n                break;\\n            case 4:\\n                week = \\\"四\\\";\\n                break;\\n            case 5:\\n                week = \\\"五\\\";\\n                break;\\n            case 6:\\n                week = \\\"六\\\";\\n                break;\\n        }\\n        return week;\\n    }\\n```\\n\\n2. 获取纪念日的天数（两个日期之间的差）：\\n\\n```java\\n\\n /**\\n     * 得到二个日期间的间隔天数\\n     *\\n     * @param date1\\n     * @param date2\\n     * @return\\n     */\\n    public static int getDayByTwoDay(String date1, String date2) {\\n        SimpleDateFormat myFormatter = new SimpleDateFormat(\\\"yyyy-MM-dd\\\");\\n        Long day = 0L;\\n        try {\\n            java.util.Date date = myFormatter.parse(date1);\\n            java.util.Date mydate = myFormatter.parse(date2);\\n            day = (date.getTime() - mydate.getTime()) / (24 * 60 * 60 * 1000);\\n        } catch (Exception e) {\\n            return 0;\\n        }\\n        return day.intValue();\\n    }\\n```\\n\\n### 实现给指定微信好友推送消息\\n```java\\n\\n    /**\\n     * 每天将指定信息推送到微信个人\\n     */\\n    @Override\\n    public void sendWechatToUser() {\\n        String url = WEI_MI_SHU_API + \\\"/openapi/v1/chat/contact\\\";\\n        WeiZhiMiShuVO weiZhiMiShuVO = new WeiZhiMiShuVO();\\n        //发送文字信息\\n        weiZhiMiShuVO.setType(1);\\n        try {\\n            //拿到发送的消息列表\\n            SimpleDateFormat format = new SimpleDateFormat(\\\"yyyy年MM月dd日\\\");\\n            SimpleDateFormat format_h = new SimpleDateFormat(\\\"yyyy-MM-dd\\\");\\n            //今天的日期\\n            String toDate = format_h.format(new Date());\\n            //相恋的日期\\n            String lian = \\\"2022-03-28\\\";\\n            //两个日期相差的天数\\n            int cha = DateUtils.getDayByTwoDay(toDate, lian);\\n            String todayDate = format.format(new Date());\\n\\n            //根据阳历计算农历\\n            Calendar today = Calendar.getInstance();\\n            String week = DateUtils.getDaysByWeekChina(toDate);\\n            today.setTime(DateUtils.chineseDateFormat.parse(todayDate));\\n            DateUtils lunar = new DateUtils(today);\\n            String nongli = lunar.toString();\\n            nongli = nongli.substring(nongli.indexOf(\\\"年\\\") + 1);\\n            StringBuilder sb = new StringBuilder();\\n            sb.append(\\\"亲爱的老婆~早\\\\n\\\\n\\\")\\n                    .append(\\\"充满希望的一天又开始了，今天也要一直开心，不能生我气气~\\\")\\n                    .append(\\\"\\\\n\\\\n今天是：\\\")\\n                    .append(todayDate)\\n                    .append(\\\"，星期\\\")\\n                    .append(week)\\n                    .append(\\\"，农历\\\")\\n                    .append(nongli)\\n                    .append(\\\"\\\\n\\\")\\n                    .append(\\\"是我们相爱的第：\\\")\\n                    .append(cha)\\n                    .append(\\\"天\\\")\\n                    .append(\\\"\\\\n\\\\n\\\")\\n\\n            ;\\n            JSONObject tianqiObject = TianXingApiUtil.getWeather();\\n            sb.append(\\\"目前济南天气：\\\")\\n                    .append(tianqiObject.getString(\\\"weather\\\"))\\n                    .append(\\\"\\\\n\\\")\\n                    .append(\\\"当前气温：\\\")\\n                    .append(tianqiObject.getString(\\\"real\\\"))\\n                    .append(\\\"\\\\n\\\")\\n                    .append(\\\"今天最高温度：\\\")\\n                    .append(tianqiObject.getString(\\\"highest\\\"))\\n                    .append(\\\"\\\\n\\\")\\n                    .append(\\\"最低温度：\\\")\\n                    .append(tianqiObject.getString(\\\"lowest\\\"))\\n                    .append(\\\"\\\\n\\\")\\n                    .append(\\\"风向：\\\")\\n                    .append(tianqiObject.getString(\\\"wind\\\"))\\n                    .append(\\\"\\\\n\\\")\\n                    .append(\\\"空气质量：\\\")\\n                    .append(tianqiObject.getString(\\\"quality\\\"))\\n                    .append(\\\"\\\\n\\\")\\n                    .append(\\\"空气质量指数：\\\")\\n                    .append(tianqiObject.getString(\\\"aqi\\\"))\\n                    .append(\\\"\\\\n\\\")\\n                    .append(\\\"小提示：\\\")\\n                    .append(tianqiObject.getString(\\\"tips\\\"));\\n\\n            //土味情话\\n            sb.append(\\\"\\\\n\\\\n\\\")\\n                    .append(\\\"爱你一日言：\\\")\\n                    .append(TianXingApiUtil.getLoveWords())\\n                    .append(\\\"\\\\n\\\\n【早安寄语】\\\")\\n                    .append(goodMorning());\\n            weiZhiMiShuVO.setContent(sb.toString());\\n            for (String str : SEND_USER) {\\n                JSONObject object = new JSONObject();\\n                object.put(\\\"apiKey\\\", WEI_MI_SHU_KEY);\\n                //好友昵称\\n                object.put(\\\"name\\\", str);\\n                //好友备注\\n                object.put(\\\"alias\\\", str);\\n                object.put(\\\"message\\\", weiZhiMiShuVO);\\n                String body = HttpUtil.createPost(url)\\n                        .body(JSON.toJSONString(object))\\n                        .execute()\\n                        .body();\\n                System.out.println(\\\"传递的参数是：\\\" + JSON.toJSONString(object));\\n                System.out.println(\\\"发送成功了吗?\\\" + body);\\n            }\\n\\n        } catch (ParseException e) {\\n            e.printStackTrace();\\n        }\\n    }\\n\\n```\\n**说明：**\\n1. `WeiZhiMiShuVO `类可以参考文章：[java实现给微信群中定时推送消息](https://blog.csdn.net/qq_34137397/article/details/128361385?spm=1001.2014.3001.5501)\\n2. 代码中涉及到的常量，都放在了常量类中，`SEND_USER`是要发给微信好友的好友昵称，不是备注哈。\\n3. 智能微秘书接口地址：[接口地址](http://wechat.aibotk.com/oapi/oapi)\\n\\n然后我们在控制器`controller`中调用该方法即可实现：\\n```java\\n/**\\n     * 发送消息给指定的人\\n     */\\n\\n    @GetMapping(value = \\\"/sendWechatToUser\\\")\\n    @Scheduled(cron =\\\"0 0 8 * * ?\\\")\\n    public void sendWechatToUser(){\\n        articleService.sendWechatToUser();\\n    }\\n\\n```\\n\\n`cron =\\\"0 0 8 * * ?`是一个corn表达式，表示每天早上8点给指定的微信好友推送消息。",
        "tags": [
            "后端",
            "掘金·日新计划",
            "Java"
        ]
    },
    {
        "article_id": "7177365571627909181",
        "cover_image": "",
        "title": "《设计师小姐姐说,我做了个状态动画 就问你怕不怕?》之前因",
        "brief": "简单分享一下,动画的分解和实现.喜欢的可以点看看哦 开启掘金成长之旅！这是我参与「掘金日新计划 · 12 月更文挑战」的第22天，点击查看活动详情",
        "user_name": "TT_Close",
        "view_count": 4088,
        "collect_count": 25,
        "comment_count": 14,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/391dcd0276451aabb45d49700e55bb90~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: condensed-night-purple\\nhighlight: night-owl\\n---\\n\\n开启掘金成长之旅！这是我参与「掘金日新计划 · 12 月更文挑战」的第22天，[点击查看活动详情](https://juejin.cn/post/7167294154827890702 \\\"https://juejin.cn/post/7167294154827890702\\\")\\n\\n\\n**前因**\\n\\n>突然有一天,设计师小姐姐说,老板让我做了一个加载状态动画,就问你怕不怕.我淡定的说,给我`gif`图.然后小姐姐说`不可以`.\\n\\n多大点事.这还能难倒我了.虽然我会的不多,但我会拆分啊.由于时间紧,我这里就不去画渐变了.直接使用`图片`代替.后续有时间了,改成`绘画`.\\n\\n复杂的动画.无非是有简单的动画组合使用.话不多说,先看`第一种状态`的动画效果,后面我还会把剩下的动画状态补上.\\n\\n<img src=\\\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05bc32e792da4fc1b371067966223489~tplv-k3u1fbpfcp-watermark.image?\\\" >\\n\\n**分析**\\n\\n从上面的表现层来说\\n- 整体动画效果分为两种\\n    - **旋转**动画\\n    - **缩放**动画\\n\\n- 从图层来说分为**6层**:\\n\\n    | 图层描述 |  图层样式 |\\n    | --- | --- |\\n    |  **底层虚化阴影**| ![截屏2022-12-15 19.33.51.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a26fb2260e2457b97cbee3f49589be0~tplv-k3u1fbpfcp-watermark.image?) |\\n    |**缩放背景**|![截屏2022-12-15 19.53.15.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5d76bd7ae1d4480bb7f2ef1de3d1162e~tplv-k3u1fbpfcp-watermark.image?)\\n    |**逆时针光线**|![截屏2022-12-15 19.53.31.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b6b2ce89c2f5481eaa3652ec1b00d01e~tplv-k3u1fbpfcp-watermark.image?)\\n    |**逆时针边线**|![截屏2022-12-15 19.53.59.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f8c6bacbaa54d35a261b1e472185624~tplv-k3u1fbpfcp-watermark.image?)\\n    |**圆环**|![截屏2022-12-15 19.54.04.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03f57c473d804a52a9254620bac2cca0~tplv-k3u1fbpfcp-watermark.image?)\\n    |**渐变色**|![截屏2022-12-15 19.54.08.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab79f38a41024a7dbd05dfb9b3cd5f06~tplv-k3u1fbpfcp-watermark.image?)\\n\\n>经过分解之后,来实现**动画**,就相对来说简单.只需要实现**旋转**和**缩放**动画即可.\\n\\n**实现**\\n\\n为了实现上面的动画,我们需要准备**两个部分**.\\n    \\n- 动画的执行\\n    \\n   从[官方文档](https://developers.weixin.qq.com/miniprogram/dev/api/ui/animation/wx.createAnimation.html)中.我们知道.如果想要执行**动画效果**,必须要创建一个**动画实例**,并调用**实例**的方法来描述动画是**旋转**还是**缩放**.然后最后通过**动画实例**的**eport**方法导出动画数据,并赋值给`组件`的`animation`属性.基本上满足了我们的需求.\\n   - 创建**动画实例**\\n     \\n     ```\\n     createAnimation(time) {\\n          return wx.createAnimation({\\n                duration: time,// 动画执行时间\\n                timingFunction: 'linear',//表示动画匀速执行\\n                delay: 0, // 动画延迟事件\\n                transformOrigin: '50% 50% 0'\\n           });\\n     }\\n     ```\\n     这里就不一一讲解参数含义了,不懂的直接看[官方文档](https://developers.weixin.qq.com/miniprogram/dev/api/ui/animation/wx.createAnimation.html)即可.从上面的方法中,我们就创建好**动画实例**了.经我们分析动画.等到三个动画效果.并且每一个**动画时长**也是不一样的.如下所示\\n     |动画效果|动画时长|\\n     |--|--|\\n      顺时针旋转动画| 500ms\\n      逆时针旋转动画| 1000ms\\n      缩放动画| 1500ms\\n     \\n     这样我们就可以先把**动画实例**创建一下.\\n     - 定义**全局动画实例**和**基数动画时长**\\n       ![截屏2022-12-15 20.41.26.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71883f78170f420cb366d648b6e25f3f~tplv-k3u1fbpfcp-watermark.image?)\\n     - 在组件进入树节点时,创建**动画实例**\\n   \\n        ![截屏2022-12-15 20.42.52.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45b46efbb8e74b12a1351bc656453241~tplv-k3u1fbpfcp-watermark.image?)\\n       \\n   - **描述动画**\\n      \\n      创建好**动画实例**后,我们再把对应的**动画效果**创建一下.如下所示\\n      ```js\\n      /// 顺时针动画效果\\n      _clockwiserotaeAnim.rotate(120 * n).step();\\n      /// 逆时针动画效果\\n      _anitclockwiserotaeAnim.rotate(-120 * n).step();\\n      /// 缩放动画效果\\n      /// 定义缩放倍数.\\n      let nscale = this.data.scale == 1.3 ? 1.0 : 1.3;\\n      _scaleAnim.scale(nscale).step();\\n      ```\\n   - 赋值给**animation**\\n     \\n     拿到**描述动画**后,我们按照[官方文档](https://developers.weixin.qq.com/miniprogram/dev/api/ui/animation/wx.createAnimation.html)示例,现在就需要**导出**和**赋值**.\\n     - 导出\\n     \\n         ```js\\n         /// 顺时针动画导出\\n         this.setData({\\n            clockAnima: _clockwiserotaeAnim.export(),\\n          })\\n         /// 逆时针动画导出\\n         this.setData({\\n            anitclockAnima: _anitclockwiserotaeAnim.export()\\n          });\\n         /// 缩放动画导出\\n         this.setData({\\n            scaleAnim: _scaleAnim.export(),\\n            scale: nscale,\\n         })\\n         ````\\n    - 赋值\\n      \\n      由于赋值都是一样的,这里就举例说明一下即可.\\n      ```\\n      <image  animation=\\\"{{scaleAnim}}\\\" />\\n      ```\\n      \\n      经过上面的配置,动画就已经初步完成了.如下所示\\n      ![MTVideo 2.GIF](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52678e189c9841ad8b5f07de57ab5315~tplv-k3u1fbpfcp-watermark.image?)\\n      \\n     \\n- 无限循环\\n\\n    为了让我们的动画可以一直执行,这里就需要使用定时器,让动画重复执行即可,从上面的**动画时长**中,我们知道,他们的时间比例时1:2:3.所以,我们只需要一个定时器即可.经过逻辑处理,来执行**3**个动画.\\n    - 定义定时器的标识\\n       ```\\n       var _intervalId = -1; // 动画定时任务id，通过setInterval来达到无限旋转，记录id，用于结束\\n       ```\\n    - 定时器使用\\n       ```js\\n       _intervalId = setInterval(() => {\\n            let time = this.data.animatime + _ANIMATION_TIME;\\n            /// 每500ms执行一下顺时针旋转动画\\n            that.configAnimation(time / 500 + 1, 0);\\n            if (time % 1500 == 0) {\\n                /// 每1500ms执行一下缩放动画\\n                that.configAnimation(0, 2);\\n            }\\n            if (time % 1000 == 0) {\\n                /// 每1000ms执行逆时针动画\\n                that.configAnimation(time / 1000 + 1, 1);\\n            }\\n            this.setData({\\n                animatime: time\\n            })\\n        }, _ANIMATION_TIME);\\n       ```\\n    - 定时器的销毁\\n       ```\\n       // 动画结束\\n\\n        stopAnimation() {\\n             // 这是为了判断定时器是否存在.\\n            if (_intervalId > 0) {\\n                // 销毁定时器\\n                clearInterval(_intervalId);\\n                _intervalId = -1;\\n            }\\n       },\\n       ```\\n   \\n   经过上面**定时执行**.我们第一种状态的**动画**就完成.\\n   \\n   >今天分享主要是在遇到复杂的动画的时候,**不要慌,学会拆分动画.一个一个去实现,总会完成的**.\\n\\n## demo\\n- [DEMO](https://gitee.com/tengteng_fan/wxlearn.git)\\n## 系列文章\\n- [完整篇](https://juejin.cn/post/7177734770120458295)\\n## 学习资料\\n- [官方文档](https://developers.weixin.qq.com/miniprogram/dev/api/ui/animation/wx.createAnimation.html)",
        "tags": [
            "掘金·日新计划",
            "前端",
            "微信小程序"
        ]
    },
    {
        "article_id": "7168397058095710216",
        "cover_image": "https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c2bdfdf039f7411e97f45f1ed30df84e~tplv-k3u1fbpfcp-watermark.image?",
        "title": "二十一个微信小程序开发技巧(上)",
        "brief": "一、前言 一些微信小程序开发技巧，希望能帮助到大家 二、behaviors （bɪ'heɪvjəz 行为） 先看看官方文档是如何介绍的 再看下官",
        "user_name": "业务崽",
        "view_count": 2602,
        "collect_count": 124,
        "comment_count": 15,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/e0281cbae3085d8477abd369dd62f164~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: nico\\nhighlight: zenburn\\n---\\n“ ***本文正在参加[「金石计划 . 瓜分6万现金大奖」](https://juejin.cn/post/7162096952883019783 \\\"https://juejin.cn/post/7162096952883019783\\\")*** ”\\n# 一、前言\\n一些微信小程序开发技巧，希望能帮助到大家\\n\\n# 二、behaviors （`bɪ'heɪvjəz` 行为）\\n先看看官方文档是如何介绍的\\n> `behaviors` 是用于组件间代码共享的特性，类似于一些编程语言中的 “mixins” 或 “traits”。\\n\\n再看下官方的解释\\n\\n> `behavior` 可以包含一组属性、数据、生命周期函数和方法。**组件引用它时，它的属性、数据和方法会被合并到组件中，生命周期函数也会在对应时机被调用**\\n\\n这个其实大家可以理解为是一个`公共`的`组件`的`js`文件，这个`js`文件可以在你的`任何`组件页面内引用，引入后你的`被引用`的js文件就拥有了你引入的这个`behaviors.js`中的一切方法及变量\\n\\n## 使用\\n新建`js`文件，注册`Behavior`\\n```js\\nmodule.exports = Behavior({\\n    properties: {},\\n    data: {\\n        name: '业务崽',\\n        age: '18'\\n    },\\n    methods: {\\n        fun1() {\\n            console.log('fun1')\\n        },\\n        fun2() {\\n            console.log('fun2')\\n        }\\n    },\\n})\\n```\\n页面1引入`Behavior`\\n```js\\n// js\\nvar myBehavior = require('./myBehavior/index.js')\\n\\nComponent({\\n    behaviors: [myBehavior]\\n})\\n```\\n\\n```html\\n/** wxml **/\\n<view>{{ name }}</view>\\n<button bindtap=\\\"fun1\\\">保存</button>\\n\\n// 业务崽\\n// fun1\\n```\\n\\n页面2引入`Behavior`\\n```js\\n// js\\nvar myBehavior = require('./myBehavior/index.js')\\n\\nComponent({\\n    behaviors: [myBehavior]\\n})\\n```\\n\\n```html\\n/** wxml **/\\n<view>{{ name }} {{ age }}</view>\\n<button bindtap=\\\"fun2\\\">保存</button>\\n\\n// 业务崽 18\\n// fun2\\n```\\n\\n# 三、页面下拉出现二楼交互\\n\\n若想在小程序内实现类似淘宝、京东等下拉出现二楼的交互，应该怎么实现？\\n\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a229a90ed3274f8197dcbe8d1ebb115a~tplv-k3u1fbpfcp-watermark.image?)\\n\\n接到这个需求后尝试了很多方案，因为微信小程序会自带一个下拉刷新的操作，就算不启用下拉刷新，下拉屏幕时也会使屏幕多一截白屏，所以这里给一个最佳解决方案\\n\\n```html\\n<swiper vertical=\\\"true\\\" current=\\\"1\\\" style=\\\"height: 100vh\\\">\\n    <swiper-item style=\\\"height: 100vh\\\">\\n        二楼下拉内容\\n    </swiper-item>\\n    <swiper-item style=\\\"height: 100vh\\\">\\n        页面内容\\n    </swiper-item>\\n</swiper>\\n```\\n可使用`swiper`自带方法监听滑动距离，添加自定义交互效果\\n\\n> Tips: 如果遇到`swiper`过大导致页面无法下拉，包一层`scroll-view`即可解决\\n\\n```html\\n<swiper-item>\\n    <scroll-view scroll-y=\\\"true\\\" style=\\\"height: 100vh;\\\">\\n    </scroll-view>\\n</swiper-item>\\n```\\n\\n# 四、router\\n微信小程序若要进行页面跳转只能使用微信小程序的跳转方法，例如：`wx.navigateTo`、`wx.redirectTo`、`wx.switchTab`等...\\n\\n那要是想使用`router`来进行路由操作，应该如何实现呢？\\n\\n## 实现\\n根目录创建`router`文件夹\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e086dd51a889499ba4fc46c9db181c11~tplv-k3u1fbpfcp-watermark.image?)\\n\\n可根据业务、分包不同将页面路由进行单文件管理，这里用`page1`、`page2`代替\\n\\n**page1.js**\\n```js\\nexport default [\\n    {\\n        name: 'page1',\\n        title: '页面1',\\n        url: 'pages/page1/index'\\n    }\\n]\\n```\\n**page2.js**\\n```js\\nexport default [\\n    {\\n        name: 'page2',\\n        title: '页面2',\\n        url: 'pages/page2/index'\\n    }\\n]\\n```\\n**pages.js**\\n```js\\nimport page1 from './page1'\\nimport page2 from './page2'\\n\\nexport default [\\n    ...page1,\\n    ...page2\\n]\\n```\\n\\n**index.js**\\n\\n因为代码过多，这里只放一个大概结构，有需要完整代码的，评论区评论\\n```js\\nimport pages from 'pages'\\n// 注册页面\\nfunction _getPages_() {\\n    if (!pages || pages.constructor !== Array) {\\n        return []\\n    }\\n    pages.forEach(item => {\\n        if (item.url.slice(0, 1) !== '/') {\\n            item.url = '/' + item.url\\n        }\\n    })\\n    return pages\\n}\\n\\nexport default class Router {\\n    constructor() {\\n        this.pages = _getPages_()\\n        this.params = null\\n    }\\n    // 保留当前页面，跳转到应用内的某个页面。但是不能跳到 tabbar 页面\\n    push(name, params = null, navigateType = {}) {}\\n    // 关闭所有页面，打开到应用内的某个页面 可传递参数 可跳转到Tabbar页面\\n    reLaunch(name, params = null) {}\\n    // 关闭当前页面，打开到应用内的某个页面 可传递参数 不可重定向到Tabbar页面\\n    redirect(name, params = null) {}\\n    // 跳转指定的tab页\\n    switchTab(name) {}\\n    // 关闭当前页面，返回上一页面或多级页面。 没有参数 代表返回上一页\\n    back() {delta = 1, params = null}\\n    // 关闭所有页面返回到首页\\n    backHome(params = null) {}\\n    // 获取指定的Page\\n    getPageFor(name) {}\\n}\\n```\\n**app.js**\\n\\n给app设置$router 属性\\n```js\\nimport MiniRouter from '/router/index'\\nApp({\\n    onLaunch () {\\n        this.$router = new MiniRouter()\\n    }\\n})\\n```\\n\\n> Tips: 用`router`定义了路由后，不是说`app.json`里就不用注册了，`app.json`里同样需注册路由\\n\\n## 使用\\n\\n```js\\n// 需要在使用的页面先获取app\\nconst app = getApp()\\n// 用法：1\\napp.$router.push(\\\"page1\\\")\\n// 用法：2\\napp.$router.push(\\\"page1\\\")\\n   .success(res => {\\n        console.log(\\\"success: \\\", res)\\n   })\\n   .fail(err => {\\n        console.log(\\\"fail: \\\", err)\\n   })\\n   .complete(_ => {\\n        console.log(\\\"complete\\\")\\n   })\\n// 用法：3 (传参)\\napp.$router.push(\\\"page1\\\", { name: '业务崽' })\\n// 用法：4 (获取参数)\\nconst params = app.$router.params // { name: '业务崽' }\\n```\\n# 五、表单校验\\n微信小程序本身是没有提供表单校验功能的，平常用的比较多的是[`WxValidate.js`]([https://github.com/wux-weapp/wx-extend/tree/master/src/assets/plugins/wx-validate]())\\n\\n首先我们下载`WxValidate.js`并放置在`utilts`目录下\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/46114448c2c54bf7a0a0c8b28dff3c47~tplv-k3u1fbpfcp-watermark.image?)\\n\\n在使用到的页面引入`WxValidate`\\n```js\\n// js\\nimport WxValidate from '../utils/WxValidate'\\n```\\n\\n页面加载初始化校验规则\\n\\n```js\\n\\ndata() {\\n    form: {\\n        userName: ''\\n    }\\n},\\nonLoad() {\\n    // 初始化表单校验规则\\n    this.initValidate()\\n  },\\n  \\ninitValidate() {\\n   const rules = {\\n       userName: { required: true }\\n   }\\n   const messages = {\\n       userName: { required: '姓名不能为空' }\\n   }\\n   this.WxValidate = new WxValidate(rules, messages)\\n},\\n```\\n提交表单\\n```js\\nsubmit () {\\nif (!this.WxValidate.checkForm(this.data.form)) {\\n     wx.showToast({\\n         title: this.WxValidate.errorList[0].msg,\\n         mask: true,\\n         icon: 'none',\\n         duration: 1500\\n     })\\n     return\\n   }\\n}\\n```\\n# 六、版本更新\\n```js\\nApp({\\n    onLaunch() {\\n        const updateManager = wx.getUpdateManager()\\n        updateManager.onCheckForUpdate(res => {\\n            if (res.hasUpdate) {\\n                wx.showLoading({\\n                     title: '版本更新中···',\\n                     mask: true\\n                })\\n            }\\n        })\\n        updateManager.onUpdateReady(() => {\\n            wx.showModal({\\n                title: '更新提示',\\n                content: '新版本已经准备好，是否重启应用？',\\n                showCancel: false,\\n                success(res) {\\n                    if (res.confirm) {\\n                        // 新的版本已经下载好，调用 applyUpdate 应用新版本并重启\\n                        updateManager.applyUpdate()\\n                    }\\n                }\\n            })\\n        })\\n        updateManager.onUpdateFailed(() => {\\n            wx.showToast({\\n                title: '更新失败,请关闭小程序进程，重新打开',\\n                icon: 'none',\\n                duration: 2000,\\n                mask: true\\n            })\\n        })\\n    }\\n})\\n```\\n\\n\\n# 七、一键生成骨架屏\\n\\n微信小程序内如何一键生成骨架屏，美观又实用\\n\\n首先，我们写一个这样的原始页面\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c6b9c7b1aa054de9a1a2e5958b270d0e~tplv-k3u1fbpfcp-watermark.image?)\\n\\n然后，在我们的开发者工具里的模拟器下方找到`···`点击生成骨架屏\\n\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef762a9b29354cc1916ced16b0d063ce~tplv-k3u1fbpfcp-watermark.image?)\\n\\n生成骨架屏文件\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/14e6168c8ac849b8a8681a742b40bdd1~tplv-k3u1fbpfcp-watermark.image?)\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8d9911814653419eaa8fa362f40879cc~tplv-k3u1fbpfcp-watermark.image?)\\n\\n分别在`wxml`和`wxss`内引入\\n```html\\nwxml\\n<import src=\\\"index.skeleton.wxml\\\" />\\n<template is=\\\"skeleton\\\" wx-if=\\\"{{ showSkeleton }}\\\" />\\n```\\n```css\\nwxss\\n@import \\\"index.skeleton.wxss\\\";\\n```\\n\\n需用`template`模板引入骨架屏，并使用`wx-if`进行控制。页面加载时默认`true`，拿到数据后赋值为`false`关闭骨架屏\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d270cef9a044fa2acc2c6c14daddd10~tplv-k3u1fbpfcp-watermark.image?)\\n\\n> Tips: 可在生成的`wxss`内自行修改骨架屏样式\\n\\n# 八、微信小程序使用less\\n\\n首先第一步，在`vsCode`内下载安装`Easy LESS`\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab86f041a40a4c5c98b23fda4a5ce586~tplv-k3u1fbpfcp-watermark.image?)\\n\\n其次我们打开编辑器扩展面板，点击`···`\\n\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bdab1ee03136472cbac2549be1279bdd~tplv-k3u1fbpfcp-watermark.image?)\\n\\n选择`从已解包的扩展文件夹安装`\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/50e5a438018647fcbe8c9eac2fd8d935~tplv-k3u1fbpfcp-watermark.image?)\\n\\n找到我们刚在`vsCode`内安装的`Easy LESS`，选择并导入\\n\\n![b2de70ed3512f2c3c742a0f1dae92cb.jpg](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5f86b2cfeb624395bfce618948d6e439~tplv-k3u1fbpfcp-watermark.image?)\\n\\n导入成功后，微信小程序会自动重启，到这一步 安装就已经成功了。但我们还需要去设置一下`Easy LESS`的输出文件，因为默认会生成`.css`文件，我们需将其设置为`.wxss`\\n\\n\\n在我们已安装的插件内找到`Easy LESS`并点击小齿轮图标\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b55f40a9f82492ead5addc3f01c8cf4~tplv-k3u1fbpfcp-watermark.image?)\\n\\n在弹开的小窗口内找到`Extension Settings`选项并点击\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c116fd317919403ea6798aa6b43e5929~tplv-k3u1fbpfcp-watermark.image?)\\n\\n点击并打开`settings.json`\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e1399cd7fef4c1ba201142f13fd161f~tplv-k3u1fbpfcp-watermark.image?)\\n\\n添加如下代码，保存重启开发者工具即可完成设置\\n\\n```json\\n// settings.json\\n\\\"less.compile\\\": {\\n     \\\"outExt\\\": \\\".wxss\\\"\\n },\\n```\\n\\n\\n# 九、独立分包\\n先来看看官方解释\\n\\n> 独立分包是小程序中一种特殊类型的分包，可以独立于主包和其他分包运行\\n\\n[独立分包](https://developers.weixin.qq.com/miniprogram/dev/framework/subpackages/independent.html)\\n\\n最主要的特性其实就是，可独立于主包和其他分包运行。这样在业务层如果有可单独运行的业务模块，即可采用独立分包的形式\\n\\n优点：不用加载主包及其它分包的内容，大幅度提升页面的启动速度\\n\\n缺点：独立分包不能依赖主包和其他分包中的内容，并且主包中的 `app.wxss` 对独立分包无效\\n\\n-----\\n\\n## 使用\\n\\n在`app.json`的`subpackages`字段中对应的分包配置项中定义`independent`字段\\n\\n```js\\n{\\n  \\\"pages\\\": [\\n    \\\"pages/index\\\",\\n    \\\"pages/logs\\\"\\n  ],\\n  \\\"subpackages\\\": [\\n    {\\n      \\\"root\\\": \\\"moduleA\\\",\\n      \\\"pages\\\": [\\n        \\\"pages/rabbit\\\",\\n        \\\"pages/squirrel\\\"\\n      ]\\n    }, {\\n      \\\"root\\\": \\\"moduleB\\\",\\n      \\\"pages\\\": [\\n        \\\"pages/pear\\\",\\n        \\\"pages/pineapple\\\"\\n      ],\\n      \\\"independent\\\": true\\n    }\\n  ]\\n}\\n```\\n\\n# 十、[page-container](https://developers.weixin.qq.com/miniprogram/dev/component/page-container.html)\\n\\n我们在写业务时经常会遇到在当前页面打开一个`全屏子页面`的需求，如果按照正常的方式去写`全屏子页面`,用户在进行返回操作时会直接离开当前页面，而不是关闭当前打开的`全屏子页面`。\\n\\n这时我们就可以采用`page-container`，去模拟一个页面容器，将我们的`全屏子页面`放在这个页面容器内。这样我们在进行返回操作时就只会关闭当前的这个`页面容器`，而不会直接离开当前页面\\n\\n## 使用\\n```html\\n<page-container show=\\\"{{ show }}\\\">\\n    <page1 />\\n</page-container>\\n```\\n\\n> Tips: 一个页面内只能存在一个`page-container`，但我们可以通过`wx-if`的方式去控制\\n\\n# 十一、副文本\\n\\n[`rich-text`标签](https://developers.weixin.qq.com/miniprogram/dev/component/rich-text.html)\\n\\n```html\\n<view>\\n    <rich-text nodes=\\\"{{content}}\\\"></rich-text>\\n</view>\\n```\\n\\n",
        "tags": [
            "前端",
            "微信小程序",
            "掘金·金石计划"
        ]
    },
    {
        "article_id": "7152695802509393951",
        "cover_image": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a5dd68c67744d83a8927577e83c10f2~tplv-k3u1fbpfcp-watermark.image?",
        "title": "你想知道的前端灰度方案都在这了",
        "brief": "背景： 用户打开页面的时候，需要根据页面的活动 id，渲染不同的迭代版本，例如活动 A 使用的代码是 v0.0.1(featureA),活动 B 使用的版本是 v0.0.2(featureB)",
        "user_name": "乘风gg",
        "view_count": 4418,
        "collect_count": 57,
        "comment_count": 18,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/25a4db542094a530751e0c0f2515a74c~300x300.image",
        "category": "前端",
        "content": "> 持续创作，加速成长！这是我参与「掘金日新计划 · 10 月更文挑战」的第1天，[点击查看活动详情](https://juejin.cn/post/7147654075599978532 \\\"https://juejin.cn/post/7147654075599978532\\\")\\n\\n## 背景：\\n\\n用户打开页面的时候，需要根据页面的活动 id，渲染不同的迭代版本，例如活动 A 使用的代码是 v0.0.1(featureA),活动 B 使用的版本是 v0.0.2(featureB)\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/31234021d5ef4d0c8c9f35056fcbe9ff~tplv-k3u1fbpfcp-watermark.image?)\\n当然灰度策略不单单是活动 id，可能包括如下情况\\n1. 按流量百分比\\n2. 按地区\\n3. 用户id\\n4. 活动id\\n5. 按ip\\n6. 等等\\n\\n## 目的\\n让产品应用逐步投放到市场，逐步发现问题，修改问题，适应市场\\n\\n## 办法：\\n### 1. nginx + lua + apollo \\n\\n推荐指数：⭐️⭐️⭐️⭐️\\n\\n修改成本：⭐️⭐️⭐️\\n\\n具体做法：用户请求 nginx,nginx 根据灰度策略判断当前用户需要渲染的版本后返回对应版本的 html， 判断版本的逻辑由 nginx 处理，灰度策略存放在某个数据库或者 apollo（比如白名单 ip,白名单 id，百分比值）\\n\\n优势：\\n* 不改动前端业务代码，维护简单\\n\\n劣势：\\n\\n* 改造成本稍大，需要后端或者运维支援、需要使用 lua 语言，可能需要修改构建流程。\\n\\n\\n### 2. bff + apollo \\n\\n推荐指数：⭐️⭐️⭐️\\n\\n修改成本：⭐️⭐️⭐️⭐️\\n\\n具体做法：类似第一种，只是把 nginx 换成了 node.js,适合有 bff 层，且 bff 承担渲染前端页面功能的项目\\n\\n优势：\\n* 不改动前端业务代码，维护简单\\n\\n劣势：\\n\\n* 对于没有 bff 的项目或者有 bff 但不承担渲染任务的项目，改造成本大，需要引入 bff 层\\n\\n### 3. 前端 ajax 请求后端接口。\\n\\n推荐指数：⭐️\\n\\n修改成本：⭐️⭐️⭐️⭐️⭐️\\n\\n具体做法：用户请求 nginx，nginx 返回 html ，前端渲染 html, 执行 script 写好的 ajax 脚本，请求后端接口，拿到灰度的版本号，最后前端动态加载不同版本的入口 main.js。在这里灰度策略、灰度版本判断逻辑都放到了后端\\n\\n优势：无\\n\\n劣势：\\n\\n*  改造成本比 2 还大，前端和后端都要改动\\n\\n*  前端同步 ajax 会延迟页面加载，导致白屏，用户有感知，可能会有重定向。\\n\\n\\n\\n### 4.前端业务代码逻辑判断\\n\\n推荐指数：⭐️\\n\\n修改成本：⭐️⭐️⭐️⭐️\\n\\n具体做法：前端在代码里面 if else 判断，例如 A用户使用 A 组件，B 用户使用 B 组件\\n\\n优势：\\n* 纯前端\\n\\n劣势：\\n\\n*  不适合项目级别控制的 A/B test，只适用于组件级别\\n*  代码冗余，可能有多版本，多个 if 判断 ，维护麻烦\\n\\n\\n### 5. 前端自己做资源的入口判断\\n\\n推荐指数：⭐️⭐️⭐️⭐️\\n\\n修改成本：⭐️\\n\\n具体做法：用户请求 nginx，nginx 返回 html ，前端渲染 html, 执行 script 脚本，前端判断灰度的版本号，最后动态加载不同版本的入口 main.js。在这里灰度策略、灰度版本判断逻辑都放在前端 html 内的 script 脚本处理。\\n\\n优势：\\n\\n* 无需后端运维参与改造。\\n* 项目级别的灰度，不修改具体的业务代码\\n\\n劣势：\\n\\n需要灰度的时候，需要前端修改，增加前端工作量\\n\\n\\n## 看了上面几种情况，再总结一下，灰度发布的本质问题其实就 3 个\\n### 1. 打包的资源怎么处理，即怎么区分 featureA 的资源还是 featureB 的资源\\n 通常我们打包的时候，只会放到这3个地方，怎么记录版本号呢？\\n1. 上传到 cdn\\n\\n 可以通过资源地址的 hash 值判断\\n \\n2. 放到云服务器\\n\\n 需要每次打包出来的目录名不一致，然后根据资源目录名称，本质也是地址 hash 不同\\n \\n3. docker 镜像\\n\\n 通过镜像的版本号来判断\\n\\n### 2. 灰度策略放在哪里\\n1. 放到后端业务的数据库\\n2. apollo\\n3. 前端\\n### 3. 灰度版本的判断逻辑放在哪\\n1. 可以放到 nginx\\n2. 可以放到BFF（Node.js）\\n3. 可以放到前端\\n\\n\\n\\n**但是这三个问题一结合，就会出现很多的灰度方案，结合自身项目选型的难度就会增大，可能还会涉及到 Docker ，多套服务器环境的情况，例如，使用灰度的时候，是灰度到另一套环境呢，还是只是前端资源的灰度。希望这篇文章能给大家带来一点启发。** \\n",
        "tags": [
            "前端",
            "架构",
            "掘金·日新计划"
        ]
    },
    {
        "article_id": "7176816492795658299",
        "cover_image": "",
        "title": "如何将本地文件转成流数据传递给后端？",
        "brief": "开启掘金成长之旅！这是我参与「掘金日新计划 · 12 月更文挑战」的第13天，点击查看活动详情 简介 项目实际开发过程中，可能涉及文件上传的需求。前端无法直接将一个文件传递给后端，而是需要将一个文件转",
        "user_name": "拾荒草",
        "view_count": 1162,
        "collect_count": 18,
        "comment_count": 6,
        "avatar": "https://p3-passport.byteacctimg.com/img/mosaic-legacy/3792/5112637127~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: smartblue\\n---\\n开启掘金成长之旅！这是我参与「掘金日新计划 · 12 月更文挑战」的第13天，[点击查看活动详情](https://juejin.cn/post/7167294154827890702 \\\"https://juejin.cn/post/7167294154827890702\\\")\\n\\n# 简介\\n项目实际开发过程中，可能涉及文件上传的需求。前端无法直接将一个文件传递给后端，而是需要将一个文件转成流数据通过POST接口传递给后端。\\n\\n那么？我如何将本地文件转换成**流数据**呢？\\n\\n# 通过input标签获取数据信息\\n\\n## 文件选取\\n\\n**html**中，将**input**标签的**type**设置成**file**可以实现文件选取。\\n\\n```\\n<body>\\n\\t<input type=\\\"file\\\"  />\\n</body>\\n```\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb399ae96a5b4e75bd2cbe784b437c32~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n此时，**input**标签还有**multiple**、**accept**两个相关属性可选。\\n\\n-   multiple：每次是否可以选择多个文件\\n-   accept：可选择的文件类型\\n\\n```\\n<body>\\n\\t\\t<input type=\\\"file\\\"  multiple=\\\"multiple\\\" accept=\\\".pdf,.png\\\" />\\n</body>\\n```\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb06f97875f947b6bfe966937c79e29a~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n## 获取文件的数据信息\\n\\n当我们选择文件后，会触发input标签上的**changge**事件，我们给该事件绑定我们自定义的处理事件，即可获取到选择的文件信息。如:\\n\\n```\\n\\t<body>\\n\\t\\t<input type=\\\"file\\\"  multiple=\\\"multiple\\\" accept=\\\".pdf,.png\\\" id=\\\"inputFile\\\" onchange=\\\"fileChange\\\" />\\n\\t</body>\\n\\t<script type=\\\"text/javascript\\\">\\n\\t\\tfunction fileChange(){\\n\\t\\t\\tlet fileList = document.getElementById(\\\"inputFile\\\").files\\n\\t\\t\\tconsole.log(fileList )\\n\\t\\t}\\n\\t</script>\\n```\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e4a7a83987fb49af88b39999bc66f8dc~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n我们仔细观察控制台，可以发现文件选择后，浏览器返回了一个FileList对象，这个对象是一个伪数组，包含了每个文件的**File**对象。\\n\\n### File对象\\n\\n什么是File对象呢？我们先看官网的定义：\\n\\n文件（**File**）接口提供有关文件的信息，并允许网页中的 JavaScript 访问其内容。\\n\\n简单来说，File是一个构造函数，我们控制台中的**fileList[0]** 对应的内容就是**File**的实例化对象。\\n\\n验证下：\\n\\n```js\\nconsole.log(fileList[0].__proto__.constructor)   // ƒ File() { [native code] }\\n```\\n\\nFile构造函数有5个属性：\\n\\n| 属性名                                                                                                 | 属性含义                                                                                                                      |\\n| --------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------- |\\n| [File.lastModified](https://developer.mozilla.org/zh-CN/docs/Web/API/File/lastModified)             | 返回当前 File 对象所引用文件最后修改时间                                                                                                   |\\n| [File.name](https://developer.mozilla.org/zh-CN/docs/Web/API/File/name)                             | 返回当前 File 对象所引用文件的名字                                                                                                      |\\n| [File.size](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/size)                             | 返回文件的大小                                                                                                                   |\\n| [File.webkitRelativePath](https://developer.mozilla.org/zh-CN/docs/Web/API/File/webkitRelativePath) | 返回 [File](https://developer.mozilla.org/zh-CN/docs/Web/API/File) 相关的 path 或 URL                                           |\\n| [File.](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/size)type                             | 返回文件的MIME 类型<https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types>                                 |\\n| [File.lastModifiedDate](https://developer.mozilla.org/zh-CN/docs/Web/API/File/lastModifiedDate)     | 返回当前 File 对象所引用文件最后修改时间的 [Date](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date) 对象 |\\n\\n**fileList[0]** 作为File构造函数的实例化对象，自然继承以上所有属性。\\n\\n```\\nfunction fileChange(){\\n      // 我们选择一个pdf文件\\n\\t\\t\\tlet fileList = document.getElementById(\\\"inputFile\\\").files\\n\\t\\t\\tconsole.log(fileList[0])\\n\\t\\t}\\n```\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/84de198a51ab412cb69c6a5f0a62bc01~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n### 通过FileReader获取数据信息\\n\\n我们可以理解为File对象是DOM接口和文件之间的一个桥梁，通过这个桥梁我们，我们拿到了文件，知道了它的名称、大小等信息。但如果我们想知道文件的具体内容是什么，就要借助其他接口实现了。\\n\\n**FileReader**构造函数就是用来获取文件内容的。我们来看个示例：\\n\\n```\\n<body>\\n\\t\\t<input type=\\\"file\\\"  multiple=\\\"multiple\\\" id=\\\"inputFile\\\" onchange=\\\"fileChange()\\\" />\\n\\t</body>\\n\\t<script type=\\\"text/javascript\\\">\\n\\t\\tfunction fileChange(){\\n\\t\\t\\t//获取file对象（点击input，上传文件触发）\\n\\t\\t\\tlet fileList = document.getElementById(\\\"inputFile\\\").files\\n\\t\\t\\t//创建fileReader实例化对象\\n\\t\\t\\tlet fileReader = new FileReader();\\n\\t\\t\\t//读取的文件或数据\\n\\t\\t\\tfileReader.readAsDataURL(fileList[0])\\n\\t\\t\\t//文件读取成功的回调\\n\\t\\t\\tfileReader.onload = function(){\\t\\n\\t\\t\\t\\t//fileReader.result 就是文件的的内容\\n\\t\\t\\t\\tconsole.log(fileReader.result)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t</script>\\n```\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52c4f22aa7ce4f5296b38e39767876e4~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n从上述示例我们可以知道，通过fileReader的result属性，我们可以拿到文件的具体数据。我们来看看fileReader的其他属性与方法。\\n\\n### fileReader的属性与方法\\n\\n#### 主要的事件\\n\\n| 事件名                                                                                         | 事件触发条件                    |\\n| ------------------------------------------------------------------------------------------- | ------------------------- |\\n| [FileReader.onabort](https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader/onabort)   | 该事件在读取操作被中断时触发。           |\\n| [FileReader.onerror](https://developer.mozilla.org/en-US/docs/Web/API/FileReader/onerror)   | 该事件在读取操作发生错误时触发。          |\\n| [**FileReader.onload**](https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader/onload) | 该事件在读取操作完成时触发。            |\\n| FileReader.onloadstart                                                                      | 该事件在读取操作开始时触发。            |\\n| FileReader.onloadend                                                                        | 该事件在读取操作结束时（要么成功，要么失败）触发。 |\\n| FileReader.onprogress                                                                       | 该事件在读取文件时触发。              |\\n\\n#### 核心方法\\n\\n| 方法名                                                                                                             | 方法内容                                                                                                                                                                                                                     |\\n| --------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\\n| [FileReader.abort()](https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader/abort)                         | 中止读取操作。在返回时，readyState属性为DONE。                                                                                                                                                                                           |\\n| [FileReader.readAsArrayBuffer()](https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader/readAsArrayBuffer) | 开始读取指定的 [Blob](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob)中的内容, 一旦完成, result 属性中保存的将是被读取文件的 [ArrayBuffer](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) 数据对象. |\\n| [FileReader.**readAsDataURL()**](https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader/readAsDataURL)     | 开始读取指定的[Blob](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob)中的内容。一旦完成，result属性中将包含一个data: URL格式的Base64字符串以表示所读取文件的内容。                                                                                            |\\n| [FileReader.readAsText()](https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader/readAsText)               | 开始读取指定的[Blob](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob)中的内容。一旦完成，result属性中将包含一个字符串以表示所读取的文件内容。                                                                                                              |\\n\\n注：这里的Blob也是一个文件属性的构造函数，File构造函数继承与Blob构造函数。File实例化对象拥有Blob上的所有属性与方法，也有一些属于自己的内置方法。\\n\\n#### 核心属性\\n\\n[FileReader.result](https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader/result)\\n\\n**只读属性，** 文件的内容。该属性仅在读取操作完成后才有效，数据的格式取决于使用[FileReader.**readAsDataURL()** ](https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader/readAsDataURL)还是[FileReader.readAsArrayBuffer()](https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader/readAsArrayBuffer)。\\n\\ndataUrl和[ArrayBuffer](https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader/readAsArrayBuffer)都是文件在计算机中的一种存储格式，本篇文章我们不展开讨论，总之，这两种格式都是可以直接传递给后端的，当然，对于多数情况下，我们传递给后端的还是[ArrayBuffer](https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader/readAsArrayBuffer)。\\n\\n  \\n\\n\\n# 将数据发送给后端\\n\\n当我们获取到数据后，将文件传递给后端是非常容易的。我们如果使用axios，发送一个接口应该是这样：\\n\\n```\\naxios.post(\\\"http://192.XXXX.XXX\\\",data).then(res =>{\\n\\t\\tconsole.log(res)\\n})\\n```\\n\\n应用到我们的文件发送代码中，应该是这样\\n\\n```\\nfunction fileChange(){\\n\\t\\t\\t// .....\\n\\t\\t\\tfileReader.onload = function(){\\t\\n\\t\\t\\t\\t//fileReader.result 文件的内容\\n\\t\\t\\t\\tlet data = {\\n\\t\\t\\t\\t\\tfileBuffer:fileReader.result\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\taxios.post(\\\"url\\\",data).then(res =>{\\n\\t\\t\\t\\t\\tconsole.log(res)\\n\\t\\t\\t\\t})\\n\\t\\t\\t}\\n\\t\\t}\\n```\\n\\n要注意的是，大数据的传输一定是使用post接口的（需要和后端沟通），同时，代码中的fileBuffer名称也是需要和后端沟通的。\\n",
        "tags": [
            "掘金·日新计划",
            "前端",
            "JavaScript"
        ]
    },
    {
        "article_id": "7174794945453097017",
        "cover_image": "",
        "title": "都ES13了，迭代器、生成器还没搞懂？",
        "brief": "不知不觉，ES13已经发布半年了，新特性暂且不提，很多旧特性我们都没彻底掌握，本次就一起来复习下ES6中的迭代器和生成器吧。",
        "user_name": "侃如",
        "view_count": 2132,
        "collect_count": 30,
        "comment_count": 9,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/151f57cffad56e2caa93e4d8d85285ad~300x300.image",
        "category": "前端",
        "content": "---\\nhighlight: arduino-light\\ntheme: channing-cyan\\n---\\n开启掘金成长之旅！这是我参与「掘金日新计划 · 12 月更文挑战」的第3天，[点击查看活动详情](https://juejin.cn/post/7167294154827890702 \\\"https://juejin.cn/post/7167294154827890702\\\")\\n## 前言\\n大家好，我是侃如，最近在复习ES6，打算扫清一些自己之前学习忽略的知识点。看了一下，不知不觉都到ES13了(类加了#关键字、await也可以顶层调用了......)\\n新特性暂且不提（有机会后面总结下）。跟身边的小伙伴沟通了下，发现部分同学对迭代器、生成器还比较模糊，怎么用？为什么用？完全是一头雾水，借这个机会跟大家分享下自己的复习成果，希望也能帮大家扫除一些知识盲点。\\n\\n> 不要在面试官问你时，才想起来被自己忽略的知识点。\\n## 迭代器\\nIterator被称为**迭代器**，在JavaScript中，**迭代器**是一个函数对象，它存在于**可迭代对象**的原型链中，可以通过可迭代对象的生成方法**Symbol.iterator**来访问。\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2b883d93da3488e91b3dcf5efc46573~tplv-k3u1fbpfcp-watermark.image?)\\n\\n迭代器可以通过使用**next()** 方法实现迭代，next()方法会返回具有两个属性的对象：value和 done，value表示当前迭代的值，done是一个布尔值表示迭代是否结束。如果迭代结束，则done返回true否则返回false。\\n\\n```js\\n        const arr = [\\\"a\\\",\\\"b\\\",\\\"c\\\"];\\n        //Array Iterator {}\\n        console.log(arr[Symbol.iterator]());\\n        const it = arr[Symbol.iterator]();\\n        //{value: \\\"a\\\", done: false}\\n        console.log(it.next());\\n        //{value: \\\"b\\\", done: false}\\n        console.log(it.next());\\n        //{value: \\\"c\\\", done: false}\\n        console.log(it.next());\\n        //{value: undefined, done: true}\\n        console.log(it.next());\\n```\\n### 迭代协议\\n迭代协议分为两个：可迭代协议、迭代器协议。\\n\\n**可迭代协议**：定义迭代行为的协议，一个对象本身或原型链上存在一个可以通过Symbol.iterator调用的iterator属性，那么这个对象就是可迭代对象。\\n\\n**迭代器协议**：定义了迭代器的迭代方式，调用next()方法，返回对应结构。\\n### 内置可迭代对象\\n自身或原型链上存在Symbol.iterator方法的对象被称为可迭代对象，自身或原型链本就内置Symbol.iterator方法的对象被称为内置可迭代对象。\\n常见的内置可迭代对象：\\n- Array\\n- string\\n- Set\\n- Map\\n- 类数组对象\\n\\n这块不清楚的可以阅读往期文章：[ Set、Map、类数组，傻傻区分不清楚？](https://juejin.cn/post/7171837653493481509)\\n\\n## 生成器\\n生成器允许我们创建一个可以自动维护自己的状态的迭代函数，它是可迭代对象也是迭代器。\\n### 生成器函数的特点：\\n生成器通过 **function*** 创建，和普通函数相比它多了一个 * ,调用生成器函数时它不会执行任何代码，仅会返回一个叫 Generator 的迭代器，可以按迭代器协议进行迭代。\\n\\n```js\\n        function* fun() {\\n           console.log(1);\\n        }\\n        fun();//不执行内部打印\\n        \\n        //1\\n        //{value: undefined, done: true}\\n        console.log(fun().next());\\n```\\n\\n生成器函数多次调用该函数，每次都会返回一个新的 Generator，每个 Generator 仅可以迭代一次。\\n### yield 表达式\\n生成器函数中可以书写**yield** 表达式用来定义函数的内部状态， Generator会指向这个状态。\\n\\n```js\\n        function* fun() {\\n            console.log(1)\\n            yield 'a'\\n            console.log(2)\\n            yield 'b'\\n            console.log(3)\\n            yield 'c'\\n        }\\n        const g = fun()\\n        //1\\n        // {value: \\\"a\\\", done: false}\\n        console.log(g.next());\\n        //2\\n        // {value: \\\"b\\\", done: false}\\n        console.log(g.next());\\n        //3\\n        // {value: \\\"c\\\", done: false}\\n        console.log(g.next());\\n   \\n        // {value: undefined, done: true}\\n        console.log(g.next());\\n```\\n### next传参\\nnext 方法可以传入参数，传入的参数会作为上一步yield的返回值。\\n\\n```js\\n        function* fun() {\\n            console.log(\\\"start\\\")\\n            const a = yield 'a'\\n            console.log(a)\\n            const b = yield 'b'\\n            console.log(b)\\n            const c = yield 'c'\\n            console.log(c)\\n        }\\n        const g = fun()\\n        //start\\n        // {value: \\\"a\\\", done: false}\\n        console.log(g.next(\\\"d\\\"));\\n        \\n        //e\\n        // {value: \\\"b\\\", done: false}\\n        console.log(g.next(\\\"e\\\"));\\n        \\n        //f\\n        // {value: \\\"c\\\", done: false}\\n        console.log(g.next(\\\"f\\\"));\\n        \\n        //g\\n        // {value: undefined, done: true}\\n        console.log(g.next(\\\"g\\\"));\\n```\\n看一下上面这段代码，可能不是那么好理解，可以多捋捋。\\n\\n第一次给next()传的参数是\\\"d\\\"，但是上一步没有yield，也没有打印，打印start，value为\\\"a\\\",done为false；\\n\\n第二次给next()传的参数是\\\"e\\\"，上一步存在yield，打印\\\"e\\\"，value为\\\"b\\\",done为false；\\n\\n第三次给next()传的参数是\\\"f\\\"，上一步存在yield，打印\\\"f\\\"，value为\\\"c\\\",done为false；\\n\\n第四次给next()传的参数是\\\"g\\\"，上一步存在yield，打印\\\"g\\\"，此时不存在yield，value为undefined，done为true，结束迭代；\\n### return方法\\n当生成器函数使用return方法时，会返回其携带的参数，同时结束Generator。\\n\\n```js\\n         function* fun() {\\n            console.log(1)\\n            yield 'a'\\n            console.log(2)\\n            yield 'b'\\n            console.log(3)\\n            yield 'c'\\n        }\\n        const g = fun()\\n        //1\\n        // {value: \\\"a\\\", done: false}\\n        console.log(g.next());\\n        \\n        // {value: \\\"return\\\", done: true}\\n        console.log(g.return(\\\"return\\\"));\\n     \\n        // {value: undefined, done: true}\\n        console.log(g.next());\\n   \\n        // {value: undefined, done: true}\\n        console.log(g.next());\\n```\\n### yield* 表达式\\n\\nyield* 会返回一个迭代器对象，相当于在Generator内部再调用另一个Generator。\\n\\n```js\\n         function* fun() {\\n            yield 'a';\\n            yield 'b';\\n            yield 'c';\\n        }\\n        function* fun1() {\\n            yield* fun();\\n            \\n        }\\n        const g = fun1()\\n        \\n        // {value: \\\"a\\\", done: false}\\n        console.log(g.next());\\n        \\n        // {value: \\\"b\\\", done: false}\\n        console.log(g.next());\\n     \\n        // {value: \\\"c\\\", done: false}\\n        console.log(g.next());\\n   \\n        // {value: undefined, done: true}\\n        console.log(g.next());\\n```\\n## 为什么要使用迭代器、生成器？\\n大家都知道在JavaScript中，遍历的方法很多：遍历数组的for循环、遍历Set、Map的forEach、遍历对象的for...in等。那为什么要再加一个迭代器呢？\\n迭代器是一个统一的遍历方法，无论是数组、字符串还是Set、Map只要是可迭代对象都可以用它遍历。\\n\\n当然，next()方法过于繁琐，需要频繁调用，我们通常会使用for...of来进行遍历，可以使用for...of的必定是可迭代对象。\\n\\n使用生成器函数可以将一个**不可迭代的对象变成一个可迭代对象**：\\n\\n```js\\n        const obj = {};\\n\\n        obj[Symbol.iterator] = function* () {\\n            yield \\\"a\\\";\\n            yield \\\"b\\\";\\n            yield \\\"c\\\";\\n        };\\n        for (const value of obj) {\\n            \\n            //a\\n            //b\\n            //c\\n            console.log(value);\\n        }\\n```\\n\\n",
        "tags": [
            "前端",
            "掘金·日新计划",
            "JavaScript"
        ]
    },
    {
        "article_id": "7158393635828924429",
        "cover_image": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36183f199ae842c4bacf4abb50021104~tplv-k3u1fbpfcp-watermark.image?",
        "title": "记一次pr经历，我成为了vite的contributor",
        "brief": "今天一个朋友来问我一个关于vite的问题。通过解决这个问题我成为了vite的contributor。",
        "user_name": "猪猪爱前端",
        "view_count": 2830,
        "collect_count": 30,
        "comment_count": 15,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/bdc95d8ec7a570042b06e2d94aaaf8d4~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: orange\\n---\\n## 问题引入\\n**先附上pr链接**: [点我进入](https://github.com/vitejs/vite/pull/10427) \\n\\n今天一个朋友来问我一个关于`vite`的`预构建`问题: `为什么要设置插件对预构建的入口文件进行重导出？`\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/74626965fbd24915993e43d41f6d98fa~tplv-k3u1fbpfcp-watermark.image?)\\n如果你没了解过`vite`可能不太清楚这个问题是什么意思。所以我们先简单讲解一下`vite的预构建原理`，然后加深对这个问题的理解。\\n## vite依赖预构建\\n- `介绍`: 我们知道`vite`之所以能够做到`毫秒级热更新`、`快速冷启动`、`按需编译`、`无需等待`编译执行完成才能启动项目，一方面归功于浏览器对于模块化的支持，可以通过`<script type=\\\"module\\\"></script>`支持模块化的导入。而另一方面的自然归功于对于第三方模块的依赖预构建。\\n- `功能`: 为什么`vite`需要`依赖预构建`呢？ 它的主要功能有两个。\\n1. 我们知道浏览器支持的模块化，只支持`ESModule`、对于`CJS规范`是不支持的，但是某些第三方库发布采用的可能是`UMD、CJS`。这样将会造成浏览器无法识别，所以预构建的第一个作用就是`转化非ESM规范的第三方依赖为ESM规范`。\\n2. 如果你在项目中采用了原生的ESM支持，那么浏览器监测到一个`import语句`将会向`服务器`发送一个`请求`，如果我们不采用`esbuild`进行`预构建打包`，而你又在使用`类似loadsh`这样分割成`几十个甚至上百个文件`的第三方库，那么就会发送`几百个http`请求。而浏览器最多只支持`同时`发送`六个http`请求，这样就会造成页面显示缓慢。所以`vite`需要对第三方依赖进行预构建打包。\\n- 为了让大家理解依赖预构建的源码实现，这里我通过几行代码简单解释:\\n1. `对入口文件进行依赖扫描`: 这个插件意思很简单，过滤掉相对路径，找到第三方包的包名放入依赖数组中，当然了，我这个只是最简单的处理。\\n```js\\n//下面我们假设入口文件为index.js\\nconst {build} = require(\\\"esbuild\\\")\\n//用于存放扫描到的第三方依赖包名称\\nconst deps = []\\nfunction depScanPlugin(deps){\\n  return {\\n    name:'esbuild-plugin-dep-scan'\\n    setup(build){\\n      //不能以.开头 \\\"./index.js\\\"不行\\n      //\\\"react\\\"可以\\n      build.onResolve({filter:/^[^\\\\.]/},({path})=>{\\n        //将收集到的路径放入deps中即可\\n        deps.push(path)\\n        return {\\n          path\\n        }\\n      })\\n    }\\n  }\\n}\\n//进行依赖扫描\\nbuild({\\n  //依赖预构建扫描不需要写入文件\\n  write:false,\\n  entryPoints:[\\\"./index.js\\\"],\\n  plugins:[depScanPlugin(deps)]\\n})\\n```\\n2. 然后将获取的数组进行预构建打包。`特别提示: 对于esbuild来说，如果你正在打包第三方库，那么你只需要在entryPoints中指定包名就可以了`。\\n```js\\nconst path = require('path')\\nbuild({\\n  entryPoints:deps,\\n  witre:true,\\n  bundle:true,\\n  format:\\\"esm\\\",\\n  outfile:path.resolve(\\n    process.cwd(),\\n    \\\"./node_modules/.vite/deps_temp\\\"\\n  ),\\n  splitting:true,\\n})\\n```\\n- 这样我们就完成了**vite的依赖预构建**。是的，依赖预构建的**核心**就是这么简单。但是如果说引入的第三方包是`import package from \\\"react-dom/client\\\"`这样的形式呢？那是不是说，我们在deps中收集到的就应该是`[\\\"react-dom/client\\\"]`了，如果这样直接传递给`esbuild`能不能打包呢？答案是肯定的，但是这将会导致产物目录的非扁平化。但是我们又希望打包出来的`产物`应当是`扁平化`的。例如:`\\\"react-dom/client\\\"`打包后应该生成`react-dom_client.js`文件。这该如何解决呢？\\n```js\\nbuild({\\n  entryPoints:['react'],\\n  outdir:'./dist'\\n})\\n/*\\n  这样打包出的产物结构将会是\\n  -dist\\n   -react.js\\n*/\\nbuild({\\n  entryPoints:['react-dom/client'],\\n  outdir:'./dist'\\n})\\n/*\\n  这样打包出的产物结构将会是\\n  -dist\\n   -react-dom\\n    -client.js\\n*/\\n```\\n- 要解决这个问题，首先要知道`esbuild`产物结构跟什么有关系。显然他跟`entryPoints`中传递的包有密切关系。如果传递一个不含有`/`字符的包那么它将是`扁平化`的。但是如果含有`/`那么就是`非扁平化`的。那么我们设想一下假如我给`entryPoints`中传递的`\\\"react-dom/client\\\"`变成`\\\"react-dom_client\\\"`。这不就可以了吗？但是这会导致`esbuild无法识别这个路径`。那就写插件吧！\\n1. 我们先将收集到的依赖进行扁平化处理，然后找到这个第三方包的真实位置，将扁平化后的名称与真实位置做映射。\\n```js\\n//假设这是收集到的依赖\\nconst deps = ['react-dom/client',...其他依赖]\\nconst flattenDeps = new Array(deps.length)\\nconst flattenDepsMapEntries = {}\\nconst depEntries = new Array(deps.length)\\nfunction flattenId(id){\\n  return id.replace(/\\\\//g,\\\"_\\\")\\n}\\nconst getEntry = ()=>{/*省略它的实现*/}\\ndeps.forEach(dep=>{\\n  if(dep.includes(\\\"/\\\")){\\n    //获取这个包的入口文件路径\\n    const entry = getEntry(dep),\\n    //扁平化路径\\n    const flattenDep = flattenId(dep)\\n    flattenDeps.push(flattenDep)\\n    flattenDepsMapEntries[flattenDep] = entry\\n  }\\n})\\n//flattenDeps = [\\\"react-dom_client\\\"]\\n//flattenDepsMapEntries = {\\\"react-dom_client\\\":'入口路径'}\\n```\\n2. 我们在写一个`esbuild`的插件进行处理: 因为`esbuild`无法识别`\\\"react-dom_client\\\"`这样的路径，所以我们在这个插件内部将这样的路径处理为`入口绝对路径`，然后交给`esbuild`，`esbuild`就能识别了。\\n```js\\nfunction preBundlePlugin(flattenDepsMapEntries){\\n  return {\\n    name:\\\"esbuild-plugin-pre-bundle\\\",\\n    setup(build){\\n      //接受所有的路径\\n      build.onResolve(\\n        {filter:/.*/},\\n        ({path,importer})=>{\\n         //没有importer表示是顶层模块，也就是传递\\n         //的flattenDeps\\n         if(!importer){\\n           const entry = flattenDepsMapEntries[path]\\n           if(entry){\\n             return {path:entry}\\n           }\\n         }\\n         return {path}\\n      })\\n    }\\n  }\\n}\\n```\\n3. 应用这个插件\\n```diff\\nconst path = require('path')\\nbuild({\\n  entryPoints:deps,\\n  witre:true,\\n  bundle:true,\\n  format:\\\"esm\\\",\\n  outfile:path.resolve(\\n    process.cwd(),\\n    \\\"./node_modules/.vite/deps_temp\\\"\\n  ),\\n  splitting:true,\\n+ plugins:[preBundlePlugin(flattenDepsMapEntries)]\\n})\\n```\\n- 那么到这里，你是不是就以为这个问题`完美解决`了呢？实际上`esbuild`又开始作妖了。我们刚才返回的路径是一个绝对路径，那么对于esbuild来说，你这样做就相当于`entryPoints:[\\\"入口绝对路径\\\"]`，也就是说你传递了一个`E://xxx//xxx//node_modules/react-dom/client.js`这样的路径给它，这样做的结果就是它生成的产物结构依旧是非扁平化的。这个插件相当于无效了。那又该怎么办呢？\\n\\n1. 那该如何破坏他的产物生成结构呢？创建虚拟模块。\\n2. 我们在`onLoad钩子`中自己去读取文件，然后返回里面的内容。那么`esbuild`就将会当做这是一个`代理模块`，这样打包出来的`产物`就将与`路径无关`。而是使用传递的文件名。例如`\\\"react-dom/client=>client.js\\\"`。\\n```diff\\nfunction preBundlePlugin(flattenDepsMapEntries){\\n  return {\\n    name:\\\"esbuild-plugin-pre-bundle\\\",\\n    setup(build){\\n      //接受所有的路径\\n      build.onResolve(\\n        {filter:/.*/},\\n        ({path,importer})=>{\\n         //没有importer表示是顶层模块，也就是传递\\n         //的flattenDeps\\n         if(!importer){\\n           const entry = flattenDepsMapEntries[path]\\n           if(entry){\\n             return {\\n              path:entry,\\n+            namespace:\\\"dep\\\"\\n             }\\n           }\\n         }\\n         return {path}\\n      })\\n+      build.onLoad({filter:/.*/,namespace:\\\"dep\\\"},async ({path})=>{\\n+        return {\\n+          contents:await fs.promises.readFile(path,\\\"utf-8\\\"),\\n+          loader:\\\"js\\\",\\n+          resolveDir:process.cwd()\\n+        }\\n+     })\\n    }\\n  }\\n}\\n```\\n- 好了，但是你以为到这里就结束了吗？ 不不不，这才是本文的关键之处。假设现在找到的依赖有两个，`react-dom、scheduler`,我们知道`react-dom`依赖`scheduler`，而我们都做了代理模块，那么对于打包`scheduler`的时候，作为代理模块打包、在`react-dom`中会遇到`import {} from \\\"scheduler`这样的语句，而这里的`scheduler`将和`代理模块`没有任何关系，这就会导致打包`两次`。\\n- 我们来理理思绪，首先因为产物不是扁平化的，所以我们改变`entryPoints:deps=>flattenDeps`，但是这样没有效果，所以创建`代理模块`，断开`esbuild`自己的处理逻辑，作为一个全新的模块打包。但是这样会导致二次打包。这又该怎么办呢？\\n- 方法也很简单。我们改造`代理模块`，在打包`react-dom`的时候会遇到`import {} from \\\"scheduler`这个语句。那么我们修改`代理模块`内容。也让他去引入，然后重导出。但是我怎么知道`scheduler`暴露了那些方法呢？这就需要用到`es-module-lexer`，这个库可以分析文件的`import`和`export`语句。**我们只需要用这个库去分析包的入口文件就能得到导出了那些文件。就可以改造代理模块了**。\\n```js\\n//假设A库导出了a方法\\n//重导出代码\\nimport {a} from \\\"A\\\"\\nexport {a}\\n```\\n- 这样做就相当于`代理模块`也去引入了`scheduler`模块，`react-dom`也是引入了`scheduler`，这样就让`scheduler`摆脱了代理模块的限制。\\n- 我们看看源码中对于这一段代码的解释：`对于入口文件，我们将会读取他本身，然后构造一个代理模块来保留原始id而不是使用文件路径。以便esbuild输出所需的输出文件结构。有必要重新导出以将虚拟代理模块与实际模块分离，因为实际模块可能会通过相对导入引用-如果我们不分离代理和实际模块，esbuild将创建相同的副本单元`。\\n```js\\n// For entry files, we'll read it ourselves and construct a proxy module\\n// to retain the entry's raw id instead of file path so that esbuild\\n// outputs desired output file structure.\\n// It is necessary to do the re-exporting to separate the virtual proxy\\n// module from the actual module since the actual module may get\\n// referenced via relative imports - if we don't separate the proxy and\\n// the actual module, esbuild will create duplicated copies of the same\\n// module!\\nconst root = path$n.resolve(config.root);\\nbuild.onLoad({ filter: /.*/, namespace: \\\"dep\\\" }, ({ path: id }) => {\\n  const entryFile = qualified[id];\\n  let relativePath = normalizePath$3(path$n.relative(root, entryFile));\\n  if (\\n    !relativePath.startsWith(\\\"./\\\") &&\\n    !relativePath.startsWith(\\\"../\\\") &&\\n    relativePath !== \\\".\\\"\\n  ) {\\n    relativePath = `./${relativePath}`;\\n  }\\n  let contents = \\\"\\\";\\n  const { hasImports, exports, hasReExports } = exportsData[id];\\n  if (!hasImports && !exports.length) {\\n    // cjs\\n    contents += `export default require(\\\"${relativePath}\\\");`;\\n  } else {\\n    if (exports.includes(\\\"default\\\")) {\\n      contents += `import d from \\\"${relativePath}\\\";export default d;`;\\n    }\\n    if (hasReExports || exports.length > 1 || exports[0] !== \\\"default\\\") {\\n      contents += `\\\\nexport * from \\\"${relativePath}\\\"`;\\n    }\\n  }\\n  return {\\n    loader: \\\"js\\\",\\n    contents,\\n    resolveDir: root,\\n  };\\n});\\n```\\n- 可以发现，对于一些功能的实现，真的是很精妙，虽然改不了`esbuild`的源码，但是利用他的特性就是可以绕开这些问题，直达中心。\\n## 对vite源码的修改\\n- 有了上面的铺垫，相信你就能很轻易的理解文章开头提出的问题了。`他想表达的就是他发现直接更改路径并不会出现二次打包问题`。\\n```js\\nfunction preBundlePlugin(flattenDepsMapEntries){\\n  return {\\n    name:\\\"esbuild-plugin-pre-bundle\\\",\\n    setup(build){\\n      //接受所有的路径\\n      build.onResolve(\\n        {filter:/.*/},\\n        ({path,importer})=>{\\n         //没有importer表示是顶层模块，也就是传递\\n         //的flattenDeps\\n         if(!importer){\\n           const entry = flattenDepsMapEntries[path]\\n           if(entry){\\n             return {path:entry}\\n           }\\n         }\\n         return {path}\\n      })\\n    }\\n  }\\n}\\n```\\n- 例如在插件当中直接这样硬核改变路径，`esbuild依然不会使用返回的文件路径作为输出目录`，他与传递的`entryPoints强相关`。例如传递的`entryPoints:[\\\"react-dom_client\\\"]`那么无论如何在`onResolve`中修改路径最终产生的文件都是`react-dom_client.js`。这就有意思了，那么这就意味着`代理模块的存在是没有必要的`。我测试了这种情况下是否会出现二次打包的问题，答案是并不会。想想这确实符合常规思维逻辑，在一个第三方模块内引入另外一个第三方模块，`本质上还是要解析另外一个第三方模块的入口文件，而我在onResolve钩子中将这个路径改成与另外一个第三方模块的入口路径相同，那么他们就应该是同一个模块所以不应该被打包两次`。\\n- 但是这样就不能解释，为什么作者要大费周章的搞这么复杂的东西呢？我的心中出现了两种可能：\\n1. **我理解这部分的源码出错了，作者这样做并不是我理解的这个意思**。\\n2. **因为某种原因导致作者当时不得不这么做**。\\n- 对于第一种情况，我实在是想不到，还有没有其他什么可能。那到底是什么原因导致作者当时不得不那么做呢？明明有更简单的方法。**我突然想到了，有没有可能是版本问题。**`vite`**的初始版本是在几年前开发的。那么那个时候的**`esbuild`**版本就不会是现在这个版本，那会不会当时的**`esbuild`**并不能像现在这样智能以至于它并不能识别上述情况，所以一定会二次打包所以不得不使用重导出来处理这个问题**。\\n- 有了这样的思路，我立刻下载了`老版本的esbuild`进行测试。测试结果如下:\\n```js\\n//0.8.34版本(两年前)\\nconst {build} = require(\\\"esbuild\\\")\\nconst path = require('path')\\nbuild({\\n  entryPoints:[\\\"react-dom\\\",\\\"myScheduler_jsx\\\"],\\n  plugins:[\\n   {\\n     name:\\\"resolveMyScheduler\\\",\\n     setup(build){\\n       build.onResolve({filter:/myScheduler_jsx/},()=>{\\n         return {\\n           path:path.resolve(\\n             process.cwd(),\\n             \\\"./node_modules/scheduler/cjs/scheduler.development.js\\\"\\n           )\\n         }\\n       })\\n     }\\n   }\\n  ]\\n})\\n```\\n- 打包结果显示:`果然两年前的版本直接修改路径会出现非扁平化产物`。\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22b2cec5dc0e4b718fdfdb5f2d540e42~tplv-k3u1fbpfcp-watermark.image?)\\n- 我们继续添加代理模块处理，观察添加`代理模块后`是不是就`不出现非扁平化产物了`。\\n```diff\\n//0.8.34版本(两年前)\\nconst {build} = require(\\\"esbuild\\\")\\nconst path = require('path')\\nbuild({\\n  entryPoints:[\\\"react-dom\\\",\\\"myScheduler_jsx\\\"],\\n  plugins:[\\n   {\\n     name:\\\"resolveMyScheduler\\\",\\n     setup(build){\\n       build.onResolve({filter:/myScheduler_jsx/},()=>{\\n         return {\\n           path:path.resolve(\\n             process.cwd(),\\n             \\\"./node_modules/scheduler/cjs/scheduler.development.js\\\"\\n           ),\\n+         namespace:'dep'\\n         }\\n       })\\n+     build.onLoad({filter:/.*/,namespace:'dep'},({path:p})=>{\\n+       return {\\n+         contents:await fs.promises.readFile(p,\\\"utf-8\\\"),\\n+         loader:'js',\\n+         resolveDir:path.dirname(p)\\n+       }\\n+     })\\n     }\\n   }\\n  ]\\n})\\n```\\n- 显然，确实通过代理模块，产物变成了扁平化结构。\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6de8b219e007440c8fc379b0aebd457e~tplv-k3u1fbpfcp-watermark.image?)\\n\\n- 最后我们测试`最新版本的esbuild`。\\n```js\\n//0.15.10(当前版本)\\nconst {build} = require(\\\"esbuild\\\")\\nconst path = require('path')\\nbuild({\\n  entryPoints:[\\\"react-dom\\\",\\\"myScheduler_jsx\\\"],\\n  plugins:[\\n   {\\n     name:\\\"resolveMyScheduler\\\",\\n     setup(build){\\n       build.onResolve({filter:/myScheduler_jsx/},()=>{\\n         return {\\n           path:path.resolve(\\n             process.cwd(),\\n             \\\"./node_modules/scheduler/cjs/scheduler.development.js\\\"\\n           )\\n         }\\n       })\\n     }\\n   }\\n  ]\\n})\\n```\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee1081d7eb774dbc9cb269beee9ba01a~tplv-k3u1fbpfcp-watermark.image?)\\n\\n- 产物依旧是`扁平化`的，并且与传递的`entryPoints属性`成`强相关`。\\n- 好啦！终于弄清楚了为什么作者当初一定要用代理模块和重导出来处理。那么这个结果也表明，`目前的vite不再需要代理模块和重导出了，这部分的代码可以删除`。得到这个结果后，我立刻向`vite`提交了这个`pr`。\\n\\n<img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/86d45420391b4b668275917930e600ca~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"\\\" width=\\\"100%\\\" />\\n\\n最终巨佬`patak`对这个`pr`进行了`merge`。还送上了❤。\\n\\n<img src=\\\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fd27c73f65b848ab96c14a13d0403922~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"\\\" width=\\\"50%\\\" />\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
        "tags": [
            "前端",
            "Vue.js",
            "JavaScript"
        ]
    },
    {
        "article_id": "7193896470536257593",
        "cover_image": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/392a5a80d070482eb3b7637459942ff2~tplv-k3u1fbpfcp-watermark.image?",
        "title": "LogicFlow插件用前准备",
        "brief": "LogicFlow 是一款流程图编辑框架，提供了一系列流程图交互、编辑所必需的功能和灵活的节点自定义、插件等拓展机制。LogicFlow支持前端研发自定义开发各种逻辑编排场景，如流程图、ER图、BPM",
        "user_name": "小鑫同学",
        "view_count": 641,
        "collect_count": 1,
        "comment_count": 1,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/5ead43b3213f176d5ab1e30432149b4d~300x300.image",
        "category": "前端",
        "content": ">🎄Hi~ 大家好，我是小鑫同学，一位长期从事前端开发的编程爱好者，我将使用更为实用的案例输出更多的编程知识，同时我信奉分享是成长的唯一捷径，在这里也希望我的每一篇文章都能成为你技术落地的参考~\\n\\n### 专栏目录：\\n1. [LogicFlow安装与准备工作](https://juejin.cn/post/7186422818916007996) \\n2. [LogicFlow自定义业务节点](https://juejin.cn/post/7186800549293981753) \\n3. [LogicFlow自定义边（Edge）](https://juejin.cn/post/7187171903952879674)  \\n4. [LogicFlow更多配置选项](https://juejin.cn/post/7187535095392600121)  \\n5. [LogicFlow插件用前准备](https://juejin.cn/post/7193896470536257593)  \\n6. [LogicFlow内置插件使用](https://juejin.cn/post/7193896646357286970)  \\n7. [LogicFlow内置菜单插件](https://juejin.cn/post/7193898053026676792) \\n\\n## 🚀技术&代码分享\\n- 我在 [IT200](https://it200.cn/) 总结技术学习；\\n- 我在 [1024Code](https://1024code.com/5bCP6ZG) 在线编写代码；\\n- 我在 [掘金](https://juejin.cn/user/3966693685871694) 分享技术文章；\\n- 我在 [Github](https://github.com/OSpoon) 参与开源学习；\\n\\n## 😇推荐几个好用的工具\\n- [var-conv](https://github.com/OSpoon/var-conv) 适用于VSCode IDE的代码变量名称快速转换工具\\n- [generator-vite-plugin](https://github.com/OSpoon/generator-vite-plugin) 快速生成Vite插件模板项目\\n- [generator-babel-plugin](https://github.com/OSpoon/generator-babel-plugin) 快速生成Babel插件模板项目\\n\\n## 进入正题\\n\\n>LogicFlow 是一款流程图编辑框架，提供了一系列流程图交互、编辑所必需的功能和灵活的节点自定义、插件等拓展机制。LogicFlow支持前端研发自定义开发各种逻辑编排场景，如流程图、ER图、BPMN流程等。在工作审批配置、机器人逻辑编排、无代码平台流程配置都有较好的应用。\\n\\n这一节将讲解快速上手 LogicFlow 流程图编辑框架的插件用前准备工作，项目整体基于[Vue3+Vite3+Ts4](https://1024code.com/codecubes/0z9xIZl)开发，为帮助还为熟练使用 Vue3 和 Typescript 语法的小伙伴提供便利，如果你已经很熟练在Vue3中的开发习惯，建议直接访问 [LogicFlow](http://logic-flow.org/) 将获取完整的入门指南。\\n\\n## 1. 安装插件扩展模块：\\n\\n当你真的需要用到插件的功能时可以安装下面这个模块，每个模块各司其职：\\n```shell\\nnpm i @logicflow/extension\\n```\\n\\n## 2. 注册插件到全局或实例\\n插件的注册分为两种，分别是**注册到全局**和**注册到实例**，这个就需要按你业务的实际需要来设置了：\\n\\n- 注册到全局：将如下的代码安装到 `Vue` 的 `main.ts` 入口文件中即可\\n```typescript\\nimport { BpmnElement } from '@logicflow/extension';\\nLogicFlow.use(BpmnElement);\\n```\\n\\n- 注册到实例：将扩展包在LF对象实例化后，将需要用到的插件通过 `plugins` 注册\\n```typescript\\nimport LogicFlow from \\\"@logicflow/core\\\";\\nimport { DndPanel, SelectionSelect, Group } from \\\"@logicflow/extension\\\";\\nimport \\\"@logicflow/core/dist/style/index.css\\\";\\nimport \\\"@logicflow/extension/lib/style/index.css\\\";\\n\\nconst lf = new LogicFlow({\\n  container: document.querySelector(\\\"#app\\\"),\\n  grid: true,\\n  plugins: [DndPanel, SelectionSelect, Group]\\n});\\n```\\n\\n## 总结\\n\\n这一节的内容就到此结束了，本小节内容简单，主要是为了提供一份可以为后续内置插件和自定义插件的使用提供一份可以**fork**的代码仓库，本节源码将使用注册到实例的方式操作，搞定后就马上要开始插件部分的学习了~\\n\\n---\\n\\n如果看完觉得有收获，欢迎点赞、评论、分享支持一下。你的支持和肯定，是我坚持写作的动力~\\n\\n",
        "tags": [
            "前端",
            "Vue.js",
            "TypeScript"
        ]
    },
    {
        "article_id": "7195079975567884349",
        "cover_image": "https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c32b8eafc1c42aea4b76092045f3083~tplv-k3u1fbpfcp-watermark.image?",
        "title": "Java基础-变量默认值",
        "brief": "变量默认值 之前我们说实例变量都有一个默认值，如果希望修改这个默认值，可以在定义变量的同时就赋值，或者将代码放入初始化代码块中，代码块用{}包围，如下所示： int x = 1; int y; {  ",
        "user_name": "爱敲代码的小杨同学",
        "view_count": 1094,
        "collect_count": 0,
        "comment_count": 0,
        "avatar": "https://p3-passport.byteacctimg.com/img/mosaic-legacy/3797/2889309425~300x300.image",
        "category": "后端",
        "content": "变量默认值\\n\\n之前我们说实例变量都有一个默认值，如果希望修改这个默认值，可以在定义变量的同时就赋值，或者将代码放入初始化代码块中，代码块用{}包围，如下所示：\\n\\nint x = 1;\\n\\nint y;\\n\\n{\\n\\n    y = 2;\\n\\n}\\n\\nx的默认值设为了1，y的默认值设为了2。在新建一个对象的时候，会先调用这个初始化，然后才会执行构造方法中的代码，关于构造方法，我们稍后介绍。\\n\\n静态变量也可以这样初始化：\\n\\nstatic int STATIC_ONE = 1;\\n\\nstatic int STATIC_TWO;\\n\\nstatic\\n\\n{\\n\\n    STATIC_TWO = 2;\\n\\n}\\n\\nSTATIC_TWO=2；语句外面包了一个static{}，这叫静态初始化代码块。静态初始化代码块在类加载的时候执行，这是在任何对象创建之前，且只执行一次。\\n\\n[]https://www.bilibili.com/video/BV1ss4y1x76u/?spm_id_from=333.999.0.0(url)",
        "tags": [
            "后端",
            "Java",
            "程序员"
        ]
    },
    {
        "article_id": "7190160289617150008",
        "cover_image": "https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/890217d92ab44b1c8099f95a43327ae5~tplv-k3u1fbpfcp-watermark.image?",
        "title": "5分钟学会！antd5自研的css-in-js的定制主题原理",
        "brief": "本文将介绍antd5的自研cssinjs的架构的核心原理，5分钟，深入组件库源码，理解并学习其思想，你甚至可以自己手写一个。",
        "user_name": "谦宇",
        "view_count": 677,
        "collect_count": 8,
        "comment_count": 2,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/34daf308526b4f8cee0a19b5c7bc1d31~300x300.image",
        "category": "前端",
        "content": "## 前言\\n\\nantd4以前的版本用less的变量来实现多套less模板，来渲染主题。局限性很大，所以antd5做了新的官方的css-in-js的主题实现，来控制更复杂的主题业务场景，接着我会展示源码细节并深入学习。\\n\\n## 我的理解\\n\\n按我的理解css-in-js就是将通过序列化css的属性名来实现css的模块化，所以你会看到webpack可以编译module.css的文件来隔离, 包括其他emotion、styled-components的cssinjs的方案的大放异彩，js控制样式自然灵活度极高，所以你几乎看不到css文件，但是同时你的项目内会有大量的js的编译代码，说白了打包出来的js文件会很大。antd5区别于其他方案，做了各种`缓存`，以及更可控的`组件级别的控制`，`相比性能对于组件库的层面是要优于其他css-in-js的方案的`。\\n\\n## 源码\\n\\n首先在任意一个antd5的component中你可以看到这段代码，useStyle返回的wrapSSR和hashId，hashId会被用于classNames的序列化样式属性中，那么重点是wrapSSR这个函数，函数传入了react的元素节点，大概率也能想到传入的节点要混入style对象。\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a448d7be59bc40ce8faabc3709bb321f~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9acb831ded464d1e95024801e8d93ec7~tplv-k3u1fbpfcp-watermark.image?)\\n\\n```ts\\n//./style/index.tsx\\nexport default genComponentStyleHook('Collapse', (token) => {\\n  const collapseToken = mergeToken<CollapseToken>(token, {\\n    collapseContentBg: token.colorBgContainer,\\n    collapseHeaderBg: token.colorFillAlter,\\n    collapseHeaderPadding: `${token.paddingSM}px ${token.padding}px`,\\n    collapsePanelBorderRadius: token.borderRadiusLG,\\n    collapseContentPaddingHorizontal: 16, // Fixed value\\n  });\\n    \\n  //返回的是一个通过js对象描述的一个样式表\\n  return [\\n    genBaseStyle(collapseToken),\\n    genBorderlessStyle(collapseToken),\\n    genGhostStyle(collapseToken),\\n    genArrowStyle(collapseToken),\\n    genCollapseMotion(collapseToken),\\n  ];\\n});\\n```\\n你会看到在每个组件的styles文件夹都会有一个genComponentStyleHook的api，第一个就是组件标识肯定会用来做属性的区分等，第二个是一个回调传入的token是一个样式配置对象，所以重点是这个token对象的样式配置，`这个token你可以理解为可以切换不同优先级的配置对象，可以覆盖原有的样式，你可以把它想象成一个主题变量，控制所有的组件对应的样式修改，也可以对单个组件的某个样式属性修改`。\\n\\n第二个参数回调其实是StyleFn，是控制整个组件主题的核心函数。这里简单看下源码genBaseStyle、genBorderlessStyle等做了什么\\n\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9bfd199e4ff84b8585d675673147c574~tplv-k3u1fbpfcp-watermark.image?)\\n\\n所以最终返回的是一个受token控制的js的样式对象，接下来去找genComponentStyleHook, 但是得先聊一聊token这个东西。\\n\\n### token是一个组件样式修改的变量\\n\\n   \\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/619a784741d54ebebc7baa4bb6acdf84~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bbd5073fc89447b79cd9b5c506907aad~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8bae52bd08564ae997eb7153da90a9c2~tplv-k3u1fbpfcp-watermark.image?)\\n\\n最主要的是AliasToken和ComponentTokenMap这两个类型，一个对全局所有组件的混入修改，一个是对于组件的以及组件内部的混入修改。包括附带的一些前缀用于区分组件。所以token是可以控制优先级的一个`样式配置对象`。\\n\\n## Design Token的生命周期\\n\\n一个token能玩出花了哈哈，说白了就是配置对象从`Seed Token`这个最小单位开始，组装成一个Map的主题对象，那么他会返回一个`Map Token`对应，你会看到下面从ColorPrimary变出了colorPrimaryBg和colorPrimary这两个。colorPrimaryBg是由colorPrimary派生的。为什么要有Seed Token，是因为方便设计师创造出对于的主题色，并通过算法去调和其他主题色。\\n\\n说白了Seed Token就是一个零件，而MapToken是组装零件的。那么，`Aliae Token`又是个啥，其实就是一个别名，做复用多个Map token 有共性的零件。最终影响组件主题色，那么这个派生关系或者说代码的执行流程就是Design Token的生命周期\\n\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/336ffee0cc734bd1ae2f7a5cbc0e3129~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n## genComponentStyleHook 遍历生成组件样式对象的集合\\n```ts\\nimport { useStyleRegister } from '@ant-design/cssinjs';\\n//...\\nexport default function genComponentStyleHook<ComponentName extends OverrideComponent>(\\n  component: ComponentName,\\n  styleFn: (token: FullToken<ComponentName>, info: StyleInfo<ComponentName>) => CSSInterpolation,\\n  getDefaultToken?:\\n    | OverrideTokenWithoutDerivative[ComponentName]\\n    | ((token: GlobalToken) => OverrideTokenWithoutDerivative[ComponentName]),\\n) {\\n   //注意！ 这里其实就是useStyle这个函数\\n  return (prefixCls: string): UseComponentStyleResult => {\\n    const [theme, token, hashId] = useToken();\\n    const { getPrefixCls, iconPrefixCls } = useContext(ConfigContext);\\n    const rootPrefixCls = getPrefixCls();\\n\\n    // Generate style for all a tags in antd component.\\n    useStyleRegister({ theme, token, hashId, path: ['Shared', rootPrefixCls] }, () => [\\n      {\\n        // Link\\n        '&': genLinkStyle(token),\\n      },\\n    ]);\\n\\n    return [\\n      useStyleRegister(\\n        { theme, token, hashId, path: [component, prefixCls, iconPrefixCls] },\\n        () => {\\n          const { token: proxyToken, flush } = statisticToken(token);\\n\\n          const defaultComponentToken =\\n            typeof getDefaultToken === 'function' ? getDefaultToken(proxyToken) : getDefaultToken;\\n          const mergedComponentToken = { ...defaultComponentToken, ...token[component] };\\n\\n          const componentCls = `.${prefixCls}`;\\n          const mergedToken = mergeToken<\\n            TokenWithCommonCls<GlobalTokenWithComponent<OverrideComponent>>\\n          >(\\n            proxyToken,\\n            {\\n              componentCls,\\n              prefixCls,\\n              iconCls: `.${iconPrefixCls}`,\\n              antCls: `.${rootPrefixCls}`,\\n            },\\n            mergedComponentToken,\\n          );\\n\\n          const styleInterpolation = styleFn(mergedToken as unknown as FullToken<ComponentName>, {\\n            hashId,\\n            prefixCls,\\n            rootPrefixCls,\\n            iconPrefixCls,\\n            overrideComponentToken: token[component],\\n          });\\n          flush(component, mergedComponentToken);\\n          return [genCommonStyle(token, prefixCls), styleInterpolation];\\n        },\\n      ),\\n      hashId,\\n    ];\\n  };\\n}\\n```\\n你会发现最核心的是useStyleRegister这个api返回的就是genComponentStyleHook，那么useStyle又返回就是warpssr，所以重点就是useStyleRegister，那么我们看看在`@ant-design/cssinjs`包里面useStyleRegister做了什么。\\n\\n### useStyleRegister 注册全局的样式表\\n\\n```ts\\n/**\\n * 注册全局的样式表\\n */\\nexport default function useStyleRegister(\\n  info: {\\n    theme: Theme<any, any>;\\n    token: any;\\n    path: string[];\\n    hashId?: string;\\n    layer?: string;\\n  },\\n  styleFn: () => CSSInterpolation,\\n) {\\n  const { token, path, hashId, layer } = info;\\n  const {\\n    autoClear,\\n    mock,\\n    defaultCache,\\n    hashPriority,\\n    container,\\n    ssrInline,\\n    transformers,\\n    linters,\\n  } = React.useContext(StyleContext);\\n  const tokenKey = token._tokenKey as string;\\n   \\n   //注意这里的fullPuth用于缓存查找的key，已经做很细粒度的path\\n  const fullPath = [tokenKey, ...path];\\n\\n  // 根据环境判断是否要处理样式\\n  let isMergedClientSide = isClientSide;\\n  if (process.env.NODE_ENV !== 'production' && mock !== undefined) {\\n    isMergedClientSide = mock === 'client';\\n  }\\n\\n  const [cachedStyleStr, cachedTokenKey, cachedStyleId] = useGlobalCache(\\n    'style',\\n    fullPath,\\n    // Create cache if needed\\n    () => {\\n      const styleObj = styleFn();\\n      const [parsedStyle, effectStyle] = parseStyle(styleObj, {\\n        hashId,\\n        hashPriority,\\n        layer,\\n        path: path.join('-'),\\n        transformers,\\n        linters,\\n      });\\n      const styleStr = normalizeStyle(parsedStyle);\\n      const styleId = uniqueHash(fullPath, styleStr);\\n\\n      if (isMergedClientSide) {\\n        const style = updateCSS(styleStr, styleId, {\\n          mark: ATTR_MARK,\\n          prepend: 'queue',\\n          attachTo: container,\\n        });\\n\\n        (style as any)[CSS_IN_JS_INSTANCE] = CSS_IN_JS_INSTANCE_ID;\\n\\n        // Used for `useCacheToken` to remove on batch when token removed\\n        style.setAttribute(ATTR_TOKEN, tokenKey);\\n\\n        // Dev usage to find which cache path made this easily\\n        if (process.env.NODE_ENV !== 'production') {\\n          style.setAttribute(ATTR_DEV_CACHE_PATH, fullPath.join('|'));\\n        }\\n\\n        // Inject client side effect style\\n        Object.keys(effectStyle).forEach((effectKey) => {\\n          if (!globalEffectStyleKeys.has(effectKey)) {\\n            globalEffectStyleKeys.add(effectKey);\\n\\n            // Inject\\n            updateCSS(\\n              normalizeStyle(effectStyle[effectKey]),\\n              `_effect-${effectKey}`,\\n              {\\n                mark: ATTR_MARK,\\n                prepend: 'queue',\\n                attachTo: container,\\n              },\\n            );\\n          }\\n        });\\n      }\\n\\n      return [styleStr, tokenKey, styleId];\\n    },\\n    // Remove cache if no need\\n    ([, , styleId], fromHMR) => {\\n      if ((fromHMR || autoClear) && isClientSide) {\\n        removeCSS(styleId, { mark: ATTR_MARK });\\n      }\\n    },\\n  );\\n\\n  return (node: React.ReactElement) => {\\n    let styleNode: React.ReactElement;\\n    \\n    //一个你得在非ssr服务端渲染，一个是否在client，一个外部的配置，如果不满足就返回空\\n    if (!ssrInline || isMergedClientSide || !defaultCache) {\\n      styleNode = <Empty />;\\n    } else {\\n      styleNode = (\\n        <style\\n          {...{\\n            [ATTR_TOKEN]: cachedTokenKey, //token的缓存标识\\n            [ATTR_MARK]: cachedStyleId,  //样式的缓存标识\\n          }}\\n          dangerouslySetInnerHTML={{ __html: cachedStyleStr }}\\n        />\\n      );\\n    }\\n\\n    return (\\n      <>\\n        {styleNode}\\n        {node}\\n      </>\\n    );\\n  };\\n}\\n\\n```\\n首先这里通过useGlobalCache函数，传入对应的fullPath，然后执行传入的函数，会执行前面提到过的StyleFn这个函数，styleFn执行时组件本身的样式和被合并的token就被加载到一个StyleObj对象上了。\\n\\n通过parseStyle函数传入的path、hashId、以及暴露在外的api最终解析出来的是一个内部`key都被序列化的对象`。将返回的cachedStyleStr, cachedTokenKey, cachedStyleId这三个缓存的值传入`<style>`这个标签。\\n\\n在html中，style标签是使用来定义html文档的样式信息，在该标签中你可以规定浏览器怎样显示html文档内容。那么存入了对应的token缓存标识、样式的缓存标识、以及样式的字符串，最终被解析渲染，`那么你会发现其实他的样式是运行时，同时也是组件级别的样式按需更新。`\\n\\n## 核心原理总结\\n\\n首先在组件内的useStyle传入了warpSSR和hashID，执行genComponentStyleHook，最终返回useStyleRegister这个函数并传入styleFn，核心执行useGlobalCache函数，styleFn执行时组件本身的样式和被合并的token就被加载到一个StyleObj对象上了。通过parseStyle函数传入的path、hashId、以及暴露在外的api最终解析出来的是一个被序列化的对象，最终cachedStyleStr, cachedTokenKey, cachedStyleId渲染到style标签上，这样可以让组件本身具备了更细粒度的包体积和性能。",
        "tags": [
            "Ant Design",
            "前端",
            "React.js"
        ]
    },
    {
        "article_id": "7165586370814017549",
        "cover_image": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6903fdc4807c41179f4286d0262d1d02~tplv-k3u1fbpfcp-watermark.image?",
        "title": "码上开火车-Three.js 3D Web 游戏案例分享",
        "brief": "码上开火车是一款 3D 单机策略游戏。创作这款游戏主要是为了参加 AMD 和码上掘金举办的马上掘金编程挑战赛。 现在和大家聊聊这款游戏从设计到开发这个过程的总结。",
        "user_name": "代码与野兽",
        "view_count": 2751,
        "collect_count": 72,
        "comment_count": 17,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/dac9f5ba3e7b6d8015a9b37536d4ef59~300x300.image",
        "category": "前端",
        "content": "码上开火车是一款 3D 单机策略游戏。创作这款游戏主要是为了参加 AMD 和码上掘金举办的马上掘金编程挑战赛。\\n\\n欢迎大家体验：<https://code.juejin.cn/pen/7163229245261479947>\\n\\n设计和开发这款游戏，一共花费了大概两周的业余时间。\\n\\n现在和大家聊聊这款游戏从设计到开发这个过程的总结。\\n\\n# 团队\\n\\n游戏的作者是我的独立游戏团队，一共两个人，我和 Z 哥。我主要负责策划、程序、项目管理等工作，Z 哥负责美术、模型、音乐、素材等工作。\\n\\n很多小型游戏的开发，特别是 Web 游戏，一个人都可以独立完成。不要等到团队有多少人后才开始进行开发。\\n\\n维护一个游戏团队是很难的，因为一款游戏通常是需要插图、音效、模型、程序、策划、剧情、运营等多个部分组成。维持这种团队需要各种人才，成本非常之高。而依靠游戏开发赚钱又比较难。自己做游戏，很多时候还不如直接接一些外包项目来做来钱更快。\\n\\n所以，在很早的时候我就想好了，如果以后要组织一个游戏团队，人一定要少，而且每个人都应该是一个六边形战士，具有极强的学习能力和抗压能力，可以身兼数职、独当一面。我的目标也不高，首先能赚些钱，然后做一些我们自己喜欢的、小而美的东西。\\n\\n很幸运，我遇到了 Z 哥这个技术狂。三十多岁的年纪，仍然每天下班后仍钻研数小时技术，并以一己之力将某超大型国企的信息技术部门的技术水平提升了数个档次。\\n\\n我自己也可以做一些设计方面的工作，只是没有那么多足够的经验。让专业的人负责专业的事，可以让整个团队更具有战斗力。\\n\\n# 设计\\n\\n码上开火车是一款简单的策略游戏，没有复杂的剧情，也没有管线。所以它的设计可以简单分为 UI、模型、玩法三个方面。\\n\\n## UI 设计\\n\\nUI 设计与模型设计都属于美工的范围。\\n\\n通常设计 UI 时不会从零开始设计，而是会在一些设计网站上面寻找灵感，然后模仿一些 UI 进行修改。\\n\\n可以从专业的游戏网站，比如 [indienova](https://indienova.com/) 上面找一些资源或灵感。或者从专业的设计网站上寻找图标和模型。\\n\\n## 模型设计\\n\\n通常模型也是从一些资源网站上面进行下载，然后做一些调整再进行使用。比如 [clara](https://clara.io/) 上面就有一大堆 3D 模型。\\n\\n推荐一款 gltf 格式的模型在线查看器：<https://techbrood.com/tool?p=gltf-viewer>。虽然网页的 UI 设计有一股上个世纪的感觉，但确实非常好用。\\n\\n## 玩法设计\\n\\n游戏规则设计其实挺简单的。\\n\\n第一版草图如下：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b66c5836073946fdab51c8bcf96c6b69~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n码上跑火车本质上就是一个无限循环单机游戏。\\n\\n后面又经过一系列调整，最终就是现在大家看到的效果。\\n\\n# 开发\\n\\n一款游戏采用什么技术并没有什么太大区别。特别是单机游戏，技术不是关键，可玩性才是。\\n\\n但还是要简单提一下技术。\\n\\n首先在模式上可以简单分为 2D 和 3D。2D 游戏在技术上比较简单，可以跳过建模这一步，当然 2D 游戏也可以建模。一些简单的 2D 游戏，只使用图片等资源就可以了。3D 游戏则必须使用模型，对应的还需要有一整套的渲染引擎、物理引擎、粒子系统等。相比较 2D 游戏会复杂很多。\\n\\n市面上有一些第三方的游戏引擎，会涵盖游戏设计、开发、测试、部署全流程。而大公司一般会有自己研发的游戏引擎。\\n\\n比较流行的有 [unity](https://unity.com/)、[cocos](https://www.cocos.com/)、[egret](https://www.egret.com/)、[layabox](https://www.layabox.com/) 等，这些游戏引擎通常都支持脚本语言的开发，比如 JavaScript/TypeScript，并且大多数都支持多平台构建，比如一套源码可以打包成移动端、HTML 或者微信小游戏。\\n\\n专注于 Web 游戏开发的引擎有 [createjs](https://createjs.com/) 和 [pixijs](https://pixijs.com/) 等。\\n\\n当然如果游戏足够简单的话，可以不使用游戏引擎。比如码上开火车就没有使用任何游戏引擎。它主要使用了四个主要的库/框架：\\n\\n-   three.js：负责 3D 效果呈现。\\n-   jquery：负责 DOM 操作。\\n-   preloadjs：负责资源预加载。\\n-   tailwindcss：CSS 框架。\\n\\n## 基于 jQuery 的数据响应式和组件化\\n\\n游戏场景主体是 canvas，UI 是 DOM。UI 的数量非常少，而且没有页面切换。所以完全没有必要使用像 React 这类框架，jQuery 反而更简单粗暴。\\n\\n但是 jQuery 没有数据响应式和组件化，难免在修改状态的时候同时维护 UI。\\n\\n在游戏第一版完成的时候，就是这么做的。但是继续增加功能会很累。\\n\\n所以我对它进行了简单地重构，利用 jQuery 实现了简易的数据响应式和组件化。这样更新数据后不再需要关注 UI 的变化。\\n\\n```js\\nclass Reactivity {\\n  constructor({ state, updateCallback } = {}) {\\n    this.state = state;\\n    this.updateState = this.updateState.bind(this)\\n    this.updateCallback = updateCallback\\n    this.initUpdate()\\n    this.bindEvents()\\n  }\\n\\n  updateState(key, value) {\\n    if (typeof value === 'function') {\\n      $(this).trigger(`state.change`, [key, value(this.state)]);\\n      return\\n    }\\n    $(this).trigger(`state.change`, [key, value]);\\n  }\\n\\n  bindEvents() {\\n    $(this).on(`state.change`, this.updateCallback);\\n  }\\n\\n  initUpdate() {\\n    Object.keys(this.state).forEach((key) => {\\n      this.updateCallback(null, key, this.state[key]);\\n    });\\n  }\\n}\\n```\\n\\n对，只用了 27 行，就实现了 jQuery 数据响应式。\\n\\n核心代码就是 $.trigger 和 $.on 这两个 API。\\n\\n使用方式如下：\\n\\n```js\\nconst { updateState } = new Reactivity({\\n  state: {\\n    'key': 'value'\\n  },\\n  updateCallback: (event, key, value) => {\\n  }\\n})\\n\\nupdateState('key', 'hello')\\n```\\n\\n组件化是基于 Reactivity 进行封装的，实现了事件绑定、指令、动态组件、静态组件、ref 等，代码不多，有 100 多行。\\n\\n```js\\nclass Component {\\n  constructor({ template, state, methods } = {}) {\\n    this.refs = {}\\n    this.template = template || ``\\n    this.state = state || {}\\n    this.methods = methods || {}\\n    this.type = typeof this.template === 'string' ? 'static' : 'dynamic'\\n    this.el = typeof this.template === 'string' ? $(this.template) : $(this.template(this.state))\\n    this.mount()\\n    this.#bindEvents()\\n    this.#bindRef()\\n    this.updateState = new Reactivity({\\n      state: this.state,\\n      updateCallback: this.#updateElements.bind(this)\\n    }).updateState\\n  }\\n\\n  mount() {\\n    $('body').append(this.el)\\n  }\\n\\n  unmount() {\\n    this.el.remove()\\n  }\\n\\n  #bindEvents() {\\n    const events = [\\n      'click',\\n      'change',\\n      'input',\\n      'blur',\\n      'focus',\\n      'keydown',\\n      'keyup',\\n      'keypress',\\n      'mouseenter',\\n      'mouseleave',\\n      'mouseover',\\n      'mouseout',\\n      'mousedown',\\n      'mouseup',\\n      'touchstart',\\n      'touchend',\\n      'touchmove',\\n      'touchcancel',\\n      'wheel',\\n      'scroll',\\n      'resize',\\n      'load',\\n      'unload',\\n      'abort',\\n      'error',\\n      'select',\\n      'contextmenu',\\n      'dblclick',\\n      'drag',\\n      'dragend',\\n      'dragenter',\\n      'dragleave',\\n      'dragover',\\n      'dragstart',\\n      'drop',\\n      'copy',\\n      'cut',\\n      'paste',\\n      'reset',\\n      'submit',\\n      'focusin',\\n      'focusout',\\n      'animationstart',\\n      'animationend',\\n      'animationiteration',\\n      'transitionend',\\n      'transitionstart',\\n      'transitioncancel',\\n      'transitionrun',\\n      'mousewheel'\\n    ]\\n\\n    events.forEach(evt => {\\n      Array.from([this.el, ...this.el.find(`[on-${evt}]`)]).forEach(el => {\\n        const methodName = $(el).attr(`on-${evt}`)\\n        if (methodName) {\\n          $(el).on(evt, this.methods[methodName])\\n        }\\n      })\\n    })\\n  }\\n\\n  #bindRef() {\\n    Array.from([this.el, ...this.el.find('[ref]')]).forEach(el => {\\n      const refName = $(el).attr('ref')\\n      if (refName) {\\n        this.refs[refName] = $(el)\\n      }\\n    })\\n  }\\n\\n  #updateElements(evt, key, value) {\\n    this.state[key] = value\\n    if (this.type === 'dynamic') {\\n      this.unmount()\\n      this.el = $(this.template(this.state))\\n      this.mount()\\n      this.#bindEvents()\\n      this.#bindRef()\\n    }\\n    this.#render(this.el, key, value)\\n  }\\n\\n  #render(el, key, value) {\\n    // data-class\\n    Array.from([el, ...el.find(`*[data-class*='${key}']`)]).forEach(el => {\\n      const reg = new RegExp(`{${key}}`, 'g')\\n      const classTemp = $(el).attr('data-class')\\n      if (classTemp) {\\n        const classRaw = classTemp.replaceAll(reg, value)\\n        $(el).attr('class', (i, val) => `${val} ${classRaw}`)\\n      }\\n    })\\n\\n    // data-style\\n    Array.from([el, ...el.find(`*[data-style*=${key}]`)]).forEach(el => {\\n      const styleTemp = $(el).data('style')\\n      if (styleTemp) {\\n        const reg = new RegExp(`{${key}}`, 'g')\\n        const styleRaw = styleTemp.replaceAll(reg, value)\\n        $(el).attr('style', (i, val) => `${val || ''} ${styleRaw} `)\\n      }\\n    })\\n\\n    // data-bind \\n    Array.from([el, ...el.find(`[data-bind=${key}]`)]).forEach(el => {\\n      const reg = new RegExp(`{${key}}`, 'g')\\n      // data-temp\\n      const temp = $(el).data('temp')\\n      if (temp) {\\n        $(el).text(temp.replaceAll(reg, value))\\n      }\\n    })\\n\\n    // data-show\\n    const dataShowEls = Array.from(el.find(`[data-show=${key}]`))\\n    const show = el.data('show')\\n    if (show) {\\n      dataShowEls.push(el)\\n    }\\n    dataShowEls.forEach(el => {\\n      if (value) {\\n        $(el).show()\\n      } else {\\n        $(el).hide()\\n      }\\n    })\\n  }\\n}\\n```\\n\\n## 如何用 HTML 模拟一个滚动条？\\n\\n游戏中有一个帮助面板，右侧的滚动条 UI 是高度定制的。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dfedea474ee74c4cad869345d2918397~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n实现原理比较简单，左侧内容区使用一个容器元素包裹真正的内容元素。容器元素设置溢出隐藏，内容元素通过 translate-y 进行位置调整。\\n\\n监听滚动条按钮的 mousedown 事件，然后在其中再监听 mousemove 事件，计算移动的 x 距离，然后设置按钮的 top 属性，然后计算按钮高度和整个滚动条高度的比例，将这个比例同步给左侧内容区，进行偏移调整。\\n\\n最后监听 mouseup 事件，取消 mousedown 和 mousemove 的监听。\\n\\n除了 mousedown 事件外，还需要处理 mousewheel 事件，也就是滚轮事件。处理逻辑基本与上述相同。\\n\\n## 预加载的原理\\n\\n为什么需要预加载呢？\\n\\n因为游戏中通常会包含大量的图片、音频、字体包等资源。如果不预加载，那么在游戏的过程中容易出现各种卡顿或者页面某个部分空白的情况。而且现代浏览器一般会对 network 进行限制，最多只能同时发出 3 个请求，超过这个数量会出现取消请求的现象。\\n\\n预加载就是维护了一个资源下载池，保证永远同时最多只有 3 个资源请求，每当有资源请求成功后，再发起下一个请求。\\n\\n  \\n# 合作\\n\\n\\n关于码上开火车这款游戏的开发就聊到这里了。\\n\\n如果你对游戏开发感兴趣，或者需要开发一些 3D 模型展示、3D 游戏、元宇宙等项目，欢迎联系我。",
        "tags": [
            "前端",
            "游戏",
            "three.js"
        ]
    },
    {
        "article_id": "7151757666337947656",
        "cover_image": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a7a4730ab85f4d08a131f4c1b267d3cf~tplv-k3u1fbpfcp-watermark.image?",
        "title": "使用Flutter，历时三个月，我写了一个桌面版本的象棋打谱软件，象棋助手",
        "brief": "简介 象棋助手是一个跨平台的象棋打谱软件，支持在Windows、macOS以及Linux操作系统上面使用。目前该项目已通过官网对外发布，可通过官网下载使用。 目前该软件已支持大部分象棋打谱功能，未支持",
        "user_name": "欧阳锋",
        "view_count": 4041,
        "collect_count": 21,
        "comment_count": 16,
        "avatar": "https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/11/160e41b2f9519d89~tplv-t2oaga2asx-image.image",
        "category": "前端",
        "content": "# 简介\\n象棋助手是一个跨平台的象棋打谱软件，支持在Windows、macOS以及Linux操作系统上面使用。目前该项目已通过官网对外发布，可通过官网下载使用。\\n\\n\\n![首页深色模式.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/50dc092381f742b6bb4de90166c42092~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n目前该软件已支持大部分象棋打谱功能，未支持功能也在陆续规划中，后续都将提供支持。\\n\\n官网：[https://cca.yhdm360.cn](https://cca.yhdm360.cn)\\n\\n# 功能点：\\n以下是象棋助手0.1.3版本的所有功能点：\\n* 打谱，支持变招、记谱，棋谱同步等功能\\n\\n* 棋库管理、同步\\n\\n* 棋谱编辑，支持撤销、重做\\n\\n* 支持导入、导出标准PGN棋谱\\n\\n* 支持导入象棋桥CBF棋谱\\n\\n* 支持棋图生成，方便分享\\n\\n* 支持复制、粘贴FEN\\n\\n* 支持推演棋盘，随时拆解\\n\\n\\n# 软件架构\\n该软件使用BLOC作为状态管理库，并使用macOS UI作为UI框架开发。\\n\\n由于Flutter在桌面端的支持依然存在着不少欠缺，部分功能不得不采用曲线救国的方式实现，部分实现仍然不完美，期待着Flutter团队早日完善桌面端支持。\\n\\n# 期待反馈\\n欢迎大家到官网下载使用，微软与苹果应用商店后续也会逐步上架，大家如果在使用过程中，有任何疑问，欢迎到社区反馈。\\n\\n附录：\\n\\n微信公众号：欧阳锋工作室\\n\\n独立开发QQ交流群：850273774\\n\\n象棋助手QQ交流群：725840654",
        "tags": [
            "Flutter",
            "前端",
            "后端"
        ]
    },
    {
        "article_id": "7189897548490866746",
        "cover_image": "",
        "title": "原理揭秘：为什么HBuilderX可以打开微信开发者工具?",
        "brief": "通过阅读本文你可以了解到：1. 微信小程序开发者工具提供的开发辅助功能： 命令行和HTTP调用的使用方法 2.了解HBuilderX可以打开微信开发者工具并编译和运行项目的原理。欢迎阅读本文一起学习！",
        "user_name": "NewName",
        "view_count": 1319,
        "collect_count": 11,
        "comment_count": 6,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/b32c60a4505714d21d26bdd40964b92b~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: smartblue\\n---\\n我们知道uni-app 是一个使用 Vue.js 开发所有前端应用的框架，开发者编写一套代码，可发布到iOS、Android、Web、以及各种小程序、快应用等多个平台。uni-app 的开发工具为HBuilderX，在开发阶段我们可以让使用HBuilderX开发的uni-app项目运行到微信开发者工具。\\n\\n今天我们来探索一下为什么HBuilderX可以打开微信开发者工具并编译和运行项目。通过阅读本文你可以了解到：1. 微信小程序开发者工具提供的开发辅助功能： 命令行和HTTP调用的使用方法 2.了解HBuilderX可以打开微信开发者工具并编译和运行项目的原理。欢迎阅读本文一起学习！\\n\\n# 1.开发者工具的命令行和HTTP调用\\n\\n开发者工具提供了[命令行](https://developers.weixin.qq.com/miniprogram/dev/devtools/cli.html)与 [HTTP](https://developers.weixin.qq.com/miniprogram/dev/devtools/http.html) 服务两种接口供外部调用，开发者可以通过命令行或 HTTP 请求指示工具进行登录、预览、上传等操作。由于命令行和HTTP二者提供的功能相同，所以本文以命令行为例说明有关功能的使用方法。\\n\\n## 1.1 首先要开启服务端口\\n\\n要使用命令行，注意首先需要在开发者工具的【设置】 ->【 安全设置】中开启服务端口，如下图所示：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a874fe5ee4634a4884d982d28729081b~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n## 1.2 找到命令行工具\\n\\n命令行工具所在位置：1.macOS: <安装路径>/Contents/MacOS/cli 2.Windows: <安装路径>/cli.bat\\n\\n笔者使用的是windows系统，命令行工具在开发者工具安装目录的根目录下面，如下图所示：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee080877302e4c479b4b8dbb96c641ef~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n## 1.3 使用命令行工具\\n\\n在路径上输入cmd然后按回车键，可快速将windows的cmd切换到微信开发者目录，如下图所示：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b6a9d24b16d546cca3c9a588af677115~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb8b5419997a449486d83f03342804a2~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n然后我们输入cli 回车 ，可见命令行工具输出了提示信息，如下图所示：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c3bdf69a405411abcdad32cac92a2ff~tplv-k3u1fbpfcp-zoom-1.image)\\n下面我们尝试使用几个命令：\\n\\n### 1.3.1 islogin\\n\\n下面我们使用一下[ islogin](https://developers.weixin.qq.com/miniprogram/dev/devtools/cli.html#%E6%98%AF%E5%90%A6%E5%B7%B2%E7%BB%8F%E7%99%BB%E5%BD%95%E5%B7%A5%E5%85%B7)命令检查一下当前是否已经登录工具，如下图所示：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e68fac797dc343c899222cbdfa19db01~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n### 1.3.2 upload\\n\\n下面我们使用[upload](https://developers.weixin.qq.com/miniprogram/dev/devtools/cli.html#%E4%B8%8A%E4%BC%A0%E4%BB%A3%E7%A0%81)命令上传小程序代码：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd469b875aaa4190b906a44ee88f43a5~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n我们可以登录到小程序开发者后台检查上传结果，如下图所示：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/32d60b1968ec4b7591794438e2e5ccb0~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n### 1.3.3 preview\\n\\n下面我们使用[preview](https://developers.weixin.qq.com/miniprogram/dev/devtools/cli.html#%E9%A2%84%E8%A7%88)命令进行预览：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/615a2b4cb0564706acec38d27027b000~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f9fc9440757445d8cf2139938b1bcdf~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n可见preview命令可以在控制台打印出二维码，因为参数--qr-format的默认值为terminal，也可以指定其他值，详见文档。\\n\\n关于其他的命令，读者可以自行尝试，下面说一下[open](https://developers.weixin.qq.com/miniprogram/dev/devtools/cli.html#%E5%90%AF%E5%8A%A8%E5%B7%A5%E5%85%B7)命令和HBuilderX是如何打开开发者工具的。\\n\\n# 2.HBuilderX打开开发者工具\\n\\n## 2.1 open命令简介\\n\\nopen命令用于启动开发者工具，运行命令时有可选的参数--project。project代表要运行项目的路径，如果指定了project则打开工具的时候还会打开项目，每次执行都会自动编译刷新，并且自动打开模拟器和调试器。要注意两点：\\n\\n第一，project不能是相对路径；\\n\\n第二，项目路径所指向的这个小程序项目必须含正确格式的 project.config.json 且其中有 appid 和 projectname 字段。示例：\\n\\n```\\n# 打开工具\\ncli open\\n# 打开路径 /Users/username/demo 下的项目\\ncli open --project /Users/username/demo\\n```\\n\\n除了open命令，微信开发者工具还提供了[open-other](https://developers.weixin.qq.com/miniprogram/dev/devtools/cli.html#%E6%89%93%E5%BC%80%E5%85%B6%E4%BB%96%E9%A1%B9%E7%9B%AE)命令，可以在工具中以「其他」项目的形式打开文件或者文件夹。这个命令的--project参数是必选的，指定打开的文件或者文件夹路径，支持绝对路径和相对路径。示例：\\n\\n```\\n# 打开指定项目，在「其他」项目窗口中打开\\ncli open-other --project /Users/username/demo\\n```\\n\\n了解了open命令我们来看HBuilderX是如何打开开发者工具的。\\n\\n## 2.2 HBuilderX打开开发者工具\\n\\n在HBuilderX中点击【运行】-【运行到小程序模拟器】-【微信开发者工具】，如下图所示：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1782acaec18546d0afbcdb633990ab9f~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n提示需要设置【微信开发者路径】，如下图所示：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89333b888d8a41b18943f97df5796920~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n填写微信开发者工具路径，点击【确定】，如下图所示：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/272eb0eca03f4809ad4145d2f81f5aaa~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n（注意，如上文所述，指定的这个微信小程序根目录就可以找到命令行工具。）\\n\\n然后重新点击【运行】-【运行到小程序模拟器】-【微信开发者工具】，可以看到HBuilderX成功打开了微信开发者工具，如下图所示：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b3f40d0abe574dbeb50779ab6d6102d3~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n注意上图中的绿色框选部分的端口号：50429和我们在微信开发者工具中【设置】-【安全设置】显示的端口号是一样的。\\n\\n至此，我们可以知道为什么HBuilderX可以打开微信开发者工具并运行项目的原理了吧？就是使用了微信小程序提供的命令行工具，更具体的说是使用了open命令。HBuilderX要想使用命令行工具那么就要知道命令行工具的路径，所以需要为HBuilderX配置微信开发者工具的安装路径。\\n\\n# 参考文章\\n\\n1.[uni-app跨端开发微信小程序之手把手带你写一个用程序自动打开微信开发者工具的小插件](https://blog.csdn.net/yilingsj/article/details/117197151)\\n\\n2.[uni-app跨端开发微信小程序之HBuilderX项目实现多环境开发](http://www.yilingsj.com/xwzj/2021-05-02/uni-app-HBuilderX-to-vue-cli.html)\\n",
        "tags": [
            "前端",
            "JavaScript",
            "微信小程序"
        ]
    },
    {
        "article_id": "7160281215940067336",
        "cover_image": "https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8984fa71e46c499cba5ae600ab0cacc2~tplv-k3u1fbpfcp-watermark.image?",
        "title": "我让虚拟DOM的diff算法过程动起来了",
        "brief": "去年写了一篇文章介绍虚拟`DOM`的`patch`过程和`diff`算法过程，当时使用的是双端`diff`算法，今年看到了`Vue3`使用的已经是快速`diff`算法，所以也想写一篇来记录一下，但是肯",
        "user_name": "街角小林",
        "view_count": 2622,
        "collect_count": 90,
        "comment_count": 13,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/894ec075c1d445a53e71bf0796debe8a~300x300.image",
        "category": "前端",
        "content": "去年写了一篇文章[手写一个虚拟DOM库，彻底让你理解diff算法](https://juejin.cn/post/6984939221681176607)介绍虚拟`DOM`的`patch`过程和`diff`算法过程，当时使用的是双端`diff`算法，今年看到了`Vue3`使用的已经是快速`diff`算法，所以也想写一篇来记录一下，但是肯定已经有人写过了，所以就在想能不能有点不一样的，上次的文章主要是通过画图来一步步展示`diff`算法的每一种情况和过程，所以就在想能不能改成动画的形式，于是就有了这篇文章。当然目前的实现还是基于双端`diff`算法的，后续会补充上快速`diff`算法。\\n\\n传送门：[双端Diff算法动画演示](https://wanglin2.github.io/VNode_visualization_demo/)。\\n\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a68b3f19661e4b9e8eb335f94c20e90e~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n\\n界面就是这样的，左侧可以输入要比较的新旧`VNode`列表，然后点击启动按钮就会以动画的形式来展示从头到尾的过程，右侧是水平的三个列表，分别代表的是新旧的`VNode`列表，以及当前的真实`DOM`列表，`DOM`列表初始和旧的`VNode`列表一致，算法结束后会和新的`VNode`列表一致。\\n\\n需要说明的是这个动画只包含`diff`算法的过程，不包含`patch`过程。\\n\\n先来回顾一下双端`diff`算法的函数：\\n\\n```js\\nconst diff = (el, oldChildren, newChildren) => {\\n  // 指针\\n  let oldStartIdx = 0\\n  let oldEndIdx = oldChildren.length - 1\\n  let newStartIdx = 0\\n  let newEndIdx = newChildren.length - 1\\n  // 节点\\n  let oldStartVNode = oldChildren[oldStartIdx]\\n  let oldEndVNode = oldChildren[oldEndIdx]\\n  let newStartVNode = newChildren[newStartIdx]\\n  let newEndVNode = newChildren[newEndIdx]\\n  while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\\n    if (oldStartVNode === null) {\\n      oldStartVNode = oldChildren[++oldStartIdx]\\n    } else if (oldEndVNode === null) {\\n      oldEndVNode = oldChildren[--oldEndIdx]\\n    } else if (newStartVNode === null) {\\n      newStartVNode = oldChildren[++newStartIdx]\\n    } else if (newEndVNode === null) {\\n      newEndVNode = oldChildren[--newEndIdx]\\n    } else if (isSameNode(oldStartVNode, newStartVNode)) { // 头-头\\n      patchVNode(oldStartVNode, newStartVNode)\\n      // 更新指针\\n      oldStartVNode = oldChildren[++oldStartIdx]\\n      newStartVNode = newChildren[++newStartIdx]\\n    } else if (isSameNode(oldStartVNode, newEndVNode)) { // 头-尾\\n      patchVNode(oldStartVNode, newEndVNode)\\n      // 把oldStartVNode节点移动到最后\\n      el.insertBefore(oldStartVNode.el, oldEndVNode.el.nextSibling)\\n      // 更新指针\\n      oldStartVNode = oldChildren[++oldStartIdx]\\n      newEndVNode = newChildren[--newEndIdx]\\n    } else if (isSameNode(oldEndVNode, newStartVNode)) { // 尾-头\\n      patchVNode(oldEndVNode, newStartVNode)\\n      // 把oldEndVNode节点移动到oldStartVNode前\\n      el.insertBefore(oldEndVNode.el, oldStartVNode.el)\\n      // 更新指针\\n      oldEndVNode = oldChildren[--oldEndIdx]\\n      newStartVNode = newChildren[++newStartIdx]\\n    } else if (isSameNode(oldEndVNode, newEndVNode)) { // 尾-尾\\n      patchVNode(oldEndVNode, newEndVNode)\\n      // 更新指针\\n      oldEndVNode = oldChildren[--oldEndIdx]\\n      newEndVNode = newChildren[--newEndIdx]\\n    } else {\\n      let findIndex = findSameNode(oldChildren, newStartVNode)\\n      // newStartVNode在旧列表里不存在，那么是新节点，创建插入\\n      if (findIndex === -1) {\\n        el.insertBefore(createEl(newStartVNode), oldStartVNode.el)\\n      } else { // 在旧列表里存在，那么进行patch，并且移动到oldStartVNode前\\n        let oldVNode = oldChildren[findIndex]\\n        patchVNode(oldVNode, newStartVNode)\\n        el.insertBefore(oldVNode.el, oldStartVNode.el)\\n        // 将该VNode置为空\\n        oldChildren[findIndex] = null\\n      }\\n      newStartVNode = newChildren[++newStartIdx]\\n    }\\n  }\\n  // 旧列表里存在新列表里没有的节点，需要删除\\n  if (oldStartIdx <= oldEndIdx) {\\n    for (let i = oldStartIdx; i <= oldEndIdx; i++) {\\n      removeEvent(oldChildren[i])\\n      oldChildren[i] && el.removeChild(oldChildren[i].el)\\n    }\\n  } else if (newStartIdx <= newEndIdx) {\\n    let before = newChildren[newEndIdx + 1] ? newChildren[newEndIdx + 1].el : null\\n    for (let i = newStartIdx; i <= newEndIdx; i++) {\\n      el.insertBefore(createEl(newChildren[i]), before)\\n    }\\n  }\\n}\\n```\\n\\n该函数具体的实现步骤可以参考之前的文章，本文就不再赘述。\\n\\n我们想让这个`diff`过程动起来，首先要找到动画的对象都有哪些，从函数的参数开始看，首先`oldChildren`和 `newChildren`两个`VNode`列表是必不可少的，可以通过两个水平的列表表示，然后是四个指针，这是双端`diff`算法的关键，我们通过四个箭头来表示，指向当前所比较的节点，然后就开启循环了，循环中新旧`VNode`列表其实基本上是没啥变化的，我们实际操作的是`VNode`对应的真实`DOM`元素，包括`patch`打补丁、移动、删除、新增等等操作，所以我们再来个水平的列表表示当前的真实`DOM`列表，最开始肯定是和旧的`VNode`列表是对应的，通过`diff`算法一步步会变成和新的`VNode`列表对应。\\n\\n再来回顾一下创建`VNode`对象的`h`函数：\\n\\n```js\\nexport const h = (tag, data = {}, children) => {\\n  let text = ''\\n  let el\\n  let key\\n  // 文本节点\\n  if (typeof children === 'string' || typeof children === 'number') {\\n    text = children\\n    children = undefined\\n  } else if (!Array.isArray(children)) {\\n    children = undefined\\n  }\\n  if (data && data.key) {\\n    key = data.key\\n  }\\n  return {\\n    tag, // 元素标签\\n    children, // 子元素\\n    text, // 文本节点的文本\\n    el, // 真实dom\\n    key,\\n    data\\n  }\\n}\\n```\\n\\n我们输入的`VNode`列表数据会使用`h`函数来创建成`VNode`对象，所以可以输入的最简单的结构如下：\\n\\n```json\\n[\\n  {\\n    tag: 'div',\\n    children: '文本节点的内容',\\n    data: {\\n      key: 'a'\\n    }\\n  }\\n]\\n```\\n\\n输入的新旧`VNode`列表数据会保存在`store`中，可以通过如下方式获取到：\\n\\n```js\\n// 输入的旧VNode列表\\nstore.oldVNode\\n// 输入的新VNode列表\\nstore.newVNode\\n```\\n\\n接下来定义相关的变量：\\n\\n```js\\n// 指针列表\\nconst oldPointerList = ref([])\\nconst newPointerList = ref([])\\n// 真实DOM节点列表\\nconst actNodeList = ref([])\\n// 新旧节点列表\\nconst oldVNodeList = ref([])\\nconst newVNodeList = ref([])\\n// 提示信息\\nconst info = ref('')\\n```\\n\\n指针的移动动画可以使用`css`的`transition`属性来实现，只要修改指针元素的`left`值即可，真实`DOM`列表的移动动画可以使用`Vue`的列表过渡组件[TransitionGroup](https://cn.vuejs.org/guide/built-ins/transition-group.html)来轻松实现，模板如下：\\n\\n```html\\n<div class=\\\"playground\\\">\\n  <!-- 指针 -->\\n  <div class=\\\"pointer\\\">\\n    <div\\n         class=\\\"pointerItem\\\"\\n         v-for=\\\"item in oldPointerList\\\"\\n         :key=\\\"item.name\\\"\\n         :style=\\\"{ left: item.value * 120 + 'px' }\\\"\\n         >\\n      <div class=\\\"pointerItemName\\\">{{ item.name }}</div>\\n      <div class=\\\"pointerItemValue\\\">{{ item.value }}</div>\\n      <img src=\\\"../assets/箭头_向下.svg\\\" alt=\\\"\\\" />\\n    </div>\\n  </div>\\n  <div class=\\\"nodeListBox\\\">\\n    <!-- 旧节点列表 -->\\n    <div class=\\\"nodeList\\\">\\n      <div class=\\\"name\\\" v-if=\\\"oldVNodeList.length > 0\\\">旧的VNode列表</div>\\n      <div class=\\\"nodes\\\">\\n        <TransitionGroup name=\\\"list\\\">\\n          <div\\n               class=\\\"nodeWrap\\\"\\n               v-for=\\\"(item, index) in oldVNodeList\\\"\\n               :key=\\\"item ? item.data.key : index\\\"\\n               >\\n            <div class=\\\"node\\\">{{ item ? item.children : '空' }}</div>\\n          </div>\\n        </TransitionGroup>\\n      </div>\\n    </div>\\n    <!-- 新节点列表 -->\\n    <div class=\\\"nodeList\\\">\\n      <div class=\\\"name\\\" v-if=\\\"newVNodeList.length > 0\\\">新的VNode列表</div>\\n      <div class=\\\"nodes\\\">\\n        <TransitionGroup name=\\\"list\\\">\\n          <div\\n               class=\\\"nodeWrap\\\"\\n               v-for=\\\"(item, index) in newVNodeList\\\"\\n               :key=\\\"item.data.key\\\"\\n               >\\n            <div class=\\\"node\\\">{{ item.children }}</div>\\n          </div>\\n        </TransitionGroup>\\n      </div>\\n    </div>\\n    <!-- 提示信息 -->\\n    <div class=\\\"info\\\">{{ info }}</div>\\n  </div>\\n  <!-- 指针 -->\\n  <div class=\\\"pointer\\\">\\n    <div\\n         class=\\\"pointerItem\\\"\\n         v-for=\\\"item in newPointerList\\\"\\n         :key=\\\"item.name\\\"\\n         :style=\\\"{ left: item.value * 120 + 'px' }\\\"\\n         >\\n      <img src=\\\"../assets/箭头_向上.svg\\\" alt=\\\"\\\" />\\n      <div class=\\\"pointerItemValue\\\">{{ item.value }}</div>\\n      <div class=\\\"pointerItemName\\\">{{ item.name }}</div>\\n    </div>\\n  </div>\\n  <!-- 真实DOM列表 -->\\n  <div class=\\\"nodeList act\\\" v-if=\\\"actNodeList.length > 0\\\">\\n    <div class=\\\"name\\\">真实DOM列表</div>\\n    <div class=\\\"nodes\\\">\\n      <TransitionGroup name=\\\"list\\\">\\n        <div\\n             class=\\\"nodeWrap\\\"\\n             v-for=\\\"item in actNodeList\\\"\\n             :key=\\\"item.data.key\\\"\\n             >\\n          <div class=\\\"node\\\">{{ item.children }}</div>\\n        </div>\\n      </TransitionGroup>\\n    </div>\\n  </div>\\n</div>\\n```\\n\\n双端`diff`算法过程中是不会修改新的`VNode`列表的，但是旧的`VNode`列表是有可能被修改的，也就是当首尾比较没有找到可以复用的节点，但是通过直接在旧的`VNode`列表中搜索找到了，那么会移动该`VNode`对应的真实`DOM`，移动后该`VNode`其实就相当于已经被处理过了，但是该`VNode`的位置又是在当前指针的中间，不能直接被删除，所以只好置为空`null`，所以可以看到模板中有处理这种情况。\\n\\n另外我们还创建了一个`info`元素用来展示提示的文字信息，作为动画的描述。\\n\\n但是这样还是不够的，因为每个旧的`VNode`是有对应的真实`DOM`元素的，但是我们输入的只是一个普通的`json`数据，所以模板还需要新增一个列表，作为旧的`VNode`列表的关联节点，这个列表只要提供节点引用即可，不需要可见，所以把它的`display`设为`none`：\\n\\n```js\\n// 根据输入的旧VNode列表创建元素\\nconst _oldVNodeList = computed(() => {\\n  return JSON.parse(store.oldVNode)\\n})\\n// 引用DOM元素\\nconst oldNode = ref(null)\\nconst oldNodeList = ref([])\\n```\\n\\n```html\\n<!-- 隐藏 -->\\n<div class=\\\"hide\\\">\\n  <div class=\\\"nodes\\\" ref=\\\"oldNode\\\">\\n    <div\\n         v-for=\\\"(item, index) in _oldVNodeList\\\"\\n         :key=\\\"index\\\"\\n         ref=\\\"oldNodeList\\\"\\n         >\\n      {{ item.children }}\\n    </div>\\n  </div>\\n</div>\\n```\\n\\n然后当我们点击启动按钮，就可以给我们的三个列表变量赋值了，并使用`h`函数创建新旧`VNode`对象，然后传递给打补丁的`patch`函数就可以开始进行比较更新实际的`DOM`元素了：\\n\\n```js\\nconst start = () => {\\n  nextTick(() => {\\n    // 表示当前真实的DOM列表\\n    actNodeList.value = JSON.parse(store.oldVNode)\\n    // 表示旧的VNode列表\\n    oldVNodeList.value = JSON.parse(store.oldVNode)\\n    // 表示新的VNode列表\\n    newVNodeList.value = JSON.parse(store.newVNode)\\n    nextTick(() => {\\n      let oldVNode = h(\\n        'div',\\n        { key: 1 },\\n        JSON.parse(store.oldVNode).map((item, index) => {\\n          // 创建VNode对象\\n          let vnode = h(item.tag, item.data, item.children)\\n          // 关联真实的DOM元素\\n          vnode.el = oldNodeList.value[index]\\n          return vnode\\n        })\\n      )\\n      // 列表的父节点也需要关联真实的DOM元素\\n      oldVNode.el = oldNode.value\\n      let newVNode = h(\\n        'div',\\n        { key: 1 },\\n        JSON.parse(store.newVNode).map(item => {\\n          return h(item.tag, item.data, item.children)\\n        })\\n      )\\n      // 调用patch函数进行打补丁\\n      patch(oldVNode, newVNode)\\n    })\\n  })\\n}\\n```\\n\\n可以看到我们输入的新旧`VNode`列表是作为一个节点的子节点的，这是因为只有当比较的两个节点都存在非文本节点的子节点时才需要使用`diff`算法来高效的更新他们的子节点，当`patch`函数运行完后你可以打开控制台查看隐藏的`DOM`列表，会发现是和新的`VNode`列表保持一致的，那么你可能要问，为什么不直接用这个列表来作为真实`DOM`列表呢，还要自己额外创建一个`actNodeList`列表，其实是可以，但是`diff`算法过程中是使用`insertBefore`等方法来移动真实`DOM`节点的，所以不好加过渡动画，只会看到节点瞬间换位置，不符合我们的动画需求。\\n\\n到这里效果如下：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/990954f0df5a4826916ddeb90edc4bee~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n\\n接下来我们先把指针搞出来，我们创建一个处理函数对象，这个对象上会挂载一些方法，用于在`diff`算法过程中调用，在函数中更新相应的变量。\\n\\n```js\\nconst handles = {\\n  // 更新指针\\n  updatePointers(oldStartIdx, oldEndIdx, newStartIdx, newEndIdx) {\\n    oldPointerList.value = [\\n      {\\n        name: 'oldStartIdx',\\n        value: oldStartIdx\\n      },\\n      {\\n        name: 'oldEndIdx',\\n        value: oldEndIdx\\n      }\\n    ]\\n    newPointerList.value = [\\n      {\\n        name: 'newStartIdx',\\n        value: newStartIdx \\n      },\\n      {\\n        name: 'newEndIdx',\\n        value: newEndIdx\\n      }\\n    ]\\n  },\\n}\\n```\\n\\n然后我们就可以在`diff`函数中通过`handles.updatePointers()`更新指针了：\\n\\n```js\\nconst diff = (el, oldChildren, newChildren) => {\\n  // 指针\\n  // ...\\n  handles.updatePointers(oldStartIdx, oldEndIdx, newStartIdx, newEndIdx)\\n  // ...\\n}\\n```\\n\\n这样指针就出来了：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/504f9addb3da4d819ab60eb64d2ccfab~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n\\n然后在`while`循环中会不断改变这四个指针，所以在循环中也需要更新：\\n\\n```js\\nwhile (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\\n  // ...\\n  handles.updatePointers(oldStartIdx, oldEndIdx, newStartIdx, newEndIdx)\\n}\\n```\\n\\n但是这样显然是不行的，为啥呢，因为循环也就一瞬间就结束了，而我们希望每次都能停留一段时间，很简单，我们写个等待函数：\\n\\n```js\\nconst wait = t => {\\n  return new Promise(resolve => {\\n    setTimeout(\\n      () => {\\n        resolve()\\n      },\\n      t || 3000\\n    )\\n  })\\n}\\n```\\n\\n然后我们使用`async/await`语法，就可以轻松在循环中实现等待了：\\n\\n```js\\nconst diff = async (el, oldChildren, newChildren) => {\\n  // ...\\n  while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\\n    // ...\\n    handles.updatePointers(oldStartIdx, oldEndIdx, newStartIdx, newEndIdx)\\n    await wait()\\n  }\\n}\\n```\\n\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b77f68b169241c481d780522fe3614a~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n\\n接下来我们新增两个变量，来突出表示当前正在比较的两个`VNode`：\\n\\n```js\\n// 当前比较中的节点索引\\nconst currentCompareOldNodeIndex = ref(-1)\\nconst currentCompareNewNodeIndex = ref(-1)\\n\\nconst handles = {\\n  // 更新当前比较节点\\n  updateCompareNodes(a, b) {\\n    currentCompareOldNodeIndex.value = a\\n    currentCompareNewNodeIndex.value = b\\n  }\\n}\\n```\\n\\n```html\\n<div\\n     class=\\\"nodeWrap\\\"\\n     v-for=\\\"(item, index) in oldVNodeList\\\"\\n     :key=\\\"item ? item.data.key : index\\\"\\n     :class=\\\"{\\n         current: currentCompareOldNodeIndex === index,\\n     }\\\"\\n     >\\n  <div class=\\\"node\\\">{{ item ? item.children : '空' }}</div>\\n</div>\\n<div\\n     class=\\\"nodeWrap\\\"\\n     v-for=\\\"(item, index) in newVNodeList\\\"\\n     :key=\\\"item.data.key\\\"\\n     :class=\\\"{\\n         current: currentCompareNewNodeIndex === index,\\n     }\\\"\\n     >\\n  <div class=\\\"node\\\">{{ item.children }}</div>\\n</div>\\n```\\n\\n给当前比较中的节点添加一个类名，用来突出显示，接下来还是一样，需要在`diff`函数中调用该函数，但是，该怎么加呢：\\n\\n```js\\nwhile (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\\n    if // ...\\n    } else if (isSameNode(oldStartVNode, newStartVNode)) {\\n      // ...\\n      oldStartVNode = oldChildren[++oldStartIdx]\\n      newStartVNode = newChildren[++newStartIdx]\\n    } else if (isSameNode(oldStartVNode, newEndVNode)) {\\n      // ...\\n      oldStartVNode = oldChildren[++oldStartIdx]\\n      newEndVNode = newChildren[--newEndIdx]\\n    } else if (isSameNode(oldEndVNode, newStartVNode)) {\\n      // ...\\n      oldEndVNode = oldChildren[--oldEndIdx]\\n      newStartVNode = newChildren[++newStartIdx]\\n    } else if (isSameNode(oldEndVNode, newEndVNode)) {\\n      // ...\\n      oldEndVNode = oldChildren[--oldEndIdx]\\n      newEndVNode = newChildren[--newEndIdx]\\n    } else {\\n      // ...\\n      newStartVNode = newChildren[++newStartIdx]\\n    }\\n```\\n\\n我们想表现出头尾比较的过程，其实就在这些`if`条件中，也就是要在每个`if`条件中停留一段时间，那么可以直接这样吗：\\n\\n```js\\nconst isSameNode = async () => {\\n  // ...\\n  handles.updateCompareNodes()\\n  await wait()\\n}\\n\\nif (await isSameNode(oldStartVNode, newStartVNode))\\n```\\n\\n很遗憾，我尝试了不行，那么只能改写成其他形式了：\\n\\n```js\\nwhile (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\\n  let stop = false\\n  let _isSameNode = false\\n  if (oldStartVNode === null) {\\n    callbacks.updateInfo('')\\n    oldStartVNode = oldChildren[++oldStartIdx]\\n    stop = true\\n  }\\n  // ...\\n  if (!stop) {\\n    callbacks.updateInfo('头-头比较')\\n    callbacks.updateCompareNodes(oldStartIdx, newStartIdx)\\n    _isSameNode = isSameNode(oldStartVNode, newStartVNode)\\n    if (_isSameNode) {\\n      callbacks.updateInfo(\\n        'key值相同，可以复用，进行patch打补丁操作。新旧节点位置相同，不需要移动对应的真实DOM节点'\\n      )\\n    }\\n    await wait()\\n  }\\n  if (!stop && _isSameNode) {\\n    // ...\\n    oldStartVNode = oldChildren[++oldStartIdx]\\n    newStartVNode = newChildren[++newStartIdx]\\n    stop = true\\n  }\\n  // ...\\n}\\n```\\n\\n我们使用一个变量来表示是否进入到了某个分支，然后把检查节点是否能复用的结果也保存到一个变量上，这样就可以通过不断检查这两个变量的值来判断是否需要进入到后续的比较分支中，这样比较的逻辑就不在`if`条件中了，就可以使用`await`了，同时我们还使用`updateInfo`增加了提示语：\\n\\n```js\\nconst handles = {\\n  // 更新提示信息\\n  updateInfo(tip) {\\n    info.value = tip\\n  }\\n}\\n```\\n\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1bf0816a2ed4f22af8934ba5c3d73cd~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n\\n接下来看一下节点的移动操作，当头（`oldStartIdx`对应的`oldStartVNode`节点）尾（`newEndIdx`对应的`newEndVNode`节点）比较发现可以复用时，在打完补丁后需要将`oldStartVNode`对应的真实`DOM`元素移动到`oldEndVNode`对应的真实`DOM`元素的位置，也就是插入到`oldEndVNode`对应的真实`DOM`的后面一个节点的前面：\\n\\n```js\\nif (!stop && _isSameNode) {\\n  // 头-尾\\n  patchVNode(oldStartVNode, newEndVNode)\\n  // 把oldStartVNode节点移动到最后\\n  el.insertBefore(oldStartVNode.el, oldEndVNode.el.nextSibling)\\n  // 更新指针\\n  oldStartVNode = oldChildren[++oldStartIdx]\\n  newEndVNode = newChildren[--newEndIdx]\\n  stop = true\\n}\\n```\\n\\n那么我们可以在`insertBefore`方法移动完真实的`DOM`元素后紧接着调用一下我们模拟列表的移动节点的方法：\\n\\n```js\\nif (!stop && _isSameNode) {\\n  // ...\\n  el.insertBefore(oldStartVNode.el, oldEndVNode.el.nextSibling)\\n  callbacks.moveNode(oldStartIdx, oldEndIdx + 1)\\n  // ...\\n}\\n```\\n\\n我们要操作的实际上是代表真实`DOM`节点的`actNodeList`列表，那么关键是要找到具体是哪个，首先头尾的四个节点指针它们表示的是在新旧`VNode`列表中的位置，所以我们可以根据`oldStartIdx`和`oldEndIdx`获取到`oldVNodeList`中对应位置的`VNode`，然后通过`key`值在`actNodeList`列表中找到对应的节点，进行移动、删除、插入等操作：\\n\\n```js\\nconst handles = {\\n  // 移动节点\\n  moveNode(oldIndex, newIndex) {\\n    let oldVNode = oldVNodeList.value[oldIndex]\\n    let newVNode = oldVNodeList.value[newIndex]\\n    let fromIndex = findIndex(oldVNode)\\n    let toIndex = findIndex(newVNode)\\n    actNodeList.value[fromIndex] = '#'\\n    actNodeList.value.splice(toIndex, 0, oldVNode)\\n    actNodeList.value = actNodeList.value.filter(item => {\\n      return item !== '#'\\n    })\\n  }\\n}\\n\\nconst findIndex = (vnode) => {\\n  return !vnode\\n    ? -1\\n    : actNodeList.value.findIndex(item => {\\n        return item && item.data.key === vnode.data.key\\n      })\\n}\\n```\\n\\n其他的插入节点和删除节点也是类似的：\\n\\n插入节点：\\n\\n```js\\nconst handles = {\\n  // 插入节点\\n  insertNode(newVNode, index, inNewVNode) {\\n    let node = {\\n      data: newVNode.data,\\n      children: newVNode.text\\n    }\\n    let targetIndex = 0\\n    if (index === -1) {\\n      actNodeList.value.push(node)\\n    } else {\\n      if (inNewVNode) {\\n        let vNode = newVNodeList.value[index]\\n        targetIndex = findIndex(vNode)\\n      } else {\\n        let vNode = oldVNodeList.value[index]\\n        targetIndex = findIndex(vNode)\\n      }\\n      actNodeList.value.splice(targetIndex, 0, node)\\n    }\\n  }\\n}\\n```\\n\\n删除节点：\\n\\n```js\\nconst handles = {\\n  // 删除节点\\n  removeChild(index) {\\n    let vNode = oldVNodeList.value[index]\\n    let targetIndex = findIndex(vNode)\\n    actNodeList.value.splice(targetIndex, 1)\\n  }\\n}\\n```\\n\\n这些方法在`diff`函数中的执行位置其实就是执行`insertBefore`、`removeChild`方法的地方，具体可以本文源码，这里就不在具体介绍了。\\n\\n另外还可以凸显一下已经结束比较的元素、即将被添加的元素、即将被删除的元素等等，最终效果：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5f0e074330740b4a329ad2020c32dd2~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n\\n\\n时间原因，目前只实现了双端`diff`算法的效果，后续会增加上快速`diff`算法的动画过程，有兴趣的可以点个关注哟~\\n\\n仓库：[https://github.com/wanglin2/VNode_visualization](https://github.com/wanglin2/VNode_visualization)。",
        "tags": [
            "掘金·日新计划",
            "前端",
            "JavaScript"
        ]
    },
    {
        "article_id": "7175689778090901561",
        "cover_image": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f45b69b135424ee492fef7769b7c9744~tplv-k3u1fbpfcp-watermark.image?",
        "title": "JavaScript 最佳实践：如何写出更可靠、更高性能的代码",
        "brief": "自2000年以来，Web开发一直在以惊人的速度发展。从最初毫无章法可循的 “野蛮生长”，到如今已发展出完整的规范体系，各种研究成果和最佳实践层出不穷。Web开发领域的最新技术和开发工具已经令人目不暇接",
        "user_name": "CoderBin",
        "view_count": 3724,
        "collect_count": 136,
        "comment_count": 21,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/880868841b36eb13d36e1a0ab7a52cac~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: vuepress\\nhighlight: atom-one-dark\\n---\\n\\n# 前言\\n自2000年以来，Web 开发一直在以惊人的速度发展。从最初毫无章法可循的 “野蛮生长”，到如今已发展出完整的规范体系，各种研究成果和最佳实 践层出不穷。Web 开发领域的最新技术和开发工具已经令人目不暇接。其中，前端三件套中的核心 JavaScript 尤其成为了研究和关注的焦点。 JavaScript 的最佳实践可以分成几类，适用于开发流程的不同阶段。\\n>提示：阅读本文大约需要50分钟\\n## 1. 可维护性\\n在早期网站中，JavaScript 主要用于实现一些小型动效或表单验证。今天的 Web 应用程序则动辄成千上万行 JavaScript 代码，用于完成各种各样的复杂处理。这些变化要求开发者把可维护能力放到重要位置上。正如更传统意义上的软件工程师一样，JavaScript 开发者受雇是要为公司创造价值的。他们不仅要保证产品如期上线，而且要随着时间推移为公司不断积累 知识资产。 \\n\\n**编写可维护的代码十分重要，因为大多数开发者会花大量时间去维护别人写的代码**。实际开发中，从第一行代码开始写起的情况非常少，通常是要在别人的代码之上构建自己的工作。让自己的代码容易维护，可以保证其他开发者更好地完成自己的工作。\\n\\n**注意**：可维护代码的概念并不只适用于 JavaScript，其中很多概念适用于所有编程语言，尽管部分概念特定于 JavaScript。\\n\\n### 1.1 什么是可维护的代码\\n通常，说代码“可维护”就意味着它具备如下特点。\\n\\n* **容易理解** ：无须求助原始开发者，任何人一看代码就知道它是干什么的，以及它是怎么实现的。 \\n* **符合常识** ：代码中的一切都显得顺理成章，无论操作有多么复杂。 \\n* **容易适配** ：即使数据发生变化也不用完全重写。\\n* **容易扩展** ：代码架构经过认真设计，支持未来扩展核心功能。 \\n* **容易调试** ：出问题时，代码可以给出明确的信息，通过它能直接定位 问题。\\n\\n**能够写出可维护的 JavaScript 代码是一项重要的专业技能。这就是业余爱好者和专业开发人员之间的区别，前者用一个周末就拼凑出一个网站，而后者真正了解自己的技术。**\\n\\n### 1.2 编码规范\\n**编写可维护代码的第一步是认真考虑编码规范**。大多数编程语言会涉及编码规范，简单上网一搜，就可以找到成千上万的相关文章。专业组织有为开发者建立的编码规范，旨在让人写出更容易维护的代码。优秀开源项目有严格的编码规范，可以让社区的所有人容易地理解代码是如何组织的。 \\n\\n编码规范对 JavaScript 而言非常重要，因为这门语言实在太灵活了。与大多数面向对象语言不同， JavaScript 并不强迫开发者把任何东西都定义为对象。它支持任何编程风格，包括传统的面向对象编程、声明式编程，以及函数式编程。简单看几个开源的 JavaScript库，就会发现有很多方式可以创建对象、定义方法和管理环境。\\n\\n接下来的几节会讨论制定编码规范的一些基础知识。这些话题很重要，当然每个人的需求不同，实现方式也可以不同。\\n\\n#### 1.2.1 可读性\\n要想让代码容易维护，首先必须使其可读。可读性必须考虑代码是一种文本文件。**为此，代码缩进是保证可读性的重要基础**。如果所有人都使用相同的缩进，整个项目的代码就会更容易让人看懂。缩进通常要使用空格数而不是Tab（制表符）来定义，因为后者在不同文本编辑器中的显示不同。一般来说，缩进是4个空格，当然具体多少个可以自己定。 \\n\\n**可读性的另一方面是代码注释**。在大多数编程语言中，广泛接受的做法是为每个方法都编写注释。因为 JavaScript 可以在代码中的任何地 方创建函数，所以这一点经常被忽视。正因为如此，可能给 JavaScript 中的每个函数都写注释才更重要。一般来说，以下这些地方应该写注释。\\n\\n* **函数和方法** 。每个函数和方法都应该有注释来描述其用途，以及完成任务所用的算法。同时，也写清使用这个函数或方法的前提 （假设）、每个参数的含义，以及函数是否返回值（因为通过函 数定义看不出来）。\\n\\n* **大型代码块** 。多行代码但用于完成单一任务的，应该在前面给出注释，把要完成的任务写清楚。 \\n* **复杂的算法** 。如果使用了独特的方法解决问题，要通过注释解释明白。这样不仅可以帮助别人查看代码，也可以帮助自己今后查 看代码。 \\n* **使用黑科技** 。由于浏览器之间的差异，JavaScript 代码中通常包含一些黑科技。不要假设其他人一看就能明白某个黑科技是为了解决某个浏览器的什么问题。如果某个浏览器不能使用正常方式达到目的，那要在注释里把黑科技的用途写出来。这样可以避免别人误以为黑科技没有用而把它“修复”掉，结果你已解决的问 题又会出现。\\n\\n**缩进和注释可以让代码更容易理解，将来也更容易维护。**\\n\\n#### 1.2.2 变量和函数命名\\n代码中变量和函数的适当命名对于其可读性和可维护性至关重要。因为很多 JavaScript 开发者是业余爱好者出身，所以很容易用foo 、 bar 命名变量，用 doSomething 来命名函数。专业 JavaScript 开发者必须改掉这些习惯，这样才能写出可维护的代码。以下是关于命名的通用规则。\\n\\n* **变量名应该是名词**，例如 car 或 person 。\\n\\n*  **函数名应该以动词开始**，例如 `getName()` 。返回布尔值的函数 通常以 is 开头，比如 `isEnabled()` 。\\n*  对变量和函数都使用符合逻辑的名称，不用担心长度。长名字的问题可以通过后处理和压缩解决（后面会讨论）。 \\n*  **变量、函数和方法应该以小写字母开头，使用驼峰大小写 （camelCase）形式**，如 `getName()` 和 `isPerson` 。类名应该首 字母大写，如Person 、RequestFactory 。常量值应该全部 大写并以下划线相接，比如 `REQUEST_TIMEOUT` 。 \\n*  **名称要尽量用描述性和直观的词汇**，但不要过于冗长。 `getName()` 一看就知道会返回名称，而 `PersonFactory` 一看就知道会产生某个 Person 对象或实体。\\n\\n#### 1.2.3 变量类型透明化\\n因为 JavaScript 是松散类型的语言，所以很容易忘记变量包含的数据类型。**适当命名可以在某种程度上解决这个问题**，但还不够。有三种方式可以标明变量的数据类型。\\n\\n**第一种标明变量类型的方式是通过初始化**。定义变量时，应该立即将其初始化为一个将来要使用的类型值。例如，要保存布尔值的变量，可以将其初始化为 true 或 false ；而要保存数值的变量，可以将其初始化为一个数值。再看几个例子：\\n```js\\n// 通过初始化标明变量类型\\nlet found = false; // 布尔值\\nlet count = -1;    // 数值\\nlet name = \\\"\\\";     // 字符串\\nlet person = null; // 对象\\n```\\n初始化为特定数据类型的值可以明确表示变量的类型。ES6之前，初始化方式不适合函数声明中函数的参数；ES6之后，可以在函数声明中为参数指定默认值来标明参数类型。\\n\\n**第二种标明变量类型的方式是使用匈牙利表示法**。匈牙利表示法指的是在变量名前面前缀一个或多个字符表示数据类型。这种表示法曾在脚本语言中非常流行，很长时间以来也是 JavaScript 首选的格式。对于基本数据类型，JavaScript传统的匈牙利表示法用 o 表示对象，s 表示字符串，i 表示整数，f 表示浮点数，b 表示布尔值。示例如下：\\n```js\\n// 使用匈牙利表示法标明数据类型\\nlet bFound;  // 布尔值\\nlet iCount;  // 整数\\nlet sName;   // 字符串\\nlet oPerson; // 对象\\n```\\n匈牙利表示法也可以很好地应用于函数参数。它的缺点是使代码可读性下降、不够直观，并破坏了类似句子的自然阅读流畅性。因此，匈牙利表示法在开发者中失宠了。\\n\\n**最后一种标明变量类型的方式是使用类型注释**。类型注释放在变量名后面、初始化表达式的前面。基本思路是在变量旁边使用注释说明类型，比如：\\n```js\\n// 使用类型注释表明数据类型\\nlet found /*:Boolean*/ = false\\nlet count /*:int*/ = 10\\nlet name /*:String*/ = 'Nicholas'\\nlet person /*:Object*/ = null\\n```\\n类型注释在保持代码整体可读性的同时向其注释了类型信息。类型注释的缺点是不能再使用多行注释把大型代码块注释掉了。因为类型注释也是多行注释，所以会造成干扰，如下例所示：\\n```js\\n// 这样多行注释不会生效\\n/*\\nlet found /*:Boolean*/ = false;\\nlet count /*:int*/ = 10;\\nlet name /*:String*/ = \\\"Nicholas\\\";\\nlet person /*:Object*/ = null;\\n*/\\n```\\n这里本来是想使用多行注释把所有变量声明都注释掉。但类型注释产生了干扰，因为第一个/* （第2行）的实例会与第一个*/ （第3行） 的实例匹配，所以会导致语法错误。如果想注释掉使用类型注释的代码，则只能使用单行注释一行一行地注释掉每一行（很多编辑器可以自动完成）。\\n\\n**以上是最常用的三种标明变量数据类型方式。每种方式都有其优点和缺点，可以根据实际情况选用。关键要看哪一种最适合自己的项目， 并保证一致性。**\\n\\n### 1.3 松散耦合\\n**只要应用程序的某个部分对另一个部分依赖得过于紧密，代码就会变成紧密耦合，因而难以维护**。典型的问题是在一个对象中直接引用另一个对象，这样，修改其中一个，可能必须还得修改另一个。紧密耦合的软件难于维护，肯定需要频繁地重写。\\n\\n考虑到相关的技术，Web 应用程序在某些情况下可能变得过于紧密耦合。关键在于有这个意识，随时注意不要让代码产生紧密耦合。\\n\\n#### 1.3.1 解耦HTML/JavaScript\\n**Web 开发中最常见的耦合是 HTML/JavaScript 耦合**。在网页中，HTML和 JavaScript 分别代表不同层面的解决方案。HTML 是数据，JavaScript 是行为。这是因为它们之间要交互操作，需要通过不同的方式将这两种技术联系起来。可惜的是，其中一些方式会导致 HTML 与 JavaScript 紧密耦合。\\n\\n把 JavaScript 直接嵌入在 HTML 中，要么使用包含嵌入代码的 `<script>` 元素，要么使用 HTML 属性添加事件处理程序，这些都会造成紧密耦合。比如下面的例子：\\n```html\\n<!-- 使用<script>造成HTML/JavaScript紧密耦合 -->\\n<script>\\n  document.write('Hello world!')\\n</script>\\n<!-- 使用事件处理程序属性造成HTML/JavaScript紧密耦合 -->\\n<input type=\\\"button\\\" value=\\\"Click Me\\\" onclick=\\\"handleClick()\\\" />\\n```\\n虽然技术上这样做没有问题，但实践中，这样会将表示数据的 HTML 与定义行为的 JavaScript 紧密耦合在一起。**理想情况下，HTML 和 JavaScript 应该完全分开，通过外部文件引入 JavaScript，然后使用 DOM 添加行为**。\\n\\nHTML 与 JavaScript 紧密耦合的情况下，每次分析 JavaScript 的报错都要先确定错误来自 HTML 还是 JavaScript。这样也会引发代码可用性的新错误。在这个例子中，用户可能会在 `handleClick()` 函数可用之 前点击按钮，从而导致 JavaScript 报错。因为每次修改按钮的行为都需要既改 HTML 又改  JavaScript，而实际上只有后者才是有必要修改的，所以就会降低代码的可维护性。\\n\\n在相反的情况下，HTML 和 JavaScript 也会变得紧密耦合：把 HTML 包含在 JavaScript 中。这种情况通常发生在把一段 HTML 通过 innerHTML 插入到页面中时，示例如下：\\n```js\\n// HTML紧密耦合到了JavaScript\\nfunction insertMessage(msg) {\\n  let container = document.getElementById('container')\\n  container.innerHTML = `\\n    <div class=\\\"msg\\\">\\n      <p> class=\\\"post\\\">${msg}</p>\\n      <p><em>Latest message above.</em></p>\\n    </div>\\n  `\\n}\\n```\\n**一般来说，应该避免在 JavaScript 中创建大量 HTML**。同样，这主要是为了做到数据层和行为层各司其职，在出错时更容易定位问题所在。使用上面的示例代码时，如果动态插入的 HTML 格式不对，就会造成页面布局出错。不过在这种情况下定位错误就更困难了，因为这时候通常首先会去找页面中出错的 HTML 源代码，但又找不到，因为它是动态生成的。修改数据或页面的同时还需要修改J avaScript，这说明两层是紧密耦合的。\\n\\n**HTML 渲染应该尽可能与 JavaScript 分开**。在使用 JavaScript 插入数据时，应该尽可能不要插入标记。相应的标记可以包含并隐藏在页面中，在需要的时候 JavaScript 可以直接用它来显示，而不需要动态生成。另一个办法是通过 Ajax 请求获取要显示的 HTML，这样也可以保证同一个渲染层（PHP、JSP、Ruby等）负责输出标记，而不是把标记嵌 在 JavaScript 中。 \\n\\n**解耦HTML和JavaScript可以节省排错时间，因为更容易定位错误来源**。同样解耦也有助于保证可维护性。修改行为只涉及JavaScript， 修改标记只涉及要渲染的文件。\\n\\n#### 1.3.2 解耦CSS/JavaScript\\nWeb 应用程序的另一层是 CSS，主要负责页面显示。JavaScript 和 CSS 紧密相关，它们都建构在 HTML 之上，因此也经常一起使用。与 HTML和 JavaScript 的情况类似，CSS 也可能与 JavaScript 产生紧密耦合。最常见的例子就是使用 JavaScript 修改个别样式，比如：\\n```js\\n// CSS紧耦合到了JavaScript\\nelement.style.color = 'red'\\nelement.style.backgroundColor = 'blue'\\n```\\n**因为CSS负责页面显示，所以任何样式的问题都应该通过CSS文件解决**。可是，如果JavaScript直接修改个别样式（比如颜色），就会增 加一个排错时要考虑甚至要修改的因素。结果是JavaScript某种程度 上承担了页面显示的任务，与CSS成了紧密耦合。如果将来有一天要修 改样式，那么CSS和JavaScript可能都需要修改。这对负责维护的开发者来说是一个噩梦。层与层的清晰解耦是必需的。 \\n\\n现代Web应用程序经常使用JavaScript改变样式，因此虽然不太可能完全解耦CSS和JavaScript，但可以让这种耦合变成更松散。**这主要可以通过动态修改类名而不是样式来实现**，比如：\\n```js\\n// CSS与JavaScript松散耦合\\nelement.className = \\\"edit\\\";\\n```\\n**通过修改元素的CSS类名，可以把大部分样式限制在CSS文件里**。 JavaScript只负责修改应用样式的类名，而不直接影响元素的样式。 只要应用的类名没错，那么显示的问题就只跟CSS有关，而跟 JavaScript无关。 \\n\\n同样，保证层与层之间的适当分离至关重要。显示出问题就应该只到 CSS中解决，行为出问题就应该只找JavaScript的问题。**这些层之间的松散耦合可以提升整个应用程序的可维护性**。\\n\\n#### 1.3.3 解耦应用程序逻辑/事件处理程序\\n**每个Web应用程序中都会有大量事件处理程序在监听各种事件**。可是，其中很少能真正做到应用程序逻辑与事件处理程序分离。来看下面的例子：\\n```js\\nfunction handleKeyPress(event) {\\n  if (event.keyCode == 13) {\\n    let target = event.target\\n    let value = 5 * parseInt(target.value)\\n    if (value > 10) {\\n      document.getElementById('error-msg').style.display = 'block'\\n    }\\n  }\\n}\\n```\\n这个事件处理程序除了处理事件，还包含了应用程序逻辑。这样做的问题是双重的。\\n* **首先**，除了事件没有办法触发应用程序逻辑，结果造成调试困难。如果没有产生预期的结果怎么办？是因为没有调用事件处理程序，还是因为应用程序逻辑有错误？\\n\\n* **其次**，如果后续事件也会对应相同的应用程序逻辑，则会导致代码重复，或者把它提取到单独的函数中。无论情况如何，都会导致原本不必要的多余工作。\\n\\n**更好的做法是将应用程序逻辑与事件处理程序分开，各自负责处理各自的事情**。事件处理程序应该专注于event 对象的相关信息，然后把这些信息传给处理应用程序逻辑的某些方法。例如，前面的例子可以重写为如下代码：\\n```js\\nfunction validateValue(value) {\\n  value = 5 * parseInt(value)\\n  if (value > 10) {\\n    document.getElementById('error-msg').style.display = 'block'\\n  }\\n}\\n\\nfunction handleKeyPress(event) {\\n  if (event.keyCode == 13) {\\n    let target = event.target\\n    validateValue(target.value)\\n  }\\n}\\n```\\n这样修改之后，**应用程序逻辑跟事件处理程序就分开了**。 `handleKeyPress()` 函数只负责检查用户是不是按下了回车键 （`event.keyCode` 等于13 ），如果是则取得事件目标，并把目标值传给 `validateValue()` 函数，该函数包含应用程序逻辑。注意，`validateValue()` 函数中不包含任何依赖事件处理程序的代码。这个函数只负责接收一个值，并根据该值执行其他所有操作。 \\n\\n把应用程序逻辑从事件处理程序中分离出来有很多好处。\\n* **首先**，这可以让我们以最少的工作量轻松地修改触发某些流程的事件。如果原来是通过鼠标单击触发流程，而现在又想增加键盘操作来触发，那么修改起来也很简单。\\n\\n* **其次**，可以在不用添加事件的情况下测试代码，这样创建单元测试或自动化应用程序流都会更简单。\\n\\n**以下是在解耦应用程序逻辑和业务逻辑时应该注意的几点。**\\n* 不要把 event 对象传给其他方法，而是只传递 event 对象中必要的数据。 \\n\\n* 应用程序中每个可能的操作都应该无需事件处理程序就可以执行。 \\n* 事件处理程序应该处理事件，而把后续处理交给应用程序逻辑。\\n\\n**做到上述几点能够给任何代码的可维护性带来巨大的提升，同时也能为将来的测试和开发提供很多可能性。**\\n\\n### 1.4 编码惯例\\n编写可维护的JavaScript不仅仅涉及代码格式和规范，也涉及代码做什么。企业开发Web应用程序通常需要很多人协同工作。**这时候就需要保证每个人的浏览器环境都有恒定不变的规则**。为此，开发者应该遵守某些编码惯例。\\n\\n#### 1.4.1 尊重对象所有权\\n**JavaScript的动态特性意味着几乎可以在任何时候修改任何东西**。过去有人说，JavaScript中没有什么是神圣不可侵犯的，因为不能把任何东西标记为最终结果或者恒定不变。但ECMAScript 5引入防篡改对象之后，情况不同了。当然，对象默认还是可以修改的。在其他语言中，在没有源代码的情况下，对象和类不可修改。JavaScript则允许在任何时候修改任何对象，因此就可能导致意外地覆盖默认行为。因为这门语言没有什么限制，所以就需要开发者自己限制自己。\\n\\n**在企业开发中，非常重要的编码惯例就是尊重对象所有权，这意味着不要修改不属于你的对象**。简单来讲，如果你不负责创建和维护某个对象及其构造函数或方法，就不应该对其进行任何修改。更具体一点说，就是如下惯例。\\n\\n* 不要给实例或原型添加属性。\\n* 不要给实例或原型添加方法。\\n* 不要重定义已有的方法。\\n\\n**问题在于，开发者会假设浏览器环境以某种方式运行。修改了多个人使用的对象也就意味着会有错误发生**。假设有人希望某个函数叫作 `stopEvent()` ，用于取消某个事件的默认行为。然后，你把它给改了，除了取消事件的默认行为，又添加了其他事件处理程序。可想而知，问题肯定会接踵而至。别人还认为这个函数只做最开始的那点事，但由于对它后来添加的副作用并不知情，因此很可能就会用错或者造成损失。\\n\\n**以上规则不仅适用于自定义类型和对象，而且适用于原生类型和对象**，比如Object 、String 、document 、window ，等等。考虑到浏览器厂商也有可能会在不公开的情况下以非预期方式修改这些对象，潜在的风险就更大了。\\n\\n有个流行的Prototype库就发生过类似的事件。该库在document 对象上实现了 `getElementsByClassName()` 方法，返回一个Array 的实例，而这个实例上还增加了 `each()` 方法。jQuery的作者 John Resig 后来在自己的博客上分析了这个问题造成的影响。他在博客中指出这个问题是由于浏览器也原生实现了相同的 `getElementsByClassName()` 方法造成的，但 Prototype 的同名方法返回的是Array 而非NodeList ，NodeList 没有 `each()` 方法。使用这个库的开发者之前会写这样的代码：\\n```js\\ndocument.getElementsByClassName(\\\"selected\\\").each(Element.hide);\\n```\\n虽然这样写在没有原生实现getElementsByClassName() 方法的浏览器里没有问题，但在实现它的浏览器里就会出问题。这是因为两个同名方法返回的结果不一样。我们不能预见浏览器厂商将来会怎么修改原生对象，因此不管怎么修改它们都可能在将来某个时刻出现冲 突时导致问题。\\n\\n**为此，最好的方法是永远不要修改不属于你的对象**。只有你自己创建的才是你的对象，包括自定义类型和对象字面量。Array 、 document 等对象都不是你的，因为在你的代码执行之前它们已经存在了。可以按如下这样为对象添加新功能。\\n\\n* 创建包含想要功能的新对象，通过它与别人的对象交互。 \\n* 创建新自定义类型继承本来想要修改的类型，可以给自定义类型添加新功能。 \\n\\n很多JavaScript库目前支持这种开发理念，这样无论浏览器怎样改变 都可以发展和适应。\\n\\n#### 1.4.2 不声明全局变量\\n**与尊重对象所有权密切相关的是尽可能不声明全局变量和函数**。同样，这也关系到创建一致和可维护的脚本运行环境。最多可以创建一 个全局变量，作为其他对象和函数的命名空间。来看下面的例子：\\n```js\\n// 两个全局变量：不要！\\nvar name = 'Nicholas'\\nfunction sayName() {\\n  console.log(name)\\n}\\n```\\n以上代码声明了两个全局变量：`name` 和 `sayName()` 。可以像下面这样把它们包含在一个对象中：\\n```js\\n// 一个全局变量：推荐\\nvar MyApplication = {\\n  name: 'Nicholas',\\n  sayName: function() {\\n    console.log(this.name)\\n  }\\n}\\n```\\n这个重写后的版本只声明了一个全局对象 MyApplication 。该对象包含了 `name` 和 `sayName()` 。这样可以避免之前版本的几个问题。\\n* 首先，变量 `name` 会覆盖 `window.name` 属性，而这可能会影响其他功能。\\n* 其次，有助于分清功能都集中在哪里。调用 `MyApplication.sayName()` 从逻辑上会暗示，出现任何问题都可以在MyApplication 的代码中找原因。\\n\\n**这样一个全局对象可以扩展为命名空间的概念**。命名空间涉及创建一个对象，然后通过这个对象来暴露能力。比如，Google Closure 库就利用了这样的命名空间来组织其代码。下面是几个例子。\\n\\n* `goog.string` ：用于操作字符串的方法。 \\n* `goog.html.utils` ：与HTML相关的方法。 \\n* `goog.i18n` ：与国际化（i18n）相关的方法。\\n\\n对象goog 就相当于一个容器，其他对象包含在这里面。**只要使用对象以这种方式来组织功能，就可以称该对象为命名空间**。整个Google Closure库都构建在这个概念之上，能够在同一个页面上与其他 JavaScript库共存。 \\n\\n**关于命名空间，最重要的确定一个所有人都同意的全局对象名称**。这个名称要足够独特，不可能与其他人的冲突。大多数情况下，可以使用开发者所在的公司名，例如goog 或Wrox 。下面的例子演示了使用 Wrox 作为命名空间来组织功能：\\n```js\\n// 创建全局对象\\nvar Wrox = {};\\n// 创建命名空间\\nWrox.ProJS = {};\\n// 添加其他对象\\nWrox.ProJS.EventUtil = { ... };\\nWrox.ProJS.CookieUtil = { ... };\\n```\\n在这个例子中，Wrox 是全局变量，然后在它的下面又创建了命名空间。如果一本书所有代码都保存在Wrox.ProJS 命名空间中，那么其他作者的代码就可以使用自己的对象来保存。只要每个人都遵循这个模式，就不必担心有人会覆盖这里的EventUtil 或CookieUtil ，因为即使重名它们也只会出现在不同的命名空间中。比如下面的例子：\\n\\n```js\\n// 为另一本书创建命名空间\\nWrox.ProAjax = {};\\n// 添加其他对象\\nWrox.ProAjax.EventUtil = { ... };\\nWrox.ProAjax.CookieUtil = { ... };\\n// 可以照常使用ProJS下面的对象\\nWrox.ProJS.EventUtil.addHandler( ... );\\n// 以及ProAjax下面的对象\\nWrox.ProAjax.EventUtil.addHandler( ... );\\n```\\n**虽然命名空间需要多写一点代码，但从可维护性角度看，这个代价还是非常值得的。命名空间可以确保代码与页面上的其他代码互不干扰。**\\n\\n#### 1.4.3 不要比较null\\n**JavaScript不会自动做任何类型检查，因此就需要开发者担起这个责任**。结果，很多JavaScript代码不会做类型检查。**最常见的类型检查是看值是不是null**。然而，与null 进行比较的代码太多了，其中很多因为类型检查不够而频繁引发错误。比如下面的例子：\\n```js\\nfunction sortArray(values) {\\n  if (values != null) {\\n    // 不要这样比较！\\n    values.sort(comparator)\\n  }\\n}\\n```\\n这个函数的目的是使用给定的比较函数对数组进行排序。为保证函数正常执行，values 参数必须是数组。但是，if 语句在这里只简单地检查了这个值不是null 。实际上，字符串、数值还有其他很多值可以通过这里的检查，结果就会导致错误。 \\n\\n**现实当中，单纯比较null 通常是不够的。检查值的类型就要真的检查类型，而不是检查它不能是什么**。例如，在前面的代码中，values 参数应该是数组。为此，应该检查它到底是不是数组，而不是检查它不是null 。可以像下面这样重写那个函数：\\n```js\\nfunction sortArray(values) {\\n  if (values instanceof Array) {\\n    // 推荐\\n    values.sort(comparator)\\n  }\\n}\\n```\\n此函数的这个版本可以过滤所有无效的值，根本不需要使用null 。 \\n\\n如果看到比较null 的代码，可以使用下列某种技术替换它。 \\n* **如果值应该是引用类型**，则使用 `instanceof` 操作符检查其构造函数。\\n\\n* **如果值应该是原始类型**，则使用 `typeof` 检查其类型。\\n* **如果希望值是有特定方法名的对象**，则使用 `typeof` 操作符确保 对象上存在给定名字的方法。代码中比较null 的地方越少，就越容易明确类型检查的目的，从而消除不必要的错误。\\n\\n#### 1.4.4 使用常量\\n**依赖常量的目标是从应用程序逻辑中分离数据，以便修改数据时不会引发错误**。显示在用户界面上的字符串就应该以这种方式提取出来，可以方便实现国际化。URL也应该这样提取出来，因为随着应用程序越来越复杂，URL极有可能变化。基本上，像这种地方将来因为某种原因而需要修改时，可能就要找到某个函数并修改其中的代码。每次像这样修改应用程序逻辑，都可能引入新错误。**为此，可以把这些可能会修改的数据提取出来，放在单独定义的常量中，以实现数据与逻辑分离。**\\n\\n关键在于把数据从使用它们的逻辑中分离出来。可以使用以下标准检查哪些数据需要提取。\\n\\n* **重复出现的值** ：任何使用超过一次的值都应该提取到常量中，这样可以消除一个值改了而另一个值没改造成的错误。这里也包括 CSS的类名。 \\n\\n* **用户界面字符串** ：任何会显示给用户的字符串都应该提取出来，以方便实现国际化。 \\n* **URL** ：Web应用程序中资源的地址经常会发生变化，因此建议把所有URL集中放在一个地方管理。\\n* **任何可能变化的值** ：任何时候，只要在代码中使用字面值，就问问自己这个值将来是否可能会变。如果答案是“是”，那么就应该把它提取到常量中。\\n\\n使用常量是企业级JavaScript开发的重要技术，因为它可以让代码更容易维护，同时可以让代码免受数据变化的影响。\\n\\n## 2. 性能\\n相比JavaScript刚问世时，目前每个网页中JavaScript代码的数量已有极大的增长。代码量的增长也带来了运行时执行JavaScript的性能问题。 **JavaScript一开始就是一门解释型语言，因此执行速度比编译型语言要慢一些**。Chrome是第一个引入优化引擎将JavaScript编译为原生代码的浏览器。随后，其他主流浏览器也紧随其后，实现了JavaScript编译。\\n\\n即使到了编译JavaScript时代，仍可能写出运行慢的代码。**不过，如果遵循一些基本模式，就能保证写出执行速度很快的代码。**\\n\\n### 2.1 作用域意识\\n随着作用域链中作用域数量的增加，访问当前作用域外部变量所需的时间也会增加。访问全局变量始终比访问局部变量慢，因为必须遍历作用域链。**任何可以缩短遍历作用域链时间的举措都能提升代码性能。**\\n\\n#### 2.1.1 避免全局查找\\n**改进代码性能非常重要的一件事，可能就是要提防全局查询**。全局变量和函数相比于局部值始终是最费时间的，因为需要经历作用域链查找。来看下面的函数：\\n```js\\nfunction updateUI() {\\n  let imgs = document.getElementsByTagName('img')\\n  for (let i = 0, len = imgs.length; i < len; i++) {\\n    imgs[i].title = `${document.title} image ${i}`\\n  }\\n  let msg = document.getElementById('msg')\\n  msg.innerHTML = 'Update complete.'\\n}\\n```\\n这个函数看起来好像没什么问题，**但其中三个地方引用了全局 document 对象**。如果页面的图片非常多，那么 for 循环中就需要引用 document 几十甚至上百次，**每次都要遍历一次作用域链**。\\n* 通过在局部作用域中保存 document 对象的引用，能够明显提升这个函数的性能，因为只需要作用域链查找 。\\n* 通过创建一个指向 document 对象的局部变量，可以通过将全局查找的数量限制为一个来提高这个函数的性能：\\n\\n```js\\nfunction updateUI() {\\n  let doc = document\\n  let imgs = doc.getElementsByTagName('img')\\n  for (let i = 0, len = imgs.length; i < len; i++) {\\n    imgs[i].title = `${doc.title} image ${i}`\\n  }\\n  let msg = doc.getElementById('msg')\\n  msg.innerHTML = 'Update complete.'\\n}\\n```\\n这里先把 document 对象保存在局部变量 doc 中。然后用 doc 替代 了代码中所有的 document。这样调用这个函数只会查找一次作用域链，相对上一个版本，肯定会快很多。 \\n\\n**因此，一个经验规则就是，只要函数中有引用超过两次的全局对象，就应该把这个对象保存为一个局部变量。**\\n\\n#### 2.1.2 不使用with语句\\n**在性能很重要的代码中，应避免使用 with 语句**。与函数类似，with 语句会创建自己的作用域，因此也会加长其中代码的作用域链。**在 with 语句中执行的代码一定比在它外部执行的代码慢，因为作用域链查找时多一步**。 \\n\\n**实际编码时很少有需要使用with 语句的情况，因为它的主要用途是节省一点代码**。大多数情况下，使用局部变量可以实现同样的效果，无须增加新作用域。下面看一个例子：\\n```js\\nfunction updateBody() {\\n  with (document.body) {\\n    console.log(tagName)\\n    innerHTML = 'Hello world!'\\n  }\\n}\\n```\\n这段代码中的 with 语句让使用 `document.body` 更简单了。使用局部变量也可以实现同样的效果，如下：\\n```js\\nfunction updateBody() {\\n  let body = document.body\\n  console.log(body.tagName)\\n  body.innerHTML = 'Hello world!'\\n}\\n```\\n虽然这段代码多了几个字符，但比使用 with 语句还更容易理解了， 因为 tagName 和 innerHTML 属于谁很明确。这段代码还通过把 `document.body` 保存在局部变量中来省去全局查找。\\n\\n### 2.2 选择正确的方法\\n**与其他语言一样，影响性能的因素通常涉及算法或解决问题的方法**。经验丰富的开发者知道用什么方法性能更佳。通常很多能在其他编程语言中提升性能的技术和方法同样也适用于JavaScript。\\n\\n#### 2.2.1 避免不必要的属性查找\\n在计算机科学中，算法复杂度使用大表示法来表示。最简单同时也最快的算法可以表示为常量值或。然后，稍微复杂一些的算法同时执行时间也更长一些。下表列出了JavaScript中常见算法的类型。\\n\\n\\n| 表示法 | 名称 | 说明 |\\n| :---: | :---: | :---: |\\n| O(1) | 常量 | 无论多少值，执行时间都不变。表示简单值和保存在变量中的值 |\\n| O(log n) | 对数 | 执行时间随着值的增加而增加，但算法完成不需要读取每个值。 例子：二分查找 |\\n| O(n) | 线性 | 执行时间与值的数量直接相关。例子：迭代数组的所有元素 |\\n| O(n^2) | 二次方 | 执行时间随着值的增加而增加，而且每个值至少要读取 次。例 子：插入排序 |\\n\\n**常量值或O(1) ，指字面量和保存在变量中的值，表示读取常量值所需的时间不会因值的多少而变化**。读取常量值是效率极高的操作，因此非常快。来看下面的例子：\\n```js\\nlet value = 5\\nlet sum = 10 + value\\nconsole.log(sum)\\n```\\n以上代码查询了4次常量值：数值5、变量value 、数值10和变量sum 。整体代码的复杂度可以认为是O(1)。\\n\\n**在JavaScript中访问数组元素也是O(1)操作，与简单的变量查找一样**。因此，下面的代码与前面的例子效率一样：\\n```js\\nlet values = [5, 10]\\nlet sum = values[0] + values[1]\\nconsole.log(sum)\\n```\\n**使用变量和数组相比访问对象属性效率更高，访问对象属性的算法复杂度是O(n)**。访问对象的每个属性都比访问变量或数组花费的时间长，**因为查找属性名要搜索原型链**。简单来说，**查找的属性越多，执行时间就越长**。来看下面的例子：\\n```js\\nlet values = { first: 5, second: 10 }\\nlet sum = values.first + values.second\\nconsole.log(sum)\\n```\\n这个例子使用两次属性查找来计算sum 的值。一两次属性查找可能不会有明显的性能问题，但几百上千次则绝对会拖慢执行速度。\\n\\n特别要注意避免通过多次查找获取一个值。例如，看下面的例子：\\n```js\\nlet query = window.location.href.substring(window.location.href.indexOf('?'))\\n```\\n这里有6次属性查找：\\n* 3次是为查找 `window.location.href.substring()`\\n* 3次是为查找 `window.location.href.indexOf()`\\n\\n通过数代码中出现的点号数量，就可以知道有几次属性查找。以上代码效率特别低，这是因为使用了两次 `window.location.href` ，即同样的查找执行了两遍。\\n\\n**只要使用某个object 属性超过一次，就应该将其保存在局部变量中**。第一次仍然要用O(n)的复杂度去访问这个属性，但后续每次访问就都是O(1)，这样就是质的提升了。例如，前面的代码可以重写为如下：\\n\\n```js\\nlet url = window.location.href\\nlet query = url.substring(url.indexOf('?'))\\n```\\n这个版本的代码只有4次属性查找，比之前节省了约33%。在大型脚本中如果能这样优化，可能就会明显改进性能。 \\n\\n**通常，只要能够降低算法复杂度，就应该尽量通过在局部变量中保存值来替代属性查找**。另外，如果实现某个需求既可以使用数组的数值索引，又可以使用命名属性（比如NodeList 对象），那就都应该使用数值索引。\\n\\n#### 2.2.2 优化循环\\n**循环是编程中常用的语法构造，因此在JavaScript中也十分常见**。优化这些循环是性能优化的重要内容，因为循环会重复多次运行相同的代码，所以运行时间会自动增加。其他语言有很多关于优化循环的研究，这些技术同样适用于JavaScript。优化循环的基本步骤如下。\\n\\n1. **简化终止条件** 。因为每次循环都会计算终止条件，所以它应该尽可能地快。这意味着要避免属性查找或其他操作。 \\n\\n2. **简化循环体** 。循环体是最花时间的部分，因此要尽可能优化。要确保其中不包含可以轻松转移到循环外部的密集计算。\\n\\n3. **使用后测试循环** 。最常见的循环就是 for 和 while 循环，这两种循环都属于先测试循环。do-while 就是后测试循环，避免了对终止条件初始评估 ，因此应该会更快。\\n\\n>注意：在旧版浏览器中，从循环迭代器的最大值开始递减至0的效率更高。之所以这样更快，是因为JavaScript引擎用于检查循环分支条件的指令数更少。在现代浏览器中，正序还是倒序不会有可感知的性能差异。因此可以选择最适合代码逻辑的迭代方式。\\n\\n以上优化的效果可以通过下面的例子展示出来。这是一个简单的for 循环：\\n```js\\nfor (let i = 0; i < values.length; i++) {\\n  process(values[i])\\n}\\n```\\n这个循环会将变量 i 从 0 递增至数组values 的长度。假设处理这些值的顺序不重要，**那么可以将循环变量改为递减的形式**，如下所示：\\n```js\\nfor (let i = values.length - 1; i >= 0; i--) {\\n  process(values[i])\\n}\\n```\\n这一次，变量 i 每次循环都会递减。在这个过程中，终止条件的计算复杂度也从查找 `values.length` 的变成了访问 0 的。循环体只有一条语句，已不能再优化了。不过，整个循环可修改为后测试循环：\\n```js\\nlet i = values.length - 1\\nif (i > -1) {\\n  do {\\n    process(values[i])\\n  } while (--i >= 0)\\n}\\n```\\n**这里主要的优化是将终止条件和递减操作符合并成了一条语句**。然后，如果再想优化就只能去优化 `process()` 的代码，因为循环已没有可以优化的点了。\\n\\n**使用后测试循环时要注意，一定是至少有一个值需要处理一次**。如果 这里的数组是空的，那么会浪费一次循环，而先测试循环就可以避免这种情况。\\n\\n#### 2.2.3 展开循环\\n**如果循环的次数是有限的，那么通常抛弃循环而直接多次调用函数会更快**。仍以前面的循环为例，如果数组长度始终一样，则可能对每个元素都调用一次 `process()` 效率更高：\\n```js\\n// 抛弃循环\\nprocess(values[0])\\nprocess(values[1])\\nprocess(values[2])\\n```\\n这个例子假设 values 数组始终只有3个值，然后分别针对每个元素调用一次`process()` 。像这样展开循环可以节省创建循环、计算终止条件的消耗，从而让代码运行更快。\\n\\n**如果不能提前预知循环的次数，那么或许可以使用一种叫作达夫设备 （Duff's Device）的技术**。该技术是以其发明者Tom Duff命名的，他最早建议在C语言中使用该技术。在JavaScript实现达夫设备的人是 Jeff Greenberg。达夫设备的基本思路是以 8 的倍数作为迭代次数从而将循环展开为一系列语句。来看下面的例子：\\n```js\\n// 来源：Jeff Greenberg在 JavaScript 中实现的达夫设备\\n// 假设 values.length > 0\\nlet iterations = Math.ceil(values.length / 8)\\nlet startAt = values.length % 8\\nlet i = 0\\ndo {\\n  switch (startAt) {\\n    case 0:\\n      process(values[i++])\\n    case 7:\\n      process(values[i++])\\n    case 6:\\n      process(values[i++])\\n    case 5:\\n      process(values[i++])\\n    case 4:\\n      process(values[i++])\\n    case 3:\\n      process(values[i++])\\n    case 2:\\n      process(values[i++])\\n    case 1:\\n      process(values[i++])\\n  }\\n  startAt = 0\\n} while (--iterations > 0)\\n```\\n这个达夫设备的实现首先通过用 `values` 数组的长度除以 8 计算需要多少次循环。`Math.ceil()` 用于保证这个值是整数。`startAt` 变量保存着仅按照除以 8 来循环不会处理的元素个数。第一次循环执行时，会检查 `startAt` 变量，以确定要调用 `process()` 多少次。例如，假设数组有 10 个元素，则 `startAt` 变量等于 2，因此第一次循环只会调用 `process()` 两次。第一次循环末尾，`startAt` 被重置为 0。于是后续每次循环都会调用 8 次 `process()` 。这样展开之后，能够加快大数据集的处理速度。\\n\\nAndrew B. King 在 Speed Up Your Site 一书中提出了更快的达夫设备实现，他将 do-while 循环分成了两个单独的循环，如下所示：\\n```js\\n// 来源：Speed Up Your Site（New Riders，2003）\\nlet iterations = Math.floor(values.length / 8)\\nlet leftover = values.length % 8\\nlet i = 0\\nif (leftover > 0) {\\n  do {\\n    process(values[i++])\\n  } while (--leftover > 0)\\n}\\ndo {\\n  process(values[i++])\\n  process(values[i++])\\n  process(values[i++])\\n  process(values[i++])\\n  process(values[i++])\\n  process(values[i++])\\n  process(values[i++])\\n  process(values[i++])\\n} while (--iterations > 0)\\n```\\n在这个实现中，变量 `leftover` 保存着只按照除以 8 来循环不会处理， 因而会在第一个循环中处理的次数。处理完这些额外的值之后进入主循环，每次循环调用 8 次 `process()` 。这个实现比原始的实现快约  40%。\\n\\n展开循环对于大型数据集可以节省很多时间，但对于小型数据集来说，则可能不值得。因为实现同样的任务需要多写很多代码，所以如果处理的数据量不大，那么显然没有必要。\\n\\n#### 2.2.4 避免重复解释\\n**重复解释的问题存在于 JavaScript 代码尝试解释 JavaScript 代码的情形**。在使用 `eval()` 函数或 `Function` 构造函数，或者给 `setTimeout()` 传入字符串参数时会出现这种情况。下面是几个例子：\\n```js\\n// 对代码求值：不要\\neval(\\\"console.log('Hello world!')\\\")\\n// 创建新函数：不要\\nlet sayHi = new Function(\\\"console.log('Hello world!')\\\")\\n// 设置超时函数：不要\\nsetTimeout(\\\"console.log('Hello world!')\\\", 500)\\n```\\n在上面所列的每种情况下，都需要重复解释包含JavaScript代码的字符串。**这些字符串在初始解析阶段不会被解释，因为代码包含在字符串里**。这意味着在JavaScript运行时，必须启动新解析器实例来解析这些字符串中的代码。**实例化新解析器比较费时间，因此这样会比直接包含原生代码慢。**\\n\\n这些情况都有对应的解决方案。很少有情况绝对需要使用 `eval()` ， 因此应该尽可能不使用它。此时，只要把代码直接写出来就好了。对于 `Function` 构造函数，重写为常规函数也很容易。而调用 `setTimeout()` 时则可以直接把函数作为第一个参数。比如：\\n```js\\n// 直接写出来\\nconsole.log('Hello world!')\\n// 创建新函数：直接写出来\\nlet sayHi = function() {\\n  console.log('Hello world!')\\n}\\n// 设置超时函数：直接写出来\\nsetTimeout(function() {\\n  console.log('Hello world!')\\n}, 500)\\n```\\n**为了提升代码性能，应该尽量避免使用要当作JavaScript代码解释的字符串。**\\n\\n#### 2.2.5 其他性能优化注意事项\\n在评估代码性能时还有一些地方需要注意。下面列出的虽然不是主要问题，但在使用比较频繁的时候也可能有所不同。\\n* **原生方法很快** 。应该尽可能使用原生方法，而不是使用 JavaScript 写的方法。原生方法是使用C或C++等编译型语言写的，因此比JavaScript写的方法要快得多。JavaScript 中经常被忽视的是 `Math` 对象上那些执行复杂数学运算的方法。这些方法总是比执行相同任务的JavaScript函数快得多，比如求正弦、余 弦等。 \\n\\n* **switch 语句很快** 。如果代码中有复杂的 if-else 语句，将其转换成switch 语句可以变得更快。然后，通过重新组织分支，把最可能的放前面，不太可能的放后面，可以进一步提升性能。 \\n\\n* **位操作很快** 。在执行数学运算操作时，位操作一定比任何布尔值或数值计算更快。选择性地将某些数学操作替换成位操作，可以极大提升复杂计算的效率。像求模、逻辑AND与和逻辑OR或都很适合替代成位操作。\\n\\n### 2.3 语句最少化\\n**JavaScript代码中语句的数量影响操作执行的速度**。一条可以执行多个操作的语句，比多条语句中每个语句执行一个操作要快。那么优化的目标就是寻找可以合并的语句，以减少整个脚本的执行时间。为此，可以参考如下几种模式。\\n#### 2.3.1 多个变量声明\\n```js\\n// 有四条语句：浪费\\nlet count = 5\\nlet color = 'blue'\\nlet values = [1, 2, 3]\\nlet now = new Date()\\n```\\n在强类型语言中，不同数据类型的变量必须在不同的语句中声明。**但在JavaScript中，所有变量都可以使用一个 let 语句声明**。前面的代码可以改写为如下：\\n```js\\n// 一条语句更好\\nlet count = 5,\\n  color = 'blue',\\n  values = [1, 2, 3],\\n  now = new Date()\\n```\\n这里使用一个 let 声明了所有变量，变量之间以逗号分隔。这种优化很容易做到，且比使用多条语句执行速度更快。\\n\\n#### 2.3.2 插入迭代性值\\n任何时候只要使用迭代性值（即会递增或递减的值），都要尽可能使用组合语句。来看下面的代码片段：\\n```js\\nlet name = values[i]\\ni++\\n```\\n前面代码中的两条语句都只有一个作用：\\n* 第一条从 values 中取得一个值并保存到 name 中\\n* 第二条递增变量 i\\n\\n把迭代性的值插入第一条语句就可以将它们合并为一条语句：\\n```js\\nlet name = values[i++]\\n```\\n这一条语句完成了前面两条语句完成的事情。**因为递增操作符是后缀形式的，所以 i 在语句其他部分执行完成之前是不会递增的**。只要遇到类似的情况，就要尽量把迭代性值插入到上一条使用它的语句中。\\n\\n#### 2.3.3 使用数组和对象字面量\\n**两种使用数组和对象的方式：构造函数和字面量**。使用构造函数始终会产生比单纯插入元素或定义属性更多的语句，而字面量只需一条语句即可完成全部操作。来看下面的例子：\\n```js\\n// 创建和初始化数组用了四条语句：浪费\\nlet values = new Array()\\nvalues[0] = 123\\nvalues[1] = 456\\nvalues[2] = 789\\n// 创建和初始化对象用了四条语句：浪费\\nlet person = new Object()\\nperson.name = 'Nicholas'\\nperson.age = 29\\nperson.sayName = function() {\\n  console.log(this.name)\\n}\\n```\\n在这个例子中，分别创建和初始化了一个数组和一个对象。两件事都 用了四条语句：一条调用构造函数，三条添加数据。这些语句很容易转换成字面量形式:\\n```js\\n// 一条语句创建并初始化数组\\nlet values = [123, 456, 789]\\n// 一条语句创建并初始化对象\\nlet person = {\\n  name: 'Nicholas',\\n  age: 29,\\n  sayName() {\\n    console.log(this.name)\\n  }\\n}\\n```\\n重写后的代码只有两条语句：一条创建并初始化数组，另一条创建并初始化对象。相对于前面使用了8条语句，这里使用两条语句，减少了 75% 的语句量。对于数千行的JavaScript代码，这样的优化效果可能更明显。\\n\\n**应尽可能使用数组或对象字面量，以消除不必要的语句。**\\n\\n>注意：减少代码中的语句量是很不错的目标，但不是绝对的法则。一味追求语句最少化，可能导致一条语句容纳过多逻辑，最终难以理解。\\n\\n### 2.4 优化DOM交互\\n**在所有JavaScript代码中，涉及DOM的部分无疑是非常慢的**。DOM操作和交互需要占用大量时间，因为经常需要重新渲染整个或部分页面。此外，看起来简单的操作也可能花费很长时间，因为DOM中携带着大量信息。理解如何优化DOM交互可以极大地提升脚本的执行速度。\\n\\n#### 2.4.1 实时更新最小化\\n**访问DOM时，只要访问的部分是显示页面的一部分，就是在执行实时更新操作**。之所以称其为实时更新，是因为涉及立即（实时）更新页面 的显示，让用户看到。每次这样的更新，无论是插入一个字符还是删除页面上的一节内容，都会导致性能损失。这是因为浏览器需要为此重新计算数千项指标，之后才能执行更新。实时更新的次数越多，执行代码所需的时间也越长。反之，实时更新的次数越少，代码执行就越快。来看下面的例子：\\n```js\\nlet list = document.getElementById('myList'),\\n  item\\nfor (let i = 0; i < 10; i++) {\\n  item = document.createElement('li')\\n  list.appendChild(item)\\n  item.appendChild(document.createTextNode('Item ${i}'))\\n}\\n```\\n以上代码向列表中添加了10项。每添加1项，就会有两次实时更新：一次添加`<li>`元素，一次为它添加文本节点。因为要添加10项，所以整个操作总共要执行20次实时更新。 \\n\\n为解决这里的性能问题，需要减少实时更新的次数。有两个办法可以实现这一点。\\n* 第一个办法是从页面中移除列表，执行更新，然后再把 列表插回页面中相同的位置。这个办法并不可取，因为每次更新时页面都会闪烁。\\n\\n* **第二个办法是使用文档片段构建 DOM 结构，然后一次性将 它添加到 list 元素**。这个办法可以减少实时更新，也可以避免页面闪烁。比如：\\n```js\\nlet list = document.getElementById('myList'),\\n  fragment = document.createDocumentFragment(),\\n  item\\nfor (let i = 0; i < 10; i++) {\\n  item = document.createElement('li')\\n  fragment.appendChild(item)\\n  item.appendChild(document.createTextNode('Item ' + i))\\n}\\nlist.appendChild(fragment)\\n```\\n这样修改之后，完成同样的操作只会触发一次实时更新。这是因为更新是在添加完所有列表项之后一次性完成的。文档片段在这里作为新创建项目的临时占位符。最后，使用 `appendChild()` 将所有项目都添加到列表中。别忘了，在把文档片段传给 `appendChild()` 时，会把片段的所有子元素添加到父元素，片段本身不会被添加。 \\n\\n**只要是必须更新DOM，就尽量考虑使用文档片段来预先构建DOM结构，然后再把构建好的DOM结构实时更新到文档中。**\\n#### 2.4.2 使用innerHTML\\n在页面中创建新DOM节点的方式有两种：使用DOM方法如 `createElement()` 和 `appendChild()`，以及使用 `innerHTML`。 对于少量DOM更新，这两种技术区别不大，**但对于大量DOM更新，使用 innerHTML 要比使用标准DOM方法创建同样的结构快很多**。 \\n\\n在给 innerHTML 赋值时，后台会创建 HTML 解析器，然后会使用原生 DOM 调用而不是 JavaScript 的 DOM 方法来创建 DOM 结构。**原生DOM方法速度更快，因为该方法是执行编译代码而非解释代码**。前面的例子如果使用 innerHTML 重写就是这样的：\\n```js\\nlet list = document.getElementById('myList'),\\n  html = ''\\nfor (let i = 0; i < 10; i++) {\\n  html += '<li>Item ${i}</li>'\\n}\\nlist.innerHTML = html\\n```\\n以上代码构造了一个HTML字符串，然后将它赋值给 `list.innerHTML` ，结果也会创建适当的DOM结构。虽然拼接字符串也会有一些性能损耗，但这个技术仍然比执行多次DOM操作速度更快。\\n\\n**与其他DOM操作一样，使用 innerHTML 的关键在于最小化调用次数**。 例如，下面的代码使用innerHTML 的次数就太多了：\\n```js\\nlet list = document.getElementById('myList')\\nfor (let i = 0; i < 10; i++) {\\n  list.innerHTML += '<li>Item ${i}</li>' // 不要\\n}\\n```\\n这里的问题是每次循环都会调用 innerHTML ，因此效率极低。事实上，调用 innerHTML 也应该看成是一次实时更新。构建好字符串然后调用一次 innerHTML 比多次调用 innerHTML 快得多。\\n>注意：使用 innerHTML 可以提升性能，但也会暴露巨大的 XSS 攻击面。无论何时使用它填充不受控的数据，都有可能被攻击者注入可执行代码。此时必须要当心。\\n\\n#### 2.4.3 使用事件委托\\n大多数 Web 应用程序会大量使用事件处理程序实现用户交互。一个页面中事件处理程序的数量与页面响应用户交互的速度有直接关系。**为了减少对页面响应的影响，应该尽可能使用事件委托。**\\n\\n**事件委托利用了事件的冒泡**。任何冒泡的事件都可以不在事件目标上，而在目标的任何祖先元素上处理。基于这个认知，可以把事件处理程序添加到负责处理多个目标的高层元素上。只要可能，就应该在文档级添加事件处理程序，因为在文档级可以处理整个页面的事件。\\n\\n#### 2.4.4 注意HTMLCollection\\n由于Web应用程序存在很大的性能问题，`HTMLCollection` 对象是有缺点。任何时候，只要访问HTMLCollection ，无论是它的属性还是方法，就会触发查询文档，而这个查询相当耗时。减少访问HTMLCollection 的次数可以极大地提升脚本的性能。 \\n\\n**可能优化 HTMLCollection 访问最关键地方就是循环了**。之前，我们讨论过要把计算 HTMLCollection 长度的代码转移到 for 循环初始化的部分。来看下面的例子：\\n```js\\nlet images = document.getElementsByTagName('img')\\nfor (let i = 0, len = images.length; i < len; i++) {\\n  // 处理\\n}\\n```\\n这里的关键是把 length 保存到了 len 变量中，而不是每次都读一次 HTMLCollection 的 length 属性。在循环中使用 HTMLCollection 时，应该首先取得对要使用的元素的引用，如下面所示。这样才能避免在循环体内多次调用 HTMLCollection ：\\n```js\\nlet images = document.getElementsByTagName('img'),\\n  image\\nfor (let i = 0, len = images.length; i < len; i++) {\\n  image = images[i]\\n  // 处理\\n}\\n```\\n这段代码增加了image 变量，用于保存当前的图片。有了这个局部变 量，就不需要在循环中再访问images HTMLCollection 了。 \\n\\n编写JavaScript代码时，关键是要记住，只要返回HTMLCollection 对象，就应该尽量不访问它。以下情形会返回HTMLCollection ：\\n* 调用 getElementsByTagName() ； \\n* 读取元素的 childNodes 属性；\\n* 读取元素的 attributes 属性；\\n* 访问特殊集合，如 document.form 、document.images 等。\\n\\n理解什么时候会碰到 HTMLCollection 对象并适当地使用它，有助于明显地提升代码执行速度。\\n\\n## 3. 部署\\n**任何JavaScript解决方案最重要的部分可能就是把网站或Web应用程序部署到线上环境了**。在此之前我们已完成了很多工作，包括架构方面和优化方面的。现在到了把代码移出开发环境，发布到网上，让用户去使用它的时候了。不过，在发布之前还需要解决一些问题。\\n\\n### 3.1 构建流程\\n**准备发布JavaScript代码时最重要一环是准备构建流程**。开发软件的典型模式是编码、编译和测试。换句话说，首先要写代码，然后编译，之后运行并确保它能够正常工作。\\n\\n但因为JavaScript不是编译型语言，所以这个流程经常会变成编码、测试。你写的代码跟在浏览器中测试的代码一样。这种方式的问题在于代码并不是最优的。你写的代码不应该不做任何处理就直接交给浏览器，原因如下。\\n* **知识产权问题** ：如果把满是注释的代码放到网上，其他人就很容易了解你在做什么，重用它，并可能发现安全漏洞。 \\n* **文件大小** ：你写的代码可读性很好，容易维护，但性能不好。浏览器不会因为代码中多余的空格、缩进、冗余的函数和变量名而受益。 \\n* **代码组织** ：为保证可维护性而组织的代码不一定适合直接交付给浏览器。\\n\\n为此，需要为JavaScript文件建立构建流程。\\n\\n#### 3.1.1 文件结构\\n**构建流程首先定义在源代码控制中存储文件的逻辑结构**。最好不要在一个文件中包含所有JavaScript代码。**相反，要遵循面向对象编程语言的典型模式，把对象和自定义类型保存到自己独立的文件中**。这样可以让每个文件只包含最小量的代码，让后期修改更方便，也不易引 入错误。\\n\\n此外，在使用并发源代码控制系统（如Git、CVS或 Subversion）的环境中，这样可以**减少合并时发生冲突的风险。**\\n\\n**注意，把代码分散到多个文件是从可维护性而不是部署角度出发的**。对于部署，应该把所有源文件合并为一个或多个汇总文件。Web应用程序使用的JavaScript文件越少越好，因为HTTP请求对某些Web应用程序而言是主要的性能瓶颈。**而且，使用 `<script>` 标签包含 JavaScript 是阻塞性操作**，这导致代码下载和执行期间停止所有其他下载任务。 因此，要尽量以符合逻辑的方式把JavaScript代码组织到部署文件中。\\n\\n#### 3.1.2 任务运行器\\n**如果要把大量文件组合成一个应用程序，很可能需要任务运行器自动完成一些任务**。任务运行器可以完成代码检查、打包、转译、启动本地服务器、部署，以及其他可以脚本化的任务。 \\n\\n很多时候，任务运行器要通过命令行界面来执行操作。因此你的任务运行器可能仅仅是一个辅助组织和排序复杂命令行调用的工具。从这个意义上说，任务运行器在很多方面非常像 `.bashrc` 文件。其他情况下，要在自动化任务中使用的工具可能是一个兼容的插件。 \\n\\n**如果你使用 Node.js 和 npm 打印 JavaScript 资源，Grunt 和 Gulp 是两个主流的任务运行器**。它们非常稳健，其任务和指令都是通过配置文件，以纯 JavaScript 形式指定的。使用 Grunt 和 Gulp 的好处是它们分别有各自的插件生态，因此可以直接使用npm包。\\n\\n#### 3.1.3 摇树优化\\n**摇树优化（tree shaking）是非常常见且极为有效的减少冗余代码的策略**。使用静态模块声明风格意味着构建工具可以确定代码各部分之间的依赖关系。更重要的是，摇树优化还能确定代码中的哪些内容是完全不需要的。 \\n\\n实现了摇树优化策略的构建工具能够分析出选择性导入的代码，其余模块文件中的代码可以在最终打包得到的文件中完全省略。假设下面是个示例应用程序：\\n```js\\nimport { foo } from './utils.js'\\nconsole.log(foo)\\nexport const foo = 'foo'\\nexport const bar = 'bar' // unused\\n```\\n这里导出的 bar 就没有被用上，而构建工具可以很容易发现这种情况。在执行摇树优化时，构建工具会将bar 导出完全排除在打包文件之外。静态分析也意味着构建工具可以确定未使用的依赖，同样也会排除掉。通过摇树优化，最终打包得到的文件可以瘦身很多。\\n\\n#### 3.1.4 模块打包器\\n**以模块形式编写代码，并不意味着必须以模块形式交付代码**。通常，由大量模块组成的JavaScript代码在构建时需要打包到一起，然后只交付一个或少数几个JavaScript文件。 \\n\\n模块打包器的工作是识别应用程序中涉及的JavaScript依赖关系，将它们组合成一个大文件，完成对模块的串行组织和拼接，然后生成最终提供给浏览器的输出文件。\\n\\n能够实现模块打包的工具非常多。Webpack、Rollupt 和 Browserify 只是其中的几个，可以将基于模块的代码转换为普遍兼容的网页脚本。\\n\\n### 3.2 验证\\n即使已出现了能够理解和支持JavaScript的IDE，大多数开发者仍通过在浏览器中运行代码来验证自己的语法。这种方式有很多问题。\\n* 首先，如此验证不容易自动化，也不方便从一个系统移植到另一个系统。\\n\\n* 其次，除了语法错误，只有运行的代码才可能报错，没有运行到的代码则无法验证。有 一些工具可以帮我们发现JavaScript代码中潜在的问题，最流行的是 Douglas Crockford的JSLint和ESLint。 \\n\\n这些代码检查工具可以发现JavaScript代码中的语法错误和常见的编码错误。下面是它们会报告的一些问题：\\n\\n* 使用 eval() ； \\n* 使用未声明的变量； \\n* 遗漏了分号； \\n* 不适当地换行； \\n* 不正确地使用逗号； \\n* 遗漏了包含语句的括号； \\n* 遗漏了switch 分支中的 break ； \\n* 重复声明变量； \\n* 使用了 with ； \\n* 错误地使用等号（应该是两个或三个等号）； \\n* 执行不到的代码。\\n\\n在开发过程中添加代码检查工具有助于避免出错。推荐开发者在构建流程中也加入代码检查环节，以便在潜在问题成为错误之前识别它们。\\n\\n### 3.3 压缩\\n谈到JavaScript文件压缩，实际上主要是两件事：**代码大小** （code size）和 **传输负载** （wire weight）。\\n* 代码大小指的是浏览器需要解析的字节数\\n\\n* 而传输负载是服务器实际发送给浏览器的字节数。\\n\\n在Web开发的早期阶段，这两个数值几乎相等，服务器发送给浏览器的是未经修改的源文件。而今天，这两个数值不可能相等，实际上也不应该相等。\\n\\n#### 3.3.1 代码压缩\\n**JavaScript不是编译成字节码，而是作为源代码传输的**，所以源代码文件通常包含对浏览器的JavaScript解释器没有用的额外信息和格式。JavaScript压缩工具可以把源代码文件中的这些信息删除，并在保证程序逻辑不变的前提下缩小文件大小。\\n\\n**注释、额外的空格、长变量或函数名都能提升开发者的可读性，但对浏览器而言这些都是多余的字节**。压缩工具可以通过如下操作减少代码大小：\\n* 删除空格（包括换行）； \\n* 删除注释； \\n* 缩短变量名、函数名和其他标识符。\\n\\n**所有JavaScript文件都应该在部署到线上环境前进行压缩。在构建流程中加入这个环节压缩JavaScript文件是很容易的。**\\n\\n#### 3.3.2 JavaScript编译\\n**类似于最小化，JavaScript代码编译通常指的是把源代码转换为一种逻辑相同但字节更少的形式**。与最小化的不同之处在于，编译后代码的结构可能不同，但仍然具备与原始代码相同的行为。编译器通过输入全部 JavaScript 代码可以对程序流执行稳健的分析。 \\n\\n编译可能会执行如下操作： \\n* 删除未使用的代码； \\n* 将某些代码转换为更简洁的语法； \\n* 全局函数调用、常量和变量行内化\\n\\n#### 3.3.3 JavaScript 转译\\n我们提交到项目仓库中的代码与浏览器中运行的代码不一样。ES6、 ES7和ES8都为ECMAScript规范扩充增加了更好用的特性，但不同浏览器支持这些规范的步调并不一致。 \\n\\n**通过JavaScript转译，可以在开发时使用最新的语法特性而不用担心浏览器的兼容性问题**。转译可以将现代的代码转换成更早的 ECMAScript版本，通常是ES3或ES5，具体取决于你的需求。这样可以 确保代码能够跨浏览器兼容。\\n\\n>注意：“转译”（transpilation）和“编译”（compilation） 经常被人当成同一个术语混用。编译是将源代码从一种语言转换为另一种语言。转译在本质上跟编译是一样的，只是目标语言与源语言是一种语言的不同级别的抽象。因此，把ES6/ES7/ES8代码 转换为ES3/ES5代码从技术角度看既是编译也是转译，只是转译更为确切一些。\\n\\n#### 3.3.4 HTTP压缩\\n**传输负载是从服务器发送给浏览器的实际字节数**。这个字节数不一定与代码大小相同，因为服务器和浏览器都具有压缩能力。所有当前主流的浏览器（IE/Edge、Firefox、Safari、Chrome和Opera）都支持客户端解压缩收到的资源。服务器则可以根据浏览器通过请求头部 （Accept-Encoding）标明自己支持的格式，选择一种用来压缩 JavaScript文件。\\n\\n在传输压缩后的文件时，服务器响应的头部会有字段（Content-Encoding）标明使用了哪种压缩格式。浏览器看到这个头部字段后，就会根据这个压缩格式进行解压缩。**结果是通过网络传输的字节数明显小于原始代码大小。**\\n\\n例如，使用Apache服务器上的两个模块（mod_gzip 和 mod_deflate ）可以减少原始JavaScript文件的约70%。这很大程度上是因为JavaScript的代码是纯文件，所以压缩率非常高。减少通过网络传输的数据量意味着浏览器能更快收到数据。\\n\\n注意，服务器压缩和浏览器解压缩都需要时间。不过相比于通过传入更少的字节数而节省的时间，整体时间应该是减少的。\\n\\n>注意：大多数Web服务器（包括开源的和商业的）具备HTTP压缩 能力。关于如何正确地配置压缩，请参考相关服务器的文档。\\n\\n## 4. 小结\\n随着JavaScript开发日益成熟，最佳实践不断涌现。曾经的业余爱好如今 也成为了正式的职业。因此，前端开发也需要像其他编程语言一样，注重 可维护性、性能优化和部署。\\n\\n**1. 为保证JavaScript代码的可维护性，可以参考如下编码惯例。**\\n* 其他语言的编码惯例可以作为添加注释和确定缩进的参考，但 JavaScript作为一门适合松散类型的语言也有自己的一些特殊要求。 \\n\\n* 由于JavaScript必须与HTML和CSS共存，因此各司其职尤为重要：JavaScript负责定义行为，HTML负责定义内容，而CSS负责定义外观。 \\n* 如果三者职责混淆，则可能导致难以调试的错误和可维护性问题。\\n\\n**2. 随着Web应用程序中JavaScript代码量的激增，性能也越来越重要。因此应该牢记如下这些事项。**\\n* 执行JavaScript所需的时间直接影响网页性能，其重要性不容忽视。\\n\\n* 很多适合C语言的性能优化策略同样也适合JavaScript，包括循环展开和使用switch 语句而不是if 语句。 \\n* 另一个需要重视的方面是DOM交互很费时间，因此应该尽可能限制DOM 操作的数量。\\n\\n**3. 开发Web应用程序的最后一步是上线部署。以下是本文讨论的相关要点。**\\n* 为辅助部署，应该建立构建流程，将JavaScript文件合并为较少的（最好是只有一个）文件。\\n\\n* 构建流程可以实现很多源代码处理任务的自动化。例如，可以运行 JavaScript验证程序，确保没有语法错误和潜在的问题。\\n* 压缩可以让文件在部署之前变得尽量小。\\n* 启用HTTP压缩可以让网络传输的JavaScript文件尽可能小，从而提升 页面的整体性能。\\n\\n> 每文一句：积累知识，胜过积蓄金银。\\n\\n本次的分享就到这里，如果本章内容对你有所帮助的话可以**点赞+收藏**。文章有不对的地方欢迎指出，有任何疑问都可以在评论区留言。希望大家都能够有所收获，大家一起探讨、进步！\\n\\n***本文正在参加[「金石计划 . 瓜分6万现金大奖」](https://juejin.cn/post/7162096952883019783)***",
        "tags": [
            "掘金·金石计划",
            "前端",
            "JavaScript"
        ]
    },
    {
        "article_id": "7167747048786264094",
        "cover_image": "",
        "title": "VueDialog弹窗诟病轻松解决",
        "brief": "摘要 相信用Vue框架多的老哥对弹窗的使用的问题都有一些使用上的诟病,本轮主要阐述针对组件封装不符合逻辑编写,如何最小化封装达成简化调用目的。 分析 常规的Vue前端UI组件如elment-ui、Iv",
        "user_name": "沈二到不行",
        "view_count": 5804,
        "collect_count": 100,
        "comment_count": 44,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/328f88bdfcc9cf39e32b9f936a80d0fb~300x300.image",
        "category": "前端",
        "content": "# 摘要\\n  相信用Vue框架多的老哥对弹窗的使用的问题都有一些使用上的诟病,本轮主要阐述针对组件封装不符合逻辑编写,如何最小化封装达成简化调用目的。\\n# 分析\\n 常规的Vue前端UI组件如**elment-ui**、**Iview**、**Ant Design Vue**等UI组件库针对模态窗的封装基本都是套式的,MVVM大家基本都在提,从另外一个角度分析Dialog封装在实际使用上，弹窗过多时漫天的变量如何解决,我们把**temlplate**中的内容理解为表现层,**script**理解为逻辑层,虽然解决了数据的绑定问题,但说实在的,vue的逻辑层和表现层互相穿插使用还是相对存在一些问题,也许你会提Vue也支持Jsx写法,安装了插件也能实现React的写法和效果,此时我以模态窗的例子来说明一些问题\\n 1. **elment-ui**\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ebf76f6f8ff14623854b51f3654ba8f2~tplv-k3u1fbpfcp-watermark.image?)\\n 2. **Iview**\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c01df4d5c8f466fbe18ef70205d2c8c~tplv-k3u1fbpfcp-watermark.image?)\\n3. **Ant Design Vue**\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af09f41ab1524103b6444296e6dec34b~tplv-k3u1fbpfcp-watermark.image?)\\n大家在实践过程中,实现这样一个简单操作,点击明细->弹窗表单信息->确定调用数据保存接口\\n这个过程如一个业务处理中有很多的编辑弹窗,或者保存逻辑需要连贯性，还有区分会凭空使得一个处理变得很凌乱复杂。\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36e33bf444cc4ce5a382f08557626e36~tplv-k3u1fbpfcp-watermark.image?)\\n可以看到一个弹窗,如果扩展3个data变量，两个方法。如果有10个弹窗,那么也变将会多出来3*10个属性和2*10个方法。\\n 我们针对弹窗的调用习惯更倾向于layer和react这种随时取用的写法\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/399f978b11904d29a8b6260b537fcd7e~tplv-k3u1fbpfcp-watermark.image?)\\n那么问题来了,vue虽然号称支持jsx写法如下图,但却会失去拥有当前页面属性方法共享的部分权力,本质上来说，其实就是函数式组件乃至于后来都趋向的**钩子函数**或者叫**组合式**,其本质也就是上下文的共享。\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e8cdb2c238847b2aa93e8b6087d9b95~tplv-k3u1fbpfcp-watermark.image?)\\n# 优化办法\\n   如果结合vue特点,要合并属性和方法,必然要封装模态窗为组件,但**显示**和**确认**,并不是一个链结构,由此就必须实现一个回调,但回调这种写法,往往是要在组件中进行一些约定,而且现在在**Promise**横行外加**aysnc await** 去JQ时代**链式折磨**的前提下,简单来讲,异步调用但采用同步写法。\\n   如果把Promise比作 **\\\"线程\\\"** 那我们就需要一个调度,去控制在点击 **“确认”** 时结束。\\n  - deferred对象就是jQuery的回调函数解决方案,**$.Deferred** 给我提供了思路,也就是把promise对象的reject和resolve开放出来\\n  ```js\\n  function generateDeferredPromise() {\\n  return (() => {\\n    let resolve;\\n    let reject;\\n    let p = new Promise((res, rej) => {\\n      resolve = res;\\n      reject = rej;\\n    });\\n\\n    return {\\n      promise: p,\\n      reject,\\n      resolve\\n    };\\n  })();\\n}\\n  ```\\n - 完整的模态窗封装如下,可以看到我们在show的时候返回了promise对象，在确认的时候触发了回调\\n ```\\n <template>\\n  <el-dialog \\n  :title=\\\"title\\\" \\n  :visible.sync=\\\"drawer\\\">\\n        <slot />\\n <div slot=\\\"footer\\\" class=\\\"dialog-footer\\\">\\n    <el-button @click=\\\"drawer = false\\\">取 消</el-button>\\n    <el-button type=\\\"primary\\\" @click=\\\"saveData\\\">确 定</el-button>\\n</div>\\n</el-dialog>\\n</template>\\n\\n<script>\\n\\nfunction generateDeferredPromise() {\\n  return (() => {\\n    let resolve;\\n    let reject;\\n    let p = new Promise((res, rej) => {\\n      resolve = res;\\n      reject = rej;\\n    });\\n\\n    return {\\n      promise: p,\\n      reject,\\n      resolve\\n    };\\n  })();\\n}\\nexport default {\\n  name:'modal',\\n  props: {\\n    title: {\\n      type: String,\\n      default: undefined,\\n    },\\n    handle:{\\n        type:Function,\\n        default:(res)=>{},\\n    }\\n  },\\n    data() {\\n      return {\\n        drawer: false,\\n        promise:null,\\n      }\\n    },\\n    mounted() {\\n        if(this.handle){\\n            this.handle(this);\\n        }\\n    },\\n    methods: {\\n      show() {\\n        this.drawer = true\\n        this.promise=new generateDeferredPromise();\\n        return this.promise.promise;\\n      },\\n      saveData(){\\n        this.promise.resolve();\\n        this.promise.promise.then(()=>{\\n          this.drawer=false;\\n        })\\n      \\n      }\\n    }\\n}\\n</script>\\n\\n<style>\\n\\n</style>\\n ```\\n - 调用时如下,可以很轻松的变相达成函数式编程的特点,在调用时减去了2个属性和一个方法,10个弹窗由原本的30+20个减少为20。\\n ```\\n    <modal title=\\\"审批/反馈\\\" ref=\\\"modal\\\">\\n     <el-descriptions :model=\\\"audit\\\"  class=\\\"margin-top\\\"  :column=\\\"1\\\"  border>\\n       <el-descriptions-item label=\\\"意见\\\">\\n          <el-radio-group v-model=\\\"audit.state\\\">\\n      <el-radio  :label=\\\"true\\\">通过</el-radio>\\n      <el-radio  :label=\\\"false\\\">不通过</el-radio>\\n    </el-radio-group>\\n       </el-descriptions-item>\\n       <el-descriptions-item label=\\\"内容\\\">\\n          <el-input type=\\\"textarea\\\" v-model=\\\"audit.comment\\\"></el-input>\\n       </el-descriptions-item>\\n     </el-descriptions>\\n</modal>\\n async handleAudit(row) {\\n      const { show } = this.$refs[\\\"modal\\\"] || {};\\n      show().then(async () => {\\n       //保存逻辑处理\\n      });\\n    },\\n ```\\n # 总结\\n - 本质其实本次分享页并没有很多新意,这种引用式的封装,很多人也早都想到了,只不过感觉针对弹窗这块的封装,很多走了极端，要么就追求layer那种写法兼容习惯,要么干脆还是保留原样,只做一些特殊处理，属性还是原样保留了。\\n - 至于回调,我之前虽然用过一段,但还是觉得不慎习惯，因为偶然有个共享弹窗存在确认后逻辑不同的问题给我造成了困扰,觉得写法有点儿变态,因此做了一些尝试和延展,觉得算是比较良性的一个调用方式吧。\\n - 框架性的东西,我诧异的是,理论性的东西,一个比一个探的深,但涉及到便捷性，却很少有人去探究，乃至于框架性的东西除了UI和风格不同,写法也大同小异。\\n\\n***本文正在参加[「金石计划 . 瓜分6万现金大奖」](https://juejin.cn/post/7162096952883019783 \\\"https://juejin.cn/post/7162096952883019783\\\")***\\n \\n \\n\\n",
        "tags": [
            "掘金·金石计划",
            "前端",
            "Vue.js"
        ]
    },
    {
        "article_id": "7189795970916286501",
        "cover_image": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f8aaef6feeb84421a53ac031a8284903~tplv-k3u1fbpfcp-watermark.image?",
        "title": "Svelte 不支持小程序开发？我不允许！",
        "brief": "本文介绍了该如何为 Svelte 开发自定义渲染器以跨平台渲染，基于 Taro 框架，通过插件的形式，让 Svelte 也拥有开发小程序的能力。",
        "user_name": "SyMind",
        "view_count": 1447,
        "collect_count": 10,
        "comment_count": 4,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/49be270bb9fe6585b33931b0efb5ea30~300x300.image",
        "category": "前端",
        "content": "# Svelte 好火啊！\\n\\n年末了，看到组内的同学在整理 2022 年流行的前端技术的文章，在里面看到大篇幅对 Svelte 优缺点和原理的介绍。读完之后，对这个没有虚拟 DOM，通过重度依赖编译阶段实现响应式数据的框架产生了极大的兴趣。\\n\\n于是开始对其进行学习并做了一些尝试，在我之前的工作经历中，经常会使用 Taro 这个框架来开发小程序，了解到 `svelte-native` 这个能够让 Svelte 开发原生应用的库后，立马着手尝试将这个框架用于小程序的开发。\\n\\n现在，基于 Taro 框架，通过插件的形式，让 Svelte 拥有开发小程序的能力。项目位于https://github.com/SyMind/tarojs-plugin-svelte ，你可以阅读 README 来安装并使用它！\\n\\n\\n![weapp.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d96703a3228c406e87080bb14ce7816e~tplv-k3u1fbpfcp-watermark.image?)\\n\\n# 如何让 Svelte 进行跨平台渲染\\n\\n## 面临的问题\\n\\n不同于 React 和 Vue 这种拥有虚拟 DOM 的技术，Svelte 本身并没有进行平台无关的抽象，在实现上与 DOM API 强耦合。\\n\\nSvelte 自身是一个编译器，它的输入是编写的 `*.svelete` 文件，输出是导出一个 `class` 的 `*.js` 文件。\\n\\n```html\\n<h1>Hello world!</h1>\\n```\\n\\n上面是一个极简单的 Svelte 组件，它仅渲染一个文本内容为 `Hello world!` 的 `h1` 标签，它的编译结果如下：\\n\\n```js\\n/* App.svelte generated by Svelte v3.55.1 */\\nimport {\\n\\tSvelteComponent,\\n\\tdetach,\\n\\telement,\\n\\tinit,\\n\\tinsert,\\n\\tnoop,\\n\\tsafe_not_equal\\n} from \\\"svelte/internal\\\";\\n\\nfunction create_fragment(ctx) {\\n\\tlet h1;\\n\\n\\treturn {\\n\\t\\tc() {\\n\\t\\t\\th1 = element(\\\"h1\\\");\\n\\t\\t\\th1.textContent = \\\"Hello world!\\\";\\n\\t\\t},\\n\\t\\tm(target, anchor) {\\n\\t\\t\\tinsert(target, h1, anchor);\\n\\t\\t},\\n\\t\\tp: noop,\\n\\t\\ti: noop,\\n\\t\\to: noop,\\n\\t\\td(detaching) {\\n\\t\\t\\tif (detaching) detach(h1);\\n\\t\\t}\\n\\t};\\n}\\n\\nclass App extends SvelteComponent {\\n\\tconstructor(options) {\\n\\t\\tsuper();\\n\\t\\tinit(this, options, null, create_fragment, safe_not_equal, {});\\n\\t}\\n}\\n\\nexport default App;\\n```\\n\\n可以看到 `create_fragment` 方法用于创建组件 DOM 节点，在方法中 `h1` 标签通过 `element()` 方法创建出来，然后使用 `h1.textContent` 属性赋予文本内容。显然 `element()` 就是 Svelte 内容用于创建 DOM 节点的方法，而其内部正是调用了我们再熟悉不过的 `document.createElement()` 方法。\\n\\n```js\\nexport function element<K extends keyof HTMLElementTagNameMap>(name: K) {\\n\\treturn document.createElement<K>(name);\\n}\\n```\\n\\n所以 Svelte 要实现跨平台渲染，没有办法像 React 那样直接通过 `react-reconciler` 这样的包，然后传入使用平台特定 API 实现的配置，即可实现一个特定平台的自定义渲染器。Svelte 甚至都没有将浏览器端的 `document` 抽象出来，所以为了让 Svelte 实现跨平台渲染，需要一些较为 Hack 的手段，以下是我能想到的方法。\\n\\n## 方法1：替换 svelte/internal\\n\\n因为 `element()` DOM 操作是从 `svelte/internal` 包中导出的，我们可以通过 Babel 等编译器对 Svelte 的产出进行修改，将其中的 `svelte/internal` 包替换为我们自己编写的文件路径。在该文件中会重新引入 `svelte/internal` 并导出，但此时我们可以对需要修改的方法进行重新实现，比如 `element()` 方法。\\n\\n```js\\nimport * as internal from 'svelte/internal'\\n\\ninternal.element = function() {\\n    // 新的逻辑\\n}\\n\\nexport internal\\n```\\n\\n但需要注意的是，`svelte/internal` 中存在其他依赖 `element()` 的方法也需要同步进行更改，所以这个方法的工作量估计不少。\\n\\n> Svelte 之所以抽象出 element() 方法，而非在结果代码中直接使用 document.createElement() 主要的目的应该是为了考虑代码压缩，而并非抽离平台特定的 API，但我想之后一定它会做这件事。\\n\\n## 方法2：伪造 document 和 window\\n\\n第二种方法是自己伪造全局的 `document` 和 `window` 对象，其中 `svelte-native` 就是通过这种方法实现的，下面是 `svelte-native` 中的代码：\\n\\n```typescript\\nfunction installGlobalShims(): SvelteNativeDocument {\\n    // 通过全局的 document 导出伪造的 DOM API\\n    let window = global as any;\\n\\n    window.window = global;\\n    window.document = new SvelteNativeDocument();\\n\\n    window.getComputedStyle = (node: NativeViewElementNode<View>) => {\\n        return node.nativeView.style;\\n    };\\n\\n    window.performance = {\\n        now() {\\n            return Date.now();\\n        },\\n    };\\n\\n    window.CustomEvent = class {\\n        detail: any;\\n        eventName: string;\\n        type: string;\\n        constructor(name: string, detail: any = null) {\\n            this.eventName = name; //event name for nativescript\\n            this.type = name; // type for svelte\\n            this.detail = detail;\\n        }\\n    };\\n\\n    window.dispatchEvent = function (event: CustomEvent) {\\n        logger.info(() => `Event dispatched ${event}`);\\n    };\\n\\n    return window.document;\\n}\\n```\\n\\n小程序的环境比较特殊，无法在 `global` 对象上挂载其他东西，此时可以通过 webpack 的 `ProvidePlugin` 来处理。Taro 本身就对 webpack 增加了以下配置，所以使用 Taro 框架来开发小程序时可以直接使用 DOM API！\\n\\n```js\\nwebpack.ProvidePlugin({\\n    window: ['@tarojs/runtime', 'window'],\\n    document: ['@tarojs/runtime', 'document'],\\n    navigator: ['@tarojs/runtime', 'navigator'],\\n    requestAnimationFrame: ['@tarojs/runtime', 'requestAnimationFrame'],\\n    cancelAnimationFrame: ['@tarojs/runtime', 'cancelAnimationFrame'],\\n    Element: ['@tarojs/runtime', 'TaroElement'],\\n    SVGElement: ['@tarojs/runtime', 'SVGElement'],\\n    MutationObserver: ['@tarojs/runtime', 'MutationObserver']\\n})\\n```\\n\\n# Svelte Component 还是 Web Component\\n\\n我们需要考虑该以何种形式暴露 Taro 组件，使用 React 开发 Taro 应用时，通过从 `@tarojs/components` 包中导入 React 组件，最终渲染成对应的小程序标签。\\n\\n```js\\nimport { View } from '@tarojs/components'\\n```\\n\\n实际上导入的 View 只是一个值为 `view` 的字符串变量，React 在运行时会将类型为字符串的节点通过 Taro 提供的 `document.createElement()` 方法构造出小程序的 `view` 标签。而 Svelte 是一个编译时框架，在看到大写字符开头时会直接认为这是一个 Svelte Component 即一个 class，导致组件会在运行时报错。\\n\\n我们当然可以直接将 `View` 实现为一个 Svelte Component，但是这会增加编译后项目整体的代码量，如最开始那个极简单的 Svelte 组件的例子，每个 Svelte 组件都会编译成一个 class 徒增很多体积，所以在实现 Svelte 的 Taro 插件时我选择以 Web Components 的形式来暴露 Taro 组件。\\n\\n```html\\n<taro-view>hello world!</taro-view>\\n```\\n\\n这面临着另一个问题，Svelte 编译后的产出创建标签的代码为 `element('taro-view')`，而目标的小程序标签是 `view`，所以我们期望的产出是 `element('view')`。\\n\\n我们当然可以通过替换 `svelte/internal` 的方式，来修改 `element()` 方法，以在运行时调用 `document.createElement()` 方法前移除 `taro-` 掉前缀。但我们有更好的选择，对 Svelte 的产出再次进行编译，遍历到 `name` 为 `element` 的 `CallExpression`，若其参数为 `taro-view` 我们就移除掉它的前缀，这不会增加任何多余的运行时代码！\\n\\n# 避免 innerHTML 优化\\n\\nSvelte 通过编译分析，会对不会更新的节点直接通过 `innerHTMl` 的方式进行批量创建，下面是一个例子。\\n\\n```html\\n<h1>\\n    <span>Hello</span>\\n    <span>World</span>\\n</h1>\\n```\\n\\n对于标签的渲染，Svelte 会编译成以下的代码：\\n\\n```js\\nfunction create_fragment(ctx) {\\n\\tlet h1;\\n\\n\\treturn {\\n\\t\\tc() {\\n\\t\\t\\th1 = element(\\\"h1\\\");\\n\\n\\t\\t\\th1.innerHTML = `<span>Hello</span> \\n\\t<span>World</span>`;\\n\\t\\t},\\n\\t\\tm(target, anchor) {\\n\\t\\t\\tinsert(target, h1, anchor);\\n\\t\\t},\\n\\t\\tp: noop,\\n\\t\\ti: noop,\\n\\t\\to: noop,\\n\\t\\td(detaching) {\\n\\t\\t\\tif (detaching) detach(h1);\\n\\t\\t}\\n\\t};\\n}\\n```\\n\\n这是 Svelte 非常激动人心的优化，提升组件运行时的速度，但这个优化对于处理跨平台渲染来说就十分痛苦了，因为实现 `innerHTML` 功能的成本很高，需要在运行时进行解析，然后进行遍历来创建各个节点。\\n\\n幸运的是 Svelte 编译器有一个 `hydratable` 参数，它原本的目的是为了 SSR 挂载时能够复用已有节点，为了这个目的 Svelte 此时生成的代码不会产生使用 `innerHTML` 批量生成节点的操作，以此也让我们能够绕开这个问题。\\n\\n\\n# 写在最后\\n\\n从前我一直认为虚拟 DOM 的优点之一是具有跨平台的能力，但在接触过 Svelte 后明白虚拟 DOM 只是为了在运行时进行节点 diff，跨平台的基础是分离平台特定 API。\\n\\n甚至就算像 Svelte 这种内部与 DOM API 高耦合的框架，我们依旧可以通过运行时伪造或编译时代理 window 和 document 对象来进行跨平台！\\n\\n之后我可能会继续探索更多 Svelte 的渲染器，比如让其渲染在 terminal、three.js 等，这应该会非常有趣。",
        "tags": [
            "前端",
            "Svelte",
            "微信小程序"
        ]
    },
    {
        "article_id": "7194411101365207097",
        "cover_image": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e9249764d1b844669eb81443dd54edf5~tplv-k3u1fbpfcp-watermark.image?",
        "title": "手写图表指南",
        "brief": "1 前言 说到数据可视化，大家应该都不陌生。它旨在借助于图形化手段，清晰有效的传达与沟通信息。广义的数据可视化涉及信息技术、自然科学、统计分析、图形学等多种学科。 我们熟知的图形、图表以及地图等都属于",
        "user_name": "猫不群",
        "view_count": 325,
        "collect_count": 2,
        "comment_count": 0,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/174359556bbc092388f732a21be7afc0~300x300.image",
        "category": "前端",
        "content": "![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ba4ade61c544612ba8471c324f14e49~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n## 1 前言\\n说到数据可视化，大家应该都不陌生。它旨在借助于图形化手段，清晰有效的传达与沟通信息。广义的数据可视化涉及信息技术、自然科学、统计分析、图形学等多种学科。\\n\\n![图例来源网络](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f6b20903c1e4e3096cc32bd8ed5b66d~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n我们熟知的图形、图表以及地图等都属于数据可视化的范畴。今天我们主要讨论数据可视化中的图表，像柱状图、折线图、面积图、饼图、热力图都是使用频率非常高的图表。\\n\\n![图例来源网络](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ac0ae8ea974468b8290d7475f09cc23~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n如果要在移动端绘制一个类似于下图，使用真实数据渲染的简单面积图表，我们应该如何实现它呢？相信大家脑子里应该都有各种方案了，那么接下来我们就来一步步实现它。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a3ce7083e62f4c6f927cdab0eecae4cc~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/646103e4bb554e849b34dc34cfa9af8f~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n## 2 技术选型\\n#### 需求\\n- 图表样式定制化  \\n  图表样式为我司设计师独立设计，最终实现效果应该做到100%还原设计细节；\\n- 交互效果    \\n  默认情况下数据游标只显示当前数据点，如需查看其他月份或者时刻数据，需要用户手动点击切换；\\n- 曲线面积图     \\n  最终需要绘制出一个面积图，也就是用真实数据绘制出的曲线与坐标轴相交而形成的一个区域；\\n  \\n明确了具体的需求之后，我们就可以考虑技术方案选型了。\\n#### 2.1 图表库\\n目前业界有很多成熟的图表库，像我们熟知的highcharts、echarts，Bizcharts，G2，更高阶的three.js等等。如果采用现有图表库来实现上述图表的话，会存在以下一些问题。\\n- 无法100%还原图表样式\\n- 包体积大，引入会造成项目性能问题\\n\\n引入现有图表库的方案固然非常简单，大大节省了前端同学的开发量。但是存在着以上两个比较突出的问题。 \\n\\n图表库的图表样式都是通过配置完成，实现出来的效果在某些细节上难以完全还原设计稿，并且翻文档测试配置项的过程也比较繁琐。而且如果后续设计同学需要优化图表样式，并且此优化难以通过现有图表库配置项实现的话，那可能就需要二次开发图表库，对我们来说，也是一个不小的工作量；  \\n\\n通常C端的图表需求并不是那么通用，可能一个项目也就实现这么一两个图表，如果引入图表库的话，对项目本身来说，无形中又增加了一些打包成本。那有些同学可能会说，现在的某些图表库已经可以按需引用了，这样**增加打包体积**这个问题可能就不是问题了，虽然现在的某些比较成熟的图表库可以按需引用，但是在引用某个图表文件之前还是要引入一些核心文件，这些核心文件依然会占据不小的包体积。总结来说，引入现有图表库的方案**成本高、灵活性差**。\\n\\n#### 2.2 canvas\\ncanvas相信对每一个前端开发者来说都不陌生，如果我们采用canvas来绘制图表的话，有两个问题比较棘手，上文中有提到过，我们要实现的图表是有交互效果的，当用户点击数据点的时候，则需要显示当前数据点的数据游标，再点击其他数据点的时候，数据游标也要相应的切换。大家都知道，使用原生canvas来实现**事件系统**异常麻烦，并且canvas的**重绘机制**也是我非常不喜欢的一点。总结一下，原生canvas**没有完备的事件系统，重绘机制繁琐**；\\n\\n当然，现在也有很多优秀的canvas框架能够解决上述问题，比如fabric.js和konva.js，尤其是fabric.js，让我们使用canvas不再别扭，感兴趣的同学也可以尝试一下。\\n\\n#### 2.3 svg\\nsvg是一种基于XML语法的图像格式，是可缩放的矢量图形。那什么是矢量图形呢？矢量图是计算机图形学中用点、直线或者多边形等基于数学方程的几何图元表示的图像，所以矢量图具有无论放大多少倍都不会失真的特性。而与之相对应的则是位图，位图是用像素阵列表示的图像。svg在绘制图表上有天然的优势，\\n- **开发成本低**  \\n  svg基于XML语法，XML语法是一种类似于HTML语法的可扩展标记语言，也就是说svg是使用一系列的元素(line、circle，polygon等)来描述图形的。那svg元素和dom元素之间是不是存在着某种关联呢？\\n\\n  ![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4546277bdf64eec985bc227cde35321~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n  ![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1af6957655b746bc890794568bc3def2~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n  我们由元素间的继承关系可以得出的结论是：svg元素和dom元素基本相似，因此对于svg元素，完全可以从dom元素的角度去理解和应用，上手成本几乎就可以忽略不计了。并且svg和css，javascript等其他网络标准无缝衔接。本质上，**svg相对于图像，就好比html相对于文本**；\\n- **完备的事件系统**    \\n  由于svg元素与dom元素类似，因此dom元素中的事件系统对于svg同样适用；\\n- **文件体积小，兼容性好**  \\n  前文已经介绍过，svg绘制出来的是一种矢量图形，而矢量图形都是使用点、直线等几何图元构成的图形，是对图像的图形描述，本质上依然是文本文件，所以它具有体积小的天然优势。 \\n  \\n  svg是由万维网联盟（W3C）自1999年开始开发的开放标准。兼容性方面几乎所有主流浏览器都支持。  \\n  \\n因此，最终我选择了使用svg来绘制图表。\\n\\n\\n## 3 svg基础\\n在我们正式绘制图表之前，首先需要了解一些svg的基础知识。\\n#### 3.1 svg元素\\nsvg图像就是使用不同的svg元素来创建的，svg元素常用的主要分为动画元素，形状元素，字体元素，图形元素，文本元素等。\\n- **形状元素**   \\n`<circle>, <ellipse>, <line>, <mesh>, <path>, <polygon>, <polyline>, <rect>`  \\n形状元素是绘制svg图像最常用的，path元素是svg中一个非常强大的元素，它类似于canvas中的path，利用它能够绘制出任何你想要的图形。在我们本次绘制图表过程中，path元素亦不可或缺；\\n- **动画元素**  \\n`<animate>，<animateColor>，<animateMotion>，<animateTransform>，<discard>，<mpath>，<set>`  \\n想要给svg元素添加动画，最简单的方式是使用动画元素，即用动画元素包裹住svg图形，即可添加动画；\\n\\n其他元素就不再赘述。\\n\\n#### 3.2 svg应用场景\\n- **iconfont图标库和字体库**  \\niconfont图标库应该是svg最常见的一个使用场景，svg矢量图、文件小的特性使得它非常适合来绘制小图标，像我们转转的图标库也是使用svg来绘制的。svg绘制图标也有一些小小的缺点，比如它只能绘制纯色或者css渐变色图标，从颜色方面来说没有图片色系丰富，层次分明。\\n\\n- **业务动画**  \\n我们业务中一些常用的动画场景也会使用svg实现，比如**loading效果**，**圆环进度条**，**商品添加购物车特效**等；像商品添加购物车的特效在电商网站是非常常见的，一般我们的实现思路是使用js+css动画实现；其实svg中的路径动画更适用于这个场景，我们可以在需要加购的商品和购物车之间绘制一条隐形的path，当用户触发加购操作的时候触发路径动画，即animateMotion，这样也可以实现同样的功能。\\n\\n## 4 svg如何绘制图表？\\n通过以上对背景以及一些前置知识的介绍，相信大家已经对svg有了一个初步的了解，接下来我们就回到最初的问题，如何通过svg来从头开始绘制一个曲线面积图？我主要分了以下几个步骤，下文会对每个步骤逐一进行说明。\\n#### 4.1 坐标系\\n计算机绘图使用的坐标系统都是网格坐标系。其以左上角作为坐标系的原点，X轴正方形向右逐渐开始增大，Y轴正方向向下逐渐开始增大。\\n\\n![图例来源于网络](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e1fbac3ae0e4a96a71ef23d627b1eb6~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n了解了svg的坐标系之后，我们来绘制曲线面积图中的坐标系，坐标系其实就是由两条线相交而成，svg中的line元素就是用来绘制直线的，所以使用line元素就可以绘制出X轴和Y轴。需要注意的是svg的坐标系原点在左上角，而我们需要实现的图表中坐标系原点在左下角，所以在实现的时候要对y轴的实际坐标进行处理。\\n```\\ncreateCoordinate() {\\n      this.svg.createLine(\\n        [\\n          {\\n            x1: '0',\\n            y1: '0',\\n            x2: '0',\\n            // ui设计稿上y轴高度为205，由于顶部游标的存在（游标高度57，宽度122），所以y轴变为205+57；\\n            // 由于整个坐标轴往下平移了57，所以最下面的坐标会出现不显示的情况，故再增加50的buffer\\n            y2: `${this.$toRealPx(262 + 50)}px`,\\n            stroke: '#F0F0F0',\\n            'stroke-width': '1',\\n          },\\n          {\\n            x1: '0',\\n            y1: `${this.$toRealPx(262 + 50)}px`,\\n            x2: `${this.$toRealPx(595)}px`,\\n            y2: `${this.$toRealPx(262 + 50)}px`,\\n            stroke: '#F0F0F0',\\n            'stroke-width': '1',\\n          },\\n        ],\\n        this.svgObj\\n      )\\n    }\\n```\\n\\n#### 4.2 网格\\n在我们需要实现的两个图表中，图表背景处均有网格，网格的实现原理也是使用line元素，只要标记好起点以及终点，就可以完美绘制。此处不再展开。\\n#### 4.3 数据点和数据游标\\n**数据点**：即用来标记当前数据位置的小原点，数据点有两种状态，分别是未点击态和点击态，实现数据点我们使用svg中的circle元素即可。当数据点被点击时，我们只需要更改circle元素的填充属性。\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/08f2a99b6a4e45ed9e3bea045d1857a8~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n```\\nconst circlePoints = this.graphAxisData.map((v, idx) => {\\n        return {\\n          cx: v.xAxis,\\n          cy: v.yAxis || 0,\\n          r: this.$toRealPx(5),\\n          stroke: '#7792D8',\\n          'stroke-width': this.$toRealPx(3),\\n          fill: 'white',\\n          title: `class${idx + 1}`,\\n          imageIndex: `imageClass${idx + 1}`,\\n        }\\n      })\\n```\\n\\n**数据游标**：数据游标在我们的图表里是一个不规则图形，其有点类似于会话气泡。我们要实现数据游标有两种方式，第一种方式是使用svg的path元素来绘制，那path元素的参数具体应该怎么设置呢？其实可以跟设计师同学沟通，一般设计同学在用设计软件导出的时候，设计软件会携带path元素的具体参数，这是方案一；还有第二种比较简单的方案是利用svg中的image元素，也就是将数据游标当作一个图片绘制到图表中，这种方案比较简单省事，我采用的也是此方案。\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9065fa982ab045358f35277f6b460be1~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n```\\nconst circleImage = this.graphAxisData.map((v, idx) => {\\n        return {\\n          x: (v.xAxis - this.$toRealPx(122) / 2),\\n          y: (v.yAxis - this.$toRealPx(52) - this.$toRealPx(8)) || 0,\\n          height: this.$toRealPx(52),\\n          width: this.$toRealPx(122),\\n          id: `imageClass${idx + 1}`,\\n          href: 'https://pic3.zhuanstatic.com/zhuanzh/b13744dd-c240-4961-8054-9f923586ea5a.png',\\n        }\\n      })\\n      const circleText = this.graphAxisData.map((v, idx) => {\\n        return {\\n          x: v.xAxis,\\n          y: (v.yAxis - this.$toRealPx(52 / 2)) || 0,\\n          fill: '#111111',\\n          'font-size': this.$toRealPx(24),\\n          'text-anchor': 'middle',\\n          title: `¥${v.oriYAxis}`,\\n          id: `class${idx + 1}`,\\n        }\\n      })\\n```\\n#### 4.4 曲线\\n接下来就要绘制图表中最重要的一个部分，也就是用真实数据渲染出来的一条曲线，绘制曲线我们依然是利用path元素绘制贝塞尔曲线，贝塞尔曲线只需要少量的点就可以绘制一条光滑曲线。在svg中，path元素用来绘制贝塞尔曲线的命令有两组，第一组是C,S命令，用来绘制三次贝塞尔曲线；第二组是Q,T命令，用来绘制二次贝塞尔曲线。  \\n\\n我绘制图表使用的是三次贝塞尔曲线，那首先了解一下三次贝塞尔曲线。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98a829b20ab4421793c486e859ddffe3~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n其中，t代表斜率，取值为0-1;p0代表起始点坐标(x0,y0);p1代表第一个控制点坐标(x1,y1);p2代表第二个控制点坐标（x2,y2);p3代表终点坐标(x3,y3);pt代表这条曲线上的任意一个点坐标(xt,yt)。当t由0-1逐渐变化的时候，可以得到一系列的(xt,yt),这一些列（xt,yt)就组成了一条三次贝塞尔曲线，这就是三次贝塞尔曲线的定义。\\n\\n通过以上介绍可知，绘制三次贝塞尔曲线必须得知道起始点、两个控制点以及终点。后端会返回给我们相应的几个数据点，也就是说这几个数据点的坐标是已知的，现在的问题就成了给定一组已知数据点，如何将其拟合成一条曲线？其实思路很简单，假如说有已知的5个点，那么我们将第一个点作为起始点，第二个点作为终点，计算出他们之间的控制点，绘制一条曲线，同样的，又以第二个点作为起点，第三个点作为终点，再重复以上过程，最终即绘制出一条横穿五个点的平滑曲线。\\n\\n此处附上算法源码\\n```\\ncreateBezierLine() {\\n      const polygonPath = this.getCubicBezierCurvePath(\\n        this.graphAxisData.map((v) => {\\n          return {\\n            x: v.xAxis,\\n            y: v.yAxis,\\n          }\\n        })\\n      )\\n\\n      this.svg.createPath(\\n        {\\n          d: polygonPath,\\n          fill: 'none',\\n          stroke: '#7792D8',\\n          'stroke-width': 2\\n        },\\n        this.svgObject\\n      )\\n    }\\n    \\ngetCubicBezierCurvePath(knots) {\\n      const firstControlPoints = []\\n      const secondControlPoints = []\\n      const path = []\\n\\n      this.getCubicBezierCurvePoints(knots, firstControlPoints, secondControlPoints)\\n\\n      for (let i = 0, len = knots.length; i < len; i++) {\\n        if (i === 0) {\\n          path.push(['M', knots[i].x, knots[i].y].join(' '))\\n        } else {\\n          const firstControlPoint = firstControlPoints[i - 1]\\n          const secondControlPoint = secondControlPoints[i - 1]\\n          path.push(\\n            [\\n              'C',\\n              firstControlPoint.x,\\n              firstControlPoint.y, // 第一个控制点\\n              secondControlPoint.x,\\n              secondControlPoint.y, // 第二个控制点\\n              knots[i].x,\\n              knots[i].y, // 实点\\n            ].join(' ')\\n          )\\n        }\\n      }\\n\\n      return path.join(' ')\\n    }\\n    \\ngetCubicBezierCurvePoints(knots, firstControlPoints, secondControlPoints) {\\n      const rhs = []\\n      const n = knots.length - 1\\n      let x = 0\\n      let y = 0\\n      let i = 0\\n\\n      if (n < 1) {\\n        return\\n      }\\n\\n      // Set right hand side X values0\\n      for (i = 0; i < n - 1; ++i) {\\n        rhs[i] = 4 * knots[i].x + 2 * knots[i + 1].x\\n      }\\n      rhs[0] = knots[0].x + 2 * knots[1].x\\n      rhs[n - 1] = 3 * knots[n - 1].x\\n\\n      // Get first control points X-values\\n      x = this.getFirstControlPoints(rhs)\\n\\n      // Set right hand side Y values\\n      for (i = 1; i < n - 1; ++i) {\\n        rhs[i] = 4 * knots[i].y + 2 * knots[i + 1].y\\n      }\\n      rhs[0] = knots[0].y + 2 * knots[1].y\\n      rhs[n - 1] = 3 * knots[n - 1].y\\n\\n      // Get first control points Y-values\\n      y = this.getFirstControlPoints(rhs)\\n\\n      for (i = 0; i < n; ++i) {\\n        // First control point\\n        firstControlPoints[i] = {\\n          x: x[i],\\n          y: y[i],\\n        }\\n\\n        // Second control point\\n        if (i < n - 1) {\\n          secondControlPoints[i] = {\\n            x: 2 * knots[i + 1].x - x[i + 1],\\n            y: 2 * knots[i + 1].y - y[i + 1],\\n          }\\n        } else {\\n          secondControlPoints[i] = {\\n            x: (knots[n].x + x[n - 1]) / 2,\\n            y: (knots[n].y + y[n - 1]) / 2,\\n          }\\n        }\\n      }\\n    }\\n    \\ngetFirstControlPoints(rhs) {\\n      const n = rhs.length\\n      const x = [] // Solution vector.\\n      const tmp = [] // Temp workspace.\\n      let b = 2.0\\n      let i = 0\\n      x[0] = rhs[0] / b\\n\\n      for (i = 1; i < n; i++) {\\n        // Decomposition and forward substitution.\\n        tmp[i] = 1 / b\\n        b = (i < n - 1 ? 4.0 : 2.0) - tmp[i]\\n        x[i] = (rhs[i] - x[i - 1]) / b\\n      }\\n\\n      for (i = 1; i < n; i++) {\\n        x[n - i - 1] -= tmp[n - i] * x[n - i] // Backsubstitution.\\n      }\\n      return x\\n    }\\n```\\n#### 4.5 面积\\n最后一步就是绘制曲线与X轴和Y轴相交而形成的面积部分。假如说这条曲线不是一条曲线而是一条折线的话，那么其实很容易就能实现。我们将这条折线与X轴和Y轴连接起来形成一个闭合图形polygon，然后通过给polygon进行填充即可得到折线的面积图。\\n\\n我们利用这个思路，如果一条折线上的点足够多的话，那么这条折线就会无限趋近于一条曲线。反之，一条曲线也可以看成是无限多的点构成的折线，所以我们利用svg中的getTotalLength()和getPointAtLength()这两个方法就可以将path转换为多边形，最后再填充多边形即可得到最终的面积图。\\n\\n\\n## 5 结语\\n通过以上5个步骤，我们就能够基于svg从头开始实现一个简单的曲线面积图。svg的使用场景还是非常丰富的，并且兼容性一直都不错，如果需要实现这种相对不那么复杂且交互少的图形，svg还是一个不错的方案。如果要实现复杂图层、复杂动效以及复杂交互，canvas框架可能会是一个更好的选择。\\n\\n最后，开年第一篇，祝大家新年快乐，2023突（兔）飞猛进，大展鸿图（兔），前途（兔）无量！\\n\\n\\n\\n## 参考\\nhttps://www.infoq.cn/article/ogwddr4u8x0s*5aaytsh\\nhttps://gist.github.com/mingzhi22/be3324ffd9765687ea2f\\n\\n",
        "tags": [
            "前端",
            "JavaScript",
            "算法"
        ]
    },
    {
        "article_id": "7164007268952834084",
        "cover_image": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c03eb940b0bc45ec8117d552aae9737e~tplv-k3u1fbpfcp-watermark.image?",
        "title": "当你有了技术深度，很可能也同时有了技术广度",
        "brief": "很多同学不知道深入研究一些技术的意义在哪，会用不就行了？花那么大精力深入原理有什么好处呢？ 这个问题就用我的两段真实学习经历来解答吧。 我刚开始写一些技术文章是研究 Babel 插件的时候，就从那里开",
        "user_name": "zxg_神说要有光",
        "view_count": 7272,
        "collect_count": 85,
        "comment_count": 22,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/4e9e751e2b32fb8afbbf559a296ccbf2~300x300.image",
        "category": "前端",
        "content": "很多同学不知道深入研究一些技术的意义在哪，会用不就行了？花那么大精力深入原理有什么好处呢？\\n\\n这个问题就用我的两段真实学习经历来解答吧。\\n\\n## 第一段学习经历\\n\\n我刚开始写一些技术文章是研究 Babel 插件的时候，就从那里开始讲：\\n\\nBabel 是一个 JS 的编译器，把高版本语法的代码，转换成低版本的代码，并且会自动引入 polyfill。\\n\\n它分为三个步骤，parse、transform、generate：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce6803cf0f244e4ba6bd0571954718af~tplv-k3u1fbpfcp-watermark.image?)\\n\\nparse 阶段把代码从字符串转换为 AST，transform 阶段对 AST 做各种增删改，generate 阶段再把转换后的 AST 打印成目标代码并生成 sourcemap。\\n\\n所有的转换都是对 AST 的转换，也就是在 transform 阶段生效的。Babel 把这些 AST 转换逻辑组织成了一个个 plugin，plugin 比较多，用起来比较麻烦，所以又提供了 preset，也就是 plugin 的集合。\\n\\n这样我们只需要用 preset-xx 就可以了，不用关心具体用到了啥 plugin。比如常用的 @babel/preset-env，只要指定 targets 运行环境，preset-env 内部会自动引入相应的 plugin 来做 AST 的转换。\\n\\n本质上来说 babel 的核心功能就是对 AST 的各种转换，我们也可以自己写 plugin 来做这种转换。\\n\\n当然，除了代码转换外，还可以静态分析，也就是通过分析 AST 来发现一些问题，在编译期间报错。\\n\\n提到静态分析，自然会想到 ESLint 和 TypeScript Compiler，它俩不也是做 JS 的静态分析么？也是在编译期间发现一些代码中的问题并报错。只不过 ESLint 发现的是一些逻辑错误或者格式错误，而 TSC 发现的是类型错误。\\n\\n都是基于 AST，那 Babel 能不能实现 ESLint 和 TSC 的功能呢？\\n\\n于是当时我就尝试用 Babel 插件实现了下 Lint 的功能：\\n\\n我发现 ESLint 里的逻辑错误的 rule 都很容易实现，因为都是对 AST 的分析。\\n\\n比如 for 迭代方向的错误，就是看条件是 \\\\< 还是 \\\\>，对应的是 ++ 还是 --，基于 AST 很容易分析出来：\\n\\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/810fe33331cf4dc3b207bedf83331de6~tplv-k3u1fbpfcp-watermark.image?)\\n\\n但是格式的错误就没办法了，因为 Babel 插件里拿不到这个 AST 关联的 token 信息。\\n\\n我去看了下 ESLint 插件里是怎么检查出格式错误的：\\n\\n发现 ESLint 提供了根据 AST 节点拿到它的 token 信息的 api，比如块语句可以拿到 { 的 token 信息，也就是所在的行列号等：\\n\\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/02cba24873b04d33adf9464d4f22017b~tplv-k3u1fbpfcp-watermark.image?)\\n\\n也可以拿到  { 的上一个 token 也就是 ) 的 token 信息，包含了行列号：\\n\\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cba344fcee3f431c9d8ed1aee7d6ec0d~tplv-k3u1fbpfcp-watermark.image?)\\n\\n那这俩行列号一对比，不就知道了是不是在同一行，是不是中间有空格么？也就知道了是不是有格式问题。\\n\\nESLint 插件可以实现这种格式错误的检查，但是 Babel 插件就不可以。\\n\\n是因为 AST 中不包含这部分信息么？\\n\\n其实也不是，@babel/parser 也支持生成带 token 的 AST，只是没有提供对应的 api 给插件用：\\n\\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/482390fc4bb148c78e377c6c49d69a22~tplv-k3u1fbpfcp-watermark.image?)\\n\\n如果 Babel 插件提供了查询 AST 节点的 token 的 api，那完全可以替代 ESLint 插件的功能。\\n\\n然后我注意到 ESLint 插件提供了 fix 功能，可以自动 fix 一些错误，比较好奇它是怎么实现的，难道也是像 Babel 这样递归打印 AST 么？\\n\\n研究了下发现并不是。\\n\\nESLint 插件可以在 report 错误的时候指定把某个 range 的文本替换成另一段文本：\\n\\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d91d73549c444f31a8bff19b4ef48bff~tplv-k3u1fbpfcp-watermark.image?)\\n\\n原理就是字符串替换：\\n\\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f00636210a1c48ba8e3f348d79ea80eb~tplv-k3u1fbpfcp-watermark.image?)\\n\\n所以说，Babel 插件和 ESLint 插件至少有这两处不同：\\n\\n- ESLint 插件可以通过 api 拿到 AST 关联的 token 信息，检查出格式问题，而 Babel 插件不行\\n- ESLint 的自动 fix 修改代码是通过字符串替换实现的，而 Babel 则是通过递归打印修改后的 AST 为字符串\\n\\nESLint 的静态分析搞明白了，我又在想： TSC 的类型检查不也是对 AST 做静态分析么？用 Babel 插件能实现么？\\n\\n我还真实现了一个简易版的类型检查，还支持泛型和简单的类型编程：\\n\\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3bb198ffcba843c4b420461eaf577aba~tplv-k3u1fbpfcp-watermark.image?)\\n\\n但我发现有很多功能是实现不了的，比如 TypeScript 可以做跨文件的同名 namespace 合并，比如 TypeScript 可以声明跨文件的全局类型。\\n\\n而 Babel 的编译是对单个文件进行的，也就是对一个文件进行 parse、transform、generate 这样的处理，下个文件再 parse、transform、generate。\\n\\nTSC 会根据配置加载 lib 下的类型、加载 types 的类型，再根据 inclues、excludes、files 的配置加载项目代码里的类型，这样该放全局的放全局，该合并的合并，最后再去检查。\\n\\n这种编译流程上的区别导致了 Babel 虽然可以编译 TS 代码，但并不能实现类型检查。它处理 TS 代码都是把类型语法给忽略掉的。\\n\\n当然，也不只是 Babel，你用 swc、esbuild 等也是一样。\\n\\n想做类型检查只能单独跑 tsc --noEmit，没有第二个选项。\\n\\n搞懂了 Babel 和 ESLint、TSC 的区别，就知道为什么都是基于 AST，而 Babel 却不能取代它们两者了。\\n\\n再就是代码转换，这个可是 Babel 的强项，但转换代码我们却不只用 Babel，还会用 Terser 做一次压缩（es6 之前的代码是 uglify，之后的就是 terser 了）。\\n\\n为什么 Babel 明明可以在编译的过程中实现这种压缩的功能，却要用 Terser 单独来压缩呢？\\n\\n其实真可以，babel 也一直在推进这事，只不过还没完成，这个 babel/minify 的项目还在 beta 阶段：\\n\\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a570630d05264c6a9682b965cf35ae40~tplv-k3u1fbpfcp-watermark.image?)\\n\\n它的原理很容易想到，就是一系列 babel 插件来分析和转换代码：\\n\\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63bb930f6840472c972505abe58bdff8~tplv-k3u1fbpfcp-watermark.image?)\\n\\n前面这些编译工具都是处理 JS 的，后面我发现 postcss 就是 css 版的 babel，而且配置方式啥的都一样。\\n\\n基于 postcss 同样可以实现 Lint，也就是 stylelint 工具，也同样可以实现压缩等等。\\n\\n而且给 css 的 class 加 hash的 css modules 或者 scoped css 都是用它实现的。\\n\\n然后我发现所有的前端编译工具都是 parse、transform、generate 这三个阶段，都是基于 AST 做分析和转换。\\n\\n也很容易想明白，因为源代码和目标代码都是字符串，而中间的处理都是 AST，那自然都是这样的流程。\\n\\n包括 Vue Template Compiler 也是一样，只不过它是 template 转 render function，也同样支持 transform 插件。\\n\\n编译搞懂了，那自然会涉及到打包工具，因为我们一般不直接用编译工具，而是声明对什么文件用什么来编译，让打包工具去调用这些编译器，并把生成的代码打成几个 chunk。\\n\\n打包工具做的事情只是根据 AST 分析出依赖图，然后对依赖图中的每个节点调用不同的编译器来编译，之后分成几个部分，包上一层 UMD 的代码生成最终的代码，当然还可以注入一些 runtime 代码。\\n\\n学打包工具只需要了解 chunk 拆分、以及它的 runtime 代码做了什么事情之类的。编译和打包是两个维度的事情。\\n\\n最近工具链有统一的趋势，比如 bun、rome、esbuild 等等一些工具，它们有的想把编译、Lint、压缩、打包等统一成一个工具来做，从原理上来说这是可行的，只是成本比较高，不然 babel minify 不会现在还是 beta 了。\\n\\n讲了这么多，我们再回头看一下：\\n\\n其实我就是研究 Babel 的时候，发现它的静态分析和 ESLint、TSC 一样都是基于 AST 做的，它的代码转换和 Terser 又有重叠部分，然后发现 postcss 也是差不多的，从而发现前端编译工具原理都类似，完全可以统一，再就是编译和打包是两个维度的事情。\\n\\n我深入研究 Babel 的时候，为了搞懂它和关联的一些技术的区别，又研究了下其他技术，最终搞懂了 Babel 的同时也搞懂了很多其他工具的原理。\\n\\n这就是为什么我标题说的有了技术深度的同时也会拥有技术广度。\\n\\n## 第二段学习经历\\n\\n再来举个例子，就是我最近在研究的调试：\\n\\n调试我们一般用 Chrome DevTools，它可以调试网页，也可以调试 Node.js，这是为什么呢？\\n\\n因为 Chrome DevTools 是基于 CDP（Chrome Devtools Protocol）和 JS 运行时通信的：\\n\\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ecee1618e734030b6c1db6acdb438a5~tplv-k3u1fbpfcp-watermark.image?)\\n\\nNode.js 之前的调试都是在命令行，没有 UI，所以对接了 CDP，这样就能直接用 Chrome DevTools 的 UI 来调试了。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/75b3d563d6544900935abba7c3b50c71~tplv-k3u1fbpfcp-watermark.image?)\\n\\n既然只要对接 CDP 就行，那也不用非得用 Chrome DevTools 来调试，用 VSCode Debugger 也完全可以。\\n\\n只不过 VSCode Debugger 多了一层适配器协议：\\n\\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72c9dd9f2376443c9625d109251e13b1~tplv-k3u1fbpfcp-watermark.image?)\\n\\n多这一层协议是 VSCode 为了让 Debugger UI 可以跨语言复用。\\n\\n后来发现小程序调试工具、跨端引擎调试工具很多也都是用 Chrome DevTools 来调试，其实它们也是对接了 CDP，这样就可以用 Chrome DevTools 来调试它们的代码了。\\n\\n调试工具分为 backend、frontend，UI 的部分是 frontend，代码运行时是 backend。\\n\\n我试了下集成 Chrome DevTools frontend，自己实现 backend 的 CDP 服务，是可以的。这就是跨端引擎调试工具的原理。\\n\\n也可以基于 JS 运行时的 backend，对接 CDP 来实现 frontend 部分。\\n\\n这个过程中我了解到 Puppeteer 就是基于 CDP 实现的，它就是调试模式跑了一个 Chromium，然后连上 CDP 来做远程控制。\\n\\n基于 CDP 实现这个并不难，所以我自己写了一个简易版 puppeteer。\\n\\n不只是 puppeteer，lighthouse 的 cli 能拿到网页的运行数据并做一些记录和分析，也是基于 CDP 实现的。有网页分析需求的时候，也可以自己基于 CDP 这么搞。\\n\\n这是我学习调试的经历：发现网页和 Node.js 的调试都可以用 Chrome DevTools 和 VSCode Debugger 调试，了解了下它们的原理都是基于 CDP，而且小程序调试工具、跨端引擎调试工具等可以用 Chrome DevTools 来调试也都是因为对接了 CDP。自己试了下实现 CDP backend 和 frontend，然后了解到 Puppeteer 和 LightHouse CLI 也都是基于 CDP 实现的，于是我实现了简易版的 Puppeteer。\\n\\n我研究网页和 node 调试的过程中，顺便也搞懂了跨端引擎、小程序调试工具的原理和 Puppeteer 的原理。\\n\\n这个案例也同样可以说明有了技术深度的同时也会拥有技术广度。\\n\\n## 总结\\n\\n很多技术从表面上看是毫不相关的，但再深入一点你会发现它们存在千丝万缕的关系。深入学习一门技术的同时，你也能顺蔓摸瓜掌握其他技术的原理，而且会比单独学习那门技术理解的更深。\\n\\n当你有了技术深度的同时，很可能也同时有了技术广度，这俩并不冲突。\\n",
        "tags": [
            "前端",
            "JavaScript",
            "Node.js"
        ]
    },
    {
        "article_id": "7154579554034515982",
        "cover_image": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b0c5db9e9de416d9041347074d7c8c1~tplv-k3u1fbpfcp-watermark.image?",
        "title": "一个登录案例包学会 Pinia ",
        "brief": "Pinia 删减了复杂的概念，简化了数据流转的过程，只剩下 store、state、getters、actions 这四个核心功能。本文使用一个用户登录的案例，来学习 Pinia 的使用。",
        "user_name": "昆吾kw",
        "view_count": 9375,
        "collect_count": 305,
        "comment_count": 25,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/3745b7eb198f2357155cd88eb7930f35~300x300.image",
        "category": "前端",
        "content": "持续创作，加速成长！这是我参与「掘金日新计划 · 10 月更文挑战」的第18天，[点击查看活动详情](https://juejin.cn/post/7147654075599978532 \\\"https://juejin.cn/post/7147654075599978532\\\")\\n\\n# 一个登录案例学会 Pinia\\n\\nPinia 号称下一代的 Vuex。\\n\\n经过初步体验，发现相比于 Vuex，Pinia 确实有了很大进步，最明显的就是删减了复杂的概念，简化了数据流转的过程，现在只剩下了 store、state、getters、actions 这四个核心概念。\\n\\n接下来使用一个**用户登录**的案例，来学习 Pinia 的使用。\\n\\n## 案例概述\\n\\n需要用到：\\n\\n-   vite：创建和管理 vue 项目\\n-   pinia：状态管理\\n-   axios：网络请求\\n-   vite-plugin-mock：提供登录的 mock 接口\\n-   pinia-plugin-persistedstate：状态持久化插件\\n\\n我们会先 mock 一个简单的登录接口，然后介绍使用 Pinia 的基本流程，最后在组件中使用 Pinia，完成整个流程。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/91f30df9c2b84d63adee6f29beaf0749~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n### 初始化工程\\n\\n创建 Vue 项目可以使用 create-vite 和 create-vue 这两个脚手架。案例使用前者。\\n\\n```\\npnpm create vite pinia-login\\n```\\n\\n选择 Vue 和 使用 JavaScript 构建：\\n\\n![image-20221007164049987](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/801328d681754ffba779ae6b849c9717~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n![image-20221007164147819](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9763828708fb4b4a9d4805346e9c42cb~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n然后进入项目并安装依赖：\\n\\n```\\ncd vite pinia-login\\npnpm install\\n```\\n\\n代码示例上传到[仓库](https://github.com/hsyq/lite-demo)。到最后完成后的目录结构如下：\\n\\n![image-20221010221819787](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c91fbfbce3684061a202bd0fea117779~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n## Mock 的用法\\n\\n项目开发阶段通常会使用 mock 数据。插件 [vite-plugin-mock](https://www.npmjs.com/package/vite-plugin-mock) 同时提供了开发环境和生产环境下的数据 mock 服务，简单好用。\\n\\n### 安装\\n\\n插件依赖于 mockjs，需要一并安装：\\n\\n```\\npnpm add -D vite-plugin-mock mockjs\\n```\\n\\n### 配置\\n\\n在 `vite.config.js` 配置文件启用插件。\\n\\n**Mock 服务通常只用于开发阶段**，因此我们需要在配置文件中判断当前所处环境。\\n\\n在 webpack 中通常会配置一个 `NODE_ENV` 的环境变量。而在 Vite 中，不用开发者进行设置，它提供了一种方便的判断开发环境和生产环境的方式，如下：\\n\\n```\\nimport { defineConfig } from 'vite'\\nimport vue from '@vitejs/plugin-vue'\\nimport { viteMockServe } from 'vite-plugin-mock'\\n​\\nexport default defineConfig((config) => {\\n  const { command } = config\\n  return {\\n    plugins: [\\n      vue(),\\n      viteMockServe({\\n        // 只在开发阶段开启 mock 服务\\n        localEnabled: command === 'serve'\\n      })\\n    ]\\n  }\\n})\\n```\\n\\n上面，配置文件导出一个立即执行的 `defineConfig` 函数。它又接收一个函数作为参数，该函数接收一个 `config` 参数，它包含一个 `command` 属性。当在命令行中执行 `vite` （开发）命令时， `command` 的值为 `serve`，当执行 `vite build` （构建）命令时，对应的值为 `build`。据此，可以识别所处环境。\\n\\n插件 `vite-plugin-mock` 有一个配置项 `localEnabled`，可以决定是否开启 mock 服务。默认即为开启状态。结合 `command` 属性，就可以动态的切换 mock 服务的状态了。\\n\\n### 编写 mock server\\n\\n该插件开箱即用。默认它会读取项目根目录下 `mock` 文件下的内容，作为 mock server。\\n\\n新建一个模拟用户接口的服务，它导出一个数组，数组里每一项用来模拟一个接口：\\n\\n```\\n// /mock/user.js\\n​\\nexport default [\\n  // 用户登录\\n  {\\n    // 请求地址\\n    url: \\\"/api/user/login\\\",\\n    // 请求方法\\n    method: \\\"post\\\",\\n    // 响应数据\\n    response: () => {\\n      return {\\n        code: 0,\\n        message: 'success',\\n        data: {\\n          token: \\\"Token\\\",\\n          username: \\\"昆吾kw\\\"\\n        }\\n      }\\n    }\\n  }\\n]\\n```\\n\\n插件内部使用了 [Connect](https://github.com/senchalabs/connect) 来提供接口服务，它是一个比 `Express` 更悠久的 Node HTTP 框架。上面的写法就相当于创建了一个这样的接口服务：\\n\\n```\\napp.post('/api/user/login', (req, res)=>{\\n    res.send({\\n        code: 0,\\n        message: 'success',\\n        data: {\\n          token: \\\"Token\\\",\\n          username: \\\"昆吾kw\\\"\\n        }\\n    })\\n})\\n```\\n\\n由于开启了`mock` 服务，当前端在发出 `ajax` 请求时，会被拦截到，交由 `mock` 服务处理。没有做数据校验，前端传任何数据来都返回上面的结果。\\n\\n## 使用 Pinia\\n\\n如果用过 `Vuex`，那么可以无缝切换到 `Pinia`，用过之后，你会直呼**简约就是美**。\\n\\n`Pinia` 提供了更简单的 API，具有更少的规范，提供了 Composition API 风格的 API。尤其是对 `Typescript` 的支持，比 `Vuex` 好用太多。\\n\\nPinia 的核心概念只剩下了：\\n\\n-   store：状态仓库\\n-   state：状态，和 vuex 保持一致\\n-   getters：类似组件的计算属性，和 vuex 中的 getters 的保持一致\\n-   actions：和 vuex 中的 actions 保持一致，可以处理逻辑并修改 state\\n\\n安装依赖：\\n\\n```\\npnpm add pinia axios\\n```\\n\\naxios 一会在 actions 中发送请求。\\n\\n使用 Pinia 的一般套路是：\\n\\n0.  创建 pinia\\n0.  注册 pinia\\n0.  创建 store\\n0.  抽离需要管理的数据作为 state，声明 getters 优化状态读取，声明 actions 处理业务逻辑\\n0.  在需要的地方（组件或其他），导入和使用 store\\n\\n### 创建 pinia\\n\\n和 `Vuex` 的用法一样，通常会在 `src` 目录下创建 store 目录来存放状态管理有关的代码。\\n\\n首先是创建 `pinia` 插件。在该文件中，从安装好的 `pinia` 模块中导出一个 `createPinia` 方法，它用于创建一个pinia `插`件实例供 Vue 注册和使用。\\n\\n```\\n// store/index.js\\n​\\nimport { createPinia } from 'pinia'\\n​\\nconst pinia = createPinia()\\n​\\nexport default pinia\\n```\\n\\n### 注册 pinia\\n\\n在项目的入口文件中，注册上面创建出来的 `pinia` 插件。\\n\\n```\\nimport { createApp } from 'vue'\\nimport App from './App.vue'\\nimport pinia from './store'\\n​\\nconst app = createApp(App)\\napp.use(pinia).mount('#app')\\n```\\n\\n`app` 实例调用 `use` 方法来注册插件。在 Vue2 中，注册插件直接调用 `Vue.use`方法。\\n\\n### 创建用户 store\\n\\n过去使用 `Vuex` 时，通常会先创建一个根 `store`，然后划分模块，每个模块拆分成一个文件进行管理，然后再导入根 `store` 中注册。\\n\\n`Pinia` 中没有 `module` 的概念，是一个拍平的 `store` 结构。`Pinia` 推荐按照功能去划分一个个的 `store` ，这样更方便管理和使用。\\n\\n使用 `defineStore` 方法创建 `store`，`store` 的命名遵循 `useXXX` 的形式。创建时需要指定一个唯一的 `id`，有两种方式：\\n\\n```\\nconst useStore = defineStore('main', {\\n  // other options...\\n})\\n​\\nconst useStore = defineStore({\\n   id: 'main'\\n  // other options...\\n})\\n```\\n\\n下面是定义的用户 `store`。\\n\\n```\\n// store/user.js\\n​\\nimport axios from 'axios'\\nimport { defineStore } from 'pinia'\\n​\\n// 创建 store\\nconst useUserStore = defineStore('user', {\\n  // 定义状态：一个函数，返回一个对象\\n  state: () => ({\\n    username: '',\\n    token: ''\\n  }),\\n   \\n  // 定义 getters，等同于组件的计算属性\\n  getters: {\\n    // getter 函数接收 state 作为参数，推荐使用箭头函数\\n    hello: state => 'Hello!' + state.username\\n  },\\n  \\n  // 定义 actions，有同步和异步两种类型\\n  actions: {\\n    // 异步 action，一般用来处理异步逻辑\\n    async login(userData) {\\n      const result = await axios.post('/api/user/login', userData)\\n      const { data, code } = result.data\\n      if (code === 0) {\\n        // action 中修改状态\\n        this.username = data.username\\n        this.token = data.token\\n      }\\n    },\\n​\\n    // 同步 action\\n    logout() {\\n      this.token = ''\\n      this.username = ''\\n    }\\n  }\\n})\\n​\\nexport default useUserStore\\n```\\n\\n### state、getters、actions\\n\\n这几个概念，相信大家都很熟悉了，就不再过多介绍了。\\n\\n重点说下 `actions` 。过去要修改 store 中的状态，需要先 `dispatch action`，再 `commit mutation`，真的很繁琐。\\n\\n这次最大的改变，就是不再需要 `dispatch` 了，也没有 `mutation` 的概念了，可以当作普通函数那样使用就好了。无论是同步逻辑，还是异步逻辑，现在都可以一股脑写在 `actions` 中了。在一个 `action` 函数中， `this` 就是当前 `store` 的实例，可以直接修改状态。\\n\\n### 组件中使用 Pinia\\n\\n组件中使用 `store` 非常方便，使用哪个就导入哪个。\\n\\n`Pinia` 和 `Vuex4` 一样，支持 `Composition API` ，先实例化 `store`；实例化 `store` 之后，可以直接使用它的 `state`、`getters` 和 `actions`。\\n\\n```\\n// App.vue\\n​\\n<script setup>\\nimport { reactive } from 'vue'\\nimport useUserStore from \\\"./store/user\\\"\\n​\\nconst userData = reactive({\\n  username: '',\\n  password: '',\\n})\\n\\n// 实例化 store\\nconst userStore = useUserStore()\\n​\\nconst onLogin = async () => {\\n  // 使用 actions，当作函数一样直接调用\\n  // login action 定义为了 async 函数，所以它返回一个 Promise\\n  await userStore.login(userData)\\n  userData.username = ''\\n  userData.password = ''\\n}\\n​\\nconst onLogout = () => {\\n  userStore.logout()\\n}\\n</script>\\n​\\n<template>\\n  <div>\\n    <!-- state：通过 store 直接访问 -->\\n    <template v-if=\\\"userStore.token\\\">\\n       {{ userStore.username }}\\n       <br />\\n       <button @click=\\\"onLogout\\\">退 出</button>\\n    </template>\\n​\\n    <template v-else>\\n      用户名：<input v-model=\\\"userData.username\\\" />\\n      <br />\\n      密码：<input v-model=\\\"userData.password\\\" type=\\\"password\\\"/>\\n      <br />\\n      <button @click=\\\"onLogin\\\">登 录</button>\\n    </template>\\n  </div>\\n</template>\\n```\\n\\n运行代码，效果如图：\\n\\n![login-demo](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c13a66d9450b457aae7138baff2d6a65~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n### pinia 状态持久化\\n\\nPinia 的数据是存在内存当中的，页面刷新数据就会丢失。所以对于一些重要数据，需要持久化到本地存储，简单的数据可以直接调用 `localStorage` 或者 `sessionStorage` API。更推荐的方式，是使用持久化插件，比如 `pinia-plugin-persistedstate`。\\n\\n安装：\\n\\n```\\npnpm add pinia-plugin-persistedstate\\n```\\n\\n然后，在创建 `pinia` 实例的时候，进行插件的注册：\\n\\n```\\nimport { createPinia } from 'pinia'\\nimport piniaPluginPersistedstate from 'pinia-plugin-persistedstate'\\n​\\nconst pinia = createPinia()\\npinia.use(piniaPluginPersistedstate)\\n​\\nexport default pinia\\n```\\n\\n`Pinia` 中的状态是以 `store` 为单位进行管理的。哪个 `store` 中的数据需要持久化，就在哪个 `store` 中去开启。比如：\\n\\n```\\n// store/user.js\\n​\\nconst useUserStore = defineStore('user', {\\n  persist: true,\\n  \\n  // ......\\n})\\n```\\n\\n通过安装、注册插件、给 `store` 增加 `persist` 属性，就完成了持久化。\\n\\n默认，持久化的数据放在 `localStorage` 中，`key` 就是该 `store` 的 `id`，存储的结构就是 `state` 的类型：\\n\\n![image-20221010231550229](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/58b346551f2c406f9dc40f47fdb24b21~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n可以通过 `persist` 进行具体的设置，比如：\\n\\n```\\nconst useUserStore = defineStore('user', {\\n  persist: {\\n    key: \\\"USER\\\",\\n    storage: sessionStorage,\\n    paths: [\\\"token\\\"]\\n  },\\n  \\n  // ......\\n})\\n```\\n\\n这样设置的效果是，数据存储在 `sessionStorage` 中，`key` 是 USER，只持久化 `token` 这个状态：\\n\\n![image-20221010232522997](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b7b7c0824bbc4810a4dd4eda95cb55c4~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n## 结语\\n\\n我们用了一个常见的登录场景，先注册好 `pinia` 插件，然后定义需要管理的数据（状态）和方法（登录逻辑），然后在组件中初始化 store，并使用数据，调用方法，演示了使用 `Pinia` 的基本流程，最后还介绍了一个持久化插件，帮助持久化 `Pinia` 中的状态。\\n\\n从这个过程中很明显体会到，`Pinia` 的使用相比 `Vuex` ，API 更加简单，数据的流转也更加清晰。如果你还没有使用 `Pinia`，强烈推荐！",
        "tags": [
            "掘金·日新计划",
            "前端",
            "Vue.js"
        ]
    }
]