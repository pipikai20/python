[
    {
        "article_id": "7187336694880796733",
        "cover_image": "",
        "title": "我挖了一条网络隧道，差点被公司激活！555",
        "brief": "和老板的对话记录 告警邮件 自己好苦命，希望明天不要被怼的太惨。 好了，让我们开始今天的内容。 你是否常常遇到这些个麻烦，因为公司安全策略的问题，每次要通过跳板机而不能直接连开发环境，使用上面已经搭建",
        "user_name": "机智的程序员小熊",
        "view_count": 8865,
        "collect_count": 57,
        "comment_count": 16,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/7e4fb9af38effb027fd6b775e09f71fe~300x300.image",
        "category": "后端",
        "content": "![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9cccdb81b2bb46dfb81f3f4014331d3b~tplv-k3u1fbpfcp-zoom-1.image)\\n和老板的对话记录\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0139cf69584e4876aba6f68a77866481~tplv-k3u1fbpfcp-zoom-1.image)\\n告警邮件\\n自己好苦命，希望明天不要被怼的太惨。\\n好了，让我们开始今天的内容。\\n你是否常常遇到这些个麻烦，因为公司安全策略的问题，每次要通过跳板机而不能直接连开发环境，使用上面已经搭建好的数据库服务。为了方便发布，自己电脑上的服务别人，不能让开发环境的机器直接连上测试。还有我们在星巴克喝着咖啡连着免费wifi的时候，会不会网络请求都被黑客抓包下来？\\n## 概述\\n> SSH 会自动加密和解密所有 SSH 客户端与服务端之间的网络数据。但是，SSH 还同时提供了一个非常有用的功能，这就是端口转发。它能够将其他 TCP 端口的网络数据通过 SSH 链接来转发，并且自动提供了相应的加密及解密服务。这一过程有时也被叫做“隧道”（tunneling）。这是因为 SSH 为其他 TCP 连接提供了一个安全的通道，避免了用户名，密码以及隐私信息的明文传输。例如，Telnet，SMTP，LDAP 这些 TCP 应用。\\n如果工作环境中的防火墙限制了一些网络端口的使用，但是允许 SSH 的连接，那么也是能够通过将 TCP 端口转发来使用 SSH 进行通讯。总的来说 SSH 端口转发能够提供两大功能：\\n* 加密 SSH Client 端至 SSH Server 端之间的通讯数据。\\n* 突破防火墙的限制完成一些之前无法建立的 TCP 连接。\\n![隧道](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b20bdb8a9d9a481f98929c775643610f~tplv-k3u1fbpfcp-zoom-1.image)\\n## 本地转发\\n当开发机的Mysql只能从跳板机连上，我怎么才能跳过跳板机来访问远程Mysql呢？\\n![访问远程服务器的Mysql](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a025662336584609adef4b6480bf5dea~tplv-k3u1fbpfcp-zoom-1.image)\\n如上图，我们要明确的是现在有三个角色，客户端（SSH Client）、跳板机(SSH Server)、和服务器。\\n客户端只能通过ssh连接到跳板机上，跳板机可以直接访问服务器的全部端口，服务器中安装了Mysql服务并监听了3306端口。\\n这个时候，我们肯定是要用本地转发来连接,命令规则如下\\n```shell\\nssh -L [local host:]<local port>:<remote host>:<remote port> <SSH hostname>\\n```\\n看起来非常的令人费解，不清楚的问题不过就是三个，what? where? how?\\n* **what** : 使用本地转发，监听本地的某个端口，当应用访问这个端口的时候，ssh会将请求截取到，通过跳板机作为中间媒介，转发到服务器上。 服务器处理完成后，数据再原路返回完成整个链路。ssh服务在这个过程中完成了加密，转发，解密，通讯的操作。\\n* **where** : 在客户端（也称本地、SSH Client）上做这个事情\\n* **how** : 使用以下命令配置,就可以达到访问本地9527端口转发到服务器的3306端口啦\\n```shell\\nssh -L 9527:服务器:3306 root@跳板机\\n```\\n解释为，当访问本机的9527的端口时，被加密后转发到跳板机的ssh服务，服务器的3306端口\\n### 注意的点\\n1. SSH 端口转发是通过 SSH 连接建立起来的，我们必须保持这个 SSH 连接以使端口转发保持生效。一旦关闭了此连接，相应的端口转发也会随之关闭。\\n2. 我们只能在建立 SSH 连接的同时创建端口转发，而不能给一个已经存在的 SSH 连接增加端口转发。\\n3. 好了，我们已经在本地 建立了端口转发，那么既然我们在监听本地的9527端口，那么其他机器也访问本地的9523端口会不会自动转发呢？比如能否新增加一台客户端2来直接连接客户端的9527 端口？答案是不行的，在主流 SSH 实现中，本地端口转发绑定的是 lookback 接口，这意味着只有 localhost 或者 127.0.0.1 才能使用本机的端口转发 , 其他机器发起的连接只会得到“ connection refused. ”。好在 SSH 同时提供了 GatewayPorts 关键字，我们可以通过指定它与其他机器共享这个本地端口转发。\\n```shell\\nssh -g -L <local port>:<remote host>:<remote port> <SSH hostname>\\n```\\n4. 当然了，你可以随意的指定remote host，假如你要访问的服务就在跳板机上，因为防火墙又不能直接访问到，那么`remote host`和`SSH hostname`可以是同一台\\n## 远程转发\\n我的开发机上部署了一个mysql服务，我想回家以后还是连上我处于内网开发机上的mysql服务，这个时候我们怎么弄呢？\\n![远程转发图示](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e24f993f1fdd438aadcdad90b2a6ef48~tplv-k3u1fbpfcp-zoom-1.image)\\n我们需要借助一台公网的服务器讲远程的流量转发过来，由于安全策略内网机器可以连通外网机器，但是外网不能访问内网机器。我们只要转发远程的请求到正确的内网的服务上就可以了。它的命令格式是：\\n```shell\\nssh -R [ssh server host:]<SSH server port>:<local host>:<local port> <SSH hostname>\\n```\\n* **what** ：使用远程转发，监听公网服务器的某个端口，当应用访问这个端口的时候，ssh会将请求截取到，通过ssh客户端作为中间媒介，转发到真实提供服务的服务器上。 服务器处理完成后，数据再原路返回完成整个链路。\\n* **where** : 在内网服务器上运行此命令\\n* **how** ：使用以下命令配置,就可以达到访问外网机器9527端口转发到内网服务器的3306端口啦\\n```shell\\nssh -R 9527:内网机器:3306 root@公网机器\\n```\\n让公网服务器监听9527端口的访问，如有访问，就加密后通过ssh服务转发请求到内网机器ssh客户端，再由内网机器ssh客户端解密后转发到内网机器3306端口。这听起来有点奇怪，因为这个时间内网服务器充当了两个角色，就是ssh客户端和server端。用下图的展示看起来更直观一点\\n![有跳板机的远程转发](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/578657e277b147ada76e84cdc5f7c66c~tplv-k3u1fbpfcp-zoom-1.image)\\n这个时候我们就可以在跳板机上使用命令\\n```shell\\nssh -R 9527:内网机器:3306 root@公网机器\\n```\\n这个时候就是让公网服务器监听9527端口的访问，如有访问，就加密后通过ssh服务转发请求到跳板机ssh客户端上，再由ssh客户端解密后转发到内网机器3306端口上。\\n\\n### 注意的点\\n1. 必须保持ssh client到ssh server的 SSH 连接以使端口转发保持生效。一旦关闭了此连接，相应的端口转发也会随之关闭。\\n2. 我们只能在建立 SSH 连接的同时创建端口转发，而不能给一个已经存在的 SSH 连接增加端口转发。\\n3. 对于远程转发来说，`/etc/ssh/sshd_config`里要把`AllowTcpForwarding`选项设置为`yes`，否则-R远程端口转发会失败。把`/etc/sysctl.conf`里的`\\nnet.ipv4.ip_forward = 0`设置为1\\n4. 默认转发到远程主机上的端口绑定的是127.0.0.1，如要绑定0.0.0.0需要把`/etc/ssh/sshd_config`里的`GatewayPorts`选项设置为`yes`。这个选项如果由于权限没法打开也有办法，可配合ssh -L将端口绑定到0.0.0.0,如下\\n```shell\\nssh -R 127.0.0.1:9527:内网机器:3306 root@公网机器\\nssh -L 0.0.0.0:9527:127.0.0.1:9527 root@127.0.0.1\\n```\\n## 本地转发与远程转发的区别与共同点\\n\\n共同点：\\n1. 都要保持ssh不要断掉\\n2. 都是在建立链接的同时创建端口转发\\n3. 都是转发请求\\n4. 都是在ssh client上运行\\n\\n区别：\\n1. 本地转发是ssh client就是client,远程转发ssh client是server\\n2. 本地转发是本地请求远程的服务，远程转发是远程请求本地的服务\\n3. 实在理不清，听我的，转发是指转发请求，本地转发就是把本地的请求转发出去；远程转发就是把远程的请求转发过来。\\n\\n## 动态转发\\n我有一台香港服务器能上外网，凭什么我自己不能上外网！还真就可以。\\n\\n前面我们已经讨论过了本地转发，远程转发，但是前提都是要求有一个固定的应用服务端的端口号。那如果没有端口号怎么办？等等，什么样的应用会没有这个端口号呢？嗯，比如说用浏览器，比如说 MSN 等等。\\n\\n同时当我们在一个不安全的 WiFi 环境下上网，用 SSH 动态转发来保护我们的网页浏览及 MSN 信息无疑是十分必要的。\\n\\n让我们先来看一下动态转发的命令格式：\\n```shell\\n ssh -D <local port> <SSH Server>\\n```\\n![动态转发](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a69f0d0ecb32430bb136f9fabac78117~tplv-k3u1fbpfcp-zoom-1.image)\\n实际使用如下\\n```\\nssh -qTFnN -D 127.0.0.1:9527 root@香港服务器\\n```\\n### 怎么使用\\n1. 在浏览器里设置使用socks5代理127.0.0.1:9527，然后浏览器就可以访问host1所在网络内的任何IP了。推荐chrome浏览器switchyOmega插件设置为下就可以了。\\n![switchyOmega](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a4dc0a4fa8c41f1b476a79cac522bcf~tplv-k3u1fbpfcp-zoom-1.image)\\n2. 如果是普通命令行应用，使用proxychains-ng，参考命令如下：\\n\\n```shell\\n   brew install proxychains-ng\\n   vim /usr/local/etc/proxychains.conf # 在ProxyList配置段下添加配置 \\\"socks5 127.0.0.1 9527\\\"\\n   proxychains-ng wget http://host2 # 在其它命令行前添加proxychains-ng即可\\n```\\n3. 如果是ssh，则用以下命令使用socks5代理：\\n```shell\\n   ssh -o ProxyCommand='/usr/bin/nc -X 5 -x 127.0.0.1:5000 %h %p' user@host2\\n```\\n## 转发常用的参数\\n用法\\n```shell\\nssh -qTfnN -D 127.0.0.1:12345 test@222.333.444.555\\n```\\n\\n`-f` 要求 ssh在执行命令前退至后台.它用于当ssh准备询问口令或密语,但是用户希望它在后台进行.该选项隐含了-n选项.\\n\\n`-N` 不执行远程命令.用于转发端口.\\n\\n`-C` 要求进行数据压缩 (包括stdin, stdout, stderr以及转发X11和TCP/IP连接 的数据).压缩算法和gzip(1)的一样,协议第一版中,压缩级别 “level” 用CompressionLevel选项控制.压缩技术在modem线路或其他慢速连接上很有用,但是在高速网络上反而 可能降低速度.可以在配置文件中对每个主机单独设定这个参数.\\n\\n`-g` 允许远端主机连接本地转发的端口\\n\\n`-q` 安静模式.消除所有的警告和诊断信息\\n\\n`-T` 禁止分配伪终端\\n\\n`-n` 把 stdin重定向到/dev/null (实际上防止从stdin读取数据). ssh在后台运行时一定会用到这个选项.它的常用技巧是远程运行X11程序.\\n\\n## 引用\\n[ssh 端口转发](https://blog.csdn.net/ablo_zhou/article/details/5727659)\\n\\n## 一起进步\\n\\n可掘金私信我，也可 [加我好友](https://juejin.cn/pin/7186863508252164151) 我们一起进步，还可以加Go语言交流群\\n"
    },
    {
        "article_id": "7186944817639718973",
        "cover_image": "",
        "title": "使用Echarts绘制街道、镇级地图（bigmap)",
        "brief": "需求要求画出上海普陀区，具体街道、镇级的地图。普通Echart只能画出省市区的的地图不能提供具体的街道、镇级数据。所以可以通过bigmap来获取具体数据。",
        "user_name": "派来学习",
        "view_count": 8676,
        "collect_count": 187,
        "comment_count": 16,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/b641194465879064d2cf6e53cd6a7f80~300x300.image",
        "category": "前端",
        "content": "需求要求画出上海普陀区，具体街道、镇级的地图。普通Echart只能画出省市区的的地图不能提供具体的街道、镇级数据。所以可以通过bigmap来获取具体数据。\\n\\n1. 下载bigmap（选择第二个全能版）\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d3912e060a1c4d07bcc00a0f004a1f0a~tplv-k3u1fbpfcp-watermark.image?)\\n\\n2. 在bigmap中下载所需街道的.kml文件\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8220b00b2f394a75a7418767e4ae0527~tplv-k3u1fbpfcp-watermark.image?)\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/259f8a4a5dbe435ca8491c08450f746a~tplv-k3u1fbpfcp-watermark.image?)\\n\\n3.下载成功后需要将.kml文件转化为json\\n\\n将.kml文件导入geojson.io，如果有多个.kml文件则依次导入，导入成功后右侧区域就是我们需要的json文件，左侧部分则是我们后面绘制地图对应的形状（这个可以不用管），复制json数据将其保存在项目中（这里我是保存在public/static/map.json)\\n\\n地址：https://geojson.io/#map=12.59/31.2626/121.38419\\n    \\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9df9b16ba3274275b44be96218ee9dc6~tplv-k3u1fbpfcp-watermark.image?)\\n\\n4.最重要的数据已经有了，接下来就可以开始使用echart进行绘制了\\n\\n首先安装echarts\\n\\n```\\nnpm install echarts\\n```\\n然后直接在vue文件中按需导入（全局导入可参考echarts文档）\\n\\n```\\nimport * as echarts from 'echarts';\\n```\\n这里还需要用到axios来请求我们刚刚的json数据，所以安装axios\\n\\n```\\nnpm i axios\\n```\\n导入axios\\n\\n```\\nimport axios from 'axios\\n```\\n用过echarts都知道，我们需要定义一个div容器来渲染地图\\n\\n```\\n<div id=\\\"main\\\" style=\\\"width: 300px; height: 500px\\\"></div>\\n```\\n因为我的需求是进入页面直接渲染的所以我把js代码直接写在了mounted钩子里面\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/81b2db630caa40e4bdf5859aa2e5465e~tplv-k3u1fbpfcp-watermark.image?)\\n\\n到这里应该就已经完成了，但是run以后发现报错了！\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ec2ed9dca5c456d9b2ba068d4ee97ee~tplv-k3u1fbpfcp-watermark.image?)\\n\\n参考到了这篇文章：http://t.csdn.cn/2mozQ\\n\\n原因：生成的地图里有一个区域为两块不连续的，type为GeometryCollection，echarts中对于此类型没有做处理\\n解决方案：把两块不连续的数组数据放到一起，类型type为Polygon。具体可参考上述文章。\\n\\n最终效果：\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bbe32814de4847ca9bb0eb06a68699ac~tplv-k3u1fbpfcp-watermark.image?)"
    },
    {
        "article_id": "7145977342861508638",
        "cover_image": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51eef85c50284f059d94aeabc93a5038~tplv-k3u1fbpfcp-watermark.image?",
        "title": "求求别再叫我切图仔了，我是前端开发！",
        "brief": "大家好我是小卢，前几天在群里见到有群友抱怨一周内要完成这么一个大概20～30页的小程序。 群友: 这20多个页面一个星期让我开发完，我是不相信😮‍💨。 群友1: 跑吧，这公司留着没用了。",
        "user_name": "快跑啊小卢_",
        "view_count": 14245,
        "collect_count": 167,
        "comment_count": 60,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/a99401d07f0e29e915a74017b9d44d85~300x300.image",
        "category": "前端",
        "content": "我报名参加金石计划1期挑战——瓜分10万奖池，这是我的第2篇文章，[点击查看活动详情](https://s.juejin.cn/ds/jooSN7t \\\"https://s.juejin.cn/ds/jooSN7t\\\")\\n## ☀️ 前言\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93da8125251b4717806af5b79f7569ff~tplv-k3u1fbpfcp-zoom-1.image)\\n* 大家好我是小卢，前几天在群里见到有群友抱怨一周内要完成这么一个大概`20～30`页的小程序。\\n\\n  * 群友: 这`20`多个页面一个星期让我开发完，我是不相信😮‍💨。\\n  * 群友1: 跑吧，这公司留着没用了，不然就只有自己加班。\\n  * 群友2: 没有耕坏的田，只有累死的牛啊，老哥！🐮。\\n  * 群友3: 用`CodeFun`啊，分分钟解决你这种外包需求。\\n  * 群友2: 对喔！可以试一下`CodeFun`，省下来的时间开黑去。\\n* 在我印象中智能生成页面代码的工具一般都不这么智能，我抱着怀疑的心态去调研了一下`CodeFun`看看是不是群友们说的这么神奇，试用了过后发现确实挺**强大**的，所以这次借此机会分享给大家。\\n## 🤔 什么是 CodeFun\\n* 大部分公司中我们前端现在的开发工作流大概是下面这几步。\\n  * 一般会有`UI`先根据产品提供的原型图产出设计稿。\\n  * 前端根据设计稿上的标注（大小,边距等）进行编写代码来开发。\\n  * 开发完后需要给`UI`走查来确认是不是`他/她`想要的效果。\\n  * 如果发现有问题之后又继续重复上面的工作->修改样式->走查。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f6eb190cace74cbebc9224b35764c55b~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n\\n* 我们做前端的都知道，重复的东西都可以封装成组件来复用，而上面这种重复的劳作是我们最不想去做的。\\n* 但是因为设计图的精细可能有时候会有`1px`的差异就会让`产品`、`UI`打回重新编写代码的情况，久而久之就严重影响了开发效率。\\n* 我时常会有这么一种疑惑，明明设计稿上都有`样式了`,为什么还要我重新手写一遍呢？那么有没有一种可能我们可以直接通过`设计稿`就自动生成代码呢？\\n* 有的！通过我的调研过后发现，发现确实`CodeFun`在同类产品中更好的解决了我遇到的问题。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8a20efd99e544438e4550ddfb714234~tplv-k3u1fbpfcp-zoom-1.image)\\n* `CodeFun`是一款 `UI` 设计稿智能生成源代码的工具，可以将 `Sketch`、`Photoshop`、`Figma` 的设计稿智能转换为前端源代码。\\n* **8 小时工作量，10 分钟完成**是它的`slogan`,它可以精准还原设计稿，不再需要反复 `UI` 走查，我觉得在使用`CodeFun`后可以极大地程度减少工作流的复杂度，让我们的工作流变成以下这样：\\n  * `UI`设计稿产出。\\n  * `CodeFun`产出代码，前端开发略微修改交付。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d2ab705ae2884604b68abb09eb8e0e8f~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n\\n## 🖥 CodeFun 如何使用\\n* 接下来我就演示一下如何快速的根据设计稿来产出前端代码，首先我们拿到一个设计稿，这里我就在网上搜了一套`Figma`的设计稿来演示。\\n* 我们在`Figma`中安装了一个`CodeFun`的插件，选择对应`CodeFun`的项目后点击上传可以看到很轻松的就传到我们的`CodeFun`项目中，当然除了`Figama`，`CodeFun`还支持`Sketch`,`PSD`,`即时设计`等设计稿。\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/394755eb686e4a2aaa99da64298df61e~tplv-k3u1fbpfcp-zoom-1.image)\\n* 我们随便进入一个页面，引入眼帘的是**中间**的**设计稿**，而在**左侧**的列表相当于**这个页面的节点**，而我们点击一下右上角的**生成代码**可以看到它通过自己的算法很智能的生成了代码。\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b766e60fc054f81b5fde638368af7df~tplv-k3u1fbpfcp-zoom-1.image)\\n* 我上面选择生成的是`React`的代码，当然啦，他还有很多种选择`微信小程序`、`Vue`、`uni-app`等等等等，简直就是多端项目的福音！不止是框架，连`Css`预处理器都可以选择适合自己的。\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a32ad5922d1496c93ae3fbc7b2885cd~tplv-k3u1fbpfcp-zoom-1.image)\\n* 将生成的代码复制到编辑器中运行，可以看到对于简单的页面完全**不用动脑子**，直接就渲染出来我们想要的效果了，如果是很复杂的页面进行一些微调即可，是不是很方便嘿嘿。\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6bc72aba01ab4d5e9ce24109c645016e~tplv-k3u1fbpfcp-zoom-1.image)\\n* `CodeFun`不管是根据你选择的模块进行生成代码还是整页生成代码用户进行复制使用之外，它还提供了代码包下载功能，在下载界面可以选择`不同页面`,`不同框架`,`不同Css预处理器`,`不同像素单位`。\\n* 如果是`React`相关甚至还会帮你把脚手架搭建好，直接下载安装依赖使用即可，有点牛呀。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1817cb3cde3849e0b4ed340bf0abdab6~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n## 🔥 CodeFun 好在哪\\n* 笔者在这之前觉得想象中的`AI`生成前端代码的功能一直都挺简陋，用起来不会到达我的预期，到底能不能解决我的痛点，其实我是有以下固有思想的：\\n  * 生成代码就是很简单的帮你把`Html`、`Css`写完嘛但是我们不同框架又不能生成。\\n  * 生成代码的变量名肯定不好看。\\n  * 生成的代码肯定固定了宽高，不同的手机端看的效果会差很多。\\n  * 平时习惯了`v-for`,`wx:for`,`map`遍历列表，这种生成代码肯定全部给你平铺出来吧。\\n* 但是当我使用过`CodeFun`之后发现确实他可以解决我们很多的重复编写前端页面代码的场景，而且也打消了我对这类`AI`生成前端页面代码功能的一些固有思想，就如它的`slogan`所说：`8 小时工作量，10 分钟完成`。\\n### 多平台、多框架支持\\n* 支持 `Vue` 等主流 `Web` 开发框架代码输出。\\n* 支持微信小程序代码输出，当你选择小程序代码输出时，像素单位会新增一个`rpx`的选项供大家选择。\\n* 使用最简单的**复制代码**功能，我们可以快速的将我们想要的样式复制到我们的项目中进行使用 。\\n* 笔者在使用的过程中一直很好奇**下载代码**的功能，如果我选择了`React`难不成还会给我自动生成脚手架？结果一试，还真给我生成了脚手架，只需要安装依赖即可，可以说是很贴心了～。\\n\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d9341c4916f146108665241827c330a0~tplv-k3u1fbpfcp-zoom-1.image)\\n### 循环列表自动输出\\n* 我们平时在写一个列表组件的时候都喜欢使用`v-for`,`wx:for`,`map`等遍历输出列表，而`CodeFun`也做到了这种代码的生成。\\n* `CodeFun`在导入设计稿的时候会自动识别哪些是`list`组件，当然你也可以手动标记组件为`List`。\\n* 然后再开启`“将 List 标签输出为循环列表”`选项即可自动根据当前选择的框架生成对应的循环遍历语法，确实是很智能了～\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d11b0f10d2f44eceaf23f4bed48df720~tplv-k3u1fbpfcp-zoom-1.image)\\n### 批量数据绑定\\n* 在我们平时`Coding`的过程中都不会把数据写死，而是用变量来代替进行动态渲染，而`CodeFun`支持批量数据绑定功能，我们可以把任何在页面中看到的元素进行数据绑定和命名修改\\n\\n* 就拿上面的循环列表举例吧，在我们一开始识别的`Html`中，遍历循环了一个`typeCards`数组，每一个都展示对应的信息，我们可以看到这里一开始是写死的，而我们平时写的时候会将它用变量替代。\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7fa461a1fd664f13afda75cbd09f4878~tplv-k3u1fbpfcp-zoom-1.image)\\n* 我们只需要点击右上角的**数据绑定**进行可视化修改即可，我们可以看到它的全部写法都改成了变量动态渲染，这就很符合我们平时编码的套路了。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce1b00a054014ea2aa350dbd6c065499~tplv-k3u1fbpfcp-zoom-1.image)\\n### 一键预览功能\\n* 有很多同学反馈在之前做小程序的情况下需要将代码编写完整并跑起来的情况下，使用微信的预览功能才可以看到效果，会比较**繁琐**。\\n* 而`CodeFun`支持直接预览，当我们导入设计稿后，选择右上角的预览功能可以**直接生成小程序二维码扫码即可进行预览**，好赞！。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b641988e554d4cf2852cf07c381999ef~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n### 更加舒适的“生成代码”\\n* 在`CodeFun`生成的代码中是会让人看起来比较舒适的。\\n  * 变量名**可读性**会比较强。\\n  * 布局一般不会固定死宽高，而是使用`padding`等属性来**自适应屏幕百分比**。\\n  * **自动处理**设计稿中的无用图层、不可见元素、错误的编组乃至不合理的文字排列。\\n  * **全智能切图**，自动分离背景图层、图标元素。\\n\\n## ✍🏻 一些思考与建议\\n* 前端开发不仅仅是一个切图的工具人，如果你一直局限于视图的表现的时候，你的前端水平也就是`curd`工程师的水平了，我们前端更多的要深入一些`性能优化`，`前端插件封装`等等有意思的事情🙋🏻。\\n* 总之如果你想你的前端水平要更加精进的情况下，可以**减少一些在页面上的投入时间**，现在的工具越来越成熟，而这些切图工作完全可以**交给现有的工具去帮助你完成**。\\n* 在使用体验上来说，`CodeFun`确实可以解决大部分切图功能，减少大家进行切图的工作时间，大家可以去试一下～但是肯定会有一些小细节不符合自己的想法，表示理解吧，毕竟`AI`智能生成代码能做成`CodeFun`这种水平已经很厉害了👍🏻。\\n* 在使用建议上来说，我建议大家可以把`CodeFun`当成一个助手，而不要完全依赖，过度依赖，去找到更合适自己使用`CodeFun`的使用方法可以**大量减少开发时间**从而去做👉🏻更有意义的事情。\\n* 很多人会很排斥，觉得没自己写的好，但是时代已经变啦～我还是那句话，所有东西都是一个辅助，一个工具，它提供了这些优质的功能而使用的好不好是看使用者本身的，欢迎大家去使用一下`CodeFun`～支持国产！！\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ff6430b88304da585dc3c72a54ec2af~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n* 记住我们是前端开发，不是切图仔！做前端，不搬砖！\\n## 👋 写在最后\\n* 如果您觉得这篇文章有帮助到您的的话不妨🍉🍉关注+点赞+收藏+评论+转发🍉🍉支持一下哟~~😛您的支持就是我更新的最大动力。\\n* 如果想跟我一起讨论和学习更多的前端知识可以加入我的[前端交流学习群](https://juejin.cn/pin/7100537227716853768)，大家一起畅谈天下~~~\\n## 🌅 往期精彩\\n[我被骂了，但我学会了如何构造高性能的树状结构🔥](https://juejin.cn/post/7142649750402121742)\\n **93👍🏻** \\n \\n[入职Apifox研发组三个月，我领悟了30个高效开发方法🔥](https://juejin.cn/post/7072142891073667108)\\n **1091👍🏻** \\n \\n[面试官:你觉得你最大的缺点是什么?](https://juejin.cn/post/7120805355042373662) **293👍🏻** \\n\\n[几个一看就会的实用JavaScript优雅小技巧🌟](https://juejin.cn/post/7079935342966472711)\\n **640👍🏻** \\n"
    },
    {
        "article_id": "7143897892531486727",
        "cover_image": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22e45c4c44154fba990bf28b321da2ea~tplv-k3u1fbpfcp-watermark.image?",
        "title": "纯前端实现「羊了个羊」小游戏🐏",
        "brief": "最近简单的「羊了个羊」小游戏火到出圈，据说狂赚几百几千万。这么弱智的玩意，即便是前端，我上我也行！!",
        "user_name": "QCY",
        "view_count": 59158,
        "collect_count": 485,
        "comment_count": 114,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/f5f0c4f5dba74e9900c6856c563c2043~300x300.image",
        "category": "前端",
        "content": "我正在参加「码上掘金挑战赛」详情请看：[码上掘金挑战赛来了！](https://juejin.cn/post/7139728821862793223 \\\"https://juejin.cn/post/7139728821862793223\\\")\\n\\n# 背景\\n最近简单的「羊了个羊」小游戏火到出圈，据说狂赚几百几千万。这么弱智的玩意，即便是前端，我上我也行！\\n\\n# 最终成果\\n\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/031d0fe19a7141e592373451dec2b5bd~tplv-k3u1fbpfcp-watermark.image?)\\n\\n# 游戏本体\\n\\n> 如果一直白屏可以换这个地址 https://1enozc.csb.app/\\n\\n[代码片段](https://code.juejin.cn/pen/7143796732931866660)\\n\\n\\n***\\n\\n# 地图模拟\\n\\n游戏本体长这样\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eaa7f2f5200c4a5aaeb1b523d3de74f5~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n可以很明显的观察到，卡片是以 `1/4` 为单位排列的\\n\\n## 1. 单层\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c5de8408d4cb43999b9dfcd40cbdf010~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n假设有这种布局，模拟成二维数组应该如下表示，每个格子就是一个数字元素\\n\\n```\\n[\\n    [0, 0, 1, 0, 0, 0],\\n    [1, 0, 0, 0, 1, 0],\\n    [0, 0, 0, 0, 0, 0],\\n]\\n```\\n\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c39d7d7507e4d6b92ddccef737c2b4b~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n## 2. 多层\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43126b4cb91d4ab691d90bad65a60306~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n```\\n[\\n    // 第1层\\n    [\\n        [1, 0, 0, 0, 1, 0],\\n        [0, 0, 0, 0, 0, 0],\\n  \\t[1, 0, 0, 0, 1, 0],\\n  \\t[0, 0, 0, 0, 0, 0],\\n    ],\\n    // 第2层\\n    [\\n  \\t[0, 0, 0, 0, 0, 0],\\n        [0, 1, 0, 1, 0, 0],\\n  \\t[0, 0, 0, 0, 0, 0],\\n  \\t[0, 0, 0, 0, 0, 0],\\n    ],\\n]\\n```\\n\\n\\n# 地图生成\\n\\n## 1. 基础生成\\n\\n最基础的地图只关乎当前层，假设当前需要判定是否放置卡片的坐标为 `[i, j]`，那么下面四个位置就不能存在卡片，否则就会出现**同层卡片重叠**\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8d923ea403b8423784faf3ea6dab074d~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n-   `[i-1,j] != 1`\\n-   `[i,j-1] != 1`\\n-   `[i-1, j-1] ! = 1`\\n-   `[i-1, j+1] ! = 1`\\n\\n\\n同时我们加入一个随机系数，保证每次生成的地图不同\\n\\n-   `Math.random() < 0.3 === true` 的时候该位置才放置卡片\\n\\n## 2. 优化地图\\n\\n以一层为例，按上面的逻辑只能生成最简单的地图，实际我们观察游戏，会发现卡片的放置是有一定规律的：\\n\\n<img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e571bcdb832549de9e8d8d8ed3cbd176~tplv-k3u1fbpfcp-zoom-1.image\\\" alt=\\\"\\\" width=\\\"30%\\\" />\\n\\n-   左右对称\\n-   从顶层到底层越来越往中心聚集，卡片越来越少\\n-   上一层不会完全覆盖下一层\\n\\n\\n加上这两点优化之后，地图应该如下展示：\\n\\n顶层 <img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/58e523af0345415884c0acf3b4980561~tplv-k3u1fbpfcp-zoom-1.image\\\" alt=\\\"顶层\\\" width=\\\"30%\\\" />\\n\\n底层 <img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/15c805bcd438485b9d1964d14447bd82~tplv-k3u1fbpfcp-zoom-1.image\\\" alt=\\\"底层\\\" width=\\\"30%\\\" />\\n\\n## 3. 卡片渲染\\n\\n每次位置和随机数判定合格，我们应该实际放置一张卡片，一个实际的 `dom`。然后根据卡片的 x、y、z、宽高 值设置实际位置\\n\\n```\\nconst style = {\\n  position: \\\"absolute\\\",\\n  top: (y * CardItem.height) / 2 + offset + \\\"px\\\",\\n  left: (x * CardItem.width) / 2 + offset + \\\"px\\\",\\n  width: CardItem.width + \\\"px\\\",\\n  height: CardItem.height + \\\"px\\\",\\n}\\n```\\n\\n# 覆盖关系\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1d0df23f4894b41a5eb15cff0ebfe9a~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n我们可以先按一层的大小初始化一个处理遮挡用的二维数组 `coverMap`，然后在之前生成的游戏地图上，从最后一层往第一层遍历。\\n\\n```\\n[\\n    // 第1层\\n    [\\n  \\t[1, 0, 0, 0, 1, 0],\\n        [0, 0, 0, 0, 0, 0],\\n  \\t[1, 0, 0, 0, 1, 0],\\n  \\t[0, 0, 0, 0, 0, 0],\\n    ],\\n    // 第2层\\n    [\\n  \\t[0, 0, 0, 0, 0, 0],\\n        [0, 1, 0, 1, 0, 0],\\n  \\t[0, 0, 0, 0, 0, 0],\\n  \\t[0, 0, 0, 0, 0, 0],\\n    ],\\n]\\n```\\n\\n先遍历第二层，发现 `[1,1]` 位置有卡片（由于是最上层可以先不考虑本身被遮挡的情况）所以我们把 `coverMap` 的对应 4 个坐标置为 `1`，第 `[1,4]` 位置的卡片也一样处理。\\n\\n处理完顶层之后的 `coverMap` 结果如下\\n\\n```\\nconst coverMap = [\\n    [0, 0, 0, 0, 0, 0],\\n    [0, 1, 1, 1, 1, 0],\\n    [0, 1, 1, 1, 1, 0],\\n    [0, 0, 0, 0, 0, 0],\\n]\\n```\\n\\n\\n第二次（底层）遍历到 `[0,0]` 位置发现有卡片，并且实际会占据：\\n\\n-   `[0,0]`\\n-   `[0,1]`\\n-   `[1,0]`\\n-   `[1,1]`\\n\\n而其中 `[1,1]` 位置，是被遮挡的，所以这张卡片也应该被判定成遮挡状态。依次处理完这一层所有卡片，同时遮挡数组更新\\n\\n```\\nconst coverMap = [\\n    [1, 1, 0, 0, 1, 1],\\n    [1, 1, 1, 1, 1, 1],\\n    [1, 1, 1, 1, 1, 1],\\n    [1, 1, 0, 0, 1, 1],\\n]\\n```\\n\\n\\n# 填充数据\\n\\n整改游戏的核心逻辑是 pending 区域存在 **3** 个同样图案的卡片时会消除。所以我们有两个关键点要注意\\n\\n## 1. 保证卡片是 3 的倍数\\n\\n之前都是用 0、1 代指卡片，实际之前设置卡片的时候，我们可以新建 `CardItem` 类的实例，每个卡片实例会记录自己的位置、样式、是否被覆盖等状况。并且我们可以用一个 `cardList` 数组保存下这些实例\\n\\n并且在地图生成完之后，根据数组数量除 3 的余数，从前开始删除对应数量的卡片\\n\\n可以想想为什么不从后面删~\\n\\n## 2. 填充卡片类型\\n\\n我们需要**随机**的把指定种类的卡片类型，**以** **3 的倍数**填充到现有卡片中去\\n\\n### 随机\\n\\n创建一个新数组，并且随机交换顺序即可\\n\\n```\\nconst tempList = [...this.cardList];\\nconst listLength = tempList.length;\\nfor (let i = 0; i < listLength; i++) {\\n  const j = Math.ceil(Math.random() * listLength);\\n  const tempItem = tempList[i];\\n  tempList[i] = tempList[j];\\n  tempList[j] = tempItem;\\n}\\n```\\n\\n### 填充\\n\\n假设有 `cardType` 种类型的卡片，那么按 3 张重复填充即可\\n\\n```\\nfor (let i = 0; i < listLength; i++) {\\n  const item = tempList[i];\\n  item.setVal(Math.floor(i / 3) % this.cardType);\\n}\\n```\\n\\n\\n# 点击交互\\n\\n## 1. 是否可以点击\\n\\n只有顶层可以被点击，我们之前已经判定过卡片是否被覆盖的逻辑，做对应处理即可。一个简单的方法是给被覆盖的卡片设置一个特殊 style\\n\\n```\\n.covered-item {\\n  pointer-event: none;\\n}\\n```\\n\\n这样对应卡片上的任何事件都不会生效\\n\\n## 2. 点击卡片\\n\\n点击到最上层的卡片之后，我们按如下步骤处理：\\n\\n1.  把点击到的卡片实例 push 到暂存数组 `pendingList` 中\\n2.  把卡片实例从 `cardMap`、`cardList` 中去除\\n3.  `pendingList` 遍历\\n    1.  如果 `pendingList` 中存在 3 张相同的卡片，则消除这 3 张卡片\\n    2.  如果不存在，且`pendingList` 中卡片数为 **7**，游戏结束 。本局失败\\n    3.  如果 `cardList` 中的卡片数量为 0，游戏结束。本局成功\\n\\n# 总结\\n\\n到这一步，整个游戏的基础框架就已经搭建好了。剩下的难点还有\\n\\n-   道具的实现\\n    -   暂存道具\\n    -   随机道具\\n    -   撤销道具\\n\\n-   动效的实现\\n    -   从排堆进入 pendding 区域\\n    -   从 pendding 区域进入暂存区\\n    -   使用随机道具时候的动画\\n    -   集齐 3 个卡片时候的消除动画\\n\\n-   样式美化\\n\\n\\n这些基本属于锦上添花了，感兴趣的同学可以自行探索一下。我提供的实时代码里基本已经实现了大部分\\n\\n# 其他\\n\\n\\n> 可以随意转载，注明作者、出处即可！\\n\\n> 源码在游戏本体部分，点击左上方 script 部分即可 \\n\\n\\n\\n\\n"
    },
    {
        "article_id": "7187582297124634680",
        "cover_image": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c951520613e74d08ac597c2bc3d94465~tplv-k3u1fbpfcp-watermark.image?",
        "title": "你知道，前端工程部署有哪些方式嘛？",
        "brief": "本文原文地址 此文章是回答知乎问题总结而来。 我将其分为四个阶段：手动部署、命令工具部署、docker镜像部署、平台化部署。 这几个阶段，越往后越复杂，越往后越友好，毕竟平台化部署有备份还可回退，那是",
        "user_name": "大流星",
        "view_count": 6746,
        "collect_count": 179,
        "comment_count": 20,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/2fa645188333863ce130edfd9c909032~300x300.image",
        "category": "前端",
        "content": "[本文原文地址](https://github.com/AttemptWeb/Record/issues/37)\\n\\n**_[此文章是回答知乎问题总结而来](https://www.zhihu.com/people/liu-heng-88-71)_**。\\n\\n我将其分为四个阶段：**手动部署**、**命令工具部署**、**docker镜像部署**、**平台化部署**。 这几个阶段，越往后越复杂，越往后越友好，毕竟平台化部署有备份还可回退，那是相当安全的。\\n\\n  \\n\\n手动部署\\n----\\n\\n    // 打包文件，生产dist目标文件 \\n    npm run build\\n\\n将dist下的文件使用 **\\\\_FTP文件传输工具 \\\\_**，上传到服务器上去，就可以直接访问最新文件了。\\n\\n**前提**：服务器上已有web服务器，类似nginx服务、Apache服务，**服务代理已经启动**。\\n\\n### 流程：本地build构建打包 ——> FTP文件上传 ——> 通过域名访问最新文件\\n\\n  \\n\\n命令工具部署\\n------\\n\\n命令工具部署其实和 手动部署是一样，只是简化而已。\\n\\n命令工具部署就是将本地build构建 和 FTP文件上传，直接通过程序来实现。例如我们通过gitlab的CI/CD工具 或 github action上传前端文件。\\n\\ngitlab CI/CD或github action通过监听master分支push操作，进行运行你的配置命令，下面我以github action配置作为例子：\\n\\n    // .github/workflows/main.yml\\n    # name: deploy to aliyun\\n    # on:\\n    #   push:\\n    #     branches:\\n    #       - master\\n    # jobs:\\n    #   build:\\n    #     runs-on: ubuntu-latest\\n    #     steps:\\n    #       # 切换分支\\n    #       - name: Checkout\\n    #         uses: actions/checkout@master\\n    #       - name: work around permission issue\\n    #         run: git config --global --add safe.directory /github/workspace\\n    #       # 使用 node:10\\n    #       - name: use Node.js 10\\n    #         uses: actions/setup-node@v1\\n    #         with:\\n    #           node-version: 10\\n    #       # npm install 同时 build 打包\\n    #       - name: npm install and build\\n    #         run: |\\n    #           npm install\\n    #           npm run build\\n    #         env:\\n    #           CI: true\\n    #       # Deploy 上传到阿里云, secrets.ACCESS_TOKEN为配置token\\n    #       - name: Deploy aliyun\\n    #         uses: easingthemes/ssh-deploy@v2.0.7\\n    #         env:\\n    #           SSH_PRIVATE_KEY: ${{ secrets.ACCESS_TOKEN }}\\n    #           ARGS: \\\"-avz --delete\\\"\\n    #           SOURCE: \\\"./docs/.vuepress/dist/\\\"\\n    #           REMOTE_HOST: \\\"47.111.149.160\\\"\\n    #           REMOTE_USER: \\\"root\\\"\\n    #           TARGET: \\\"/var/www/HerryLo.github.io\\\"\\n\\n具体细节可以参考下面的文章↓\\n\\n[真香！GitHub Action一键部署](https://juejin.cn/post/6844904022239870984)\\n\\n**前提**：服务器上已有web服务器，类似nginx服务、Apache服务，**服务代理已经启动**。\\n\\n### 流程：git push代码到代码仓库 ——> gitlab CI/CD或github action 依赖配置文件打包并构建上传 ——> 通过域名访问最新文件\\n\\n  \\n\\nDocker镜像部署\\n----------\\n\\ndocker部署是平台化部署的基础，算是命令工具部署，如果说便捷程度，其实\\\\*\\\\*命令工具部署 和 docker部署 \\\\*\\\\*差不多，但是它有个好处：docker镜像可备份；\\n\\n    // 打包文件，生产dist目标文件 \\n    npm run build\\n\\n打包构建之后，就可以通过docker构架镜像啦，下面是docker镜像的Dockerfile文件和配置：\\n\\n    FROM node:latest\\n    COPY package.json /\\n    RUN npm i --registry=https://registry.npm.taobao.org\\n    RUN npm run build\\n    \\n    FROM nginx:latest\\n    # 这里的dist/目录是你的项目打包后的文件目录\\n    COPY ./dist/ /usr/share/nginx/html/\\n    COPY ./nginx.conf /etc/nginx/conf.d/\\n    \\n    EXPOSE 80\\n\\nnginx配置文件:\\n\\n    server {\\n        listen 80 default_server;\\n        server_name _;\\n    \\n        location / {\\n          root   /usr/share/nginx/html/web;\\n          index  index.html index.htm;\\n          try_files $uri $uri/ /index.html;\\n        }\\n    \\n        # 接口代理示例\\n        # location /api {\\n        #     proxy_pass http://xxx.com;\\n        #     proxy_set_header Host $host:$server_port;\\n        #     proxy_set_header X-Real-IP $remote_addr;\\n            #     proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\\n        #     proxy_set_header Cookie $http_cookie;\\n        #     proxy_buffering off;\\n        #     proxy_cache off;\\n        # }\\n      }\\n\\n之后 通过 docker build 、docker push 镜像名 将镜像打包并推到远端仓库（一般是自己公司项目的私库），然后在服务器上拉取更新最新的镜像，然后将最新的镜像启动即可。\\n\\n**提示**：docker 镜像一般会直接把nginx服务打包在一起，所以不用再在服务器上开启单独的服务，只需要将docker端口开放即可。当然，如果是为了统一管理端口，也是可以通过专门的代理服务管理。\\n\\n### 流程：本地 build打包文件\\\\*\\\\* ——> \\\\*\\\\*docker打包镜像\\\\_ ——> 服务器更新镜像并开启最新镜像 ——> 通过域名访问最新文件\\\\_\\n\\n具体细节可以参考下面的文章↓\\n\\n[Docker构建前端项目](https://juejin.cn/post/7022815091305218078)\\n\\n  \\n\\n平台化部署\\n-----\\n\\n平台化部署其实就是全流程： \\\\*\\\\*命令工具部署 \\\\*\\\\*+ **docker镜像的组合版。**\\n\\n只需要将代码push提交，之后通过网页访问构建打包平台，例如：阿里云效流水线 或 jekins打包构建 等平台，可以通过点击按钮，下一步下一步的方式，完成打包构建，镜像上传。\\n\\n至于更新，我是使用rancher平台来进行，服务的管理或更新，镜像上传完之后，可以在rancher平台配置好相关的负载服务，剩下就只是点击更新按钮就可以。\\n\\n下面是以 阿里codeup流水线 + rancher作为流程示例：\\n\\n**提示**：\\\\_阿里codeup流水线 或 jekins打包构建 就类似于docker镜像打包，rancher部署就类似于我们将最新镜像上传到服务器上，然后开启服务。（**rancher部署可能更加复杂，因为还涉及到k8s集群知识**）\\n\\n### #流程：git push代码到代码仓库 ——> 通过\\\\_codeup\\\\_流水线构建打包上传镜像 ——> rancher等平台更新镜像 ——> 通过域名访问最新文件\\n\\n具体细节可以参考下面的文章↓\\n\\n[知识扩展-Rancher前端服务发布](https://juejin.cn/post/7094136532499431437)\\n\\n  \\n\\n总结\\n--\\n\\n前端应用部署变化到现在的阶段，也是项目众多不便于管理导致，实际的业务情况，进而推动部署方式的发展。 前端部署的流程每个公司都有一套自己的流程，学习它，适应它，就好了，没有太多疑难问题。\\n\\n使用工具没有什么难度，难度可能就是你用的不太熟。\\n\\n### #你的点赞、收藏是我的更新的动力！！"
    },
    {
        "article_id": "7188048129831206973",
        "cover_image": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4f17f4030074b1cb0118d71731f4fd0~tplv-k3u1fbpfcp-watermark.image?",
        "title": "用canvas写一个支付宝画年画",
        "brief": "接近过年了，支付宝的集福的活动又开始了，集美们的五福集齐了没有。每年的集福活动都有一些小游戏，今年也不例外，画年画就是其中之一",
        "user_name": "郑丫头",
        "view_count": 2014,
        "collect_count": 29,
        "comment_count": 19,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/0448570cc96cc5b8db0d816b69ecf674~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: cyanosis\\n---\\n我正在参加「兔了个兔」创意投稿大赛，详情请看：[「兔了个兔」创意投稿大赛](https://juejin.cn/post/7185104994801025061 \\\"https://juejin.cn/post/7185104994801025061\\\")\\n\\n接近过年了，支付宝的集福的活动又开始了，集美们的五福集齐了没有。每年的集福活动都有一些小游戏，今年也不例外，画年画就是其中之一，本篇用canvas来写一个画年兔的游戏。\\n\\n<img src=\\\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac5de9bae17c45d085580156193d0dfa~tplv-k3u1fbpfcp-watermark.image?\\\" width=\\\"300\\\" />\\n\\n## 动手前的思路\\n画年画游戏规则是：跟着特定轮廓画出线条来。\\n### 思考1、如何让鼠标只能在特定区域内画画？\\n首先要获取到这个轮廓区域所在画布上的位置，判断鼠标绘画的位置是否在指定范围内。用canvas的getImageData函数能够获取到画布上有颜色的像素点，然后根据像素点分布计算出像素点所在位置。\\n\\ngetImageData函数的用法在我之前的文章[canvas文字粒子特效](https://juejin.cn/post/7169849962262429732)中有详细介绍，不懂的可以去看看。\\n```js\\ngetImageData(canvas, ctx) {\\n    const data = ctx.getImageData(\\n        0,\\n        0,\\n        canvas.width,\\n        canvas.height,\\n    ).data;\\n    const gap = 4;\\n    const points = [];\\n    const length = data.length;\\n    for (let i = 0, wl = canvas.width * gap; i < length; i += gap) {\\n        if (data[i + gap - 1] == 255) {\\n            // 根据透明度判断\\n            const x = (i % wl) / gap;\\n            const y = Math.ceil(i / wl);\\n            points.push([x, y]);\\n        }\\n    }\\n    return points;\\n}\\n```\\n### 思考2、如何让绘制的图画动起来？\\n通过定时旋转画布实现。我选择用帧动画requestAnimationFrame函数，比setInterval函数性能更好一点。\\n\\n### 思考3、如何撤销上一步操作？\\n将每一步绘制的点都记录到创建的栈中，每一次撤销都把上一步的绘制点删除。\\n\\n### 思考4、如何判断线条绘制完毕？\\n想了很久没有什么太好的办法，如果你有想法可以分享给我。当mouseup事件执行，会判断当前步骤下绘制的点数是否>=30，如果满足条件会延迟半秒执行下一步绘制，当mousedown在半秒内触发，延迟函数会取消，等待下一个mouseup事件。\\n\\n```js\\n// mouseup事件\\nconst length = _this.execStack.reduce((prev, next) => {\\n    if (next.step == _this.curStep) {\\n        prev += next.points.length;\\n    }\\n    return prev;\\n}, 0)\\nif (length >= 30) {\\n    _this.timer = setTimeout(() => {\\n        if (_this.curStep == 2) {\\n            _this.curStep = 2.5\\n            _this.canEdit = false;\\n            _this.animate('ears_1', 3);\\n        } else if (_this.curStep == 4) {\\n            _this.curStep = 4.5\\n            _this.canEdit = false;\\n            _this.animate('shake_head', 5);\\n        } else if (_this.curStep == 6) {\\n            _this.curStep = 6.5\\n            _this.canEdit = false;\\n            _this.animate('shake_body', 7);\\n        } else if (_this.curStep <= 6) {\\n            _this.canEdit = true;\\n            _this.curStep += 1;\\n        }\\n        _this.execCanvas();\\n    }, 500);\\n}\\n```\\n\\n## 关键步骤\\n#### 1、创建一个RabbitPainting类，初始化时监听canvas的鼠标点击事件。要注意的是移动端和pc端监听的事件不同：\\n\\n```js\\nthis.pcEvents = ['mousedown', 'mousemove', 'mouseup'];\\nthis.mobileEvents = ['touchstart', 'touchmove', 'touchend'];\\n```\\n我的代码里对兼容的处理比较粗糙，只是将大致功能做出来了，所以大家多看看思路。\\n\\n鼠标移开之后，需要解除事件监听，当鼠标重新按压时再绑定事件。mousedown事件监听流程如下：\\n\\n```mermaid\\ngraph TD\\nmousedown --> mousemove --> mouseup --> 解除mousemove/mouseup\\n```\\n\\n鼠标移动时，会得到两个点，鼠标按压位置和鼠标移动位置，如果绘制的线都是从按压点到移动点的话，就会画出：\\n\\n<img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e413e4bf0444feca4c560a45b5744bf~tplv-k3u1fbpfcp-watermark.image?\\\" width=\\\"300\\\" />\\n\\n上图所示，红色的线是鼠标移动路径，黑色的线是canvas画出的线条，所以mousemove函数执行后要更新初始按压点，使前后两个点衔接在一起。\\n\\n<img src=\\\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/26f3e93207e44d4ab2b5bdf69bdb766c~tplv-k3u1fbpfcp-watermark.image?\\\" width=\\\"300\\\" />\\n\\n线条绘制函数如下：\\n```js\\ndrawLine(point) {\\n    const { ctx } = this\\n    ctx.beginPath()\\n    ctx.moveTo(point.startX, point.startY);\\n    ctx.lineTo(point.endX, point.endY);\\n    if (point.style) {\\n        for (let key in point.style) {\\n            ctx[key] = point.style[key]\\n        }\\n    }\\n    ctx.stroke();\\n    ctx.closePath()\\n}\\n```\\n\\n#### 2、兔子轮廓绘制，采用贝塞尔2阶函数绘制图形\\n\\n<img src=\\\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/599153463ab34bb59565f7963e70407a~tplv-k3u1fbpfcp-watermark.image?\\\" width=\\\"300\\\" />\\n\\n```js\\n// 外轮廓样式\\nconst wrapperStyle = {\\n    lineWidth: \\\"30\\\",\\n    strokeStyle: this.tipPathColor[0]\\n}\\n// 内虚线样式\\nconst innerStyle = {\\n    lineWidth: \\\"3\\\",\\n    strokeStyle: this.tipPathColor[1],\\n    lineDash: [15, 12]\\n}\\n```\\n```js\\ndrawCurve({ list, wrapperStyle, innerStyle }) {\\n    const { tempCtx: ctx } = this\\n    list.forEach(point => {\\n        const { x, y, list } = point;\\n        ctx.beginPath();\\n        ctx.moveTo(x, y);\\n        ctx.bezierCurveTo(...list);\\n        for (let key in wrapperStyle) {\\n            ctx[key] = wrapperStyle[key]\\n        }\\n        ctx.stroke();\\n        ctx.save()\\n        ctx.beginPath();\\n        ctx.moveTo(x, y);\\n        ctx.bezierCurveTo(...list);\\n        for (let key in innerStyle) {\\n            if (key == 'lineDash') {\\n                ctx.setLineDash(innerStyle[key]);\\n            }\\n            ctx[key] = innerStyle[key]\\n        }\\n        ctx.stroke();\\n        ctx.restore();\\n    })\\n}\\n```\\n贝塞尔曲线的关键在于设置p1和p2两个控制点，大家自行把握。\\n\\n<img src=\\\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e37a7cdfb76d49158521a8c5d49b92d7~tplv-k3u1fbpfcp-watermark.image?\\\" width=\\\"300\\\" />\\n\\n我的兔子轮廓总体是这样的：\\n\\n<img src=\\\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d40810d09b3a49ea8b1de449deb6d236~tplv-k3u1fbpfcp-watermark.image?\\\" width=\\\"300\\\" />\\n\\n#### 3、旋转画布功能\\n使用canvas的rotate函数，画布的默认中心点是（0,0），所以旋转时需要用translate（x,y）函数将中心点移动到特定位置。要注意旋转后将画布的中心点还原到（0,0）。\\n\\n```js\\nconst rotateCanvas = (centerPoints, item) => {\\n    ctx.save()\\n    ctx.translate(...centerPoints)\\n    ctx.rotate(Math.PI / 180 * item.curDeg)\\n    ctx.translate(-centerPoints[0], -centerPoints[1])\\n}\\n```\\n注意ctx.save()，用来记录画布旋转之前的状态，绘制结束后需要用ctx.restore()将画布状态还原，否则定时函数执行角度旋转时角度会累加。\\n\\n#### 4、眨眼睛动画\\n眨眼睛是用一张精灵图，因为图片是我自己画的，只有六帧，所以动画看起来不是很好，将就看着吧。\\n\\n\\n[jcode](https://code.juejin.cn/pen/7187989122928082996)\\n\\n\\n\\n\\n"
    },
    {
        "article_id": "7182545613282623549",
        "cover_image": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c116a13271084ba5b488ba725642bc33~tplv-k3u1fbpfcp-watermark.image?",
        "title": "qq农场私信我，您菜死了🥬",
        "brief": "在这里，会分享一些关于javascript代码技巧、tips、成长、学习、设计模式相关的内容，一起学习，共同进步！",
        "user_name": "Kuroo",
        "view_count": 1739,
        "collect_count": 3,
        "comment_count": 3,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/2703e015bde68a0ceac3518579be9c1c~300x300.image",
        "category": "前端",
        "content": "最近在写代码的时候发现自己总是有这样**几种症状**：\\n\\n1.  脸红心跳，像发烧一样😳；\\n1.  口干舌燥、咳嗽不停😮‍💨；\\n1.  脑袋放空，像刚通宵了一般👀；\\n1.  ......\\n\\n我逐渐怀疑，自己有没有可能是🐑了，甚至时不时就拿起体温计量一量，拿起自测试纸测一测，这样的情况一直没有得到好转，直到收到QQ农场给我发来这样的一条信息：\\n\\n`尊敬的QQ农场主，您去年和今年菜死了！🥬🥬🥬`\\n\\n  \\n\\n\\n🤔于是，我开始分析我症状根因是什么：\\n\\n1.  脸红心跳：是因为自己脑海中想象好的实现方案，但实际却写不出一行代码，或者各种Error，导致我心里**落差很大，自我怀疑**，或者是被人看穿菜的窘迫、害羞？\\n1.  口干舌燥：是因为自己陷入了 写不出代码 => 憋着气接着写，不休息喝水 => 写不出代码 这样的闭环🐶里面；\\n1.  脑袋放空：摆脱了内耗，很容易得出结论，就是**看的技术不够多，写的代码不够多**\\n\\n痛定思痛，决定在这里立下FLAG，要多看多实践，学习和思考好的代码写法，看得多，写得多。\\n\\n  \\n\\n\\n今天分享的主要是：用好**发布订阅、偏函数的一对多 & 多对一关系**和**工厂函数**\\n\\n## 发布订阅 & 偏函数（一对多/多对一关系）\\n\\n`是一种一对多的模式，或者说多对多的模式；一个事件对应多个处理函数，多个事件对应各自对应的处理函数`\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eceb8976dcc74961bd200874d7582955~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n**那假如我们想实现一个多对一的关系呢？我们可以使用偏函数**\\n\\n`偏函数个人理解类似工厂函数，利用了闭包的特性`\\n\\n```\\n// 偏函数\\nfunction after(times, cb) {\\n  let count = 0;\\n  const result = {};\\n  return inner(key, value) => {\\n    result[key] = value;\\n    count++;\\n    if (count === times) {\\n      cb(result);\\n    }\\n  };\\n}\\n```\\n\\n**结合代码看此处相当于多个inner函数对应一个callback函数，由count来控制是否触发callback，这种模式常常用于异步编程，比如Promise.all**\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0361677d0e104551b25dd0ba3edd4c78~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n**综合一对多和多对一模式：**\\n\\n```\\n// 偏函数\\nfunction after(times, cb) {\\n  let count = 0;\\n  const result = {};\\n  return (key, value) => {\\n    result[key] = value;\\n    count++;\\n    if (count === times) {\\n      cb(result);\\n    }\\n  };\\n}\\n\\n// 发布订阅\\nconst emitter = new (require(\\\"events\\\").EventEmitter)();\\nconst done = after(3, render);\\n\\nemitter.on(\\\"done\\\", done);\\nemitter.on(\\\"done\\\", other);\\n\\nfs.readFile(file, (err, template) => {\\n  emitter.emit(\\\"done\\\", \\\"template\\\", template);\\n});\\n\\nfs.readFile(file, (err, data) => {\\n  emitter.emit(\\\"done\\\", \\\"data\\\", data);\\n});\\n\\nfs.readFile(file, (err, str) => {\\n  emitter.emit(\\\"done\\\", \\\"str\\\", str);\\n});\\n```\\n\\n* * *\\n\\n## 工厂函数\\n\\n`类似现实工厂，在代码中用来生产特定结构函数/对象等的函数`\\n\\n比如想**实现一个生成校验函数**的工厂函数：\\n\\n```\\n/**\\n * config里可以包含一般的描述性属性，钩子函数等\\n**/\\nexport function factory(config) {\\n  config.before = config.before || ((d) => d);\\n\\t// pre钩子\\n  handlersMap[config.type]?.pre(config);\\n\\n  return function (data) {\\n\\t  // before钩子函数\\n    data = config.before(data);\\n    return handlersMap[config.type].check(data);\\n  };\\n}\\n\\n// 通过该方法注册不同的校验函数\\nconst handlersMap = {};\\nfactory.registerHandler = function (type, handler) {\\n  handlersMap[type] = handler;\\n};\\n```\\n\\n在项目中的实现可如图：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ce83fd632654356885bdeae26914b43~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n## 🌊总结：\\n\\n阅读好的代码，并学习一些好的写法，才是比较实际提高代码能力的方式，我也将💪持续阅读好的代码库，思考学习好的代码，把自己的成长分享出来。"
    },
    {
        "article_id": "7185413265789288507",
        "cover_image": "https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4af5f55f0aac467d898b5f13e1df9f01~tplv-k3u1fbpfcp-watermark.image?",
        "title": "用Three.js做个兔吉宝箱给大家拜个年",
        "brief": "不知不觉兔年已经来到，今年用什么形式庆贺新春呢，思来想去，就准备用Three.js做个拜年宝箱动画，宝箱落下后点击就可以打开，一直萌萌哒的小兔吉就给我拜年啦，而且每次说出的贺词都是不同的哦~",
        "user_name": "jsmask",
        "view_count": 5436,
        "collect_count": 89,
        "comment_count": 27,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/3cc923506359b8170e1d8b9051bb2bef~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: qklhk-chocolate\\n---\\n我正在参加「兔了个兔」创意投稿大赛，详情请看：[「兔了个兔」创意投稿大赛](https://juejin.cn/post/7185104994801025061)”\\n\\n## 介绍\\n\\n不知不觉兔年已经来到，今年用什么形式庆贺新春呢，思来想去，就准备用Three.js做个拜年宝箱动画，宝箱落下后点击就可以打开，一直萌萌哒的小兔吉就给我拜年啦，每次说出的贺词都是不同的，所以我把这个宝箱命名为兔吉宝箱~\\n\\n## 演示\\n\\n![演示.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f17dcd1db54b404d923ee5b76593db50~tplv-k3u1fbpfcp-watermark.image?)\\n\\n> 演示地址： https://jsmask.gitee.io/rabbit-lucky-chest\\n>\\n> 源码地址：https://gitee.com/jsmask/rabbit-lucky-chest\\n\\n## 正文\\n\\n### 基础搭建\\n\\n本项目将使用vite4来实现：\\n\\n```sh\\nyarn create vite\\n```\\n\\n起好项目名，选择vue3后，就构建成功一个基础项目了。\\n\\n再配置一下 `vite.config.js` 文件，拿些文件的时候至少得要个别名吧，因为项目也比较小，目前就简单配置了。\\n\\n```js\\nimport { defineConfig } from 'vite'\\nimport vue from '@vitejs/plugin-vue'\\nimport { resolve } from \\\"path\\\"\\n\\n// https://vitejs.dev/config/\\nexport default defineConfig({\\n  base:\\\"./\\\",\\n  server: {\\n    host: '0.0.0.0',\\n    open: false,\\n  },\\n  resolve: {\\n    alias: {\\n      \\\"@\\\": resolve(__dirname, \\\"src\\\")\\n    }\\n  },\\n  plugins: [vue()],\\n})\\n\\n```\\n\\n当然这还远远不够，我们还要安装scss来为更好的书写样式:\\n\\n```sh\\nyarn add scss -D\\n```\\n\\n这里我还安装了 `reset.css` ，目的是清除一些浏览器的默认样式。\\n\\n```sh\\nyarn add reset.css\\n```\\n\\n而且导入在 style.scss 里，然后可以在里面写一些定义的公共样式。最后把 `style.scss` 直接再导入到 `main.js` 中。\\n\\n```scss\\n// style.scss\\n@import url(\\\"reset.css\\\");\\n// ...\\n```\\n\\n为了更方便的获取一些资源，我们还要把资源文件放置到 `public` 文件夹中，这样我们就可以直接用音频，图片，模型这些资源了。\\n\\n![目录.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0680ccc879104c848e54f0f0e1065e86~tplv-k3u1fbpfcp-watermark.image?)\\n\\n### 场景搭建\\n\\n这个项目一共分两个场景，一个是刚进来默认的初始确认场景，一个是3D动画的主场景，主要实现的业务代码还是比较多的，详细请看上面的源码。\\n\\n![初始.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/424e08516d6f4de8ab1d3415c47285fa~tplv-k3u1fbpfcp-watermark.image?)\\n\\n初始场景就是非常普通页面，就是用css写一个闪动的文字动画，然后监听键盘和鼠标当按下后，闪动加快一段时间后就跳入到3D动画的场景中。\\n\\n加入这个初始默认场景的主要目的有三个，第一让用户点击后实现了交互激活音效功能，第二让用户有个准备不要一上来就开始了失去了趣味，第三点因为里面的音效有四个资源这里希望在默认来的时候先加载他们不至于后面播放不出来。\\n\\n```js\\n// audio.js\\nexport let AUDIODATA = {\\n    BGMMAIN: \\\"assets/audio/bgm.mp3\\\",\\n    PRESS:\\\"assets/audio/press.mp3\\\",\\n    OPEN: \\\"assets/audio/open.mp3\\\",\\n    FADE:\\\"assets/audio/fade.mp3\\\",\\n}\\n\\nlet bgm = new Audio();\\nbgm.src = AUDIODATA.BGMMAIN\\n\\nexport function playBGM(continuate = true) {\\n    if (!continuate) bgm.currentTime = 0;\\n    bgm.volume = 60 / 100;\\n    bgm.loop = true;\\n    bgm.play();\\n    return bgm\\n}\\n\\nexport function stopBGM() {\\n    if (!bgm) return;\\n    bgm.paused();\\n    bgm.currentTime = 0;\\n}\\n\\n// ...\\n```\\n\\n![动画场景.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/74133222342f48c3ae4c26a1d822b2d5~tplv-k3u1fbpfcp-watermark.image?)\\n\\n接下来就是3D动画的场景，要做3D首先安装 `three.js` \\n\\n```sh\\nyarn add three\\n```\\n\\n然后写一个脚本文件 `index.js` 引入将`three.js` 其中，这个文件也是我们的主逻辑脚本，其中会实现一个 `Game` 的类，在这个里面我们将实现场景初始化，引入摄像机灯光模型等 ，后面会将这个类实例化，传入到显示容器中。\\n\\n```js\\n// game/index.js\\nimport * as THREE from \\\"three\\\"\\nexport default class Game {\\n    constructor(parentEl) {\\n        this.parentEl = parentEl;\\n        this.init();\\n    }\\n    init(){\\n        this.renderer = new THREE.WebGLRenderer({\\n            antialias: true,\\n        });\\n        this.renderer.outputEncoding = THREE.sRGBEncoding;\\n        this.renderer.gammaFactor = 3;\\n        this.renderer.shadowMap.enabled = true;\\n        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;\\n        this.renderer.setPixelRatio(window.devicePixelRatio);\\n        this.renderer.setSize(window.innerWidth, window.innerHeight);\\n        this.renderer.domElement.id = \\\"game-canvas\\\"\\n        this.parentEl.appendChild(this.renderer.domElement);\\n        // ...\\n    }\\n    // ...\\n}\\n```\\n\\n```vue\\n<!--MainScene.vue-->\\n<template>\\n\\t<div ref=\\\"gameRef\\\" class=\\\"main-game\\\"></div>\\n</template>\\n\\n<script setup>\\n    import { ref, onMounted, onUnmounted } from \\\"vue\\\"\\n    import { playBGM } from \\\"@/game/audio\\\"\\n    const gameRef = ref(null)\\n    let game;\\n    onMounted(() => {\\n        playBGM();\\n        game = new Game(gameRef.value)\\n    })\\n    onUnmounted(() => {\\n        game.destroy()\\n    })\\n</script>    \\n```\\n\\n### 场景切换\\n\\n场景有了但是我们这么快速的切换呢，此时很多人都直接使用vue-router来切换。但是考虑目前项目只有两个场景到是可以不使用，这样减少了一个库，减少了资源的使用。二来路由切换后地址栏会有杂质。而且我们还没有对游戏一些自定义配置需要用到状态管理类的库，不如就用状态管理暂时充当路由使用，反正就俩场景，用 `v-if` 控制好了。\\n\\n```vue\\n<!--App.vue-->\\n<script setup>\\nimport PressScene from \\\"./view/PressScene.vue\\\"\\nimport MainScene from \\\"./view/MainScene.vue\\\"\\nimport { useSystemStore } from \\\"@/store/system\\\";\\nconst store = useSystemStore();\\n</script>\\n\\n<template>\\n    <press-scene v-if=\\\"store.scene == 'press'\\\" />\\n    <main-scene v-if=\\\"store.scene == 'play'\\\" />\\n</template>\\n```\\n\\n当然，可以看到系统管理我们用到了 `pinia` 。\\n\\n先安装一下：\\n\\n```sh\\nyarn add pinia\\n```\\n\\n再写一个专门管理系统状态的文件：\\n\\n```js\\n// system.js\\nimport { defineStore } from 'pinia'\\n\\nconst defaultState = {\\n    scene: \\\"press\\\",\\n}\\n\\nexport const useSystemStore = defineStore('system', {\\n    state: () => {\\n        return {\\n            ...defaultState\\n        };\\n    },\\n    actions: {\\n        changeScene(sceneName) {\\n            this.scene = sceneName;\\n        },\\n    }\\n})\\n```\\n\\n目前还是比较简单，就是单纯的控制场景是哪一个，当然你还可以加一些别的配置比如音量或者播放速度的控制等等。\\n\\n每次切换场景只要通知一些系统，状态要改变了，场景就会发生变化。\\n\\n```js\\n// PressScene.vue\\nwindow.addEventListener(\\\"keydown\\\", handleClick)\\nfunction handleClick() {\\n    store.changeScene(\\\"play\\\")\\n    window.removeEventListener(\\\"keydown\\\", handleClick)\\n}\\n```\\n\\n### 模型加载\\n\\n加载和导入模型，我们以宝箱为例：\\n\\n```js\\nimport * as THREE from \\\"three\\\"\\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader';\\nimport bus from \\\"./bus\\\"\\n\\nexport default class Chest {\\n    constructor(game) {\\n        this.game = game;\\n        this.scene = game.scene;\\n        this.camera = game.camera;\\n        this.target = null;\\n        this.isOpen = false;\\n        this.state = \\\"wait\\\"\\n        this.init();\\n    }\\n    init() {\\n        let loader = new GLTFLoader();\\n        loader.load(\\\"./assets/mod/chest/scene.gltf\\\", gltf => {\\n            this.target = gltf.scene;\\n            this.animations = gltf.animations;\\n            this.target.scale.set(.005, .005, .005);\\n            this.target.position.set(0, 5, 0)\\n            this.target.traverse(c => {\\n                c.castShadow = true;\\n                c.receiveShadow = true;\\n                if (c.material && c.material.map) {\\n                    c.material.map.encoding = THREE.sRGBEncoding;\\n                }\\n            });\\n            this.mixer = new THREE.AnimationMixer(this.target);\\n            this.mixer.addEventListener('finished', this.finishedAnimation.bind(this));\\n            this.scene.add(this.target);\\n            bus.$emit(\\\"loaded\\\",\\\"chest\\\")\\n        }\\n    }\\n    // ...\\n}\\n```\\n\\n因为宝箱模型是gltf格式的，所以通过实例化 `GLTFLoader` 来实现一个Loader。通过load方法来传入地址来加载它，这里要注意地址要设置成相对路径。加载成功后会就可以拿到模型信息，此时你可以设置该模型的大小位置方向等等，当然这个模型是有动画的所有我们还要保存一下它动画的信息。\\n\\n模型对象有 `traverse` 可以对此模型进行遍历，这里是对其添加一些阴影设置，当然如果有需要还可以更换材质节点等等操作。\\n\\n最后，你会发现我们这里自定义了一个bus作为来发布订阅一些消息，这里是把该模型的加载的消息发出去。然后主逻辑获取这些信息。\\n\\n发布订阅我们使用了 `mitt.js` 库来实现。\\n\\n```js\\n// bus.js\\nimport mitt from \\\"mitt\\\";\\n\\nconst bus = {};\\nconst emitter = mitt();\\n\\nbus.$on = emitter.on;\\nbus.$off = emitter.off;\\nbus.$emit = emitter.emit;\\n\\nexport default bus;\\n```\\n\\n这样在主逻辑脚本中，可以接收到加载完的消息从而通知界面逻辑。\\n\\n```js\\n// game/index.js\\nconst loadModNameList = []\\nbus.$on(\\\"loaded\\\", (name) => {\\n    loadModNameList.push(name)\\n    bus.$emit(\\\"progress\\\", ~~(loadModNameList.length / 3 * 100))\\n    if (loadModNameList.length >= 3) {\\n        setTimeout(()=>{\\n            this.chest.playGame()\\n        },500)\\n    }\\n})\\n```\\n\\n![出来.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf27f8c656a2412ea0cbedfb03bfe30d~tplv-k3u1fbpfcp-watermark.image?)\\n\\n### 宝箱选中\\n\\n这个3D动画其中一个交互是你要点击宝箱后才能打开，小兔吉出来拜年，那么怎么才能判断你点中了宝箱模型呢？其实非常简单，只要你绑定好点击事件，点击画面后就可以拿到坐标将其变成三维坐标，再根据摄像机位置，实例出 `THREE.Raycaster` 在场景中发出一道射线会捕获到经过的物体，然后根据这些物体遍历，如果其中有的物体属于宝箱的，那么就意味着刚才的点击就选中了宝箱模型。然后就可以对其发出打开等指令操作了。\\n\\n```js\\nexport default class Chest {  \\n\\tbindEvent() {\\n        window.addEventListener(\\\"mouseup\\\", this.handleClick.bind(this));\\n        window.addEventListener(\\\"touchend\\\", this.handleClick.bind(this))\\n    }\\n    handleClick(e) {\\n        let vector = new THREE.Vector3();\\n        vector.set(\\n            (e.clientX / window.innerWidth) * 2 - 1,\\n            -(e.clientY / window.innerHeight) * 2 + 1,\\n            0.5);\\n        vector.unproject(this.camera);\\n        let raycaster = new THREE.Raycaster(this.camera.position, vector.sub(this.camera.position).normalize());\\n        let intersects = raycaster.intersectObjects(this.scene.children);\\n        let isActive = false;\\n        // 遍历射线是否经过宝箱\\n        for (const item of intersects) {\\n            this.target.traverse(c => {\\n                if (c == item.object) isActive = true;\\n            })\\n        }\\n        // 如果选中并且没有打开就直接打开指令打开宝箱\\n        if (isActive && this.state == \\\"wait\\\" && !this.isOpen) {\\n            this.open();\\n        }\\n    }\\n}    \\n```\\n\\n![1.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b6df5c1dadb3476d94e108291c6e8fd2~tplv-k3u1fbpfcp-watermark.image?)\\n\\n### 模型动画\\n\\n还是以宝箱模型打开动画为例，当初模型加载完成的时候，已经把模型信息里的动画存储下来放到了 `animations` 中。\\n\\n```js\\nexport default class Chest {  \\n\\topen() {\\n        console.log(\\\"open begin\\\")\\n        this.isOpen = true;\\n        bus.$emit(\\\"open\\\")\\n        playSeOpen()\\n        this.mixer.stopAllAction();\\n        let anim = this.animations[0]\\n        let curAction = this.mixer.clipAction(anim);\\n        curAction.enabled = true;\\n        curAction.time = 0.0;\\n        curAction.clampWhenFinished = true;\\n        curAction.setEffectiveTimeScale(1.0);\\n        curAction.setEffectiveWeight(1.0);\\n        curAction.setLoop(THREE.LoopOnce, 1);\\n        curAction.play();\\n    }   \\n}\\n```\\n\\n我们先拿到所需要的打开动画 `anim` ,在动画混合器 `mixer`中，设置当前动画的动作。因为打开动画是只播放一次不需要去循环播放，所以就要设置它循环次数为1，当然还有很多细节上的设置要去调整，之后就可以使用 `play` 方法播放了。\\n\\n最后别忘了，动画每一帧都是需要更新才会有效果的。\\n\\n```js\\nexport default class Chest {     \\n\\tupdate(delta) {\\n        this.mixer && this.mixer.update(delta);\\n    }\\n}\\n```\\n\\n![2.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c27ccb4267e473b980b199afbb6c535~tplv-k3u1fbpfcp-watermark.image?)\\n\\n### 缓动动画\\n\\n这个3d世界中所有缓动动画比如宝箱下落回弹，摄像机视角的前进，都是使用gsap.js来实现的，所以先安装一下：\\n\\n```sh\\nyarn add gsap\\n```\\n\\n这里用到了gsap的时间线动画，非常简单就是实例化 `gsap.timeline` ，在某个阶段用什么缓动效果持续多久实现某个动画，结束之后会怎么都可以轻松设置。\\n\\n```js\\nimport gsap, { Bounce } from \\\"gsap\\\"\\nexport default class Chest {  \\n\\tplayGame(){\\n        this.runTimeLine();\\n    }\\n    runTimeLine() {\\n        this.timer = new gsap.timeline({\\n            defaults: { duration: 0 },\\n        });\\n        playSeFade()\\n        this.timer.to(\\n            this.target.position,\\n            {\\n                duration: 1,\\n                y: 0,\\n                ease: Bounce.easeOut,\\n                onComplete: () => {\\n                    this.rabbit.setVisible(true)\\n                },\\n            }\\n        );\\n        this.timer.to(\\n            this.camera.position,\\n            {\\n                duration: 1.2,\\n                z: 2.4,\\n                onComplete: () => {\\n                    this.bindEvent();\\n                },\\n            },\\n            1.5\\n        );\\n    }\\n}\\n```\\n\\n![4.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e6d7278ab3d4faab0aa65d1b5791c29~tplv-k3u1fbpfcp-watermark.image?)\\n\\n### 贺词动效\\n\\n贺词是做css来实现，因为打开宝箱后镜头会固定住完全可以在指定位置做文字动画，又不用再引入3D字体模型来增加资源消耗。\\n\\n![贺词.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/66627bc72b574a20a06585d4c59b7b56~tplv-k3u1fbpfcp-watermark.image?)\\n\\n当然，你会发现这些文字动画，每个文字都带了些角度偏移，从而整个贺词形成拱形。这里就不得不夸赞用scss来快速实现这个样式了。\\n\\n```scss\\n@use 'sass:math';\\n$color: rgb(255, 201, 101);\\n$border-width: 2px;\\n$border-color: #000;\\n$num: 9;\\n$deg: 12deg;\\n$delay: 350ms;\\n\\nh1 {\\n        position: relative;\\n        display: flex;\\n        justify-content: center;\\n        align-items: center;\\n        color: $color;\\n        letter-spacing: #{$border-width * 1.5};\\n        -webkit-text-stroke-color: $border-color;\\n        -webkit-text-stroke-width: $border-width;\\n        font-size: 12px;\\n        position: absolute;\\n        left: 50%;\\n        top: 50%;\\n        transform: translate(-50%, -235px);\\n\\n        &>span {\\n            position: absolute;\\n            font-size: 4.2em;\\n            font-weight: bolder;\\n            transform-origin: 50% #{$num * .85em};\\n\\n            @for $i from 0 through $num {\\n                &:nth-child(#{$i + 1}) {\\n                    transform: rotate(#{$deg * $i - (floor(math.div($num,2))+0.1) * $deg});\\n                    z-index: #{$num - $i};\\n                    animation: show 0.4s backwards;\\n                    animation-delay: #{$i * $delay + 1500};\\n                }\\n            }\\n\\n            @keyframes show {\\n                0% {\\n                    font-size: 6em;\\n                    filter: blur(0.1em);\\n                    opacity: 0;\\n                }\\n\\n                80% {\\n                    font-size: 3.6em;\\n                    filter: blur(0.001em);\\n                    opacity: 1;\\n                }\\n\\n                100% {\\n                    font-size: 4.2em;\\n                    filter: blur(0);\\n                    opacity: 1;\\n                }\\n            }\\n        }\\n}\\n```\\n\\n通过 `scss` 的 `@for` 去遍历每一个文字，然后设置他们的偏移角度和动画的延迟等，可以轻轻松松完成这个贺词动画。\\n\\n![3.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7074efbe7f7b42a9bf4305179ce89652~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## 结语\\n\\n本篇算是比较基础的带小伙伴们进入web的3d世界的搭建和交互，介绍了一些库的组合与使用，希望各位会喜欢，也希望各位也发挥想象力实现更加惊艳的效果。\\n\\n这是今年的第一篇文章，希望大家多点赞多鼓励，来年争取将更好的作品带来。新的一年，希望大家健健康康，阖家欢乐，兔年大吉。\\n\\n"
    },
    {
        "article_id": "7189648077790117925",
        "cover_image": "",
        "title": "一个vue开发者，初次接触基于schema的react后台管理系统",
        "brief": "入职接手了一个React的后台管理系统，只会点JSX皮毛的我，与schema数据类型的form表单组件的，爱恨情仇。",
        "user_name": "前端迪哥",
        "view_count": 438,
        "collect_count": 1,
        "comment_count": 2,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/18635b1294b45491a0036a48e955be2f~300x300.image",
        "category": "前端",
        "content": "招聘面试vue，入职接手了一个React的后台管理系统，需求是改个表单字段的传值，title改成purchaseTitle。\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/17c7f049957543008cdf6508c172de34~tplv-k3u1fbpfcp-watermark.image?)\\n我心想后台管理能有多难，我vue全家桶都会，React的JSX略知一二，有什么是我搞不定的？\\n我就咔咔一顿，全局搜索，顺着路由找表单页面代码。\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/faf01f4f19fc429290769d19a49f9902~tplv-k3u1fbpfcp-watermark.image?)\\n啊，这，怎么短短几行代码，竟生成了一个表单界面。<br>\\n更诡异的事情是页面中一顿搜索“采购标题”，愣是没找到。\\n这不科学啊。\\n于是，我全局搜索，采购标题，定位到了，一个schema文件。\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/92dea8e20908423a8ba8759af69d9ad8~tplv-k3u1fbpfcp-watermark.image?)\\n我心想不对啊，这写的啥，这个文件我愣是看不懂，这个项目用的不是antd吗？\\n\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0938c21c5484a88934c54f26915484c~tplv-k3u1fbpfcp-watermark.image?)\\n\\n这才是antd该有的样子，input就是input，默认值，回调函数，该有都有啊。<br>\\nantd组件库也没见过这个schema东西。<br>\\n除了中文，这些属性我是一个也看不懂。心想这应该是配置from表单中组件的位置和组件侧边文字的吧。<br>\\n心想上一个写这个项目的大佬，可真牛，组件封装得真好，配置一下就行了，我只是来维护的，膜拜一下。<br>\\n我点击提交按钮，搞清楚表单里返回的title是从哪来的就行了，于是我就不管，直接魔改\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/00c5e36923cf40ae8b5e229b6a618c14~tplv-k3u1fbpfcp-watermark.image?)\\n简直机智如我，赶紧交差。<br>\\n接下来几个维护任务，我都是这样浑水摸鱼。<be>\\n我接到一个增加单选框并设置默认值的任务，\\n    \\n    \\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b058f54d13dc4337bf817fdf4d2c66dd~tplv-k3u1fbpfcp-watermark.image?)\\n    \\n    \\n还是绕不开这个schema文件，百度了一下。<br>\\n这个schema是一种自带数据类型的JSON数据。\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/374d1c7751ba40ee8490ab7b8d27df76~tplv-k3u1fbpfcp-watermark.image?)\\n\\n我就顿悟了所以这个schema就是表单的描述文件。<br>\\n即使项目没有文档，我不能准确了解某些属性的含义，通过这个系统沉淀的这么多代码我照猫画虎，还不行？\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6db693a730f1475cac03ceb5722fe360~tplv-k3u1fbpfcp-watermark.image?)\\n\\n改一改，就成了。<br>\\n> 这个schema非常好用，直接复制粘贴其他页面的form表单schema文件，我就用现成的表单界面，我按照业务需求，改改，就行了。\\n\\n你在表单点击提交的时候，获取相应表单数值，你可以设置默认值，校验形式。<br>\\n但是复杂一点，我的表单项需要联动，显示隐藏，增加一下业务处理，又或者是改个输入项，配置特殊的自定义组件，我就难以下手了。\\n    <br>\\n原谅我能力有限，学了学蹩脚的react函数式组件，使用最简单的antd的from的案例代码，来实现业务。(๑•̀ㅂ•́)و✧\\n    <br>\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/73a3fb23a4ec466a985d5fe940aa0f4e~tplv-k3u1fbpfcp-watermark.image?)\\n"
    },
    {
        "article_id": "7185079118126383141",
        "cover_image": "",
        "title": "高颜值微信小程序 UI 组件库！",
        "brief": "大家好，我是 CUGGZ。 今天来分享 8 个高颜值的微信小程序 UI 组件库，速速收藏！ Vant Weapp Vant 是一个轻量、可靠的移动端组件库，由有赞于 2017 年开源。目前 Vant ",
        "user_name": "CUGGZ",
        "view_count": 8256,
        "collect_count": 122,
        "comment_count": 23,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/61130727b6e6bf9ed813434aeaed8ac3~300x300.image",
        "category": "前端",
        "content": "大家好，我是 CUGGZ。\\n\\n今天来分享 8 个高颜值的微信小程序 UI 组件库，速速收藏！\\n## Vant Weapp\\nVant 是一个轻量、可靠的移动端组件库，由有赞于 2017 年开源。目前 Vant 官方提供了 Vue 2 版本、Vue 3 版本和微信小程序版本，并由社区团队维护 React 版本和支付宝小程序版本。\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e25fa3c9707a4058afae51e8f4c52fa8~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n**Github（⭐️ 16.5k）：**[https://github.com/youzan/vant-weapp](https://github.com/youzan/vant-weapp)\\n## iView Weapp\\niView Weapp 是一套高质量的微信小程序 UI 组件库。\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b3a026e7af144be68a742b6f3c0c0e4d~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n**Github（⭐️ 6.3k）：**[https://github.com/TalkingData/iview-weapp](https://github.com/TalkingData/iview-weapp)\\n## Taro UI\\nTaro UI 是一款基于 Taro 框架开发的多端 UI 组件库。Taro 是由京东凹凸实验室倾力打造的多端开发解决方案。\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cad59770d6ab4a4286aef0106742c329~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n**Github（⭐️ 4.1k）：**[https://github.com/NervJS/taro-ui](https://github.com/NervJS/taro-ui)\\n## Wux Weapp\\nWux Weapp 是一套组件化、可复用、易扩展的微信小程序 UI 组件库。\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5f1ebb234c1845ae9821011a4f59b386~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n**Github（⭐️ 4.8k）：**[https://github.com/wux-weapp/wux-weapp/](https://github.com/wux-weapp/wux-weapp/)\\n## Lin UI\\nLin UI 是一套基于微信小程序原生语法实现的高质量 UI 组件库。遵循简洁、易用、美观的设计规范。\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/04748ae5887d4fdd92f3133b77ad182f~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n**Github（⭐️ 3.7k）：**[https://github.com/TaleLin/lin-ui](https://github.com/TaleLin/lin-ui)\\n## uView\\nuView UI，是uni-app生态优秀的UI框架，全面的组件和便捷的工具会让你信手拈来，如鱼得水。\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b0f7c4ad23c4b968e80b593880ee7a3~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n**Github（⭐️ 3.6k）：**[https://github.com/umicro/uView](https://github.com/umicro/uView)\\n## WeUI\\nWeUI 是一套同微信原生视觉体验一致的基础样式库，由微信官方设计团队为微信内网页和微信小程序量身设计，令用户的使用感知更加统一。包含 button、cell、dialog、 progress、 toast、article、actionsheet、icon 等各式元素。\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b7b69aa2d79346569092fe9878d00171~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n**Github（⭐️ 14.5k）：**[https://github.com/Tencent/weui-wxss](https://github.com/Tencent/weui-wxss)\\n## Touch WX\\nTouch WX是一套完全免费的微信小程序开发框架，包含丰富的UI控件用于官方组件的补充。\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae3db6e19f574b0095c3b0369a5be8ee~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n\\n**Github（⭐️ 805）：**[https://github.com/uileader/touchwx](https://github.com/uileader/touchwx)\\n"
    },
    {
        "article_id": "7167673879693885476",
        "cover_image": "",
        "title": "13个很酷但很少有人知道的HTML元素",
        "brief": "本文正在参加「金石计划 . 瓜分6万现金大奖」 1. meter & progress 元素是显示进度条的语义正确方式。 除了在已知范围内显示标量测量值外，它还允许我们指定值的低，高和最佳范围。 效果",
        "user_name": "海拥",
        "view_count": 5035,
        "collect_count": 308,
        "comment_count": 11,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/27c5a90fca52beadf8a2dc4bc0efb3f8~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: smartblue\\nhighlight: a11y-dark\\n---\\n\\n\\n**本文正在参加[「金石计划 . 瓜分6万现金大奖」](https://juejin.cn/post/7162096952883019783 \\\"https://juejin.cn/post/7162096952883019783\\\")**\\n\\n> - 原文链接：https://dev.to/ruppysuppy/7-cool-html-elements-nobody-uses-330c\\n> https://dev.to/ruppysuppy/6-cool-things-boring-old-html-can-do-3160\\n> - 原文作者：[塔帕约蒂·博斯](https://dev.to/ruppysuppy)\\n\\n## 1. `meter` & `progress`\\n\\n元素是显示进度条的语义正确方式。\\n\\n除了在已知范围内显示标量测量值外，它还允许我们指定值的**低**，**高**和**最佳**范围。\\n\\n\\n```html\\n<meter\\n  min=\\\"0\\\"\\n  max=\\\"100\\\"\\n  low=\\\"25\\\"\\n  high=\\\"75\\\"\\n  optimum=\\\"80\\\"\\n  value=\\\"50\\\"\\n></meter>\\n```\\n\\n效果\\n\\n\\n\\n![4znrursszrxsuiqqmauj.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ca68cd5a3414e01a9cfb4272a392062~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## 2. `sup` & `sub`\\n\\n我们可以在文档中添加**上标**和**下标**。``x²``sup``x₀``sub\\n\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c2f7ad7475114d4d95146a357f561a94~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/16544dc295fa4ab099f11a085cf5506f~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## 3. `datalist`\\n\\n`datalist`允许我们将自动完成建议添加到元素中\\n\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ddd4b744c7dd467299e0def0f1cdaa32~tplv-k3u1fbpfcp-watermark.image?)\\n\\n### 注意\\n\\n1.  建议不仅限于文本，还可以与**颜色**，**日期**，**时间**甚至**范围**输入一起使用。\\n1.  虽然建议的默认样式看起来**很简陋**。但是我们可以使用**CSS**设置其样式。\\n\\n## 4. `map` & `area`\\n\\n`map`并允许我们创建**图像映射**，这是**具有可单击区域图像**的一种使用办法。\\n\\n```\\n<img\\n  src=\\\"workplace.jpg\\\"\\n  alt=\\\"Workplace\\\"\\n  usemap=\\\"#workmap\\\"\\n  width=\\\"400\\\"\\n  height=\\\"379\\\"\\n/>\\n\\n<map name=\\\"workmap\\\">\\n  <area\\n    shape=\\\"rect\\\"\\n    coords=\\\"34,44,270,350\\\"\\n    alt=\\\"Computer\\\"\\n    href=\\\"computer.html\\\"\\n  />\\n  <area\\n    shape=\\\"rect\\\"\\n    coords=\\\"290,172,333,250\\\"\\n    alt=\\\"Phone\\\"\\n    href=\\\"phone.html\\\"\\n  />\\n  <area\\n    shape=\\\"circle\\\"\\n    coords=\\\"337,300,44\\\"\\n    alt=\\\"Cup of coffee\\\"\\n    href=\\\"coffee.html\\\"\\n  />\\n</map>\\n```\\n\\n\\n![uzi08fh85fvfb0ycz9de.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35e5746c50834ae88d2b8fd3efc61107~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## 5. `details` & `summary`\\n\\n`details`并且用于创建**可折叠的内容**，并且无需使用任何**JavaScript**。这是创建**下拉列表**的语义方法。\\n\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eea1133ac3e244f4bbf1a0de544a0f45~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## 6. `object`\\n\\n不知道怎样在你的网站上嵌入文件？不要找了，用`object`吧\\n\\n`object`允许我们嵌入各种文件，如**PDF**，**图像**，**视频**，**音频** 甚至 **视频**。\\n\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/00b9f11275b246638a64dc07071c11da~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## 7. `abbr`\\n\\n该元素允许我们向文档添加**缩写**。当用户将鼠标悬停在**缩写**上时，将显示完整窗体。此外，**屏幕阅读器**还可以配置为在遇到**缩写**时读出完整表格。\\n\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/18cfd2ef572f4755af6b4da70e1d2939~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## 8.预加载和缓存资源 📥\\n\\n想知道如何 **预加载** 和 **缓存资源** 吗？只需要一行代码，你就完成了！\\n\\n\\n```html\\n<link\\n  rel=\\\"preload\\\"\\n  href=\\\"https://example.com/asset.png\\\"\\n  as=\\\"image\\\"\\n/>\\n```\\n\\n## 9.为页面🖼️添加自定义链接预览\\n\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b09e809326f84c7cbc7f3b4e7a6ba394~tplv-k3u1fbpfcp-watermark.image?)\\n\\n对链接预览的生成方式感到疑惑？我们所需要的只是标签！\\n\\n\\n```html\\n<meta property=\\\"og:title\\\" content=\\\"Page title\\\" />\\n<meta\\n  property=\\\"og:description\\\"\\n  content=\\\"Page description\\\"\\n/>\\n<meta\\n  property=\\\"og:image\\\"\\n  content=\\\"https://example.com/asset.png\\\"\\n/>\\n```\\n\\n上面显示的标签使用 Open Graph Protocol（开放图谱协议），你可以使用任何标签生成器为所有其他平台生成标签\\n\\n## 10.重定向到另一个链接↪️\\n\\n将用户重定向到其他链接（通常在付款确认后使用）只需一行代码即可！\\n\\n\\n```html\\n<meta\\n  http-equiv=\\\"refresh\\\"\\n  content=\\\"3; url=https://juejin.cn/\\\"\\n/>\\n```\\n\\n上面的代码将在 3 秒后将用户重定向到 **掘金**。\\n\\n## 11. 拨打电话或邮件 📞\\n\\n需要一个链接来拨打 **电话** 或发送 **邮件**！\\n\\n```html\\n<a href=\\\"tel:+12345678910\\\">Call</a>\\n<a href=\\\"mailto:user@email.com\\\">Mail</a>\\n```\\n\\n## 12. 添加颜色选择器 🎨\\n\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a6f350287bf4476964dda842dd8c780~tplv-k3u1fbpfcp-watermark.image?)\\n\\n想要向您的网站添加 **颜色选择器**？您只需要一行，不需要花哨的 **库** 甚至也不需要 **JavaScript**！\\n\\n```html\\n<input type=\\\"color\\\" />\\n```\\n\\n## 13. 可编辑内容 ✏️\\n\\n只需将属性添加到元素即可使任何内容**可编辑**。\\n\\n\\n```html\\n<p contenteditable=\\\"true\\\">\\n  这是一段可编辑的话\\n</p>\\n```"
    },
    {
        "article_id": "7188151503423537209",
        "cover_image": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/744c3a4f2e2c4e25978bad92332365e0~tplv-k3u1fbpfcp-watermark.image?",
        "title": "2022年 躺平的一年",
        "brief": "人也变得懒惰了，没有了学习的动力，总结文章也不写了，就开始摸鱼、 躺平了。。。2022 过得没有很丰富，除了🐑还是很舒服的，满满的罪恶感，2023 一定要支棱 💪🏻 起来",
        "user_name": "iwhao",
        "view_count": 1557,
        "collect_count": 0,
        "comment_count": 8,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/1caf8fb8a24d26a1223af768d544a320~300x300.image",
        "category": "代码人生",
        "content": "「回顾2022，展望2023，我正在参与[2022年终总结征文大赛活动](https://juejin.cn/post/7172462429929111559 \\\"https://juejin.cn/post/7172462429929111559\\\")」\\n\\n我是2021 年迫于房贷压力来到北京工作，记得刚来的时候对这种快速的生活和工作节奏 特别不适应，经过一年的洗礼，从开始的\\n心余力绌已蜕变成得心应手、游刃有余了，工作是轻松了，但人也变得懒惰了，没有了学习的动力，总结文章也不写了，就开始摸鱼、 躺平了。。。\\n\\n\\n# 搬家\\n刚来北京的时候投靠了大学同学，小两室，四个人，只能睡在一张不到一米宽的 小床上，腿都伸不开，卫生也是难以启齿，蟑螂小强到处爬，交通也不方便，需要挤公交，挤地铁，高峰期的地铁站真是太可怕了，以前还不信，这可算见识到了，不过没办法，奈何囊中羞涩，只能先凑合着，一直到年初，媳妇儿要过来了，在自如上找了一个离公司稍微近一点的房子，算是有了自己的一个小窝，也慢慢置办了一些厨房小电器，开始自己做饭，周末也会找一些景点游玩，这才慢慢找到了生活的感觉，和现在比，以前的我大概只能称为 `活着`\\n\\n\\n离公司近了后真的节省了好多时间，北京工作的小伙伴们应该都深有体会，北京是真的太大了，以至于时间都浪费在路上，现在我的通勤时间 往返 不到一个小时，美滋滋。\\n\\n# 开始了骑行\\n|  |  |\\n| --- | --- |\\n| <img src=\\\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b4627a258e294499a91b830fed5d9be0~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"WechatIMG539.jpeg\\\"  /> | <img src=\\\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/437a47882fe4486c8aed86789d35cd94~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"mmexport1662968272655.jpg\\\" width=\\\"80%\\\"/> |\\n| <img src=\\\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bcb012e77ab741b7b42bc266a59ac647~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"mmexport1662968269494.jpg\\\"/> | <img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/491c30ae835a4c1b8e9c51bdeebe2729~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"IMG_20220911_193817.jpg\\\" width=\\\"90%\\\" /> |\\n\\n租的房子离公司六公里左右，由于离着地铁站不是很近，公交走路也不方便，搞了辆喜德盛的 山地车，时间自由了，再也不用等公交，挤地铁了，从七月份一直骑到到12月份，除了雨天，九点半上班 九点才出门，妥妥的舒服，最重要的 满足通勤需求的同时还顺便锻炼了身体，程序员这职业，一天到晚坐在电脑前，还真没啥机会锻炼，往常我就经常会头疼，但从骑行开始后，这个毛病有所改观，身体感觉也比之前更有活力，去年打榜掘金给的手环也派上了用场，有骑行记录功能，每日打卡妥妥的成就感，期间还和同事一起约着夜骑了长安街，看了晚上的天安门，不一样的心情，来回40多公里，也算是一次不小的挑战。\\n\\n\\n\\n# 软羊羊、沸羊羊、哑羊羊\\n自从 北京放开不检查核酸后，公司陆续有人中招，正当庆幸我和周边工位都没事的时候，在一个月黑风高的夜晚，没有任何征兆，它就是这么突然悄无声息无情的打击了我，当晚没有任何症状，到第二天早上四五点钟的时候，就头疼的难受醒了，一测体温37度多，我媳妇儿也一样，还好我们有备用药品，到八九点的时候在测体温就烧到了38多，吃了颗布洛芬就继续睡觉，但浑身疼的根本睡不着，发烧症状持续了三天，期间最高到39.4，后面虽然退烧了，但是却开始了无穷无尽的咳嗽和咽痛，直到现在写这篇总结的时候还会时不时的咳嗽两声，唉，这病毒真是挺厉害的，希望没🐑的小伙伴们做好防护，但愿2023年能结束这该死的疫情，还人们一个自由的生活。\\n# DIY了一个工 (游) 作 (戏) 生 (娱) 产 (乐) 主机\\n\\n|  |  |\\n| --- | --- |\\n| <img src=\\\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/64c18192a866404c93a4ffa0046bd9c3~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"WechatIMG543.jpeg\\\" width=\\\"80%\\\" /> | ![WechatIMG540.jpeg](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0891fcd449a844a795f9e786c3e05cc7~tplv-k3u1fbpfcp-watermark.image?) |\\n\\n\\n\\n![WechatIMG542.jpeg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6bf9d74f179c4f91a700a04eb58981ab~tplv-k3u1fbpfcp-watermark.image?)\\n自己买配件 DIY了个 主机 ，还好 一次点亮，没有遇到 爆炸，懂得小伙伴看到配置可能会有疑问，都有独立显卡了，为啥还买带核显的cpu，原因是 媳妇儿给的预算不够，所以开始的时候并没有考虑独立显卡，所以才选择带核显的cpu，不过后续也上了款入门级别的显卡，用了个小套路，就是带媳妇儿 玩了双人成行，她迷上了，但电脑没显卡 画面很卡顿，于是才同意，唉 结了婚的男人就是难呀o(╥﹏╥)o\\n\\n\\n推荐配件单\\n- 主板 华硕TUF b660\\n- 显卡 华硕TUF RX6500xt\\n- cpu i3 12100 散片\\n- 固态（很早买的 1T 西数）\\n- 内存 金百达 8Gx2 ddr4-3200\\n- 电源 鑫谷 500W 全模组\\n- 显示器 创维F24G3\\n- 机箱 航嘉\\n- cpu散热器 乔思伯CR1400 四散热管\\n- 手柄 盖世小鸡\\n\\n\\n\\n2022 过得没有很丰富，除了🐑还是很舒服的，满满的罪恶感，2023 一定要支棱 💪🏻 起来\\n\\n\\n![bc55adb5bea849508b7f8d9c6118d9c3.jpeg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ef3fc77a12743abaac8a908fa181ff3~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n\\n\\n\\n"
    },
    {
        "article_id": "7189222825570336829",
        "cover_image": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09e2c38d60ed4515879f6ce966c47a4f~tplv-k3u1fbpfcp-watermark.image?",
        "title": "国产工具好强大-一个可以允许小程序运行在任意APP的容器技术",
        "brief": "小程序的定义 提到小程序，大多数第一眼恐怕想到的就是微信小程序或者是支付宝小程序，这也是因为微信和支付宝两者的用户基量大，很多人都是从使用微信或者支付宝开始知道小程序的，也正因为如此，小程序才被特指微",
        "user_name": "夕水",
        "view_count": 2300,
        "collect_count": 11,
        "comment_count": 2,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/d8e5f941d4d4257826ba832f47cfd14f~300x300.image",
        "category": "阅读",
        "content": "## 小程序的定义\\n\\n提到小程序，大多数第一眼恐怕想到的就是微信小程序或者是支付宝小程序，这也是因为微信和支付宝两者的用户基量大，很多人都是从使用微信或者支付宝开始知道小程序的，也正因为如此，小程序才被特指微信小程序或者是支付宝小程序。\\n\\n也因此很多人一听到小程序下意识的就会认为是指微信小程序或者是支付宝，可事实上，小程序是一个广泛的概念，并不特指某一个代表，微信小程序或者是支付宝小程序都只能算作是小程序的一个代表。\\n\\n在这里个人理解小程序应该指的是一种轻应用，可以不需要下载并且安装就可以在app内运行的轻应用，小程序体现了用完即走的理念，也实现了用户触手可及的梦想，用户只需要扫一下或者是搜一下就可以访问小程序，因此用户也不用担心安装小程序就相当于是安装一个app一样，小程序真正做到了随处可用。\\n\\n## 小程序的接入\\n\\n小程序既然这么强大，那么是不是除了微信，支付宝这些大型的APP才具备运行小程序的能力呢？\\n\\n答案当然不是。虽然相关互联网大厂并没有将这些小程序的运行能力给开放出来，但是我们依然可以借助于一些技术来实现小程序的运行，这种运行能力我们也称之为小程序容器技术。\\n\\n下面我们来看一下一款比较热门的小程序容器技术——[FinClip](https://www.finclip.com/)，如下是官网的一个介绍视频。\\n\\n<video id=\\\"video\\\" onplay=\\\"videoPlay()\\\" preload=\\\"none\\\" controls=\\\"controls\\\" width=\\\"100%\\\" poster=\\\"https://public-1251849568.cos.ap-guangzhou.myqcloud.com/homeSite/picture/intro-cover.jpg\\\" src=\\\"https://public-1251849568.cos.ap-guangzhou.myqcloud.com/homeSite/video/finclipv5.mp4\\\"></video>\\n\\n简单来说，不论是移动 App，还是电脑、电视、车载主机等设备，在集成[FinClip](https://www.finclip.com/)小程序 SDK之后，都能快速获得运行小程序的能力，这就是[FinClip](https://www.finclip.com/)的能力。\\n\\n[FinClip](https://www.finclip.com/)是由凡泰极客公司推出的小程序容器技术，一个可以让任何 APP 都能具备小程序运行能力的前端容器技术，只需简单集成 [FinClip](https://www.finclip.com/)SDK ,即可在 iPhone、Android、Windows、Linux、macOS、统信等平台下的应用中运行你的小程序，这意味着，移动端、PC 端、车载设备、智能电视、智能手表都能运行小程序了。同时，它还提供一个后台管理系统，统一管理小程序的上架和下架。\\n\\n## [FinClip](https://www.finclip.com/)的优势\\n\\n[FinClip](https://www.finclip.com/)小程序容器技术主要有如下几点优势:\\n\\n* 多平台终端的兼容： 该技术自带终端小程序SDK，简单集成了之后就可以在 iPhone，Android，Windows，Linux，macOS等平台下运行你的小程序。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b241aba399b64ac1b4d618003e89d363~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n* 开发体验好: [FinClip](https://www.finclip.com/)针对小程序的开发语法，SDK的体积大小以及开发者工具都进行了相应的设计优化，每个平台中的小程序 SDK 都分为核心与拓展两部分，开发者可根据业务场景灵活选用，并且移动 App 在集成核心 SDK 后的打包体积不超过3 MB。\\n\\n* 学习门槛低: [FinClip](https://www.finclip.com/)兼容小程序语法，开发者不需要学习新的小程序语言，就可以在集成了[FinClip](https://www.finclip.com/)小程序 SDK的APP中运行，换句话说，你只要在你的APP中集成了[FinClip](https://www.finclip.com/)的SDK，你就可以使用你熟悉的开发语言来运行你的小程序。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc2fdcb7ab51474ba11242d7ca2bb605~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n* [FinClip](https://www.finclip.com/)的生态能力很强，应用场景也很广泛： [FinClip](https://www.finclip.com/)已经落地银行证券、社交 IM、政务民生、传媒教育、文化娱乐、生活服务等多个行业，开发者可以根据已有 App 的开发语言，选择 iOS，Android，Flutter，React Native，uni-app 中的小程序 SDK。\\n\\n* [FinClip](https://www.finclip.com/)也提供了自己的IDE：[FIDE](https://www.finclip.com/mop/document/develop/developer/fide-guide.html#_1-fide-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8)。该编辑器的界面与微信小程序的开发工具类似，自带调试和真机预览，简单易上手，同时支持小程序生成 APP，可以将已有小程序代码导出为 IOS 与 Android 中可用的工程文件（也是近期开发者最喜欢的功能）\\n\\n## [FinClip](https://www.finclip.com/)的开发\\n\\n通过官方提供的一些[demo](https://github.com/finogeeks/miniprogram-demo)，我们可以很快速的熟悉FinClip的开发，并且能够自己独立搭建一个小程序工程，赶快来试试吧。\\n\\n## 总结\\n\\n我们可以通过如下流程图来熟悉[FinClip](https://www.finclip.com/)容器技术:\\n\\n![FinClip.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eface41b12d14b0b9c3228cd730361be~tplv-k3u1fbpfcp-watermark.image?)\\n\\n[FinClip](https://www.finclip.com/)现在支持多种使用与部署方案，SaaS/私有化都可以，真正的开箱即用，而且 SaaS 版，每月拥有 10,000 次免费发布调用，感兴趣的朋友可以尝试体验一下。"
    },
    {
        "article_id": "7070809037398343717",
        "cover_image": "",
        "title": "字节一面，面试官问我Vue3源码，我说……",
        "brief": "“哥，我面试字节挂了！” 小明哭丧着脸：“MD，太卷了！这 Vue3 刚转正没多久，面试官就问上我原理了，什么 reactivity 实现原理，proxy ，Vue3初始化的流程，编译优化，diff ",
        "user_name": "阿崔cxr",
        "view_count": 179625,
        "collect_count": 3536,
        "comment_count": 324,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/e86084945cb7947ca2a0711748acffd9~300x300.image",
        "category": "前端",
        "content": "“哥，我面试字节挂了！”\\n\\n小明哭丧着脸：“MD，太卷了！这 Vue3 刚转正没多久，面试官就问上我原理了，什么 **reactivity 实现原理，proxy ，Vue3初始化的流程，编译优化，diff 算法的实现**……直接一面就挂了！”\\n\\n“面试问原理正常呀， 虽然 Vue3 刚转正，但已经发版很久了呀，你不会没关注吧？ ”\\n\\n小明抓了抓头发：“关注是关注了， 但源码看不懂呀 ，那一个 renderer.ts 文件就 2000 多行代码，这怎么看呀？”。\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/75fe1d3798df49d3b71725b1a0e9b9a2~tplv-k3u1fbpfcp-watermark.image?)\\n\\n“源码是难，**但如果你想面大厂拿高工资，源码是绕不过的呀**。面试官通过问你源码，一下子就能知道你是不是一个爱学习爱钻研的同学，还有呀，那 Vue3 项目那么大，处理的工程问题也要比我们平时做的项目复杂不知多少倍了，**看看人家解决问题的思路和方式，也是非常受益的**。“\\n\\n“哥，源码重要性我知道，关键是看不懂……你那有没有好的 Vue3 源码学习资料呀 ，赶紧给老弟推荐推荐~”  \\n\\n“你别说，还真让你赶上了，最近 github 上有一个库叫做 **mini-vue** , 用它来学习 Vue3 源码可以把难度降到最低。\\n\\n“mini-vue 这个库主要特点是把 **Vue3 源码中最核心的逻辑剥离出来，只留下核心逻辑** **，** 而且带有**详细的中文注释以及完善的输出**，可以帮助你快速理解框架核心运行流程。”\\n\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2508438adf464c72867e81f26ed9be28~tplv-k3u1fbpfcp-watermark.image?)\\n\\n> 注释说明了逻辑处理的 case 是什么,非常清晰 (图片截取自mini-vue)\\n\\n“哇塞，还有中文注释呢，真是太贴心了，毕竟我这英文确实不咋地哈哈！”\\n\\n“你再跑一下库的 example 看看， 就那个 helloworld ，然后看看控制台的输出。“\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2a1e30ea2744a73bf77e3720504d82e~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\\"这些输出是什么？等等， 难道说是程序执行的流程节点？\\\"\\n\\n“没错，就是程序执行的流程， **基于这个输出日志，你就能知道实例化一个组件的流程是什么**了， 有助于你理解整个框架的执行流程， 先建立一个整体认知。”\\n\\n“而且你看看输出的右侧，你可以**直接点击跳转到对应的代码上**，然后就可以开开心心打上断点，好好琢磨这代码的实现了。”\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6964953a5473459d84c3c889bacc4bba~tplv-k3u1fbpfcp-watermark.image?)\\n\\n“真是绝了， 怪不得这个库现在已经拿到 4.4k 的 star 了”\\n\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e7bc541485e34ee087f701a31ebd654a~tplv-k3u1fbpfcp-watermark.image?)\\n\\n“还不只如此呢，再给你看个绝活，mini-vue 库里面的代码实现是和 Vue3 源码里面的实现**保持高度一致**的，比如说函数的命名吧，你看这个 diff 算法函数是 patchKeyedChildren 吧”\\n\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63e40c8346c149bbb15a0904a72aa57a~tplv-k3u1fbpfcp-watermark.image?)\\n\\n当你看完简单版的实现后，想看看源码里面是如何实现的， 你只需要复制这个函数名，然后跑到 Vue3 里面搜索一下就可以了。\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f1cc85e7cafe4d8f98a342a6a2a832f8~tplv-k3u1fbpfcp-watermark.image?)\\n\\n“我草，这个绝了，我**看完简单版本之后，再去看源码的话，难度就降低很多了呀！** ”\\n\\n“哈哈哈，是的，这个其实也符合学习模型，如果你一上来就看特别复杂的，对你来讲就到了学习的恐慌区了，**很多同学就是被吓的，一看代码量那么大，逻辑那么复杂，直接就放弃了。而学习 mini-vue 这个库就是简单模式，** 我再跟你说说 mini-vue 是基于什么思想做出来的吧  你以后也可以按照它的方式来实现你自己的 mini-react、mini-webpack、mini-rollup 。”\\n\\n“真的是迫不及待了，哥你赶快坐下，我这就给你买罐红牛去，好好给我上一课~哈哈”\\n\\n我喝了一口刚刚从冰箱拿出来的冰镇红牛，翘着二郎腿缓缓说道：“看你今天这么好学的份上，我再给你唠叨几句。像 Vue3 这么大的工程项目，它会做很多事，比如给开发环境下的用户良好的错误提示↓”\\n\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f2215f4413046ad918f7b22f6569702~tplv-k3u1fbpfcp-watermark.image?)\\n\\n“你看这个，这里是在处理 HMR （热更新）↓”\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4669cbe9d7d04ad2bed5831a42d60b0a~tplv-k3u1fbpfcp-watermark.image?)\\n\\n“而这些逻辑在你刚刚看源码的时候是不需要关心的，但是这部分的逻辑对于你这个新手来讲**非常不好区分**，我给你画个图你感受感受”\\n\\n“哈哈哈，哥你可真是灵魂画手呀，这尼玛画的这么抽象，不过我看明白了。你是指**红色的方块是核心逻辑，而紫色的圆圈都是非核心的吧，比如错误提示和HMR**”\\n\\n“哈哈哈，看来我的画功还是不错的，你一下就明白了，就是这个道理。而我们学习源码的时候第一步就是先摸清这个核心逻辑，这个也称之为 **happy path**， 相当于一棵大树的树干。把这个拿下后，后面我们就可以自己看了，代码逻辑里面无非就是处理各种各样的 edge case（边缘情况）。你有没有发现，其实**这是对 Vue3 框架做了功能上的拆分**。”\\n\\n“我擦，又学到了，我已经感受到了，**把 Vue3 整体拆分变小，然后这样难度就直线下降了**，而我们再把 **happy path** 理解透彻，这一步学完之后再去理解那些 HMR 或者错误提示的逻辑，也会变得更简单。”\\n\\n“对的，这个就是**任务拆分**的思想，你可以横着切，也可以纵着切，想怎么切就怎么切，如果从算法思想的角度来讲的话就是……”\\n\\n“就是**分而治之**的思想！” 小明赶紧把他知道的名词抢先回答出来，生怕别人不知道他学过算法。\\n\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2cbdff6a7c684fec879cfab686e6138a~tplv-k3u1fbpfcp-watermark.image?)\\n\\n“哎呀，可以呀小明，看来你算法学得不错嘛。所以这个 mini-vue 库对于想学习源码的同学来讲非常有意义，现在作者已经完成了三大模块的编写了。”\\n\\n“噢？三大模块是啥？我这还真不知道”\\n\\n“三大模块是指 **reactivity（响应式模块）、runtime-core（运行时模块）、compiler（编译模块）** ， Vue3 的核心就是这三大模块。现在 Vue3 的源码是采用 monorepo 的形式， 分了好多模块，不过对于你这初学者来讲，**研究透三大模块就够你面试用了**”\\n\\n\\\"哦了哦了，我这就去把 mini-vue clone 下来好好学习学习，回头面试的时候争取搞定面试官！哥，那我学习 mini-vue 遇见问题的话可还得麻烦你呀，哈哈哈~\\\"\\n\\n“你可以直接加 mini-vue 作者的微信: **cuixr1314**，我们都叫他**大崔哥**。有问题直接问他就好了嘛 ，我有问题也是直接问他， 关于 mini-vue 上的问题他会回答你的，放心好了”\\n\\n\\\"我这就赶紧加上大崔哥哈哈哈~开心\\"
    },
    {
        "article_id": "7152404093632249893",
        "cover_image": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/adacad17066346bf96cc011610c975bb~tplv-k3u1fbpfcp-watermark.image?",
        "title": "啥,要我前端去对接外部?我也不会呀",
        "brief": "我正在参加「掘金·启航计划」 一般来说，现在公司的业务都是后端去对接外部官方接口。但是现在加个紧急需求，往我这丢了几个对接文档，让前端去对接，我内心也是打咩。",
        "user_name": "小杨不睡了",
        "view_count": 8413,
        "collect_count": 129,
        "comment_count": 13,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/df428c807d0a62df0df7c42173136d3f~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: smartblue\\n---\\n我正在参加「掘金·启航计划」\\n> 一般来说，现在公司的业务都是后端去对接外部官方接口。但是现在加个紧急需求，往我这丢了几个对接文档，让前端去对接，我内心也是打咩。\\n\\n### 一、梳理开发对接流程\\n1. 大概预览一遍对接文档，发现是需要引入外部提供给的js文件，然后再调用特定方法名通过jsonp的形式与外部联调。\\n2. 因为调用特定方法需要提供域名给对方备案，这样才能权限调起接口。业务这边上报了几个域名给对方，但是问题来了，本地要这么联调呢？ 我%x#！@#&*，我也没做过哇，只能查资料开始准备工作。\\n\\n### 二、准备工作\\n#### 1. 首先需要将本地的访问都修改伪装成报备的域名。那要怎么做呢？了解修改hots文件就可以实现，那么开始动手。\\n1.1 首先找到hots文件，windows它路径一般是在C:\\\\Windows\\\\System32\\\\drivers\\\\etc，如下图\\n![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c7a55176dbde48748cae959e781eb0c3~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n\\n1.2 打开hots文件，添加解析。把本地访问指向后面报备的域名。（域名可以不用加协议，我这里报备的是https的域名）\\n\\n![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/848d197a1f53419ca648fb811b3172f6~tplv-k3u1fbpfcp-zoom-1.image)\\n#### 2. 运行项目。\\n2.1 一开始只在vue.config.js配置了端口，在通过命令跑起项目\\n```javascript\\nmodule.exports = {\\n  devServer: {\\n    port: 9012,\\n  },\\n}\\n```\\n\\n![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d38899fb94a347389019a569d674218f~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n2.2 复制ip链接，浏览器打开，会出现资源加载不到的问题\\n\\n![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1cdfcd8a99924deb9b293d06b10e8a0f~tplv-k3u1fbpfcp-zoom-1.image)\\n2.3  替换成配置hots里面的域名，会发现项目无法运行\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f990c3fc02974acc8aa47e4d50853548~tplv-k3u1fbpfcp-watermark.image?)\\n想起来报备配置的域名是https，所以vue.config.js里面随便写的port端号号是不行的，因为https默认端口号是443。\\n2.4 修改端口号为443，并且开启https服务，重跑项目\\n```javascript\\nmodule.exports = {\\n  devServer: {\\n    https: true,\\n    port: 443,\\n  },\\n}\\n```\\n出现以下提示，点击立即前往就行\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/455985a96a0f4779b809e601be4bdfa7~tplv-k3u1fbpfcp-watermark.image?)\\n2.5 进入页面却又会提示以下错误，搜索发现可以配置vue.config.js解决\\n\\n![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33314fa1e7ac404d83e2b59981b7f958~tplv-k3u1fbpfcp-zoom-1.image)\\n添加配置\\n\\n```javascript\\nmodule.exports = {\\n  devServer: {\\n    https: true,\\n    port: 443,\\n    disableHostCheck: true,\\n  },\\n}\\n```\\n> 如果上面这种方案不行可以替换成下面这种：\\n> 在webpack 5 中disableHostCheck应该被遗弃了\\n查看文档了解到需将 disableHostCheck:true\\n替换为\\nhistoryApiFallback: true,\\nallowedHosts: “all”,\\n```javascript\\nmodule.exports = {\\n  devServer: {\\n    https: true,\\n    port: 443,\\n    historyApiFallback: true,\\n    allowedHosts: \\\"all\\\",\\n  },\\n}\\n```\\n2.6 重跑项目,发现已经是可以进入页面了\\n![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8d2f42579dd43ae9940614c3da8b968~tplv-k3u1fbpfcp-zoom-1.image)\\n#### 3.开始对接\\n3.1 在idnex.html引入文档提供的外部js\\n\\n![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/694b2c651d5a46569d8ad3ee5b0e2dd3~tplv-k3u1fbpfcp-zoom-1.image)\\n3.2 打开控制台发现以下错误\\n\\n![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1274922b8fbe47079416ebf29bb137b9~tplv-k3u1fbpfcp-zoom-1.image)\\n>搜索了解到:https地址中，如果加载了http资源，浏览器将认为这是不安全的资源，将会默认阻止，这就会给你带来资源不全的问题了，比如：图片显示不了，样式加载不了，JS加载不了。\\n>\\n**解决**:. 在index.html页面中加入（meta）头中添加upgrade-insecure-requests\\n```javascript\\n<meta http-equiv=\\\"Content-Security-Policy\\\" content=\\\"upgrade-insecure-requests\\\">\\n```\\n3.3 刷新页面,会发现调用特定方法成功\\n\\n![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bcd0441273d04a749bd2f28964fa208b~tplv-k3u1fbpfcp-zoom-1.image)\\n#### 4. 到此就可以开始写页面对接其他接口了。\\n\\n \\n"
    },
    {
        "article_id": "7166013766105038884",
        "cover_image": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce1a3c9c7bb440cabe972a70c34cee74~tplv-k3u1fbpfcp-watermark.image?",
        "title": "Node.js v19，它来了！详解 6 大特性",
        "brief": "Node.js 14 将在 2023 年 4 月结束更新维护，Node.js 16 (LTS) 预计将在 2023 年 9 月结束更新维护。",
        "user_name": "掘金安东尼",
        "view_count": 16899,
        "collect_count": 63,
        "comment_count": 29,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/4fdb253f3b5bb8d9e875e3dcabea82cb~300x300.image",
        "category": "前端",
        "content": "通译自：[6 Major Features of Node.js 19. Details of Node.js 19 new features… | by Jennifer Fu | Oct, 2022 | Better Programming](https://betterprogramming.pub/6-major-features-of-node-js-19-b98e28b9670c)\\n\\n<hr>\\n\\nNode 19 在 2022-10-18 发布。\\n\\n我们知道 Node.js 版本分两种：LTS 和 Current\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e1a337f186644768dfdb9da7a5c4503~tplv-k3u1fbpfcp-watermark.image?)\\n\\n其中，Current 版本通常每 6 个月发布一次。\\n\\n每年 4 月份发布新的偶数版本；\\n\\n每年 10 月份发布新的奇数版本；\\n\\n在刚过去的 10 月，发布的 V19.0.1 成为最新的 “Current” 尝鲜版，它一共带来 6 大特性。\\n\\n## 1. HTTP(S)/1.1 KeepAlive 默认为 true\\n\\nNode.js v19 设置 keepAlive 默认值为 true，这意味着所有出站的 HTTP(s) 连接都将使用 HTTP 1.1 keepAlive，默认时间为 5S；\\n\\n代码测试：\\n```\\nconst http = require('node:http');\\nconsole.log(http.globalAgent);\\nconst https = require('node:https');\\nconsole.log(https.globalAgent);\\n```\\n我们可以对比看看 v16 和 v19 的 node server Agent 配置差异：\\n\\n* V16\\n```\\n% nvm use 16\\nNow using node v16.0.0 (npm v7.10.0)\\n% node server\\nAgent {\\n  _events: [Object: null prototype] {\\n    free: [Function (anonymous)],\\n    newListener: [Function: maybeEnableKeylog]\\n  },\\n  _eventsCount: 2,\\n  _maxListeners: undefined,\\n  defaultPort: 80,\\n  protocol: 'http:',\\n  options: [Object: null prototype] { path: null },\\n  requests: [Object: null prototype] {},\\n  sockets: [Object: null prototype] {},\\n  freeSockets: [Object: null prototype] {},\\n  keepAliveMsecs: 1000,\\n  keepAlive : false,\\n  maxSockets: Infinity,\\n  maxFreeSockets: 256,\\n  scheduling: 'lifo',\\n  maxTotalSockets: Infinity,\\n  totalSocketCount: 0,\\n  [Symbol(kCapture)]: false\\n}\\nAgent {\\n  _events: [Object: null prototype] {\\n    free: [Function (anonymous)],\\n    newListener: [Function: maybeEnableKeylog]\\n  },\\n  _eventsCount: 2,\\n  _maxListeners: undefined,\\n  defaultPort: 443,\\n  protocol: 'https:',\\n  options: [Object: null prototype] { path: null },\\n  requests: [Object: null prototype] {},\\n  sockets: [Object: null prototype] {},\\n  freeSockets: [Object: null prototype] {},\\n  keepAliveMsecs: 1000,\\n  keepAlive: false,\\n  maxSockets: Infinity,\\n  maxFreeSockets: 256,\\n  scheduling: 'lifo',\\n  maxTotalSockets: Infinity,\\n  totalSocketCount: 0,\\n  maxCachedSessions: 100,\\n  _sessionCache: { map: {}, list: [] },\\n  [Symbol(kCapture)]: false\\n}\\n```\\n第 18、40 行，keepAlive 默认设置为 false；\\n\\n* V19\\n```\\n% nvm use 19\\nNow using node v19.0.0 (npm v8.19.2)\\n% node server\\nAgent {\\n  _events: [Object: null prototype] {\\n    free: [Function (anonymous)],\\n    newListener: [Function: maybeEnableKeylog]\\n  },\\n  _eventsCount: 2,\\n  _maxListeners: undefined,\\n  defaultPort: 80,\\n  protocol: 'http:',\\n  options: [Object: null prototype] {\\n    keepAlive: true,\\n    scheduling: 'lifo',\\n    timeout: 5000,\\n    noDelay: true,\\n    path: null\\n  },\\n  requests: [Object: null prototype] {},\\n  sockets: [Object: null prototype] {},\\n  freeSockets: [Object: null prototype] {},\\n  keepAliveMsecs: 1000,\\n  keepAlive: true,\\n  maxSockets: Infinity,\\n  maxFreeSockets: 256,\\n  scheduling: 'lifo',\\n  maxTotalSockets: Infinity,\\n  totalSocketCount: 0,\\n  [Symbol(kCapture)]: false\\n}\\nAgent {\\n  _events: [Object: null prototype] {\\n    free: [Function (anonymous)],\\n    newListener: [Function: maybeEnableKeylog]\\n  },\\n  _eventsCount: 2,\\n  _maxListeners: undefined,\\n  defaultPort: 443,\\n  protocol: 'https:',\\n  options: [Object: null prototype] {\\n    keepAlive: true,\\n    scheduling: 'lifo',\\n    timeout: 5000,\\n    noDelay: true,\\n    path: null\\n  },\\n  requests: [Object: null prototype] {},\\n  sockets: [Object: null prototype] {},\\n  freeSockets: [Object: null prototype] {},\\n  keepAliveMsecs: 1000,\\n  keepAlive: true,\\n  maxSockets: Infinity,\\n  maxFreeSockets: 256,\\n  scheduling: 'lifo',\\n  maxTotalSockets: Infinity,\\n  totalSocketCount: 0,\\n  maxCachedSessions: 100,\\n  _sessionCache: { map: {}, list: [] },\\n  [Symbol(kCapture)]: false\\n}\\n```\\n第 14、16、42、44 行设置 keepAlive 默认值及时间；\\n\\n启用 keepAlive 能使连接重用，提高网络的吞吐量。\\n\\n另外，服务器将在调用 `close()` 自动断开空闲的客户端，内部依靠 `http(s).Server.close` API 实现；\\n\\n这些修改，进一步优化了体验和性能。\\n\\n## 2. 稳定的 WebCrypto API\\n\\nWebCrypto API 是一个使用密码学构建的系统接口，在 node.js v19 趋于稳定（除 Ed25519、Ed448、X25519、X448 外）。\\n\\n我们可以通过调用 `globalThis.crypto` 或 `require('node:crypto').webcrypto` 来访问，下面以 `subtle` 加密函数为例；\\n\\n```\\n\\nconst { subtle } = globalThis.crypto;\\n\\n(async function() {\\n\\n  const key = await subtle.generateKey({\\n    name: 'HMAC',\\n    hash: 'SHA-256',\\n    length: 256\\n  }, true, ['sign', 'verify']);\\n\\n  console.log('key =', key);\\n\\n  const enc = new TextEncoder();\\n  const message = enc.encode('I love cupcakes');\\n\\n  console.log('message =', message);\\n\\n  const digest = await subtle.sign({\\n    name: 'HMAC'\\n  }, key, message);\\n\\n  console.log('digest =', digest);\\n\\n})();\\n```\\n首先生成 HMAC 密钥，生成的密钥可同时用于验证消息数据完整性和真实性；\\n\\n然后，对字符串 `I love cupcakes` 加密；\\n\\n最后创建 消息摘要，它是一种加密散列函数；\\n\\n在控制台显示：key 、message 、digest 信息\\n```\\n% node server\\nkey = CryptoKey {\\n  type: 'secret',\\n  extractable: true,\\n  algorithm: { name: 'HMAC', length: 256, hash: [Object] },\\n  usages: [ 'sign', 'verify' ]\\n}\\nmessage = Uint8Array(15) [\\n   73, 32, 108, 111, 118,\\n  101, 32,  99, 117, 112,\\n   99, 97, 107, 101, 115\\n]\\ndigest = ArrayBuffer {\\n  [Uint8Contents]: <30 01 7a 5c d9 e2 82 55 6b 55 90 4f 1d de 36 d7 89 dd fb fb 1a 9e a0 cc 5d d8 49 13 38 2f d1 bc>,\\n  byteLength: 32\\n}\\n```\\n\\n## 3. 自定义 ESM resolution 调整\\n\\nNode.js 已经删除 `--experimental-specifier-resolution `，其功能现在可以通过自定义加载器实现。\\n\\n可以在这个库中测试：[nodejs/loaders-test: Examples demonstrating the Node.js ECMAScript Modules Loaders API](https://github.com/nodejs/loaders-test)\\n\\n```\\ngit clone https://github.com/nodejs/loaders-test.git\\n\\n% cd loaders-test/commonjs-extension-resolution-loader\\n\\n% yarn install\\n```\\n\\n比如 `loaders-test/commonjs-extension-resolution-loader/test/basic-fixtures/index.js ` 文件：\\n\\n```\\nimport { version } from 'process';\\n\\nimport { valueInFile } from './file';\\nimport { valueInFolderIndex } from './folder';\\n\\nconsole.log(valueInFile);\\nconsole.log(valueInFolderIndex);\\n```\\n\\n`./file` 如果没有自定义加载器，不会去查找文件的扩展名，比如 `./file.js` 或 `./file.mjs`\\n\\n\\n设置自定义加载器后，则可解决上述问题：\\n\\n```\\nimport { isBuiltin } from 'node:module';\\nimport { dirname } from 'node:path';\\nimport { cwd } from 'node:process';\\nimport { fileURLToPath, pathToFileURL } from 'node:url';\\nimport { promisify } from 'node:util';\\n\\nimport resolveCallback from 'resolve/async.js';\\n\\nconst resolveAsync = promisify(resolveCallback);\\n\\nconst baseURL = pathToFileURL(cwd() + '/').href;\\n\\n\\nexport async function resolve(specifier, context, next) {\\n  const { parentURL = baseURL } = context;\\n\\n  if (isBuiltin(specifier)) {\\n    return next(specifier, context);\\n  }\\n\\n  // `resolveAsync` works with paths, not URLs\\n  if (specifier.startsWith('file://')) {\\n    specifier = fileURLToPath(specifier);\\n  }\\n  const parentPath = fileURLToPath(parentURL);\\n\\n  let url;\\n  try {\\n    const resolution = await resolveAsync(specifier, {\\n      basedir: dirname(parentPath),\\n      // For whatever reason, --experimental-specifier-resolution=node doesn't search for .mjs extensions\\n      // but it does search for index.mjs files within directories\\n      extensions: ['.js', '.json', '.node', '.mjs'],\\n    });\\n    url = pathToFileURL(resolution).href;\\n  } catch (error) {\\n    if (error.code === 'MODULE_NOT_FOUND') {\\n      // Match Node's error code\\n      error.code = 'ERR_MODULE_NOT_FOUND';\\n    }\\n    throw error;\\n  }\\n\\n  return next(url, context);\\n}\\n```\\n测试命令：\\n```\\n% node --loader=./loader.js test/basic-fixtures/index  \\n(node:56149) ExperimentalWarning: Custom ESM Loaders is an experimental feature. This feature could change at any time\\n(Use `node --trace-warnings ...` to show where the warning was created)\\nhello from file.js\\n```\\n将不会再报错，正常运行。\\n\\n## 4. 移除对 DTrace/SystemTap/ETW 支持\\n\\n在 Node.js v19中，移除了对 DTrace/SystemTap/ETW 的支持，主要是因为资源的优先级问题。\\n\\n数据表明很少人用到 DTrace、SystemTap 或 ETW，维护它们没有多大的意义。\\n\\n如果你想恢复使用，可提 issues => https://github.com/nodejs/node/issues/44550\\n\\n## 5. 升级 V8 引擎至 10.7\\n\\nNode.js v19 将 V8 JavaScript 引擎更新至 V8 10.7，其中包含一个新函数 Intl.NumberFormat，用于格式化敏感数字。\\n\\n```\\nIntl.NumberFormat(locales, options)\\n```\\n\\n对于不同的语言，传入不同的 locales：\\n\\n```\\nconst number = 123456.789;\\n\\nconsole.log(new Intl.NumberFormat('de-DE', { style: 'currency', currency: 'EUR' }).format(number));\\nconsole.log(new Intl.NumberFormat('ja-JP', { style: 'currency', currency: 'JPY' }).format(number));\\nconsole.log(new Intl.NumberFormat('ar-SA', { style: 'currency', currency: 'EGP' }).format(number));\\nconsole.log(new Intl.NumberFormat('zh-CN', { style: 'currency', currency: 'CNY' }).format(number));\\n```\\n\\n## 6. 试验 Node watch 模式\\n\\n运行时增加了 node --watch 选项。\\n\\n在 \\\"watch\\\" 模式下运行，当导入的文件被改变时，会重新启动进程。\\n\\n比如：\\n```\\nconst express = require(\\\"express\\\");\\nconst path = require(\\\"path\\\");\\nconst app = express();\\napp.use(express.static(path.join(__dirname, \\\"../build\\\")));\\n\\napp.listen(8080, () =>\\n  console.log(\\\"Express server is running on localhost:8080\\\")\\n);\\n```\\n\\n```\\n% node --watch server\\n(node:67643) ExperimentalWarning: Watch mode is an experimental feature. This feature could change at any time\\n(Use `node --trace-warnings ...` to show where the warning was created)\\nExpress server is running on localhost:8080\\n```\\n\\n<hr>\\n\\nNode.js 14 将在 2023 年 4 月结束更新维护，Node.js 16 (LTS) 预计将在 2023 年 9 月结束更新维护。\\n\\n建议大家开始计划将版本按需升级到 Node.js 16（LTS）或 Node.js 18（LTS）。\\n\\n推荐阅读：\\n\\n* [Node.js 19 is now available! | Node.js](https://nodejs.org/en/blog/announcements/v19-release-announce/#node-watch-experimental)\\n\\n<hr>\\n\\n>OK，以上便是本篇分享，希望各位工友喜欢~ 欢迎点赞、收藏、评论 🤟\\n>\\n>我是掘金安东尼 🤠 100 万人气前端技术博主 💥 INFP 写作人格坚持 1000 日更文 ✍ 关注我，安东尼陪你一起度过漫长编程岁月 🌏\\n\\n<sub>**😹 加我微信 [ATAR53](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93fbb0597b124aca9fa3f606616ae6bf~tplv-k3u1fbpfcp-watermark.image?)，拉你入群，定期抽奖、粉丝福利多多。只学习交友、不推文卖课~**</sub>\\n\\n<sub>**😸 我的公众号：[掘金安东尼](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5cd8bb380f84d1ab52d275b1cb4e441~tplv-k3u1fbpfcp-watermark.image?)，在上面，不止编程，更多还有生活感悟~**</sub>\\n\\n<sub>**😺 我的 GithubPage: [https://tuaran.github.io](https://link.juejin.cn/?target=https%3A%2F%2Ftuaran.github.io%2F \\\"https://link.juejin.cn?target=https%3A%2F%2Ftuaran.github.io%2F\\\")，它已经被维护 4 年+ 啦~**</sub>\\n\\n<hr>\\n\\n***本文正在参加[「金石计划 . 瓜分6万现金大奖」](https://juejin.cn/post/7162096952883019783 \\\"https://juejin.cn/post/7162096952883019783\\\")***"
    },
    {
        "article_id": "7094167882266837023",
        "cover_image": "",
        "title": "青训营21天阅读打卡活动，坚持就拿大礼包",
        "brief": "“第三届字节跳动青训营后端专场” 开营在即！参与本次学习打卡活动除了能够收获社区精选出的技术干货外，也还有丰富奖品等你拿哦",
        "user_name": "青训营官方账号",
        "view_count": 34602,
        "collect_count": 310,
        "comment_count": 7157,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/de432cd6200bc3d3f7d633a3ccd528d8~300x300.image",
        "category": "阅读",
        "content": "---\\ntheme: scrolls-light\\n---\\n“第三届字节跳动青训营后端专场” 开营在即！在青训营的课程之外，掘金开发者社区也同样会为参与青训营的各位同学提供优质的技术学习资源！参与本次学习打卡活动除了能够收获社区精选出的技术干货外，也还有丰富奖品等你来拿哦！\\n\\n# 中奖公示：https://juejin.cn/post/7117192073039577096\\n\\n## 一、活动面向人群\\n本次青训营21天阅读打卡活动面向 **参与“第三届字节跳动青训营后端专场”基础班 & 进阶班的各位同学**\\n\\n## 二、活动时间\\n**2022年5月6日 - 2022年6月30日**\\n\\n## 三、活动规则\\n1.  同学们先选择下方列出的《掘金开发者社区青训营精品学习资源合集》中的任一内容开始学习；\\n\\n\\n2.  学习完相应内容后，在本帖（活动帖）评论区评论打卡，打卡格式为：\\n\\n      **打卡日期 + 学习内容**（如：x月x日打卡，今日学习《文章名称》**+ 不少于30字 的读后感**）\\n\\n    **举例：** 5月6日打卡，今日学习《  [几个秒杀 Go 官方库的第三方开源库](https://juejin.cn/post/7082238031356231688)》：本文介绍几个对标官方库的开源库，它们的性能远超前者。当读者在使用这些官方库遇到性能问题时，可以尝试替换优化。\\n\\n1. 奖品发放相关：6月30日活动结束，将会发放中奖公示，之后会通过掘金的系统消息通知大家填写中奖问卷（所有评论将会进行为时7个工作日的人工审核，预计问卷发放时间：7月13-15日之间）\\n    \\n\\n## 四、活动奖励\\n\\n\\n\\n奖项       | 获奖方式                     | 奖品                                     | 奖品图                                                                                                                                                                                                                                                   |\\n| :--------: | :------------------------: | :--------------------------------------: | :-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: |\\n| 学习打卡 第一关 | 在活动期间内参与青训营活动，且 **打卡满 7 天**  | **掘金贴纸** 一张<br>  限量**1000份**<br> （按打卡顺序先到先得）           | ![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/906025df80a547cdb12d7184765ae1f7~tplv-k3u1fbpfcp-zoom-1.image) |\\n| 学习打卡 第二关 | 在活动期间内参与青训营活动，且 **打卡满 14 天** | **小黄鸭玩具** ✖️1<br>  限量**800**份<br> （按打卡顺序先到先得）            | ![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e296702d1d84bfc892b1dd1a000c071~tplv-k3u1fbpfcp-zoom-1.image) |\\n| 学习打卡 第三关 | 在活动期间内参与青训营活动，且 **打卡满 21 天** | **时尚休闲双肩包 or 掘金马克杯 二选一** <br> 限量**500**份 <br> 按打卡顺序先到先得 |<img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c89d704de516477dac440ff1fea99bec~tplv-k3u1fbpfcp-zoom-1.image?\\\" width=\\\"100%\\\" ><img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fd2c5cb725b5432d87e1918bf293df05~tplv-k3u1fbpfcp-zoom-1.image?\\\" width=\\\"100%\\\" >\\n\\n## 五、《掘金开发者社区青训营精品学习资源合集》\\n\\n ### 1. Go语言上手-基础语言\\n\\n#### 1)、Go语言原理与应用实践\\n\\n-   [ Go 官方库的第三方开源库](https://juejin.cn/post/7082238031356231688)\\n\\n<!---->\\n\\n-   [Go Web开发入门指南](https://juejin.cn/post/6961035838234820622)\\n\\n<!---->\\n\\n-   [Golang 零值、空值与空结构](https://juejin.cn/post/6895231755091968013)\\n\\n<!---->\\n\\n-   [go module 环境配置](https://juejin.cn/post/6844903879868416007)\\n\\n<!---->\\n\\n-   [新版本Golang的包管理入门教程](https://juejin.cn/post/6844903808942735368)\\n\\n<!---->\\n\\n-   [Golang 单元测试之路漫漫](https://juejin.cn/post/6945103902429675533)\\n\\n<!---->\\n\\n-   [gRPC负载均衡-Golang](https://juejin.cn/post/6844903554180726791)\\n\\n<!---->\\n\\n-   [Golang 并发编程实战——协程、管道、select用法](https://juejin.cn/post/6993131351294050341)\\n\\n<!---->\\n\\n-   [对Golang一知半解？这里是上百篇掘金Golang优质文章｜ Go主题月](https://juejin.cn/post/6953073994383753223)\\n\\n#### 2)、Golang 语言框架实现\\n\\n-   [GO框架：GoFrame](https://juejin.cn/post/7075098594151235597)\\n\\n<!---->\\n\\n-   [gin框架(2)- Viper配置管理](https://juejin.cn/post/6970851434531291172)\\n\\n<!---->\\n\\n-   [Go微服务架构系列--gin框架](https://juejin.cn/post/6863465961618407432)\\n\\n<!---->\\n\\n-   [Go语言国内开源](https://juejin.cn/post/6976606948930093069)\\n\\n<!---->\\n\\n-   [如何用Go语言进行Web应用的开发？附4个常用框架对比总结！](https://juejin.cn/post/7038413976601886750)\\n\\n<!---->\\n\\n-   [为Go配置JSON](https://juejin.cn/post/7067102405283807239)\\n\\n<!---->\\n\\n-   [几个秒杀 Go 官方库的第三方开源库](https://juejin.cn/post/7082238031356231688)\\n\\n<!---->\\n\\n-   [HTTP灵魂之问，巩固你的 HTTP 知识体系](https://juejin.cn/post/6844904100035821575)\\n\\n#### 3)、Go 设计模式 与 GoRM 实践\\n\\n-   [并发组件 | Go设计模式实战](https://juejin.cn/post/6891497143798857735)\\n\\n<!---->\\n\\n-   [由浅到深，入门Go语言Map实现原理](https://juejin.cn/post/6908936575183388679)\\n\\n<!---->\\n\\n-   [Go工具之generate](https://juejin.cn/post/6942005360416784397)\\n\\n<!---->\\n\\n-   [Go设计模式](https://juejin.cn/post/6987204157413277727)\\n\\n<!---->\\n\\n-   [Gorm使用规范&&最佳实践](https://juejin.cn/post/6942792361609003015)\\n\\n<!---->\\n\\n-   [MySQL安装及GORM的增删查改](https://juejin.cn/post/6943989324908085285)\\n\\n<!---->\\n\\n-   [Golang下的ORM框架gorm的介绍和使用](https://juejin.cn/post/6844904090196000775)\\n\\n### 2、计算机编程基础\\n\\n#### 1)、开发规范、开发全流程\\n\\n-   [谁说明天上线，这货压根不知道开发流程!](https://juejin.cn/post/6913716768796213261)\\n\\n<!---->\\n\\n-   [万字详解腾讯微服务平台 TSF 的敏捷开发流程](https://juejin.cn/post/6940993650432163877)\\n\\n<!---->\\n\\n-   [产品开发流程|互联网|敏捷](https://juejin.cn/post/6995928601199804430)\\n\\n<!---->\\n\\n-   [阿里官方 Redis 开发规范!](https://juejin.cn/post/6906476040797814798)\\n\\n<!---->\\n\\n-   [数据仓库开发规范](https://juejin.cn/post/6975814437311610888)\\n\\n<!---->\\n\\n-   [前后端分离项目，该如何定义接口规范](https://juejin.cn/post/7006550805041905701)\\n\\n#### 2)、编程入门知识与计算机实际应用\\n\\n-   [《图解HTTP与HTTPS》的干货1.2w字【绝对保值】](https://juejin.cn/post/6900511779869327373)\\n\\n<!---->\\n\\n-   [连肝7个晚上，总结了计算机HTTP网络协议的知识点](https://juejin.cn/post/6899005188955176974)\\n\\n<!---->\\n\\n-   [Go语言之网络编程](https://juejin.cn/post/6897063158419521544)\\n\\n<!---->\\n\\n-   [数据结构--基本介绍](https://juejin.cn/post/6914519617792638984)\\n\\n<!---->\\n\\n-   [数据库_数据库基础](https://juejin.cn/post/6979016655011594270)\\n\\n#### 3)、架构入门\\n\\n-   [三元同学在抖音架构组的八个月，他经历了什么?](https://juejin.cn/post/6963061994928898085)\\n\\n<!---->\\n\\n-   [架构师的初级技能，选组件!(2020更新版)](https://juejin.cn/post/6870288195674718222)\\n\\n<!---->\\n\\n-   [关于Android架构，你是否还在生搬硬套?](https://juejin.cn/post/6942464122273398820)\\n\\n<!---->\\n\\n-   [浅入浅出Spring架构设计](https://juejin.cn/post/7052116392979464205)\\n\\n<!---->\\n\\n-   [怎么提高自己的系统架构水平](https://juejin.cn/post/6985444616136818724)\\n\\n<!---->\\n\\n-   [分布式架构入门](https://juejin.cn/post/6923471268075438087)\\n\\n<!---->\\n\\n-   [架构入门与架构师职责](https://juejin.cn/post/6855990342249480200)\\n\\n### 3. Git 正确使用以及最佳实践\\n\\n-   [「一劳永逸」一张脑图带你掌握Git命令](https://juejin.cn/post/6869519303864123399)\\n\\n<!---->\\n\\n-   [我在工作中是如何使用 git 的](https://juejin.cn/post/6974184935804534815)\\n\\n<!---->\\n\\n-   [Git不要只会pull和push，试试这5条提高效率的命令](https://juejin.cn/post/7071780876501123085)\\n\\n<!---->\\n\\n-   [一份工作4年前端的Git备忘指南](https://juejin.cn/post/6967634683811069982)\\n\\n<!---->\\n\\n-   [通过命令行玩转Git，需要记住那些命令？](https://juejin.cn/post/7017265876638367780)\\n\\n<!---->\\n\\n-   [用21张图，把Git 工作原理彻底说清楚](https://juejin.cn/post/7030409006258585637)\\n\\n<!---->\\n\\n-   [IDEA 中玩转 Git](https://juejin.cn/post/7067515656383496222)\\n\\n<!---->\\n\\n-   [请不要再轻视Git —— 我在工作中是如何使用 Git 的](https://juejin.cn/post/7039531487666339870)\\n\\n<!---->\\n\\n-   [Git 工作流实践方案探索](https://juejin.cn/post/7050012586296737805)\\n\\n<!---->\\n\\n-   [git仓库清理--\\\"保姆级\\\"教程](https://juejin.cn/post/7024922528514572302)\\n\\n<!---->\\n\\n-   [比较全面的 Git 命令手册，几乎涵盖日常所有的使用场景（下）](https://juejin.cn/post/6960904785742528526)\\n\\n<!---->\\n\\n-   [不切换 Git 分支，却能同时在多个分支上工作，我是怎么做到的？](https://juejin.cn/post/7033937199355658271)\\n\\n### 4. 网络协议与部署\\n\\n-   [实时联网游戏后台服务技术选型和挑战](https://juejin.cn/post/6844903597423984654)\\n\\n<!---->\\n\\n-   [蚂蚁金服 mPaaS 服务端核心组件：亿级并发下的移动端到端网络接入架构解析](https://juejin.cn/post/6844903748930633735)\\n\\n<!---->\\n\\n-   [淘宝技术分享：手淘亿级移动端接入层网关的技术演进之路](https://juejin.cn/post/6862570260558675975)\\n\\n<!---->\\n\\n-   [技术问题-经典网络模型](https://juejin.cn/post/7006508444031123487)\\n\\n### 5. 数据库延展阅读\\n\\n#### 1)、数据结构概览\\n\\n-   [恋上数据结构与算法](https://juejin.cn/post/7044364562769903624)\\n\\n<!---->\\n\\n-   [一张脑图带你看动态规划算法之美](https://juejin.cn/post/6872115031501340679)\\n\\n<!---->\\n\\n-   [梳理数据结构6大排序算法](https://juejin.cn/post/6856546833025237006)\\n\\n<!---->\\n\\n-   [分治算法之美](https://juejin.cn/post/6885104477297344525)\\n\\n<!---->\\n\\n-   [链表的9个基本操作](https://juejin.cn/post/6850418120755494925)\\n\\n<!---->\\n\\n-   [DFS和BFS算法之美](https://juejin.cn/post/6861376131615227912)\\n\\n<!---->\\n\\n-   [二叉树之美](https://juejin.cn/post/6890680584033533960)\\n\\n<!---->\\n\\n-   [时间与空间复杂度](https://juejin.cn/post/6911477791754027021)\\n\\n<!---->\\n\\n-   [大学四年一路走来，我把这些私藏的算法学习工具全贡献出来了！](https://juejin.cn/post/6997188984988254222)\\n\\n<!---->\\n\\n-   [数组、链表、队列和栈，四大基础数据结构详解](https://juejin.cn/post/6996815834534379557)\\n\\n<!---->\\n\\n-   [5种限流算法，7种限流方式，挡住突发流量？](https://juejin.cn/post/7075137592265539614)\\n\\n<!---->\\n\\n-   [为了拿捏 Redis 数据结构，我画了 40 张图（完整版）](https://juejin.cn/post/7036614335157764133)\\n\\n<!---->\\n\\n-   [一份给算法新人们的「动态规划」讲解](https://juejin.cn/post/6987204978884476959)\\n\\n#### 2)、数据库与存储入门\\n\\n-   [后端程序员必备：mysql数据库相关流程图/原理图](https://juejin.cn/post/6844903905319469070)\\n\\n<!---->\\n\\n-   [Postgresql与MySQL的区别](https://juejin.cn/post/6844903799245504519)\\n\\n<!---->\\n\\n-   [MySQL技术](https://juejin.cn/column/6963438727058325512)\\n\\n<!---->\\n\\n-   [MySQL事务隔离级别和MVCC](https://juejin.cn/post/6844903808376504327)\\n\\n<!---->\\n\\n-   [138 张图带你 MySQL 入门](https://juejin.cn/post/6844904196383195144)\\n\\n<!---->\\n\\n-   [ElasticSearch全流程](https://juejin.cn/post/6972038748049670175)\\n\\n<!---->\\n\\n-   [ElasticSearch分布式集群](https://juejin.cn/post/7084838328050122789)\\n\\n<!---->\\n\\n-   [大数据Hadoop生态系统介绍](https://juejin.cn/post/7087096425137307661)\\n\\n<!---->\\n\\n-   [通俗易懂的Redis数据结构基础教程](https://juejin.cn/post/6844903644798664712)\\n\\n<!---->\\n\\n-   [如何保证缓存和数据库的一致性？](https://juejin.cn/post/7080466384664133663)\\n\\n### 5. 分布式系统\\n\\n-   [再有人问你分布式事务，把这篇扔给他](https://juejin.cn/post/6844903647197806605)\\n\\n<!---->\\n\\n-   [常用的分布式事务解决方案](https://juejin.cn/post/6844903573667446797)\\n\\n<!---->\\n\\n-   [再有人问你分布式锁，这篇文章扔给他](https://juejin.cn/post/6844903688088059912)\\n\\n<!---->\\n\\n-   [分布式事务、重复消费、顺序消费](https://juejin.cn/post/6844904003877208071)\\n\\n<!---->\\n\\n-   [微服务分布式事务实践](https://juejin.cn/post/7043974753383612430)\\n\\n<!---->\\n\\n-   [ZooKeeper分布式锁的实现原理](https://juejin.cn/post/6844903729406148622)\\n\\n<!---->\\n\\n-   [每秒上千订单场景下的分布式锁高并发优化实践](https://juejin.cn/post/6844903719318847495)\\n\\n\\n> 本次活动解释权归掘金开发者社区所有\\n"
    },
    {
        "article_id": "7189975019005411389",
        "cover_image": "",
        "title": "如何构建一个高可靠系统（上）",
        "brief": "什么是高可靠系统？站在使用者的角度，高可靠系统就是靠谱的系统，值得信赖的系统，不容易出现莫名其妙的问题，使用非常丝滑。本篇博客分为上下两部分，会从多个维度聊聊如何构建一个高可靠的系统。 过载保护：限流",
        "user_name": "CoderBear",
        "view_count": 1476,
        "collect_count": 5,
        "comment_count": 0,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/9f91e6f981d627a17d12f0238ca15a8b~300x300.image",
        "category": "后端",
        "content": "本篇博客参考：余春龙的《架构设计2.0》\\n\\n什么是高可靠系统？站在使用者的角度，高可靠系统就是靠谱的系统，值得信赖的系统，不容易出现莫名其妙的问题，使用非常丝滑。本篇博客分为上下两部分，会从多个维度聊聊如何构建一个高可靠的系统。\\n\\n## 过载保护：限流与熔断\\n系统上线前，我们会对流量进行估算，申请对应的服务器，为了不背锅，我们往往会多申请几台服务器或者申请配置更高的服务器，即使这样，也没办法保证我们的系统一定能承受所有的用户请求。这个时候，系统就需要有过载保护：拒绝一部分用户的请求，确保大多数用户可以正常的使用系统。\\n\\n过载保护有两种常用的方式：限流与熔断。\\n\\n### 限流\\n限流，在生活中也非常常见，比如：\\n- 进入火车站候车室需要安检，如果进入安检区域的人太多，那会变得一团糟，所以在人多的时候，管理人员会控制进入安检区域的人数，慢慢的将人放进去；\\n- 去景点游玩，如果景点人太多，会严重影响用户体验，也不太安全，所以管理人员有时候会在景点外设置拦截，控制入园人数，等有游客从景点出来了，再放一部分游客进入景点。\\n\\n#### 限流的两种维度\\n限流通常有两种限制维度：并发数，频率。\\n\\n#### Nginx中的限流\\nNginx就提供了限制并发数，频率这两种维度的模块：limit_conn(限制并发数)，limit_req（限制频率）。\\n在秒杀系统中，有一个商品的库存是1000，现在有几万人抢购，那意味着大部分人都是没办法抢购到商品的，将所有用户请求全部放到后面的应用服务器，应用服务器再将所有用户请求全部放到后面的数据库，这是没有任何意义的，而且会造成应用服务器、数据库的压力激增，甚至可能将应用服务器、数据库打垮。基于这两点原因，可以在Nginx进行如下的限流：\\n- 并发连接数的控制：只放2000个人进到后面的应用服务器，剩下的直接响应“已售完”，那应用服务器、数据库的压力就会小的多；\\n- 频率的控制：每个IP，每秒只能进行一次请求，避免刷子流量。\\n\\n#### RPC中的整体限流\\n某些基于TCP的RPC服务提供方大致工作原理如下图所示：\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3050fb978b146cba3721805f911b4ca~tplv-k3u1fbpfcp-watermark.image?)\\n客户端向服务端发起请求，服务端有一个监听线程、多个Work线程，监听线程将请求暂存到Request缓冲区，Work线程从Request缓冲区取出Request，进行处理。这个Request缓冲区往往是有界的内存队列，为什么是有界的？\\n- 有些Request很大，如果Request缓冲区是无界的，很容易撑爆内存；\\n- 客户端往往会设置超时时间（没有手动设置，也会有默认的），如果Request缓冲区是无界的，积压了太多的请求，那后面的请求即使处理了也没有任何意义，因为客户端已经超时，发起重试或者抛出异常了，还不如直接将Request进行丢弃。\\n\\n#### Hystrix中的限流\\n大部分开发小伙伴，第一次听说限流，应该就是在Hystrix了，Hystrix默认使用线程隔离模式，可以通过线程数+队列大小进行限流。\\n\\n#### 限流的另类用法\\n限流就是拒绝一部分用户的请求，确保大多数用户可以正常的使用系统，但是限流偶尔会有另类的用法，我在开发中，就另类的使用过限流。\\n当时，我负责的系统是面向商家的，接收商家的下单请求：\\n- 如果某一时刻，没有触发限流，我接收到商家的下单请求后，就及时处理下单请求，及时响应商家；\\n- 如果某一时刻，触发了限流，我接收到商家的下单请求后，就将请求放入MQ或者放入消息表中，后续慢慢处理，处理完成后，以站内通知的方式或者邮件的方式告知商家。\\n\\n可以看到，即使触发了限流，也没有拒绝用户的请求，还是能正常处理用户的请求，这算是限流的另类用法吧。\\n\\n#### RateLimiter\\nRateLimiter是Guava库中的一个限流器，是基于令牌桶限流算法实现的，使用起来非常方便：\\n\\n```java\\n//创建一个限流器，每秒钟产生100个令牌\\nRateLimiter rateLimiter = RateLimiter.create(100);\\n//获取一个令牌，如果可以获得到，马上返回；不能获得到，则阻塞，等待新的令牌产生\\nrateLimiter.acquire(1);\\n//不管有没有获得到令牌，都马上返回，根据返回的布尔值，判断是否获得到令牌\\nrateLimiter.tryAcquire(1);\\n```\\n如果是我来实现这个限流器，肯定会在后台启动一个线程，这个线程的任务就是每隔一段时间，往“桶”里丢一定数量的令牌，但是神一般的Guava不是这么做的，它会记录最后一次获得令牌的时间，拿令牌的时候，计算最后一次获得令牌的时间与现在的时间差，在这个时间差内，可以获得多少令牌，然后进行令牌的增加与扣减。\\n\\n#### 中央限流\\n在大部分场景中，我们使用的都是单机限流，但是单机限流有局限性，比如我们的应用有3台服务器，我们应用依赖的服务最多只能支撑100个并发，那我们只需要控制每台服务器最多可以同时“流”下去30个请求就可以了（$30*3=90<100$），但是如果有一天，我们增加了服务器，却没有通知依赖服务，那情况可就不妙了（$30*4=120>100$），有什么办法可以解决问题呢？可以使用中央限流。\\n\\n我们来看下，使用中央限流的处理流程：\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db3b6bcf00bf46699f413959b27c438d~tplv-k3u1fbpfcp-watermark.image?)\\n1. 客户端请求服务端；\\n2. 服务端请求中央限流模块，询问是否可以处理此请求；\\n3. 中央限流模块响应服务端，是否可以处理此请求。\\n\\n服务端处理完成后，可能还需要上报中央限流模块：请求已经处理完成。当然也可以不上报，中央限流模块默认一定时间后，请求被服务端处理完成。\\n\\n可以看出，使用中央限流有如下的弊端：\\n- 单点问题：中央限流模块是单点的，如果中央限流模块出现故障，应该怎么办？当然，我们可以采用ZooKeeper、ETCD等方式，使中央限流模块高可用，这就非常复杂了；\\n- 性能问题：每个请求都要先经过服务端，服务端再请求中央限流模块，中央限流模块再响应服务端，虽然都在内网，但是损耗也必然是有的；\\n- 中央限流模块压力问题：众多服务端请求中央限流模块，中央限流模块的压力剧增，中央限流模块是否可以扛得住？\\n- 超出服务端承受能力问题：因为此方案中没有单机限流的存在，只是询问中央限流模块，当中央限流模块响应“可以处理请求”，可能对于服务端而言，已经超出了自身的承受能力。\\n\\n那有没有办法解决这些问题呢？很遗憾，目前没有办法完全解决这些问题，但是我们可以利用单机限流+中央限流的方式最大程度的去缓解这些问题：\\n- 当中央限流模块出现故障，就采用单机限流，这样就可以避免中央限流模块的单点问题；\\n- 不必每次都去请求中央限流模块，可以从中央限流模块申请一批额度，当这批额度用完之后，再去申请新的额度，这样就可以缓解中央限流模块的压力和中央限流模块带来的性能问题。\\n\\n针对于第二点，我们还可以再次进行优化：最开始，我们并不需要请求中央限流模块，可以完全采用单机限流，当单机限流到达一定的阈值后，再去中央限流模块申请一批额度。\\n\\n“从中央限流模块申请一批额度”这种方式很美好，但还是存在问题：\\n- 服务端的某台机器向中央限流模块申请了最后一批额度后，服务端的其他机器就申请不到额度了，就限流了，此时只有申请了最后一批额度的机器可以正常处理客户端请求；\\n- 服务端申请的额度没有及时用完，应该如何处理？\\n\\n### 超时\\n只要发生了网络交互：比如Http请求、发送消息到MQ、RPC调用等等，都需要设置超时时间，这是构建高可靠系统最简单的，但也是最容易被忽视的一个点，在发起Http请求、发送消息到MQ、RPC调用的时候，请合理设置超时时间。\\n\\n客户端发起请求，需要设置超时时间，那是不是意味着服务端就没有超时时间了，非也，有时候在服务端也有超时时间的概念，而且这超时时间也尤为重要，如下图所示：\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3050fb978b146cba3721805f911b4ca~tplv-k3u1fbpfcp-watermark.image?)\\n小伙伴一定很熟悉这张图，在介绍限流的那一节，已经出现过了，这里又出现了，为了增强大家的记忆，我再介绍下工作流程：客户端向服务端发起请求，服务端有一个监听线程、多个Work线程，监听线程将请求暂存到Request缓冲区，Work线程从Request缓冲区取出Request，进行处理。这个Request缓冲区往往是有界的内存队列。\\n那超时体现在哪里呢？Work线程从Request缓冲区取出Request，可以先检查下这个Request是否已经超时了，如果已经超时了，那Work线程处理这个请求是没有任何意义的，还不如直接丢弃。\\n在这种情况之下，客户端和服务端可能都会有一个超时时间，此时就需要满足公式：\\n>客户端超时时间>=服务端超时时间\\n\\n如果客户端的超时时间设置为3秒，服务端的超时时间设置为5秒，那服务端多出来的2秒超时时间是没有任何意义的：服务端辛辛苦苦处理完成请求后，客户端已经超时，发起重试或者抛出异常了。\\n\\n### 重试\\n进行网络交互，网络有时会发生抖动，服务端可能也有可能正在GC，没有及时处理客户端请求，这个时候，客户端请求就会失败，我们可以进行重试，但是有一个前提：服务端必须幂等。\\n重试也并非是无脑的，会有两种常见的策略：\\n- 延迟策略：延迟一定的时间再发起重试，甚至可以逐步提高延迟时间，比如第一次重试间隔50ms，第二次重试间隔100ms，第三次重试间隔200ms；\\n- 退避策略：向某台服务器发起请求失败，发起重试就避开这台服务器，向其他服务器发起重试。\\n\\n重试的时候，还有一个小的优化点：客户端设置的总超时时间（包括重试）是3秒，服务端处理请求需要2秒，因为网络原因，客户端第一次请求经过1.5s后失败了，那还要必要进行重试吗？\\n\\n本篇博客主要介绍了构建一个高可靠系统的三个要素：限流、超时、重试，下一篇博客将会介绍隔离、降级、熔断、监控、灰度、告警。"
    },
    {
        "article_id": "7189800442858045495",
        "cover_image": "",
        "title": "【Atcoder】AtCoder Regular Contest 144 E - GCD of Path Weights | 图论、构造",
        "brief": "【Atcoder】AtCoder Regular Contest 144 E - GCD of Path Weights | 图论、构造 题目链接 E - GCD of Path Weights (a",
        "user_name": "IceTeapoy",
        "view_count": 880,
        "collect_count": 0,
        "comment_count": 0,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/7e3cae207fb317f72eecad369aaa5ed1~300x300.image",
        "category": "阅读",
        "content": "【Atcoder】AtCoder Regular Contest 144 E - GCD of Path Weights | 图论、构造\\n# 题目链接\\n[E - GCD of Path Weights (atcoder.jp)](https://atcoder.jp/contests/arc144/tasks/arc144_e)\\n# 题目大意\\n给定有 $n$ 个点 $m$ 条边的有向无环图，给定长度为 $n$ 的整数数组 $a_1,a_2,...,a_n$。若 $a_i(1\\\\le i\\\\le n)$ 为 $-1$，说明图中第 $i$ 个节点的点权未知，否则说明该点的点权为 $i$。为点权未知的节点赋值，最大化从节点 $1$ 到节点 $n$ 之间所有路径点权和的最大公约数。\\n\\n若不存在最大的答案，输出 `-1`。\\n# 思路\\n容易发现图中 $1$ 无法到达、或者无法到达 $n$ 的节点对答案没有影响，可以直接删去。然后我们进行一步转化，路径点权和让人无从下手，我们先把每个节点拆成两个节点，则点权转变为边权。比如样例 $1$:\\n```in\\n4 4\\n1 2\\n1 3\\n2 4\\n3 4\\n-1 3 7 -1\\n```\\n我们转化后建出的图为：\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/291775a5965443bea41e203534ab4400~tplv-k3u1fbpfcp-watermark.image?)\\n\\n假设从节点 $1$ 到节点 $n$ 之间所有路径边权和都是 $x$ 的倍数，那么一定可以给每个点分配一个权值 $p_1,p_2,,...,p_n$，使得对每条有权值的有向边 $(u,v,w)$，都满足 $p_v\\\\equiv p_u+w\\\\pmod x$。因为我们只关心有向边两端点权值的相对大小，我们可以用加权并查集进行维护：\\\\\\n记 $f[x]$ 表示 $x$ 在加权并查集中的父节点，$dt[x]$ 表示 $p_x+dt[x]\\\\equiv p_{f[x]}\\\\pmod x$。\\\\\\n路径压缩如下图所示，直接令 $dt$ 相加即可：\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51f2c943ea7047b696e9eba91548aea3~tplv-k3u1fbpfcp-watermark.image?)\\n------\\n所以用并查集维护两点之间的差有什么用处呢？下面我们来说明求解该问题的具体流程。\\n\\n首先我们先将原图中的边加入到加权并查集中，这些边的边权均为 $0$。\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d038e9fdb5c4df8923e37a4f5bce4f3~tplv-k3u1fbpfcp-watermark.image?)\\n\\n然后对于输入的旧图上第 $i$ 个点的点权 $a_i$，也就是转化后点 $i.1$ 和 $i.2$ 之间的边权，先查询两种是否在同一个并查集中：\\n- 如果不在，需要进行合并。\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e17304d9c3d4b39913a607cb51bf185~tplv-k3u1fbpfcp-watermark.image?)\\n- 如果在，说明 $dt[i.1]\\\\equiv dt[i.2]+a[i]\\\\mod x$，所以最后的答案是 $|dt[i.2]+a[i]-dt[i.1]|$ 的因数。\\n\\n这样我们就可以找到所有给定点权对答案进行的限制了，显然我们自己乱填的点权不会给答案更多限制，所以对所有限制取最大公约数即可。注意如果从节点 $1$ 能直接通过确定边权的路径到达节点 $n$，那么最终的答案还需要与任一从节点 $1$ 到节点 $n$ 的路径长度取最大公约数（见样例 $4$）。\\n\\n# 代码\\n```cpp\\n#include <stdio.h>\\n#include <algorithm>\\n#include <string.h>\\n#include <iostream>\\n#include <math.h>\\n#include <map>\\n#include <queue>\\n#include <vector>\\n#include <stdlib.h>\\n#include <time.h>\\nusing namespace std;\\nusing LL=long long;\\nconst int N=1e6+5;\\n//const LL mod=998244353;\\nconst LL mod=1e9+7;\\nint n,m,k,x[N],y[N];\\nLL a[N],dt[N];\\nint f[N],vis[N],vv[N];\\nvector<int> e[N];\\nint find(int x)\\n{\\n\\tif (f[x]==x) return x;\\n\\tfind(f[x]);\\n\\tdt[x]=dt[x]+dt[f[x]];\\n\\treturn f[x]=f[f[x]];\\n}\\nvoid dfs(int u)\\n{\\n\\tvv[u]=1;\\n\\tif (u==n) vis[u]=1;\\n\\tfor (auto v:e[u])\\n\\t{\\n\\t\\tif (!vv[v]) dfs(v);\\n\\t\\tif (vis[v]) vis[u]=1;\\n\\t}\\n}\\nLL gcd(LL a,LL b)\\n{\\n\\tif (b) return gcd(b,a%b);\\n\\treturn a;\\n}\\nint main()\\n{\\n\\tscanf(\\\"%d%d\\\",&n,&m);\\n\\tfor (int i=1;i<=n*2;++i) f[i]=i;\\n\\tfor (int i=1;i<=m;++i)\\n\\t{\\n\\t\\tscanf(\\\"%d%d\\\",&x[i],&y[i]);\\n\\t\\te[x[i]].push_back(y[i]);\\n\\t}\\n\\tdfs(1);\\n\\tif (!vis[n]) return printf(\\\"-1\\\\n\\\"),0;\\n\\tfor (int i=1;i<=m;++i)\\n\\t\\tif (vis[x[i]]&&vis[y[i]]) f[find(x[i]*2)]=find(y[i]*2-1);\\n\\tLL ans=0;\\n\\tfor (int i=1;i<=n;++i)\\n\\t{\\n\\t\\tscanf(\\\"%lld\\\",&a[i]);\\n\\t\\tif (!vis[i]) continue;\\n\\t\\tif (a[i]==-1) continue;\\n\\t\\tif (find(i*2-1)!=find(i*2))\\n\\t\\t{\\n\\t\\t\\tdt[f[i*2-1]]=a[i]-dt[i*2-1];\\n\\t\\t\\tf[f[i*2-1]]=i*2;\\n\\t\\t}\\n\\t\\telse ans=gcd(ans,abs(dt[i*2]+a[i]-dt[i*2-1]));\\n\\t}\\n\\tif (find(1)==(n*2)) ans=gcd(ans,dt[1]);\\n\\tif (ans==0) ans--;\\n\\tprintf(\\\"%lld\\\\n\\\",ans);\\n\\treturn 0;\\n}\\n```\\n"
    },
    {
        "article_id": "7189635461290131511",
        "cover_image": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c74d5c774d06419cbdba6a8ce6ad6f0b~tplv-k3u1fbpfcp-watermark.image?",
        "title": "告别我的2022，期待未来会更好",
        "brief": "告别2022，迎接2023年，回望过去的一年，有得有失。以往不谏，来者可追，希望2023年自己能有更多的成长与收获。",
        "user_name": "张醒言",
        "view_count": 1017,
        "collect_count": 1,
        "comment_count": 0,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/15920d6ee762be284ad11b96bf26358f~300x300.image",
        "category": "代码人生",
        "content": "---\\ntheme: smartblue\\n---\\n\\n「回顾2022，展望2023，我正在参与[2022年终总结征文大赛活动](https://juejin.cn/post/7172462429929111559)」\\n\\n## 工作的起起伏伏\\n\\n### 工作情况\\n去年年末，我换了工作，来到了一家在当时风评不错的互联网公司。当时对薪资和团队的方向都挺满意，方向比较偏后端的底层技术，也是一个刚刚组建的新团队，HR告诉我去做的是从0到1的事情。怎么说呢，当时对需要做的事情有蛮多期待的，因为工作的内容是自己感兴趣的，觉得很有挑战性，会有技术成长。\\n\\n但事情的发展没有这么顺利，入职了之后，发现团队内部的规划包括氛围都是有些问题的，提出的很多技术方案总是缺乏落地执行，入职了几个月之后，自己做的事比较少也没什么成长，一直陷入焦虑之中，只能开始看起了一些基础组件的源代码。\\n\\n后来，经历了一些被动的团队调整，新的团队给自己的感觉还是很不错的。这也算是比较幸运的事情了。在行业整体行情不好的情况下，能够专心做自己的事，已经是不错的了。\\n\\n### 在掘金\\n在这个时候，自己也在掘金写了几篇文章,参加过一些活动，比如几月更文之类的，但都没完成目标。后来发现自己还是更适合参加技术专题的活动。一部分原因，是因为自己太懒了，没有把时间有效利用起来，第二点是自己也不太愿意写很灌水的内容。一开始写文章的目的，是希望通过写文章的方式整理自己的知识点，提高自己结构化总结的能力，如果写出来的文章能够帮到大家就更好了。后来，好几篇文章上了首页推荐，也获得了几千到1w不等的阅读量，自己还是挺开心的。\\n1. [Golang Web框架还在用Gin吗，快试试全新框架Bud吧](https://juejin.cn/post/7125382825229942814)\\n2. [如何实现定时任务- Java Timer/TimerTask 源码原理解析](https://juejin.cn/post/7044490907726544933)\\n3. [好奇延时消息如何实现吗？ 来看RocketMQ是怎么做的-源码解读](https://juejin.cn/post/7047066122557849630)\\n4. [深入理解和使用 Prometheus 的 Histogram 指标类型](https://juejin.cn/post/7152837166190739486)\\n\\n这是在掘金参加活动获得的一些奖品：\\n\\n<img src=\\\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc66fc1c59c643e9bdecf5d2657e183f~tplv-k3u1fbpfcp-watermark.image?\\\"  align=center width=\\\"80%\\\" height=\\\"80%\\\"/>\\n\\n### 一些感悟\\n1. 之前自己关注的东西可能比较务虚，比如说面试时候获知的一些团队发展的内容，或者是一些小的钱和利益。说实话，更多的应该关注一些可以把握的东西。如人饮水，冷暖自知。比如承诺的团队发展，未来的团队规划，其实这些是不太能确定的。因为一次简单的团队调整，这些东西可能就不复存在了。\\n公司的发展未来，这一点很重要，尤其是现在形势不好的情况下，如果公司是往上走的，即使你在团队内工作得不开心，也可以通过转岗等方式进行调整。\\n团队的内部氛围，这是和自己最息息相关的部分了，一个好的团队leader会让你工作起来很省心，可以把全部的注意力放在你scale之内的工作上，其实效率会很高的。但相反，一个差的leader，会给你制造各种阻碍和焦虑，分散工作的精力。\\n\\n2. 事事有回应很重要，多去主动沟通和联系。工作上面多去主动沟通和确认一些问题，会更好地解决问题，也会让大家觉得你是一个靠谱的人。\\n\\n3. 坚持一些好的习惯，定期进行总结和回顾，不管是整理工作的内容，还是技术的一些积累，都可以。一个月，一年的时间都很快，日积月累的坚持，给人带来的变化和提升是巨大的，做一个长期主义者。\\n\\n\\n\\n\\n## 生活的一些新体验\\n\\n\\n### 运动\\n从工作之后，一直不太注意健康的问题，经常熬夜，饮食也是比较重油重盐。\\n2022年，从五月份开始锻炼，一开始真的2km都很难跑下来，后来慢慢地可以适应5km，10km。习惯了之后，跑10km控制1小时内的配速对我来说，不再是一个很难的事情了。后来也尝试去健身房做一些有氧锻炼，总体来说是一个良性循环。\\n慢慢的，体重也减了下来，状态最好的时候，减了20斤，但后来因为北京疫情比较厉害，自己也阳了，天气转冷，运动就停下来了。但2023年天气好一些之后，自己还是要好好坚持锻炼的。\\n\\n2022年的5月到12月，半年多时间，一共跑了大概200km。希望可以2023全年，可以跑400km+。体脂也可以降下去。\\n\\n<img src=\\\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/579187bd6d0846369b9e58aec8b5eeda~tplv-k3u1fbpfcp-watermark.image?\\\" align=center width=\\\"60%\\\" height=\\\"60%\\\"/>\\n\\n\\n\\n### 摄影\\n\\n2022年自己的一个比较开心的事，就是拿起了相机，去记录了生活。然后发现了自己确实是喜欢摄影的，有时候背着相机出门很累，回来整理图片后期什么的更累，但是当拍到自己喜欢的瞬间的时候，那种开心和满足感是真实存在的。\\n\\n希望自己2023可以把摄影这件事有目标起来，虽然说悦己是最重要的，但是如果能从自己的爱好中，再获得一些正向的反馈，催促自己不断提升，那就更好了。\\n\\n<img src=\\\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/81d58d12bc114256814ab527922e6592~tplv-k3u1fbpfcp-watermark.image?\\\"  align=center width=\\\"80%\\\" height=\\\"80%\\\"/>\\n\\n\\n\\n## 未来的期许\\n\\n### 工作\\n目前自己还没有想好要不要换工作，如果没有很好的机会的话，应该还是会在目前的岗位上。现在的经济形势不好，自己目前的团队氛围还是不错的，leader人也很好。\\n\\n如果自己想要有变动，那么一定要考虑好，因为这个年龄的每一步变动，都会对以后产生很大的影响。切记切记！\\n\\n### 生活\\n希望2023年大家的工作和生活都能越来越好，行业也能度过寒冬，有更多的机会。\\n自己的话，2023继续提升自己，在网络平台和个人博客上输出更多的内容。其实2022尝试了比较多，但都是开了一个头，没有很好的去坚持做。\\n\\n### 一些具体目标\\n1. 独立负责更多的模块，成为一个团队内对某一块内容了解比较深入的人。\\n2. 全年跑完400km，体脂减到15%以下。\\n3. 在博客上面写20篇技术相关的文章。\\n4. 读20本书（不限技术书籍，还是闲书）\\n\\n\\n「回顾2022，展望2023，我正在参与[2022年终总结征文大赛活动](https://juejin.cn/post/7172462429929111559)」"
    },
    {
        "article_id": "7189796735274156069",
        "cover_image": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/570e337f1e87437dab53dfc6526e5951~tplv-k3u1fbpfcp-watermark.image?",
        "title": "组件库从开发到维护全链路讲解（二）日历组件的核心逻辑与设计",
        "brief": "今天这章主要从以下几个方面展开讲解： 日历面板渲染（动态调整每个月的日期排列） 上下月切换（一次性应该渲染几个月的日期） 自定义周起始星期（适配不同的周起始星期，例如周日或周一） 周月切换（丝滑的切换",
        "user_name": "HashTang",
        "view_count": 1080,
        "collect_count": 4,
        "comment_count": 1,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/92e697851571083ae5158278563f2ac5~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: cyanosis\\nhighlight: vs2015\\n---\\n\\n> 本篇文章为《[前端组件库的开发与维护](https://juejin.cn/column/7176570622242193468)》系列的第二篇文章。本文案例在线文档：[calendar.hxkj.vip](https://calendar.hxkj.vip)。GitHub 仓库：[github.com/TangSY/vue3-hash-calendar](https://github.com/TangSY/vue3-hash-calendar)。\\n\\n今天这章主要从以下几个方面展开讲解：\\n\\n1. 日历面板渲染（动态调整每个月的日期排列）\\n2. 上下月切换（一次性应该渲染几个月的日期）\\n3. 自定义周起始星期（适配不同的周起始星期，例如周日或周一）\\n4. 周月切换（丝滑的切换周/月模式）\\n5. 组件的易用性（API 设计技巧）\\n6. 组件的可扩展性（slot 设计技巧）\\n7. 组件的可维护性（组件之间的设计技巧）\\n8. 改进计划（目前现存的一些问题及重构计划）\\n\\n## 日历面板渲染\\n\\n先看下日历面板由哪些内容构成：\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b79dd4556b0647308d6900fedd2ca5c0~tplv-k3u1fbpfcp-watermark.image?)\\n\\n结构还是挺明显的，从上到下分别为：标题栏、星期栏以及日历主体。其中标题栏和星期栏比较简单，着重看看日历主体部分。\\n\\n这里单纯从展示效果来区分的话，会出现两种情况。第一种情况，**当月的起始日期不在面板的第一格**，此时需要用上月的日期去填充，如下图：\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6577f20c13ff4457b23cc95e35ea215a~tplv-k3u1fbpfcp-watermark.image?)\\n\\n第二种情况，**当月的起始日期在面板的第一格**，此时就不用填充上月日期了。\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1fc1c69f504345219d4aa13b97b0f08f~tplv-k3u1fbpfcp-watermark.image?)\\n\\n但是，我们在实现的时候，其实是可以按同一种情况来计算的。我们**只需要知道当月的第一天在星期几就可以了**。若是星期日则填充 0 个上月日期，星期一就填充 1 个上月日期。。。\\n\\n然后接下来就是我们到底**需要渲染几行日期**呢？按理说：一个月最多 31 天，每行 7 天的话，我们只需要 5 行就够了。但是，从上面 1 月份那个示例图可以看出来，它是有可能占用 6 行的，而从上面 5 月份的那个示例图看，5 行也确实够用，第六行全是下个月的日期，完全可以舍弃的。\\n\\n这里其实涉及一个用户体验问题，假设日历的交互方式是通过上下滚动来切换月份，这种交互方式对于每月高度的变化不敏感，为了不给用户展现过多的无效信息，可以设计为：该占多少行就占用多少行，例如 2022 年 1 月占用 5 行，2022 年 5 月占用 6 行。\\n\\n但是，本案例中日历的交互方式是通过左右滑动来切换月份，这种交互方式对于高度的变化是很敏感的，一会儿 5 行，一会儿 6 行，导致切换时会有明显的上下抖动感。因此，需要统一高度，让其在视觉效果上保持一致性。那这个行数就确定下来了 -- **6行**。实现代码如下：\\n\\n```js\\n// 日历总天数\\nconst calendarDaysTotalLength = 42;\\n\\n// 获取月份某一天是星期几\\nexport const getDayOfWeek = (year, month, day) => {\\n  const dayOfMonth = new Date(year, month, day); // 获取当月的第day天\\n  const dayOfWeek = dayOfMonth.getDay(); // 判断第day天是星期几(返回[0-6]中的一个，0代表星期天，1代表星期一)\\n  return dayOfWeek;\\n};\\n\\n// 判断是否为闰年\\nexport const isLeap = (year: number) =>\\n  year % 4 === 0 ? (year % 100 !== 0 ? 1 : year % 400 === 0 ? 1 : 0) : 0;\\n\\n// 获取某个月的总天数\\nexport const daysOfMonth = (year: number) => [\\n  31,\\n  28 + isLeap(year),\\n  31,\\n  30,\\n  31,\\n  30,\\n  31,\\n  31,\\n  30,\\n  31,\\n  30,\\n  31,\\n];\\n\\n// 计算每个月的日历\\nconst calculateCalendarOfMonth = (year, month) => {\\n  const calendarOfCurrentMonth = []; // 当月日历数据\\n\\n  const lastMonthYear = month === 0 ? year - 1 : year; // 上个月的年份\\n  const lastMonth = month === 0 ? 11 : month - 1; // 上个月的月份\\n  const nextMonthYear = month === 11 ? year + 1 : year; // 下个月的年份\\n  const nextMonth = month === 11 ? 0 : month + 1; // 下个月的月份\\n\\n  let dayOfWeek = getDayOfWeek(year, month, 1); // 获取月份第一天是星期几\\n  const lastMonthDays = daysOfMonth(year)[lastMonth]; // 上个月的总天数 \\n  // 日历数据最前面补齐上个月的日期\\n  for (let i = 0; i < dayOfWeek; i++) {\\n    calendarOfCurrentMonth.push({\\n      year: lastMonthYear,\\n      month: lastMonth,\\n      day: lastMonthDays - (dayOfWeek - 1 - i),\\n    });\\n  }\\n\\n  // 当月日期\\n  for (let i = 0; i < daysOfMonth(year)[month]; i++) {\\n    calendarOfCurrentMonth.push({\\n      year,\\n      month,\\n      day: i + 1,\\n    });\\n  }\\n\\n  // 计算补齐日历面板需要的天数\\n  const fillDays =\\n    calendarDaysTotalLength - calendarOfCurrentMonth.length;\\n  // 在日历后面填充下个月的日期，补齐6行\\n  for (let i = 0; i < fillDays; i++) {\\n    calendarOfCurrentMonth.push({\\n      year: nextMonthYear,\\n      month: nextMonth,\\n      day: i + 1,\\n    });\\n  }\\n\\n  // 返回日期数据。数据结构：[{year: 2022, month: 0, day: 1},{year: 2022, month: 0, day: 2}...]\\n  return calendarOfCurrentMonth;\\n};\\n```\\n\\n## 上下月切换\\n\\n从下图可以看出当从 4 月份往左滑动，将会出现 5 月份日期。同理，如果往右滑动则会展示 3 月份的日期。\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/596b531140d3440f82caea244ef0db07~tplv-k3u1fbpfcp-watermark.image?)\\n\\n因此，可得出一个结论，**一次性渲染的最佳月份数量为三个月**，分别为：当前月、上个月、下个月。且，每次切换完成之后再重新计算，即可实现用户滑动时无缝衔接。\\n\\n首先，计算出页面中需要渲染的那三个月，代码实现如下：\\n\\n```js\\nconst lastMonthYear = 0; // 上个月的年份\\nconst lastMonth = 0; // 上个月的月份\\nconst nextMonthYear = 0; // 下个月的年份\\nconst nextMonth = 0; // 下个月的月份\\nconst calendarOfMonthShow = ref([]);// 用于组件渲染的全部日期数据\\n\\n// 以当前入参月份为基准，计算三个月份的日历信息\\nconst calculateCalendarOfThreeMonth = (year, month) => {\\n  lastMonthYear = month === 0 ? year - 1 : year; // 上个月的年份\\n  lastMonth = month === 0 ? 11 : month - 1; // 上个月的月份\\n  nextMonthYear = month === 11 ? year + 1 : year; // 下个月的年份\\n  nextMonth = month === 11 ? 0 : month + 1; // 下个月的月份\\n\\n  // 首月数据（上个月）\\n  const firstMonth = calculateCalendarOfMonth(lastMonthYear, lastMonth);\\n  // 第二个月数据（当前展示的月份）\\n  const secondMonth = calculateCalendarOfMonth(year, month);\\n  // 第三个月数据（下个月）\\n  const thirdMonth = calculateCalendarOfMonth(nextMonthYear, nextMonth);\\n\\n  calendarOfMonthShow.value = [firstMonth, secondMonth, thirdMonth];\\n};\\n```\\n\\n然后，在此基础上编写月份切换方法，代码实现如下：\\n\\n```js\\n// 获取上个月日历\\nconst getLastMonth = () => {\\n  calculateCalendarOfThreeMonth(lastMonthYear, lastMonth);\\n};\\n\\n// 获取下个月日历\\nconst getNextMonth = () => {\\n  calculateCalendarOfThreeMonth(nextMonthYear, nextMonth);\\n};\\n```\\n\\n## 自定义周起始星期\\n\\n目前市面上存在以下两种类型的日历。一种是以星期一为起始星期，另一种是以星期日为起始星期：\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/31e0f21faf6f4e2ab3039e34b3eb1ada~tplv-k3u1fbpfcp-watermark.image?)\\n\\n那如果要适配这两种展现形式，对日历数据的生成影响大不大？是不是意味着刚刚那个生成日历数据的方法要大改？其实不然，改动点非常小，只需要对 `calculateCalendarOfMonth` 方法进行修改即可，插入以下代码：\\n\\n```js\\n  // 加入起始星期的判断\\n  if (dayOfWeek < props.weekStartIndex) {\\n    dayOfWeek = 7 - props.weekStartIndex + dayOfWeek;\\n  } else {\\n    dayOfWeek -= props.weekStartIndex;\\n  }\\n```\\n\\n插入位置为：\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f43165c38194843829de95bde86c05a~tplv-k3u1fbpfcp-watermark.image?)\\n\\n上述代码中 `props.weekStartIndex` 为组件接收的 props 属性，具体的定义为：0 代表星期天，1 代表星期一，以此类推。这样做的话，不仅支持以星期一和星期日开头，他支持以任意星期开头（虽然没有没见过这样的需求，但是万一有个拥有奇葩思维的产品呢^-^）。如下图所示：\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b70a7ab142734d78a60d9de68c78e9d0~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## 周月切换\\n\\n这个日历除了支持左右滑动，还支持上下滑动。上下滑动支持切换周/月展示面板。那咱们来具体分析一下这个交互。\\n\\n总体上来看，分以下三种情况，我们要做的就是隐藏红框中的部分。\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb746a52df2849a3b484371a2c98eb3c~tplv-k3u1fbpfcp-watermark.image?)\\n\\n这里的实现方案大致上分为两种：\\n\\n1. 在往上滑动时，将数据源由三个月份的数据切换为三个星期的数据（跟月份数据的形式一样，保留上个星期、本星期、下个星期的数据即可）。这种方案在后续左右滑动切换星期时，处理起来会比较方便，但是周月切换的动画效果不连贯。\\n2. 在往上滑动时，保持数据源不变。只要样式上做处理，控制随着手指的滑动，除当前星期之外的布局慢慢消失。这样做的好处是，周月切换的动画效果非常连贯，没有突兀感。只是在数据处理的时候需要花点功夫。\\n\\n我这边采用的是第二种方案，**需要准确的知道当前星期处于日历面板的第几行**，然后再隐藏其他行。具体的代码实现如下：\\n\\n```js\\n// 解构出当前选中的月份及日期\\nconst { month, day } = currentMonthDay;\\n// 当前日历面板中所有的day数据\\nconst daysArr: number[] = [];\\ncalendarOfMonth.value[1].forEach((item) => {\\n  daysArr.push(item.day);\\n});\\nlet dayIndexOfMonth = daysArr.indexOf(day);\\n// 当day为月底的天数时，有可能在daysArr的前面也存在上一个月对应的日期，所以需要取lastIndexOf\\nif (day > 15) {\\n  dayIndexOfMonth = daysArr.lastIndexOf(day);\\n}\\n\\n// 计算当前日期在第几行\\nconst indexOfLine = Math.ceil((dayIndexOfMonth + 1) / 7);\\n```\\n\\n以上代码仅包含 **当前日期在第几行** 的计算逻辑，完整的周月切换代码可以前往 [GitHub](https://github.com/TangSY/vue3-hash-calendar) 查看源码.\\n\\n## 易用性\\n\\n什么是易用性？通俗点来讲就是：**当某个人看中了你的组件，想要把它引入项目中使用时的难易程度**。主要可以通过以下两个方面来降低使用者的上手成本：\\n\\n第一，**详细的文档**。那么达到了什么样的标准才叫详细的文档呢，我认为最少应该包含这几点：\\n\\n1. 文档需要列举每个 API 对应的不同使用方法；\\n2. 文档需要附上每种使用方法的 demo 代码；\\n3. 每个 demo 代码需要做到复制即可用。也就是说需要保证 demo 代码的完整性，不能说使用方复制之后还得引入个 XX 组件，还得自行编写 XX 样式代码，或者还得在复制的代码外层包裹 XX 元素之后才能正常使用。\\n4. 每个 demo 示例都需要有对应的渲染效果。\\n5. 需要保证使用方在复制 demo 示例之后的呈现效果，与其在文档上对应的渲染效果完全一致。别搞的货不对版。\\n\\n第二，**合理的 API 设计**。那这个的标准是什么呢？简单来说就是让使用者在接入时，所写的代码越少越好，使用的属性越少越好。最理想的状态就是：只需要引入组件，不添加任何额外属性即可完整体验该组件的基本功能。组件所设计的 API 是为了给组件达到锦上添花的效果，是给组件增强功能用的，这样的话，他们可以根据当前的需求选择性的查看对应 API。而不应该一开始就让使用方写一堆的属性配置才能达到可用状态，这会极大的增加使用方的心智负担，看得头都大了，甚至就直接放弃使用了。\\n\\n## 可扩展性\\n\\n这里聊的可扩展性指的是组件可定制化的程度。Vue 组件的可扩展性主要体现在 slot 的设计上，slot 设计的细粒度越小，组件的可扩展性就越高。当然，也并不是越小越好，以我理解的最佳实践就是按组件的最小功能块来划分。此方法不一定业界最佳，欢迎评论区探讨！下面以本文日历组件为例，看看 slot 是如何设计的：\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c589b207464a47a3a4e85fab8fbe56bb~tplv-k3u1fbpfcp-watermark.image?)\\n\\n从上图中可以看出，总共设计了 5 个 slot，分别为：1、今天按钮；2、确定按钮；3、整个标题栏（操作栏）；4、星期栏；5、日历每一天的日期。\\n\\n这样做的好处就是，不管使用方要改日历中的哪一块内容都可以轻松实现。例如：本日历并不直接提供农历/节假日的功能，但却可以通过上图中的 5 号插槽来实现。\\n\\n## 可维护性\\n\\n组件的可维护性主要体现在以下四个方面：\\n\\n1. **代码结构清晰**。新成员可以快速的理解子组件之间的逻辑；\\n2. **规范化命名**。即使不查看的注释的情况下，也能通过名称看出该变量/函数的用途；\\n3. **子组件/函数职责单一**。这个能有效的防止代码屎山的形成；\\n4. **完善的单元测试**。能够很好的避免“改好一个 bug 的同时，引起以前正常的逻辑无法正确执行”；\\n\\n接下来，以本案例做一个反例。\\n\\n## 改进计划\\n\\n对于本案例中的日历源码，其实还是有改进空间的，主要体现在可维护性方面。\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/34da36929175408a899e05403137934c~tplv-k3u1fbpfcp-watermark.image?)\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a8655011ebc40e7b1fcac29eb2d1fe7~tplv-k3u1fbpfcp-watermark.image?)\\n\\n可以看到，这两个子组件的代码行数都来到了 800 -1000 行，估计冲进去的看源码的小伙伴个个都破口大骂了，哈哈哈。而且里面的逻辑，在我看来还是比较混乱的，有很大的优化空间。**主要的问题就是子组件拆分的细粒度不够以及 props 组织的不够好**。不过呢，已经在重构了，后续计划分享一下重构的过程以及感悟。\\n\\n## 同系列往期文章\\n\\n[组件库从开发到维护全链路讲解（一）基础框架的搭建](https://juejin.cn/post/7189065824504643621)\\n\\n# 总结\\n\\n到此，日历组件的核心逻辑与设计思路的讲解就完成了，下篇咱们一起来看看如何高效实现的主题换肤。\\n\\n对此系列感兴趣的，不妨一键三连（点赞 + 关注 + 收藏），方便跟进后续文章。\\n\\n欢迎在评论区留下大家宝贵的建议！\\n\\n---\\n\\n作者：HashTang\\n\\n个人空间：[hxkj.vip](https://hxkj.vip)\\n\\nGitHub 主页：[github.com/TangSY](https://github.com/TangSY)\\n"
    },
    {
        "article_id": "7189459383041359933",
        "cover_image": "",
        "title": "深入理解 go sync.Map - 基本原理",
        "brief": "go 里面如果需要并发读写 map，我们可以采用 map 配合互斥锁的方式。又或者使用 sync.Map，本文就探讨一下sync.Map 的一些基本原理及用法。",
        "user_name": "eleven26",
        "view_count": 2098,
        "collect_count": 5,
        "comment_count": 0,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/63902aab0d2cb93d3bc92df504a1d98d~300x300.image",
        "category": "后端",
        "content": "我们知道，go 里面提供了 `map` 这种类型让我们可以存储键值对数据，但是如果我们在并发的情况下使用 `map` 的话，就会发现它是不支持并发地进行读写的（会报错）。\\n在这种情况下，我们可以使用 `sync.Mutex` 来保证并发安全，但是这样会导致我们在读写的时候，都需要加锁，这样就会导致性能的下降。\\n除了使用互斥锁这种相对低效的方式，我们还可以使用 `sync.Map` 来保证并发安全，它在某些场景下有比使用 `sync.Mutex` 更高的性能。\\n本文就来探讨一下 `sync.Map` 中的一些大家比较感兴趣的问题，比如为什么有了 `map` 还要 `sync.Map`？它为什么快？`sync.Map` 的适用场景（注意：不是所有情况下都快。）等。\\n\\n关于 `sync.Map` 的设计与实现原理，会在下一篇中再做讲解。\\n\\n## map 在并发下的问题\\n\\n如果我们看过 `map` 的源码，就会发现其中有不少会引起 `fatal` 错误的地方，比如 `mapaccess1`（从 `map` 中读取 `key` 的函数）里面，如果发现正在写 `map`，则会有 `fatal` 错误。\\n（如果还没看过，可以跟着这篇 [《go map 设计与实现》](https://juejin.cn/post/7177582930313609273) 看一下）\\n\\n```go\\nif h.flags&hashWriting != 0 {\\n    fatal(\\\"concurrent map read and map write\\\")\\n}\\n```\\n\\n### map 并发读写异常的例子\\n\\n下面是一个实际使用中的例子：\\n\\n```go\\nvar m = make(map[int]int)\\n\\n// 往 map 写 key 的协程\\ngo func() {\\n   // 往 map 写入数据\\n    for i := 0; i < 10000; i++ {\\n        m[i] = i\\n    }\\n}()\\n\\n// 从 map 读取 key 的协程\\ngo func() {\\n   // 从 map 读取数据\\n    for i := 10000; i > 0; i-- {\\n        _ = m[i]\\n    }\\n}()\\n\\n// 等待两个协程执行完毕\\ntime.Sleep(time.Second)\\n```\\n\\n这会导致报错：\\n\\n```\\nfatal error: concurrent map read and map write\\n```\\n\\n这是因为我们同时对 `map` 进行读写，而 `map` 不支持并发读写，所以会报错。如果 `map` 允许并发读写，那么可能在我们使用的时候会有很多错乱的情况出现。\\n（具体如何错乱，我们可以对比多线程的场景思考一下，本文不展开了）。\\n\\n### 使用 sync.Mutex 保证并发安全\\n\\n对于 `map` 并发读写报错的问题，其中一种解决方案就是使用 `sync.Mutex` 来保证并发安全，\\n但是这样会导致我们在读写的时候，都需要加锁，这样就会导致性能的下降。\\n\\n使用 `sync.Mutex` 来保证并发安全，上面的代码可以改成下面这样：\\n\\n```go\\nvar m = make(map[int]int)\\n// 互斥锁\\nvar mu sync.Mutex\\n\\n// 写 map 的协程\\ngo func() {\\n    for i := 0; i < 10000; i++ {\\n        mu.Lock() // 写 map，加互斥锁\\n        m[i] = i\\n        mu.Unlock()\\n    }\\n}()\\n\\n// 读 map 的协程序\\ngo func() {\\n    for i := 10000; i > 0; i-- {\\n        mu.Lock() // 读 map，加互斥锁\\n        _ = m[i]\\n        mu.Unlock()\\n    }\\n}()\\n\\ntime.Sleep(time.Second)\\n```\\n\\n这样就不会报错了，但是性能会有所下降，因为我们在读写的时候都需要加锁。（如果需要更高性能，可以继续读下去，不要急着使用 `sync.Mutex`）\\n\\n> `sync.Mutex` 的常见的用法是在结构体中嵌入 `sync.Mutex`，而不是定义独立的两个变量。\\n\\n### 使用 sync.RWMutex 保证并发安全\\n\\n在上一小节中，我们使用了 `sync.Mutex` 来保证并发安全，但是在读和写的时候我们都需要加互斥锁。\\n这就意味着，**就算多个协程进行并发读，也需要等待锁**。\\n但是互斥锁的粒度太大了，但实际上，并发读是没有什么太大问题的，应该被允许才对，**如果我们允许并发读，那么就可以提高性能**。\\n\\n当然 go 的开发者也考虑到了这一点，所以在 `sync` 包中提供了 `sync.RWMutex`，这个锁可以允许进行并发读，但是写的时候还是需要等待锁。\\n也就是说，**一个协程在持有写锁的时候，其他协程是既不能读也不能写的，只能等待写锁释放才能进行读写**。\\n\\n使用 `sync.RWMutex` 来保证并发安全，我们可以改成下面这样：\\n\\n```go\\nvar m = make(map[int]int)\\n// 读写锁（允许并发读，写的时候是互斥的）\\nvar mu sync.RWMutex\\n\\n// 写入 map 的协程\\ngo func() {\\n    for i := 0; i < 10000; i++ {\\n        // 写入的时候需要加锁\\n        mu.Lock()\\n        m[i] = i\\n        mu.Unlock()\\n    }\\n}()\\n\\n// 读取 map 的协程\\ngo func() {\\n    for i := 10000; i > 0; i-- {\\n        // 读取的时候需要加锁，但是这个锁是读锁\\n        // 多个协程可以同时使用 RLock 而不需要等待\\n        mu.RLock()\\n        _ = m[i]\\n        mu.RUnlock()\\n    }\\n}()\\n\\n// 另外一个读取 map 的协程\\ngo func() {\\n    for i := 20000; i > 10000; i-- {\\n        // 读取的时候需要加锁，但是这个锁是读锁\\n        // 多个协程可以同时使用 RLock 而不需要等待\\n        mu.RLock()\\n        _ = m[i]\\n        mu.RUnlock()\\n    }\\n}()\\n\\ntime.Sleep(time.Second)\\n```\\n\\n这样就不会报错了，而且性能也提高了，因为我们在读的时候，不需要等待锁。\\n\\n说明：\\n\\n* **多个协程**可以同时使用 `RLock` 而不需要等待，这是读锁。\\n* **只有一个协程**可以使用 `Lock`，这是写锁，有写锁的时候，其他协程不能读也不能写。\\n* 持有写锁的协程，可以使用 `Unlock` 来释放锁。\\n* 写锁释放之后，其他协程才能获取到锁（读锁或者写锁）。\\n\\n也就是说，使用 `sync.RWMutex` 的时候，读操作是可以并发执行的，但是写操作是互斥的。\\n这样一来，相比 `sync.Mutex` 来说等待锁的次数就少了，自然也就能获得更好的性能了。\\n\\n> gin 框架里面就使用了 `sync.RWMutex` 来保证 `Keys` 读写操作的并发安全。\\n\\n## 有了读写锁为什么还要有 sync.Map？\\n\\n通过上面的内容，我们知道了，有下面两种方式可以保证并发安全：\\n\\n* 使用 `sync.Mutex`，但是这样的话，读写都是互斥的，性能不好。\\n* 使用 `sync.RWMutex`，可以并发读，但是写的时候是互斥的，性能相对 `sync.Mutex` 要好一些。\\n\\n但是就算我们使用了 `sync.RWMutex`，也还是有一些锁的开销。那么我们能不能再优化一下呢？答案是可以的。那就是使用 `sync.Map`。\\n\\n> `sync.Map` 在锁的基础上做了进一步优化，在一些场景下使用原子操作来保证并发安全，性能更好。\\n\\n### 使用原子操作替代读锁\\n\\n但是就算使用 `sync.RWMutex`，读操作依然还有锁的开销，那么有没有更好的方式呢？\\n答案是有的，就是使用原子操作来替代读锁。\\n\\n举一个很常见的例子就是多个协程同时读取一个变量，然后对这个变量进行累加操作：\\n\\n```go\\nvar a int32\\n\\nvar wg sync.WaitGroup\\nwg.Add(2)\\n\\ngo func() {\\n    for i := 0; i < 10000; i++ {\\n        a++\\n    }\\n    wg.Done()\\n}()\\n\\ngo func() {\\n    for i := 0; i < 10000; i++ {\\n        a++\\n    }\\n    wg.Done()\\n}()\\n\\nwg.Wait()\\n\\n// a 期望结果应该是 20000才对。\\nfmt.Println(a) // 实际：17089，而且每次都不一样\\n```\\n\\n这个例子中，我们期望的结果是 `a` 的值是 `20000`，但是实际上，每次运行的结果都不一样，而且都不会等于 `20000`。\\n其中很简单粗暴的一种解决方法是加锁，但是这样的话，性能就不好了，但是我们可以使用原子操作来解决这个问题：\\n\\n```go\\nvar a atomic.Int32\\n\\nvar wg sync.WaitGroup\\nwg.Add(2)\\n\\ngo func() {\\n    for i := 0; i < 10000; i++ {\\n        a.Add(1)\\n    }\\n    wg.Done()\\n}()\\n\\ngo func() {\\n    for i := 0; i < 10000; i++ {\\n        a.Add(1)\\n    }\\n    wg.Done()\\n}()\\n\\nwg.Wait()\\n\\nfmt.Println(a.Load()) // 20000\\n```\\n\\n### 锁跟原子操作的性能差多少？\\n\\n我们来看一下，使用锁和原子操作的性能差多少：\\n\\n```go\\nfunc BenchmarkMutexAdd(b *testing.B) {\\n   var a int32\\n   var mu sync.Mutex\\n\\n   for i := 0; i < b.N; i++ {\\n      mu.Lock()\\n      a++\\n      mu.Unlock()\\n   }\\n}\\n\\nfunc BenchmarkAtomicAdd(b *testing.B) {\\n   var a atomic.Int32\\n   for i := 0; i < b.N; i++ {\\n      a.Add(1)\\n   }\\n}\\n```\\n\\n结果：\\n\\n```\\nBenchmarkMutexAdd-12       100000000          10.07 ns/op\\nBenchmarkAtomicAdd-12      205196968           5.847 ns/op\\n```\\n\\n我们可以看到，使用原子操作的性能比使用锁的性能要好一些。\\n\\n也许我们会觉得上面这个例子是写操作，那么读操作呢？我们来看一下：\\n\\n```go\\nfunc BenchmarkMutex(b *testing.B) {\\n   var mu sync.RWMutex\\n\\n   for i := 0; i < b.N; i++ {\\n      mu.RLock()\\n      mu.RUnlock()\\n   }\\n}\\n\\nfunc BenchmarkAtomic(b *testing.B) {\\n   var a atomic.Int32\\n   for i := 0; i < b.N; i++ {\\n      _ = a.Load()\\n   }\\n}\\n```\\n\\n结果：\\n\\n```\\nBenchmarkMutex-12      100000000          10.12 ns/op\\nBenchmarkAtomic-12     1000000000          0.3133 ns/op\\n```\\n\\n我们可以看到，使用原子操作的性能比使用锁的性能要好很多。而且在 `BenchmarkMutex` 里面甚至还没有做读取数据的操作。\\n\\n### sync.Map 里面的原子操作\\n\\n`sync.Map` 里面相比 `sync.RWMutex`，性能更好的原因就是使用了原子操作。\\n在我们从 `sync.Map` 里面读取数据的时候，会先使用一个原子 `Load` 操作来读取 `sync.Map` 里面的 `key`（从 `read` 中读取）。\\n注意：这里拿到的是 `key` 的一份快照，我们对其进行读操作的时候也可以同时往 `sync.Map` 中写入新的 `key`，这是保证它高性能的一个很关键的设计（类似读写分离）。\\n\\n`sync.Map` 里面的 `Load` 方法里面就包含了上述的流程：\\n\\n```go\\n// Load 方法从 sync.Map 里面读取数据。\\nfunc (m *Map) Load(key any) (value any, ok bool) {\\n   // 先从只读 map 里面读取数据。\\n   // 这一步是不需要锁的，只有一个原子操作。\\n   read := m.loadReadOnly()\\n   e, ok := read.m[key]\\n   if !ok && read.amended { // 如果没有找到，并且 dirty 里面有一些 read 中没有的 key，那么就需要从 dirty 里面读取数据。\\n      // 这里才需要锁\\n      m.mu.Lock()\\n      read = m.loadReadOnly()\\n      e, ok = read.m[key]\\n      if !ok && read.amended {\\n         e, ok = m.dirty[key]\\n         m.missLocked()\\n      }\\n      m.mu.Unlock()\\n   }\\n   \\n   // key 不存在\\n   if !ok {\\n      return nil, false\\n   }\\n   // 使用原子操作读取\\n   return e.Load()\\n}\\n```\\n\\n上面的代码我们可能还看不懂，但是没关系，这里我们只需要知道的是，**从 sync.Map 读取数据的时候，会先做原子操作，如果没找到，再进行加锁操作，这样就减少了使用锁的频率了，自然也就可以获得更好的性能（但要注意的是并不是所有情况下都能获得更好的性能）**。至于具体实现，在下一篇文章中会进行更加详细的分析。\\n\\n**也就是说，sync.Map 之所以更快，是因为相比 RWMutex，进一步减少了锁的使用，而这也就是 sync.Map 存在的原因了**\\n\\n## sync.Map 的基本用法\\n\\n现在我们知道了，`sync.Map` 里面是利用了原子操作来减少锁的使用。但是我们好像连 `sync.Map` 的一些基本操作都还不了解，现在就让我们再来看看 `sync.Map` 的基本用法。\\n\\n`sync.Map` 的使用还是挺简单的，`map` 中有的操作，在 `sync.Map` 都有，只不过区别是，在 `sync.Map` 中，所有的操作都需要通过调用其方法来进行。\\n`sync.Map` 里面几个常用的方法有（`CRUD`）：\\n\\n* `Store`：我们新增或者修改数据的时候，都可以使用 `Store` 方法。\\n* `Load`：读取数据的方法。\\n* `Range`：遍历数据的方法。\\n* `Delete`：删除数据的方法。\\n\\n```go\\nvar m sync.Map\\n\\n// 写入/修改\\nm.Store(\\\"foo\\\", 1)\\n\\n// 读取\\nfmt.Println(m.Load(\\\"foo\\\")) // 1 true\\n\\n// 遍历\\nm.Range(func(key, value interface{}) bool {\\n    fmt.Println(key, value) // foo 1\\n    return true\\n})\\n\\n// 删除\\nm.Delete(\\\"foo\\\")\\nfmt.Println(m.Load(\\\"foo\\\")) // nil false\\n```\\n\\n注意：在 `sync.Map` 中，`key` 和 `value` 都是 `interface{}` 类型的，也就是说，我们可以使用任意类型的 `key` 和 `value`。\\n而不像 `map`，只能存在一种类型的 `key` 和 `value`。从这个角度来看，它的类型类似于 `map[any]any`。\\n\\n另外一个需要注意的是，`Range` 方法的参数是一个函数，这个函数如果返回 `false`，那么遍历就会停止。\\n\\n## sync.Map 的使用场景\\n\\n在 `sync.Map` 源码中，已经告诉了我们 `sync.Map` 的使用场景：\\n\\n```\\nThe Map type is optimized for two common use cases: (1) when the entry for a given\\nkey is only ever written once but read many times, as in caches that only grow,\\nor (2) when multiple goroutines read, write, and overwrite entries for disjoint\\nsets of keys. In these two cases, use of a Map may significantly reduce lock\\ncontention compared to a Go map paired with a separate Mutex or RWMutex.\\n```\\n\\n翻译过来就是，Map 类型针对两种常见用例进行了优化：\\n\\n* 当给定 `key` 的条目只写入一次但读取多次时，如在只会增长的缓存中。（读多写少）\\n* 当多个 goroutine 读取、写入和覆盖不相交的键集的条目。（不同 goroutine 操作不同的 key）\\n\\n在这两种情况下，与 Go `map` 与单独的 `Mutex` 或 `RWMutex` 配对相比，使用 `sync.Map` 可以显著减少锁竞争（很多时候只需要原子操作就可以）。\\n\\n## 总结\\n\\n* 普通的 `map` 不支持并发读写。\\n* 有以下两种方式可以实现 `map` 的并发读写：\\n  * 使用 `sync.Mutex` 互斥锁。读和写的时候都使用互斥锁，性能相比 `sync.RWMutex` 会差一些。\\n  * 使用 `sync.RWMutex` 读写锁。读的锁是可以共享的，但是写锁是独占的。性能相比 `sync.Mutex` 会好一些。\\n* `sync.Map` 里面会先进行原子操作来读取 `key`，如果读取不到的时候，才会需要加锁。所以性能相比 `sync.Mutex` 和 `sync.RWMutex` 会好一些。\\n* `sync.Map` 里面几个常用的方法有（`CRUD`）：\\n  * `Store`：我们新增或者修改数据的时候，都可以使用 `Store` 方法。\\n  * `Load`：读取数据的方法。\\n  * `Range`：遍历数据的方法。\\n  * `Delete`：删除数据的方法。\\n* `sync.Map` 的使用场景，`sync.Map` 针对以下两种场景做了优化：\\n  * `key` 只会写入一次，但是会被读取多次的场景。\\n  * 多个 goroutine 读取、写入和覆盖不相交的键集的条目。"
    },
    {
        "article_id": "7184012075411177527",
        "cover_image": "",
        "title": "2022 年：我在死亡边缘走过",
        "brief": "当我躺在核磁共振机器里，就像科幻电影中的冷冻仓，我希望自己被封印在里面，睡个几百年。 我并没有写年终总结的习惯，以前也从来没写过。",
        "user_name": "前端技术砖家",
        "view_count": 5810,
        "collect_count": 13,
        "comment_count": 19,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/1aa4b1e03382c418c9742465900a0881~300x300.image",
        "category": "前端",
        "content": "![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2dc625b630824e60b9a14b94baeea735~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n> 当我躺在核磁共振机器里，就像科幻电影中的冷冻仓，我希望自己被封印在里面，睡个几百年。\\n\\n我并没有写年终总结的习惯，以前也从来没写过。\\n\\n一来是因为我总是觉得农历新年才是一年的开始，另外就是觉得给自己定新年目标也是一定完不成的~\\n\\n今年有点例外，我想写点东西，总结下 2022 年，让它赶紧过去。Never see you 2022~\\n\\n## 1. 死亡\\n\\n十二月的某个周日晚上，我正在快乐的玩手机玩电脑，慢慢的发现胳膊没有力气，拿不动手机了，手指也几乎打不出来字了。大约 10 分钟之后，全身已经没有力气了，从椅子上站起来都吃力。\\n\\n然后就喊我爸爸开车带我去医院急诊，住院了一星期。\\n\\n当时的感受就像一只充满气的气球，被戳了一个大口子，气在飞快的跑，气球越来越软，但气球没有任何办法。\\n\\n过去 30 年，我的身体一直很健康，完全没有任何征兆。不夸张的说，我当时觉得自己要完蛋了，甚至和我老婆交代了一些事情。\\n\\n这件事情对我的影响非常大，我希望 2022 年赶快过去，走好不送。\\n\\n经历过这件事情之后，想和大家分享一些我的想法。\\n\\n### 1.1 及时享乐\\n\\n上帝给了我们几十年的健康时光，我们碌碌无为。\\n上帝给了我们一周的痛苦，我们开始后悔没有好好享受生活。\\n\\n这件事情给我最大的一个感受就是，珍惜健康的时间，玩好享受好。\\n\\n我列了一份人生想做的事情清单，也会让家里人每人列一份。如果能把清单处理完，那以后出现最坏的事情，也不会后悔了。\\n\\n### 1.2 透明\\n\\n夫妻之间要完全透明，这样在意外到来的时候，没有后顾之忧。\\n\\n第一，我会经常和老婆交流我对生死的看法，我对死亡这种事情看的很淡，死了说不定比活着舒服。\\n\\n第二，我每个月会统计自己的资产状况，并记录在某软件上，我老婆可以很清楚的知道我有多少钱、分别放在哪里。同时我的各种账号密码，都对我老婆透明公开。\\n\\n当时我给老婆说了一句话：“如果出现最坏的结果，我的钱在哪里你都知道。另外就是这种事情我看的很淡”。\\n\\n### 1.3 莫生气\\n\\n电视剧《天道》（小说《遥远的救世主》改编）中有这样一个情节：\\n\\n男主丁元英在路边小摊吃饭，已经付过了一元饭钱，但吃完后摊主说没给钱。丁元英呆了一下，又付了一块钱。\\n\\n当时看到这里，我大受震撼，不要和不值当的人生气。\\n\\n之前在杭州租房子，物业女打电话说卫生间渗水到隔壁去了，让我打电话给隔壁房东处理。\\n\\n我的意思是让隔壁房东加我微信，看看怎么处理。\\n\\n物业女没有理我，第二天打电话指责我为什么没有联系隔壁房东，并且再次强调让我联系隔壁房东。\\n\\n按我以前的性格，我 100% 不会主动联系隔壁房东，并且会继续和物业女吵几次架。\\n\\n后来我想了想，我为什么要和物业女生气呢？这样搞下去未来几天的心情都会很糟糕的，于是我直接联系了隔壁房东，再也不用和物业女打交道了。\\n\\n有个小伙伴说不敢写文章，因为每次发出去都会被喷。我自己以前也会膈应，但现在没啥特殊的感觉了，很多喷子评论我看都不看。\\n\\n去年和好几个朋友分享过上面的故事，这件事情过后，感触更深，不要和不值当的人生气，当成空气忽略掉就可以了。\\n\\n### 1.4 健康第一\\n\\n以前每次下定决心锻炼，能坚持 2 天就算不错了。\\n\\n经历过这个事情之后，锻炼已经不用下决心了。\\n\\n我热爱运动~\\n\\n## 2. 工作\\n\\n工作上，今年是主动求变的一年，也终于想清楚了未来几年的发展方向。\\n\\n年初，团队大调整，由于我们组的业务夕阳红，所以整个组被拆掉了，我被调动去做一块新业务，但个人兴趣不是很大。\\n\\n在这个契机下，我好好思考了自己想做什么，确定了「区块链」行业大方向。\\n\\n于是转岗到了蚂蚁链团队，花了好长时间学习行业知识，也算入了门。\\n\\n半年以后，因为找到了「区块链」行业更前线的机会，并且是梦寐以求的「远程办公」，所以从蚂蚁离职，加入了新的公司。\\n\\n目前入职两个月，整体感受超出预期，希望未来几年可以火力全开。\\n\\n工作 7 年以来，今年是最特殊的一年，也是变化最大的一年，希望没有选错路。生命不息，折腾不止~\\n\\n## 3. 生活\\n\\n生活上今年最大的变化就是离开了杭州，回到了老家。\\n\\n在老家农村办公了两个多月，发现并没有想象中的那么美好，有几点原因吧：\\n\\n1. 村里冬天光秃秃的，没啥好玩的\\n2. 冷，没啥地方去\\n3. 没有外卖，没有好吃的，每天只能在家吃饭\\n4. 技术上交流机会比较少，有点憋得慌\\n\\n明年还是得去大城市折腾折腾~~~~~~\\n\\n其它的就是带父母去了一次海边。疫情结束，希望明年可以带家里人去更多的地方旅游。\\n\\n## 4. 折腾\\n\\n工作之余，一直在尝试折腾各种事情。\\n\\n### 4.1 自媒体\\n\\n前几年开始搞公众号，我只是想转发一些别人的文章，吸引一些关注，然后接点广告挣钱。没想到后来慢慢发展成了原创公众号，又累又不赚钱~~\\n\\n今年听了朋友的建议，试试短视频。本来只想做每期十几秒，回答一个问题那种超短抖音视频，轻松不累。没想到阴差阳错 B 站渠道给火了，一个月涨粉接近一万个。承蒙 B 站粉丝厚爱，为了不丢脸，只能硬着头皮做了几期长视频，效果也都还可以。就是视频做起来太累了，慢慢的就鸽子了~~~\\n\\n今年整体的创作输出上，技术内容更少了，思考感悟类内容更多了。也符合自己去年的想法，希望沉淀更多的方法论出来，授人以鱼不如授人以渔。\\n\\n在自媒体上，我没给自己太大压力，想写了就写一篇，不想写就不写了，经常几个月不更新。距离上一次更文过了快两个月了，o(╥﹏╥)o\\n\\n明年希望能多一些输出，不只是文字的，视频也希望多出几期。同时仍然不会在自媒体上给自己太多压力，开心就好~\\n\\n### 4.2 创业\\n\\n今年为了学习 web3，利用闲暇时间主动找了一些项目参与。和阿里同事深度玩了一个 web3 项目，投入了一个多月空余时间，虽然最后没有结果，但让自己真正的入门了 web3，也认识了一些牛逼的人，很充实很刺激~\\n\\n这个项目 GG 之后，又和蚂蚁的几个小伙伴折腾另外的项目玩，虽然 99% 可能不会有结果，但过程真的很有趣。\\n\\n也希望在新的一年，自己可以保持热情，让空余时间发挥更大的价值，折腾就对了~\\n\\n### 4.3 看书\\n\\n今年看了大约 15 本书，各种方向的都有，已经养成了看书的习惯，非常不错~\\n以前觉得看书，看完也记不住，太累。现在的心态就是记不住就记不住，看的时候爽就行~~\\n\\n今年再接再厉，空余时间多看书~\\n\\n### 4.4 理财\\n\\n理财上，典型的韭菜一枚。\\n今年基金和股票应该在 -30% 以上，你们挣的钱都是我亏的~\\n目前投资属于放养状态，完全不管了，亏吧~\\n新的一年会多看一些投资类的书籍，让自己的亏的明白一些。\\n\\n## 5. 总结\\n\\n2022 年就这样吧，给 2023 年定一些方向：\\n\\n1. 工作上，保持热情，持续折腾，高标准要求自己\\n2. 生活上，愿望清单开始清理，多带家里人出去玩玩\\n3. 锻炼身体\\n4. 自媒体继续努力\\n5. 学习英语\\n6. 空闲时间多折腾折腾各种项目\\n7. 认识更多朋友\\n\\n> **关于作者**\\n>\\n> 砖家，brickspert\\n>\\n> 前蚂蚁集团前端技术专家\\n>\\n> 开源库 ahooks 作者，10k+ star ⭐️\\n>\\n> 开源库 antd mobile 前负责人，10k+ star ⭐️\\n>\\n> **你可以在以下渠道找到我：**\\n>\\n> 公众号：前端技术砖家\\n>\\n> B 站：前端技术砖家\\n>\\n> 知乎：砖家\\n>\\n> 掘金：前端技术砖家\\n>\\n> Github：brickspert"
    },
    {
        "article_id": "7133045617877581831",
        "cover_image": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c9e2a275bea348d1b353dd0b027908d8~tplv-k3u1fbpfcp-watermark.image?",
        "title": "【讲真!】Git进阶精选看这篇就够了",
        "brief": "明明用了5年的git，来了字节之后感觉自己好像没用过git一样。靠，我5年前端开发经验难道是假造的咩~，真的是栓q。我不管！我不管！我不管！别人都会的我也要会！",
        "user_name": "一袋米要扛几楼",
        "view_count": 69177,
        "collect_count": 2050,
        "comment_count": 174,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/bfb7838ffe85aa04052b942809fca049~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: smartblue\\nhighlight: a11y-dark\\n---\\n\\n用了5年的source tree，来了字节之后发现大家都喜欢用命令行。什么`git rebase;git rebase -i;git cherry-pick;git stash;git commit --amend;`这些只在博客里看到的命令全都变成日常了，呜呜呜，真的是栓q。`我不管！我不管！我不管！别人都会的我也要会。`经过我夜以继日的学习终于整理出了这份《Git进阶命令精选》，`再不好好学面试都不用去了，回家睡觉去吧。`\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2559d876175a40bd928b8d17aebfc02f~tplv-k3u1fbpfcp-watermark.image?)\\n### branch管理\\n- git checkout -b feat/sass-v1 origin/feat/sass-v1 // 克隆远端分支feat/sass-v1到本地\\n- git checkout -b feat/saas-0817 // 从当前分支新建一个分支feat/saas-0817\\n- git merge [branchName] 将branchName合并到当前分支\\n- git merge [branchName] --squash 将branchName合并到当前分支，并将branchName上的所有提交合并成一次提交\\n- `git commit --amend 修改上次的提交信息，push后不会增加新的commit记录，但是会修改本次的commithash(也可以理解为删掉了最新的一次commit，重新又提交了一次)`\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ab1e78e31ce4763bc8882a4cd84c25e~tplv-k3u1fbpfcp-watermark.image?)\\n```\\ngit commit --amend\\n// 修改commit msg\\n```\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f13a7cc92f1144aaa82980f1b38afb37~tplv-k3u1fbpfcp-watermark.image?)\\n- git branch -D [branchName] 删除本地分支\\n- `git push origin -D [branchName] 删除远端分支`\\n\\n### rebase branch\\n- git pull --rebase origin [branchName] = git fetch + git rebase\\n```javascript\\n// 假设当前分支dev, commit 为 a b c d e\\n// 假设master分支, commit 为 a b f g h\\ngit pull --rebase origin master\\n// 当前分支dev commit 变为 a b c d e f g h\\n```\\n- git rebase master\\n```javascript\\n// 假设当前分支dev, commit 为 a b c d e\\n// 假设master分支, commit 为 a b f g h\\ngit rebase origin/master\\n// 当前分支dev commit 变为 a b f g h c d e\\n```\\n\\n### stash贮藏代码\\n- 场景：当你的功能还没开发完不能commit但是现在需要rebase下master,缓存区的代码该咋办？当你写了几行代码，但是现在需要切到其他分支去改bug，缓存区的代码该咋办？\\n用git stash就好啦\\n- git stash 贮藏代码\\n- git stash pop 恢复到工作区和缓存区，会移除stashid\\n- git stash list 查看当前贮藏区\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef00efe2ef2e47b2b747766fb49552a8~tplv-k3u1fbpfcp-watermark.image?)\\n`注意：stash@{0} stash@{1} stash@{2} 是stashname`\\n- `git stash apply stashname  恢复指定贮藏代码到工作区和缓存区，会保留stashid`\\n- `git stash save 'msg' 带备注贮藏`\\n- git stash show -p 显示最新的贮藏文件具体改动\\n- git stash show -p stashname 显示指定的贮藏文件具体改动\\n\\n### commit\\n- git commit -m \\\"msg\\\" --no-verify 强制提交不检查\\n- git push -f 强制提交代码并以本地版本代码为主覆盖远程\\n`git push -f是不安全的，git push --force-with-lease更安全，注意--force-with-lease失败后再执行一次也会强制提交覆盖`\\n\\n### reset回退\\n- git log 查看提交日志\\n- git reset 将所有暂存区回退到工作区\\n- git checkout . 丢弃工作区所有的更改\\n- git reset --hard [commit hash] 将从commithash(不包括此hash)之后的丢弃\\n- git reset --hard 将暂存区、工作区所有内容丢弃\\n- `git reset --soft [commit hash] 将从commithash(不包括此hash)之后的提交回退到暂存区`\\n- `git reset --soft HEAD~4 回退最近4次提交到暂存区`\\n\\n### cherry-pick 复制提交\\n- 场景：当你在merge或者rebase的时候发现冲突太多了，想哭的时候，可以用原分支check目标分支处理，然后再cherry-pick当前分支的每个提交，这样冲突就会少很多。或者另一分支上有些代码还没有merge到master，但是你当前分支又非要用的时候，就可以cherry-pick过来一份。\\n- `git cherry-pick [commit hash] 将其他分支上已提交的commit在当前分支再提交一次，产生新的commithash`\\n\\n### revert\\n- git revert [commit hash] 非merge的commit\\n- git revert -m [1|2] [commit hash] merge类型的commit\\n    - 通过git show [commit hash]查看\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/410aad5921c14939946bff6a5282b37b~tplv-k3u1fbpfcp-watermark.image?)\\n\\n    - 第三行第一个hash为编号1，第二个hash为编号2，以哪个父hash为主线则保留哪个，删除另一个\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b85ed51a434341c59a69d9a1c6c863e7~tplv-k3u1fbpfcp-watermark.image?)\\n![]()\\n\\n    - git revert -m 1 bd86846 则回滚bd86846的提交，且以ba25a9d master分支为主线保留，回滚掉1c7036f 所在分支提交\\n\\n\\n### rebase -i\\n- 场景：使用merge导致git提交线乱七八糟，提交日志过多非常难看。自从使用了rebase提交线变得无比丝滑，使用rebase -i合并每个需求的所有提交成1个，使日志变得清晰\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc389dc0661948cd973b82134c53129d~tplv-k3u1fbpfcp-watermark.image?)\\n- `git rebase -i HEAD~10` 调整最近10次提交的日志、或合并多次提交为1次，让log更好看更清晰\\n\\np使用, pick = use commit \\n\\ns合并掉, squash = use commit, but meld into previous commit\\n\\n所有的提交按时间倒序排列\\n\\n被s的会合并到上一次commit,也就是当前排列的上一个里面\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c915af52cd6544f5b50dae544724ee05~tplv-k3u1fbpfcp-watermark.image?)\\n  \\n  \\n  \\n  \\n### scope\\n\\nfeat: 新功能、新特性\\n\\nfix: 修改 bug\\n\\nperf: 更改代码，以提高性能（在不影响代码内部行为的前提下，对程序性能进行优化）\\n\\nrefactor: 代码重构（重构，在不影响代码内部行为、功能下的代码修改）\\n\\ndocs: 文档修改\\n\\nstyle: 代码格式修改, 注意不是 css 修改（例如分号修改）\\n\\ntest: 测试用例新增、修改\\n\\nbuild: 影响项目构建或依赖项修改\\n\\nrevert: 恢复上一次提交\\n\\nci: 持续集成相关文件修改\\n\\nchore: 其他修改（不在上述类型中的修改）\\n\\nrelease: 发布新版本\\n\\nworkflow: 工作流相关文件修改  \\n  \\n\\n`以上仅为个人学习总结，欢迎评论讨论` \\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1230a3439d3c4022b52cca7249404ee5~tplv-k3u1fbpfcp-watermark.image?)\\n\\n`觉得不错的记得点个赞哦~` \\n\\n笑死，下面这几篇你们都不看，那你们看啥？\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b71027d7678a477e927a17d78254a865~tplv-k3u1fbpfcp-watermark.image?)\\n\\n[你不得不知的大厂问题复盘方法论](https://juejin.cn/post/6981978319143043108)\\n\\n[设计模式这样学也太简单了吧！](https://juejin.cn/post/6953423646664687652)\\n\\n[你不知道的前端软技能](https://juejin.cn/post/6926787585423933448)\\n\\n\\n\\n"
    },
    {
        "article_id": "7186464211868844093",
        "cover_image": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/213d091249594f7c92adef545271b1a2~tplv-k3u1fbpfcp-watermark.image?",
        "title": "Spring项目中用了这种解耦模式，经理对我刮目相看",
        "brief": "前言 不知道大家在项目中有没有遇到过这样的场景，根据传入的类型，调用接口不同的实现类或者说服务，比如根据文件的类型使用 CSV解析器或者JSON解析器，在调用的客户端一般都是用if else去做判断，",
        "user_name": "JAVA旭阳",
        "view_count": 9803,
        "collect_count": 174,
        "comment_count": 33,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/e7ff7e07aaf9c553f05da5741e7badfa~300x300.image",
        "category": "后端",
        "content": "---\\ntheme: cyanosis\\n---\\n## 前言\\n\\n不知道大家在项目中有没有遇到过这样的场景，根据传入的类型，调用接口不同的实现类或者说服务，比如根据文件的类型使用 CSV解析器或者JSON解析器，在调用的客户端一般都是用`if else`去做判断，比如类型等于JSON，我就用JSON解析器，那如果新加一个类型的解析器，是不是调用的客户端还要修改呢？这显然太耦合了，本文就介绍一种方法，服务定位模式`Service Locator Pattern`来解决，它帮助我们消除紧耦合实现及其依赖性，并提出将服务与其具体类解耦。\\n\\n\\n> 欢迎关注个人公众号『JAVA旭阳』交流沟通\\n\\n## 一个例子入门\\n\\n我们通过一个例子来告诉你如何使用`Service Locator Pattern`。\\n\\n假设我们有一个从各种来源获取数据的应用程序，我们必须解析不同类型的文件，比如解析CSV文件和JSON文件。\\n\\n1.  定义一个类型的枚举\\n\\n```\\npublic enum ContentType {\\n  JSON,\\n  CSV\\n}\\n```\\n\\n2.  定义一个解析的接口\\n\\n```\\npublic interface Parser {\\n  List parse(Reader r);\\n}\\n```\\n\\n3.  根据不同的文件类型有不同的实现类\\n\\n```\\n// 解析csv\\n@Component\\npublic class CSVParser implements Parser { \\n  @Override\\n  public List parse(Reader r) { .. }\\n}\\n\\n// 解析json\\n@Component\\npublic class JSONParser implements Parser {\\n  @Override\\n  public List parse(Reader r) { .. }\\n}\\n```\\n\\n4.  最后写一个调用的客户端，通过`switch case`根据不同的类型调用不同的实现\\n\\n```\\n@Service\\npublic class Client {\\n  private Parser csvParser, jsonParser;\\n    \\n  @Autowired\\n  public Client(Parser csvParser, Parser jsonParser) {\\n    this.csvParser = csvParser;\\n    this.jsonParser = jsonParser;\\n  }\\n    \\n  public List getAll(ContentType contentType) {\\n    ..\\n    \\n    switch (contentType) {\\n      case CSV:\\n        return csvParser.parse(reader);\\n      case JSON:\\n        return jsonParser.parse(reader);\\n      ..\\n    }\\n  }\\n  ..\\n}\\n```\\n\\n**可能大部分人都是像上面一样的方式实现的，也能正常运行，那深入思考下，存在什么问题吗？**\\n\\n现在假如产品经理提出了一个新需求要支持XML类型的文件，是不是客户端也要修改代码，需要在`switch case`中添加新的类型，这就导致客户端和不同的解析器**紧密耦合。**\\n\\n**那么有什么更好的方法呢？**\\n\\n## 应用Service Locator Pattern\\n\\n没错，那就是用上我们的服务定位模式`Service Locator Pattern`。\\n\\n1.  让我们定义我们的服务定位器接口`ParserFactory`， 它有一个接受内容类型参数并返回`Parser`的方法。\\n\\n```\\npublic interface ParserFactory {\\n  Parser getParser(ContentType contentType);\\n}\\n```\\n\\n2.  我们配置`ServiceLocatorFactoryBean`使用`ParserFactory`作为服务定位器接口，`ParserFactory`这个接口不需要写实现类。\\n\\n```\\n@Configuration\\npublic class ParserConfig {\\n    \\n  @Bean(\\\"parserFactory\\\")\\n  public FactoryBean serviceLocatorFactoryBean() {\\n    ServiceLocatorFactoryBean factoryBean = new ServiceLocatorFactoryBean();\\n    // 设置服务定位接口   \\n    factoryBean.setServiceLocatorInterface(ParserFactory.class);\\n    return factoryBean;\\n  }\\n\\n}\\n```\\n\\n3.  设置解析器Bean的名称为类型名称，方便服务定位\\n\\n```\\n// 设置bean的名称和类型一致\\n@Component(\\\"CSV\\\")\\npublic class CSVParser implements Parser { .. }\\n@Component(\\\"JSON\\\")\\npublic class JSONParser implements Parser { .. }\\n@Component(\\\"XML\\\")\\npublic class XMLParser implements Parser { .. }\\n```\\n\\n4.  修改枚举, 添加XML\\n\\n```\\npublic enum ContentType {\\n  JSON,\\n  CSV,\\n  XML\\n}\\n```\\n\\n5.  最后用客户端调用，直接根据类型调用对应的解析器，没有了`switch case`\\n\\n```\\n@Service\\npublic class Client {\\n  private ParserFactory parserFactory;\\n  @Autowired\\n  public Client(ParserFactory parserFactory) {\\n    this.parserFactory = parserFactory;\\n  }\\n  public List getAll(ContentType contentType) {\\n    ..\\n    // 关键点，直接根据类型获取\\n    return parserFactory\\n        .getParser(contentType)  \\n        .parse(reader);\\n  }\\n  ..\\n}\\n```\\n\\n**嘿嘿，我们已经成功地实现了我们的目标。现在再加新的类型，我们只要扩展添加新的解析器就行，再也不用修改客户端了，满足开闭原则。**\\n\\n如果你觉得Bean的名称直接使用类型怪怪的，这边可以建议你按照下面的方式来。\\n\\n```\\npublic enum ContentType {\\n  JSON(TypeConstants.JSON_PARSER),\\n  CSV(TypeConstants.CSV_PARSER),\\n  XML(TypeConstants.XML_PARSER);\\n  private final String parserName;\\n  ContentType(String parserName) {\\n    this.parserName = parserName;\\n  }\\n  \\n  @Override\\n  public String toString() {\\n    return this.parserName;\\n  }\\n  public interface TypeConstants {\\n    \\n    String CSV_PARSER = \\\"csvParser\\\";\\n    String JSON_PARSER = \\\"jsonParser\\\";\\n    String XML_PARSER = \\\"xmlParser\\\"; \\n  }\\n}\\n\\n@Component(TypeConstants.CSV_PARSER)\\npublic class CSVParser implements Parser { .. }\\n@Component(TypeConstants.JSON_PARSER)\\npublic class JSONParser implements Parser { .. }\\n@Component(TypeConstants.XML_PARSER)\\npublic class XMLParser implements Parser { .. }\\n```\\n\\n## 剖析Service Locator Pattern\\n\\n通过前面的例子，想必大家基本知道服务定位器模式如何使用了吧，现在我们深入剖析下。\\n\\n**服务定位器模式**消除了客户端对具体实现的依赖。以下引自 `Martin Fowler` 的文章总结了核心思想： “服务定位器背后的基本思想是拥有一个知道如何获取应用程序可能需要的所有服务的对象。因此，此应用程序的服务定位器将有一个在需要时返回“服务”的方法。”\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e27b164b8c1747ce91d079176ab87fde~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n`Spring` 的`ServiceLocatorFactoryBean`实现了 `FactoryBean`接口，创建了`Service Factory`服务工厂`Bean`。\\n\\n## 总结\\n\\n我们通过使用服务定位器模式实现了一种扩展 Spring 控制反转的绝妙方法。它帮助我们解决了依赖注入未提供最佳解决方案的用例。也就是说，依赖注入仍然是首选，并且在大多数情况下不应使用服务定位器来替代依赖注入。\\n\\n> 欢迎关注个人公众号『JAVA旭阳』交流沟通"
    },
    {
        "article_id": "7164939151668674596",
        "cover_image": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d54931d5b04e4400bfcf9d90131f18e3~tplv-k3u1fbpfcp-watermark.image?",
        "title": "手把手教你轻松手写防抖和节流🔥",
        "brief": "面试官：“知道防抖和节流吗，简单地说说。” 此时我心中窃喜，这么简单，有手就行。然后就开始介绍起防抖节流的知识点。 我：“防抖是....，然后节流是....，它们的应用场景在....”",
        "user_name": "一条会coding的Shark",
        "view_count": 3941,
        "collect_count": 78,
        "comment_count": 15,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/4798dc1db39238560a22e2b3ef73010a~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: fancy\\n---\\n***本文正在参加[「金石计划 . 瓜分6万现金大奖」](https://juejin.cn/post/7162096952883019783 \\\"https://juejin.cn/post/7162096952883019783\\\")***\\n\\n## 起源\\n\\n面试官：“知道防抖和节流吗，简单地说说。”  \\n\\n此时我心中窃喜，这么简单，有手就行。然后就开始介绍起防抖节流的知识点。 \\n\\n我：“防抖是....，然后节流是....，它们的应用场景在....”\\n\\n能说的东西都说到了，能覆盖的知识点都覆盖到了，结果面试官来一句：“嗯嗯好，给我手写一下防抖节流。”\\n\\n这一刻我愣住了：“让我手写这两个....，我不会呀....”  \\n\\n最后结果可想而知。\\n\\n于是乎，我便重整旗鼓，来面对这两座对我之前而言的大山 — 防抖和节流。\\n\\n## 防抖\\n顾名思义，我们可以将防抖理解为是防止抖动。当我们在频繁地触发一个事件时，会引起不必要的性能损失，那么我们需要做的是让事件在停止触发后再触发，以此减少性能损失。\\n\\n防抖就是要延迟执行，我们一直操作触发事件并且不执行，只有当停止操作后等才会执行。\\n\\n**防抖函数**的作用是控制函数在一定时间内的执行次数。简单点说就是通过防抖函数让某个触发事件在 `n` 秒内只会被执行一次。\\n\\n## 节流\\n节流是指绑定事件后，通过动作触发事件，在这段时间内，如果动作又发生，忽略该动作，一直到事件执行完后才能重新触发。通俗的说就是控制高频执行的次数。\\n\\n**节流函数**的作用是在一个单位时间内最多只能触发一次函数执行，如果这个单位时间内多次触发函数，只能有一次生效。\\n\\n## 应用场景\\n可能这样描述对刚接触防抖节流的小伙伴来说会有些不好完全理解，接下来通过分析一下它们的应用场景来深化它们的概念。\\n\\n### 防抖应用场景\\n\\n防抖适合多次事件一次响应的情况。\\n\\n比较典型的有搜索事件，用户在不断输入值时，用防抖来节约请求资源，只有最后一次回车才能返回结果。还有按钮点击事件，为了防止用户多次重复提交也会使用防抖函数。最后就是部分的电话号码输入的验证，要等停止输入后才会进行一次验证。 \\n\\n### 节流应用场景\\n\\n节流适合大量事件按时间做平均分配触发。\\n\\n比较典型的有监听滚动或 `resize` 事件，比如是否滑到底部自动加载更多，调整窗口大小。另外还有一个就是像掘金写文章这里一样，有自动保存功能，我们一边写，它可以一边保存。剩下就比如说 `DOM` 元素拖拽，以及游戏中的刷新率都是会使用到节流函数的。\\n\\n## 手写防抖节流\\n\\n介绍了它们的理论基础知识和应用场景后，现在来手写一下它们吧。\\n\\n```\\n// 防抖（简单版本）\\nfunction debounce(fn, delay) {\\n    let timer = null;\\n    clearTimeout(timer); // 下次调用时会清除上次的timer， 然后重新延迟\\n    timer = setTimeout(function(){\\n        fn();\\n    }, delay);\\n} \\n\\n// 防抖（立即执行版本）\\nfunction debounce(fn, wait) {\\n    let timer = null\\n    return function () {\\n        let args = arguments\\n        let now = !timer\\n        timer && clearTimeout(timer)\\n        timer = setTimeout(() => {\\n            timer = null\\n        }, wait)\\n        if (now) {\\n            fn.apply(this, args)\\n        }\\n    }\\n}\\n\\n// 节流（定时器版本）\\nfunction throttle(fn, wait) {\\n    let timer = null\\n    return function () {\\n        let context = this\\n        let args = arguments\\n        if (!timer) {\\n            timer = setTimeout(() => {\\n                timer = null\\n                fn.apply(context, args)\\n            }, wait)\\n        }\\n    }\\n}\\n```\\n防抖和节流的核心就是定时器，通过配合定时器来完成防抖节流函数的手写是很常见的方式。这里附上防抖函数的两种写法以及节流函数的一种写法，都可以参考研究。\\n\\n## 总结\\n**防抖和节流能有效减少浏览器引擎的损耗，防止出现页面堵塞卡顿现象，需要熟练掌握。** 防抖和节流学习完后，还有其他的手写题等着我，接下来慢慢去学并记录下来。\\n"
    },
    {
        "article_id": "7188132100950720567",
        "cover_image": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e65af9e0903541a09394c289f039b529~tplv-k3u1fbpfcp-watermark.image?",
        "title": "学无止境，2022年年终浅记",
        "brief": "「回顾2022，展望2023，我正在参与2022年终总结征文大赛活动」 2022年已过去，23年到来，在辞旧迎新之际，希望回顾一下过往，整理一些收获与体会，并且收拾好情绪与思绪，再次起航~",
        "user_name": "遥望星辰",
        "view_count": 1496,
        "collect_count": 2,
        "comment_count": 1,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/19e1d2bafa3af312206d6eaed0539527~300x300.image",
        "category": "代码人生",
        "content": "---\\nhighlight: a11y-dark\\ntheme: cyanosis\\n---\\n「回顾2022，展望2023，我正在参与[2022年终总结征文大赛活动](https://juejin.cn/post/7172462429929111559 \\\"https://juejin.cn/post/7172462429929111559\\\")」\\n\\n2022年已过去，23年到来，在辞旧迎新之际，希望回顾一下过往，整理一些收获与体会，并且收拾好情绪与思绪，再次起航~\\n\\n作为一个有梦想的青年，有了梦想是第一步，但前行路上需要持续地努力、学习，才能不断地提升自己的能力，才有机会让梦想开花结果。所以本文的主题是借着年终总结，梳理一下去年的收获——2022年坚持学习、坚持成长的地方。\\n\\n2022年除了工作、生活，以及一些零碎的学习，能够有所坚持的大致在几个方面上——阅读、PMP学习、英语学习、Java学习、技术写作、技术分享等。不过虽然看着有不少内容，但在频率上的差别却比较大，比如几乎每天都有在阅读，而在写技术文章上大致一年只写了5、6篇，所以还不能算是比较好的习惯吧，不管怎样，下面来简单讲讲一些体会。\\n\\n### 知识的汪洋，书中自有颜如玉\\n大概“黄金屋”、“颜如玉”这种形容还是过于功利，我更愿意用“美玉”来形容书籍，书籍汇聚成的知识，像是烁石中的美玉，闪闪发光又能使人有所得。\\n\\n去年几乎每天有在阅读，没有看书的天数大致只有半个月，除了一些实体书，还喜欢用微信读书和喜马拉雅APP，不方便看书的时候会选择听书，比如上下班路上。\\n<div>\\n <img width=\\\"40%\\\" src=\\\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/67187141d90a4f0eb343852ab93b9878~tplv-k3u1fbpfcp-watermark.image?)\\\" />\\n <img width=\\\"40%\\\" src=\\\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/742e0b1154f5419398596d16e551e3bf~tplv-k3u1fbpfcp-watermark.image?)\\\" />\\n</div>\\n\\n阅读的分类集中在编程设计、商业/财经、心理-认知与行为等等，编程相关的知识，对于我的编程能力提升有所裨益；商业相关的知识，使我更加清晰了商业/经济的运转，以及理财投资的策略。\\n\\n印象比较深刻的《认知觉醒》一书，大幅改变了我喜欢晚睡的习惯，使我在很长的一段时间内坚持着23点睡觉，6点起床，不过最近一般坚持12点睡觉，7点起床。虽然也不会每天都遵守，但大体上养成了习惯，会在这时间上稍有波动，或许读书真的可以渐渐改变一个人吧。\\n\\n### 写好的、规范的代码，学一波英语\\n英文的好坏对于程序员来讲还是比较重要的，如果可以无障碍地阅读第一手编程相关信息、资料、写出规范的、符合语义的代码，这无疑对自己的成长、对团队有比较大的帮助。\\n\\n虽说目前的翻译软件都很强大，中英互译可以很便捷，但有时候直译出来的还是有些生硬、含糊，又比如翻译同一个词语时，不同的翻译软件可能得出不同的结果，哪个翻译结果比较恰当，还需要稍加斟酌。\\n\\n去年在英语流利说坚持打卡了100多天，后来觉得套餐有点贵了，最近转战多邻国，持续打卡中。目前还觉得自己的英文不太行，不过会一直学习、一直打卡。\\n\\n<img width=\\\"40%\\\" src=\\\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c2e6ebe08744eee951b32d948f840ee~tplv-k3u1fbpfcp-watermark.image?\\\" />\\n\\n\\n### 项目管理的艺术—PMP\\n学PMP的契机，一是一直处于项目管理的范畴内（被管理~），对项目管理工作有一定的好奇心；二是公司给予了考PMP可以报销的优惠政策，遂开始了为期三个月的学习之路。\\n\\n\\n![3a0ab9622bcb28e72b31d631b00eeb3.jpg](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93772e03071e4854917fc74669ec9acc~tplv-k3u1fbpfcp-watermark.image?)\\n\\n经过了几个月紧锣密鼓的学习，一遍又一遍的刷题，我对于项目管理有了更深的体会，比如项目管理的标准流程是什么，什么时候、哪个阶段适用哪些管理艺术及技巧等。对于我们做技术的来说，有利于理解管理方法及往管理岗位方向发展；以及通过对项目管理工作更清晰的认识，有利于与团队的良好协作。\\n\\n### 横向扩展技艺—JAVA\\n虽然已经在前端上工作几年了，不过不太满足于仅熟悉前端领域，想要对WEB的整体工作流程有更多的理解（也有绩效因素的加持~）。于是去年通过请教后端同事、各方面的学习，更加加深了以Java为主的相关后端知识学习、实践。\\n\\n主要学习了Java基础知识、后端架构（微服务、负载均衡、docker、rancher等）相关知识，也有了一些实际的工作实践，比如帮后端改改bug、做个小功能，然后独立打包部署，不过目前对后端技能的掌握还比较生涩，稍稍复杂的功能上手就会比较吃力，希望后续可以持续加强。\\n\\n### 技术创作与分享\\n去年的技术写作里面，在掘金上写了4篇技术文章，如果加上在公司里写的，大概6篇，这么看来是不多的，刚好最近买了张鑫旭大佬的《技术写作指南》小册，希望多加学习下，争取有更多、更好的输出。\\n\\n在技术分享上，去年带领前端团队完成了三次技术分享，虽然也不多，不过可以明显体会到各位前端同事的学习心得，从0走到1不轻易，也看到了相互取长补短的好处。\\n\\n### 后记\\n未来正在一步步到来，就像是22年已过去，23年已到来，来不及让我们感叹去年的疫情时期多么的步履艰难；未来又扑朔迷离，忽然的疫情解封似乎让我们觉得生活彻底如常，但又面临着新的新冠毒株的威胁，而生活也可能像这般无常，悲喜像是阴晴圆缺，又雨后彩虹，无论如何，希望我们砥砺前行，迎接更美好的未来。\\n\\n最后，写一句寄语：学无止境，希望我们越努力越幸运！\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n"
    },
    {
        "article_id": "7130246572306071583",
        "cover_image": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e403665c0024afdaf10c0d8329cc8c0~tplv-k3u1fbpfcp-watermark.image?",
        "title": "一名程序员的电脑桌面",
        "brief": "一个整洁桌面环境，有利于开发出干净的代码。分享了我的桌面配置，也写了配置同款桌面的教程，写给需要的人。",
        "user_name": "FSHOW",
        "view_count": 83872,
        "collect_count": 275,
        "comment_count": 221,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/487d607f6e1e73a4b9d6698ff1da4415~300x300.image",
        "category": "后端",
        "content": "\\n\\n\\n\\n配置：\\n* 酷呆桌面\\n* 注册表隐藏快捷方式箭头图标\\n* 开启桌面模式自动隐藏任务栏\\n\\n\\n## 酷呆桌面\\n> 在选择酷呆之前，一直是使用的Fences，他的桌面切换功能非常赞，适合划分工作区。但由于强迫症实在是忍受不了肉眼可见的掉帧、黑背景bug，还是准备重整一些桌面，也顺便通过本贴记录下来，希望给大家有个参考。\\n\\n酷呆桌面，用过的都知道多丝滑，就不过多介绍了，是一款国人开发，永久免费的轻量级桌面整理工具。 \\n<p align=center><img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0cc4ec35b897432f99062789296ef959~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\"  /></p>\\n\\n使用酷呆给桌面的图标做了分组，把众多工具搞到了一起，其实这样一点也不难找，我打开软件都是使用Power Toys Run，不知道什么是Power Toys Run的可以百度搜一下`Power Toy`，是一款微软开源的Windows增强工具。\\n> 每次使用Power Toys Run 都会联想到Spring的@Autowired，不知道大家有没有这种感觉...\\n\\n\\n工具栏展开后的样子\\n<p align=center><img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13eb74a85b0d41f88765a4742e428a3d~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\"  /></p>\\n\\n\\n\\n\\n搞了一个类似Mac的dock栏，把常用的工具分到一组里，把组名改成空字符串，按着`Ctrl + 鼠标滑轮向上`，可以调整分组中的图标大小。\\n<p align=center><img src=\\\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/12850794635d4990903855d0050ed552~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\"  /></p>\\n\\n\\n## 注册表隐藏快捷方式箭头图标\\n网上普遍方法是将注册表\\\\HKEY_LOCAL_MACHINE\\\\SOFTWARE\\\\Classes\\\\lnkfile下的lsShortcut给删除了，但是这种方法会导致Power Toys Run失效！ 当你用快捷键搜索应用时，会弹出找不到快捷方式的错误，所以想要鱼和熊掌兼得需要按照下面这个方法。\\n<br>\\n> 也是操作注册表，只不过这次是新建一个，而不是删除原来的，以后想要恢复也十分简单。\\n\\n1. `Win + R` 输入 `regedit`，点击确定进入注册表编辑器。\\n<p align=center><img src=\\\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e699b17bd7c41ccab81fefb7ca45f00~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\"  /></p>\\n\\n2. 在`\\\\HKEY_LOCAL_MACHINE\\\\SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Explorer`目录下对着Explorer右键，新建，项，名称改为**Shell Icons**\\n\\n<p align=center><img src=\\\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cace9f16388a4f75b3feb7af1b9deeea~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\"  /></p>\\n\\n\\n\\n\\n3. 单击Shell Icons，在右边空白处右键，新建，字符串值，并将名称改为29\\n<p align=center><img src=\\\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c7ed23d411f4cd19431d04f8d853450~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\"  /></p>\\n\\n<p align=center><img src=\\\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cff64c84e59b4822bae9e0711bcb3607~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\"  /></p>\\n\\n\\n4. 双击29这个配置，在数值数据一栏中填写\\n```text\\nC:\\\\WINDOWS\\\\system32\\\\imageres.dll,197\\n```\\n> 如果电脑有**多个磁盘**，兄弟们无法确定系统是否安装在C盘，也可以填入这个变量路径\\n**“%systemroot%\\\\system32\\\\imageres.dll,197”** \\n这个命令会自动定位系统位置。\\n\\n5. 点击确定，然后重启电脑，或者logoff注销也行，开机就发现快捷方式小箭头都没有了，而且也不影响Power Toys Run！\\n\\n## 开启桌面模式自动隐藏任务栏\\n> 有人不喜欢这个功能，萝卜青菜，各有所爱吧，不准备设置这个功能的可以直接划到底部看GIF效果图了\\n\\n右键任务栏，点击`任务栏设置`\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1116d7b245c846d9876df683dd46db77~tplv-k3u1fbpfcp-watermark.image?)\\n\\n将`在桌面模式下自动隐藏任务栏`打开\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c443a6a274a47f88368f3728134fe57~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## 大功告成\\n\\n![ezgif-4-60c39f7da9.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/235790178ad74645b8e5c509d42933c5~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n"
    },
    {
        "article_id": "7189076751920660537",
        "cover_image": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2db5bf58e4c44bfcad39e1284acc358b~tplv-k3u1fbpfcp-watermark.image?",
        "title": "程序猿健康防猝指南4：常见医药疾病知识",
        "brief": "家里常备一些药物、医疗用品，以备不时之需。了解常见的疾病、创伤的知识和防治方法，如心脏骤停、代谢疾病等",
        "user_name": "安木夕",
        "view_count": 1918,
        "collect_count": 11,
        "comment_count": 1,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/4f97c321b2f9df11757da519625aac4d~300x300.image",
        "category": "阅读",
        "content": "# 系列目录\\n> - [程序猿健康防猝指南1：体重和减肥的秘密](https://juejin.cn/post/7182374196108853306)\\n> - [程序猿健康防猝指南2：饮食健康](https://juejin.cn/post/7186448487364427835)\\n> - [程序猿健康防猝指南3：健康保健](https://juejin.cn/post/7188341138883870775)\\n> - [程序猿健康防猝指南4：常见医药疾病知识](https://juejin.cn/post/7189076751920660537)\\n> - [程序猿健康防猝指南5：运动入门基础](https://juejin.cn/post/7189808095197921337/)\\n> - [程序猿健康防猝指南6：[科学]运动](https://juejin.cn/post/7190184041922953253)\\n\\n\\n# _01、_ 💊家庭常备药物 \\n家里常备一些药物、医疗用品，以备不时之需。注意别备太多，注意有效期，以及留好说明书。\\n`11`\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1dfea09ba83344cf9dc03bf6a2a9c4bb~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n#### 💊 退热止痛药：对乙酰氨基酚、布洛芬\\n除了退烧，这两个药也是常用的止疼药，可缓解头疼、牙疼、痛经，布洛芬同时还有抗炎的作用。\\n- 有慢性肝病首选「**布洛芬**」，注意儿童版的布洛芬是滴剂或混悬液。「布洛芬」对胃肠道有刺激作用，有胃溃疡的病人慎用。\\n- 有消化道疾病的首选「**对乙酰氨基酚**」。\\n![image](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca2bb87d2e86499aa488c7737e22270d~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n\\n#### 💊 缓解鼻塞药：生理性海水鼻腔喷雾剂\\n- 感冒时可以用来缓解鼻塞，鼻炎患者可以用来缓解鼻炎症状。\\n\\n#### 💊 止泻药：口服补盐液Ⅲ（处方药）、蒙脱石散、微生态调节剂\\n- 「**口服补液盐Ⅲ**」能补充水、钠、钾、葡萄糖等，补液又止泻，能够安全有效地治疗90%以上的各种腹泻，且安全性好。\\n- 轻度腹泻可以用一些黏附剂性质的止泻药，如「蒙脱石散」。\\n- 「**微生态调节剂**」包括双歧杆菌、布拉氏酵母菌、地衣芽胞杆菌、酪酸梭菌、嗜酸乳杆菌等制剂，此类药物主要是补充生理性肠道细菌，纠正肠道菌群失调。\\n\\n#### 💊 便秘药：开塞露、乳果糖\\n- 「**开塞露**」使用中需注意，挤入直肠内应保留5-10分钟后再去排便，过早排便不能起到刺激直肠、润滑大便的作用。\\n- 「**乳果糖**」可防止大便硬结，刺激肠道，促进排便。\\n\\n#### 💊 晕车：茶苯海明、东莨菪[dàng]碱贴剂\\n乘车前 24 小时清淡饮食，避免高脂肪的大餐 。尽量坐在汽车的前排座位上，通风， 避免低头看书或玩游戏 。\\n- 「**茶苯海明**」在出发前30分钟服药，每4小时用药1次。坐车路程较短者，推荐本药。\\n- 「**东莨菪碱**」贴剂需在出发前4小时用药；最常见的不良反应是口干。\\n\\n#### 💊 皮肤止痒药：炉甘石洗剂\\n- 可用于蚊虫叮咬、长痱子止痒等，湿疹和皮肤有破损等情况不推荐使用。\\n\\n#### 💊 外伤护理系列\\n- 「**碘伏**」消毒杀菌。如果小伤口出血，用碘伏消毒后，记得贴上创可贴。创可贴要经常换，一般12小时左右换1次。\\n- 「**莫匹罗星软膏**」属于抗生素药膏，皮肤表面的感染几乎都能派上用场。比如脓痱，尿布疹破溃，包皮口炎，脚上磨出的泡泡，蚊虫叮咬之后抓破了，小面积擦伤，割伤，烧伤等。\\n\\n#### 💊 常用医用器材系列\\n- 推荐：无菌纱布、绷带、棉球、体温计、血压计。\\n\\n#### 💊其他：\\n- **人工泪液**：可以用于缓解眼疲劳和眼睛干涩，如「聚乙烯醇滴眼药」、「羧甲基纤维素钠滴眼药」。\\n- **风油精**：快速止痒；涂抹在太阳穴、前额、耳后部位可以提神醒脑；防治中暑、晕车等。\\n- **藿香正气水**：腹胀吐泻；风寒感冒、肠胃感冒。\\n\\n---\\n\\n# _02、_ ♨️烫伤、刀伤、咬伤、扭伤 \\n\\n## 🩹烫伤/烧伤\\n- **降温消肿止痛**：如伤口没有溃烂，用冷水冲洗10分钟以上，待疼痛感逐渐减轻，然后涂抹烫伤膏。\\n- **处理水泡**：当水泡不怎么痛了，可以碘伏消毒创面后放掉水泡，泡皮尽量保留，涂抹烫伤膏+包扎。如果局部出现红肿，可能是有感染，外擦红霉素软膏。\\n- **无效偏方**：涂抹牙膏、酱油没有什么用处，反而有副作用。\\n\\n## 🗡️刀伤\\n\\n如果是小伤口，可以碘伏消毒，贴创可贴即可。比较大的伤口还是去附近诊所、或者医院清创缝合治疗。\\n\\n- **止血**：伤口不是太严重的话，只需要加压包扎就可以起到很好的止血作用，压迫止血需要把手抬高，高过心脏以上，有利于止血。\\n- **去疤痕**：用姜片涂抹伤口可防止疤痕异常增生，或者使用祛除疤痕的药膏。\\n- **是否需要打破伤风（[破伤风百科](https://www.baidu.com/bh/dict/ydxx_8043339562143918327?tab=%E6%A6%82%E8%BF%B0&title=%E7%A0%B4%E4%BC%A4%E9%A3%8E&contentid=ydxx_8043339562143918327&query=%E7%A0%B4%E4%BC%A4%E9%A3%8E&sf_ref=search&from=dicta)）疫苗？** 损伤比较严重，而且出血比较多，根据病情遵医嘱使用破伤风疫苗治疗。\\n\\n## 🐕‍🦺咬伤：预防狂犬病\\n> **狂犬病**（[百科](https://www.baidu.com/bh/dict/ydxx_7932842852636302739?tab=%E6%A6%82%E8%BF%B0&title=%E7%8B%82%E7%8A%AC%E7%97%85&contentid=ydxx_7932842852636302739&query=%E7%8B%82%E7%8A%AC%E7%97%85&sf_ref=search&from=dicta)）：感染狂犬病病毒的动物伤人后传播至人，一旦出现狂犬病症状，病死率近乎100%，被咬后需接种狂犬疫苗。\\n\\n**处理**：1️⃣ 用清水或肥皂水清洗伤口；2️⃣ 碘伏消毒；3️⃣ 到医院进一步处理，动物咬伤需24小时之内注射疫苗。\\n\\n**哪些动物？**：理论上所有哺乳动物，高风险=犬、猫、蝙蝠，中风险=牛、羊、马、猪、老鼠等。同时也要关注破伤风，动物致伤造成的伤口是破伤风高风险伤口。如果说皮肤没有损破，是完好无损的，一般没有感染风险，不需要打疫苗。\\n\\n**蛇咬伤**：用布条或橡皮筋捆绑被咬的肢体避免毒素扩散，然后冲洗伤口，挤压创面排除毒素，尽快到医院处理。\\n\\n**人咬伤**：正常人是不会携带狂犬病毒的（被猫狗咬过的除外），因此不需要打疫苗，不严重的话清洗+消毒即可。\\n\\n## 🦶脚踝扭伤\\n如果能够站立，说明是轻度扭伤。用药即可痊愈，如果有剧痛，可能是伤到骨头，应立即去医院诊治。\\n- **停止运动**，不再转动已受伤的关节，一定要避免二次扭伤。\\n- **其次是冰敷**：24小时之内冷敷可局部的消肿，可以用塑料袋装一些冰块，再加点水敷在受伤的地方，每敷15分钟后休息5分钟，这样重复一两个小时左右。\\n- **贴膏药**，比如活血止痛膏，把受伤的部位抬高，以避免发生肿胀。\\n\\n------\\n# _03、_ 🏥常见疾病\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f24ef5fb6fd64478a683dd29b32798d5~tplv-k3u1fbpfcp-zoom-1.image)\\n[人体结构图](https://www.maigoo.com/goomai/189647.html)，[人体内脏器官图](https://www.maigoo.com/goomai/188994.html)\\n\\n## 🔖猝死\\n> 猝死是指平时貌似健康的人，在出乎意料的短时间内，因潜在的自然疾病而发生的死亡，直接原因表现为心脏骤停。\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3fb120062d144d5eaa55cdf6bb8ced69~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n专家称超一半猝死者为中青年人。在临床上主要分为心源性猝死和非心源性猝死，以心源性猝死为主，非心源性的相对较少。\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e30dde1b3fec48dab7ba4e4ec51a561a~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n#### 🔬**病因/病理**：\\n\\n导致猝死最常见的是心源性猝死，病因是各种心脏病，包括心律失常、冠心病等，如果本身存在冠心病等疾病应该及时就医治疗。在发病一个小时之内，会突然的出现心血管功能出现障碍，脑供血异常等，都会导致生物学死亡，这种猝死情况比较多。猝死的原因有以下个方面：\\n> 1. **不良生活习惯，是猝死的危险诱因**： 吸烟、 饮酒、肥胖、不健康饮食、久坐不动。\\n> 1. **代谢相关疾病，是猝死的基础**：高血压、高血脂、高血糖。\\n> 1. **过度疲劳，让猝死更近一步**：睡眠不足，长期处于过度疲劳状态。\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1212606460234cc983a7e99f082398de~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n#### 🪧**临床表现**：\\n\\n- **前期**：表现为胸痛、心悸、气促、疲累等症状。\\n- **发病**：突发心悸、呼吸困难、剧烈胸痛、眩晕等，猝死前常有心率加快等心电活动异常。\\n- **骤停**：意识丧失，四肢或全身抽搐、呼吸停顿，皮肤发**绀**（[gàn]，稍微带红的黑色）或面色苍白、瞳孔放大、大小便失禁。\\n- **死亡期**：出现心室停搏后，在4-6分钟内，大脑出现不可逆损害，在此期间，机体逐渐过渡到生物学死亡。\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35731c654e11492c99705c51adac1166~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n 💉**急救措施**：**心脏复苏**\\n\\n- 快速判断有无大动脉搏动消失（触摸颈动脉、股动脉）、快速评估现场环境安全是否适合抢救。呼救120急救电话，同时，有条件者寻找AED （自动体外除颤器）。\\n- 人工胸外按压（成人），按压频率100-120 次/分，按压30次，开放气道（清除患者口腔分泌物），再进行2次口对口人工呼吸。\\n> **AED自动体外除颤器**又称自动体外电击器、自动电击器，是一种便携式的医疗设备，它可以诊断特定的心律失常，并且给予电击除颤，是可被非专业人员使用的用于抢救心脏骤停患者的医疗设备。在心跳骤停时，只有在最佳抢救时间的“黄金4分钟”内，利用自动体外除颤器（AED）对患者进行除颤和心肺复苏，才是最有效制止猝死的办法。\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/47c1f08402bf49b28313b11ba2ecf47b~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n 🩺**预防**：\\n\\n- 养成良好的生活习惯，戒烟酒、劳逸结合，避免过度劳累和精神紧张。\\n- 健康饮食、多吃新鲜瓜果，少吃煎、炸、熏、烤和腌制食品，用餐不宜过饱。\\n- 规律的有氧运动，运动要循序渐进，切勿长时间的、超负荷的高强度运动。\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a1122286f6724c7891083a518a8dfb9d~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n## 🔖糖尿病\\n糖尿病属于代谢方面的疾病，以高血糖为特点，**较难治愈**，患者可通过控制糖分摄入来缓解病症加剧。糖尿病分为一型和二型，一型糖尿病存在明显的遗传性质，二型糖尿病则受环境因素影响，比如肥胖、高血压、不良饮食习惯等。糖尿病的基本症状为多食、多饮和多尿以及身材消瘦或是身材肥胖。\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fdcac3753354424e967017c3b6fcda71~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n> **胰岛素**是一种由胰脏内的胰岛β细胞分泌的蛋白质激素，他的作用主要是参与调节糖代谢，控制血糖平衡。胰岛素是临床常用的糖尿病治疗药物，也是最有效的降糖措施之一。\\n\\n 🔬**病因/病理**：\\n\\n糖尿病是一种以慢性高血糖为特征的代谢性疾病，是由于β细胞破坏使胰岛素分泌缺失或不足引起高血糖，其危害主要是并发症，会导致心脑肾以及血管疾病、器官衰竭、截肢、失明等。\\n\\n 🩸**危害**：\\n\\n- 糖尿病会导致血管、肾脏和心脏的慢性损伤和功能障碍。\\n- 糖尿病导致人体代谢紊乱，使人体的胰岛功能倒退，然后就可能会不分泌胰岛素（胰岛素会促进组织、细胞对葡萄糖的吸收和利用），这时就会引起糖、脂肪、蛋白质、水、电解质等代谢的紊乱。\\n- 严重患者还会带有糖尿病酮症酸中毒、糖尿病高渗非酮症昏迷、糖尿病视网膜病变、糖尿病足、糖尿病肾病等一系列并发症。\\n\\n 🩺**防治**：\\n\\n- **就医治疗**，注射胰岛素或服用抗糖类药物。\\n- **运动锻炼**：减肥运动锻炼，提高身体素质和免疫能力。运动可以更好促进糖类物质的消耗，达到稳定体重、控制血糖的辅助作用。\\n- **饮食清淡**：要保持低脂肪、低热量和适量蛋白质的饮食结构，尽量食用高纤维的饮食，少吃或不吃甜食，戒烟酒。\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7fb9887702b14fda873cc2903b8e7896~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n## 🔖脂肪肝（肝硬化）\\n**脂肪肝**指的就是肝细胞内堆积了太多脂肪。正常情况下，肝内总脂肪量只占据肝重量的5%，可若是超过这一数值可评判为轻度脂肪肝，而若是超过25%就是重度脂肪肝。\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/02800ca5f73d4bb1a2c250b6644561d2~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n**肝硬化**是各种慢性肝病长期作用于肝脏而导致的肝病的终末阶段，以肝脏弥漫性纤维化、假小叶和再生结节形成为组织学特征。\\n\\n 🔬**病因/病理**：\\n\\n**体重肥胖**，**过度喝酒**，久坐不动，高血压、高血脂、高血糖等。\\n\\n脂肪肝发展到肝硬化需要经历几个过程，大部分的脂肪肝不会变成肝硬化。但是，如果脂肪肝患者不积极配合治疗，治疗过程中饮食不注意，就会导致肝细胞再生障碍和坏死。肝脏就容易变性，出现纤维化，最终演变成肝硬化。\\n\\n 🩸**危害**：\\n\\n脂肪肝不只伤害的是肝脏，它还会对血脂、血糖和血压都产生影响。若不及时干预，5至10年内就可能会发生糖尿病、高血压病、血脂紊乱和痛风等代谢性疾病，10至15年也可以发生冠心病、脑卒中（中风）甚至肝硬化和肝癌。\\n\\n 🩺**防治**：\\n\\n- 定期体检，及时治疗，**脂肪肝是可逆的**。\\n- 少吃高热量，高脂肪，高胆固醇的食物，戒烟酒。在临床上，有许多肝硬化患者都是患上脂肪肝之后依然经常喝酒引起的。\\n- 多喝水，多吃蔬菜水果，蔬菜水果中含有大量维生素，可以对肝起到保护作用。\\n- 多锻炼减脂，控制体重。\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/47fcf0dbce82444e857cf22f0093b700~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n## 🔖肾结石\\n**肾结石**属于上尿路结石，是泌尿外科常见疾病。夏季发病率较高，多见于青壮年男性，经及时有效的治疗一般可以治愈。\\n\\n肾脏是产生尿液的器官和场所，尿液是身体内代谢的废物排出的主要方式之一，所以尿液中存在着大量的矿物质、代谢产物等，而结石就是我们的尿液中沉积出来的这些代谢产物及矿物质沉积而成的。当人体中水分减少或缺少抑制结石物质，导致晶体增多、积聚，最终导致结石的发生。\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78db31307a6d4bb1baf18fdf32d24d33~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n 🔬**病因/病理**：\\n\\n- **饮水不足、经常憋尿**。尿液少导致代谢产物浓度增高，就很容易引起结石。\\n- 嘌呤代谢紊乱-**尿酸高**。嘌呤代谢紊乱是导致肾结石的常见原因，一般海产品当中都含有比较丰富的嘌呤，嘌呤在进入人体并且经过一系列的消化后，人体便容易形成尿酸，而尿酸是可以帮助尿液中的草酸盐沉淀，从而导致肾结石的发生。\\n- 有家族史的人，糖尿病、肥胖、痛风和高血压患者。\\n\\n 🩸**危害/症状**：\\n\\n- 引起肾区、上腹部剧痛，**肾绞痛**（_8级疼痛，分娩是9级_）是肾结石的最为常见的一种症状，主要是由于肾结石在排出过程中堵塞了输尿管所导致的。\\n- 可并发尿路感染，如尿频、尿血等。\\n\\n 🩺**防治**：\\n\\n- 多喝水（每天应该饮水1500～1700毫升（不用饮料代替）），不要憋尿。\\n- 注意尿酸指标，定期体检。控制高嘌呤食物，如动物内脏、肉类、鱼虾等，多吃蔬菜水果。\\n- 大量喝水、适度运动有自行排出的可能，如果无法自行排出，可以服用排石药物促进结石排出。\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c6f9c78b12d415face1e305c6b443e8~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n## 🔖前列腺炎\\n前列腺（英文： prostate）是男性特有的性腺器官，前列腺炎是由多种复杂原因和诱因引起的与炎症、免疫和神经内分泌相关的病理变化。其临床表现多样，主要为尿道刺激症状和慢性盆腔疼痛，如排尿时有烧灼感、尿急、尿频、排尿疼痛，会阴、耻骨上区、腹股沟区、生殖器疼痛不适等。约50%的男性在一生中的某个时期会受到前列腺炎的影响，其中50岁以下的成年男性患病率较高。\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f4b2ab71ced4470996a8c2aa5bdf15d~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n 🔬**病因/病理**：\\n\\n前列腺的大小就是像一个栗子样的大小，前列腺因为有尿道从中间穿过，又是房事的时候精液储存的一个器官，前列腺又分泌前列腺液，组成精液的一部分，所以前列腺如果发生了疾病的话，容易出现的与排尿、生殖，以及和房事生活有关的一些症状和体征。\\n\\n大多数由病原体感染所致，也可由不健康性生活、长途骑车、久坐、酗酒、辛辣饮食诱发起病。\\n\\n 🩸**危害/症状**：\\n\\n- 会引起尿频、尿急、尿痛以及骨盆区的疼痛，影响日常（性）生活、生育能力。\\n- 细菌毒素引起的过敏反应可引起结膜炎、虹膜炎、关节炎、神经炎等。\\n\\n 🩺**防治**：\\n\\n- 及时就医治疗。\\n- 注意卫生，勤换内衣，防止细菌感染；避免久坐、憋尿。\\n- 忌食物辛辣、不洁性交、过度劳累、滥用壮阳药、房事不规律、经常熬夜等。\\n- 多喝水、戒烟酒，坚持运动，增强体质。\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a313293b93b477b85b18d0ba8a6ca9f~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n## 🔖痔疮\\n**痔疮**是很常见的肛肠疾病，十人九痔，我国成人痔疮发病率为50%~60%，其中有约5%表现出痔脱垂或便血等症状。痔疮虽不是什么大病，但严重影响生活质量，杀伤力不高，侮辱性极强。\\n\\n**痔疮**是肛门直肠下端局部血液循环障碍，导致痔静脉丛发生曲张，淤血而形成的团块，并由此带来的脱出、排便困难、潮湿瘙等症状。内外痔的划分离不开一个关键结构——齿状线，它是肛管和直肠的分界线。根据齿状线的位置，把痔疮分为外痔、内痔、混合痔。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b20059f8b9ec40ce90e9b3e7d47d0fea~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n **🟡内痔**：\\n\\n齿状线以上的部位脱垂形成的痔疮称之为**内痔**，主要表现为便后出血、痔核脱出、肛周潮湿疼痛、瘙痒，部分病人还会有排便困难。\\n\\n- 1期：便时带血；滴血或喷射状出血，排便后出血可自行停止，无痔核脱出。\\n- 2期：常有便血；排便时有痔核脱出，排便后可自行回纳。\\n- 3期：偶有便血；排便或久站、咳嗽、劳累、负重时有痔核脱出，需手动回纳。\\n- 4期：偶有便血；痔核持续脱出或回纳后易脱出，偶伴有感染、水肿、糜烂、坏死和剧烈疼痛。\\n\\n **🟡外痔：**\\n\\n发生于齿状线以下，是齿状线远侧皮扩张或结缔组织增生而形成的。主要表现为肛门不适，肛周潮湿、瘙痒，当形成血栓性外痔时，还会有剧痛。\\n\\n **🟡混合痔**：\\n\\n两者的症状都有可能出现，技能叠加，痛苦加倍。\\n\\n 🔬**病因**：\\n\\n- **不良的生活习惯**：便秘，如厕时间太久，排便过于用力，熬夜等。\\n- **久坐久站**：久坐久站会导致腹部的血流速度减慢，下肢静脉血不能回流，血液循环受到阻碍，长期保持这种情况的话，直肠静脉丛容易发生曲张，导致血液淤积，形成静脉团，痔疮也就这样出现了。\\n- **不良的饮食习惯**：膳食纤维摄入不足；大量喝酒、各种辛辣刺激的食物。\\n\\n 💉**治疗**：\\n\\n- **药物治疗**：栓剂、膏剂和洗剂。温水坐浴或药物熏洗，改善局部血液循环，缓解症状。\\n- **注射/手术治疗**：遵医嘱。严重的只能靠手术解决，据（朋友）说有一系列的不可描述过程（灌肠、刮毛、扩肛...）。后面恢复期如厕据说如同拉玻璃渣。\\n\\n 🩺**预防**：\\n\\n- **调整饮食**：膳食均衡，多吃水果、蔬菜，补充膳食纤维。\\n- **调整习惯**：减少便秘发生，5 分钟解决；勿久坐久站；保持肛门区清洁。 \\n- **运动锻炼**：运动健身提高身体素质。可以做提肛、凯格尔运动，锻炼盆底肌群。\\n\\n---\\n\\n> **©️版权申明**：版权所有@安木夕，本文内容仅供学习，欢迎指正、交流，转载请注明出处！[_原文编辑地址-语雀_](https://www.yuque.com/kanding/klife/ypkazs)\\n\\n---\\n\\n# 参考资料\\n\\n- [人体结构图](https://www.maigoo.com/goomai/189647.html) [人体内脏器官图](https://www.maigoo.com/goomai/188994.html)\\n- [家庭常备药只要 10 种就够，多了都是浪费](https://dxy.com/article/30718)\\n- [居家常备非处方药推荐](https://dxy.com/article/2275)\\n- B站：[死亡离你有多近？猝死预防科普，知道这些能救命！](https://www.bilibili.com/video/BV1XL4y1g7JJ?zw)\\n- B站：[猝死预警信号](https://www.bilibili.com/video/BV1ph411s7PS)\\n- [心源性猝死](https://zjb.yilianmeiti.com/3799/diseasepic/)\\n- [为什么看似健康的年轻人会突然猝死？](https://mp.weixin.qq.com/s/toVmO7rAJdXajuJO5h-WFQ)\\n- [不同人群常见病有哪些？男女老少孕常见病防治手册](https://www.maigoo.com/goomai/190501.html)\\n- [糖尿病的症状、危害与治疗](https://www.maigoo.com/best/8034.html)\\n- [脂肪肝有救吗？教你如何和脂肪肝说“拜拜”](https://mp.weixin.qq.com/s/1G4z4J0GjF203oO541c8wg)\\n- [关于肾结石，看这一篇就够了～](https://mp.weixin.qq.com/s/W2HvEF3ARq-MsrpP_trb0w)\\n- [图解疾病-痔疮](https://zjb.yilianmeiti.com/1/diseasepic/)\\n- [有痔疮的人，将经历什么？附上最全菊花呵护宝典](https://mp.weixin.qq.com/s/-xJUEIgaQYQEMW8ULMWBSg)\\n- B站：[好好的屁股，怎么就得了痔疮？](https://www.bilibili.com/video/BV1di4y127d3)\\n"
    },
    {
        "article_id": "7123178292865155102",
        "cover_image": "",
        "title": "尤雨溪对未来前端趋势分享: 笔记",
        "brief": "早上参加稀土掘金大会随手记下的。能力有限，欢迎勘误。 一、 开发范式&底层框架 1、React Hooks 带来的开发范式的变革 React Hooks 取代 Class Components 启发组",
        "user_name": "全栈然叔",
        "view_count": 92174,
        "collect_count": 988,
        "comment_count": 133,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/406cea3f24e05b9522a65c9b9cf124c2~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: smartblue\\n---\\n\\n早上参加稀土掘金大会随手记下的。能力有限，欢迎勘误。\\n\\n🔥 大家好我是然叔一个41岁的程序员老兵，\\n\\n我会不断分享我学习的心得 \\n\\n内附然叔优秀作品汇总链接\\n\\n建议收藏\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b76d1e0aea8c43be8df69435a1cf120a~tplv-k3u1fbpfcp-watermark.image?)\\n\\n链接在此 建议点赞赞收藏\\n↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓\\n\\n# [41岁的程序员的”毕业“走向自由职业](https://juejin.cn/post/7123012186884014116)\\n\\n\\n![Snip20220722_43.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f77af032feb416eb7a4511304312f51~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n# 一、 开发范式&底层框架\\n## 1、React Hooks 带来的开发范式的变革\\n\\n![Snip20220722_64.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/082693c637f7422a940a298fb96cde98~tplv-k3u1fbpfcp-watermark.image?)\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56f393fed6f745258061439d60860caa~tplv-k3u1fbpfcp-watermark.image?)\\n\\n- React Hooks 取代 Class Components\\n- 启发组件逻辑表达和逻辑复用的新范式\\n    - Vue3: Composition API\\n    - Svelte3: 编译后逻辑受到了React Hooks启发\\n    - SolidJS: Hooks语法相似 + 实现与CompositionAPI相似的写法\\n  \\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3dce19d601f34344a730a07a013b35cf~tplv-k3u1fbpfcp-watermark.image?)\\n  \\n### React Hooks的开发体验被逐渐正视\\n- Hooks 执行原理和原生JS心智模型的差异\\n- 不能条件式调用\\n- Stale Closure（过期闭包）的心智负担\\n- 必须手动声明 useEffect 依赖\\n- 如何”正确“使用 useEffect 是个复杂的问题\\n- 需要 useMemo / useCallback 等手动优化\\n\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c352b52059e3403d82956544ab5dbf06~tplv-k3u1fbpfcp-watermark.image?)\\n### React 团队对改善开发体验的努力\\n- useEventRFC 改善useCallback的问题\\n- Dan Abranmov 话单量时间改进新版 useEffect 文档\\n- 黄玄正在开发中的 React Forget 已在避免需要手动声明依赖\\n\\n\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c8bf91faac2f4964959c5bb04329160e~tplv-k3u1fbpfcp-watermark.image?)\\n### 基于依赖追踪的范式重新得到重视\\n- SolidJS 符合直觉无需声明依赖\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cb99f1233de0499e9d7caa9b64ae70bd~tplv-k3u1fbpfcp-watermark.image?)\\n\\n- Vue Composition API ref追踪依赖\\n\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/191808623111446b87790e149b8f3b44~tplv-k3u1fbpfcp-watermark.image?)\\n\\n- Ember Starbeam Cell追踪依赖\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/58ec267c68be45d6a86af201885ab3df~tplv-k3u1fbpfcp-watermark.image?)\\n\\n基于依赖追踪的范式 - 共同点\\n- 一次调用，符合原生JS直觉\\n- 自动追踪依赖，无需手动声明\\n- 引用稳定，无需useCallback\\n\\n\\n\\n## 3. 基于编译的响应式系统\\n\\n> 基于编译时优化改善开发体验\\n\\n- Sevlte  【$】副作用黑魔法\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/736991e3a7e348cfbd18127b06632b14~tplv-k3u1fbpfcp-watermark.image?)\\n\\n简洁代码带来的限制\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d47d8e32a6b489a8d0536ec97fc32a6~tplv-k3u1fbpfcp-watermark.image?)\\n\\n- 只能在Svelet组件内使用\\n- 组件外需要不同的API\\n- 只能在顶层作用域使用\\n\\n\\n- Vue Reactivity Transform  响应式转换\\n>  编译时宏 $ref\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5b825cf9d504b33b9150c944657b48d~tplv-k3u1fbpfcp-watermark.image?)\\n\\n- solid labels\\n> 类似于 Vue Reactivity Transform  \\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a7e5decfaba3423680335b430fb4c6c1~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n## 统一模型的优势和代价\\n\\n- ✅  利于长期的重构和复用\\n- 😭 底层实现的抽象泄漏\\n- 😭 初期学习成本\\n\\n## 4. 基于编译的运行时优化\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b8096261c714f9cb1320a9fd705d6b1~tplv-k3u1fbpfcp-watermark.image?)\\n- Svelte - 通过命令节点拼接JS代码\\n- Solid - 基本HTML字符串 -> Dom节点绑定\\n- Vue Vapor Mode - 与 Solid\\n\\n### Vue Vapor Mode\\nSFC单文件输出\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f5603ed6a754a04b08a126492e881de~tplv-k3u1fbpfcp-watermark.image?)\\n\\n类 Solid 输出\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c1d07905e614c21a7d03e1644292789~tplv-k3u1fbpfcp-watermark.image?)\\n- 一次性生成静态节点\\n- 找到动态节点进行状态绑定\\n\\n\\n# 二、工具链\\n\\n## 1. 原生语言在前端工具链中的使用\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e83e975cbc24953bc0abc73976dafc9~tplv-k3u1fbpfcp-watermark.image?)\\n> 工具链原生语言参与比例提高\\n- esbuild （Go）\\n- SWC (Rust)\\n- Vite (JS / GoHybrid Via ESBuild)\\n- napi-rs (Rust)\\n- Parcel2 (JS/Rust hybird)\\n- Bun (Zig)\\n\\n趋势分析\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/23cc4cf64d384e68babacc59c5403169~tplv-k3u1fbpfcp-watermark.image?)\\n\\n> JS 与 原生语言混合成为趋势\\n\\n## 2. 工具链的抽象层次\\n- browserfy/webpack/rollup  - 专注打包、抽象层次低\\n- Parcel/Vue-CLI/CRA - 专注抽象层次\\n- Vite - CLI专注于应用、API专注于支持上层框架、抽象层次高\\n\\n\\n## 3、 基于Vite的上层框架\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b085f23d6c0645f88e8780687bd2a2fc~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n# 四、上层框架Meta Framworks\\n## 1. JS全栈的意义\\n常用的全栈框架\\n> BFF 一个语言打通前后端\\n\\n## 2. 数据打通\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/59ccccc2ac0f4d79a2bfa8be0667e6d5~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## 3. 类型打通\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c710d9730e4e4f7c927bc56fb5a33ce1~tplv-k3u1fbpfcp-watermark.image?)\\n- 通过显示引入共享类型\\n- 基于DB schema 生成类型\\n- Nuxt3 自动基于文件布局生成API/路由类型\\n\\n\\n## 4. JS全栈的代价\\n- 虽然数据已经渲染出了HTML 但还需要额外发送一份Hydrate\\n- 及时客户端没有交互组件依然会被打包发送至客户端\\n- Hydrate 影响页面交互指标（TTI）\\n\\n\\n## 5. 社区的探索\\n\\n- Server-only Components (Next/Nuxt)\\n- Partial hydration / Island\\n- Fine-grained+ resumable hydration  (Qwik)\\n- Shell + hydration (VitePress)\\n\\n\\n\\n早上参加稀土掘金大会随手记下的。能力有限，欢迎勘误。\\n\\n早上参加稀土掘金大会随手记下的。能力有限，欢迎勘误。\\n\\n早上参加稀土掘金大会随手记下的。能力有限，欢迎勘误。\\n\\n\\n# 往年优秀文章汇总\\n\\n## 征文获奖 & 千赞文章\\n\\n-   [彻底搞懂HTTP协议 - 天天造轮子](https://juejin.cn/post/7038627294197317662 \\\"https://juejin.cn/post/7038627294197317662\\\") -🔥月冠军\\n-   [做了一夜动画，让大家十分钟搞懂Webpack](https://juejin.cn/post/6961961165656326152 \\\"https://juejin.cn/post/6961961165656326152\\\") - 👍🏻1471赞\\n-   [【Vue官方教程笔记】- 尤雨溪手写mini-vue](https://juejin.cn/post/6911897255087702030 \\\"https://juejin.cn/post/6911897255087702030\\\") 👍🏻1643赞\\n-   [【Vue3官方教程】🎄万字笔记 | 同步导学视频](https://juejin.cn/post/6909247394904702984 \\\"https://juejin.cn/post/6909247394904702984\\\") - 👍🏻1536赞\\n\\n## Vue学习系列\\n\\n-   [Element3开发内幕 - Vue CLI插件开发](https://juejin.cn/post/6899334776860180494 \\\"https://juejin.cn/post/6899334776860180494\\\") 192赞\\n-   [忙了一夜用CompositionAPI征服产品妹子花里胡哨的需求](https://juejin.cn/post/6891885484524437518 \\\"https://juejin.cn/post/6891885484524437518\\\") 129赞\\n-   [Vue3.0全球发布会干货总结](https://juejin.cn/post/6875236411349008398 \\\"https://juejin.cn/post/6875236411349008398\\\") 286赞\\n-   [Element3.0升级日记 - TimeLine组件](https://juejin.cn/post/6867865667089989639 \\\"https://juejin.cn/post/6867865667089989639\\\") 70赞\\n-   [跟我一起编写Vue3版ElementUI](https://juejin.cn/post/6864462363039531022 \\\"https://juejin.cn/post/6864462363039531022\\\") 156赞\\n-   [渐进式手敲Vue3.0框架 - 2万字以上 - 持续更新](https://juejin.cn/post/6850037267466190856 \\\"https://juejin.cn/post/6850037267466190856\\\") 93赞\\n-   [如何参加开源项目-如何给Vue3.0提PR](https://juejin.cn/post/6844904191744278542 \\\"https://juejin.cn/post/6844904191744278542\\\") 85赞\\n\\n# 硬核面试题\\n\\n-   [Day01 JS整数是怎么表示的 | 面试打卡365](https://juejin.cn/post/7048191028280426526 \\\"https://juejin.cn/post/7048191028280426526\\\")\\n-   [Day02 - 0.1 + 0.2 === 0.3嘛 | 面试打卡365](https://juejin.cn/post/7048554678858022925 \\\"https://juejin.cn/post/7048554678858022925\\\")[\\\\\\n    ](https://juejin.cn/post/7048554678858022925 \\\"https://juejin.cn/post/7048554678858022925\\\")\\n-   [Day03 - 数字超过最大限制的如何处理? | 面试打卡365](https://juejin.cn/post/7048998409067298830 \\\"https://juejin.cn/post/7048998409067298830\\\")\\n-   [Day04 - 判断数据类型的方式有哪些？| 面试365](https://juejin.cn/post/7049383966700208165 \\\"https://juejin.cn/post/7049383966700208165\\\")\\n-   [Day05 - new 一个函数发生了什么？| 面试365](https://juejin.cn/post/7049731312801808420 \\\"https://juejin.cn/post/7049731312801808420\\\")\\n-   [Day06 - 构造函数的返回值与new实例关系 | 面试365](https://juejin.cn/post/7050087767962976287 \\\"https://juejin.cn/post/7050087767962976287\\\")[\\\\\\n    ](https://juejin.cn/post/7050087767962976287 \\\"https://juejin.cn/post/7050087767962976287\\\")\\n-   [Day07 - 为什么箭头函数不能当构造函数 | 面试365](https://juejin.cn/post/7050476297318825992 \\\"https://juejin.cn/post/7050476297318825992\\\")\\n-   [Day08 - 什么是闭包？如何制造闭包？](https://juejin.cn/post/7050861660000976904 \\\"https://juejin.cn/post/7050861660000976904\\\")\\n-   [Day09 - 闭包应用1 - 制造惰性函数](https://juejin.cn/post/7051233635608821797 \\\"https://juejin.cn/post/7051233635608821797\\\")\\n-   [Day10-闭包应用-偏应用函数与柯里化](https://juejin.cn/post/7051547767855906852 \\\"https://juejin.cn/post/7051547767855906852\\\")\\n-   [Day11-闭包应用 - 立即执行函数IIFE](https://juejin.cn/post/7051968010512236574 \\\"https://juejin.cn/post/7051968010512236574\\\")\\n-   [Day12 - 闭包应用4 - 类库封装](https://juejin.cn/post/7052238635671748616 \\\"https://juejin.cn/post/7052238635671748616\\\")\\n-   [Day13 - 闭包应用6 - 构建器打包webpack](https://juejin.cn/post/7052658786477015054 \\\"https://juejin.cn/post/7052658786477015054\\\")[\\\\\\n    ](https://juejin.cn/post/7052658786477015054 \\\"https://juejin.cn/post/7052658786477015054\\\")\\n-   [Day14 - 词法作用域、块级作用域、作用域链、静态动态作用域](https://juejin.cn/post/7053087344827744292 \\\"https://juejin.cn/post/7053087344827744292\\\")[\\\\\\n    ](https://juejin.cn/post/7053087344827744292 \\\"https://juejin.cn/post/7053087344827744292\\\")\\n-   [Day15 - let为什么可以解决循环陷阱](https://juejin.cn/post/7053475694730280997 \\\"https://juejin.cn/post/7053475694730280997\\\")\\n-   [Day16 - 为什么一定要有块级作用域](https://juejin.cn/post/7053826986812112909 \\\"https://juejin.cn/post/7053826986812112909\\\")\\n-   [Day17 - let是否会造成变量提升](https://juejin.cn/post/7054194651380580389 \\\"https://juejin.cn/post/7054194651380580389\\\")\\n-   [Day18 - this指向的多种形式](https://juejin.cn/post/7054525103098298404 \\\"https://juejin.cn/post/7054525103098298404\\\")\\n-   [Day19 - React与this指向](https://juejin.cn/post/7054949116295512077 \\\"https://juejin.cn/post/7054949116295512077\\\")\\n-   [Day20 - 如何实现call和apply、bind](https://juejin.cn/post/7055224075324489764 \\\"https://juejin.cn/post/7055224075324489764\\\")[\\\\\\n    ](https://juejin.cn/post/7055224075324489764 \\\"https://juejin.cn/post/7055224075324489764\\\")\\n-   [Day21 - innerText、 nodeValue与 textContent的区别](https://juejin.cn/post/7056045978855571493 \\\"https://juejin.cn/post/7056045978855571493\\\")\\n-   [Day22 - 语义化标签搭建wiki](https://juejin.cn/post/7056047002903134244 \\\"https://juejin.cn/post/7056047002903134244\\\")\\n-   [Day23 - document以外的常用对象](https://juejin.cn/post/7056677173561655326 \\\"https://juejin.cn/post/7056677173561655326\\\")[\\\\\\n    ](https://juejin.cn/post/7056677173561655326 \\\"https://juejin.cn/post/7056677173561655326\\\")\\n-   [Day24 - 图片懒加载的原理](https://juejin.cn/post/7056794350361477134 \\\"https://juejin.cn/post/7056794350361477134\\\")\\n-   [Day25 - HTML5新特性](https://juejin.cn/post/7056997859677175821 \\\"https://juejin.cn/post/7056997859677175821\\\")\\n-   [Day26 - Canvas 与 SVG的区别](https://juejin.cn/post/7057410984914190350 \\\"https://juejin.cn/post/7057410984914190350\\\")[\\\\\\n    ](https://juejin.cn/post/7057410984914190350 \\\"https://juejin.cn/post/7057410984914190350\\\")\\n\\n## 天天造轮子\\n\\n-[坚持造轮子第一天 - 模板引擎](https://juejin.cn/post/6884138429181870093 \\\"https://juejin.cn/post/6884138429181870093\\\")\\n\\n-   [坚持造轮子第二天 - 防抖与节流](https://juejin.cn/post/6885250789825052679 \\\"https://juejin.cn/post/6885250789825052679\\\")\\n-   [坚持造轮子第三天 - 数据响应式](https://juejin.cn/post/6885546581438201869 \\\"https://juejin.cn/post/6885546581438201869\\\")\\n-   [坚持造轮子第四天 - 统一状态管理](https://juejin.cn/post/6886002492577234952 \\\"https://juejin.cn/post/6886002492577234952\\\")\\n-   [坚持造轮子第五天 - 时间旅行](https://juejin.cn/post/6887844088335302670 \\\"https://juejin.cn/post/6887844088335302670\\\")[](https://juejin.cn/post/6887844088335302670 \\\"https://juejin.cn/post/6887844088335302670\\\")\\n-   [坚持造轮子第六天 - Mixin -装备合成路径](https://juejin.cn/post/6891935359651807239 \\\"https://juejin.cn/post/6891935359651807239\\\")\\n-   [天天造轮子第七天 - 中间件实现 - Compose 的 N 种姿势](https://juejin.cn/post/6893338774088974343 \\\"https://juejin.cn/post/6893338774088974343\\\")\\n-   [天天造轮子第八天 - Promise - 网友来稿](https://juejin.cn/post/6897911460656070669 \\\"https://juejin.cn/post/6897911460656070669\\\")\\n-   [做了一夜动画，让大家十分钟搞懂Webpack](https://juejin.cn/post/6961961165656326152 \\\"https://juejin.cn/post/6961961165656326152\\\")\\n\\n\\n\\n\\n# 欢迎关注然叔\\n\\n## 公众号： 前端大班车\\n\\n## B站： 全栈然叔\\n\\n🔥 这是然叔最近推出的前端工程化体系课程。\\n\\n40h + 视频讲解。\\n\\n三个实战带你无死角打通前端工程化\\n\\n欢迎联系然叔(微信： xiaran310574 )， 也欢迎留下宝贵意见。\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0231b01c009b4528b79b4e54ec3aa553~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n-   我正在参与掘金技术社区创作者签约计划招募活动，[点击链接报名投稿](https://juejin.cn/post/7112770927082864653 \\\"https://juejin.cn/post/7112770927082864653\\\")。\\n\\n\\n\\n\\n\\n\\n\\n\\n"
    },
    {
        "article_id": "7175818459379417146",
        "cover_image": "https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6381eb201b6a44ed9f3bbfa91e9c6fec~tplv-k3u1fbpfcp-watermark.image?",
        "title": "前端实现登录拼图验证",
        "brief": "不知各位朋友现在在web端进行登录的时候有没有注意一个变化，以前登录的时候是直接账号密码通过就可以了，而现在我们需要通过拼图的验证才能成功登录",
        "user_name": "桃小瑞",
        "view_count": 8048,
        "collect_count": 276,
        "comment_count": 48,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/8ee9674feb974bff53fb08f5850f82bd~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: channing-cyan\\n---\\n\\n开启掘金成长之旅！这是我参与「掘金日新计划 · 12 月更文挑战」的第18天，[点击查看活动详情](https://juejin.cn/post/7167294154827890702)\\n\\n# 前言\\n\\n不知各位朋友现在在`web`端进行登录的时候有没有注意一个变化，以前登录的时候是直接账号密码通过就可以直接登录，再后来图形验证码，数字结果运算验证，到现在的拼图验证。这一系列的转变都是为了防止机器操作，但对于我们来说，有亿点麻烦，但也没办法呀。\\n\\n今天我们也一起来做一个制造亿点麻烦的人，实现一个拼图验证。\\n\\n## 实现原理\\n\\n这个实现原理并不复杂，我们只需要一张图作为我们的拼接素材，我们再单独弄一个盒子，然后移动它，到我们的指定位置，到达指定范围内即验证通过，反之验证未通过。\\n\\n既然原理我们知道了，那我们就开干吧。\\n\\n## 实现前端登录拼图验证\\n\\n本篇文章以 `css` 为主， `javascript`为辅实现。\\n\\n### 搭建框架\\n\\n我们要实现这个功能，我们需要先搭建出来一个框架。\\n\\n```html\\n\\n// css\\n\\n<style>\\n    .check{\\n            width: 400px;\\n            height: 300px;\\n            background-repeat: no-repeat;\\n            background-size: 100% 100%;\\n            background-image: url(https://img0.baidu.com/it/u=2028084904,3939052004&fm=253&fmt=auto&app=138&f=JPEG?w=889&h=500);\\n        }\\n</style>\\n\\n// html\\n\\n<div class=\\\"check\\\"></div>\\n\\n```\\n\\n我们画出来后，它就长下面图这样。\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22595667f2f24d70973422baa982385e~tplv-k3u1fbpfcp-watermark.image?)\\n\\n### 添加被校验区域及校验区域\\n\\n我们需要添加一个被校验的区域及校验区域，用来做我们的校验，像下图这两个东西。\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/01b8357cacf3473aa0ce10e3d1883932~tplv-k3u1fbpfcp-watermark.image?)\\n\\n这里我们使用伪类来实现这两个区域。\\n\\n**校验区域**\\n\\n```css\\n    .check::before{\\n            content: '';\\n            width: 50px;\\n            height: 50px;\\n            background: rgba(0, 0, 0, 0.5);\\n            border: 1px solid #fff;\\n            position: absolute;\\n            top: 100px;\\n            left: 280px;\\n    }\\n```\\n\\n这样一个校验区域就做好了。\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f15bb010c6a444d9beaaf6fed152c034~tplv-k3u1fbpfcp-watermark.image?)\\n\\n**被校验区域**\\n\\n这里我们需要使用到`background-position`根据我们的校验区域大小进行切出我们的被校验区域。\\n\\n`background-image`和`background-repeat`我们直接继承，`background-position`设置为校验区域的坐标位置（也就是距离`top`和`left`的距离），我们将`background-size`图片大小设为原盒子的大小。这样我们就得到了校验区域的那一片区域，也就是我们的被校验区域了。\\n\\n```css\\n    .check-child{\\n            content: '';\\n            width: 50px;\\n            height: 50px;\\n            border: 1px solid #fff;\\n            background-image: inherit;\\n            background-repeat: inherit;\\n            background-size: 400px 300px;\\n            background-position: -280px -100px;\\n            position: absolute;\\n            top: 100px;\\n            left: 10px;\\n    }\\n    \\n    // html\\n    \\n    <!-- 被校验区域 -->\\n    <div class=\\\"check-child\\\"></div>\\n```\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff46a87254fe4329aa983cfedc96d5a4~tplv-k3u1fbpfcp-watermark.image?)\\n\\n### 添加拖动条\\n\\n这里我们两个区域都添加完了，我们需要添加一个拖动条。\\n\\n我们先添加一个拖动区域。\\n\\n```html\\n    // css\\n    .drag{\\n            width: 400px;\\n            height: 50px;\\n            background-color: #e3e3e3;\\n            margin-top: 10px;\\n            position: relative;\\n    }\\n    \\n    // html\\n    <div class=\\\"drag\\\"></div>\\n```\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/535a9248c5b8401a9733264d2470c1c2~tplv-k3u1fbpfcp-watermark.image?)\\n\\n现在拖动区域有了，我们需要在拖动区域内添加一个可拖动的盒子，及操作说明，不然看起来交互效果不友好。\\n\\n#### 添加可拖动的盒子及交互说明\\n\\n我们添加一个可以拖动的盒子。\\n\\n```html\\n    // css\\n    \\n    .drag-child{\\n        width: 50px;\\n        height: 50px;\\n        background-color: aquamarine;\\n        z-index: 10;\\n        position: absolute;\\n        top: 0;\\n        left: 0;\\n    }\\n    \\n    // html\\n    \\n    <!-- 可拖动的盒子 -->\\n    <div class=\\\"drag-child\\\"></div>\\n```\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7441002317f149cd9912239abbe13d6f~tplv-k3u1fbpfcp-watermark.image?)\\n\\n为了我们友好的交互，我们在拖动区域内给他添加操作说明。\\n\\n\\n```html\\n    // css\\n    \\n    .drag-tips{\\n        display: flex;\\n        align-items: center;\\n        justify-content: end;\\n        width: 95%;\\n        height: 100%;\\n        margin: 0 auto;\\n        font-size: 12px;\\n        color: #8a8a8a;\\n    }\\n    \\n    // html\\n    \\n    <!-- 可拖动的盒子 -->\\n    <div class=\\\"drag-tips\\\">\\n        <span>按住左边按钮向右拖动完成上方图像验证</span>\\n    </div>\\n```\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6355c29a78ef40388f31b933d431819b~tplv-k3u1fbpfcp-watermark.image?)\\n\\n#### 拖动条动起来\\n\\n这一步我们需要让我们的拖动盒子动起来，让他可以在拖动区域内随意的左右拖动。\\n\\n```js\\n    // 获取元素实例\\n    const drag = document.querySelector('.drag-child')\\n\\n    // 声明鼠标按下事件\\n    const dragMouseDown = event => {\\n        // 添加鼠标移动事件\\n        document.addEventListener('mousemove', dragMouseMove)\\n    }\\n    // 监听鼠标移动事件\\n    const dragMouseMove = event => {\\n        // 获取当前 x 轴坐标\\n        const { offsetX } = event\\n        if(offsetX < 0 || offsetX > 350){\\n            return\\n        }\\n        // 修改可移动盒子的 x 轴坐标\\n        drag.style.transform = `translateX(${offsetX}px)`\\n    }\\n    // 结束鼠标监听事件\\n    const dragMouseUP = event => {\\n        // 移除鼠标移动事件\\n        document.removeEventListener('mousemove', dragMouseMove)\\n    }\\n\\n    // 添加鼠标按下事件\\n    document.addEventListener('mousedown', dragMouseDown)\\n    // 添加鼠标弹起事件\\n    document.addEventListener('mouseup', dragMouseUP)\\n```\\n现在我们的盒子就可以正常的拖动了，但现在它还有几个问题，我们后面来解决。\\n\\n1. 提示文字会被选中；\\n2. 在`拖动区域`内拖动会闪烁；\\n\\n### 联动被校验区域\\n\\n我们先让被校验区域跟着我们的拖动动起来。\\n\\n```js\\n    // 图形校验\\n    const check = document.querySelector('.check-child')\\n    \\n    // 修改被校验区域坐标\\n    check.style.left = `${offsetX}px`\\n```\\n\\n这样我们的被校验区域就能够跟着动了，我们声明一个方法用来表示，通过校验的回调。\\n\\n```js\\n    // 通过校验回调\\n    const success = () => {\\n        console.log('通过校验');\\n    }\\n    \\n    // 监听鼠标移动事件\\n    const dragMouseMove = event => {\\n        // 获取当前 x 轴坐标\\n        const { offsetX } = event\\n        if(offsetX < 0 || offsetX > 350){\\n            return\\n        }\\n        // 修改可移动盒子的 x 轴坐标\\n        drag.style.transform = `translateX(${offsetX}px)`\\n        \\n        // 修改被校验区域坐标\\n        check.style.transform = `translateX(${offsetX}px)`\\n\\n        if(offsetX >= 278 && offsetX <= 285){\\n            // 执行回调\\n            success()\\n        }\\n    }\\n```\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c6f90f4a9d8b4cf0a587eea416f037da~tplv-k3u1fbpfcp-watermark.image?)\\n\\n### 添加交互动画\\n\\n这里我们在鼠标移出监听的时候添加一个动画，当当前未通过校验的时候我们给他还原到初始位置。\\n\\n```css\\n@keyframes move {\\n    to {\\n        transform: translateX(0);\\n    }\\n}\\n```\\n\\n```js\\n    // 结束鼠标监听事件\\n    const dragMouseUP = event => {\\n        // 移除鼠标移动事件\\n        document.removeEventListener('mousemove', dragMouseMove)\\n\\n        // 获取当前 x 轴坐标\\n        const { offsetX } = event\\n\\n        if(offsetX < 278 || offsetX > 285){\\n            // 修改可移动盒子的 x 轴坐标\\n            drag.style.animation = 'move 0.5s ease-in-out'\\n            // 修改被校验区域坐标\\n            check.style.animation = 'move 0.5s ease-in-out'\\n            \\n            // 动画结束监听回调\\n            const animationEnd = ()=>{\\n                // 修改可移动盒子的 x 轴坐标\\n                drag.style.transform = `translateX(${0}px)`\\n                // 修改被校验区域坐标\\n                check.style.transform = `translateX(${0}px)`\\n\\n                // 清除动画属性\\n                drag.style.animation = ''\\n                check.style.animation = ''\\n                // 移出动画结束监听\\n                document.removeEventListener(\\\"animationend\\\", animationEnd)\\n            }\\n            // 添加动画结束监听\\n            document.addEventListener(\\\"animationend\\\", animationEnd)\\n        }\\n    }\\n```\\n\\n当我们未通过校验，且放开鼠标的时候，它就会自动回到初始位置。\\n\\n### 解决遗留问题\\n\\n#### 1、 提示文字会被选中\\n\\n我们在提示文字的样式中添加`user-select: none;`，禁用掉文字选择。\\n\\n```css\\n    /* 提示文字说明 */\\n    .drag-tips{\\n        display: flex;\\n        align-items: center;\\n        justify-content: end;\\n        width: 95%;\\n        height: 100%;\\n        margin: 0 auto;\\n        font-size: 12px;\\n        color: #8a8a8a;\\n        user-select: none;\\n        z-index: 1;\\n        position: absolute;\\n        top: 0;\\n        left: 0;\\n\\n    }\\n\\n```\\n\\n#### 2、 在`拖动区域`内拖动会闪烁\\n\\n我们将我们刚刚使用的`offsetX`改为`pageX`。这里需要注意一下边距偏移量的问题哦。\\n\\n```js\\n    // 监听鼠标移动事件\\n    const dragMouseMove = event => {\\n        console.log(event);\\n        // 获取当前 x 轴坐标\\n        const { pageX }  = event\\n        if(pageX < 0 || pageX > 350){\\n            return\\n        }\\n        // 修改可移动盒子的 x 轴坐标\\n        drag.style.transform = `translateX(${pageX}px)`\\n        \\n        // 修改被校验区域坐标\\n        check.style.transform = `translateX(${pageX}px)`\\n\\n        if(pageX >= 278 && pageX <= 285){\\n            // 执行回调\\n            success()\\n        }\\n    }\\n    // 结束鼠标监听事件\\n    const dragMouseUP = event => {\\n        // 移除鼠标移动事件\\n        document.removeEventListener('mousemove', dragMouseMove)\\n\\n        // 获取当前 x 轴坐标\\n        const { pageX } = event\\n\\n        if(pageX < 278 || pageX > 285){\\n            // 修改可移动盒子的 x 轴坐标\\n            drag.style.animation = 'move 0.5s ease-in-out'\\n            // 修改被校验区域坐标\\n            check.style.animation = 'move 0.5s ease-in-out'\\n            \\n            // 动画结束监听回调\\n            const animationEnd = ()=>{\\n                // 修改可移动盒子的 x 轴坐标\\n                drag.style.transform = `translateX(${0}px)`\\n                // 修改被校验区域坐标\\n                check.style.transform = `translateX(${0}px)`\\n\\n                // 清除动画属性\\n                drag.style.animation = ''\\n                check.style.animation = ''\\n                // 移出动画结束监听\\n                document.removeEventListener(\\\"animationend\\\", animationEnd)\\n            }\\n            // 添加动画结束监听\\n            document.addEventListener(\\\"animationend\\\", animationEnd)\\n        }\\n    }\\n```\\n\\n## 效果图\\n\\n我们看一下效果图。\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a9ec22abf2584411a7b2b211d0f3185c~tplv-k3u1fbpfcp-watermark.image?)\\n\\n# 完整代码\\n\\n```html\\n<!DOCTYPE html>\\n<html lang=\\\"en\\\">\\n<head>\\n    <meta charset=\\\"UTF-8\\\">\\n    <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\">\\n    <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\">\\n    <title>drag</title>\\n    <style>\\n        *{\\n            margin: 0;\\n            padding: 0;\\n        }\\n\\n        body{\\n            padding: 20px;\\n        }\\n\\n        /* 图形拼图验证码 */\\n        .check{\\n            width: 400px;\\n            height: 300px;\\n            background-repeat: no-repeat;\\n            background-size: 100% 100%;\\n            background-image: url(https://img0.baidu.com/it/u=2028084904,3939052004&fm=253&fmt=auto&app=138&f=JPEG?w=889&h=500);\\n            position: relative;\\n        }\\n\\n        .check::before{\\n            content: '';\\n            width: 50px;\\n            height: 50px;\\n            background: rgba(0, 0, 0, 0.5);\\n            border: 1px solid #fff;\\n            position: absolute;\\n            top: 100px;\\n            left: 280px;\\n        }\\n\\n        .check-child{\\n            content: '';\\n            width: 50px;\\n            height: 50px;\\n            border: 1px solid #fff;\\n            background-image: inherit;\\n            background-repeat: inherit;\\n            background-size: 400px 300px;\\n            background-position: -280px -100px;\\n            position: absolute;\\n            top: 100px;\\n            left: 0;\\n        }\\n        /* 拖动条 */\\n        .drag{\\n            width: 400px;\\n            height: 50px;\\n            background-color: #e3e3e3;\\n            margin-top: 10px;\\n            position: relative;\\n        }\\n        /* 可拖动的盒子 */\\n        .drag-child{\\n            width: 50px;\\n            height: 50px;\\n            background-color: aquamarine;\\n            z-index: 10;\\n            position: absolute;\\n            top: 0;\\n            left: 0;\\n        }\\n        /* 提示文字说明 */\\n        .drag-tips{\\n            display: flex;\\n            align-items: center;\\n            justify-content: end;\\n            width: 95%;\\n            height: 100%;\\n            margin: 0 auto;\\n            font-size: 12px;\\n            color: #8a8a8a;\\n            user-select: none;\\n            z-index: 1;\\n            position: absolute;\\n            top: 0;\\n            left: 0;\\n\\n        }\\n\\n        @keyframes move {\\n            to {\\n                transform: translateX(0);\\n            }\\n        }\\n    </style>\\n</head>\\n<body>\\n    <!-- 图形校验区域 -->\\n    <div class=\\\"check\\\">\\n        <!-- 被校验区域 -->\\n        <div class=\\\"check-child\\\"></div>\\n    </div>\\n    <!-- 拖动条 -->\\n    <div class=\\\"drag\\\">\\n        <!-- 操作说明 -->\\n        <div class=\\\"drag-tips\\\">\\n            <span>按住左边按钮向右拖动完成上方图像验证</span>\\n        </div>\\n        <!-- 可拖动的盒子 -->\\n        <div class=\\\"drag-child\\\"></div>\\n    </div>\\n</body>\\n<script>\\n    // 获取元素实例\\n    const drag = document.querySelector('.drag-child')\\n\\n    // 图形被校验区域\\n    const check = document.querySelector('.check-child')\\n\\n    // 通过校验回调\\n    const success = () => {\\n        console.log('通过校验');\\n    }\\n\\n    // 声明鼠标按下事件\\n    const dragMouseDown = event => {\\n        // 添加鼠标移动事件\\n        document.addEventListener('mousemove', dragMouseMove)\\n    }\\n    // 监听鼠标移动事件\\n    const dragMouseMove = event => {\\n        // 获取当前 x 轴坐标\\n        const { pageX }  = event\\n        if(pageX < 0 || pageX > 350){\\n            return\\n        }\\n        // 修改可移动盒子的 x 轴坐标\\n        drag.style.transform = `translateX(${pageX}px)`\\n        \\n        // 修改被校验区域坐标\\n        check.style.transform = `translateX(${pageX}px)`\\n\\n        if(pageX >= 278 && pageX <= 285){\\n            // 执行回调\\n            success()\\n        }\\n    }\\n    // 结束鼠标监听事件\\n    const dragMouseUP = event => {\\n        // 移除鼠标移动事件\\n        document.removeEventListener('mousemove', dragMouseMove)\\n\\n        // 获取当前 x 轴坐标\\n        const { pageX } = event\\n\\n        if(pageX < 278 || pageX > 285){\\n            // 修改可移动盒子的 x 轴坐标\\n            drag.style.animation = 'move 0.5s ease-in-out'\\n            // 修改被校验区域坐标\\n            check.style.animation = 'move 0.5s ease-in-out'\\n            \\n            // 动画结束监听回调\\n            const animationEnd = ()=>{\\n                // 修改可移动盒子的 x 轴坐标\\n                drag.style.transform = `translateX(${0}px)`\\n                // 修改被校验区域坐标\\n                check.style.transform = `translateX(${0}px)`\\n\\n                // 清除动画属性\\n                drag.style.animation = ''\\n                check.style.animation = ''\\n                // 移出动画结束监听\\n                document.removeEventListener(\\\"animationend\\\", animationEnd)\\n            }\\n            // 添加动画结束监听\\n            document.addEventListener(\\\"animationend\\\", animationEnd)\\n        }\\n    }\\n\\n    // 添加鼠标按下事件\\n    document.addEventListener('mousedown', dragMouseDown)\\n    // 添加鼠标弹起事件\\n    document.addEventListener('mouseup', dragMouseUP)\\n\\n\\n</script>\\n</html>\\n```\\n\\n# 最后\\n\\n本篇`前端实现登录拼图验证`就到此结束了，这个功能一般都是在登录的时候用的。本篇文章的案例可以正常使用。\\n\\n本篇实现的代码中存在一个遗留问题，非拖动区域内能拖动。"
    },
    {
        "article_id": "7183639661246414909",
        "cover_image": "https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/41d316796d2b4d0ea403d1a01bd76acf~tplv-k3u1fbpfcp-watermark.image?",
        "title": "现代前端框架的重要概念",
        "brief": "梳理现代前端框架重要概念，深入代码原理分析。适用于各个阶段前端开发者学习理解，尤其是前端小白入门以及技术 leader 框架选型。建议收藏",
        "user_name": "superZidan",
        "view_count": 9215,
        "collect_count": 201,
        "comment_count": 52,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/21dc2120acb1aa73ab2ff294a0a5eefe~300x300.image",
        "category": "前端",
        "content": "许多初学者经常会问 “我需要学习哪个框架 ？” 以及 “学习框架前需要掌握多少 JS 或者 TS ？” 无数带有主观色彩的文章都在宣传作者首选框架或库的优势，而不是向读者展示其背后的概念以做出更明智的决定。所以让我们先解决第二个问题\\n\\n# 学习框架前需要掌握多少 JS 或者 TS\\n\\n尽可能多地去学以让更好的你理解它们所基于的概念。你将需要了解基本数据类型、函数、基本运算符和文档对象模型 ( DOM )，这是 HTML 和 CSS 在 JS 中的表示。除此之外的一切也都 OK，但并不严格要求某个精通框架或库。\\n\\n如果你是一个完完全全的新手，[JS for cats](http://jsforcats.com/) 应该是一个不错的入门资料。持续学习，直到你感到自信为止，然后继续前进，直到你再次感到自信为止。当掌握了足够的 JS / TS 知识后，你就可以开始学习框架。其他的知识你可以并行学习。\\n\\n# 哪些重要概念\\n\\n-   State （状态）\\n-   Effects （副作用）\\n-   Memoization （记忆化）\\n-   Templating and rendering （模板与渲染）\\n\\n所有现代框架都从这些概念中派生出它们的功能\\n\\n## state\\nState 只是为你的应用程序提供动力的数据。它可能在全局级别，适用于应用程序的大部分组件，或适用于单个组件。让我们写一个计数器的简单例子来说明一下。它保留的计数是 state 。我们可以读取 state 或者写入 state 以增加计数\\n\\n最简单的表示通常是一个变量，其中包含我们的状态所包含的数据：\\n```js\\nlet count = 0; \\nconst increment = () => { count++; }; \\nconst button = document.createElement('button'); \\nbutton.textContent = count; \\nbutton.addEventListener('click', increment); document.body.appendChild(button);\\n```\\n但这个代码有个问题：类似调用 `increment` 方法一样去修改 `count` 的值 ，并不会自动修改 button 的文案。我们需要手动去更新所有的内容，但这样的做法在复杂场景下代码的可维护性 & 扩展性都不是很好。\\n\\n让 `count` 自动更新依赖它的使用方的能力称之为 ***reactivity（响应式）** *。这是通过订阅并重新运行应用程序的订阅部分来更新的。\\n\\n几乎所有的现代前端框架和库都拥有让 state 变成 reactivity 的能力。基本上可以分为 3 种解决方案，采用其中至少一种或者多种混用来实现这个能力：\\n\\n-   Observables / Signals （可观察的 / 信号）\\n-   Reconciliation of immutable updates （协调不可变的更新）\\n-   Transpilation （转译）\\n\\n这些概念还是直接用英文表达比较贴切 🤣\\n\\n### Observables / Signals （可观察的 / 信号）\\n\\nObservables 基本上是在读取 state 的时候通过一个订阅方法来收集依赖，然后在更新的时候触发依赖的更新\\n``` js\\nconst state = (initialValue) => ({\\n  _value: initialValue,\\n  get: function() {\\n    /* 订阅 */;\\n    return this._value; \\n  },\\n  set: function(value) {\\n    this._value = value;\\n    /* 触发更新 */;\\n  }\\n});\\n```\\n\\n[knockout](https://knockoutjs.com/) 是最早使用这个概念的框架之一，它使用带有 / 不带参数的相同函数进行写/读访问\\n\\n这种模式最近有开始有框架通过 signals 来实现，比如 [Solid.js](https://www.solidjs.com/docs/latest/api#createsignal) 和 [preact signals](https://preactjs.com/guide/v10/signals/) ；相同的模式也在 [Vue](https://vuejs.org/) 和 [Svelte](https://svelte.dev/) 中使用到。RxJS 为 Angular 的 reactive 层提供底层能力，是这一模式的延伸，超越了简单状态。[Solid.js](https://www.solidjs.com/) 用 Stores（一些通过 setter 方法来操作的对象）的方式进一步抽象了 signals\\n\\n### Reconciliation of immutable states（协调不可变的更新）\\n不可变意味着如果对象的某个属性发生改变，那么整个对象的引用就会发生改变。所以协调器做的事情就包括通过简单的引用对比就判断出对象是否发生了改变\\n\\n```js\\nconst state1 = {\\n  todos: [{ text: 'understand immutability', complete: false }],\\n  currentText: ''\\n};\\n// 更新 currentText 属性\\nconst state2 = {\\n  todos: state1.todos,\\n  currentText: 'understand reconciliation'\\n};\\n// 添加一个 todo\\nconst state3 = {\\n  todos: [\\n    state1.todos[0],\\n    { text: 'understand reconciliation', complete: true }\\n  ],\\n  currentText: ''\\n};\\n\\n// 由于不可变性，这里将会报错\\nstate3.currentText = 'I am not immutable!';\\n```\\n\\n如你所见，未变更项目的引用被重新使用。如果协调器检测到不同的对象引用，那么它将重新运行所有的组件，让所有的组件的 state （props, memos, effects, context） 都使用最新的这个对象。由于读取访问是被动的，所以需要手动指定对响应值的依赖。\\n\\n很显然，你不会用上面这种方式定义 state 。要么你是从一个已经存在的属性构造 state ，要么你会使用 `reducer` 来构造 state。一个 reducer 函数就是接收一个 state 对象然后返回一个新的 state 对象。\\n\\n[react](https://reactjs.org/) 和 [preact](https://preactjs.com/) 就使用这种模式。它适合与 vDOM 一起使用，我们将在稍后描述模板时探讨它。\\n\\n并不是所有的框架都借助 vDOM 将 state 变成完成响应式。例如 [Mithril.JS](https://mithril.js.org/components.html#state) 要不是在 state 修改后触发对应的生命周期事件，要不是手动调用 `m.redraw()` 方法，才能够触发更新\\n\\n\\n### Transpilation（转译）\\nTranspilation 是在构建阶段，重写我们的代码让代码可以在旧的浏览器运行或者赋予代码其他的能力；在这种情况下，转译则是被用于把一个简单的变量修改成响应式系统的一部分。\\n\\n[Svelte](https://svelte.dev/) 就是基于转译器，该转译器还通过看似简单的变量声明和访问为他们的响应式系统提供能力\\n\\n另外，[Solid.js](https://solidjs.com/) 也是使用 Transpilation ，但 Transpilation 只使用到模版上，没有使用到 state 上\\n\\n## Effects\\n大部分情况下，我们需要做的更多是操作响应式的 state，而很少需要操作基于 state 的 DOM 渲染。我们需要管理好副作用，这些副作用是由于视图更新之外的状态变化而发生的所有事情（虽然有些框架把视图更新也当作是副作用，例如 [Solid.js](https://solidjs.com/) ）\\n\\n记得之前 state 的例子中，我们故意把订阅操作的代码留空。现在让我们把这些留空补齐来处理副作用，让程序能够响应更新\\n\\n``` js\\nconst context = [];\\n\\nconst state = (initialValue) => ({\\n  _subscribers: new Set(),\\n  _value: initialValue,\\n  get: function() {\\n    const current = context.at(-1);\\n    if (current) { this._subscribers.add(current); }\\n    return this._value;\\n  },\\n  set: function(value) {\\n    if (this._value === value) { return; }\\n    this._value = value;\\n    this._subscribers.forEach(sub => sub());\\n  }\\n});\\n\\nconst effect = (fn) => {\\n  const execute = () => {\\n    context.push(execute);\\n    try { fn(); } finally { context.pop(); }\\n  };\\n  execute();\\n};\\n```\\n\\n上面代码基本上是对 [preact signals](https://preactjs.com/guide/v10/signals/) 或者 [Solid.js](https://solidjs.com/) 响应式 state 的简化版本，它不包含错误处理和复杂状态处理（使用一个函数接收之前的状态值，返回下一个状态值），但这些都是很容易就可以加上的\\n\\n这允许我们使前面的示例具有响应性：\\n\\n``` js\\nconst count = state(0);\\nconst increment = () => count.set(count.get() + 1);\\nconst button = document.createElement('button');\\neffect(() => {\\n  button.textContent = count.get();\\n});\\nbutton.addEventListener('click', increment);\\ndocument.body.appendChild(button);\\n```\\n\\n> ☝ 可以尝试运行一下上面 Effect 的两个代码块的例子，源代码地址在 [这里](https://github.com/zidanDirk/concepts-behind-modern-frameworks/tree/master/effects)\\n\\n在大多数情况下，框架允许在不同生命周期，让 Effect 在渲染 DOM 之前、期间或之后运行。\\n\\n## Memoization\\nMemoization 意味着缓存 state 值的计算结果，并且在结果的依赖发生改变的时候进行更新。它基本上是一种返回派生（derived） state 的 Effect\\n\\n在某些会重新运行其组件函数的框架中，如 react 和 preact，允许在它所依赖的状态没有改变时避免这部分组件重新渲染\\n\\n对于其他框架，情况恰恰相反：它允许你选择部分组件进行响应式更新，同时缓存之前的计算\\n\\n对于我们简单的响应系统，memo 大概是这样实现\\n\\n```js\\nconst memo = (fn) => {\\n  let memoized;\\n  effect(() => {\\n    if (memoized) {\\n      memoized.set(fn());\\n    } else {\\n      memoized = state(fn());\\n    }\\n  });\\n  return memoized.get;\\n};\\n```\\n\\n## Templating and rendering\\n\\n现在有了原始的、派生的和缓存形式的 state，我们想把它展示给用户。在我们的例子中，我们直接操作 DOM 来添加按钮和更新按钮的内容文案。\\n\\n为了提升开发体验，几乎所有的现代框架都支持 [DSL](https://baike.baidu.com/item/%E9%A2%86%E5%9F%9F%E7%89%B9%E5%AE%9A%E8%AF%AD%E8%A8%80/2826893) 来在代码中编写类似于所需输出的内容。虽然有不同的风格，比如 `.jsx` ，`.vue` ，`.svelte` 文件，但这一切都归结为用类似于 HTML 的代码来表示 DOM。所以基本上是\\n\\n``` jsx\\n<div>Hello, World</div>\\n\\n// 在你的 JS 代码中\\n// 变成你的 HTML:\\n\\n<div>Hello, World</div>\\n```\\n\\n你可以能会问：“在哪里放置我的 state ?”。非常好的问题，大部分的情况 下，`{}` 用于在属性和节点中表达动态内容。\\n\\n最常用的 JS 模板语言扩展无疑是 JSX。在 react 中，它被编译为存粹的 JavaScript 语言，允许创建对于 DOM 的虚拟表示，也就是经常被提到的「虚拟文档对象」或者简称为 vDOM。\\n\\n这是基于创建 JS 对象比访问 DOM 快得多的前提，所以如果你可以用创建 JS 对象替换访问 DOM，那么你就可以节省时间\\n\\n然而，如果你的项目在任何情况下都没有大量的 DOM 修改或者只是创建不需要修改的对象；那么上面这个方案的优点就会变成缺点，那这个时候就需要使用 memoization 来将缺点的影响降到最小。\\n\\n```js\\n// 1. 源代码\\n<div>Hello, {name}</div>\\n\\n// 2. 转译成 js 代码\\ncreateElement(\\\"div\\\", null, \\\"Hello, \\\", name);\\n\\n// 3. 执行 js 后返回的对象\\n{\\n  \\\"$$typeof\\\": Symbol(react.element),\\n  \\\"type\\\": \\\"div\\\",\\n  \\\"key\\\": null,\\n  \\\"ref\\\": null,\\n  \\\"props\\\": {\\n    \\\"children\\\": \\\"Hello, World\\\"\\n  },\\n  \\\"_owner\\\": null\\n}\\n\\n// 4. 渲染 vdom\\n/* HTMLDivElement */<div>Hello, World</div>\\n```\\n\\nJSX 不仅仅用在 react，也用在了 Solid.js。例如，使用 Solid 转译器更彻底地改变代码\\n\\n``` jsx\\n// 1. 源代码\\n<div>Hello, {name()}</div>\\n\\n// 2. 转译成 js 代码\\nconst _tmpl$ = /*#__PURE__*/_$template(`<div>Hello, </div>`, 2);\\n(() => {\\n  const _el$ = _tmpl$.cloneNode(true),\\n    _el$2 = _el$.firstChild;\\n  _$insert(_el$, name, null);\\n  return _el$;\\n})();\\n\\n// 3. 渲染 vdom\\n/* HTMLDivElement */<div>Hello, World</div>\\n```\\n\\n虽然转译之后的代码一开始看到会觉得挺吓人，但它更容易解释其中代码的逻辑。首先，模版的静态部分被创建出来；然后，创建出来的对象被克隆并创建一个新的实例，新的实例包含被添加的动态部分，以及将动态部分的更新与 state 的更新关联起来。\\n\\nSvelte 在转译的时候做的工作更多，不仅仅处理了模版，还处理了 state\\n\\n``` js\\n// 1. 源代码\\n<script>\\nlet name = 'World';\\nsetTimeout(() => { name = 'you'; }, 1000);\\n</script>\\n\\n<div>Hello, {name}</div>\\n\\n// 2. 转译成 js 代码\\n/* 生成自 Svelte v3.55.0 版本 */\\nimport {\\n        SvelteComponent,\\n        append,\\n        detach,\\n        element,\\n        init,\\n        insert,\\n        noop,\\n        safe_not_equal,\\n        set_data,\\n        text\\n} from \\\"svelte/internal\\\";\\n\\nfunction create_fragment(ctx) {\\n        let div;\\n        let t0;\\n        let t1;\\n\\n        return {\\n                c() {\\n                        div = element(\\\"div\\\");\\n                        t0 = text(\\\"Hello, \\\");\\n                        t1 = text(/*name*/ ctx[0]);\\n                },\\n                m(target, anchor) {\\n                        insert(target, div, anchor);\\n                        append(div, t0);\\n                        append(div, t1);\\n                },\\n                p(ctx, [dirty]) {\\n                        if (dirty & /*name*/ 1) set_data(t1, /*name*/ ctx[0]);\\n                },\\n                i: noop,\\n                o: noop,\\n                d(detaching) {\\n                        if (detaching) detach(div);\\n                }\\n        };\\n}\\n\\nfunction instance($$self, $$props, $$invalidate) {\\n        let name = 'World';\\n\\n        setTimeout(\\n                () => {\\n                        $$invalidate(0, name = 'you');\\n                },\\n                1000\\n        );\\n\\n        return [name];\\n}\\n\\nclass Component extends SvelteComponent {\\n        constructor(options) {\\n                super();\\n                init(this, options, instance, create_fragment, safe_not_equal, {});\\n        }\\n}\\n\\nexport default Component;\\n\\n// 3. 执行 JS 代码\\n/* HTMLDivElement */<div>Hello, World</div>\\n```\\n\\n当然也有例外，在 [Mithril.js](https://mithril.js.org/) 中，虽然可以使用 JSX，但鼓励你编写 JS 代码\\n\\n```js\\n// 1. 源代码\\nconst Hello = {\\n  name: 'World',\\n  oninit: () => setTimeout(() => {\\n    Hello.name = 'you';\\n    m.redraw();\\n  }, 1000),\\n  view: () => m('div', 'Hello, ' + Hello.name + '!')\\n};\\n\\n// 2. 执行 JS 代码\\n/* HTMLDivElement */<div>Hello, World</div>\\n```\\n\\n有的人会觉得这样做的开发体验不太好，但有的人更希望对自己的代码有更多的控制权。这取决于他们想要解决的是哪一类的问题，缺少 transpilation 这个步骤也可能成为优点。\\n\\n许多其他框架也允许在不进行 transpilation 的情况下使用，尽管很少有人这样推荐。\\n\\n# “现在我应该学习什么框架或者库？”\\n\\n我有一些好消息和一些坏消息要告诉你\\n\\n坏消息是：没有银弹。没有任何一个框架是在所有层面都优于其他框架的。任何一个框架都有它的优点和妥协。React 有它的 hook 规则，Angular 缺乏简单的 signals，Vue 的向后兼容性问题，Svelte 的伸缩性不太好，Solid.js 禁止解构，Mithril.js 不是真正的响应式，等等\\n\\n好消息是：没有错误选择 —— 除非项目的要求确实受到限制，无论是在捆绑包大小还是性能方面。每个框架都可以完成工作。有些人可能需要解决他们的设计决策，这可能会使你的速度变慢，但无论如何你都能够获得可行的结果。\\n\\n话虽这么说，没有框架也可能是一个可行的选择。许多项目都被过度使用 JavaScript 破坏了，而带有一些交互性的静态页面也可以完成这项工作。\\n\\n现在你已经了解了这些框架和库所应用的概念，请选择最适合你当前任务的方案。不要为下个项目的框架选型而感到担心。你不需要学习所有的内容。\\n\\n如果你尝试一个新的框架，我发现最有帮助的事情之一就是关注它的社区，无论是在社交媒体、Discord、github 还是其他地方。他们可以告诉你哪些方法适合他们的框架，这将帮助你更快地获得更好的解决方案。\\n\\n# 冲吧，你可以有个人喜好！\\n\\n如果你的主要目标是就业，我建议学习 React 或者 Vue。 如果你想要轻松的获取性能和控制体验，请尝试 Solid.js\\n\\n但请记住，所有其他选择都同样有效。 你不应该因为我这么说就选择一个框架，而应该使用最适合你的框架。\\n\\n如果你看完了整篇文章，感谢你的耐心等待。 希望对你有所帮助。 在这里发表你的评论，祝你有美好的一天 🌹\\n\\n参考文章\\n\\n-   [](https://dev.to/lexlohr/concepts-behind-modern-frameworks-4m1g)<https://dev.to/lexlohr/concepts-behind-modern-frameworks-4m1g>\\n-   [](https://github.com/zidanDirk/concepts-behind-modern-frameworks/)<https://github.com/zidanDirk/concepts-behind-modern-frameworks/>\\n"
    },
    {
        "article_id": "7188124857958137911",
        "cover_image": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0de0ae52db4f4e0ab78fad51f14407c3~tplv-k3u1fbpfcp-watermark.image?",
        "title": "介绍一个令强迫症讨厌的小红点组件",
        "brief": "小红点，然后让强迫症用户“没法活”。 为了 KPI，程序员也不得不实现这样令人讨厌的功能。本篇介绍能让你轻松搞定小红点的 Flutter 组件 —— Badge。",
        "user_name": "岛上码农",
        "view_count": 1523,
        "collect_count": 8,
        "comment_count": 0,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/097899bbe5d10bceb750d5c69415518a~300x300.image",
        "category": "Android",
        "content": "---\\ntheme: v-green\\nhighlight: \\n---\\n\\n### 前言\\n在 App 的运营中，活跃度是一个重要的指标，日活/月活……为了提高活跃度，就发明了小红点，然后让强迫症用户“没法活”。\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b03ac930aa6452eb11be1e9695c5b00~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n小红点虽然很讨厌，但是为了 KPI，程序员也不得不屈从运营同学的~~逼迫~~（讨好），得想办法实现。这一篇，来介绍一个徽标（Badge）组件，能够快速搞定应用内的小红点。\\n### Badge 组件\\n`Badge` 组件被 Flutter 官方推荐，利用它让小红点的实现非常轻松，只需要2个步骤就能搞定。\\n\\n1. 引入依赖\\n\\n在 `pubspec.yaml`文件种引入相应版本的依赖，如下所示。\\n```yaml\\nbadges: ^2.0.3\\n```\\n\\n2. 将需要使用小红点的组件使用 Badge 作为上级组件，设置小红点的位置、显示内容、颜色（没错，也可以改成小蓝点）等参数，示例代码如下所示。\\n```dart\\nBadge(\\n  badgeContent: Text('3'),\\n  position: BadgePosition.topEnd(top: -10, end: -10),\\n  badgeColor: Colors.blue,\\n  child: Icon(Icons.settings),\\n)\\n```\\n`position`可以设置徽标在组件的相对位置，包括右上角（`topEnd`）、右下角（`bottomEnd`）、左上角（`topStart`）、左下角（`bottomStart`）和居中（`center`）等位置。并可以通过调整垂直方向和水平方向的相对位置来进行位置的细微调整。当然，`Badge` 组件考虑了很多应用场景，因此还有其他的一些参数：\\n\\n- `elevation`：阴影偏移量，默认为2，可以设置为0消除阴影；\\n- `gradient`：渐变色填充背景；\\n- `toAnimate`：徽标内容改变后是否启用动效哦，默认有动效。\\n- `shape`：徽标的形状，默认是原型，也可以设置为方形，设置为方形的时候可以使用 `borderRadius` 属性设置圆角弧度。\\n- `borderRadius`：圆角的半径。\\n- `animationType`：内容改变后的动画类型，有渐现（fade）、滑动（slide）和缩放（scale）三种效果。\\n- `showBadge`：是否显示徽标，我们可以利用这个控制小红点的显示与否，比如没有提醒的时候该值设置为 `false` 即可隐藏掉小红点。\\n\\n总的来说，这些参数能够满足所有需要使用徽标的场景了。\\n### 实例\\n我们来看一个实例，我们分别在导航栏右上角、内容区和底部导航栏使用了三种类型的徽标，实现效果如下。\\n\\n![badge.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae248691b0be4741bd7e404cda716c11~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n其中导航栏的代码如下，这是 `Badge` 最简单的实现方式了。\\n```dart\\nAppBar(\\n  title: const Text('Badge Demo'),\\n  actions: [\\n    Badge(\\n      showBadge: _badgeNumber > 0,\\n      padding: const EdgeInsets.all(4.0),\\n      badgeContent: Text(\\n        _badgeNumber < 99 ? _badgeNumber.toString() : '99+',\\n        textAlign: TextAlign.center,\\n        style: const TextStyle(\\n          color: Colors.white,\\n          fontSize: 11.0,\\n        ),\\n      ),\\n      position: BadgePosition.topEnd(top: 4, end: 4),\\n      child: IconButton(\\n        onPressed: () {},\\n        icon: const Icon(\\n          Icons.message_outlined,\\n          color: Colors.white,\\n        ),\\n      ),\\n    ),\\n  ],\\n),\\n```\\n内容区的徽标代码如下，这里使用了渐变色填充，动画形式为缩放，并且将徽标放到了左上角，注意如果使用了渐变色那么会覆盖 `badgeColor` 指定的背景色。\\n```dart\\nBadge(\\n  showBadge: _badgeNumber > 0,\\n  padding: const EdgeInsets.all(6.0),\\n  badgeContent: Text(\\n    _badgeNumber < 99 ? _badgeNumber.toString() : '99+',\\n    textAlign: TextAlign.center,\\n    style: const TextStyle(\\n      color: Colors.white,\\n      fontSize: 10.0,\\n    ),\\n  ),\\n  position: BadgePosition.topStart(top: -10, start: -10),\\n  badgeColor: Colors.blue,\\n  animationType: BadgeAnimationType.scale,\\n  elevation: 0.0,\\n  gradient: const LinearGradient(\\n    begin: Alignment.topCenter,\\n    end: Alignment.bottomCenter,\\n    colors: [\\n      Colors.red,\\n      Colors.orange,\\n      Colors.green,\\n    ],\\n  ),\\n  child: Image.asset(\\n    'images/girl.jpeg',\\n    width: 200,\\n    height: 200,\\n  ),\\n),\\n```\\n底部导航栏的代码如下所示，这里需要注意，`Badge` 组件会根据内容区的尺寸自动调节大小，底部导航栏的显示控件有限，推荐使用小红点（不用数字标识）即可。\\n```dart\\nBottomNavigationBar(items: [\\n  BottomNavigationBarItem(\\n    icon: Badge(\\n        showBadge: _badgeNumber > 0,\\n        padding: const EdgeInsets.all(2.0),\\n        badgeContent: Text(\\n          _badgeNumber < 99 ? _badgeNumber.toString() : '99+',\\n          textAlign: TextAlign.center,\\n          style: const TextStyle(\\n            color: Colors.white,\\n            fontSize: 11.0,\\n          ),\\n        ),\\n        position: BadgePosition.topEnd(top: -4, end: -6),\\n        animationType: BadgeAnimationType.fade,\\n        child: const Icon(Icons.home_outlined)),\\n    label: '首页',\\n  ),\\n  const BottomNavigationBarItem(\\n    icon: Icon(\\n      Icons.star_border,\\n    ),\\n    label: '推荐',\\n  ),\\n  const BottomNavigationBarItem(\\n    icon: Icon(\\n      Icons.account_circle_outlined,\\n    ),\\n    label: '我的',\\n  ),\\n]),\\n```\\n### 总结\\n本篇介绍了使用 `Badge` 组件实现小红点徽标组件。可以看到，`Badge` 组件的使用非常简单，相比我们自己从零写一个 `Badge` 组件来说，使用它可以让我们省时省力、快速地完成运营同学要的小红点。本篇源码已上传至：[实用组件相关代码](https://gitee.com/island-coder/flutter-beginner/tree/master/widgets)。\\n\\n> 我是岛上码农，微信公众号同名。如有问题可以加本人微信交流，微信号：`island-coder`。\\n> \\n> 👍🏻：觉得有收获请点个赞鼓励一下！\\n> \\n> 🌟：收藏文章，方便回看哦！\\n> \\n> 💬：评论交流，互相进步！\\n\\n"
    },
    {
        "article_id": "7188813915826946104",
        "cover_image": "",
        "title": "Git stash 实战 - 代码没写完，想要切到其他分支，除了临时 commit 还有什么办法",
        "brief": "Git 的 stash 功能，顾名思义，就是为了存储代码。Git stash 能帮你完好保存好稍后可能用到的代码，并且快速清理工作目录的工具。",
        "user_name": "Heneyin",
        "view_count": 2878,
        "collect_count": 1,
        "comment_count": 1,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/c42c5baffff036412027cb1625bee16d~300x300.image",
        "category": "开发工具",
        "content": "Git 的 stash 功能，顾名思义，就是为了存储代码。假设你正在分支 `feature/make-bug` 尽情创作，刚修改了一半的代码，你领导忽然告诉你在版本分支 v1.0.0 有个紧急 bug 要你修复。像我刚用 Git 不久的时候，下意识直接切换分支 `git checkout v1.0.0`，这么做的话，就会有两种后果：\\n1. 分支切换失败，git 报错。\\n\\n```\\nerror: Your local changes to the following files would be overwritten by checkout:\\n        service.py\\nPlease commit your changes or stash them before you switch branches.\\nAborting\\n```\\n\\n2. 修改的文件会被带到目标分支。\\n\\n这里先不追究造成这两种情况的原因。如果不使用 stash，怎么能正确切换到 `v1.0.0` 分支呢？有两种方式：\\n1. 在  `feature/make-bug` 使用 commit 提交修改，然后切换到 `v1.0.0` 修改完 bug 后，再切回  `feature/make-bug` 继续开发，如果不愿意保留上次的临时 commit 记录，则执行 `git reset HEAD^` 来完成\\n2. 手动将修改的文件文件保存在 git 工作空间之外。\\n\\n两种都不是好方法，第一种很不灵活，而且还为未完成的工作生成一个 commit。第二种手动复制粘贴更不是好主意。\\n\\n相比于第一种方法，git  stash 可以直接将未提交的修改保存在本地，并允许你做其他的修改，执行其他的 git 操作，比如切到其他分支。当你需要的时候，可以再将 stash 存储过的修改还原。\\n\\n# 如何使用 git stash\\n\\n对于上例，下面是当你使用 git stash 的执行步骤：\\n1. 确保文件已经保存，通常 IDE 会自动保存好。\\n2. 执行 `git stash` 存储当前修改。\\n3. 切换到 `v1.0.0` 分支。\\n4. 在 `v1.0.0` 分支修改 bug，并提交修改。\\n5. 切换回到 `feature/make-bug` 分支。\\n6. 执行 `git stash pop` 命令还原存储的修改。\\n\\n原理上，Git stash 会将代码存储在工程的工作目录 `.git/refs/stash` 中， 并且并不会被 `git push` 推送到远程。\\n\\nGit stash 能帮你完好保存好稍后可能用到的代码，并且快速清理工作目录的工具。\\n\\n# 如何创建一个 stash\\n最简单的命令就是：\\n```\\n$ git stash\\nSaved working directory and index state WIP on master: 83a38ba Merge branch 'feature/make-bug'\\n```\\n\\n默认情况下，git stash 存储没有 commit 的修改。不会存储未跟踪的文件（刚新建没有被 add 的文件）与 ignored 文件，一般来说是不需要这这种文件的。当你确实需要时，可以通过 `git stash` 的额外的参数来控制:\\n- `git stash -u` 或者 `git stash --include-untracked` ：表示存储未跟踪的文件。\\n- `git stash -a` 或者 `git stash --all` ：表示存储为跟踪与 ignored 的文件。\\n\\n# 查看你的 stash\\n\\n使用 `git stash list` 查看现在所有的 stash，stash 是通过堆栈（后进先出）的顺序存储的。如下所示：\\n\\n```\\n$ git stash list\\nstash@{0}: WIP on master: 83a38ba Merge branch 'feature/make-bug'\\n```\\n\\n默认 Git 会为 stash 添加默认描述，如上, 有 WIP 文本（正在工作并编写的代码）、分支名、commit 号，上一个提交的描述。但是这提供的信息不太友好，当有多个 stash 的时候，也难以区分，不利于记忆，这时候你可以使用命令 `git stash save <description>` 自定义 stash 描述：\\n\\n```\\n$ git stash save '添加用户删除 dao' \\nSaved working directory and index state On master: 添加用户删除 dao\\n\\n$ git stash list\\nstash@{0}: On master: 添加用户删除 dao\\nstash@{1}: WIP on master: 83a38ba Merge branch 'feature/make-bug'\\n```\\n\\n# 恢复 stash 改动\\n\\n你可以使用  `git stash apply` 与 `git stash pop` 恢复 stash 的存储。直接执行这两个命令，会恢复栈顶的的 stash（即 `stash@{0}` 最后保存的 stash）到工作目录。\\n两者不同的是，pop 会移除堆栈中的 stash，而 apply 不会。\\n\\n```\\n$ git stash pop \\nOn branch master\\nChanges not staged for commit:\\n  (use \\\"git add <file>...\\\" to update what will be committed)\\n  (use \\\"git checkout -- <file>...\\\" to discard changes in working directory)\\n\\n        modified:   dao.py\\n\\nno changes added to commit (use \\\"git add\\\" and/or \\\"git commit -a\\\")\\n```\\n\\n当你需要恢复最近的 stash 的时候， 直接 `pop` 是最方便的。\\n\\n当然，你可以选择你想恢复哪个 stash，通过指定 stash id 来完成, 同样，pop 会移除堆栈中的指定 stash，而 apply 不会。\\n```\\n$ git stash pop stash@{2}\\n# 直接写 id 也可以\\n$ git stash pop 2\\n```\\n\\n或：\\n```\\n$ git stash apply stash@{1}\\n# 直接写 id 也可以\\n$ git stash pop 1\\n```\\n\\n# 清理 stash\\n当你不需要 stash 的时候，通过下面的命令来清理：\\n\\n- git stash clear 清理所有的 stash\\n- git stash drop <stash_id> 删除指定的 stash\\n\\n```\\n$ git stash drop 0\\n```\\n\\n# 展示 stash 中的修改\\n\\n使用 `git stash show <stash_id>` 来展示修改：\\n```\\n$ git stash show 0\\n dao.py | 3 +++\\n 1 file changed, 3 insertions(+)\\n```\\n传入 `--patch` 或者 `-p` 查看更详细的信息：\\n```\\ndiff --git a/dao.py b/dao.py\\nindex e69de29..8941b16 100644\\n--- a/dao.py\\n+++ b/dao.py\\n@@ -0,0 +1,3 @@\\n+def addUser(user):\\n+    session.insert(user)\\n+    session.commit()\\n```\\n\\n可见是添加了一个叫 addUser 的方法。\\n\\n# 恢复 stash 到新的分支\\n\\n有一个场景，当你想要恢复 stash 的时候，原分支上已经做了与你 stash 冲突的修改。这时候 pop stash，就会造成代码冲突，这时候就可以使用 `git stash branch <new_branch_name stash_id>` 命令来解决，它会创建一个新的分支，并把 stash pop 到新分支上，你可以在新分支上解决冲突与进一步修改：\\n\\n```\\n$ git stash branch feature/modify-dao 0\\nSwitched to a new branch 'feature/modify-dao'\\nOn branch feature/modify-dao\\nChanges to be committed:\\n  (use \\\"git reset HEAD <file>...\\\" to unstage)\\n\\n        modified:   dao.py\\n\\nDropped refs/stash@{0} (4a09ff22f71b41ea5426f16463e61eb9d491c840)\\n```\\n\\n# 创建一个 stash 但先不存储\\n在有些场景下，你可能需要先创建一个 stash，但不想立刻保存到 stash 堆栈中。这时候可以使用 `git stash create '<desc>'` 命令完成，它创建一个 stash，并返回一个引用，在稍后需要存储到堆栈的时候，再使用 `git stash store -m \\\"<desc in stack>\\\" \\\"<引用id>\\\"` 命令。\\n\\n```\\n# 为了方便先清理所有 stash\\n$ git stash clear\\n# 创建但不存储到堆栈\\n$ git stash create 'sample stash'\\ndb37916f9a66853ed780174d305900a757f2cc0b\\n$ git stash list\\n# 空结果\\n```\\n实际存储:\\n```\\ngit stash store -m \\\"sample stash testing..\\\" \\\"db37916f9a66853ed780174d305900a757f2cc0b\\\"\\n```\\n\\n# 总结\\n\\n本文介绍了 stash 的应用场景与常用用法，希望能有所帮助。\\n\\n参考： https://opensource.com/article/21/4/git-stash"
    },
    {
        "article_id": "7188799546904805436",
        "cover_image": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/40d53071468a437a8fe1059e5427ea22~tplv-k3u1fbpfcp-watermark.image?",
        "title": "兔年就是要画一只可爱的小兔子啦",
        "brief": "2023年就是兔年啦~ 在这个兔年开始的时候当然是要画一只可爱的小兔子来保佑我们今年顺顺利利、和和美美，在文章的开头就先祝大家新年快乐！！！ 在新的一年中，祝大家事业“兔”飞猛进，大展宏“兔”，前“",
        "user_name": "鹤云云",
        "view_count": 949,
        "collect_count": 2,
        "comment_count": 0,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/1b99863cd5a91e6784407941bb66409a~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: smartblue\\n---\\n我正在参加「兔了个兔」创意投稿大赛，详情请看：[「兔了个兔」创意投稿大赛](https://juejin.cn/post/7185104994801025061 \\\"https://juejin.cn/post/7185104994801025061\\\")\\n\\n# 前言\\n\\n2023年就是兔年啦~ 在这个兔年开始的时候当然是要画一只可爱的小兔子来保佑我们今年顺顺利利、和和美美，在文章的开头就先祝大家新年快乐！！！\\n\\n在新的一年中，祝大家事业“兔”飞猛进，大展宏“兔”，前“兔”无量！\\n\\n废话就不多说了，阅读完本文你将收获下面这只可爱的小兔子。\\n\\n![20230113-102250.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6bf7060fe465497ea879eb255bf2858a~tplv-k3u1fbpfcp-watermark.image?)\\n\\n需要注意的是，本文主要给出实现的具体思路，但是其中涉及到的一些GLSL有关的基础知识，就不会在本文中详细介绍了，在文中会给出相应的链接，读者可以自行查看。\\n\\n\\n\\n# 分析\\n首先我们来对这个图像进行一波简单的分析。可以很容易的看出来这幅图主要分为 “背景” + “头像” 两个部分。背景中的兔子头实际上就是前面的大的兔子头的缩小版。所以我们还是需要聚焦于头像的绘制。\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61a6a80a6502473fac0cc7f846cf4c1a~tplv-k3u1fbpfcp-watermark.image?)\\n\\n通过上图我们可以看出，整个头像基本上都是由圆（椭圆）和线段构成的，所以从几何元素上来说还是比较简单的。接下来我们将逐步的实现它。\\n\\n# 开始编码\\n\\n首先，我们的运行环境当然是作者喜欢的Shadertoy!!!如果还不知道shadertoy及运行环境的小伙伴，可以查看这篇专栏里的文章。 [Shader从入门到放弃 - 鹤云云的专栏 - 掘金 (juejin.cn)](https://juejin.cn/column/7169417227739856903 \\\"https://juejin.cn/column/7169417227739856903\\\")\\n\\n## 轮廓 —— 头\\n首先我们先画一个圆。\\n\\n```c\\n    float y = uv.y;\\n    vec2 nuv = vec2(uv.x, y);\\n    float d = length(nuv);\\n    float blur = 0.005;\\n    float m = S(0.2, 0.2 - blur, d);\\n    float size = 0.;\\n   \\n    col.rgb = mix(col.rgb, vec3(1.0, 0.976, 0.96), m);\\n\\n```\\n其中，`S` 函数是是给 `smoothstep` 函数定义的别名，为了少打几个字母而已。\\n有关 `smoothstep` 方面的知识，可以在[Shader从入门到放弃（二） —— 常见GLSL内置函数 - 掘金 (juejin.cn)](https://juejin.cn/post/7166939417599279112)这篇文章中查看。在本文中就不再过多的进行赘述了。\\n\\n`mix` 函数的作用是用于将背景色与我们的前景色进行叠加，其具体原理也可以在[Shader从入门到放弃（二） —— 常见GLSL内置函数 - 掘金 (juejin.cn)](https://juejin.cn/post/7166939417599279112) 中查看。\\n\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e9e7811eb042416b91ca071476cd9a14~tplv-k3u1fbpfcp-watermark.image?)\\n\\n但是！！！哪里头这么圆的兔子，所以我得让这个兔子头稍微的变形一丢丢。。。我们可以通过以下代码来实现。\\n\\n```c\\n    float y = uv.y + (uv.x * uv.x) * 0.5;\\n```\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3c2932fbe7043b6950f246e535297f4~tplv-k3u1fbpfcp-watermark.image?)\\n\\n结果如上，这是什么意思呢？ 这里是Shader绘图中一个很重要的技巧。就是将坐标系进行变形，(**domain distortion**)\\n\\n我们绘制一下 `uv.x * uv.x * 0.5` 这个函数图像。\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d2b21c1897c40daa27c8e4260ad41e3~tplv-k3u1fbpfcp-watermark.image?)\\n\\n而我们通过这样的运算，我们在绘制这个圆时的坐标系就会变成下面这样，所以在此坐标系下绘制的圆理所当然的也就会变形咯~\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d0ba19abfa814a3186e0b7ee259ddc95~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## 轮廓 —— 耳朵\\n\\n接下来是兔子🐰的灵魂 —— 耳朵，实际上我们也是画一个圆，只是这里我们要让这个圆变得更加“扁”一点。\\n\\n```c\\nnuv = uv;\\nnuv *= vec2(4.0, 1.0);\\nd = length(nuv);\\n\\nsize = 0.4;\\nblur = 0.01;\\nm = S(size, size - blur, d);\\n\\ncol.rgb = mix(col.rgb, vec3(1.0, 0.976, 0.96), m);\\n```\\n\\n![iShot_2023-01-15_16.17.12.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b9c524d539c241f6a16b91ed132bc645~tplv-k3u1fbpfcp-watermark.image?)\\n\\n接着，类似的我们运用与上面绘制兔头轮廓的方式使其变形一点。\\n\\n```c\\nnuv = uv;\\nnuv = vec2(nuv.x, nuv.y - (nuv.x * nuv.x) * 20.);\\nnuv *= vec2(4.0, 1.0);\\nd = length(nuv);\\n\\nsize = 0.4;\\nblur = 0.01;\\nm = S(size, size - blur, d);\\n\\ncol.rgb = mix(col.rgb, vec3(1.0, 0.976, 0.96), m);\\n```\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8dddff6878e7411899506b6aa76df49b~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n### withInBox\\n接下来有一个比较重点的知识需要注意了，我们需要用到一个叫做 `withInBox`的函数，该函数的作用就是将某个坐标转换到一个矩形内，进行坐标的重映射。该函数如下：\\n\\n```c\\nvec2 withInBox(vec2 uv, vec4 rect) {\\n    return (uv - rect.xy) / (rect.zw - rect.xy);\\n}\\n```\\n很容易看出来，其实就是将画布上的坐标转换到了某个矩形内。简而言之，**就是用这个矩形区域替代了原来的画布区域。**\\n\\n### 旋转\\n在Shader中旋转一个坐标同样是运用的旋转公式，只不过我们可以使用矩阵来简化这一操作，下面给出一个旋转矩阵。我们如果要旋转一个点，那么我们使用这个矩阵来乘以这个坐标就可以了。\\n\\n```c\\nmat2 Rot(float a) {\\n    a = a / 180. * PI;\\n    float c = cos(a);\\n    float s = sin(a);\\n    return mat2(c, s, -s, c);\\n}\\n\\n```\\n\\n代码如下：\\n\\n```c\\nvec2 ruv = uv * Rot(-15.);\\nvec4 rect = vec4(0.0, 0.0, 0.5, 0.5);\\nnuv = withInBox(ruv - vec2(0.08, 0.2), rect);\\nnuv = vec2(nuv.x, nuv.y - (nuv.x * nuv.x) * 20.);\\nnuv *= vec2(4.0, 1.0);\\nd = length(nuv);\\n```\\n此时，我们的画面如下：\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f4a0255d9f247f3ad172728e35d02cf~tplv-k3u1fbpfcp-watermark.image?)\\n\\n我们将之前的兔头也显示出来：\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36cb3cced6ef43569408cefeb2d8cddc~tplv-k3u1fbpfcp-watermark.image?)\\n\\n### 对称作画技巧\\n\\n此时，我们只绘制了一只耳朵，可能读者已经想到我再重复做一遍这个操作不就好了吗？？\\n\\n事实上的确可以做，但是在shader中我们有更加巧妙的办法，对于轴对称的图形，我们通常可以使用取绝对值的方法来快速的绘制对称的图形。所以，此时我们想要绘制另一半的耳朵，只需要取x的绝对值就可以了！\\n\\n截止目前，main函数中的代码如下：\\n```c\\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\\n    vec2 uv = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\\n    vec4 col = vec4(vec3(0.0), 0.);\\n\\n    float y = uv.y + (uv.x * uv.x) * 0.5;\\n    vec2 nuv = vec2(uv.x, y);\\n    float d = length(nuv);\\n    float blur = 0.005;\\n    float m = S(0.2, 0.2 - blur, d);\\n    float size = 0.;\\n    col.rgb = mix(col.rgb, vec3(1.0, 0.976, 0.96), m);\\n    \\n    float side = sign(uv.x);\\n    uv.x = abs(uv.x);a\\n    vec2 ruv = uv * Rot(-15.);\\n    vec4 rect = vec4(0.0, 0.0, 0.5, 0.5);\\n    nuv = withInBox(ruv - vec2(0.08, 0.2), rect);\\n    nuv = vec2(nuv.x, nuv.y - (nuv.x * nuv.x) * 20.);\\n    nuv *= vec2(4.0, 1.0);\\n    d = length(nuv);\\n\\n    size = 0.4;\\n    blur = 0.01;\\n    m = S(size, size - blur, d);\\n    \\n    col.rgb = mix(col.rgb, vec3(1.0, 0.976, 0.96), m);\\n    \\n    fragColor = col;\\n}\\n```\\n可以看出，我们已经初步的具备了一个兔子的轮廓了。\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96edac3abd774d9ebb2122db3fd47f29~tplv-k3u1fbpfcp-watermark.image?)\\n\\n到现在为止，我们基本上已经学到了所有的绘制兔子的方法，接下来就是依葫芦画瓢，方法都是相同的，只不过我们绘制的图形和大小不同罢了，下面的内容就会说的比较粗略了。如果你有任何疑问，可以在评论区发表你的问题。\\n\\n后续绘制兔头的代码我就不一一贴在文章中，在文章的末尾，我会讲完整的代码放在“码上掘金”中，供读者自行查看。\\n\\n## 背景\\n现在让我们快进到绘制完兔头的部分，我们现在要做的就是绘制我们的背景。\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a5afd4995e84cacb079fa7a908ded55~tplv-k3u1fbpfcp-watermark.image?)\\n\\n首先，我们可以看出，在文章开头的图里，我们的背景分成两块，一个是背景的渐变色，另一个则是许多的小兔子。\\n\\n### 渐变色\\n渐变色比较简单，就是根据我们的一个y坐标来混合两种颜色。\\n\\n```c\\nfloat gradient = smoothstep(-0.5, 0.2, uv.y);\\nvec3 col = mix(vec3(1.0, 0.8, 0.9), vec3(0.7, 0.9, 1.0), gradient);\\n```\\n\\n### 许多小兔子\\n许多的小兔子则是利用了另一种shader编程中常用的技巧。我们可以利用下面的代码来将我们的画布划分为一个个的小格子。\\n\\n```c\\nvec2 st = fract(uv * 3.0);\\nvec2 id = floor(uv * 3.0);\\n```\\n上面的代码中的`st` 表示的是每个小格子中新的uv坐标。而`id`则代表每个格子的唯一id。\\n\\n读者可以查看这一篇文章进一步的加深理解。[Shader从入门到放弃（四） —— 绘制闪耀星际 - 掘金 (juejin.cn)](https://juejin.cn/post/7169108140024135688)\\n\\n那么，那么我只需要将这个新的坐标套入刚刚我们绘制兔头的函数中，就可以在这一个个的小格子中绘制出小的兔子头。\\n\\n```c\\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\\n    vec2 uv = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\\n    float gradient = smoothstep(-0.5, 0.2, uv.y);\\n    vec3 col = mix(vec3(1.0, 0.8, 0.9), vec3(0.7, 0.9, 1.0), gradient);\\n    \\n    vec4 head = Head(uv, iTime);\\n    uv *= 5.;\\n    vec2 id = floor(uv);\\n    float n = Hash21(id);\\n    vec2 st = fract(uv) - 0.5;\\n    \\n    vec4 fHead = Head(st, 0.0);\\n    col.rgb = mix(col, fHead.rgb, fHead.a);\\n    col.rgb = mix(col, head.rgb, head.a);\\n\\n    fragColor = vec4(col, 1.0);\\n}\\n```\\n\\n结果如下：\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f448f4bacc6d46e9a542967527b80fd9~tplv-k3u1fbpfcp-watermark.image?)\\n\\n最后，我们可以根据每个格子的id来生成一个hash值，再根据这个hash值来生成一个旋转角度，这样每个格子的旋转初始值都不一样，这样就可以形成一种错落有致的美。\\n\\n为避免啰嗦，最后的代码就不再贴出来了，这块大家可以自行思考一下应该怎样去做。\\n\\n完整的代码如下：\\n[jcode](https://code.juejin.cn/pen/7188798883471261748)\\n# 总结\\n\\nOK，今天我们学习到了如何绘制一只可爱的小兔子，你有没有被这个小兔子所萌化呢？作者最后发现，这只兔子还与“那年那兔那些事”中的兔子竟然有几分神似呢。\\n\\n最后祝大家新年快乐，兔年大吉~~~ 如果你觉得本文有用，别忘了给作者点赞哦。\\n\\n"
    },
    {
        "article_id": "7131801252500865055",
        "cover_image": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a116048dd5a9475889469e1e33240bcd~tplv-k3u1fbpfcp-watermark.image?",
        "title": "关于前端低代码的一些个人观点",
        "brief": "2022，低代码彻底火了，甚至火到没有点相关经验，都不好意思出去面试的程度，堪称lowcode“元年”。在整个互联网大裁员的背景下，无论你是否相信它是降本提效的利器，都不重要了。因为行业趋势总是这般浩",
        "user_name": "郑鱼咚",
        "view_count": 72854,
        "collect_count": 572,
        "comment_count": 273,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/5a3703acdec4ac063d1a675e0718863b~300x300.image",
        "category": "前端",
        "content": "2022，低代码彻底火了，甚至火到没有点相关经验，都不好意思出去面试的程度，堪称lowcode“元年”。在整个互联网大裁员的背景下，无论你是否相信它是降本提效的利器，彷佛都不重要了。因为行业趋势总是这般浩浩荡荡，是不以个人意志为转移的。从下图某技术峰会的分享主题中就可见一斑。\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/940410a2c38a4fbab33b85c9ea6f9031~tplv-k3u1fbpfcp-watermark.image?)\\n\\n刚好笔者最近正在开发一个B端低代码的平台。所以，想把这段时间的感悟整理一下与大家分享一些。不过，开头先声明一点，本文只聊观点与感悟，不聊具体技术细节。 \\n\\n## 低代码的产生背景\\n### 互联网产品趋于标准化\\n据我观察，有相当一部分的程序员一提起低代码就摇头say no，表示曾经被这些低代码平台“伤害过”，因为产品需求一旦涉及平台暂不支持的功能，轻则导致加班返工，重则绩效堪忧，甚至丢了工作。  \\n\\n这是一个新事物发展初期必经的一个阶段: 与现有环境水土不服。假如站在更高的角度，设想一下: 当有一天，你的老板宣布，产品经理以后提的需求一律不得超出低代码平台支持的能力范围时，该作何感想。不要轻易说不可能，因为资本的本质就是追逐利润，假如由于这些非标需求额外付出的开发成本，创造不了预期的收益，那对那些试错成本宽容度较低的团队而言，这些需求完全没有存在的必要（回头想一想，你的产品经理提的那些奇奇怪怪且上线没几天就又改回去的需求，你真的认为有价值嘛）。\\n\\n了解点软件外包行业的都知道，很多外包订单都是先copy一个个的模版项目，在之上稍加改动即可交付。因为和他们对接的大部分客户需求都很标准化。比如，客户需要开发一个H5商城，商品、订单、物流再加一个商品运营后台就完全可以满足需求了，甚至不在意UI的样式与竞品一模一样。不过这里也不排除有定制化开发的报价相比完全套模版会高出一大截的因素，但这也至少说明这些非标需求是锦上添花的功能，根本不是刚需。  \\n\\n其实大厂也有这个趋势。毕竟各厂的业务范围越来越出现交叉的态势，产品层面也都是互相copy，真正具有创新性的产品越来越少。C端的产品，尤其在一些大厂充分竞争或者优势的业务领域，因为要追求UI设计、交互、产品体验的差异性，所以相对不容易标准化。比如每年双11的促销各家要紧跟潮流，玩法每年都不尽相同，这种就很难标准化。但大部分的B端产品，对定制化要求不高，随着产品形式的固化，用户已然形成了一套约定俗成的交互习惯。\\n\\n### 应用开发的技术栈趋于成熟\\n就拿前端出活的主力:js框架来说，vue、react虽然还在大版本的迭代，但对整个开发方式的影响，已经不足以与15、16年jQuery到现代框架的那种革命性相提并论了。更多是一些类如更灵活的逻辑拆分、服务端渲染等方面的优化。针对前端开发中的痛点，拆分出的比如构建工具、前端框架、框架之上的UI组件库、跨端等等各个技术领域的边界，也都划分的比较明确了，且发展日趋成熟。这是前端低代码出现的技术背景。\\n\\n## 前端低代码实现\\n笔者对低代码的理解是: 可以通过配置化的低成本交互方式（主流是拖拽）加上少量的一些胶水代码，去满足一类应用的需求。这里笔者以发展更加成熟的B端低代码讲述，C端也是很类似，但是因为样式、动画等定制要求要比B端的复杂许多，所以目前前端低代码相对成熟的应用是在B端。低代码实现原理其实非常简单，就是先预置丰富的原子组件，通过拖拽选择所需组件在画板上进行位置的编排。之后，进行一些组件属性的设置。\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/459ca8c3c44a49139466c34402f012e8~tplv-k3u1fbpfcp-watermark.image?)\\n\\n最终生产出一份jsonSchema或者供开发者二次开发的“源代码”，驱动用户端的内容渲染。原理虽然简单明确，但它也有一些实现难点。比如以下几种：\\n- 一、宏观设计\\n  - 首先设计一个能够面向不同业务场景的低代码项目，是个不小的挑战。\\n    比如一个公司级别的低代码项目，目标是赋能各条业务线。这个就会有一个问题：每个业务对低代码平台的能力要求是不同的，除了大量可复用的功能，肯定也会有不少的定制化需求。甚至各条业务线的产品形态很不一致，有面向C端的，有面向B端的。 \\n    \\n    如果是中心化的思想，一套低代码平台，满足各业务线的需求，首先人力成本很难均摊下去，其次平台随着接入业务线增多，不可避免的会变得臃肿不堪，难以维护。如果每个业务线都独立做一套符合自身业务特性的低代码，这样难度会降低不少，但也意味着公司级别的低代码物料复用变得困难。\\n    讲下业界目前比较流行的解决方案：\\n    1.  在公司级甚至业界推动低代码协议统一。这样就让跨业务甚至业界的物料复用变得可能，阿里前端委员会为此付出了不少努力，大家有空可以了解下。\\n    2.  将低代码架构分层。先有一个低代码基础架构，再用它去“生成”一个个面向具体业务场景的低代码平台。那么如何设计好这个“生成低代码平台的低代码平台”就成为了重中之中。这有点类似于低代码“中台”与“前台”的关系。\\n    \\n   \\n- 二、实现细节\\n    - 1. 状态联动  \\n这个相对好解决一些。 阿里的formily、x-render、jsonschema-form等这些成熟方案的都能够解决，他们之间的差异更多的是在联动性能上，不过这也是在超长表单场景下差距才会比较明显。\\n    - 2. 事件编排  \\n下图就是目前最常见的一种设计，可以配置点击一个button时，要触发哪种类型的事件，事件触发要调用哪些函数，一般都会内置一些比较常见的函数，比如打开一个Modal框等。如果内置不满足需求，就需要插入一些定制化的代码。\\n\\n以下是阿里lowcode-engine的交互设计。\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/584accd7348847f482d068a68432e187~tplv-k3u1fbpfcp-watermark.image?)\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/296f99f9a3db41ceb2009a885ad24301~tplv-k3u1fbpfcp-watermark.image?)  \\n\\n这个平台内置的相对简单。我接触过的内置相对丰富的是[iofod](https://fx.iofod.cn/)这个全场景低代码平台，这里为他们的开发者打个广告。笔者还与他们的开发者加了好友，吃惊的是这么大的工作量竟然是一个人完成的，体验下来比很多公司团队级的产品都用心。 \\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e01743991d5489a83d9b8843cde65ce~tplv-k3u1fbpfcp-watermark.image?)  \\n\\n- 3. 异步数据绑定\\n\\n传统的前端开发大量时间其实是花在与后端接口的对接上，这些工作在目前前端低代码的开发模式中，一点都不会少。\\n\\n如下图，你需要一个表单回填的功能。后端给的详情数据，与前端表单需要的格式差异很大，这里就不得不去手写一个转换函数去解决。\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1eec4409b724353af6ebfd158d0d7b4~tplv-k3u1fbpfcp-watermark.image?)\\n\\n这也是低代码平台大家诟病最多的一点，即：还是需要写代码。但是低代码的价值，从来就不是追求一行代码不写，而是让开发者尽量的少写代码。有人说，我copy代码其实来的更快，而且这功能我开发起来很熟，代码不会有任何问题。但是，你是不是经常在提交cr之后，又悄悄的commit了几个fix呢。最可怕的是测试也觉得这功能很常见，不用细测了，将隐患带上了线。试着回顾一下过往项目的bug列表，是不是很多都是因为不经意的走神或者疏忽造成的。这就是低代码目前就能够解决的一个问题，通过内置一些常见的功能，减少常见功能的开发、测试成本。使大部分功能的交付质量，不依赖于某一个开发者在某一段时间的开发经验、精力及水平。这是笔者认为，现阶段低代码技术的最大价值。\\n\\n## 低代码对行业的影响\\n\\n### 框架、类库的作者也许会喜闻乐见\\n因为之前要面向不同层次的前端开发者，框架、库的作者往往会在API设计时尽量追求友好易懂，但这种追求会在其他方面比如性能方面作出妥协。这就像尤雨溪说的那样，框架开发有时更像是“带着镣铐跳舞”。很多时侯，用起来“爽”与高性能是一件不可兼得的事情，编程语言的发展就是一例，java、python、js等这些高级语言的流行，本质就是通过牺牲一部分的性能，从而提升普通开发者的编程体验。如果未来的前端框架，只面向低代码平台的开发者，而这些开发者的编程水平大概率比较强时，那么API的设计就可以更加贴近框架一侧，这会让这些框架的潜力发挥的更加彻底。\\n\\n## 自上而下的推动最有效\\n下边讲一下前端视角去推广低代码，可能会遇到的问题:  \\n\\n- 前端开发模式换用低代码之后，UI及产品经理如果还是按照原先对你的期待去要求实现效果。这肯定会造成一些难解的冲突与麻烦。他们也许会认为这个开发最近肯定偷懒了。以往像让某个按钮变个颜色，换个位置这种轻而易举就能答应的事情，现在要思索很久或者直接给个此功能无法支持的回复，这显然不符合产品方的利益。    \\n\\n- 前文提到，如果只是前端开发模式换用低代码，而后端的字段约束，返回格式还是像以前那样的随意，肯定会造成低代码平台上需要处理前后端交互兼容的地方越来越多，这就导致可维护性大大降低。有人说这里可以用node做一个BFF层的接口格式转换，但这种方式也只是换了个地方写兼容代码，治标不治本。\\n\\n所以，最理想是整个产研团队一块推动的方式。这样产品、前端、后端、测试整个流程都对低代码平台有一个统一的功能预期，产品不提非标需求，前后端不写非标代码，测试不测非标功能，这样才能更好的发挥低代码的价值。但是，想想好像有哪里不对劲。至于是哪里不对劲？下一段就会讲到。\\n\\n## 会造成失业吗\\n\\n一定会造成一部分失业。是的，笔者对这个问题表现的偏悲观一些，或者说，更理性一些。针对这个问题，我也询问过很多身边的同行，有一部分说根本不会造成程序员失业，他们给出常见理由如下：\\n1. 低代码平台是用来帮助开发者从日常繁琐重复的工作中解放中，去做一些更有价值的事情。是一件双赢的事情，怎么会失业呢？\\n2. 低代码也是需要人力去开发的，本身就会创造一些岗位出来，这会抵消掉由于它的流行所替代的那些HC。\\n3. 低代码太弱了，比如某一个细分领域且复杂的功能就无法实现。   \\n\\n但这里其实存在一个量上的误解。假如团队有10个人，因为换用低代码之后，只需要2-3个人即可搞定日常的开发，那老板就哪怕花费原先6个人的工资去雇佣剩下的2-3个高手程序员，也是一笔划算的“交易”。而且，这已经不单单是我的设想，而是朋友公司里真实发生的事情。  \\n\\n他们公司的技术负责人，高价请了两个架构师，负责低代码平台的开发、维护。后续用5、6k的低薪资去招聘大量的工作内容就是拖拖拽拽的低代码开发者，甚至是无任何编程经验的人员，简单培训之后即可上岗。遇到需要写专业代码或者比较复杂的的场景，就先记录下来，之后让架构师过来解决。\\n\\n至于第三种观点，我认为低代码其实很像自动驾驶的普及。目前司机这个岗位的存在必要，还是因为现阶段的自动驾驶不够完美。当它应对的场景越来越多，甚至超过经验丰富的老司机时，那司机这个岗位就会消失了。当然，另一方面想，这其实也是一件技术进步带来的好事，可以降低事故发生的几率。\\n\\n这些当然还听起来至少不像是近期会发生的事情。作为一名开发者，目前能做的就是，专注于一些真正有价值的事情上，努力提升自己的不可替代性。优秀的编程思想，架构能力永远是稀缺资源。\\n\\n## 不看好目前的低代码创业\\n\\n目前的低代码发展过程中还未出现一些真正的具有壁垒的技术。稍有点研发实力的公司都能做，而且，因为对自己的业务相对更加了解，做出来会更适合公司的实际情况。当然，目前提供低代码服务的很大一部分公司，很多都是之前做企业SASS、PASS的换了个产品名字，他们之前的产品本来就有市场，所以低代码只是一个帮助他们营销的噱头罢了。\\n\\n## 总结\\n低代码一定是有发展前景的，目前在一些特定的企业oa、sass或者标准化的业务场景比如审批流等特定场景下已经取得了不错的应用。  \\n\\n未来已来。你相信与否已变得不再重要，重要的是当你的老板某一天从隔壁老板口里知晓，这世上存在一种不需要写代码，或者只需少量程序员皆可交付应用的开发方式时，一定会至少先让你们试一试。如果真有那么一天，你刚好是CTO或者决策者，一定记得调研完帮兄弟们说一句，不行，这玩意十分不靠谱！\\n"
    },
    {
        "article_id": "7173809617846140941",
        "cover_image": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc7a02e98f5e4c65a27477603839c5eb~tplv-k3u1fbpfcp-watermark.image?",
        "title": "老板：你为什么要选择 Vue？",
        "brief": "假如你是团队的前端负责人，现在老板要拓展新业务，需要开发一个 Web 应用，让你来做技术选型，你之前用 Vue 比较多，对 Vue 比较熟悉，希望能在团队内部推行 Vue 技术栈，你会怎么跟老板说呢？",
        "user_name": "Kagol",
        "view_count": 13308,
        "collect_count": 77,
        "comment_count": 120,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/0a880dcba7fab84a4ac53445164d3ebd~300x300.image",
        "category": "阅读",
        "content": "大家好，我是 Kagol，[Vue DevUI](https://github.com/DevCloudFE/vue-devui) 开源组件库和 EditorX 富文本编辑器创建者，专注于前端组件库建设和开源社区运营。\\n\\n假如你是团队的前端负责人，现在老板要拓展新业务，需要开发一个 Web 应用，让你来做技术选型，你之前用 Vue 比较多，对 Vue 比较熟悉，希望能在团队内部推行 Vue 技术栈，你会怎么跟老板说呢？以下是我做的一些调研，也许能对你有帮助。\\n\\n声明：Vue 和 React 都是我很喜欢的前端框架，如有说得不对的地方，欢迎一起讨论交流。\\n\\n## 一、Vue 在国内的使用量远高于 React / Angular\\n\\n- 业界主流前端框架：React、Vue、Angular，从近3年的使用趋势上看，React 稳定在第一，Angular 逐年下降，**Vue 持续增长**。\\n- 从受欢迎程度上看，以 Svelte、Solid 为代表的新兴前端框架很受开发者喜爱，不过它们的使用量和生态繁荣程度还远低于三大框架。\\n- 虽然 React 在国外的份额高于 Vue，但 **Vue 在国内的使用量大幅领先于 React**，并且呈现出持续增长的趋势，这意味着**在国内能更容易招聘到使用过 Vue、熟悉 Vue 的开发者**。\\n\\n![全球使用情况.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6246856cf7a24574b50080bd72c33ea6~tplv-k3u1fbpfcp-watermark.image?)\\n\\n图1: Vue 和 React 在全球的使用情况和受欢迎程度对比(来自 StateOfJS 数据)\\n\\n![中国使用情况.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b7ba8891950435b911b250513cf2a76~tplv-k3u1fbpfcp-watermark.image?)\\n\\n图2: Vue 和 React 在中国的使用情况对比（来自 CSDN 调查报告）\\n\\n参考：\\n- [https://2021.stateofjs.com/en-US/libraries/front-end-frameworks/](https://2021.stateofjs.com/en-US/libraries/front-end-frameworks/)\\n- [https://csdn.gitcode.host/Survey-Report-on-Developers-in-China/survey/](https://csdn.gitcode.host/Survey-Report-on-Developers-in-China/survey/)\\n\\n## 二、Vue 中文资料多，学习曲线平缓，上手快\\n\\n- 国人开发，美观易读的官方中文文档，除了基本的使用指南和API文档之外，Vue 官网还提供了深色模式、互动教程、演练场和丰富的示例，降低了开发者的学习成本，提升了文档阅读体验。\\n- 在掘金、知乎、思否等国内技术社区，Vue 的关注者、文章数、讨论数都比 React 高，Vue 相关视频在B站的播放量和评论数总体上也比 React 高，Vue 中文书籍也比 React 的多，这意味着国内的 Vue 开发者拥有比 React 开发者更丰富的中文学习资料，并且在开发过程中遇到问题也能更容易找到解决方案。\\n- 从代码编写上，Vue 使用模板写法，从传统写法过渡的成本低，而 React 的 JSX 写法需要更多额外的学习成本。\\n\\n![官方中文文档易读.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36035f06efea46e2aba3ab06fbc45331~tplv-k3u1fbpfcp-watermark.image?)\\n\\n图3: Vue 官方中文文档\\n\\n![中文学习资料多.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5d045498da9498eb3b0e14e3bce84c2~tplv-k3u1fbpfcp-watermark.image?)\\n\\n图4: Vue 和 React 在国内各技术社区的关注者和内容数据对比\\n\\n![代码编写.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ffac9687c1e748c18a766fdb8557b609~tplv-k3u1fbpfcp-watermark.image?)\\n\\n图5: Vue 和 React 在代码编写上的对比\\n\\n参考：\\n- [https://cn.vuejs.org/](https://cn.vuejs.org/)\\n- [https://juejin.cn/live/xdc202201](https://juejin.cn/live/xdc202201)\\n\\n## 三、Vue 是渐进式框架，更轻量，性能高\\n\\n- Vue 是一个渐进式框架，它的设计非常注重灵活性和“可以被逐步集成”这个特点，可以根据你的需求场景，用不同的方式使用 Vue，并轻易地集成到你的现有项目中，不管你的项目是 HTML 网页、Web Components、SPA、桌面端、移动端、WebGL，甚至是命令行终端界面。\\n- Vue 的体积几乎只有 React 的一半（未压缩情况下），并且 Vue 3.0 的全局 API 和内置组件都支持摇树优化，这意味着用户只需要为他们实际使用到的功能“买单”，未使用的功能代码将不会出现在最终的打包产物中。\\n- 经过 Benchmark 工具的测试，包括创建数据行、替换所有行、部分更新、选择行、交换行、移除行、追加行在内的所有操作，**Vue 都比 React 性能要好**，特别是交换行操作，Vue 比 React 性能高出5倍以上。\\n\\n![包体积.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5fa31e9f7d943308d3c0c0375303c25~tplv-k3u1fbpfcp-watermark.image?)\\n\\n图6: Vue 和 React 包体积对比\\n\\n![性能测试.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe776bb89bf64b01aa66fc86861f671e~tplv-k3u1fbpfcp-watermark.image?)\\n\\n图7: Vue 和 React 性能测试数据\\n\\n参考：\\n- [https://krausest.github.io/js-framework-benchmark/2022/table_chrome_102.0.5005.61.html](https://krausest.github.io/js-framework-benchmark/2022/table_chrome_102.0.5005.61.html)\\n\\n## 四、Vue 官方支持的 Web 应用开发工具全面，可持续性好\\n\\n- Vue 官方提供路由、状态管理、单元测试、静态站点生成等常见 Web 应用开发工具，无需从众多第三方依赖库中做选择，并能获得更好的业务连续性支持；而 React 官方只提供了一个视图层工具，其他必要的 Web 应用开发配套工具都需要依赖于第三方库。\\n- 在 Awesome 资源大全中，awesome-vue 的资源数是 awesome-react 的6倍，这意味着 Vue 开发者不仅能获得更好的官方工具支持，而且能在社区找到更多配套的 Web 开发工具和学习资源。\\n\\n![官方支持.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/11ea54e829984f8d9947f80efc82e8df~tplv-k3u1fbpfcp-watermark.image?)\\n\\n图8: Vue 和 React 官方工具和生态对比\\n\\n参考：\\n- [https://github.com/vuejs/awesome-vue](https://github.com/vuejs/awesome-vue)\\n- [https://github.com/enaqx/awesome-react](https://github.com/enaqx/awesome-react)\\n\\n再次声明：Vue 和 React 都是我很喜欢的前端框架，我们的 Vue DevUI 组件以及组件的单元测试都是使用 TypeScript + JSX 语法写的，所以如有说得不对的地方，欢迎一起友好讨论交流。"
    },
    {
        "article_id": "7151221875224346637",
        "cover_image": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da64f164dff44fc0b4665ae732c9d788~tplv-k3u1fbpfcp-watermark.image?",
        "title": "2022年我的面试万字总结（代码篇）",
        "brief": "又到了金九银十季，最近我也是奔波于各种面试。我自己总结整理了很多方向的前端面试题。借着国庆这个假期，也把这些题目总结分享给大家，也祝正在面试的朋友们能够拿到满意的offer。",
        "user_name": "逍丶",
        "view_count": 15590,
        "collect_count": 743,
        "comment_count": 21,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/a87f08adcd0dad907726396180915552~300x300.image",
        "category": "前端",
        "content": "---\\nhighlight: arduino-light\\ntheme: orange\\n---\\n持续创作，加速成长！这是我参与「掘金日新计划 · 10 月更文挑战」的第6天，[点击查看活动详情](https://juejin.cn/post/7147654075599978532 \\\"https://juejin.cn/post/7147654075599978532\\\")\\n\\n# 前言\\n\\n又到了金九银十季，最近我也是奔波于各种面试。我自己总结整理了很多方向的前端面试题。借着国庆这个假期，也把这些题目总结分享给大家，也祝正在面试的朋友们能够拿到满意的offer。\\n# 往期文章\\n（1）[ 2022年我的面试万字总结（浏览器网络篇）](https://juejin.cn/post/7149438206419664927)\\n\\n（2）[ 2022年我的面试万字总结（CSS篇）](https://juejin.cn/post/7149716216167268366)\\n\\n（3）[  2022年我的面试万字总结（HTML篇）](https://juejin.cn/post/7150109570609152014)\\n\\n（4）[ 2022年我的面试万字总结（JS篇上） ](https://juejin.cn/post/7150462512817782815)\\n\\n（5）[ 2022年我的面试万字总结（JS篇下）](https://juejin.cn/editor/drafts/7150847615263834119)\\n\\n（7）[ 2022年我的面试万字总结（Vue上）](https://juejin.cn/post/7151597651719356446)\\n\\n（8）[ 2022年我的面试万字总结（Vue下）](https://juejin.cn/post/7151604799077613599)\\n\\n（9）[ 2022年我的面试万字总结（Vue3+TS）](https://juejin.cn/post/7160962909332307981)\\n \\n （10）[ 2022年我的面试万字总结（Node、webpack、性能优化）](https://juejin.cn/post/7161292246526984228)\\n  \\n（11）[ 2022年我的面试万字总结（小程序、git）](https://juejin.cn/post/7161584249898795045)\\n\\n# 一、手写代码题\\n## 1. 手写Object.create\\n\\n思路：将传入的对象作为原型\\n\\n```\\nfunction create(obj) {\\n  function F() {}\\n  F.prototype = obj\\n  return new F()\\n}\\n```\\n\\n## 2. 手写instanceof\\n\\ninstanceof 运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。\\n\\n实现步骤：\\n\\n0.  首先获取类型的原型\\n0.  然后获得对象的原型\\n0.  然后一直循环判断对象的原型是否等于类型的原型，直到对象原型为 `null`，因为原型链最终为 `null`\\n\\n```\\nfunction myInstanceof(left, right) {\\n  let proto = Object.getPrototypeOf(left), // 获取对象的原型\\n      prototype = right.prototype; // 获取构造函数的 prototype 对象\\n​\\n  // 判断构造函数的 prototype 对象是否在对象的原型链上\\n  while (true) {\\n    if (!proto) return false;\\n    if (proto === prototype) return true;\\n​\\n    proto = Object.getPrototypeOf(proto);\\n  }\\n}\\n```\\n\\n## 3. 手写 new\\n\\n（1）首先创建了一个新的空对象\\n\\n（2）设置原型，将对象的原型设置为函数的 prototype 对象。\\n\\n（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）\\n\\n（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。\\n\\n```\\n function myNew(fn, ...args) {\\n      // 判断参数是否是一个函数\\n      if (typeof fn !== \\\"function\\\") {\\n        return console.error(\\\"type error\\\");\\n      }\\n      // 创建一个对象，并将对象的原型绑定到构造函数的原型上\\n      const obj = Object.create(fn.prototype);\\n      const value = fn.apply(obj, args); // 调用构造函数，并且this绑定到obj上\\n      // 如果构造函数有返回值，并且返回的是对象，就返回value ;否则返回obj\\n      return value instanceof Object ? value : obj;\\n    }\\n```\\n\\n## 4. 手写promise(简易版)\\n\\n```\\nclass MyPromise {\\n  constructor(fn){\\n    // 存储 reslove 回调函数列表\\n    this.callbacks = []\\n    const resolve = (value) => {\\n      this.data = value // 返回值给后面的 .then\\n      while(this.callbacks.length) {\\n        let cb = this.callbacks.shift()\\n        cb(value)\\n      }\\n    }\\n    fn(resolve)\\n  }\\n  then(onResolvedCallback) {\\n    return new MyPromise((resolve) => {\\n      this.callbacks.push(() => {\\n        const res = onResolvedCallback(this.data)\\n        if (res instanceof MyPromise) {\\n          res.then(resolve)\\n        } else {\\n          resolve(res)\\n        }\\n      })\\n    })\\n  }\\n}\\n// 这是测试案例\\nnew MyPromise((resolve) => {\\n  setTimeout(() => {\\n    resolve(1)\\n  }, 1000)\\n}).then((res) => {\\n    console.log(res)\\n    return new MyPromise((resolve) => {\\n      setTimeout(() => {\\n        resolve(2)\\n      }, 1000)\\n    })\\n}).then(res =>{console.log(res)})\\n```\\n\\n### 4.2 Promise.all\\n\\n```\\nMyPromise.all = function (promisesList) {\\n  return new MyPromise((resolve, reject) => {\\n    if (!Array.isArray(promiselList) return reject(new Error('必须是数组'))\\n    if (!promisesList.length) return resolve([])\\n    let arr = [], count = 0\\n    // 直接循环同时执行传进来的promise\\n    for (let i = 0, len = promisesList.length; i < len; i++) {\\n      // 因为有可能是 promise 有可能不是，所以用resolve()不管是不是都会自动转成promise\\n      Promise.resolve(promise).then(result => {\\n          // 由到promise在初始化的时候就执行了，.then只是拿结果而已，所以执行完成的顺序有可能和传进来的数组不一样\\n          // 也就是说直接push到arr的话，顺序有可能会出错\\n          count++\\n          arr[i] = result\\n          // 不能用arr.length===len，是因为数组的特性\\n          // arr=[]; arr[3]='xx'; console.log(arr.length) 这打印出来会是4 而不是1\\n          if(count === len) resolve(arr)\\n      }).catch(err => reject(err))\\n    }\\n  })\\n}\\n```\\n\\n### 4.3 Promise.race\\n\\n传参和上面的 all 一模一样，传入一个 Promise 实例集合的数组，然后全部同时执行，谁先快先执行完就返回谁，只返回一个结果\\n\\n```\\nMyPromise.race = function(promisesList) {\\n  return new MyPromise((resolve, reject) => {\\n    // 直接循环同时执行传进来的promise\\n    for (const promise of promisesList) {\\n      // 直接返回出去了，所以只有一个，就看哪个快\\n      promise.then(resolve, reject)\\n    }\\n  })\\n}\\n```\\n\\n## 5. 防抖和节流\\n\\n函数防抖是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。\\n\\n函数节流是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。\\n\\n```\\n// //防抖\\nfunction debounce(fn, date) {\\n  let timer  //声明接收定时器的变量\\n  return function (...arg) {  // 获取参数\\n    timer && clearTimeout(timer)  // 清空定时器\\n    timer = setTimeout(() => {  //  生成新的定时器\\n      //因为箭头函数里的this指向上层作用域的this,所以这里可以直接用this，不需要声明其他的变量来接收\\n      fn.apply(this, arg) // fn()\\n    }, date)\\n  }\\n}\\n//--------------------------------\\n// 节流\\nfunction debounce(fn, data) {\\n  let timer = +new Date()  // 声明初始时间\\n  return function (...arg) { // 获取参数\\n    let newTimer = +new Date()  // 获取触发事件的时间\\n    if (newTimer - timer >= data) {  // 时间判断,是否满足条件\\n      fn.apply(this, arg)  // 调用需要执行的函数,修改this值,并且传入参数\\n      timer = +new Date() // 重置初始时间\\n    }\\n  }\\n}\\n```\\n\\n## 6. 手写 call 函数\\n\\n**call 函数的实现步骤：**\\n\\n0.  判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。\\n0.  判断传入上下文对象是否存在，如果不存在，则设置为 window 。\\n0.  处理传入的参数，截取第一个参数后的所有参数。\\n0.  将函数作为上下文对象的一个属性。\\n0.  使用上下文对象来调用这个方法，并保存返回结果。\\n0.  删除刚才新增的属性。\\n0.  返回结果。\\n\\n```\\n// call函数实现\\nFunction.prototype.myCall = function(context) {\\n  // 判断调用对象\\n  if (typeof this !== \\\"function\\\") {\\n    console.error(\\\"type error\\\");\\n  }\\n  // 获取参数\\n  let args = [...arguments].slice(1),\\n      result = null;\\n  // 判断 context 是否传入，如果未传入则设置为 window\\n  context = context || window;\\n  // 将调用函数设为对象的方法\\n  context.fn = this;\\n  // 调用函数\\n  result = context.fn(...args);\\n  // 将属性删除\\n  delete context.fn;\\n  return result;\\n};\\n```\\n\\n## 7. 手写 apply 函数\\n\\n**apply 函数的实现步骤：**\\n\\n0.  判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。\\n0.  判断传入上下文对象是否存在，如果不存在，则设置为 window 。\\n0.  将函数作为上下文对象的一个属性。\\n0.  判断参数值是否传入\\n0.  使用上下文对象来调用这个方法，并保存返回结果。\\n0.  删除刚才新增的属性\\n0.  返回结果\\n\\n```\\n// apply 函数实现\\nFunction.prototype.myApply = function(context) {\\n  // 判断调用对象是否为函数\\n  if (typeof this !== \\\"function\\\") {\\n    throw new TypeError(\\\"Error\\\");\\n  }\\n  let result = null;\\n  // 判断 context 是否存在，如果未传入则为 window\\n  context = context || window;\\n  // 将函数设为对象的方法\\n  context.fn = this;\\n  // 调用方法\\n  if (arguments[1]) {\\n    result = context.fn(...arguments[1]);\\n  } else {\\n    result = context.fn();\\n  }\\n  // 将属性删除\\n  delete context.fn;\\n  return result;\\n};\\n```\\n\\n## 8. 手写 bind 函数\\n\\n**bind 函数的实现步骤：**\\n\\n0.  判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。\\n0.  保存当前函数的引用，获取其余传入参数值。\\n0.  创建一个函数返回\\n0.  函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。\\n\\n```\\n// bind 函数实现\\nFunction.prototype.myBind = function(context) {\\n  // 判断调用对象是否为函数\\n  if (typeof this !== \\\"function\\\") {\\n    throw new TypeError(\\\"Error\\\");\\n  }\\n  // 获取参数\\n  var args = [...arguments].slice(1),\\n      fn = this;\\n  return function Fn() {\\n    // 根据调用方式，传入不同绑定值\\n    return fn.apply(\\n      this instanceof Fn ? this : context,\\n      args.concat(...arguments)\\n    );\\n  };\\n};\\n```\\n\\n## 9. 函数柯里化的实现\\n\\n函数柯里化指的是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。\\n\\n```\\n\\nfunction curry(fn, ...args) {\\n  return fn.length <= args.length ? fn(...args) : curry.bind(null, fn, ...args);\\n}\\n```\\n\\n## 10. 手写AJAX请求\\n\\n**创建AJAX请求的步骤：**\\n\\n-   创建一个 XMLHttpRequest 对象。\\n-   在这个对象上**使用 open 方法创建一个 HTTP 请求**，open 方法所需要的参数是请求的方法、请求的地址、是否异步和用户的认证信息。\\n-   在发起请求前，可以为这个对象**添加一些信息和监听函数**。比如说可以通过 setRequestHeader 方法来为请求添加头信息。还可以为这个对象添加一个状态监听函数。一个 XMLHttpRequest 对象一共有 5 个状态，当它的状态变化时会触发onreadystatechange 事件，可以通过设置监听函数，来处理请求成功后的结果。当对象的 readyState 变为 4 的时候，代表服务器返回的数据接收完成，这个时候可以通过判断请求的状态，如果状态是 2xx 或者 304 的话则代表返回正常。这个时候就可以通过 response 中的数据来对页面进行更新了。\\n-   当对象的属性和监听函数设置完成后，最后调**用 sent 方法来向服务器发起请求**，可以传入参数作为发送的数据体。\\n\\n```\\nconst SERVER_URL = \\\"/server\\\";\\nlet xhr = new XMLHttpRequest();\\n// 创建 Http 请求\\nxhr.open(\\\"GET\\\", SERVER_URL, true);\\n// 设置状态监听函数\\nxhr.onreadystatechange = function() {\\n  if (this.readyState !== 4) return;\\n  // 当请求成功时\\n  if (this.status === 200) {\\n    handle(this.response);\\n  } else {\\n    console.error(this.statusText);\\n  }\\n};\\n// 设置请求失败时的监听函数\\nxhr.onerror = function() {\\n  console.error(this.statusText);\\n};\\n// 设置请求头信息\\nxhr.responseType = \\\"json\\\";\\nxhr.setRequestHeader(\\\"Accept\\\", \\\"application/json\\\");\\n// 发送 Http 请求\\nxhr.send(null);\\n```\\n\\n## 11. 使用Promise封装AJAX请求\\n\\n```\\n// promise 封装实现：\\nfunction getJSON(url) {\\n  // 创建一个 promise 对象\\n  let promise = new Promise(function(resolve, reject) {\\n    let xhr = new XMLHttpRequest();\\n    // 新建一个 http 请求\\n    xhr.open(\\\"GET\\\", url, true);\\n    // 设置状态的监听函数\\n    xhr.onreadystatechange = function() {\\n      if (this.readyState !== 4) return;\\n      // 当请求成功或失败时，改变 promise 的状态\\n      if (this.status === 200) {\\n        resolve(this.response);\\n      } else {\\n        reject(new Error(this.statusText));\\n      }\\n    };\\n    // 设置错误监听函数\\n    xhr.onerror = function() {\\n      reject(new Error(this.statusText));\\n    };\\n    // 设置响应的数据类型\\n    xhr.responseType = \\\"json\\\";\\n    // 设置请求头信息\\n    xhr.setRequestHeader(\\\"Accept\\\", \\\"application/json\\\");\\n    // 发送 http 请求\\n    xhr.send(null);\\n  });\\n  return promise;\\n}\\n```\\n\\n## 12. 手写深拷贝\\n\\n```\\n function fn(obj) {\\n      // 判断数据是否是复杂类型\\n      if (obj instanceof Object) {\\n        //判断数据是否是数组\\n        if (Array.isArray(obj)) {\\n          //声明一个空数组来接收拷贝后的数据\\n          let result = []\\n          obj.forEach(item => {\\n            // 需要递归深层遍历，否则复制的是地址\\n            result.push(fn(item))\\n          })\\n          // 返回输出这个数组,数组拷贝完成\\n          return result\\n        } else {\\n          //如果是对象,就声明一个空对象来接收拷贝后的数据\\n          let result = {}\\n          for (let k in obj) {\\n            // 使用递归深层遍历\\n            result[k] = fn(obj[k])\\n          }\\n          // 返回输出这个对象,对象拷贝完成\\n          return result\\n        }\\n      }\\n      // 简单数据类型则直接返回输出\\n      return obj\\n    }\\n```\\n\\n## 13. 手写打乱数组顺序的方法\\n\\n主要的实现思路就是：\\n\\n-   取出数组的第一个元素，随机产生一个索引值，将该第一个元素和这个索引对应的元素进行交换。\\n-   第二次取出数据数组第二个元素，随机产生一个除了索引为1的之外的索引值，并将第二个元素与该索引值对应的元素进行交换\\n-   按照上面的规律执行，直到遍历完成\\n\\n```\\nlet arr = [1,2,3,4,5,6,7,8,9,10];\\nfor (let i = 0; i < arr.length; i++) {\\n  const randomIndex = Math.round(Math.random() * (arr.length - 1 - i)) + i;\\n  [arr[i], arr[randomIndex]] = [arr[randomIndex], arr[i]];\\n}\\nconsole.log(arr)\\n​\\n```\\n\\n## 14. 实现数组扁平化\\n\\n通过循环递归的方式，一项一项地去遍历，如果每一项还是一个数组，那么就继续往下遍历，利用递归程序的方法，来实现数组的每一项的连接：\\n\\n```\\nlet arr = [1, [2, [3, 4, 5]]];\\nfunction flatten(arr) {\\n  let result = [];\\n​\\n  for(let i = 0; i < arr.length; i++) {\\n    if(Array.isArray(arr[i])) {\\n      result = result.concat(flatten(arr[i]));\\n    } else {\\n      result.push(arr[i]);\\n    }\\n  }\\n  return result;\\n}\\nflatten(arr);  //  [1, 2, 3, 4，5]\\n```\\n\\n## 15. 实现数组的flat方法\\n\\n```\\nfunction _flat(arr, depth) {\\n  if(!Array.isArray(arr) || depth <= 0) {\\n    return arr;\\n  }\\n  return arr.reduce((prev, cur) => {\\n    if (Array.isArray(cur)) {\\n      return prev.concat(_flat(cur, depth - 1))\\n    } else {\\n      return prev.concat(cur);\\n    }\\n  }, []);\\n}\\n```\\n\\n## 16. 实现数组的push方法\\n\\n```\\nlet arr = [];\\nArray.prototype.push = function() {\\n    for( let i = 0 ; i < arguments.length ; i++){\\n        this[this.length] = arguments[i] ;\\n    }\\n    return this.length;\\n}\\n​\\n```\\n\\n## 17. 实现数组的filter方法\\n\\n```\\nArray.prototype._filter = function(fn) {\\n    if (typeof fn !== \\\"function\\\") {\\n        throw Error('参数必须是一个函数');\\n    }\\n    const res = [];\\n    for (let i = 0, len = this.length; i < len; i++) {\\n        fn(this[i]) && res.push(this[i]);\\n    }\\n    return res;\\n}\\n```\\n\\n## 18. 实现数组的map方法\\n\\n```\\nArray.prototype._map = function(fn) {\\n   if (typeof fn !== \\\"function\\\") {\\n        throw Error('参数必须是一个函数');\\n    }\\n    const res = [];\\n    for (let i = 0, len = this.length; i < len; i++) {\\n        res.push(fn(this[i]));\\n    }\\n    return res;\\n}\\n```\\n\\n## 19. 实现 add(1)(2)(3)(4)\\n\\n可以实现任意数量数字相加，但是需要用+号隐式转换\\n\\n```\\n function fn() {\\n      let result = [];\\n      function add(...args) {\\n        // ...args剩余参数,可以获取到传进来的参数\\n        result = [...result, ...args]\\n        return add;\\n      };\\n      // 创建一个取代 valueOf 方法的函数,覆盖自定义对象的 valueOf 方法\\n      add.toString = () => result.reduce((sum, k) => sum + k, 0);\\n      return add;\\n    };\\nlet add = fn()\\n   console.log(+add(1)(2)(3)(4)) // --->10\\n    // let add2 = fn();\\n    console.log(+add2(1, 2, 3)(4)) // --->10\\n```\\n\\n参数固定的情况下，不需要用+号，可以根据参数长度来判断返回值\\n\\n```\\n    function currying(fn, length) {\\n      length = length || fn.length; // 第一次调用,给length赋值fn的长度,后面每次重复调用,length的长度都会减去参数的长度\\n      return function (...args) {\\n        return args.length >= length // 当前传递进来的参数的长度与length长度进行比较\\n          ? fn.apply(this, args) // 把最后一组实参传给为赋值的形参,此时所有形参都已赋值,并调用fn函数\\n          : currying(fn.bind(this, ...args), length - args.length)\\n        // 每一次调用fn.bind,都会把当前的args里的实参依次传给fn的形参,length的长度减去参数的长度\\n        // 相当于fn.bind(this, 1).bind(this, 2, 3),bind的连续调用,来填充fn的参数\\n        // 直到某一次调用,fn的形参即将全部都被赋值时,条件成立,会执行fn.apply,把最后的参数传递过去,并且调用fn\\n      }\\n    }\\n    function fn(a, b, c, d) {\\n      return a + b + c + d\\n    }\\n    const add = currying(fn)\\n    add(4)(3)(1)(2) //10\\n    add(1, 3)(4)(2) //10\\n    add(1)(3, 4, 2) //10\\n```\\n\\n## 20. 用Promise实现图片的异步加载\\n\\n```\\nlet imageAsync=(url)=>{\\n            return new Promise((resolve,reject)=>{\\n                let img = new Image();\\n                img.src = url;\\n                img.οnlοad=()=>{\\n                    console.log(`图片请求成功，此处进行通用操作`);\\n                    resolve(image);\\n                }\\n                img.οnerrοr=(err)=>{\\n                    console.log(`失败，此处进行失败的通用操作`);\\n                    reject(err);\\n                }\\n            })\\n        }\\n        \\nimageAsync(\\\"url\\\").then(()=>{\\n    console.log(\\\"加载成功\\\");\\n}).catch((error)=>{\\n    console.log(\\\"加载失败\\\");\\n})\\n```\\n\\n## 21. 手写发布-订阅模式\\n\\n```\\nclass EventCenter{\\n  // 1. 定义事件容器，用来装事件数组\\n    let handlers = {}\\n​\\n  // 2. 添加事件方法，参数：事件名 事件方法\\n  addEventListener(type, handler) {\\n    // 创建新数组容器\\n    if (!this.handlers[type]) {\\n      this.handlers[type] = []\\n    }\\n    // 存入事件\\n    this.handlers[type].push(handler)\\n  }\\n​\\n  // 3. 触发事件，参数：事件名 事件参数\\n  dispatchEvent(type, params) {\\n    // 若没有注册该事件则抛出错误\\n    if (!this.handlers[type]) {\\n      return new Error('该事件未注册')\\n    }\\n    // 触发事件\\n    this.handlers[type].forEach(handler => {\\n      handler(...params)\\n    })\\n  }\\n​\\n  // 4. 事件移除，参数：事件名 要删除事件，若无第二个参数则删除该事件的订阅和发布\\n  removeEventListener(type, handler) {\\n    if (!this.handlers[type]) {\\n      return new Error('事件无效')\\n    }\\n    if (!handler) {\\n      // 移除事件\\n      delete this.handlers[type]\\n    } else {\\n      const index = this.handlers[type].findIndex(el => el === handler)\\n      if (index === -1) {\\n        return new Error('无该绑定事件')\\n      }\\n      // 移除事件\\n      this.handlers[type].splice(index, 1)\\n      if (this.handlers[type].length === 0) {\\n        delete this.handlers[type]\\n      }\\n    }\\n  }\\n}\\n```\\n\\n## 22. Object.defineProperty(简易版)\\n\\n```\\n //  Vue2的响应式原理，结合了Object.defineProperty的数据劫持，以及发布订阅者模式\\n //  Vue2的数据劫持，就是通过递归遍历data里的数据，用Object.defineProperty给每一个属性添加getter和setter,\\n //  并且把data里的属性挂载到vue实例中，修改vue实例上的属性时，就会触发对应的setter函数，向Dep订阅器发布更新消息，\\n //  对应的Watcher订阅者会收到通知，调用自身的回调函数，让编译器去更新视图。\\n    const obj = {\\n      name: '刘逍',\\n      age: 20\\n    }\\n    const p = {}\\n    for (let key in obj) {\\n      Object.defineProperty(p, key, {\\n        get() {\\n          console.log(`有人读取p里的${key}属性`);\\n          return obj[key]\\n        },\\n        set(val) {\\n          console.log(`有人修改了p里的${key}属性,值为${val},需要去更新视图`);\\n          obj[key] = val\\n        }\\n      })\\n    }\\n```\\n\\n## 23. Proxy数据劫持(简易版)\\n\\n```\\n // Vue3的数据劫持通过Proxy函数对代理对象的属性进行劫持，通过Reflect对象里的方法对代理对象的属性进行修改，\\n // Proxy代理对象不需要遍历，配置项里的回调函数可以通过参数拿到修改属性的键和值\\n // 这里用到了Reflect对象里的三个方法，get，set和deleteProperty，方法需要的参数与配置项中回调函数的参数相同。\\n // Reflect里的方法与Proxy里的方法是一一对应的，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。\\n   const obj = {\\n      name: '刘逍',\\n      age: 20\\n    }\\n   const p = new Proxy(obj, {\\n      // 读取属性的时候会调用getter\\n      get(target, propName) {  //第一个参数为代理的源对象,等同于上面的Obj参数。第二个参数为读取的那个属性值\\n        console.log(`有人读取p对象里的${propName}属性`);\\n        return Reflect.get(target, propName)\\n      },\\n      // 添加和修改属性的时候会调用setter\\n      set(target, propName, value) { //参数等同于get，第三个参数为修改后的属性值\\n        console.log(`有人修改了p对象里的${propName}属性,值为${value},需要去修改视图`);\\n        Reflect.set(target, propName, value)\\n      },\\n      // 删除属性时，调用deleteProperty\\n      deleteProperty(target, propName) { // 参数等同于get\\n        console.log(`有人删除了p对象里的${propName}属性，需要去修改视图`);\\n        return Reflect.deleteProperty(target, propName)\\n      }\\n    })\\n```\\n\\n## 24. 实现路由(简易版)\\n\\n```\\n// hash路由\\nclass Route{\\n  constructor(){\\n    // 路由存储对象\\n    this.routes = {}\\n    // 当前hash\\n    this.currentHash = ''\\n    // 绑定this，避免监听时this指向改变\\n    this.freshRoute = this.freshRoute.bind(this)\\n    // 监听\\n    window.addEventListener('load', this.freshRoute, false)\\n    window.addEventListener('hashchange', this.freshRoute, false)\\n  }\\n  // 存储\\n  storeRoute (path, cb) {\\n    this.routes[path] = cb || function () {}\\n  }\\n  // 更新\\n  freshRoute () {\\n    this.currentHash = location.hash.slice(1) || '/'\\n    this.routes[this.currentHash]()\\n  }\\n}\\n```\\n\\n## 25. 使用 setTimeout 实现 setInterval\\n\\n实现思路是使用递归函数，不断地去执行 setTimeout 从而达到 setInterval 的效果\\n\\n```\\nfunction mySetInterval(fn, timeout) {\\n  // 控制器，控制定时器是否继续执行\\n  var timer = {\\n    flag: true\\n  };\\n  // 设置递归函数，模拟定时器执行。\\n  function interval() {\\n    if (timer.flag) {\\n      fn();\\n      setTimeout(interval, timeout);\\n    }\\n  }\\n  // 启动定时器\\n  setTimeout(interval, timeout);\\n  // 返回控制器\\n  return timer;\\n}\\n```\\n\\n## 26. 使用setInterval实现setTimeout\\n\\n```\\n    function mySetInterval(fn, t) {\\n      const timer = setInterval(() => {\\n        clearInterval(timer)\\n        fn()\\n      }, t)\\n    }\\n \\n    mySetInterval(() => {\\n      console.log('hoho');\\n    }, 1000)\\n```\\n\\n## 27. 实现 jsonp\\n\\n```\\n// 动态的加载js文件\\nfunction addScript(src) {\\n  const script = document.createElement('script');\\n  script.src = src;\\n  script.type = \\\"text/javascript\\\";\\n  document.body.appendChild(script);\\n}\\naddScript(\\\"http://xxx.xxx.com/xxx.js?callback=handleRes\\\");\\n// 设置一个全局的callback函数来接收回调结果\\nfunction handleRes(res) {\\n  console.log(res);\\n}\\n// 接口返回的数据格式\\nhandleRes({a: 1, b: 2});\\n```\\n\\n## 28. 提取出url 里的参数并转成对象\\n\\n```\\nfunction getUrlParams(url){\\n  let reg = /([^?&=]+)=([^?&=]+)/g\\n  let obj = { }\\n  url.replace(reg, function(){\\n      obj[arguments[1]] = arguments[2]\\n  })\\n  // 或者\\n  const search = window.location.search\\n  search.replace(/([^&=?]+)=([^&]+)/g, (m, $1, $2)=>{obj[$1] = decodeURIComponent($2)})\\n  \\n  return obj\\n}\\nlet url = 'https://www.junjin.cn?a=1&b=2'\\nconsole.log(getUrlParams(url)) // { a: 1, b: 2 }\\n```\\n\\n## 29. 请写至少三种数组去重的方法？（原生js）\\n\\n```\\n//利用filter\\nfunction unique(arr) {\\n  return arr.filter(function(item, index, arr) {\\n    //当前元素，在原始数组中的第一个索引==当前索引值，否则返回当前元素\\n    return arr.indexOf(item, 0) === index;\\n  });\\n}\\n    var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];\\n        console.log(unique(arr))\\n```\\n\\n```\\n//利用ES6 Set去重（ES6中最常用）\\nfunction unique (arr) {\\n  return Array.from(new Set(arr))\\n}\\nvar arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];\\nconsole.log(unique(arr))\\n //[1, \\\"true\\\", true, 15, false, undefined, null, NaN, \\\"NaN\\\", 0, \\\"a\\\", {}, {}]\\n```\\n\\n```\\n//利用for嵌套for，然后splice去重（ES5中最常用）\\nfunction unique (arr) {\\n        for(var i=0; i<arr.length; i++){\\n            for(var j=i+1; j<arr.length; j++){\\n                if(arr[i]==arr[j]){         //第一个等同于第二个，splice方法删除第二个\\n                    arr.splice(j,1);\\n                    j--;\\n                }\\n            }\\n        }\\nreturn arr;\\n}\\nvar arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];\\n    console.log(unique(arr))\\n    //[1, \\\"true\\\", 15, false, undefined, NaN, NaN, \\\"NaN\\\", \\\"a\\\", {…}, {…}]     \\n    //NaN和{}没有去重，两个null直接消失了\\n```\\n\\n# 二、算法基础\\n## 1. 时间&空间复杂度\\n\\n-   复杂度是数量级（方便记忆、推广），不是具体数字。\\n-   常见复杂度大小比较：O(n^2) > O(nlogn) > O(n) > O(logn) > O(1)\\n\\n### 1.1 时间复杂度\\n\\n常见时间复杂度对应关系：\\n\\n-   O(n^2)：2层循环（嵌套循环）\\n-   O(nlogn)：快速排序（循环 + 二分）\\n-   O(n)：1层循环\\n-   O(logn)：二分\\n\\n### 1.2 空间复杂度\\n\\n常见空间复杂度对应关系：\\n\\n-   O(n)：传入一个数组，处理过程生成一个新的数组大小与传入数组一致\\n\\n## 2. 八大数据结构\\n\\n### 1. 栈\\n\\n`栈`是一个`后进先出`的数据结构。`JavaScript`中没有`栈`，但是可以用`Array`实现`栈`的所有功能。\\n\\n```\\n// 数组实现栈数据结构\\nconst stack = []\\n​\\n// 入栈\\nstack.push(0)\\nstack.push(1)\\nstack.push(2)\\n​\\n// 出栈\\nconst popVal = stack.pop() // popVal 为 2\\n```\\n\\n**使用场景**\\n\\n-   场景一：十进制转二进制\\n-   场景二：有效括号\\n-   场景三：函数调用堆栈\\n\\n### 2. 队列\\n\\n`队列`是一个`先进先出`的数据结构。`JavaScript`中没有`队列`，但是可以用`Array`实现`队列`的所有功能。\\n\\n```\\n// 数组实现队列数据结构\\nconst queue = []\\n​\\n// 入队\\nstack.push(0)\\nstack.push(1)\\nstack.push(2)\\n​\\n// 出队\\nconst shiftVal = stack.shift() // shiftVal 为 0\\n\\n```\\n\\n**使用场景**\\n\\n-   场景一：日常测核酸排队\\n-   场景二：JS异步中的任务队列\\n-   场景三：计算最近请求次数\\n\\n### 3. 链表\\n\\n`链表`是多个元素组成的列表，元素存储不连续，用`next`指针连在一起。`JavaScript`中没有`链表`，但是可以用`Object`模拟`链表`。\\n\\n**使用场景**\\n\\n-   场景一：JS中的原型链\\n-   场景二：使用链表指针获取 JSON 的节点值\\n\\n### 4. 集合\\n\\n`集合`是一个`无序且唯一`的数据结构。`ES6`中有集合：`Set`，集合常用操作：去重、判断某元素是否在集合中、求交集。\\n\\n```\\n// 去重\\nconst arr = [1, 1, 2, 2]\\nconst arr2 = [...new Set(arr)]\\n​\\n// 判断元素是否在集合中\\nconst set = new Set(arr)\\nconst has = set.has(3) // false\\n​\\n// 求交集\\nconst set2 = new Set([2, 3])\\nconst set3 = new Set([...set].filter(item => set2.has(item)))\\n```\\n\\n**使用场景**\\n\\n-   场景一：求交集、差集\\n\\n### 5. 字典(哈希)\\n\\n`字典`也是一种存储`唯一值`的数据结构，但它以`键值对`的形式存储。`ES6`中的字典名为`Map`，\\n\\n```\\n// 字典\\nconst map = new Map()\\n​\\n// 增\\nmap.set('key1', 'value1')\\nmap.set('key2', 'value2')\\nmap.set('key3', 'value3')\\n​\\n// 删\\nmap.delete('key3')\\n// map.clear()\\n​\\n// 改\\nmap.set('key2', 'value222')\\n​\\n// 查\\nmap.get('key2')\\n\\n```\\n\\n**使用场景**\\n\\n-   场景：leetcode刷题\\n\\n### 6. 树\\n\\n`树`是一种`分层`的数据模型。前端常见的树包括：DOM、树、级联选择、树形控件……。`JavaScript`中没有`树`，但是可以通过`Object`和`Array`构建`树`。树的常用操作：深度/广度优先遍历、先中后序遍历。\\n\\n**使用场景**\\n\\n-   场景一：DOM树\\n-   场景二：级联选择器\\n\\n### 7. 图\\n\\n`图`是网络结构的抽象模型，是一组由边连接的节点。图可以表示任何二元关系，比如道路、航班。JS中没有图，但是可以用`Object`和`Array`构建`图`。图的表示法：邻接矩阵、邻接表、关联矩阵。\\n\\n**使用场景**\\n\\n-   场景一：道路\\n-   场景二：航班\\n\\n### 8. 堆\\n\\n`堆`是一种特殊的完全二叉树。所有的节点都大于等于（最大堆）或小于等于（最小堆）它的子节点。由于`堆`的特殊结构，我们可以用`数组`表示`堆`。\\n\\n**使用场景**\\n\\n-   场景：leetcode刷题\\n\\n## 3. 排序方法\\n\\n### 3.1 冒泡排序\\n\\n比较两个记录键值的大小，如果这两个记录键值的大小出现逆序，则交换这两个记录\\n\\n**每遍历一个元素，都会把之前的所有相邻的元素都两两比较一遍，即便是已经排序好的元素**\\n\\n```\\n//[1,3,4,2]->[1,3,2,4]->[1,2,3,4]->[1,2,3,4]\\n\\nlet n = 0\\nfunction bubbleSort(arr){\\n    for(let i = 1;i < arr.length;i++){\\n        for(let j = i;j > 0;j--){\\n            n++ // 1+2+3+...+arr.length-1\\n            if(arr[j] < arr[j-1]){\\n                [arr[j],arr[j-1]] = [arr[j-1],arr[j]];\\n            }\\n        }\\n    }\\n    return arr;\\n}\\n​\\n```\\n\\n### 3.2 插入排序\\n\\n第i（i大于等于1）个记录进行插入操作时，R1、 R2，...，是排好序的有序数列，取出第i个元素，在序列中找到一个合适的位置并将她插入到该位置上即可。\\n\\n**相当于把当前遍历的元素取出，在序列中找到一个合适的位置将它插入。它的第二层循环不必遍历当前元素之前的所有元素，因为当前元素之前的序列是排序好的，碰到第一个小于当前元素的值，就可以停止继续向前查找了，然后把当前元素插入当前位置即可**\\n\\n```\\n\\nfunction insertSort(arr){\\n    for(let i = 1;i < arr.length;i++){\\n        let j = i-1;\\n        if(arr[i]<arr[j]){\\n            let temp = arr[i];\\n            while(j >= 0 && temp < arr[j]){\\n                arr[j+1] = arr[j];\\n                j--;\\n            }\\n            arr[j+1] = temp;\\n        }\\n    }\\n    return arr;\\n}\\n​\\n//[1,3,4,2] ->[1,3,4,4]->[1,3,3,4]->[1,2,3,4]\\n//i=3 temp=2 j=2 arr[j]=4 arr[3]=4 [1,3,4,4]； j=1 arr[2]=3 [1,3,3,4]； j=0  [1,2,3,4]\\n```\\n\\n### 3.3 希尔排序\\n\\n算法先将要排序的一组数按某个增量d（n/2,n为要排序数的个数）分成若干组，每组中记录的下标相差d.对每组中全部元素进行直接插入排序，然后再用一个较小的增量（d/2）对它进行分组，在每组中再进行直接插入排序。当增量减到1时，进行直接插入排序后，排序完成。\\n\\n```\\n\\nfunction hillSort(arr){\\n    let len = arr.length;\\n    for(let gap = parseInt(len / 2);gap >= 1;gap = parseInt(gap / 2)){\\n        for(let i = gap;i < len;i++){\\n            if(arr[i] < arr[i-gap]){\\n                let temp = arr[i];\\n                let j = i - gap;\\n                while(j >= 0 && arr[j] > temp){\\n                    arr[j+gap] = arr[j];\\n                    j -= gap;\\n                }\\n                arr[j+gap] = temp;\\n            }\\n        }\\n    }\\n    return arr;\\n}\\n​\\n```\\n\\n\\n\\n![微信截图_20221006102742.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1612c370bd704e48aa83741d72119e63~tplv-k3u1fbpfcp-watermark.image?)\\n\\n### 3.4 选择排序\\n\\n在第i次选择操作中，通过n-i次键值间比较，从n-i+1个记录中选出键值最小的记录，并和第i（1小于等于1小于等于n-1）个记录交换\\n\\n**每一次遍历，都把当前元素与剩下元素里的最小值交换位置**\\n\\n```\\n//[4,1,3,2]->[1,4,3,2]->[1,2,4,3]->[1,2,3,4]\\n\\nfunction selectSort(arr){\\n    for(let i = 0;i < arr.length;i++){\\n        let min = Math.min(...arr.slice(i));\\n        let index\\n        for (let j = i; j < arr.length; j++) {\\n          if (arr[j] === min) {\\n            index = j\\n            break\\n          }\\n        }\\n        [arr[i],arr[index]] = [arr[index],arr[i]];\\n    }\\n    return arr;\\n}\\n​\\n```\\n\\n### 3.5 快排\\n\\n在n个记录中取某一个记录的键值为标准，通常取第一个记录键值为基准，通过一趟排序将待排的记录分为小于或等于这个键值的两个独立的部分，这是一部分的记录键值均比另一部分记录的键值小，然后，对这两部分记录继续分别进行快速排序，以达到整个序列有序\\n\\n**取当前排序数组的第一个值作为基准值keys，通过一次遍历把数组分为right大于基准值和left小于等于基准值的两部分，然后对两个部分重复以上步骤排序，最后return的时候按照[left,keys,right]的顺序返回**\\n\\n```\\n\\nfunction quickSort(arr){\\n    if(arr.length <= 1) return arr;\\n    let right = [],left = [],keys = arr.shift();\\n    for(let value of arr){\\n        if(value > keys){\\n            right.push(value)\\n        }else{\\n            left.push(value);\\n        }\\n    }\\n    return quickSort(left).concat(keys,quickSort(right));\\n}\\n\\n//[4,1,3,2]-->quickSort([1,3,2]).concat(4,quickSort([]))\\n//         -->quickSort([]).concant(1,quickSort([3,2])).concat(4,quickSort([]))\\n//         -->quickSort([]).concant(1,quickSort([2]).concant(3)).concat(4,quickSort([]))\\n//         -->[1,2,3,4]\\n//keys=4 R[] L[1,3,2]  \\n-------quickSort(left)\\n//keys=1 R[3,2] L[]\\n//keys=3 R[] L[2]\\n//quickSort(left)=[1,2,3]\\n​\\n```\\n\\n### **3.6各排序算法的稳定性，时间复杂度，空间复杂度**\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2eb6796900134ba7b4c4420f5dce5fd2~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n每个语言的排序内部实现都是不同的。\\n\\n对于 JS 来说，数组长度大于 10 会采用快排，否则使用插入排序。选择插入排序是因为虽然时间复杂度很差，但是在数据 量很小的情况下和 O(N * logN) 相差无几，然而插入排序需要的常数时间很小，所以相对别的排序来说更快。\\n\\n## 4. JS尾递归优化斐波拉契数列\\n\\n正常的斐波拉契数列js实现方式\\n\\n```\\nconst Fibonacci = (n) => {\\n    if (n <= 1) return 1;\\n    return  Fibonacci(n - 1) + Fibonacci(n - 2);\\n}\\nFibonacci(10) // 89\\nFibonacci(40) // 165580141 计算缓慢有延迟了\\nFibonacci(100) // 栈溢出，无法得到结果复制代码\\n```\\n\\n使用尾递归优化该方法\\n\\n```\\nconst Fibonacci = (n, sum1 = 1, sum2 = 1) => {\\n     if (n <= 1) return sum2;\\n     return Fibonacci(n - 1, sum2, sum1 + sum2)\\n}\\nFibonacci(10) // 89\\nFibonacci(100) // 573147844013817200000 速度依旧很快\\nFibonacci(1000) // 7.0330367711422765e+208 还是没有压力复制代码\\n```\\n\\n尾递归优化可以在数量较大的计算中，可以起到很好的作用\\n"
    },
    {
        "article_id": "7188878848228851769",
        "cover_image": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0b988e1db044409b5051f9d345b9bf7~tplv-k3u1fbpfcp-watermark.image?",
        "title": "Mybatis返回集合类型到底是空集合还是null？源码解读",
        "brief": "本文针对笔者日常开发中对 Mybatis 返回类型的是否需要判断为 null 结合源码，思考总结而来 Mybatis 版本 3.5.11 Spring boot 版本 3.0.1 github地址：h",
        "user_name": "wayn",
        "view_count": 2680,
        "collect_count": 18,
        "comment_count": 6,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/532a7f62611cb7c6e4f1feee180e6939~300x300.image",
        "category": "后端",
        "content": "> Mybatis 作为国内开发中常用到的半自动 orm 框架，相信大家都很熟悉，它提供了简单灵活的xml映射配置，方便开发人员编写简单、复杂SQL，在国内互联网公司使用众多。\\n\\n本文针对笔者日常开发中对 `Mybatis` 返回集合类型是否需要判断为 `null` 结合源码，思考总结而来\\n- `Mybatis` 版本 3.5.11\\n- `Spring boot` 版本 3.0.1\\n- github地址：https://github.com/wayn111， 欢迎大家关注，点个star\\n\\n# 一. 流程图分析\\n直接给出博主梳理的调用流程图，从用户dao方法执行开始，经过 `MapperProxy` 动态代理，对返回结果进行处理再到结束\\n![未命名文件 (2).jpg](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4435458802fb43dc9d6e365f792b821f~tplv-k3u1fbpfcp-watermark.image?)\\n其中有几个比较重要的类，我说明一下\\n- `MapperMethod` 对SQL执行类型进行判断，判断是insert、update、delete还是select类型，每个类型的处理流程都不一样\\n- `PrepareStatementHandler` 对完成参数替换后的SQL语句执行数据库查询，返回ResultSet\\n- `DefaultResultHandler` 对执行结果进行处理转换\\n\\n# 二. DefaultResultSetHandler对返回结果进行处理\\n在 `Mybatis` 中 `ResultSetHandler` 接口用于在 `StatementHandler` 对象执行完查询操作或存储过程后，对结果集或存储过程的执行结果进行处理。同理，当返回集合类型时，`Mybatis` 最后也会交给 `ResultSetHandler` 的实现类 `DefaultResultSetHandler` 来处理，最终在 `handleResultSet()` 方法中完成对返回集合类型的处理，如下图\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db0b5726087d4d28bc5613b0d8e02a95~tplv-k3u1fbpfcp-watermark.image?)\\n\\n可以看出 `Mybatis` 先创建 `DefaultResultHandler` 对象，接着放入 `handleRowValues()` 方法中，该方法会把数据库查询返回的多条记录转换为 `resultMap` 对应的对象放入 `defaultResultHandler`，最后调用 `defaultResultHandler.getResultList()` 方法将结果放到最终返回需要的 `multipleResults` 中。`multipleResults` 对象中就包含了我们最终返回的集合对象，`Mybatis` 会从 `multipleResults` 中获取第一个元素作为 `MapperProxy` 的返回结果\\n\\n# 三. DefaultResultHandler一个包含实际要返回集合对象的处理类\\n在上面代码中有一个非常重要的类，那就是 `DefaultResultHandler` 类，实际上我们返回的集合对象就是 `DefaultResultHandler` 内部的成员属性 `list` ，查看源码\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8371962699e473986a4d15e302eb91b~tplv-k3u1fbpfcp-watermark.image?)\\n\\n- 里面有一个 `list` 成员属性，该属性在构造器中由`objectFactory`对象调用 `create(List.class)` 方法创建，进入其中\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98a513d4cb784418b49645d87d900ab8~tplv-k3u1fbpfcp-watermark.image?)\\n在 `resolveInterface(type)` 方法中，对传入的类对象做具体转换\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/620ddd8dcd594914bb8ef3bdc1ce8de9~tplv-k3u1fbpfcp-watermark.image?)\\n\\n可以看到 `List.class` 被转换为 `ArrayList.class`，接着调用 `instantiateClass()` 方法，完成空集合的创建，**（划重点）由此可见，`Mybatis` 返回集合类型默认是空集合**\\n- `handlerResult(ResultContext<?> context)` 方法，该方法会往 `list` 中添加元素\\n\\n- `getResultList()` 方法，直接返回list成员属性\\n\\n结合上面提到的最后调用 `defaultResultHandler.getResultList()` 方法将结果放到最终返回需要的 `multipleResults` 中，我们很容易就能知道，我们返回的集合对象实际上就是 `DefaultResultHandler` 类中的 `list` 属性，然后我们重新梳理下上文中第二部分：\\n\\n**DefaultResultSetHandler对返回结果进行处理**\\n1. 先创建  `DefaultResultHandler` 对象，**初始化 `list` 成员属性为空集合**\\n2. 在 `handleRowValues()` 方法中，处理返回记录，转换为 `resultMap` 对应的对象类型，这个过程中，如果数据库返回不为空，就会**调用 `DefaultResultHandler` 类中的 `handlerResult(ResultContext<?> context)` 方法，将返回对象放入成员属性 `list` 集合中**\\n3. **调用 `defaultResultHandler.getResultList()` 方法，将成员属性 `list` 集合放入`multipleResults` 中**，这也就对应了上文提到的 `multipleResults` 对象中就包含了我们最终返回的集合对象\\n\\n# 四. 总结\\n由上经过源码分析，我们知道 `Mybatis` 返回集合类型默认是空集合，我们在日常开发中，对于 `Mybatis` 返回集合类型不需要判断是否为 `null`，直接调用 `list.size() > 0` 或者其他第三方工具包提供的集合判空方法即可"
    },
    {
        "article_id": "7181078511401041980",
        "cover_image": "https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35f7225aee2d401c86de1e7ed9ecdb77~tplv-k3u1fbpfcp-watermark.image?",
        "title": "JS Promise 101：Promise基础",
        "brief": "面试官：你知道Promise的错误为啥不能通过try/catch捕获嘛？ 我：嗯？为什么要try/catch？",
        "user_name": "我不是小超人啊",
        "view_count": 34263,
        "collect_count": 344,
        "comment_count": 73,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/2648f775e98d0bdd45c93b6c279bf28d~300x300.image",
        "category": "前端",
        "content": "---\\nhighlight: arduino-light\\n---\\n# 前言\\n之前我写过一篇文章，讨论了为什么`async await`中的错误可以被`try catch`，而`setTimeout`等api不能，有小伙伴提出之前面试被面试官问过为什么`Promise`的错误不能`try catch`，为什么要这么设计。好吧，虽然`Promise`这个话题大家都聊烂了，今天我们再来展开聊聊🤭。\\n\\n# 什么是Promise\\n`Promise`是一个用来代表异步操作结果的对象，我们可以通过观察者模式观察异步操作的结果。在其它语言里面，我们多多少少接触过`future`，`deferred`这些概念,`Promise`其实就是`Javascript`的类似实现。\\n根据[MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)定义：\\n\\nA `Promise` is in one of these states:\\n\\n*   _pending_: initial state, neither fulfilled nor rejected.\\n*   _fulfilled_: meaning that the operation was completed successfully.\\n*   _rejected_: meaning that the operation failed.\\n\\n一个`fulfilled Promise`有一个`fulfillment`值，而`rejected Promise`则有一个`rejection reason`。\\n\\n# 为什么要引入Promise？\\n\\n异步处理在我们日常开发中是很常见的场景，在`Promise`出现之前，我们都是通过回调来处理异步代码的结果，但是出现了一些问题：\\n\\n* `回调地狱`，在有多个异步逻辑存在依赖关系时，我们只能在回调里嵌套，这些深度嵌套的代码让代码难以阅读和维护，业界称之为回调地狱\\n* 回调也没用标准的方式来处理错误，大家都凭自己的喜好来处理错误，可能我们使用的库跟api都定义了一套处理错误的方式，那我们把多个库一起搭配使用时，就需要花额外的精力去把他们处理皮实\\n* 有时候我们需要对一个已经完成的逻辑注册回调。这也没有统一的标准，对于大部分代码，我们根本就不能对这些已经执行完的代码注册回调，有些会同步执行回调，有些会异步执行回调，我们根本不可能记住所有api的机制，要么每次使用时我们都要研究这个api的实现机制，要么我们可能就在写bug\\n* 而且，如果我们想对一个异步逻辑注册多个回调，这也要看api提供方支不支持\\n* 最重要的，如果有统一的方式来处理错误跟正确结果的话，我们就有可能实现一套通用的逻辑来简化代码复杂度,这种自己发挥的情况就很难\\n\\n是的，`Promise`的出现就是为了解决这所有的问题。\\n\\n# 怎么创建Promise\\n## Promise构造函数\\n`Promise`有一个构造函数，接收一个函数作为参数，这个传入构造函数里的函数被称作`executor`。\\n`Promise`的构造函数会同步地调用`executor`，`executor`又接收`resolve`函数跟`reject`函数作为参数，然后我们就可以通过这两个函数俩决定当前`Promise`的状态（`resolve`进入`fulfilled`或者`reject`进入`rejected`）。\\n\\n我们在`resolve Promise`时，可以直接给它一个值，或者给它另外一个`Promise`，这样最终是`fulfilled`还是`rejected`将取决于我们给它的这个`Promise`最后的状态。\\n\\n假如我们现在有一个`promise a`：\\n\\n* 如果我们在`promise a`里面调用`resolve`，传入了另一个`promise b`，`promise a`的状态将取决于`promise b`的执行结果\\n* 如果我们直接传给`resolve`一个普通的值，则`promise a`带着这个值进入`fulfilled`状态\\n* 如果我们调用`reject`，则`promise a`带着我们传给`reject`的值进入`rejected`状态\\n\\n`Promise`在一开始都是`pending`状态，之后执行完逻辑之后变成`settled（fulfilled或者rejected）`，`settled`不能变成`pending`，`fulfilled`不能变成`rejected`，`rejected`也不能变成`fulfilled`。总之一旦变成`settled`状态，之后就不会再变了。\\n\\n我们也不能直接拿到`Promise`的状态，只能通过注册`handler`的方式，`Promise`会在恰当的时机调用这些`handler`，`JavaScript Promise`可以注册三种`handler`：\\n\\n* `then` 当`Promise`进入`fulfilled`状态时会调用此函数\\n* `catch` 当`Promise`进入`rejected`状态时会调用此函数\\n* `finally`当`Promnise`进入`settled`状态时会调用此函数（无论`fulfilled`还是`rejected`）\\n\\n这三个`handler`函数都会返回一个新的`Promise`，这个新的`Promise`跟前面的`Promise`关联在一起，他的状态取决于前面`Promise`状态以及当前`handler`的执行情况。\\n\\n我们先来看一段代码直观感受下：\\n```\\nfunction maybeNum() {\\n  // create a promise\\n  return new Promise((resolve, reject)=>{\\n    console.info('Promise Start')\\n    setTimeout(()=>{\\n      try{\\n        const num=Math.random();\\n        const isLessThanHalf=num<=0.5;\\n        if(isLessThanHalf){\\n          resolve(num)\\n        }else{\\n          throw new Error('num is grater than 0.5')\\n        }\\n      }catch (e) {\\n        reject(e)\\n      }\\n    },100)\\n    console.info('Promise End')\\n  })\\n}\\n\\nmaybeNum().then(value => {\\n  console.info('fulfilled',value)\\n}).catch(error=>{\\n  console.error('rejected',error)\\n}).finally(()=>{\\n  console.info('finally')\\n})\\nconsole.info('End')\\n```\\n\\n`maybeNum`函数返回了一个`Promise`，`Promise`里面我们调用了`setTimeout`做了一些异步操作，以及一些`console`打印。\\n\\n出现的结果类似这样：\\n```\\nPromise Start\\nPromise End\\nEnd\\nfulfilled 0.438256424793777\\nfinally\\n```\\n或者这样:\\n```\\nPromise Start\\nPromise End\\nEnd\\nrejected Error: num is grater than 0.5 ...\\nfinally\\n```\\n\\n我们可以发现，除了`setTimeout`里的部分，其它都是同步按顺序执行的，所以`Promise`本身并没有做什么骚操作，它只是提供了一种观察异步逻辑的途径，而不是让我们的逻辑变成异步，比如在这里我们自己实现异步逻辑时还是要通过调用`setTimeout`。\\n\\n此外，我们还可以通过`Promise.resolve`跟`Promise.reject`来创建`Promise`。\\n## Promise.resolve\\n`Promise.resolve(x)`等价于\\n```\\nx instanceof Promise?x:new Promise(resolve=>resolve(x))\\n```\\n如果我们传给它的参数是一个`Promise`，（而不是`thenable`，关于什么是`thenable`我们稍后会讲）它会立即返回这个`Promise`，否则它会创建一个新的`Promise`，`resolve`的结果为我们传给它的参数，如果参数是一个`thenable`，那会视这个`thenable`的情况而定，否则直接带着这个值进入`fulfilled`状态。\\n\\n这样我们就可以很轻松地把一个`thenable`转换为一个原生的`Promise`，而且更加方便的是如果有时候我们不确定我们接收到的对象是不是Promise，用它包裹一下就好了，这样我们拿到的肯定是一个`Promise`。\\n## Promise.reject\\n`Promise.reject`等价于\\n```\\nnew Promise((resolve,reject)=>reject(x))\\n```\\n也就是说，不管我们给它什么，它直接用它`reject`，哪怕我们给的是一个`Promise`。\\n\\n# Thenable\\n\\n`JavaScript Promise`的标准来自`Promise/A+`，，所以`JavaScript`的`Promise`符合`Promise/A+`标准，但是也增加了一些自己的特性，比如`catch`跟`finally`。（`Promise/A+`只定义了`then`）\\n\\n在`Promise/A+`里面有个`thenable`的概念，跟`Promise`有一丢丢区别：\\n\\n-   A “promise” is an object or function with a `then` method whose behavior conforms to [the Promises/A+ specification].\\n-   A “thenable” is an object or function that defines a `then` method.\\n\\n所以`Promise`是`thenable`，但是`thenable`不一定是`Promise`。之所以提到这个，是因为互操作性。`Promise/A+`是标准，有不少实现，我们刚刚说过，我们在`resolve`一个`Promise`时，有两种可能性，`Promise`实现需要知道我们给它的值是一个可以直接用的值还是`thenable`。如果是一个带有`thenable`方法的对象，就会调用它的`thenable`方法来`resolve`给当前`Promise`。这听起来很挫，万一我们恰好有个对象，它就带`thenable`方法，但是又跟`Promise`没啥关系呢？\\n这已经是目前最好的方案了，在`Promise`被添加进`JavaScript`之前，就已经存在很多`Promise`实现了，通过这种方式可以让多个`Promise`实现互相兼容，否则的话，所有的`Promise`实现都需要搞个`flag`来表示它的`Promise`是`Promise`。\\n\\n# 再具体谈谈使用Promise\\n\\n刚刚的例子里，我们已经粗略了解了一下`Promise`的创建使用，我们通过`then``catch``finally`来“hook”进`Promise`的`fulfillment`，`rejection`，`completion`阶段。大部分情况下，我们还是使用其它api返回的`Promise`，比如`fetch`的返回结果，只有我们自己提供api时或者封装一些老的api时（比如包装`xhr`），我们才会自己创建一个`Promise`。所以我们现在来进一步了解一下`Promise`的使用。\\n\\n## then\\n`then`的使用很简单，\\n```\\nconst p2=p1.then(result=>doSomethingWith(result))\\n```\\n我们注册了一个`fulfillment handler`，并且返回了一个新的`Promise（p2)`。`p2`是`fulfilled`还是`rejected`将取决于`p1`的状态以及`doSomethingWith`的执行结果。如果`p1`变成了`rejected`，我们注册的`handler`不会被调用，`p2`直接变成`rejected`，`rejection reason`就是`p1`的`rejection reason`。如果`p1`是`fulfilled`，那我们注册的`handler`就会被调用了。根据`handler`的执行情况，有这几种可能：\\n\\n* `doSomethingWith`返回一个`thenable`，`p2`将会被`resolve`到这个`thenable`（取决于这个`thenable`的执行情况，决定`p2`是`fulfilled`还是`rejected`）\\n* 如果返回了其它值，`p2`直接带着那个值进入`fulfilled`状态\\n* 如果`doSomethingWith`中途出现`throw`，`p2`进入`rejected`状态\\n\\n这词儿怎么看着这么眼熟？没错我们刚刚介绍`resolve`跟`reject`时就是这么说的，这些是一样的行为，在我们的`handler`里`throw`跟调用`reject`一个效果，`return`跟`resolve`一个效果。\\n\\n而且我们知道了我们可以在`then/catch/finally`里面返回`Promise`来`resolve`它们创建的`Promise`，那我们就可以串联一些依赖其它异步操作结果且返回`Promise`的api了。像这样：\\n```\\np1.then(result=>secondOperation(result))\\n  .then(result=>thirdOperation(result))\\n  .then(result=>fourthOperation(result))\\n  .then(result=>fifthOperation(result))\\n  .catch(error=>console.error(error))\\n```\\n其中任何一步出了差错都会调用`catch`。\\n\\n如果这些代码都改成回调的方式，就会形成`回调地狱`，每一步都要判断错误，一层一层嵌套，大大增加了代码的复杂度，而`Promise`的机制能够让代码扁平化，相比之下更容易理解。\\n\\n## catch\\n`catch`的作用我们刚刚也讨论过了，它会注册一个函数在`Promise`进入`rejected`状态时调用，除了这个，其他行为可以说跟then一模一样。\\n```\\nconst p2=p1.catch(error=>doSomethingWith(error))\\n```\\n这里我们在`p1`上注册了一个`rejection handler`，并返回了一个新的`Promise p2`，`p2`的状态将取决于`p1`跟我们在这个`catch`里面做的操作。如果`p1`是`fulfilled`，这边的`handler`不会被调用，`p2`就直接带着`p1`的`fulfillment value`进入`fulfilled`状态，如果`p1`进入`rejected`状态了，这个`handler`就会被调用。取决于我们的`handler`做了什么：\\n\\n* `doSomethingWith`返回一个`thenable`，`p2`将会被`resolve`到这个`thenable`\\n* 如果返回了其它值，`p2`直接带着那个值进入`fulfilled`状态\\n* 如果`doSomethingWith`中途出现`throw`，`p2`进入`rejected`状态\\n\\n没错，这个行为跟我们之前讲的`then`的行为一模一样，有了这种一致性的保障，我们就不需要针对不同的机制记不同的规则了。\\n\\n这边尤其需要注意的是，如果我们从`catch handler`里面返回了一个`non-thenable`，这个`Promise`就会带着这个值进入`fulfilled`状态。这将`p1`的`rejection`转换成了`p2`的`fulfillment`，这有点类似于`try/catch`机制里的`catch`，可以阻止错误继续向外传播。\\n\\n这是有一个小问题的，如果我们把`catch handler`放在错误的地方：\\n\\n```\\nsomeOperation()\\n    .catch(error => {\\n        reportError(error);\\n    })\\n    .then(result => {\\n        console.log(result.someProperty);\\n    });\\n```\\n这种情况如果`someOperation`失败了，`reportError`会报告错误，但是`catch handler`里什么都没返回，默认就返回了`undefined`，这会导致后面的`then`里面因为返回了`undefined`的`someProperty`而报错。\\n```\\nUncaught (in promise) TypeError: Cannot read property 'someProperty' of undefined\\n```\\n由于这时候的错误没有`catch`来处理，`JavaScript`引擎会报一个`Unhandled rejection`。\\n所以如果我们确实需要在链式调用的中间插入`catch handler`的话，我们一定要确保整个链路都有恰当的处理。\\n\\n## finally\\n我们已经知道，`finally`方法有点像`try/catch/finally`里面的`finally`块，`finally handler`到最后一定会被调用，不管当前`Promise`是`fulfilled`还是`rejected`。它也会返回一个新的`Promise`，然后它的状态也是根据之前的`Promise`以及`handler`的执行结果决定的。不过`finally handler`能做的事相比而言更有限。\\n```\\nfunction doStuff() {\\n    loading.show();\\n    return getSomething()\\n        .then(result => render(result.stuff))\\n        .finally(() => loading.hide());\\n}\\n```\\n我们可以在做某件耗时操作时展示一个加载中的组件，然后在最后结束时把它隐藏。我在这里没有去处理`finally handler`可能出现的错误，这样我代码的调用方既可以处理结果也可以处理错误，而我可以保证我打开的一些副作用被正确销毁（比如这里的隐藏loading）。\\n\\n\\n细心的同学可以发现，`Promise`的三种`handler`有点类似于传统的`try/catch/finally`:\\n```\\ntry{\\n  // xxx\\n}catch (e) {\\n  // xxx\\n}finally {\\n  \\n}\\n```\\n\\n正常情况下，`finally handler`不会影响它之前的`Promise`传过来的结果，就像`try/catch/finally`里面的`finally`一样。除了返回的`rejected`的`thenable`，其他的值都会被忽略。也就是说，如果`finally`里面产生了异常，或者返回的`thenable`进入`rejected`状态了，它会改变返回的`Promise`的结果。所以它即使返回了一个新的值，最后调用方拿到的也是它之前的`Promise`返回的值，但是它可以把`fulfillment`变成`rejection`，也可以延迟`fulfillment`（毕竟返回一个`thenable`的话，要等它执行完才行）。\\n\\n简单来说就是，它就像`finally`块一样，不能包含`return`，它可以抛出异常，但是不能返回新的值。\\n\\n```\\nfunction returnWithDelay(value, delay = 10) {\\n    return new Promise(resolve => setTimeout(resolve, delay, value));\\n}\\n \\n// The function doing the work\\nfunction work() {\\n    return returnWithDelay(\\\"original value\\\")\\n        .finally(() => {\\n            return \\\"value from finally\\\";\\n        });\\n}\\n \\nwork()\\n    .then(value => {\\n        console.log(\\\"value = \\\" + value); // \\\"value = original value\\\"\\n    });\\n```\\n这边我们可以看到最后返回的值并不是`finally`里面返回的值，主要有两方面：\\n* `finally`主要用来做一些清理操作，如果需要返回值应该使用`then`\\n* 没有`return`的函数、只有`return`的函数、以及`return undefined`的函数，从语法上来说都是返回`undefined`的函数，`Promise`机制无法区分这个`undefined`要不要替换最终返回的值\\n\\n## then其实有两个参数\\n我们目前为止看到的`then`都是接受一个`handler`，其实它可以接收两个参数，一个用于`fulfillment`，一个用于`rejection`。而且`Promise.catch`等价于`Promise.then(undefined,rejectionHadler)`。\\n\\n```\\np1.then(result=>{\\n  \\n},error=>{\\n  \\n})\\n```\\n\\n这个跟\\n\\n```\\np1.then(result=>{\\n\\n}).catch(error=>{\\n\\n})\\n```\\n\\n可不等价，前者两个`handler`都注册在同一个`Promise`上，而后者`catch`注册在`then`返回的`Promnise`上，这意味着如果前者里只有`p1`出错了才会被处理，而后者`p1`出错，以及`then`返回的`Promise`出错都能被处理。\\n\\n# 解答开头的问题\\n现在我们知道要提供`Promise`给外部使用，`Promise`设计成在外面是没有办法获取`resolve`函数的，也就改变不了一个已有`Promise`的状态，我们只能基于已有`Promise`去生成新的`Promise`。如果允许异常向外抛出，那我们该怎么恢复后续`Promise`的执行？比如`Promise a`出现异常了，异常向外抛出，外面是没办法改变`Promise a`的数据的。设计成在`Promise`里面发生任何错误时，都让当前`Promise`进入`rejected`状态，然后调用之后的`catch handler`，`catch handler`有能力返回新的`Promise`，提供`fallback`方案，可以大大简化这其中的复杂度。\\n\\n# 工具方法\\n`Promise`还提供了一些工具方法，我们可以使用它们来同时处理多个`Promise`，例如`Promise.all`，`Promise.race`，`Promise.allsettled`，`Promise.any`，今天我就不一一介绍了，大家感兴趣的可以自行了解一下。\\n\\n# 写在结尾\\n`Promise`的出现，让我们：\\n1. `Promise`提供了标准的方式来处理结果\\n2. `Promise`的`then`返回新的`Promise`，可以多个串联，达到注册多个回调的效果\\n3. 对于已经完成的异步操作，我们后来注册的`then`也能被调用\\n4. 我们只能通过`executor`函数提供的两个函数来改变`Promise`的状态，没有其他办法可以`resolve`或者`reject` `Promise`，而且这两个方法也不存在于`Promise`本身，所以我们可以把我们的`Promise`对象给其他人去使用，比如我们提供给外部一个api，以`Promise`返回，可以放心地让外部通过`Promise`来观察最终的结果，他们也没办法来改变`Promise`的状态。\\n5. 可以实现统一的同时处理多个`Promise`的逻辑\\n\\n而且，我在本文开头提到过，回调地狱有两个问题是：\\n* 向已经完成的操作添加回调并没有统一的标准\\n* 很难向某个操作添加多个回调\\n\\n这些都被`Promise`的标准解决了，标准确保了两件事：\\n* `handler`一定会被调用\\n* 调用是异步的\\n\\n也就是说，如果我们获取到了其它api提供的`Promise`，有了类似如下的代码：\\n```\\nconsole.log('before')\\np1.then(()=>{\\n  console.log('in')\\n})\\nconsole.log('after')\\n```\\n标准确保了，执行结果是`before`，然后是`after`，最后是（在`p1`变成`fulfilled`状态或者已经变成`fulfilled`状态时）`in`。如果`Promise`在经过一段时间之后才变成`fulfilled`，这个`handler`也会被往后调度。如果`Promise`已经变成`fulfilled`了，那`fulfillment handler`会被立即调度（不是立即执行），调度指的是被加入微任务队列，确保这些`handler`被异步调用大概是`Promise`唯一让同步代码被异步调用的情形了。\\n\\n`Promise`推出也好多年了，我们日常开发中已经离不开它了，即使是`async` `await`背地里还是在跟它打交道，希望本文带给大家对`Promise`更全面的认识，当然了，关于`Promise`还有一些最佳实践跟反模式，由于篇幅的原因下次再见啦，Happy coding~\\n\\n\\n"
    },
    {
        "article_id": "7189919112615690297",
        "cover_image": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d5a5581cf58744c3b82d6139147d18f9~tplv-k3u1fbpfcp-watermark.image?",
        "title": "简单聊聊因果推断",
        "brief": "简单聊聊因果推断这个事。 Thoughtworks 曾与一家国际知名药企合作，解决患者用药依从性低(从药物治疗的角度，药物依从性是指患 者对药物治疗方案的执行程度)的问题。 如果仅着眼于患者本身，其不",
        "user_name": "Andy_Qin",
        "view_count": 692,
        "collect_count": 4,
        "comment_count": 0,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/f1aadcdcacb4b247878a2058bb02f37a~300x300.image",
        "category": "人工智能",
        "content": "简单聊聊因果推断这个事。\\n\\nThoughtworks 曾与一家国际知名药企合作，解决患者用药依从性低(从药物治疗的角度，药物依从性是指患 者对药物治疗方案的执行程度)的问题。\\n\\n如果仅着眼于患者本身，其不持续用药，也许是忘了，或者动力不足，看似可以简单归因并立刻着手解决。但 当我们打开这个问题，置身于整个系统，会发现影响患者持续用药的因素涉及方方面面。\\n\\n除患者个人层面，涉及到的利益相关方包含患者、医院、医生、制药机构、医药代理、甚至政府机构。其中影 响因素可能有医生对患者的影响、医疗保险的报销规定、社区医疗资源分布、甚至家人的陪伴等等。多层因素 之间亦互相牵连，相互影响。\\n\\n最终发现，从患者主观能动性出发所能提升的用药依从性大概只占小部分。而医生对患者的支持，以及医保的 报销比例，或许更大程度决定了患者是否持续用药。\\n\\n一个原本以为从患者角度的动机或者习惯问题，在深入研讨后会发现它是一个更大的系统问题，而非个人动机的问题。\\n\\n这正是我们今天的现状，我们所面临的大部分问题是一团缠绕的纱线。因此，为了避免想当然从某个点随意牵 扯一条线而造成“死结”，我们需要花更多的时间与精力，来解开这团纱线。\\n\\nD o n e l l a M e a d o w s 在 《 系 统 之 美 》中提到：“**厘清影响问题的各个元素并理解其间的关系 ， 我们才能更好找出所谓问题的杠杆解。**” 。我们在解决问题时需要关注问题所处的上下文、系统关系，以及各个元素之间的内部因果与联系。复杂问题之间互为因果、环环嵌套，因而有时难以分析和筛选、聚焦于某个单一问题而创造的方案，往往只是局部优化。为此我们需要分析每个问题的产生原因和影响结果，找到某个问题所关联的上下游问题。\\n\\n贝叶斯提出的逆概率定理，认为概率现象也是主观信念程度的变化和更新，让概率也失去了客观性；统计学创始人高尔顿和学生皮尔逊用相关关系取代了因果关系。至此，基于统计的科学研究壮大发展，因果效应基于统计计量的研究开启。\\n\\n计量经济学家格兰杰基于概率形式给出因果检测公式，论证事件发生是否存在先后的显著性。但是**只能判断发生事件在时间上的先后是否有统计显著性**，并不能判断因果。\\n\\n但相关性并不能准确的说明因果关系。相关性并不能取代因果性，无法处理具有共同混杂因子的变量关系，统计数据常因果颠倒（无方向性）、造就伪相关、对数据要求也很高(iid)、泛化性、鲁棒性都很差。\\n\\n那么如何分析因果关系以及将其用在实践中就需要借助一些更高效的工具和手段。\\n\\n我们首先来定义下什么是因果，休谟在《人类理解研究》中提到：“**我们可以给一个因下定义说，它是先行于、接近于另一个对象的一个对象，而且在这里，凡与前一个对象类似的一切对象都和与后的一个对象累死的那些对象处在累死的先行关系或者接近关系中。或者，换言之，假如没有前一个对象，那么后一个对象就不可能存在。**”（最后那句话也是反事实的定义。）\\n\\n在图灵奖得主朱迪尔·珀尔（Pearl）在 2000 年的论文《 Causality: Models, Reasoning, and inference》中提出了**因果阶梯论（**Pearl Causal Hierarchy**）：**\\n\\n他认为，因果推断有三个层级，\\n\\n![](https://www.qin.news/content/images/2023/01/image-5.png)\\n\\n最低的第一层级是**相关（association）**，涉及的是预测，而不涉及因果关系，只讨论变量之间的关联，比如公鸡打鸣与日出之间的相关关系。\\n\\n第二层级是**干预（intervention）**，涉及因果性，比如吸烟与患肺癌之间的因果关系。\\n\\n第三层级是**反事实（Counterfactuals）**，涉及的是回答诸如“如果情况不是现在这样，可能会发生什么”的问题。\\n\\n在论文中也提到了我们常遇到的五个问题：\\n\\n*   给定的疗法在治疗某种疾病上的有效性？\\n*   是新的税收优惠导致了销量上升吗？\\n*   每年的医疗费用上升是由于肥胖症人数的增多吗？\\n*   招聘记录可以证明雇主的性别歧视罪吗？\\n*   我应该放弃我的工作吗？\\n\\n我们常说**相关性不等于因果性**，但这些问题的一般特征是它们关心的都是什么东西带来的效果，但我们并没有很好的办法和科学的办法能够表达这样的问题，以及确保我们的结论不出问题。现实世界中绝大多数东西我们都很难找到准确因和果，往往都是复杂的、环环相扣的、互相影响的。\\n\\n耶日• 内曼在 1923 年发表了《_On the Applications of the Theory of Probability to Agricultural Experiments_》他提出了用于因果推断的“潜在结果”（potential outcomes）的数学模型，并将它和统计推断结合起来。\\n\\n**一个或多个处理作用在个体上产生的预期效果我们称之为潜在结果 (Potential outcome)。**之所以称为潜在结果是因为在一个个体上最终只有一个结果会出现并被观察到，也就是和个体所接受的处理相对应的那个结果。另外的潜在结果是观察不到的，因为它们所对应的处理并没有实际作用在该个体上。**因果效果的定义依赖于潜在结果，但是它并不依赖于哪一个潜在结果实际发生。**\\n\\nRubin（1974）重新独立地提出了潜在结果的概念，提出了鲁宾因果模型，将潜在结果框架扩展为在观察性和实验性研究中思考因果关系的一般框架。\\n\\n![](https://www.qin.news/content/images/2023/01/image-6.png)\\n\\n鲁宾因果模型是基于潜在结果的想法。例如，如果一个人上过大学，他在 40 岁时会有特定的收入，而如果他没有上过大学，他在 40 岁时会有不同的收入。为了衡量这个人上大学的因果效应，我们需要比较同一个人在两种不同的未来中的结果。由于不可能同时看到两种潜在结果，因此总是缺少其中一种潜在结果。这种困境就是“因果推理的基本问题”。\\n\\n由于因果推理的根本问题，无法直接观察到单元级别的因果效应。然而，随机实验允许估计人口水平的因果效应。随机实验将人们随机分配到对照组：大学或非大学。由于这种随机分配，各组（平均）相等，40 岁时的收入差异可归因于大学分配，因为这是各组之间的唯一差异。然后可以通过计算处理（上大学）和对照（非上大学）样本之间的平均值差异来获得平均因果效应（也称为平均处理效应）的估计值。\\n\\n然而，在许多情况下，由于伦理或实际问题，随机实验是不可能的。在这种情况下，存在非随机分配机制。上大学的例子就是这种情况：人们不是随机分配上大学的。相反，人们可能会根据他们的经济状况、父母的教育等来选择上大学。已经开发了许多用于因果推断的统计方法，例如倾向得分匹配。这些方法试图通过寻找类似于处理单元的控制单元来纠正分配机制。\\n\\nPearl 和 Mackenzie 在《The Causal Revolution》中提出了一种因果结构模型——SCM。SCM 由三部分构成：\\n\\n1.  图模型（Graphical models）\\n2.  结构化方程（Structural equations）\\n3.  反事实和介入式逻辑（Counterfactual and interventional logic）\\n\\n图模型最早是由 遗传学家 Sewell Wright 在 1918 年左右提出的，最初是为了推断决定豚鼠出生体重的因素的相对重要性。他利用这种结构发展了路径分析的方法，这种技术通常用于分层和复杂过程的因果推断任务，如表型遗传。\\n\\n他在 1921年的论文《Correlation and Causation》就有画因果图，描述各种遗传因素与豚鼠出生体重之间关系的结构性因果模型的代表。Wright的路径追踪规则定义了一套使用一组关联关系的规则，以生成一个因果图。因果图也可以被认为是结构因果模型的 DAG 表示方法。\\n\\n![](https://www.qin.news/content/images/2023/01/image-7.png)\\n\\n抽烟的人容易导致肺癌，抽烟的人也容易出现黄手指。因为抽烟这个“共因”，“黄手指”和“肺癌”产生了关联，我们不难发现，手指黄的人很多都容易患肺癌。但是我们不能说，黄手指会导致肺癌，它俩并没有因果关系。这个“共因”也被称之为“混杂因子”（confounder）。在这个例子中，“抽烟”就是“黄手指”和“肺癌”的混杂因子，它让“黄手指”和“肺癌”出现了一种“伪相关”，这种伪相关也被称为“偏倚”（bias）。，**因果推理的一大目标就是尽量消除混杂带来的偏倚（也就是那些非因果的关联关系），找出真正的因果关系。**\\n\\n在因果关联领域有一个著名的法则，被称为d-分离法则。d-分离的全称是有向分离（directional separation），是一种判断变量是否条件独立的方法。\\n\\n我们可以通过后门准则来消除混杂因子的影响。**如果我们有足够的数据能够将所有**A**和** Y **之间的后门路径全部阻断，那么我们就可以识别（identify）**A**和** Y **之间的因果关系。**\\n\\n简单来说，混杂（confounding）就是因果变量之间的共因。而混杂因子（confounder）就是能够阻断因果变量之间所有后门路径的变量（可能混杂因子不止一个）。这里要特别说明的是，**混杂因子的概念是建立在因果图结构之上的，必须要指定因果图的结构，混杂因子才有意义**。在一个复杂的因果图中，某个变量可能阻断了某两个变量之间的所有后门路径，因此它是某两个变量的混杂因子，但它对另一个路径来说可能并不是混杂因子。因此我们纠缠于谁是混杂因子没有实际意义，有意义的是，以哪个变量为条件可以消除这条路径上的混杂。\\n\\n让我们回到现实的场景中。\\n\\n传统的机器学习是预测工作，拟合用户的特征和目标 Y 值之间的关系，但无法建模实验前后对业务目标带来的收益。而因果推断可以拆分实验变量 T 和协变量 X（用户特征），来构建不同用户在不同实验下产生的不同行为的因果模型。\\n\\n我们可以通过公式看看。下面是一个经典的贝叶斯公式：\\n\\nP(Y∣X)\\\\=P(X)P(X,Y)​\\\\=P(X)P(X∣Y)P(Y)​P(Xk​∣Y\\\\=1)\\\\=P(Y\\\\=1)P(Xk​)P(Y\\\\=1∣Xk​)​\\n\\n当已知结果发生了（Y=1），相分析引起结果的原因 Xk​。通过贝叶斯公式发现  P(Xk​) 也就是 Xk​的概率越高，Y 的概率越高，但这个概率高低是非因果的。\\n\\n下面是 SCM 因果推断的公式：\\n\\nP(Y∣do(X))\\\\=u∑​P(Y∣X,u)P(u)\\n\\n我们可以发现在控制了 u 的情况下，切断了 u -> x 的后门路径，那就可以通过干预某些有意义的变量来评估因果效应。现实中常见的场景是在有某些约束的情况下，如何给目标客户分配合适的权益，从而达到业务目标最大化。\\n\\n我们可以假设我们是一个电商网站，我们需要通过优惠券刺激用户消费。那么在总成本不变下发什么样的折扣券给到什么样的用户效果最好呢？\\n\\n我们可以将不同的用户进行划分，然后对不同用户群体做 AB Test 发放不同的优惠券，从而来观测哪些用户群体的适合哪些优惠券，效果更加好。只预测收到优惠券后产生的借款。无法区别对活动更敏感人群和自然转化人群。但通过Uplift 的增量进行建模，即优惠券而产生的收益，就能够精准找到对活动更敏感人群。\\n\\nUplift models 用于预测一个 treatment 的增量反馈价值。举个例子来说，假如我们想知道对一个用户展现一个广告的价值，通常的模型只能告诉我们用户在展示广告后的购买意愿很强，但事实很有可能是他们在被展示广告之前就已经很想购买了。Uplift models 聚焦于用户被展示广告后购买意愿的增量。\\n\\n在一个理想的世界中我们能够将每一个个体根据类型划分，然后找到 “persuadables” 的那一波人，也就是投资汇报率最高的那一波人。对于 “sleeping dogs” 的那一波人肯定不是营销的目标人群。但是在现实生活中我们却没有办法准确的判断一个人是属于哪种类型，因为我们不可能对同一个用户 treated 或者 notreated。但是借助统计和机器学习的知识，我们就可以得到相似的用户大致会怎么反应。这就是 uplift 模型的核心，每一个用户会得到一个位于 -1 到 1 的 lift score，用于指导用户人群的选择。\\n\\n用 uplift 模型可以辅助你找到更合适的用户进行实验。而在推荐上的具体工作像是《Causal intervention for leveraging popularity bias in recommendation》这篇论文也详解得很好，里面详细分析了分析如何使用因果推断来消除流行度偏差。\\n\\n总结一下，因果推断非常适合解决某个场景下选择某一批用户用某个手段得到某个收益的互联网场景，但这个领域在 AI 和互联网具体场景下还是很原始，有待发展。还有像因果发现、因果强化学习、因果推断、与深度学习结合等等子方向还在蓬勃发展中。个人来说还是很相信因果推断会是个大势，可能将来会大量与机器学习、深度学习融合。在现实中干预一个目标的已知因子、混杂因子是非常非常多的，如何找到合适的因子也会成为一个大难题。"
    },
    {
        "article_id": "7189564391648395321",
        "cover_image": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8fbca1be2c5e4664808d99e38520d7c0~tplv-k3u1fbpfcp-watermark.image?",
        "title": "从0实现React18系列七-事件系统",
        "brief": "本系列是讲述从0开始实现一个react18的基本版本。由于React源码通过Mono-repo 管理仓库，我们也是用pnpm提供的workspaces来管理我们的代码仓库，打包我们使用rollup进行",
        "user_name": "sunnyhuang519626",
        "view_count": 442,
        "collect_count": 2,
        "comment_count": 0,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/da5ea93aeda6aeb9e50197a82535027c~300x300.image",
        "category": "前端",
        "content": "本系列是讲述从0开始实现一个react18的基本版本。由于`React`源码通过**Mono-repo** 管理仓库，我们也是用`pnpm`提供的`workspaces`来管理我们的代码仓库，打包我们使用`rollup`进行打包。\\n\\n[仓库地址](https://github.com/huangchucai/miniReact)\\n\\n[具体章节代码commit](https://github.com/huangchucai/miniReact/commit/eb57d976bd83b9965eb31ed1d6f1b40903ebdf99)\\n\\n在使用React的时候，我们都知道React实现了一套自己的事件系统，今天我们以`click`事件为例，讲解React事件系统的内部实践。\\n\\n思考一下如下代码，在React中, 当我们点击`p`标签的时候，是一个什么顺序输出。`div -> div -> p`分别绑定了`onClickCapture`和`onClick`的函数。\\n```javascript\\nexport default function App() {\\n  const [num, setNum] = useState(3);\\n  return (\\n      <div\\n          onClick={() => {\\n            console.log(\\\"container click\\\");\\n          }}\\n          onClickCapture={() => {\\n            console.log(\\\"container onClickCapture\\\");\\n          }}\\n      >\\n        <div\\n            onClick={() => {\\n              console.log(\\\"div click\\\");\\n            }}\\n            onClickCapture={() => {\\n              console.log(\\\"div onClickCapture\\\");\\n            }}\\n        >\\n          <p\\n              onClickCapture={() => {\\n                console.log(\\\"p onClickCapture\\\");\\n              }}\\n              onClick={() => {\\n                console.log(\\\"p click\\\");\\n                setNum(num + 1);\\n              }}\\n          >\\n            {num}\\n          </p>\\n        </div>\\n      </div>\\n  );\\n}\\n```\\n`container onClickCapture`  ->  `div onClickCapture`  -> `p onClickCapture`  ->  `p click`  -> `div click` -> `container click`。\\n\\n当我们使用`e.stopPropagation`在某一次点击的时候，又会发送什么呢？\\n\\n这篇文章就从事件本质去解释执行的流程。\\n\\n### 绑定事件参数-入口\\n我们知道在书写`jsx`的时候，事件绑定`onClick`会被`babel`转换到`ReactElement`的`props`上。事件系统又是和宿主环境相关，在浏览器中是使用`react-dom`的包进行处理。事件相关处理主要文件`SyntheticEvent.ts`。\\n\\n那如何将我们传递的事件参数`onClick、onClickCapture`等传递到`react-dom`中呢？\\n\\n分2步：\\n1. 初始化阶段 \\n2. 更新阶段\\n\\n#### 初始化阶段\\n从前面调和章节中，我们知道在初始化阶段，为了构建离屏`DOM`树，我们会在`completeWork`的时候去调用`react-dom`中`hostConfig`的`createInstance`的创建dom。\\n\\n在这里，我们就可以将`ReactElement props`传递给`react-dom`。 这样在`createInstance`的时候，我们就得到了`props`的数据了。\\n\\n```javascript\\n// react-reconciler - completeWork  1. 构建DOM\\nconst instance = createInstance(wip.type, newProps);\\n```\\n\\n```javascript\\n// react-dom - hostConfig 1. 创建DOM\\nexport const createInstance = (type: string, props: Props): Instance => {\\n  const element = document.createElement(type) as unknown;\\n  updateFiberProps(element as DOMElement, props);\\n  return element as DOMElement;\\n};\\n```\\n\\n之后`updateFiberProps`，我们就可以将`props`保存在新建的`dom`的某一个属性(`__props`)中。方便之后事件处理\\n```javascript\\n// react-dom - SyntheticEvent.ts\\nexport function updateFiberProps(node: DOMElement, props: Props) {\\n  // dom.__props = reactElement props\\n  node[elementPropsKey] = props;\\n}\\n```\\n\\n#### 更新阶段\\n正常在更新阶段，我们需要进行如下步骤\\n\\n1. `completeWork`的时候，对于`HostComponent`，对比前后`props`属性的变化。\\n2. 如果属性变动后，执行`markUpdate`标记更新\\n3. 然后在`commitMutationEffectsOnFibers`的时候，触发`commitUpdate`。\\n4. `commitUpdate`中针对`HostComponent`执行`updateFiberProps`操作。\\n\\n这样就可以得到了最新的属性，并赋值给对应的`dom`。\\n\\n### 注册事件\\n由于react兼容各个平台的事件机制，自己实现了一套事件系统，在React17之前，事件都是绑定在`document`上，React17后，事件被绑定到同一容器`container`统一管理。同时对于微前端项目，也可以隔离多个容器。\\n```javascript\\nlet container = document.getElementById(\\\"root\\\") // 这个就是绑定事件的contaienr\\nReactDOM.createRoot(container).render(<App />\\n```\\n\\n由于不是绑定在真实的Dom上，所以React模拟出了一套事件流： `事件捕获 -> 事件源 -> 事件冒泡`。也基于自身重写了事件源对象`event`。\\n\\n在初始化渲染的时候，我们就需要**注册事件**， 这里以`click`为例。\\n```javascript\\n// react-dom -> root.ts\\nexport function createRoot(container: Container) {\\n  const root = createContainer(container);\\n\\n  return {\\n    render(element: ReactElementType) {\\n      initEvent(container, \\\"click\\\"); \\n      return updateContainer(element, root);\\n    },\\n  };\\n}\\n```\\n调用`initEvent`,传递我们实际绑定的`DOM`节点。进行事件绑定。主要是通过`addEventListener`绑定事件。\\n```javascript\\n// react-dom SyntheticEvent.ts\\nexport function initEvent(container: Container, eventType: string) {\\n  container.addEventListener(eventType, (e: Event) => {\\n    dispatchEvent(container, eventType, e);\\n  });\\n}\\n```\\n所以我们平时的点击事件，实际监听触发的都在`container`上，并不是本身监听了事件。这样统一处理，也可以减少事件的监听。\\n\\n### 事件分发`dispatchEvent`\\n注册事件后，我们知道，当我们点击一个元素的时候，实际上触发的是`container`元素，那目标元素是如何执行绑定的`onClick`或者`onClickCapture`函数的呢？\\n\\n很容易想到的是，我们应该需要收集`container`到`目标元素`的沿途过程中的事件绑定，然后依次去触发它们。\\n\\n所以`dispatchEvent`的主要流程分为下面4步骤：\\n1. 收集沿途的绑定事件（`onClick`或者`onClickCapture`冒泡或捕获）\\n2. 基于原始事件参数`event`构造合成事件参数\\n3. 遍历捕获`capture`，依次执行\\n4. 遍历冒泡`bubble`，依次执行\\n\\n```javascript\\nfunction dispatchEvent(container: Container, eventType: string, e: Event) {\\n  const targetElement = e.target;\\n\\n  if (targetElement === null) {\\n    console.warn(\\\"事件不存在target\\\", e);\\n  }\\n  // 1. 收集沿途的事件\\n  const { bubble, capture } = collectPaths(\\n    targetElement as DOMElement,\\n    container,\\n    eventType\\n  );\\n  // 2. 构造合成事件\\n  const se = createSyntheticEvent(e);\\n  // 3. 遍历capture\\n  triggerEventFlow(capture, se);\\n  // 4. bubble\\n  if (!se.__stopPropagation) {\\n    triggerEventFlow(bubble, se);\\n  }\\n}\\n```\\n接下来我们依次分析：\\n\\n#### 1. 收集绑定事件`collectPaths`\\n`collectPaths`这个函数主要是收集从实际点击的`Dom元素`到`container`的绑定事件。接收三个函数\\n1. `targetElement`: 点击的目标元素`e.target`\\n2. `container`: 容器`Dom`元素\\n3. `eventType`: 事件类型，主要是用于映射，例如`click` 映射 `onClick`、`onClickCapture`\\n\\n从之前的绑定事件参数中我们得知，`ReactElemenet` 的参数绑定在对应的`Dom`元素的`__props`属性中。\\n\\n所以向上遍历的过程中，要获取`elementProps`, 然后根据是否存在事件绑定进行对应的逻辑。通过`collectPaths`后\\n我们得到一个`capture`和`bubble`的数组。\\n\\n```javascript\\nfunction collectPaths(\\n  targetElement: DOMElement,\\n  container: Container,\\n  eventType: string\\n) {\\n  const paths: Paths = {\\n    capture: [],\\n    bubble: [],\\n  };\\n  while (targetElement && targetElement !== container) {\\n    // 收集\\n    const elementProps = targetElement[elementPropsKey];\\n    if (elementProps) {\\n      const callbackNameList = getEventCallbackNameFromEventType(eventType);\\n      // callbackNameList = [\\\"onClickCapture\\\", \\\"onClick\\\"]\\n      if (callbackNameList) {\\n        callbackNameList.forEach((callbackName, i) => {\\n          const eventCallback = elementProps[callbackName];\\n          if (eventCallback) {\\n            if (i === 0) {\\n              //capture\\n              paths.capture.unshift(eventCallback);\\n            } else {\\n              paths.bubble.push(eventCallback);\\n            }\\n          }\\n        });\\n      }\\n    }\\n    targetElement = targetElement.parentNode as DOMElement;\\n  }\\n  return paths;\\n}\\n```\\n这里可能有一个疑惑点，就是为什么在`catpure`的时候我们要使用`unshift`，而在`bubble`中，我们使用`push`。\\n\\n捕获阶段是从上到下的，所以最上面的元素应该是最先执行的。使用`unShift`保证后遍历到的，先执行。\\n![事件收集流程图](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/49c94352a1374e6ab853b922a75af30b~tplv-k3u1fbpfcp-watermark.image?)\\n\\n#### 2. 构造合成事件参数`createSyntheticEvent`\\n由于react自己实现的事件系统，所以在处理事件冒泡和捕获的时候时候，需要自定义一些实现来模拟阻止冒泡。\\n例如`e.stopPropagation`，除了执行本身之外，还需要额外的逻辑。\\n\\n当用户调用`e.stopPropagation`的时候，我们将一个私有遍历`__stopPropagation`设置为`true`。在之后的遍历中使用。\\n\\n```javascript\\nfunction createSyntheticEvent(e: Event) {\\n  const syntheticEvent = e as SyntheticEvent;\\n  syntheticEvent.__stopPropagation = false;\\n  const originStopPropagation = e.stopPropagation;\\n\\n  syntheticEvent.stopPropagation = () => {\\n    syntheticEvent.__stopPropagation = true;\\n    if (originStopPropagation) {\\n      originStopPropagation();\\n    }\\n  };\\n  return syntheticEvent;\\n}\\n```\\n\\n#### 3. 遍历捕获事件`triggerEventFlow`\\n这个阶段主要是依次执行在第一步中收集的函数，执行的时候传入第二步构造的事件对象。\\n\\n当发现上层有调用`e.stopPropagation()`的时候，就停止循环。\\n```javaScript\\n// dispatchEvent 调用\\n// 3. capture\\ntriggerEventFlow(capture, se);\\n\\nfunction triggerEventFlow(paths: EventCallback[], se: SyntheticEvent) {\\n  for (let i = 0; i < paths.length; i++) {\\n    const callback = paths[i];\\n    callback.call(null, se);\\n\\n    if (se.__stopPropagation) {\\n      break;\\n    }\\n  }\\n}\\n```\\n\\n#### 4. 遍历冒泡事件`triggerEventFlow`\\n```javaScript\\n// dispatchEvent 调用\\n// 4. bubble\\nif (!se.__stopPropagation) {\\n  triggerEventFlow(bubble, se);\\n}\\n```\\n\\n### 总结\\n这样就实现了一个基于click的事件系统。\\n![整体流程.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d2aab42e4aca4f7db91ee607639d4ef8~tplv-k3u1fbpfcp-watermark.image?)\\n\\n思考如下例子，在react中的执行顺序是怎么样的呢？\\n\\n\\n```\\nfunction App() {\\n  const [num, setNum] = useState(3);\\n  return (\\n    <div\\n      onClick={() => {\\n        console.log(\\\"container click\\\");\\n      }}\\n      onClickCapture={() => {\\n          console.log(\\\"container onClickCapture\\\");\\n      }}\\n    >\\n      <div\\n        onClick={(e) => {\\n          e.stopPropagation()\\n          console.log(\\\"div click\\\");\\n        }}\\n        onClickCapture={() => {\\n          console.log(\\\"div onClickCapture\\\");\\n        }}\\n      >\\n        <p\\n          onClickCapture={() => {\\n            console.log(\\\"p onClickCapture\\\");\\n          }}\\n          onClick={() => {\\n            console.log(\\\"p-click\\\");\\n            setNum(num + 1);\\n          }}\\n        >\\n          {num}\\n        </p>\\n      </div>\\n    </div>\\n  );\\n}\\n```\\n\\n> `container onClickCapture`   ->  `div onClickCapture` -> `p onClickCapture`  -> `p-click` -> `div click`\\n\\n\\n如果改成div的 `onClickCapture`执行`e.stopPropagation()`呢？打断继续向下遍历的流程，并也不会执行冒泡操作了。所以输出如下：\\n\\n> `container onClickCapture`   ->  `div onClickCapture`\\n\\n\\n#### 下一节\\n下一节我们讲解多节点的`diff`的原理"
    },
    {
        "article_id": "7178783712363708475",
        "cover_image": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca9592779c094b37a94c67da6b1c6e55~tplv-k3u1fbpfcp-watermark.image?",
        "title": "一次令人窒息的百度面试",
        "brief": "最近接到了百度的面试，个人觉得基础知识准备的比较充分，就去网上找了一些百度的面经，冥冥之中我在众多的面试题中打开了下边两个面试题： 2021百度前端社招面经 百度前端面试题分享，带答案 看完之后我直呼",
        "user_name": "let_code",
        "view_count": 41602,
        "collect_count": 682,
        "comment_count": 83,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/228c6472b9739995b5726abe9047f3d0~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: fancy\\n---\\n\\n最近接到了百度的面试，个人觉得基础知识准备的比较充分，就去网上找了一些百度的面经，冥冥之中我在众多的面试题中打开了下边两个面试题：\\n\\n[2021百度前端社招面经](https://juejin.cn/post/7002233276861513758)\\n\\n[百度前端面试题分享，带答案](https://juejin.cn/post/6970867290480853006)\\n\\n看完之后我直呼“哇哦~”，全部在我的射程范围之内。我该不会如此幸运到问的全会吧。\\n\\n是的，答案就是不会，我就是没有幸运到问的全会。\\n\\n话不多说，接下来就回顾下面试的问题。\\n\\n# 看简历\\n\\n上来首先是万年不变的自我介绍，介绍完之后面试官就开始逐行看我的简历，并针对简历上的项目经历进行询问。询问的十分详细。\\n\\n# 如何实现新手指引\\n\\n问这个问题的原因是我简历上写到了使用driver.js库实现了新手指引。\\n\\n使用js实现如下：\\n\\n```html\\n<!DOCTYPE html>\\n<html lang=\\\"en\\\">\\n\\n<head>\\n    <meta charset=\\\"UTF-8\\\">\\n    <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\">\\n    <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\">\\n    <title>新手指引功能</title>\\n    <style>\\n        * {\\n            margin: 0;\\n            padding: 0;\\n        }\\n\\n        body {\\n            box-sizing: border-box;\\n        }\\n\\n        .stepBlock {\\n            background-color: burlywood;\\n            margin-right: 20px;\\n        }\\n\\n        .positionStyle{\\n            position: absolute;\\n            z-index: 200;\\n        }\\n\\n        /* 蒙层样式 */\\n        .overlay {\\n            position: fixed;\\n            top: 0;\\n            left: 0;\\n            right: 0;\\n            bottom: 0;\\n            background-color: rgba(0, 0, 0, .5);\\n            z-index: 100;\\n        }\\n    </style>\\n</head>\\n\\n<body>\\n    <section id=\\\"mask\\\">\\n        <section class=\\\"positionStyle\\\" id=\\\"tip\\\"></section>\\n        <section class=\\\"positionStyle\\\" id=\\\"curStepMask\\\"></section>\\n    </section>\\n\\n    <section style=\\\"margin:200px;\\\">\\n        <span id=\\\"first\\\" class=\\\"stepBlock\\\">\\n            第一步\\n        </span>\\n        <span id=\\\"second\\\" class=\\\"stepBlock\\\">\\n            第二步\\n        </span>\\n        <span id=\\\"third\\\" class=\\\"stepBlock\\\">\\n            第三步\\n        </span>\\n    </section>\\n\\n    <section style=\\\"margin-top:30px\\\">\\n        <button onclick=\\\"setMask()\\\">开始指引</button>\\n    </section>\\n\\n    <script>\\n        const tipDict = [\\n            { id: 'first', content: '这里是第1步哦' },\\n            { id: 'second', content: '这里是第2步哦' },\\n            { id: 'third', content: '这里是最后一步哦，点击完成按钮结束新手指引' },\\n        ]\\n        let flag = 0;\\n\\n        function setMask() {\\n            // 添加蒙层\\n            let mask = document.getElementById('mask')\\n            mask.setAttribute('class', 'overlay')\\n            setTip()\\n        }\\n\\n        function removeMask() {\\n            // 移除蒙层\\n            let mask = document.getElementById('mask')\\n            mask.setAttribute('class', '')\\n\\n            // 移除tip提示的子元素\\n            removeTip()\\n            removeStepMask()\\n        }\\n\\n        function setTip() {\\n            if (flag < tipDict.length) {\\n                // 获取当前步骤的元素，以及元素的位置信息，供后续定位提示信息和覆盖信息使用\\n                const curStepEle = document.getElementById(tipDict[flag].id)\\n                const bound = curStepEle.getBoundingClientRect()\\n\\n                // 找到id为tip的元素\\n                let ele = document.getElementById(\\\"tip\\\")\\n\\n                // 如果存在子元素，先移除\\n                removeTip()\\n                removeStepMask()\\n\\n                // 创建提示信息和下一步的统一父元素，方便后续移除元素\\n                let node = document.createElement('div')\\n                // 创建提示信息\\n                let tipText = document.createTextNode(tipDict[flag].content)\\n                // 将提示信息插入到父元素\\n                node.appendChild(tipText)\\n                // 创建“下一步”按钮\\n                let nextBtn = document.createElement('button')\\n                nextBtn.innerHTML = flag === tipDict.length - 1 ? '完成' : '下一步';\\n                nextBtn.onclick = setTip;\\n                // 将按钮插入到父元素\\n                node.appendChild(nextBtn)\\n                // 设置统一父元素的位置\\n\\n\\n                ele.style.left = bound.x + 'px'\\n                ele.style.top = bound.y + 20 + 'px'\\n                // 将统一的父元素插入到id为tip的元素\\n                ele.appendChild(node)\\n\\n                // 将当前步骤高亮显示\\n                let tag = flag - 1\\n                if (tag >= 0) {\\n                    document.getElementById(tipDict[tag].id).style = ''\\n                }\\n                // const curStepEle = document.getElementById(tipDict[flag].id)\\n                // const bound = curStepEle.getBoundingClientRect()\\n\\n                const curStepMask = document.getElementById('curStepMask')\\n                curStepMask.style.left = bound.x + 'px'\\n                curStepMask.style.top = bound.y + 'px'\\n\\n                const curStepEleClone = curStepEle.cloneNode(true)\\n                curStepMask.appendChild(curStepEleClone)\\n\\n                flag++\\n            } else {\\n                flag = 0;\\n                removeMask()\\n            }\\n        }\\n        function removeStepMask() {\\n            let ele = document.getElementById('curStepMask')\\n            let child = ele.lastElementChild\\n            if (child) {\\n                ele.removeChild(child)\\n            }\\n        }\\n        function removeTip() {\\n            let ele = document.getElementById(\\\"tip\\\")\\n            let child = ele.lastElementChild\\n            if (child) {\\n                ele.removeChild(child)\\n            }\\n        }\\n    </script>\\n</body>\\n\\n</html>\\n```\\n\\n注意元素中包含如下结构：\\n```html\\n<section id=\\\"mask\\\"> \\n    <section class=\\\"positionStyle\\\" id=\\\"tip\\\"></section> \\n    <section class=\\\"positionStyle\\\" id=\\\"curStepMask\\\"></section>\\n</section>\\n```\\n\\n实现思路是：\\n\\n- 点击“开始指引”：找到id为mask的元素，为该元素添加蒙层样式（setMask）\\n- 添加提示信息：找到id为tip的元素，将提示信息添加为该元素的子元素(setTip)\\n- 高亮当前步骤元素：找到当前目标元素，克隆目标元素，然后将克隆后的目标元素添加为curStepMask的子元素(setTip)\\n- 定位tip和curStepMask的元素：curStepMask元素在当前目标元素的正上方，tip元素根据情况而定\\n- 每次添加当前提示信息时要移除上一次添加的提示信息和覆盖元素（removeTip，removeStepMask）\\n\\n\\n**getBoundingClientRect**\\n\\n> 返回值是一个 [`DOMRect`](https://developer.mozilla.org/zh-CN/docs/Web/API/DOMRect) 对象，是包含整个元素的最小矩形（包括 `padding` 和 `border-width`）。该对象使用 `left`、`top`、`right`、`bottom`、`x`、`y`、`width` 和 `height` 这几个以像素为单位的只读属性描述整个矩形的位置和大小。除了 `width` 和 `height` 以外的属性是相对于视图窗口的左上角来计算的。 --MDN\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56f59a1c24384143ad805f6938d76a38~tplv-k3u1fbpfcp-watermark.image?)\\n\\n# 图片上有一个人脸，除了脸部以外加上蒙层\\n\\n方案一：\\n\\n添加遮罩层，在图片上方添加一张只有人脸的图片：\\n\\n```html\\n\\n<!DOCTYPE html>\\n<html lang=\\\"en\\\">\\n\\n<head>\\n    <meta charset=\\\"UTF-8\\\">\\n    <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\">\\n    <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\">\\n    <title>图片添加蒙层</title>\\n    <style type=\\\"text/css\\\">\\n        img {\\n            position: absolute;\\n            top: 50%;\\n            left: 50%;\\n            width: 300px;\\n        }\\n\\n        .overlay {\\n            position: fixed;\\n            top: 0;\\n            right: 0;\\n            bottom: 0;\\n            left: 0;\\n            background-color: rgba(0, 0, 0, .5);\\n            z-index: 100;\\n        }\\n    </style>\\n</head>\\n\\n<body>\\n    <div class=\\\"overlay\\\">\\n        <img src=\\\"../images/mask.png\\\" style=\\\"width:200px\\\" />\\n    </div>\\n    <img src=\\\"../images/cat.png\\\" />\\n</body>\\n\\n</html>\\n```\\n\\n最终实现效果：（没有用一模一样的图片，只是模拟了类似的效果）\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fd506f46c966467f9ca42e4a0fc4c6ee~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n上述是在整个页面添加蒙层，若想只在图片部分添加蒙层：\\n```html\\n<!DOCTYPE html>\\n<html lang=\\\"en\\\">\\n\\n<head>\\n    <meta charset=\\\"UTF-8\\\">\\n    <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\">\\n    <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\">\\n    <title>图片添加蒙层</title>\\n    <style type=\\\"text/css\\\">\\n        img {\\n            width: 300px;\\n        }\\n\\n        .overlay {\\n            position: absolute;\\n            top: 0;\\n            right: 0;\\n            bottom: 0;\\n            left: 0;\\n            background-color: rgba(0, 0, 0, .5);\\n            z-index: 100;\\n        }\\n    </style>\\n</head>\\n\\n<body>\\n    <div style=\\\"position: relative;width: 300px;\\\">\\n        <div class=\\\"overlay\\\">\\n            <img src=\\\"../images/kid.png\\\" style=\\\"width:200px\\\" />\\n        </div>\\n        <img src=\\\"../images/cat.png\\\" />\\n    </div>\\n</body>\\n\\n</html>\\n```\\n\\n效果：\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9998e021460d411e952d37589f9c6856~tplv-k3u1fbpfcp-watermark.image?)\\n\\n# echarts动画实现原理\\n\\n对Echarts目前处于使用的水平，原理后续学习的话再补上吧~~~\\n\\n# 了解canvas吗\\n\\nHTML5 `<canvas>` 元素用于图形的绘制，通过脚本 (通常是JavaScript)来完成。\\n\\n`<canvas>` 标签只是图形容器，必须使用脚本来绘制图形。\\n\\n可以通过多种方法使用 canvas 绘制路径,盒、圆、字符以及添加图像。\\n\\n[canvas教程传送门](https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial)\\n\\n# 如何实现组件滑动切换效果\\n\\n不使用react-transition-group\\n\\n# 对语义化的理解\\n\\n语义化就是正确的标签做正确的事。语义化的好处在于：\\n\\n- 对于开发团队而言，代码更加容易维护\\n- 在css没有加载出来的情况下也能很好的展示结构\\n- 有利于SEO优化\\n- 更好地支持各种终端，例如无障碍阅读和有声小说等\\n\\n# HTML5有哪些语义化标签\\n\\n常用的语义化标签有：\\n\\n- header：定义页眉信息\\n- nav：导航栏\\n- section：页面的组成部分\\n- footer：脚注信息\\n- aside：侧边栏信息，比如菜单或者广告等\\n\\n# less 多处用到px转换为vw 如何实现\\n\\nsass中可以定义函数，接收参数并且返回计算值：\\n```scss\\n/*比如：在父元素字体大小为 12px 的容器内绘制图形交互*/\\n@function pxToEm ($px) {\\n  @return ($px/12) + em;\\n}\\n\\n# Sass\\n.box {\\n    width: pxToEm(36);\\n}\\n\\n# CSS\\n.box {\\n    width: 3em;\\n}\\n```\\n\\nless中函数是内置的不能够自定义，所以可以使用混入：\\n\\n```less\\n/*\\n将宽度为 375px 的 UI 设计稿转换成使用单位 vw 来适配移动端的网页。\\n避免编译：~' 值 '\\n*/\\n\\n.pxToVW (@px, @attr: width) {\\n    @vw: (@px / 375) * 100;\\n    @{attr}: ~\\\"@{vw}vw\\\"; \\n}\\n\\n# Less\\n.box {\\n    .pxToVW(75);\\n    .pxToVW(150, height);\\n}\\n\\n# CSS\\n.box {\\n    width: 20vw;\\n    height: 40vw;\\n}\\n```\\n\\n[less传送门](https://juejin.cn/post/6844903520441729037)\\n\\n# vue-router中router和route的区别\\n\\nrouter是路由实例对象，包含一些路由跳转方法，比如push。\\n\\nroute是路由信息对象，包含和路由相关的一些信息，比如params,location等。\\n\\n# vue单页面应用无刷新更新组件怎么实现的\\n\\n我理解面试官询问的点在于vue-router两种模式下如何实现的url到组件的映射。\\n\\n## hash模式\\n\\nhash模式是vue-router的默认模式。hash指的是url描点，当描点发生变化的时候，浏览器只会修改访问历史记录，不会访问服务器重新获取页面。因此可以监听描点值的变化，根据描点值渲染指定dom。\\n\\n-   改变描点\\n\\n可以通过`location.hash = \\\"/hashpath\\\"`的方式修改浏览器的hash值。\\n\\n-   监听描点变化\\n\\n可以通过监听hashchange事件监听hash值的变化。\\n\\n```\\nwindow.addEventListener('hashchange', () => {\\n   const hash = window.location.hash.substr(1)\\n   // 根据hash值渲染不同的dom\\n})\\n```\\n\\n## history模式\\n\\n通过mode选项开启history模式，history 模式和 hash 模式的区别在于：\\n\\n1. history模式中不带有“#”，更加美观\\n2. history模式当用户刷新或直接输入地址时会向服务器发送一个请求，所以history模式需要服务端同学进行支持，将路由都重定向到根路由\\n\\n-   改变url\\n\\nH5的history对象提供了pushState和replaceState两个方法，当调用这两个方法的时候，url会发生变化，浏览器访问历史也会发生变化，但是浏览器不会向后台发送请求。\\n\\n```\\n// 第一个参数：data对象，在监听变化的事件中能够获取到\\n// 第二个参数：title标题\\n// 第三个参数：跳转地址\\nhistory.pushState({}, \\\"\\\", '/a')\\n```\\n\\n-   监听url变化\\n\\n可以通过监听popstate事件监听history变化，也就是点击浏览器的前进或者后退功能时触发。\\n\\n```\\nwindow.addEventListener(\\\"popstate\\\", () => {\\n    const path = window.location.pathname\\n    // 根据path不同可渲染不同的dom\\n})\\n```\\n\\n> 从某种程度来说，调用 `pushState()` 和 `window.location = \\\"#foo\\\"`基本上一样，他们都会在当前的 document 中创建和激活一个新的历史记录。但是 `pushState()` 有以下优势：\\n> -   新的 URL 可以是任何和当前 URL 同源的 URL。但是设置 [`window.location`](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/location) 只会在你只设置锚的时候才会使当前的 URL。\\n> -   非强制修改 URL。相反，设置 `window.location = \\\"#foo\\\";` 仅仅会在锚的值不是 #foo 情况下创建一条新的历史记录。\\n>-   可以在新的历史记录中关联任何数据。`window.location = \\\"#foo\\\"`形式的操作，你只可以将所需数据写入锚的字符串中。\\n>\\n>注意： `pushState()` 不会造成 [`hashchange`](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/hashchange_event) 事件调用，即使新的 URL 和之前的 URL 只是锚的数据不同。\\n> ----MDN\\n\\n# vue在页面中如何监听回到上一步的操作\\n\\n挂载完成后，判断浏览器是否支持popstate\\n\\n```js\\nmounted(){\\n  if (window.history && window.history.pushState) {\\n    history.pushState(null, null, document.URL);\\n    window.addEventListener('popstate', this.goBack, false);\\n  }\\n},\\n```\\n\\n页面销毁时，取消监听。否则其他vue路由页面也会被监听\\n```js\\ndestroyed(){\\n  window.removeEventListener('popstate', this.goBack, false);\\n},\\n```\\n\\n页面跳转函数\\n```js\\nmethods:{\\n  goBack(){\\n    this.$router.replace({path: '/'});\\n    //replace替换原路由，作用是避免回退死循环\\n  }\\n}\\n```\\n\\n# 代码题：回文字符串\\n```js\\nfunction checkStr(str) {\\n    return str === str.split('').reverse().join('')\\n}\\n```\\n\\n# 场景提：一个公告栏，每一天都可以展示，当用户点击关闭后今天不显示，明天（过了今天零点）还会显示\\n\\n我给出的方案就是在localStorage中存储用户关闭公告栏的时间戳，等再次进入页面的时候判断是不是存在localStorage：\\n- 若不存在则证明从来没有关闭过公告栏，那就显示；\\n- 若存在，就判断时间戳和当前时间是否是同一天，不是同一天就显示\\n\\n# 代码题：命名方式中划线改小驼峰\\n\\n方案一：\\n\\n```js\\nfunction transName(arr) {\\n    let res = arr.map(e => {\\n        let items = e.split('-').map((item, index) => {\\n            if (index) {\\n                let first = item.substring(0,1)\\n                let rest = item.substring(1)\\n                return first.toUpperCase()+rest\\n            }else{\\n                return item.toLowerCase()\\n            }\\n        })\\n        return items.join('')\\n    })\\n    return res\\n}\\nconsole.log(transName(['A-b-cee', 'ca-de-ea', 'e-fe-eaa','f-g','mn']))\\n\\n```\\n\\n方案二：\\n\\n```js\\nfunction turnName(str){\\n    return str.replace(/-[a-zA-Z]/g,match=>match.replace('-','').toUpperCase())\\n}\\n```\\n\\n# 代码题：命名方式小驼峰改中划线\\n\\n```js\\nlet s1 = 'aBBcdE';\\n\\nlet t = s1.replace( /[A-Z]/g, match=>'-'+match.toLowerCase());\\nconsole.log(t);\\n```\\n\\n# git commit之后修改上一次commit的信息\\n\\n> 刚commit还没有push\\n\\ngit commit --amend\\n\\n会进入vim编辑器，点击i，修改commit信息后，点击esc，输入ZZ退出。\\n\\ngit log 可以看见最近commit信息\\n\\n> 刚push，修改最近一次commit\\n\\ngit commit --amend\\n\\n会进入vim编辑器，点击i，修改commit信息后，点击esc，输入ZZ退出。\\n\\ngit log 可以看见最近commit信息，pull后再push到远程(但是每次pull后再push会导致覆盖原来的更改，后来直接强制推送成功了：git push origin HEAD:master --force)\\n\\n> 修改历史push的commit信息\\n\\ngit rebase -i HEAD~3\\n\\n表示要修改当前版本的倒数第三次状态.\\n\\n这个命令出来之后，会出来三行东东：\\n\\n```\\npick:*******\\n\\npick:*******\\n\\npick:*******\\n```\\n\\n如果你要修改哪个，就把那行的pick改成edit，然后保存退出(点击esc，输入ZZ退出)\\n\\n这时通过git log你可以发现，git的最后一次提交已经变成你选的那个了，这时再使用：\\n\\ngit commit --amend 来对commit进行修改。\\n\\n修改完成后使用git rebase --continue\\n\\n然后将变化push到远程：git push origin HEAD:master --force\\n\\n# webpack优化构建速度\\n\\n[直接参考这篇文章](https://juejin.cn/post/6844904071736852487)\\n\\n# 前端性能优化\\n\\n## 页面渲染优化\\n\\nWebkit 渲染引擎流程：\\n\\n-   处理 HTML 并构建 DOM 树\\n-   处理 CSS 构建 CSS 规则树(CSSOM)\\n-   DOM Tree 和 CSSOM Tree 合成一棵渲染树 Render Tree。\\n-   根据渲染树来布局，计算每个节点的位置\\n-   调用 GPU 绘制，合成图层，显示在屏幕上\\n\\n1. 避免css阻塞：css影响renderTree的构建，会阻塞页面的渲染，因此应该**尽早（将 CSS 放在 head 标签里）和尽快（启用 CDN 实现静态资源加载速度的优化)的**将css资源加载\\n2. 避免js阻塞：js可以修改CSSOM和DOM，因此js会阻塞页面的解析和渲染，并且会等待css资源的加载。也就是说js会抢走渲染引擎的控制权。所以我们需要给js资源添加defer或者async，延迟js脚本的执行。\\n3. 使用字体图标 iconfont 代替图片图标：\\n    - 图片会增加网络请求次数，从而拖慢页面加载时间\\n    - iconfont可以很好的缩放并且不会添加额外的请求\\n\\n4. 降低css选择器的复杂度：浏览器读取选择器，遵循的原则是从选择器的右边到左边读取。\\n    - 减少嵌套：最多不要超过三层，并且后代选择器的开销较高，慎重使用\\n    - 避免使用通配符，对用到的元素进行匹配即可\\n    - 利用继承，避免重复匹配和定义\\n    - 正确使用类选择器和id选择器\\n\\n5. 减少重绘和回流:\\n    \\n    **CSS**\\n\\n    -   避免使用table布局。\\n    -   尽可能在DOM树的最末端改变class。\\n    -   避免设置多层内联样式。\\n    -   将动画效果应用到position属性为absolute或fixed的元素上。\\n    -   避免使用CSS表达式（例如：calc()）。\\n\\n    **JavaScript**\\n\\n    -   避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。\\n    -   避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。\\n    -   为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。用一次回流替代多次回流\\n    -   避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。\\n    -   对具有复杂动画的元素生成一个新图层\\n\\n\\n## JS中的性能优化\\n\\n1. 使用事件委托\\n2. 防抖和节流\\n3. 尽量不要使用[JS动画](https://zh.javascript.info/js-animation)，[css3动画](https://www.runoob.com/css3/css3-animations.html)和[canvas动画](https://juejin.cn/post/7008811592733655077)都比JS动画性能好\\n\\n## 图片的优化\\n\\n1. 雪碧图：借助减少http请求次数来进行优化\\n2. 图片懒加载：在图片即将进入可视区域的时候进行加载（后边有判断即将进入可视区域的方法）\\n3. 使用CSS3代替图片：有很多图片使用 CSS 效果（渐变、阴影等）就能画出来，这种情况选择 CSS3 效果更好\\n\\n## webpack优化\\n\\n1. 代码压缩：html,css,js文件压缩\\n2. Tree shaking 去除死代码\\n3. `babel-plugin-transform-runtime`减少ES6转化ES5的冗余\\n4. 提升打包速度\\n\\n## vue\\n\\n1. 路由懒加载\\n2. 合理使用computed和watch\\n3. v-for添加key\\n4. v-for的同时避免使用v-if\\n5. destory时销毁事件：比如addEventListener添加的事件、setTimeout、setInterval、bus.$on绑定的监听事件等\\n6. 第三方插件按需引入\\n\\n## react\\n\\n1.  map循环展示添加key\\n2.  路由懒加载\\n3.  使用scu，memo或者pureComponent避免不必要的渲染\\n\\n\\n\\n\\n# 前端的缓存机制\\n\\n分为强缓存和协商缓存。\\n\\n强缓存不需要客户端向服务端发送请求，有两种响应头实现方案：\\n- Expires：值是一个绝时间，在这个时间前缓存有效，但是如果本地时间被修改，会导致缓存失效\\n- Cache-control：值是一个相对时间，单位为秒，资源在这个时间内有效\\n\\n强缓存过期之后会使用协商缓存，协商缓存需要客户端向服务端发送请求，资源未过期则服务端返回304否则返回新的资源。\\n协商缓存也有两种实现方案：\\n- Last-Modified 和 If-Modified-Since：`Last-Modified` 表示本地文件最后修改日期，`If-Modified-Since` 会将 `Last-Modified` 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来。但是如果本地文件被打开，会导致`Last-Modified` 被修改。\\n- ETag 和 If-None-Match：`ETag` 类似于文件指纹，`If-None-Match` 会将当前 `ETag` 发送给服务器，询问该资源 `ETag` 是否变动，有变动的话就将新的资源发送回来。并且 `ETag` 优先级比 `Last-Modified` 高。\\n\\n\\n# 如何判断图片即将进入可视区域\\n\\n方案1：clientHeight+scroolTop>offsetTop\\n\\n```html\\n<!DOCTYPE html>\\n<html lang=\\\"en\\\">\\n\\n<head>\\n    <meta charset=\\\"UTF-8\\\">\\n    <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\">\\n    <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\">\\n    <title>图片加载优化</title>\\n</head>\\n\\n<body>\\n    <div style=\\\"background-color: green;width:100vw;height:8000px\\\">\\n    </div>\\n    <div id=\\\"yellow\\\" style=\\\"background-color: yellow;width:100vw;height:800px\\\">\\n    </div>\\n\\n    <script>\\n        document.addEventListener('scroll', () => {\\n            const clientH = document.documentElement.clientHeight//获取屏幕可视区域的高度\\n            const scrollT = document.documentElement.scrollTop//获取浏览器窗口顶部与文档顶部之间的距离，也就是滚动条滚动的距离\\n            const offsetTop = document.getElementById('yellow').offsetTop//获取元素相对于文档顶部的高度\\n            if (clientH + scrollT > offsetTop) {\\n                console.log('进入可视区域啦！！')\\n            }\\n        })\\n    </script>\\n</body>\\n\\n</html>\\n```\\n\\n方案2：下滑过程中bound.top会越来越小\\n\\n```html\\n<!DOCTYPE html>\\n<html lang=\\\"en\\\">\\n\\n<head>\\n    <meta charset=\\\"UTF-8\\\">\\n    <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\">\\n    <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\">\\n    <title>图片加载优化</title>\\n</head>\\n\\n<body>\\n    <div style=\\\"background-color: green;width:100vw;height:8000px\\\">\\n    </div>\\n    <div id=\\\"yellow\\\" style=\\\"background-color: yellow;width:100vw;height:800px\\\">\\n    </div>\\n\\n    <script>\\n        document.addEventListener('scroll', () => {\\n            var bound = document.getElementById('yellow').getBoundingClientRect(); ////获取元素的大小及位置\\n            var clientHeight = window.innerHeight;\\n            if (bound.top <= clientHeight) {\\n                console.log('进入可视区域啦')\\n            }\\n        })\\n    </script>\\n</body>\\n\\n</html>\\n```\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n"
    },
    {
        "article_id": "7189104246728425531",
        "cover_image": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a6962e855004ece8a6ecbf0279122d4~tplv-k3u1fbpfcp-watermark.image?",
        "title": "刺激，线程池的一个BUG直接把CPU干到100%了。",
        "brief": "你好呀，我是歪歪。分享一个线程池的 BUG ，这个 BUG 能直接把 CPU 给飚到 100%，希望大家永远踩不到。 但是，u1s1，确实也很难踩到...",
        "user_name": "why技术",
        "view_count": 1717,
        "collect_count": 20,
        "comment_count": 2,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/8b472f29b528ad097a78d288ef895900~300x300.image",
        "category": "后端",
        "content": "你好呀，我是歪歪。\\n\\n给大家分享一个关于 ScheduledExecutorService 线程池的 BUG 啊，这个 BUG 能直接把 CPU 给飚到 100%，希望大家永远踩不到。\\n\\n但是，u1s1，一般来说也很难踩到。\\n\\n到底咋回事呢，让我给你细细嗦嗦。\\n\\n## Demo\\n\\n老规矩，按照惯例，先搞个 Demo 出来玩玩：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5655dc89ef3941abb917d9e1654da934~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n项目里面使用到了 ScheduledThreadPoolExecutor 线程池，该线程池对应的核心线程数放在配置文件里面，通过 @Value 注解来读取配置文件。\\n\\n然后通过接口触发这个线程池里面的任务。\\n\\n具体来说就是在上面的示例代码中，在调用 testScheduledPool 接口之后，程序会在 60 秒之后输出“执行业务逻辑”。\\n\\n这个代码的逻辑还是非常简单清晰的，但是上面的代码有一个问题，不知道你看出来没有？\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5fd9fe3bd8f4b27aa8ccc576db40210~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n没看出来也没关系，我这里都是鼓励式教学的，不打击同学的积极性。\\n\\n所以，别着急，我先给你跑起来，你瞅一眼立马就能看出问题是啥：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/49d3002b6ca44d928ac618fceb18c4e1~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n为什么 coreSize 是 0 呢，我们配置文件里面明明写的是 2 啊？\\n\\n因为 setCoreSize 方法是 static 的，导致 @Value 注解失效。\\n\\n如果去掉 static 那么就能正确读取到配置文件中的配置：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87b14a156fa8401c8f4d7ddda9aac927~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n虽然这里面也大有学问，但是这并不是本文的重点，这只是一个引子，\\n\\n为的是引出为什么会在项目里面出现下面这种 coreSize 等于 0 的奇怪的代码：\\n\\n> ScheduledExecutorService executor = Executors.newScheduledThreadPool(0);\\n\\n如果我直接给出上面的代码，一点有人说只有小（大）可（傻）爱（逼）才会这样写。\\n\\n但是铺垫一个背景之后，就容易接受的多了。\\n\\n你永远可以相信我的行文结构，老司开车稳得很，你放心。\\n\\n好，经过前面的铺垫，其实我们的 Demo 能直接简化到这个样子：\\n\\n```\\npublic static void main(String[] args){\\n    ScheduledExecutorService e = Executors.newScheduledThreadPool(0);\\n    e.schedule(() -> {\\n        System.out.println(\\\"业务逻辑\\\");\\n    }, 60, TimeUnit.SECONDS);\\n    e.shutdown();\\n}\\n```\\n\\n这个代码是可以正常运行的，你粘过去直接就能跑，60 秒后是会正常输出的。\\n\\n如果你觉得 60 秒太长了，那么你可以改成 3 秒运行一下，看看程序是不是正常运行并结束了。\\n\\n但是就这个看起来问题不大的代码，会导致 CPU 飚到 100% 去。\\n\\n真的，儿豁嘛。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b57899dd9e7844218600a0be8849ed41~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n## 咋回事呢\\n\\n到底咋回事呢？\\n\\n这个其实就是 JDK 的 BUG 导致的，我带你瞅瞅：\\n\\n> https://bugs.openjdk.org/browse/JDK-8065320\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7dcafb3fa3e047ee93d348e0813a27b8~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n首先，你看 Fix Version 那个地方是 9，也就是说明这个 BUG 是在 JDK 9 里面修复了。JDK 8 里面是可以复现的。\\n\\n其次，这个标题其实就包含了非常多的信息了，它说对于 ScheduledExecutorService 来说 getTask 方法里面存在频繁的循环。\\n\\n那么问题就来了：频繁的循环，比如 for(;;) ，while(true) 这样的代码，长时间从循环里面走不出来，会导致什么现象？\\n\\n那不就是导致 CPU 飙高吗。\\n\\n注意，这里我说的是“长时间从循环里面走不出来”，而不是死循环，这两者之间的差异还是很大的。\\n\\n我代码里面的示例就是使用的提出 BUG 的哥们给出的实例：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/21d4093c10854e0e8b46bcd6fd755fb9~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n他说，在这个示例下，如果你在一个只有单核的服务器上跑，然后使用 TOP 命令，会看到持续 60 秒的 CPU 使用率为 100%。\\n\\n为什么呢？\\n\\n答案就藏在前面提到的 getTask 方法中：\\n\\n> java.util.concurrent.ThreadPoolExecutor#getTask\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be267af79b0640aa8ef6813b33d8fecf~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n这个方法里面果然是有一个类似于无线循环的代码，但是它为什么不停的执行呢？\\n\\n现在赶紧想一想线程池的基本运行原理。当没有任务处理的时候，核心线程在干啥？\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ac8caec5b4d4a199b5549e7ebe28e4e~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n是不是就阻塞在这个地方，等着任务过来进行处理的，这个能理解吧：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cf538e4f4074599a5e64e39ff2d112f~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n那我再问你一个问题，这行代码的作用是干啥：\\n\\n> workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS)\\n\\n是不是在指定时间内如果没有从队列里面拉取到任务，则抛出 InterruptedException。\\n\\n那么它什么时候会被触发呢？\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e7f765bdbf64e79ae8ad3e809ea3521~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n在 timed 参数为 true 的时候。\\n\\ntimed 参数什么时候会为 true 呢？\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9db6c5b20c8345ecaf0e19789403154c~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n当 allowCoreThreadTimeOut 为 true 或者当前工作的线程大于核心线程数的时候。\\n\\n而 allowCoreThreadTimeOut 默认为 false：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b608b50058944f8ae4e68689392f20c~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n那么也就是在这个案例下满足了当前工作的线程大于核心线程数这个条件：\\n\\n> wc > corePoolSize\\n\\n通过 Debug 知道，wc 是 1，corePoolSize 为 0：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aef49e1282074d8e993c23e576ec54cb~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n所以 timed 变成了 true。\\n\\n好，这里要注意了，朋友。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb40e94c3aaf4475a9eed3201ce32328~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n经过前面的分析，我们已经知道了在当前的案例下，会触发 for(;;)这个逻辑：\\n\\n> workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS)\\n\\n那么这个 keepAliveTime 到底是多少呢？\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/157b2478ff504324ab8f22dc41f72837~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n来，大声的喊出这个数字：0，这是一个意想不到的、诡计多端的 0。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a3a894f4bb94749a41da69d9cc4130a~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n所以，这个地方中的 r 每次都会返回一个 null，然后再次开启循环。\\n\\n对于正常的线程池来说，触发了这个逻辑，代表没有任务要执行了，可以把对应线程进行回收了。\\n\\n回收，对应的就是这部分代码会返回一个 null：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d5bdce6a19544508b3eb683c0be9057b~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n然后在外面 runWorker 方法中的，由于 getTask 返回了 null，从而执行了 finally 代码里面的逻辑，也就是从当前线程池移除线程的逻辑：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/222d6c7a11d540f9a164ed73580725a8~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n但是，朋友，我要说但是了。\\n\\n在我们的案例下，你看 if 判断的条件：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/82fa1098506d4ca7af8db1af7b80778d~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n这里面的 wc > 1 || workQueue.isEmpty()) 是 false\\n\\n所以这个 if 条件不成立，那么它又走到了 poll 这里：\\n\\n> > workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS)\\n\\n由于这里的 keepAliveTime 是 0，所以马不停蹄的的开启下一轮循环。\\n\\n那么这个循环什么时候结束呢？\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/34bab61a0a4a4a03814b84705921fc2e~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n就是在从队列里面获取到任务的时候。\\n\\n那么队列里面什么时候才会有任务呢？\\n\\n在我们的案例里面，是 60 秒之后。\\n\\n所以，在这 60 秒内，这部分代码相当于是一个“死循环”，导致 CPU 持续飙高到 100%。\\n\\n这就是 BUG，这就是根本原因。\\n\\n但是看到这里是不是觉得还差点意思？\\n\\n我说 100% 就 100% 吗？\\n\\n得拿出石锤来才行啊。\\n\\n所以，为了拿出实锤，眼见为实，我把核心流程拿出来，然后稍微改动一点点代码：\\n\\n```\\npublic static void main(String[] args) {\\n    ArrayBlockingQueue<Runnable> workQueue =\\n            new ArrayBlockingQueue<>(100);\\n    //绑定到 5 号 CPU 上执行\\n    try (AffinityLock affinityLock = AffinityLock.acquireLock(5)) {\\n        for (; ; ) {\\n            try {\\n                Runnable r = workQueue.poll(0, TimeUnit.NANOSECONDS);\\n                if (r != null)\\n                    break;\\n            } catch (InterruptedException retry) {\\n            }\\n        }\\n    }\\n}\\n```\\n\\nAffinityLock 这个类在之前的文章里面出现过：[《面试官:Java如何绑定线程到指定CPU上执行?》](https://mp.weixin.qq.com/s/494wqyxyFzDuGwG_51tFbQ)\\n\\n就是把线程绑定到指定 CPU 上去执行，减少 CPU 抖动带来的损耗， 具体我就不介绍了，有兴趣去看我之前的文章。\\n\\n把这个程序跑起来之后，打开资源监视器，你可以看到 5 号 CPU 立马就飚到 100% 了，停止运行之后，立马就下来了：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/473460706bff40a08ebb978accdc5653~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n这就是眼见为实，这真是 JDK 的 BUG，我真没骗你。\\n\\n## 怎么修复\\n\\n在 JDK 9 里面是怎么修复这个 BUG 的呢？\\n\\n在前面提到的 BUG 的链接中，有这样的一个链接，里面就是 JDK 9 版本里面针对上述的 BUG 进行的修复：\\n\\n> http://hg.openjdk.java.net/jdk9/jdk9/jdk/rev/6dd59c01f011\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5a7317fe64d4610b6632a3a5a2dbac6~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n点开这个链接之后，你可以找到这个地方：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d637ad31ccd4db09a15709cd21b96d9~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n首先对比一下标号为 ① 和 ② 的地方，默认值从 0 纳秒修改为了 DEFAULT_KEEPALIVE_MILLIS 毫秒。\\n\\n而 DEFAULT_KEEPALIVE_MILLIS 的值为在标号为 ③ 的地方， 10L。\\n\\n也就是默认从 0 纳秒修改为了 10 毫秒。而这一处的改动，就是为了防止出现 coreSize 为 0 的情况。\\n\\n我们重点关注一下 DEFAULT_KEEPALIVE_MILLIS 上面的那一坨注释。\\n\\n我给你翻译一下，大概是这样的：\\n\\n这个值呢一般来说是用不上的，因为在 ScheduledThreadPoolExecutor 线程池里面的线程都是核心线程。\\n\\n但是，如果用户创建的线程池的时候，不听劝，头铁，要把 corePoolSize 设置为 0 会发生什么呢？\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/69680a8382f043708e591dd887bee9e6~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n因为 keepAlive 参数设置的为 0，那么就会导致线程在 getTask 方法里面非常频繁的循环，从而导致 CPU 飙高。\\n\\n那怎么办呢？\\n\\n很简单，设置一个小而非零的值就可以，而这个小是相对于 JVM 的运行时间而言的。\\n\\n所以这个 10 毫秒就是这样来的。\\n\\n## 再来一个\\n\\n在研究前面提到的编号为 8065320 的 BUG 的时候，我还发现一个意外收获，编号为 8051859 的 BUG，它们是挨着的，排排坐。\\n\\n有点意思，也很简单，所以分享一波：\\n\\n> https://bugs.openjdk.org/browse/JDK-8051859\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f1f187b5285b4116bf1594274fee2fdb~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n这个 BUG 又说的是啥事儿呢：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42af568709a248be9d819ac216e00df4~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n看截图这个 BUG 也是在 JDK 9 版本之后修复的。\\n\\n这个 BUG 的标题说的是 ScheduledExecutorService 线程池的 scheduleWithFixedDelay 方法，遇到大延迟时会执行失败。\\n\\n具体啥意思呢？\\n\\n我们还是先拿着 Demo 说：\\n\\n```\\npublic class ScheduledTaskBug {\\n    static public void main(String[] args) throws InterruptedException {\\n        ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();\\n        //第一个任务\\n        executor.scheduleWithFixedDelay(new Runnable() {\\n            @Override\\n            public void run() {\\n                System.out.println(\\\"running scheduled task with delay: \\\" + new Date());\\n            }\\n        }, 0, Long.MAX_VALUE, TimeUnit.MICROSECONDS);\\n\\n        //第二个任务\\n        executor.submit(new Runnable() {\\n            @Override\\n            public void run() {\\n                System.out.println(\\\"running immediate task: \\\" + new Date());\\n            }\\n        });\\n        Thread.sleep(5000);\\n        executor.shutdownNow();\\n    }\\n}\\n```\\n\\n你把这个代码粘过去之后，发现输出是这样的：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/619d9af724e146379ea44bf42aa9f9cb~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n只有第一个任务执行了，第二个任务没有输出结果。\\n\\n正常来说，第一个任务的延迟时间，也就是 initialDelay 参数是 0，所以第一次执行的时候是立即执行：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5b459fe3a40a437aa3492fea09faa550~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n比如我改成这样，把周期执行的时间单位，由微秒修改为纳秒，就正常了：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7834b5978a1d43fe846de242709902f3~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n神奇不神奇？你说这不是 BUG 这是啥？\\n\\n提出 BUG 的这个哥们在描述里面介绍了 BUG 的原因，主要是提到了一个字段和两个方法：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8a15ab9ced746dab09ea5f81c51ce34~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n一个字段是指 period，两个方法分别是 TimeUnit.toNanos(-delay) 和 ScheduledFutureTask.setNextRunTime()。\\n\\n首先，在 ScheduledThreadPoolExecutor 里面 period 字段有三个取值范围：\\n\\n-   正数，代表的是按照固定速率执行(scheduleAtFixedRate)。\\n-   负数，代表的是按照固定延时执行(scheduleWithFixedDelay)。\\n-   0，代表的是非重复性任务。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/66302a69330a40b9af115b72f567a33e~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n比如我们的示例代码中调用的是 scheduleWithFixedDelay 方法，它里面就会在调用 TimeUnit.toNanos 方法的时候取反，让 period 字段为负数：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/380d693b8ac64321ace6f7cda0e3d846~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n好，此时我们开始 Debug 我们的 Demo，先来一个正常的。\\n\\n比如我们来一个每 30ms 执行一次的周期任务，请仔细看：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b853d5c9637646c195a175513ad7c5ac~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n在执行 TimeUnit.toNanos(-delay) 这一行代码的时候，把 30 微秒转化为了 -30000 纳秒，也就是把 period 设置为 -30000。\\n\\n然后来到 setNextRunTime 方法的时候，计算任务下一次触发时间的时候，又把 period 转为正数，没有任何毛病：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7271aaf2396949e88cc02c5375b2b26b~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n但是，当我们把 30 修改为 Long.MAX_VALUE 的时候，有意思的事情就出现了：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/931f1795263b455ba5da6ce7a69c471f~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n> delay=9223372036854775807  \\n> -delay=-9223372036854775807  \\n> unit.toNanos(-delay)=-9223372036854775808\\n\\n直接给干溢出了，变成了 Long.MIN_VALUE：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/07de5098c76d4c62a1a92ba376b7dcf3~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n当来到 setNextRunTime 方法的时候，你会发现由于我们的 p 已经是 Long.MIN_VALUE 了。\\n\\n那么 -p 是多少呢？\\n\\n给你跑一下：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dba0854aaa9c4d8ebefcc5f078a0b853~tplv-k3u1fbpfcp-zoom-1.image)\\n\\nLong.MIN_VALUE 的绝对值，还是 Long.MIN_VALUE。一个神奇的小知识点送给你，不客气。\\n\\n所以 -p 还是 Long.MIN_VALUE：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/19a5c3a55e6e493c9c442659fa3ea5c9~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n我们来算一下啊，一秒等于 10 亿纳秒：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/07711ee1cd6646b380f0a6a5e742b716~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n那么下一次触发时间就变成了这样：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da59552902c34029a37b690721bb0924~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n292 年之前。\\n\\n这就是在 BUG 描述中提到的：\\n\\n> This results in triggerTime returning a time in the distant past.\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0080ffcee52349ef9198bd1f340ecb0b~tplv-k3u1fbpfcp-zoom-1.image)\\n\\nthe distant past，就是 long long ago，就是 292 年之前。就是 1731 年，雍正九年，那个时候的皇帝还是九子夺嫡中一顿乱杀，冲出重围的胤禛大佬。\\n\\n确实是很久很久以前了。\\n\\n那么这个 BUG 怎么修复呢？\\n\\n其实很简单：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee7cdb1656af4fec9cdb0d3cdb35a79a~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n把 unit.toNanos(-delay) 修改为 -unit.toNanos(delay)，搞定。\\n\\n我给你盘一下：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4db0c8a3e70049048f8989f3fce10c12~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n这样就不会溢出，时间就变成了 292 年之后。\\n\\n那么问题就来了，谁特么会设置一个每 292 年执行一次的 Java 定时任务呢？\\n\\n好，你看到这里了，本文就算结束了，我来问你一个问题：你知道了这两个 BUG 之后，对你来说有什么收获吗？\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee6cb90f948f45f59b852ab5ffed9f64~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n没有，是的，除了浪费了几分钟时间外，没有任何收获。\\n\\n那么恭喜你，又在我这里学到了两个没有卵用的知识点。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/823b73935cef4e5b8b8d4aabbb32a6b4~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n## 汇总\\n\\n这个小节为什么叫做汇总呢？\\n\\n因为我发现这里出现的一串 BUG，除了本文提到的 2 个外，还有 3 个我都写过了，所以在这里汇个总，充点字数，凑个篇幅：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0014323b10a9420aa9af24b8dd059dae~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n> 8054446: Repeated offer and remove on ConcurrentLinkedQueue lead to an OutOfMemoryError\\n\\n[《我的程序跑了60多小时，就是为了让你看一眼JDK的BUG导致的内存泄漏。》](https://mp.weixin.qq.com/s/nWDU5u7ijnefhysOjeXHCA)\\n\\n这篇文章就是从 ConcurrentLinkedQueue 队列的一个 BUG 讲起。jetty 框架里面的线程池用到了这个队列，导致了内存泄漏。\\n\\n同时通过 jconsole、VisualVM、jmc 这三个可视化监控工具，让你看见“内存泄漏”的发生。\\n\\n> 8062841: ConcurrentHashMap.computeIfAbsent stuck in an endless loop\\n\\n[《震惊！ConcurrentHashMap里面也有死循环，作者留下的“彩蛋”了解一下？》](https://mp.weixin.qq.com/s/5T3kIyvcoosIIvlWtAGHKw)\\n\\n这个 BUG 在 Dubbo 和 Seata 里面都有提到过，也被 Seata 官方的一篇博客中被引用过：\\n\\n> https://seata.io/zh-cn/blog/seata-dsproxy-deadlock.html\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8327e06b290345f58bc49510f8fea141~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n> 8073704: FutureTask.isDone returns true when task has not yet completed\\n\\n[《Doug Lea在J.U.C包里面写的BUG又被网友发现了。》](https://mp.weixin.qq.com/s/B3PrMiR4_Ghg9ROQj0ks0Q)\\n\\n这个 BUG 也是在 JDK 9 版本里面修复的，逻辑弯弯绕绕的，但是理解之后，对于 FutureTask 状态流转就能有一个比较深刻的认知了。有兴趣可以看看。"
    },
    {
        "article_id": "7161964571853815822",
        "cover_image": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a17fbb58f1842968ffeb45f5ff21b7c~tplv-k3u1fbpfcp-watermark.image?",
        "title": "MySQl 索引之道",
        "brief": "SQL 写不好 加班少不了 日常工作中SQL 是必不可少的一项技术 但是很多人不会过多的去关注SQL问题 一是数据量小 二是没有意识到索引的重要性 本文主要是整理 SQL失效场景 如果里面的细节",
        "user_name": "进阶的派大星",
        "view_count": 26900,
        "collect_count": 536,
        "comment_count": 44,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/ebb0d4fab24d53a705930beec5e665ce~300x300.image",
        "category": "后端",
        "content": "\\n> MySQl 专栏持续更新 不说晦涩难懂的东西 尽量输出容易理解 和 使用的SQL技巧 和 初中级开发不是很常用的但很有用的知识\\n> \\n> 欢迎查看👉🏻👉🏻👉🏻[SQL 专栏](https://juejin.cn/column/7157955810826387470)   查漏补缺    指教一二 \\n> \\n> ![src=http __img2.biaoqingjia.com_biaoqing_201810_2c3993f64eec252da6d674f9d80fc4e9.gif&refer=http __img2.biaoqingjia.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9572ab2e6c3545dbaa4b2b75f4a3b6c1~tplv-k3u1fbpfcp-watermark.image?)\\n> \\n> 每一次写博客对技术都会有更深入的理解 积少成多 百天计划我也想看看自己有多少成长  祝君好运 工作顺利\\n\\n***本文正在参加[「技术专题19期 漫谈数据库技术」](https://juejin.cn/post/7160601544600567845 \\\"https://juejin.cn/post/7160601544600567845\\\")活动***\\n# 前言\\nSQL 写不好 加班少不了  日常工作中SQL 是必不可少的一项技术 但是很多人不会过多的去关注SQL问题 一是数据量小 二是没有意识到索引的重要性 本文主要是整理 SQL失效场景 如果里面的细节你都知道 那你一定是学习能力比较好的人 膜拜 写完这篇文章 我感觉自己之前知道的真的是 “目录” 没有明白其中的内容 如果你能跟着节奏看完文章 一定会有收获 至少我写完感觉思维通透很多 以后百分之九十的 SQl索引问题 和 面试这方面问题都能拿捏两\\n\\n`文章 字数 六千余字 观看时长十分钟 练习时长两个半小时  持续补充ing`\\n# 文章概要\\n\\n\\n![图片.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76b70720b0cb422fb2583fb80a745e99~tplv-k3u1fbpfcp-watermark.image?)\\n\\n# 索引失效 整理\\n## 基础数据准备\\n准备一个数据表作为 数据演示  这里面一共 创建了三个索引\\n- 联合索引  `sname`, `s_code`, `address`\\n- 主键索引  `id`\\n- 普通索引  `height`\\n```java\\nSET NAMES utf8mb4;\\nSET FOREIGN_KEY_CHECKS = 0;\\n\\n-- ----------------------------\\n-- Table structure for student\\n-- ----------------------------\\nDROP TABLE IF EXISTS `student`;\\nCREATE TABLE `student`  (\\n  `id` int(11) NOT NULL AUTO_INCREMENT,\\n  `sname` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,\\n  `s_code` int(100) NULL DEFAULT NULL,\\n  `address` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\\n  `height` double NULL DEFAULT NULL,\\n  `classid` int(11) NULL DEFAULT NULL,\\n  `create_time` datetime(0) NOT NULL ON UPDATE CURRENT_TIMESTAMP(0),\\n  PRIMARY KEY (`id`) USING BTREE,\\n  INDEX `普通索引`(`height`) USING BTREE,\\n  INDEX `联合索引`(`sname`, `s_code`, `address`) USING BTREE\\n) ENGINE = InnoDB AUTO_INCREMENT = 5 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;\\n\\n-- ----------------------------\\n-- Records of student\\n-- ----------------------------\\nINSERT INTO `student` VALUES (1, '学生1', 1, '上海', 170, 1, '2022-11-02 20:44:14');\\nINSERT INTO `student` VALUES (2, '学生2', 2, '北京', 180, 2, '2022-11-02 20:44:16');\\nINSERT INTO `student` VALUES (3, '变成派大星', 3, '京东', 185, 3, '2022-11-02 20:44:19');\\nINSERT INTO `student` VALUES (4, '学生4', 4, '联通', 190, 4, '2022-11-02 20:44:25');\\n```\\n\\n## 问题思考\\n上面的SQL 我们已经创建好基本的数据  在验证之前 先带着几个问题  \\n\\n\\n![图片.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/06be80e0d7c04d639e3a694c907b4da8~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n我们先从上往下进行验证 \\n\\n## 最左匹配原则\\n写在前面：我很早之前就听说过数据库的最左匹配原则，当时是通过各大博客论坛了解的，但是这些博客的局限性在于它们对最左匹配原则的描述就像一些数学定义一样，往往都是列出123点，满足这123点就能匹配上索引，否则就不能。\\n最左匹配原则就是指在联合索引中，如果你的 SQL 语句中用到了联合索引中的最左边的索引，那么这条 SQL 语句就可以利用这个联合索引去进行匹配，我们上面建立了联合索引 可以用来测试最左匹配原则 `sname`, `s_code`, `address`  \\n\\n\\n请看下面SQL语句 进行思考 是否会走索引\\n\\n\\n```java\\n-- 联合索引 sname,s_code,address\\n\\n1、select create_time from student where sname = \\\"变成派大星\\\"  -- 会走索引吗？\\n\\n2、select create_time from student where s_code = 1   -- 会走索引吗？\\n\\n3、select create_time from student where address = \\\"上海\\\"  -- 会走索引吗？\\n\\n4、select create_time from student where address = \\\"上海\\\" and s_code = 1 -- 会走索引吗？\\n\\n5、select create_time from student where address = \\\"上海\\\" and sname = \\\"变成派大星\\\"  -- 会走索引吗？\\n\\n6、select create_time from student where sname = \\\"变成派大星\\\" and address = \\\"上海\\\"  -- 会走索引吗？\\n\\n7、select create_time from student where sname = \\\"变成派大星\\\" and s_code = 1 and address = \\\"上海\\\"  -- 会走索引吗？\\n```\\n凭你的经验 哪些会使用到索引呢 ？ 可以先思考一下 在心中记下数字\\n\\n![图片.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/783520d8f38b4e259e8f6d7b65a05103~tplv-k3u1fbpfcp-watermark.image?)\\n\\n**走索引例子**\\n\\n```java\\nEXPLAIN  select create_time from student where sname = \\\"变成派大星\\\"  -- 会走索引吗？\\n```\\n![图片.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d253165cfba04252aa4c4a219b697a81~tplv-k3u1fbpfcp-watermark.image?)\\n\\n**未走索引例子**\\n\\n```java\\nEXPLAIN select create_time from student where address = \\\"上海\\\" and s_code = 1 -- 会走索引吗？\\n```\\n\\n走的全表扫描 rows = 4\\n![图片.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9395730bd49645f1848278ff1d7d2467~tplv-k3u1fbpfcp-watermark.image?)\\n如果不知道`EXPLAIN` 是什么的 或者看不懂分析出来的数据的话 建议去看看另一篇文章[分析命令EXPLAIN超详解](https://juejin.cn/post/7161254854571065375)\\n\\n如果你内心的答案没有全部说对就接着往下看\\n\\n最左匹配原则顾名思义：最左优先，以最左边的为起点任何连续的索引都能匹配上。**同时遇到范围查询(>、<、between、like)就会停止匹配**。  \\n例如：s_code = 2 如果建立(`sname`, `s_code`)顺序的索引，是匹配不到(`sname`, `s_code`)索引的;\\n\\n但是如果查询条件是sname = \\\"变成派大星\\\" and s_code = 2或者a=1(又或者是s_code = 2 and sname = \\\"变成派大星\\\" )就可以，**因为优化器会自动调整`sname`, `s_code`的顺序**。再比如sname = \\\"变成派大星\\\" and s_code > 1 and address = \\\"上海\\\"  `address是用不到索引的`，因为s_code字段是一个范围查询，它之后的字段会停止匹配。\\n\\n不带范围查询 索引使用类型\\n![图片.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/62cf1fbb4d694a32b1374a7621259924~tplv-k3u1fbpfcp-watermark.image?)\\n\\n带范围使用类型\\n\\n![图片.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a8bf03bef225405b83de31f9ffcdd1af~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n根据上一篇文章的讲解 可以明白 ref 和range的含义  级别还是相差很多的\\n\\n\\n![图片.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd7c90f9067344fdaa91724d0f6882f1~tplv-k3u1fbpfcp-watermark.image?)\\n\\n### 思考\\n\\n为什么左链接一定要遵循最左缀原则呢？\\n\\n### 验证\\n看过一个比较好玩的回答 \\n\\n>你可以认为联合索引是闯关游戏的设计  \\n例如你这个联合索引是state/city/zipCode  \\n那么state就是第一关 city是第二关， zipCode就是第三关  \\n你必须匹配了第一关，才能匹配第二关，匹配了第一关和第二关，才能匹配第三关\\n\\n这样描述不算完全准确 但是确实是这种思想\\n\\n要想理解联合索引的最左匹配原则，先来理解下索引的底层原理。索引的底层是一颗B+树，那么联合索引的底层也就是一颗B+树，只不过联合索引的B+树节点中存储的是键值。由于构建一棵B+树只能根据一个值来确定索引关系，所以数据库依赖联合索引最左的字段来构建 文字比较抽象 我们看一下\\n\\n\\n加入我们建立 A,B 联合索引 他们在底层储存是什么样子呢？\\n\\n- 橙色代表字段 A\\n- 浅绿色 代表字段B\\n\\n图解：\\n![图片.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a35b2ec784eb48109fe2916eade3c248~tplv-k3u1fbpfcp-watermark.image?)\\n\\n我们可以看出几个特点\\n\\n- A 是有顺序的  1，1，2，2，3，4\\n- B 是没有顺序的 1，2，1，4，1，2 这个是散列的\\n- 如果A是等值的时候 B是有序的  例如 （1，1），（1，2） 这里的B有序的 （2，1）,(2,4) B 也是有序的\\n\\n这里应该就能看出 如果没有A的支持 B的索引是散列的 不是连续的 \\n\\n再细致一点 我们重新创建一个表\\n\\n```java\\nDROP TABLE IF EXISTS `leftaffix`;\\n\\nCREATE TABLE `leftaffix`  (\\n\\n  `a` int(11) NOT NULL AUTO_INCREMENT,\\n\\n  `b` int(11) NULL DEFAULT NULL,\\n\\n  `c` int(11) NULL DEFAULT NULL,\\n\\n  `d` int(11) NULL DEFAULT NULL,\\n\\n  `e` varchar(11) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\\n\\n  PRIMARY KEY (`a`) USING BTREE,\\n\\n  INDEX `联合索引`(`b`, `c`, `d`) USING BTREE\\n\\n) ENGINE = InnoDB AUTO_INCREMENT = 8 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;\\n \\n-- ----------------------------\\n-- Records of leftaffix\\n-- ----------------------------\\nINSERT INTO `leftaffix` VALUES (1, 1, 1, 1, '1');\\n\\nINSERT INTO `leftaffix` VALUES (2, 2, 2, 2, '2');\\n\\nINSERT INTO `leftaffix` VALUES (3, 3, 2, 2, '3');\\n\\nINSERT INTO `leftaffix` VALUES (4, 3, 1, 1, '4');\\n\\nINSERT INTO `leftaffix` VALUES (5, 2, 3, 5, '5');\\n\\nINSERT INTO `leftaffix` VALUES (6, 6, 4, 4, '6');\\n\\nINSERT INTO `leftaffix` VALUES (7, 8, 8, 8, '7');\\nSET FOREIGN_KEY_CHECKS = 1;\\n```\\n\\n\\n![图片.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/39277837f4fb4f8d8f4707ae5a597880~tplv-k3u1fbpfcp-watermark.image?)\\n\\n> 在创建索引树的时候会对数据进行排序 根据最左缀原则  会先通过 B 进行排序 也就是 如果出现值相同就 根据 C 排序 如果 C相同就根据D 排序 排好顺序之后就是如下图：\\n\\n\\n\\n\\n![图片.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/311f0f59b47141a185b466f26df0d2e0~tplv-k3u1fbpfcp-watermark.image?)\\n\\n>索引的生成就会根据图二的顺序进行生成  我们看一下 生成后的树状数据是什么样子\\n\\n\\n\\n![图片.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cb22bb31c6f14d3683164388042bc0f1~tplv-k3u1fbpfcp-watermark.image?)\\n\\n> 解释一些这个树状图  首先根据图二的排序 我们知道顺序 是 1111a  2222b 所以 在第三层 我们可以看到 1111a 在第一层 2222b在第二层  因为 111 < 222 所以 111 进入第二层 然后得出第一层\\n\\n\\n![图片.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5393546a6d59417388538798c34ca04f~tplv-k3u1fbpfcp-watermark.image?)\\n\\n简化一下就是这个样子\\n\\n\\n但是这种顺序是相对的。这是因为MySQL创建联合索引的规则是首先会对联合索引的最左边`第一个字段排序`，在第一个字段的排序基础上，然后在对第二个字段进行排序。所以B=2这种查询条件没有办法利用索引。\\n\\n>\\n\\n看到这里还可以明白一个道理 为什么我们建立索引的时候不推荐建立在经常改变的字段 因为这样的话我们的索引结构就要跟着你的改变而改动 所以很消耗性能 \\n\\n### 补充\\n\\n评论区老哥的提示 最左缀原则可以通过跳跃扫描的方式打破 简单整理一下这方面的知识\\n\\n\\n这个是在 8.0 进行的优化\\n\\n`MySQL8.0版本`开始增加了索引跳跃扫描的功能，当第一列索引的唯一值较少时，即使where条件没有第一列索引，查询的时候也可以用到联合索引。\\n比如我们使用的联合索引是 bcd  但是b中字段比较少 我们在使用联合索引的时候没有 使用 b 但是依然可以使用联合索引\\n**MySQL联合索引有时候遵循最左前缀匹配原则，有时候不遵循。**\\n### 小总结\\n\\n前提 如果创建 b,c,d 联合索引面\\n\\n- 如果 我where 后面的条件是` c = 1 and d = 1 `为什么不能走索引呢 如果没有b的话 你查询的值相当于` *11` 我们都知道`*`是所有的意思也就是我能匹配到所有的数据\\n- 如果 我 where 后面是` b = 1 and d =1` 为什么会走索引呢？ 你等于查询的数据是 `1*1 `我可以通过前面 1 进行索引匹配 所以就可以走索引 \\n- 最左缀匹配原则的最重要的就是 第一个字段\\n\\n\\n我们接着看下一个失效场景\\n\\n## select *\\n### 思考\\n这里是我之前的一个思维误区 select * 不会导致索引失效 之前测试发现失效是因为where 后面的查询范围过大 导致索引失效 并不是Select * 引起的  但是为什么不推荐使用select * \\n### 解释\\n\\n-   增加查询分析器解析成本。\\n-   增减字段容易与 resultMap 配置不一致。\\n-   无用字段增加网络 消耗，尤其是 text 类型的字段。  \\n    在阿里的开发手册中，大面的概括了上面几点。\\n\\n\\n在使用Select * 索引使用正常\\n![图片.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f81456c6434c4beda1388db375956a17~tplv-k3u1fbpfcp-watermark.image?)\\n\\n虽然走了索引但是 也不推荐这种写法 为什么呢？\\n\\n首先我们在上一个验证中创建了联合索引 我们使用B=1 会走索引  但是 与直接查询索引字段不同  使用`SELECT*`,获取了不需要的数据，则首先通过辅助索引过滤数据，然后再通过聚集索引获取所有的列，这就多了一次b+树查询，速度必然会慢很多，减少使用select * 就是降低回表带来的损耗。\\n\\n\\n![图片.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c32c8aa321f3458b95a00ae04ec8c37b~tplv-k3u1fbpfcp-watermark.image?)\\n\\n![图片.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d5e676c05644c1aaaf62a5f214354b3~tplv-k3u1fbpfcp-watermark.image?)\\n\\n也就是 Select * 在一些情况下是会走索引的 如果不走索引就是 where 查询范围过大 导致MySQL 最优选择全表扫描了 并不是Select * 的问题\\n\\n\\n![图片.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/641cc7d7b0ad4d04aa9417f721ca7be1~tplv-k3u1fbpfcp-watermark.image?)\\n\\n上图就是索引失效的情况 \\n\\n范围查找也不是一定会索引失效 下面情况就会索引生效就是 级别低 生效的原因是因为缩小了范围 \\n\\n![图片.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05fab88741414b70896dedc185d6a3ff~tplv-k3u1fbpfcp-watermark.image?)\\n\\n### 小总结\\n\\n- select * 会走索引\\n- 范围查找有概率索引失效但是在特定的情况下会生效 范围小就会使用 也可以理解为 返回结果集小就会使用索引\\n-  mysql中连接查询的原理是先对驱动表进行查询操作，然后再用从驱动表得到的数据作为条件，逐条的到被驱动表进行查询。\\n-  每次驱动表加载一条数据到内存中，然后被驱动表所有的数据都需要往内存中加载一遍进行比较。效率很低，所以mysql中可以指定一个缓冲池的大小，缓冲池大的话可以同时加载多条驱动表的数据进行比较，放的数据条数越多性能io操作就越少，性能也就越好。所以，如果此时使用`select *` 放一些无用的列，只会白白的占用缓冲空间。浪费本可以提高性能的机会。\\n\\n- 按照评论区老哥的说法 select * 不是造成索引失效的直接原因 大部分原因是 where 后边条件的问题 但是还是尽量少去使用select * 多少还是会有影响的\\n\\n## 使用函数\\n\\n使用在Select 后面使用函数可以使用索引 但是下面这种做法就不能\\n\\n![图片.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/48f8fee5fda042b4a21ba190a68dbca2~tplv-k3u1fbpfcp-watermark.image?)\\n\\n![图片.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b22c7170e6bd4c9084e6f0dc01521412~tplv-k3u1fbpfcp-watermark.image?)\\n\\n因为索引保存的是索引字段的原始值，而不是经过函数计算后的值，自然就没办法走索引了。\\n\\n不过，从 MySQL 8.0 开始，索引特性增加了函数索引，即可以针对函数计算后的值建立一个索引，也就是说该索引的值是函数计算后的值，所以就可以通过扫描索引来查询数据。\\n\\n这种写法我没使用过 感觉情况比较少 也比较容易注意到这种写法\\n\\n## 计算操作\\n这个情况和上面一样 之所以会导致索引失效是因为改变了索引原来的值 在树中找不到对应的数据只能全表扫描\\n\\n![图片.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c4ce2c6583a4107aab778669bf1b775~tplv-k3u1fbpfcp-watermark.image?)\\n因为索引保存的是索引字段的原始值，而不是 b - 1 表达式计算后的值，所以无法走索引，只能通过把索引字段的取值都取出来，然后依次进行表达式的计算来进行条件判断，因此采用的就是全表扫描的方式。\\n\\n下面这种计算方式就会使用索引\\n\\n![图片.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab31b17d52f44d4297c1a10248c97f33~tplv-k3u1fbpfcp-watermark.image?)\\n\\nJava比较熟悉的可能会有点疑问，这种对索引进行简单的表达式计算，在代码特殊处理下，应该是可以做到索引扫描的，比方将 b - 1 = 6 变成 b = 6 - 1。\\n是的，是能够实现，但是 MySQL 还是偷了这个懒，没有实现。\\n\\n### 小总结\\n\\n总而言之 言而总之 只要是影响到索引列的值 索引就是失效\\n\\n## Like %\\n\\n这个真的是难受哦  因为经常使用这个 所以还是要小心点\\n在看为什么失效之前 我们先看一下 Like % 的解释\\n1.  **%百分号通配符:** 表示任何字符出现任意次数(可以是0次).\\n2.  **_下划线通配符:** 表示只能匹配单个字符,不能多也不能少,就是一个字符.\\n3.  **like操作符:** LIKE作用是指示mysql后面的搜索模式是利用通配符而不是直接相等匹配进行比较.\\n\\n**注意:** 如果在使用like操作符时,后面的没有使用通用匹配符效果是和=一致的,\\n\\n```java\\nSELECT * FROM products WHERE products.prod_name like '1000';\\n```\\n\\n2.匹配包含\\\"Li\\\"的记录(包括记录\\\"Li\\\") :\\n```java\\nSELECT* FROM products WHERE products.prod_name like '%Li%';\\n```\\n3.匹配以\\\"Li\\\"结尾的记录(包括记录\\\"Li\\\",不包括记录\\\"Li \\\",也就是Li后面有空格的记录,这里需要注意) \\n```java\\nSELECT * FROM products WHERE products.prod_name like '%Li';\\n```\\n\\n在左不走 在右走\\n\\n`右：`\\n虽然走 但是索引级别比较低主要是模糊查询 范围比较大 所以索引级别就比较低\\n![图片.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c0fd95c00a9f44ffbed872907e23bd76~tplv-k3u1fbpfcp-watermark.image?)\\n\\n`左：`\\n这个范围非常大 所以没有使用索引的必要了 这个可能不是很好优化 还好不是一直拼接上面的\\n\\n![图片.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/183762e539b04420b6db1acc4a7cabbb~tplv-k3u1fbpfcp-watermark.image?)\\n\\n### 小总结\\n\\n索引的时候和查询范围关系也很大 范围过大造成索引没有意义从而失效的情况也不少\\n\\n## 使用Or导致索引失效\\n这个原因就更简单了\\n\\n在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效\\n举个例子，比如下面的查询语句，b 是主键，e 是普通列，从执行计划的结果看，是走了全表扫描。\\n\\n![图片.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5fe15263f1414f058690cb11a02fdbbe~tplv-k3u1fbpfcp-watermark.image?)\\n\\n### 优化\\n这个的优化方式就是 在Or的时候两边都加上索引\\n\\n就会使用索引 避免全表扫描\\n![图片.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2924e8c883046a793416a7e9f9307e4~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## in使用不当\\n\\n首先使用In 不是一定会造成全表扫描的 **IN肯定会走索引，但是当IN的取值范围较大时会导致索引失效，走全表扫描**\\n\\n\\n![图片.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c6239288d63424f97463355bd4c459c~tplv-k3u1fbpfcp-watermark.image?)\\n\\n![图片.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a515623c61a403b86af444c7db46fa9~tplv-k3u1fbpfcp-watermark.image?)\\n\\nin 在结果集 大于30%的时候索引失效\\n\\n## not in 和 In的失效场景相同\\n\\n## order By\\n\\n![图片.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/664a7329241840e888d5569d4b0e3475~tplv-k3u1fbpfcp-watermark.image?)\\n这一个主要是Mysql 自身优化的问题 我们都知道OrderBy 是排序 那就代表我需要对数据进行排序 如果我走索引 索引是排好序的 但是我需要回表 消耗时间 另一种 我直接全表扫描排序 不用回表 也就是\\n\\n- 走索引 + 回表\\n- 不走索引 直接全表扫描\\n\\nMysql 认为直接全表扫面的速度比 回表的速度快所以就直接走索引了  在Order By 的情况下 走全表扫描反而是更好的选择\\n\\n## 子查询会走索引吗\\n\\n答案是会 但是使用不好就不会\\n\\n\\n## 大总结\\n\\n\\n\\n![图片.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/10bddf61252f42c7919e2f7be2b410e5~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## 减少回表优化思路\\n**这个对于SQL有研究的人可能是比较了解的但是对于工作时长不久的会比较陌生的词语 但是这个是非常有意思 且重要的**\\n\\n在这个索引问题上面还有一个细节的东西 其中印象比较深刻的是回表会造成效率下降 但是在我们日常工作中是比较常用单列索引 联合索引对于新手来说不是很常用 但是单列索引在一些情况下肯定不是最优解 例如 like % 问题 会造成索引问题 近期了解到一个 `ICP` 知识  我之前都没有关注过 不知道大家对这个了解多少 我这里就进行一些整理\\n\\n首先我们ICP 全称是 `Index Condition Pushdown` 中文可以说成是索引下推 主要的作用解决数据查询回表的问题 但是前提是和联合索引进行使用 才能发挥出来功效 接下来不了解的小伙伴可以认真看一下这一点 个人感觉还是比较有意思的东西\\n\\n### 回表问题\\n上面其实对于回表查询没有过多的解释 就再提一什么是回表查询\\n\\n回表查询一般发生在非主键索引上面 需要进行两次树查询 所以效率会有所折扣 我们要想解决这个行为就可以使用 联合索引去优化\\n\\n### ICP 索引下推\\n这个是在MySQL 5.6 之后提供的特性 这个如果面试中问到 我们平常面试的时候 面试官都有喜欢问什么版本 增加了什么  如果问你 MySQL 5.6 之后增加什么优化 不知道大家都能说出什么 这个就是一个很加分点 你能说明白什么是索引下推 面试官会对你增加好感 至少说明你还是有点东西在身上的 不啰嗦了 开始研究\\n\\n![图片.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a548a5c1fad46819a37da9a9bf0d058~tplv-k3u1fbpfcp-watermark.image?)\\n\\n我们先看一下 5.6 之前 和 5.6 之后 查询流程会有什么变化\\n\\n假设 我我们需要查询 `select * from table1 where b like '3%' and c = 3`\\n\\n**5.6 之前**\\n- 先通过 联合索引 查询到 开头为 3 的数据 然后拿到主键（上图中青色块为主键）\\n- 然后通过主键去主键索引里面去回表查询 二级索引里面查询出来几个 3 开头的就回表几次\\n\\n**5.6 之后**\\n- 先通过 二级索引 查询到开头为 3 的数据 然后 再找到 c = 3 的数据进行过滤 之后拿到主键\\n- 通过主键进行回表查询\\n\\n上面都会进行回表查询但是 5.6 之前没有完全去利用 二级缓存进行数据过滤 如果 3 开头的数据非常多 那就要一直回表 但是 5.6 之后去利用后续索引字段进行查询\\n\\n怎么说呢 就是为什么索引下推要和联合索引进行使用 普通所以没有  索引下推就是充分利用 联合索引的字段进过滤 尽量减少需要回表的数据 来增加查询效率 感觉思路是很简单的 \\n\\n对于Innodb 引擎的ICP 只适合 二级索引\\n\\n`小细节：`\\n\\n索引下推除了依赖 联合索引之外 还不能在子查询下面进行使用  存储函数也不能使用 \\n\\n怎么查看是否使用索引下推\\n\\n\\n![图片.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c9c9758fe2549d0b53d954208a22bff~tplv-k3u1fbpfcp-watermark.image?)\\n看这个你可能有点印象但是 理论上不是很明白 但是我现在是明白了 还有很多知识点要补充啊 慢慢写\\n\\n\\n- 如果你是直接跳到这里 看看文章有多长 `建议收藏`\\n- 如果你一步步看到这里 感觉有点帮助 `赞赞来一个`\\n- 如果感觉文章有问题 建议评论区指出 `会修正`\\n\\n周五愉快 文章完结🥰\\n\\n持续更新SQL相关系列 可追更 不可催更\\n\\n![0bd2663ecc3e21c3a51f382cec4bb8b6.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bed95998e47144b4a49e8a42246ece50~tplv-k3u1fbpfcp-watermark.image?)\\n\\n***本文正在参加[「技术专题19期 漫谈数据库技术」](https://juejin.cn/post/7160601544600567845 \\\"https://juejin.cn/post/7160601544600567845\\\")活动***"
    },
    {
        "article_id": "7186656006893420604",
        "cover_image": "https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/26f9381501054117943b2804c4934aca~tplv-k3u1fbpfcp-watermark.image?",
        "title": "兔年共赏电子烟花可好？",
        "brief": "新年到，放鞭炮。Wait根据国家相关法律法规，禁止在市区燃放鞭炮。Emmmm，真是破了大防。不过嘛，我在电脑上燃放一下电子鞭炮总没问题吧？？？所以，今天我们就来在电脑上完成一个简单的烟花效果",
        "user_name": "鹤云云",
        "view_count": 7893,
        "collect_count": 57,
        "comment_count": 17,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/1b99863cd5a91e6784407941bb66409a~300x300.image",
        "category": "前端",
        "content": "---\\nhighlight: a11y-light\\ntheme: smartblue\\n---\\n\\n“我正在参加「兔了个兔」创意投稿大赛，详情请看：[「兔了个兔」创意投稿大赛](https://juejin.cn/post/7185104994801025061 \\\"https://juejin.cn/post/7185104994801025061\\\")”\\n\\n# 前言\\n新年到，放鞭炮。Wait......根据国家相关法律法规，禁止在市区燃放鞭炮。。。Emmmm，真是破了大防。不过嘛，我在电脑上燃放一下电子鞭炮总没问题吧？？？\\n\\n所以，今天我们就来在电脑上完成一个简单的燃放鞭炮的小特效。\\n\\n我们的运行环境当然是作者喜欢的Shadertoy!!!如果还不知道shadertoy及运行环境的小伙伴，可以查看这篇专栏里的文章。 [Shader从入门到放弃 - 鹤云云的专栏 - 掘金 (juejin.cn)](https://juejin.cn/column/7169417227739856903)\\n\\n阅读本文你将会收获一幅美丽的兔子🐰烟花🎆图~\\n\\n![20230106-141535.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b2a5d5f6706849ce90d6598f5a493f19~tplv-k3u1fbpfcp-watermark.image?)\\n\\n# 编码\\n\\n## 归一化UV坐标\\n\\n```c\\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\\n    vec2 uv = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\\n    vec3 col = vec3(0.0);\\n\\n    float d = length(uv);\\n    col += 0.005 / d;\\n    fragColor = vec4(col, 1.0);\\n}\\n```\\n之前学习过[Shader从入门到放弃 - 鹤云云的专栏 - 掘金 (juejin.cn)](https://juejin.cn/column/7169417227739856903)专栏的小伙伴应该对这一步很熟悉了吧。\\n\\n不过鉴于有新人朋友阅读文章，在这里我还是啰嗦一下，这一步主要是将坐标进行一次重新的映射。\\n假设我们的画布区域的大小是 640x360，其原点处于左下角。我们的代码是将坐标转化为 `-0.5~0.5` 之间。\\n\\n![iShot_2023-01-09_18.23.06-tuya.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2d9fac308e44a19b835079e25033d78~tplv-k3u1fbpfcp-watermark.image?)\\n\\n现在我们就将坐标转化为了 `-0.5 ~ 0.5` 之间了。\\n而 `d = length(uv)` 则是计算各个像素点距离画布中心的位置了。\\n\\n我们可以设置`col = d`来观察各个像素点距离画布中心的颜色，像素颜色越黑则表示其距离画布中心越近。其距离的范围是 `0~0.5` 这一点一定要记住。\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d3e4fb1c2184326824be64a9269a75a~tplv-k3u1fbpfcp-watermark.image?)\\n\\n为什么我们需要用一个常数来除以这个`d` 呢？因为我们想要其中心很亮，然后离中心越远的地方就越暗淡。如下面的函数图像所示，我们可以通过调整这个常数项来改变我们的圆点的亮度和大小。常数越大的话我们的圆点就越大、越亮。\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a3f308c0fba44af28211ff3d04beeaba~tplv-k3u1fbpfcp-watermark.image?)\\n\\n这里我们暂时取值0.005吧。结果如下：\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa7dfe97584e4badbbbc2d708bf1b0c2~tplv-k3u1fbpfcp-watermark.image?)\\n\\n这个小圆点就是贯穿我们始终的东西了，也就是所谓的“粒子”。我们将使用多个粒子来绘制我们的烟花。\\n\\n## 动起来吧\\n第二步我们就要让这个小家伙动起来了。看过专栏的同学应该知道，如果我们想要实现一些动画，我们肯定是需要用到 `iTime` 这个参数的，这里我再啰嗦一下。\\n\\n`iTime` 是shadertoy 提供的一个内置的变量，它会随着时间不断地变大。所以我们可以利用它来实现一下动画。\\n首先，第一步要做的依然还是对其进行归一化。否则动画就会拥有无限的时间轴，而不会反复进行播放了。\\n\\nWait！可能你又要问，这个`iTime` 是不断变大的如何让它“归一化”呢？ 呃呃呃，这里是作者的措词问题。其实也不能算是归一化吧。就是把 `iTime` 限制在 0~1的区间。\\n\\nGLSL为我们提供了一个常用的函数 `fract` 该函数可以取其小数点后的部分。\\n\\nWait Wait Wait，这里有一个极易犯错的点！\\n\\n**`fract(x)` 函数等价于的是 `x - floor(x)`。这就意味着：`fract(-1.2345)`并不等于 `-0.2345` 也不等于 `0.2345`，它实际上等价于 `-1.2345 - floor(-1.2345) = -1.2345 - (-2) = 0.7655`！！！**\\n\\n现在我们修改代码如下：\\n\\n```c\\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\\n    vec2 uv = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\\n    vec3 col = vec3(0.0);\\n\\n    float t = fract(iTime);\\n    vec2 dir = vec2(1.0, 1.0) * 0.5;\\n\\n    vec2 p = uv - dir * t;\\n\\n    float d = length(p);\\n    col += 0.008 / d;\\n\\n    fragColor = vec4(col, 1.0);\\n}\\n```\\n容我对以上代码稍加解释：\\n\\n- `t = fract(iTime)` 是为了将 `iTime` 限制在 0~1的范围内。\\n- `dir = vec2(1.0, 1.0) * 0.5` 是为了给我们的粒子一个运动的方向。而 0.5 则是因为我们的画布范围只有 `-0.5~0.5` 所以我们要限制其范围。\\n- `p = uv - dir * t`，根据当前时间来计算当前粒子的位置\\n\\n最终结果如下：\\n![20230109184637_rec_.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2758ba2925934eddbc88cf067f48d32f~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## More And More\\n嘿！如果我说我们的程序已经完成了30%你相信吗。但是事实就是如此，我们的程序的基本结构已经快呼之欲出了。对于单个的烟花粒子来说，它就是从一处运动到另一处的过程，现在我们要增加更多的烟花粒子！！！\\n\\n从直觉上来说，我们需要增加更多的粒子的话，第一个击中你的思路是什么？没错，就是`for` 循环。假设我们现在有10个粒子。我们很容易写出下面的代码：\\n```c\\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\\n    vec2 uv = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\\n    vec3 col = vec3(0.0);\\n\\n    float t = fract(iTime);\\n    for(float i = 0.0; i < 10.0; i++) {\\n        vec2 dir = vec2(1.0, 1.0) * 0.5;\\n        vec2 p = uv - dir * t;\\n        float d = length(p);\\n        col += 0.008 / d;\\n    }\\n\\n    fragColor = vec4(col, 1.0);\\n}\\n```\\n但是，我们现在这个几个粒子都是朝着同一个方向在运动，这可不妙，我们希望每个粒子的运动方向都不一样。所以我们需要一个根据 `i` 产生不同方向的 “**随机函数**”。这里我为大家提供一个函数。\\n\\n```c\\nvec2 Hash12(float f) {\\n    float a = fract(sin(f * 3456.12) * 7529.12);\\n    float b = fract(sin(a + f * 123.789) * 2346.67);\\n    return vec2(a, b);\\n}\\n\\n```\\n该函数与其说是一个 “随机函数”，不如说是一个哈希函数，因为它并不是真正意思上的随机，它所起到的作用其实就是只要输入值有一点点的变化，输出的结果就会有很大的差异。\\n\\n所以该函数的一个接受一个浮点数，输出一个2维向量的哈希函数。\\n\\n通常的做法就是使用三角函数，再乘以一个很大的值，最后取它的小数部分。这里需要读者好好体会一番。\\n\\n有了这个函数我们可以改写我们 `for` 循环中的部分：\\n\\n```c\\nfor(float i = 0.0; i < 50.0; i++) {\\n    vec2 dir = Hash12(i + 1.0) - 0.5;\\n    vec2 p = uv - dir * t;\\n    float d = length(p);\\n    col += 0.0005 / d;\\n}\\n```\\n结果如下：\\n\\n![20230109-212937.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94aa2c468626456f9f8f18ce0eeba4fa~tplv-k3u1fbpfcp-watermark.image?)\\n\\n看起来不错。。。But，这个烟花的造型似乎是……呃呃呃，有点***方***？？Excuse me?(问号❓脸)\\n\\n这是因为我们使用的是直角坐标系，要修正这个问题，我们需要先随机产生极坐标系的坐标，然后将极坐标系转化为直角坐标系。\\n\\n我们修改一下我们的**哈希函数**，并修改`for`循环中的内容\\n\\n```c\\nvec2 Hash12Polar(float f) {\\n    float rad = fract(sin(f * 3456.12) * 7529.12) * 3.1415926 * 2.0;\\n    float r = fract(sin((rad + f) * 714.57) * 567.234);\\n\\n    float x = cos(rad);\\n    float y = sin(rad);\\n    return vec2(x, y) * r;\\n}\\n\\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\\n    vec2 uv = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\\n    vec3 col = vec3(0.0);\\n\\n    float t = fract(iTime);\\n    for(float i = 0.0; i < 50.0; i++) {\\n        vec2 dir = Hash12(i + 1.0) - 0.5;\\n        vec2 p = uv - dir * t;\\n        float d = length(p);\\n        col += 0.0005 / d;\\n    }\\n\\n    fragColor = vec4(col, 1.0);\\n}\\n```\\n\\n结果如下：这下好像不错了诶。\\n![20230109-212548.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fae3db096099458391f2b59d07e061c0~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## Boom! 艺术就是爆炸！\\n现在我们的粒子能够正常的炸开！但是似乎……缺少了一点视觉上的冲击感？\\n\\n我们期望这个烟花能够爆炸的更加激烈一些。现在的烟花似乎不够亮，众所周知，烟花爆炸的那一瞬间是非常的耀眼，宛如一瞬即逝的艺术。\\n\\n所以，不如让我们把烟花调亮一点？我们引入一个新的变量`brightness`来表示亮度\\n\\n```c\\nfloat brightness = 0.005;\\ncol += brightness / d;\\n```\\n这下够亮！\\n\\n![20230109213829_rec_.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8904636c6ad44d279a130f8f16453ba5~tplv-k3u1fbpfcp-watermark.image?)\\n\\n接下来我们要控制一下这个亮度的时间，我们要让这种艺术消失于一瞬之间。 我们先来看一下代码吧。\\n\\n```c\\nfloat minBrightness = 0.001;\\nfloat maxBrightness = 0.005;\\nfloat brightness = mix(maxBrightness, minBrightness, smoothstep(0.0, 0.05, t));\\ncol += brightness / d;\\n```\\n\\n我们先声明了两个变量来分别表示最小的亮度和最大的亮度。然后我们想要的效果是在很短的时间内，最大的亮度就衰减到最小值。\\n\\n**从最大值变为最小值(衰减的过程)**，我们可以使用 `mix` 函数。此处再稍微啰嗦一点，`mix` 函数的作用是在两个值之间进行线性插值，它等价于：\\n\\n```js\\nfunction mix(lower, upper, p) {\\n    return lower * (1 - p) + upper * p;\\n}\\n```\\n而**快速的让时间变化**，我们需要使用到 `smoothstep` 函数，该函数可以将值分为三个部分。\\n\\n`smoothstep(a, b, x)` 它接受3个参数。分为两种情况：\\n1. if a < b:\\n    \\n    x < a时，x = 0; x > b时，x = 1; 否则它在 a, b之间进行线性插值，结果在 0 ~ 1之间\\n    \\n2. if a > b:\\n    x > a时，x = 0; x < b时，x = 1; 否则它在 a, b之间进行线性插值，结果在 0 ~ 1之间\\n    \\n这里需要多加体会一下。如果你现在不懂就暂时先接着往下看吧。\\n\\n通过刚刚的一番操作，我们可以得到这样的结果（此处由于gif图帧率不足无法展示爆炸💥效果，就先不放图了，最后看代码吧。）\\n\\n现在我们完成了单个爆炸效果，我们可以使用一个函数将其封装起来，以提高代码的可读性。\\n\\n```c\\nfloat Explosion(vec2 uv, float t) {\\n    float m = 0.0;\\n    for(float i = 0.0; i < 50.0; i++) {\\n        vec2 dir = Hash12Polar(i + 1.0) * 0.5;\\n        vec2 p = uv - dir * t;\\n        float d = length(p);\\n        float minBrightness = 0.001;\\n        float maxBrightness = 0.005;\\n        float brightness = mix(maxBrightness, minBrightness, smoothstep(0.0, 0.05, t));\\n        m += brightness / d;\\n    }\\n    return m;\\n}\\n```\\n\\n## 更多的烟花！\\n\\n与创建多个粒子来表示烟花类似的，我们可以通过`for` 循环来创建多个烟花！\\n\\n```c\\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\\n    vec2 uv = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\\n    vec3 col = vec3(0.0);\\n\\n    float t = fract(iTime);\\n    for (float i = 0.0; i < 5.0; i++) {\\n        vec2 offs = Hash12(i + 1.0) - 0.5;\\n        col += Explosion(uv - offs, t);\\n    }\\n    \\n    fragColor = vec4(col, 1.0);\\n}\\n```\\n![20230109-215904.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1af857a47594a38a860c53808275fd8~tplv-k3u1fbpfcp-watermark.image?)\\n\\n现在，我们拥有多个烟花啦~ 但是他们都是一起爆炸的，我们想要他们爆炸的时间有点参差感。\\n\\n所以，我们需要将时间 `t` 放到 `for` 循环里面去。并且，我们也想要让爆炸的位置随着时间变化，所以我们也需要将我们的时间`t` 传入到哈希函数中。\\n\\n```c\\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\\n    vec2 uv = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\\n    vec3 col = vec3(0.0);\\n\\n    \\n    for (float i = 0.0; i < 5.0; i++) {\\n        float t = iTime + i / 5.0;\\n        float ft = floor(t); // 这里的floor表示向下取整，可以理解为是每一个烟花的id\\n        vec2 offs = Hash12(i + 1.0 + ft * 0.1) - 0.5;\\n        col += Explosion(uv - offs, fract(t));\\n    }\\n    \\n    fragColor = vec4(col, 1.0);\\n}\\n```\\n结果如下：\\n\\n![20230109220710_rec_.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3fde686f76ab48c0b9780c2287c75274~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## 绽放更加美丽的色彩吧！\\n我们快要大功告成了，最后只需要修改它们的颜色就完成啦~！\\n```c\\n\\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\\n    vec2 uv = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\\n    vec3 col = vec3(0.0);\\n\\n    \\n    for (float i = 0.0; i < 5.0; i++) {\\n        float t = iTime + i / 5.0;\\n        float ft = floor(t);\\n        vec2 offs = Hash12(i + 1.0 + ft * 0.1) - 0.5;\\n        vec3 color = sin(i + ft * vec3(.34, .56, .78)) * 0.25 + 0.75;\\n        col += Explosion(uv - offs, fract(t)) * color;\\n    }\\n    \\n    fragColor = vec4(col, 1.0);\\n}\\n```\\n结果如下啦~\\n\\n![20230109221029_rec_.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/674695a4d62f4484a596c39261988d5f~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n### 最终代码如下\\n[jcode](https://code.juejin.cn/pen/7186655381601878054)\\n\\n\\n\\n# 总结\\n\\n今天我们的烟花盛宴就到此为止啦~ 想必大家都学会了吧。如果没学会也没关系，再仔细的品读上面的文章，相信这个春天你也能开出最绚烂的花~ \\n\\n# 补充\\n\\n等等，明明文章开头说的是放兔子烟花，你倒是教教我们怎么放兔子烟花呢？ 其实这个就比较简单与繁琐了。\\n\\n说它繁琐呢 是因为兔子的轮廓需要我们自己想办法表示出来（这一块就留给大家自行解决了哈）\\n\\n说它简单呢 是因为我们只需要将我们获得的数据 “硬编码” 到我们的程序中就可以了。\\n\\n比如说这样，下面是我自己录的数据\\n\\n```c\\n\\nfloat Explosion(vec2 uv, float t) {\\n    float spark = 0.0;\\n    vec2 points[69];\\n    points[0] = vec2(-0.109375, 0.13828125000000002);\\n    points[1] = vec2(-0.11666666666666664, 0.19765624999999998);\\n    points[2] = vec2(-0.12395833333333334, 0.24765625000000002);\\n    points[3] = vec2(-0.12395833333333334, 0.30078125);\\n    points[4] = vec2(-0.11562499999999998, 0.35234374999999996);\\n    points[5] = vec2(-0.10312500000000002, 0.40234375);\\n    points[6] = vec2(-0.08229166666666665, 0.43671875000000004);\\n    points[7] = vec2(-0.052083333333333315, 0.44765625);\\n    points[8] = vec2(-0.02395833333333336, 0.42578125);\\n    points[9] = vec2(-0.016666666666666663, 0.38203125000000004);\\n    points[10] = vec2(-0.00833333333333336, 0.32734375000000004);\\n    points[11] = vec2(-0.00833333333333336, 0.27109375);\\n    points[12] = vec2(-0.010416666666666685, 0.22734374999999996);\\n    points[13] = vec2(-0.013541666666666674, 0.16953125000000002);\\n    points[14] = vec2(0.008333333333333304, 0.16484374999999996);\\n    points[15] = vec2(0.009375000000000022, 0.21015625000000004);\\n    points[16] = vec2(0.012499999999999956, 0.26328125);\\n    points[17] = vec2(0.018750000000000044, 0.31171875000000004);\\n    points[18] = vec2(0.028124999999999956, 0.36015624999999996);\\n    points[19] = vec2(0.03749999999999998, 0.39296875);\\n    points[20] = vec2(0.055208333333333304, 0.42734375);\\n    points[21] = vec2(0.08229166666666665, 0.44453125000000004);\\n    points[22] = vec2(0.10729166666666667, 0.43515625);\\n    points[23] = vec2(0.125, 0.38828125);\\n    points[24] = vec2(0.13124999999999998, 0.33359375);\\n    points[25] = vec2(0.13020833333333337, 0.28046875000000004);\\n    points[26] = vec2(0.12395833333333328, 0.23671874999999998);\\n    points[27] = vec2(0.1177083333333333, 0.19609374999999996);\\n    points[28] = vec2(0.10520833333333335, 0.15546875000000004);\\n    points[29] = vec2(0.11979166666666663, 0.13359374999999996);\\n    points[30] = vec2(0.1479166666666667, 0.10234374999999996);\\n    points[31] = vec2(0.16562500000000002, 0.06640625);\\n    points[32] = vec2(0.17604166666666665, 0.024218749999999956);\\n    points[33] = vec2(0.18437499999999996, -0.025781249999999978);\\n    points[34] = vec2(0.18541666666666667, -0.07265624999999998);\\n    points[35] = vec2(0.17395833333333333, -0.11953124999999998);\\n    points[36] = vec2(0.14166666666666672, -0.20703125);\\n    points[37] = vec2(0.11145833333333333, -0.23203125000000002);\\n    points[38] = vec2(0.08125000000000004, -0.25390625);\\n    points[39] = vec2(0.048958333333333326, -0.26328125);\\n    points[40] = vec2(0.007291666666666696, -0.26640625);\\n    points[41] = vec2(-0.04583333333333334, -0.26171875);\\n    points[42] = vec2(-0.08437499999999998, -0.24921875);\\n    points[43] = vec2(-0.11249999999999999, -0.23203125000000002);\\n    points[44] = vec2(-0.13854166666666667, -0.20390625);\\n    points[45] = vec2(-0.16249999999999998, -0.16015625);\\n    points[46] = vec2(-0.17708333333333331, -0.11328125);\\n    points[47] = vec2(-0.18333333333333335, -0.05390624999999999);\\n    points[48] = vec2(-0.17812499999999998, 0.00390625);\\n    points[49] = vec2(-0.16666666666666669, 0.04921874999999998);\\n    points[50] = vec2(-0.14895833333333336, 0.08671874999999996);\\n    points[51] = vec2(-0.12708333333333333, 0.11640625000000004);\\n    points[52] = vec2(-0.08750000000000002, -0.07265624999999998);\\n    points[53] = vec2(-0.09791666666666665, -0.08984375);\\n    points[54] = vec2(-0.08854166666666669, -0.11015625000000001);\\n    points[55] = vec2(-0.078125, -0.09609374999999998);\\n    points[56] = vec2(0.08750000000000002, -0.09453125000000001);\\n    points[57] = vec2(0.09375, -0.07890625000000001);\\n    points[58] = vec2(0.10312500000000002, -0.09609374999999998);\\n    points[59] = vec2(0.09583333333333333, -0.11171874999999998);\\n    points[60] = vec2(-0.020833333333333315, -0.18671875);\\n    points[61] = vec2(-0.00833333333333336, -0.19609375);\\n    points[62] = vec2(0.0010416666666667185, -0.20546874999999998);\\n    points[63] = vec2(0.013541666666666674, -0.21953125);\\n    points[64] = vec2(0.019791666666666652, -0.18671875);\\n    points[65] = vec2(0.01041666666666663, -0.19453125);\\n    points[66] = vec2(-0.011458333333333348, -0.20703125);\\n    points[67] = vec2(-0.027083333333333348, -0.21640625000000002);\\n    points[68] = vec2(0.15937500000000004, -0.1679687);\\n    for(int i = 0; i < 69; i++) {\\n        points[i].y /= (960. / 640.);\\n        vec2 dir = points[i] * 0.8;\\n        float d = length(uv - dir * t);\\n        float fi = float(i);\\n        float brightness = mix(0.001, 0.005, smoothstep(0.05, 0.0, t));\\n        brightness *= (sin(t * 20. + fi * 68.)) * 0.5 + .5;\\n        brightness *= smoothstep(1.0, 0.75, t);\\n        spark += brightness / d;\\n\\n    }\\n    return spark;\\n}\\n```\\n一只只可爱的小兔子就出现啦~！\\n\\n![20230112140915_rec_.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a112e905f0143248bbbba34459658ab~tplv-k3u1fbpfcp-watermark.image?)"
    },
    {
        "article_id": "7189535902375346234",
        "cover_image": "",
        "title": "[CleanArchitecture] Google官方的Nowinandroid是如何抽出抽象层(Domain Layer)的",
        "brief": "Google官方的安卓应用Nowinandroid使用了目前很主流的技术，其中在架构分层方面使用到了干净架构即CleanArchitecture，本文主要学习Google是如何抽出抽象层的。",
        "user_name": "linversion",
        "view_count": 595,
        "collect_count": 3,
        "comment_count": 1,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/3f5df8e4eb73472bbc61545c3dbbb166~300x300.image",
        "category": "Android",
        "content": "Google官方的安卓应用Nowinandroid使用了目前很主流的技术，其中在架构分层方面使用到了干净架构即CleanArchitecture，该架构配合MVVM模式可以大大提升可读性、拓展性以及可移植性，本文主要学习Google是如何抽出抽象层的。\\n\\n*补充：干净架构的分层如下*\\n\\n[![pS1W9df.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f60daabc4d9a4f4a9ccec66d280d3ed0~tplv-k3u1fbpfcp-zoom-1.image)](https://imgse.com/i/pS1W9df)\\n\\n随着业务的不断迭代，工程会变得越来越庞大，这时候引入抽象层是很有必要的，抽象层负责管理app中的业务逻辑，除了提升可读性外，还可以将多个地方共用的逻辑抽取并封装成usecases，便于在多个ViewModel中使用。\\n\\n## 什么是Use case?\\n\\nUse case意思为用例，一般来说就是函数（也可以是一个class，内部只有一个简单的public method），一个用例代表一个逻辑或者操作，用例执行后会组合或者拉取Data Layer、其它用例的数据，比如读取用户数据即可作为一个用例。\\n\\n用例的命名一般按照逻辑名_UseCase的格式，便于阅读理解，google使用的是动词+名词+UseCase格式，如：\\n```kotlin\\nclass GetUserNewsResourcesUseCase @Inject constructor(\\n    private val newsRepository: NewsRepository,\\n    private val userDataRepository: UserDataRepository\\n) {\\n    /**\\n     * Returns a list of UserNewsResources which match the supplied set of topic ids.\\n     *\\n     * @param filterTopicIds - A set of topic ids used to filter the list of news resources. If\\n     * this is empty the list of news resources will not be filtered.\\n     */\\n    operator fun invoke(\\n        filterTopicIds: Set<String> = emptySet()\\n    ): Flow<List<UserNewsResource>> =\\n        if (filterTopicIds.isEmpty()) {\\n            newsRepository.getNewsResources()\\n        } else {\\n            newsRepository.getNewsResources(filterTopicIds = filterTopicIds)\\n        }.mapToUserNewsResources(userDataRepository.userData)\\n}\\n```\\n可以看到该GetUserNewsResourcesUseCase是一个class，重写了其invoke方法，invoke方法会返回用例执行后的返回值，除此之外没有其它方法。\\n\\n## 抽取出抽象层的流程\\n总体可以分享为以下几步：\\n\\n1. 找出ViewModel中复杂的和重复的业务逻辑\\n2. 创建对应逻辑的use cases\\n3. 将逻辑移动到use cases\\n4. 重构ViewModel，构建的时候传入的是use cases而不是repositories\\n5. 编写use cases的单元测试\\n\\n\\n- **找出ViewModel中复杂的和重复的业务逻辑**  \\nNowinandroid的app分为三个大模块：For you、Saved(Bookmarks)、Interests，对应三个tab页面，它们的ViewModel中的业务逻辑如下图所示：  \\n[![pS14kWD.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7296709d45ec4cf8bcd42a426c023784~tplv-k3u1fbpfcp-zoom-1.image)](https://imgse.com/i/pS14kWD)    \\n可以看到在observes栏有很多相同颜色的逻辑，为了逻辑复用，直接将相同的逻辑抽出来封装成use case(Candidate UseCase栏)，可以使得ViewModel更简洁明了。\\n\\n- **将逻辑移动到use cases，重构ViewModel**  \\nBookmarksVM、ForYouVM、TopicVM都用到了相同的UseCase-GetSavableNewsResourcesUseCase，来看下这个UseCase怎么封装。  \\n\\n```kotlin\\n    class GetUserNewsResourcesUseCase @Inject constructor(\\n        private val newsRepository: NewsRepository,\\n        private val userDataRepository: UserDataRepository\\n    ) {\\n        /**\\n         * Returns a list of UserNewsResources which match the supplied set of topic ids.\\n         *\\n         * @param filterTopicIds - A set of topic ids used to filter the list of news resources. If\\n         * this is empty the list of news resources will not be filtered.\\n         */\\n        operator fun invoke(\\n            filterTopicIds: Set<String> = emptySet()\\n        ): Flow<List<UserNewsResource>> =\\n            if (filterTopicIds.isEmpty()) {\\n                newsRepository.getNewsResources()\\n            } else {\\n                newsRepository.getNewsResources(filterTopicIds = filterTopicIds)\\n            }.mapToUserNewsResources(userDataRepository.userData)\\n    }\\n\\n\\n    private fun Flow<List<NewsResource>>.mapToUserNewsResources(\\n        userDataStream: Flow<UserData>\\n    ): Flow<List<UserNewsResource>> =\\n        filterNot { it.isEmpty() }\\n            .combine(userDataStream) { newsResources, userData ->\\n                //组合数据源\\n                newsResources.mapToUserNewsResources(userData)\\n            }\\n\\n```\\n很简单，构造的时候传入了多个数据源Repository，用例执行的时候将多个数据源的数据组合起来并返回，现在BookmarksVM中的逻辑就很简单明了了，执行用例拿到数据做筛选并转换成热流给UI层使用，其它使用到相同逻辑的ViewModel也是如此。\\n  ```kotlin\\n    @HiltViewModel\\n    class BookmarksViewModel @Inject constructor(\\n        private val userDataRepository: UserDataRepository,\\n        getSaveableNewsResources: GetUserNewsResourcesUseCase\\n    ) : ViewModel() {\\n\\n        val feedUiState: StateFlow<NewsFeedUiState> = getSaveableNewsResources() //执行用例\\n            .filterNot { it.isEmpty() }\\n            .map { newsResources -> newsResources.filter(UserNewsResource::isSaved) } // Only show bookmarked news resources.\\n            .map<List<UserNewsResource>, NewsFeedUiState>(NewsFeedUiState::Success)\\n            .onStart { emit(Loading) }\\n            .stateIn(\\n                //转换成StateFlow\\n                scope = viewModelScope,\\n                started = SharingStarted.WhileSubscribed(5_000),\\n                initialValue = Loading\\n            )\\n\\n        fun removeFromSavedResources(newsResourceId: String) {\\n            viewModelScope.launch {\\n                userDataRepository.updateNewsResourceBookmark(newsResourceId, false)\\n            }\\n        }\\n    }\\n  ```\\n- **抽象层代码单独存放在一个module**   \\n[![pS153Ax.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/473100f5919c461faf29bc50ffb5b370~tplv-k3u1fbpfcp-zoom-1.image)](https://imgse.com/i/pS153Ax)  \\n可以看到module里面主要是包含usecases和model，这里的model类代表用例执行后的结果，如果你的用例返回结果结合了多个数据源，那么model类即是做一个结果封装，反之如果用例的数据来源是单一的，那么它使用到的model结构其实跟data层的结构是一样的，但为了保持接结构分层，一般也会单独建一个model。\\n\\n- **编写UseCase的单元测试**  \\n一个工程有了好的代码分层还不够，单元测试也是很重要的，UseCase作为一个逻辑用例，编写代码的时候要关注是否是可测试的，其中有一点比较重要的原则是：单一职责原则，即所测试单元的职责是单一的(如只进行数据的拉取结合操作)，并不负责创建数据源repository，数据源由构建函数传入，这样保证了数据源是可以mock的。\\n    ```kotlin\\n    class GetUserNewsResourcesUseCaseTest {\\n\\n        @get:Rule\\n        val mainDispatcherRule = MainDispatcherRule()\\n\\n        private val newsRepository = TestNewsRepository()\\n        private val userDataRepository = TestUserDataRepository()\\n\\n        val useCase = GetUserNewsResourcesUseCase(newsRepository, userDataRepository)\\n\\n        @Test\\n        fun whenNoFilters_allNewsResourcesAreReturned() = runTest {\\n\\n            // Obtain the user news resources stream.\\n            val userNewsResources = useCase()\\n\\n            // Send some news resources and user data into the data repositories.\\n            newsRepository.sendNewsResources(sampleNewsResources)\\n\\n            // Construct the test user data with bookmarks and followed topics.\\n            val userData = emptyUserData.copy(\\n                bookmarkedNewsResources = setOf(sampleNewsResources[0].id, sampleNewsResources[2].id),\\n                followedTopics = setOf(sampleTopic1.id)\\n            )\\n\\n            userDataRepository.setUserData(userData)\\n\\n            // Check that the correct news resources are returned with their bookmarked state.\\n            assertEquals(\\n                sampleNewsResources.mapToUserNewsResources(userData),\\n                userNewsResources.first()\\n            )\\n        }\\n    }\\n    ```\\n    关于Flow的单元测试可以参考我的另一篇文章：([ViewModel中的StateFlow和SharedFlow，使用建议以及单元测试 - 掘金 (juejin.cn)](https://juejin.cn/post/7189176023362043965))\\n    \\n## 总结\\n- 抽象层单独放到一个module，里面存放用例（usecase）以及model\\n- usecase代表一个业务逻辑，一般是一个函数或者只有invoke方法的类，执行后返回结果\\n- 抽取抽象层的步骤一般为：找出ViewModel中复杂的和重复的业务逻辑，将逻辑移到usecase里，ViewModel构建的时候传入usecase"
    },
    {
        "article_id": "7189860636661121084",
        "cover_image": "",
        "title": "GitHub Actions 自动部署前端 Vue 项目",
        "brief": "一. 概述 作为前端技术人员，如果要部署一个项目大体要经过：代码开发、代码推送、打包dist文件、scp到服务器、服务器nginx配置、完成部署这几个流程，现实中我们希望项目部署尽可能自动且简单，因此",
        "user_name": "小样的",
        "view_count": 1541,
        "collect_count": 3,
        "comment_count": 1,
        "avatar": "https://p26-passport.byteacctimg.com/img/mosaic-legacy/3795/3033762272~300x300.image",
        "category": "前端",
        "content": "### 一. 概述\\n\\n作为前端技术人员，如果要部署一个项目大体要经过：`代码开发`、`代码推送`、`打包dist文件`、`scp到服务器`、`服务器nginx配置`、`完成部署`这几个流程，现实中我们希望项目部署尽可能自动且简单，因此诞生了各种`CI/CD`工具，比如：`Jenkins`、`gitlab ci`、`gitlab runner`等，其实我们最熟悉的 `GitHub` 也提供了`CI/CD` 的能力：`GitHub Actions`,它于2019年11月正式发布，现已经支持多种的语言和框架：**Node.js, Python, Java, PHP, Ruby, Go, Rust, C/C++, .NET, Android, iOS**.当然在利用`GitHub Actions`自动部署项目之前，先要利用`GitHub Pages`来发布我们的前端项目。\\n\\n### 二. GitHub Pages\\n\\n![github pages](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a15dddb566e45eda6068f43adfc1a5c~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n什么是 `GitHub Pages`？官网的介绍：**Websites for you and your projects.Hosted directly from your GitHub repository. Just edit, push, and your changes are live.** 说的很明确了，可以利用它,将我们托管在 `GitHub` 仓库的项目部署为一个可以对外访问的网站，免去了我们自己购买与配置服务器的麻烦。\\n\\n-   **首先创建一个项目**，以Vue项目为例，利用 Vue 脚手架创建一个项目\\n\\n```\\nnpm init vue@latest\\n复制代码\\n```\\n\\n这里假设你已经熟悉了 Vue 项目创建，如果不熟悉Vue可以去[查看](https://link.juejin.cn?target=https%3A%2F%2Fcn.vuejs.org%2Fguide%2Fquick-start.html%23creating-a-vue-application \\\"https://cn.vuejs.org/guide/quick-start.html#creating-a-vue-application\\\") 执行如下命令：\\n\\n```\\n> cd <your-project-name>\\n> npm install\\n> npm run dev\\n复制代码\\n```\\n\\n运行后在浏览器中打开本地地址，得到如下页面： ![vue](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d930e2e8189f402a9b890ea7e716e2d7~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n-   **在`GitHub`上创建一个新的`Repository`,将项目上传到`GitHub`仓库**\\n\\n```\\ngit init\\ngit add .\\ngit commit -m \\\"备注信息\\\"\\ngit remote add origin 你的远程仓库地址\\ngit push -u origin master\\n复制代码\\n```\\n\\n-   **配置 `GitHub Actions`** 回到`GitHub`,点击`Setting`->`Pages`，看到如下界面 ![github](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bdb972084e4b49ea92be282ae64f6e27~tplv-k3u1fbpfcp-zoom-1.image) ![github](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6067285c18304bf6915d3a31beb3da0d~tplv-k3u1fbpfcp-zoom-1.image) 并没有展示网址，别急！此时还需要我们去新建一个名为**gh-pages**的分支，创建完成后再次打开`Pages`，可以看到页面发生了变化 ![github](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/070588cec27649b39a30184964044e09~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n> **Source**: 选择`Deploy from a branch`, **Branch**：`github pages` 默认只能识别项目根目录的 `index` 文件，我们这里选择新建的`gh-pages`的`root`根目录，意思是去这个分支的根目录加载`index.html`文件.\\n\\n-   **打包应用，并发布到 `gh-pages` 分支** 打包应用，执行`npm run build` ，在项目根目录下得到打包后的产物`dist`文件夹,\\n\\n    ![截屏2022-11-18 17.53.12](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6166985f3aee4a3ab456f666875497a2~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n    切换当前分支到`gh-pages`,并且将原有内容全部删除, 最后将`dist`文件夹下的内容全部拷贝到`gh-pages`上，push到远端.\\n\\n    ![pic](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b090eabafbb341aa8a6eaf5cdb689b1b~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n再次点击`Setting`->`Pages` ,稍等一会儿，下面出现了一个网址,这就是项目线上地址 ![pci1](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/312d7892e7c14d209d8c8c9e9d5a5134~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n-   **遇到问题** 点击查看网址，并没有像我们预期的那样展示页面，而是一片空白。打开调试版查看错误信息： ![pic02](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/655d645b03314e16a7398f24b03c73ef~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n如果有项目部署经验的一看就知道是怎么回事了，这是打包编译后的文件路径配置有问题，资源文件`css`、`js`，加载的路径地址不对，加载的是根路径 `https://<用户名>.github.io/assets/index.bf782a5b.js`,而我们的资源文件在`/vue-pages/`目录下，所以当然报错`404`，修复也很简单，如果你的Vue项目是基于 Vite 的构建的，需要修改`vite.config.js`，添加`base:'./'`\\n\\n```\\nexport default defineConfig({\\n  plugins: [vue(), vueJsx()],\\n  base:'./',// 将根路径换成相对路径\\n  resolve: {\\n    alias: {\\n      \\\"@\\\": fileURLToPath(new URL(\\\"./src\\\", import.meta.url)),\\n    },\\n  },\\n})\\n复制代码\\n```\\n\\n如果是基于`webpack`构建，修改`vue.config.js`添加`publicPath: './'`.\\n\\n```\\nmodule.exports = {\\n  /**\\n   * publicPath 默认是 / 是根路径，这个是指服务的根路径：https://xxx.github.io/，发布后会从这个路径下找 js.css 等资源，而生成的网站路径是这个 https://xxx.github.io/Vue-Element/，显然是找不到的\\n   * 我们需要修改为 相对路径'./' 或是‘.’ 或是 直接设置的项目子路径 :/项目名称/ 就可找到资源了\\n   */\\n  publicPath: './',\\n  outputDir: 'dist', // dist\\n  assetsDir: 'static',\\n  lintOnSave: process.env.NODE_ENV === 'development',\\n  productionSourceMap: false,\\n...\\n复制代码\\n```\\n\\n重新打包，将`dist`文件夹下内容拷贝到`gh-pages`分支下，并重新打开`pages`链接：`https://<用户名>.github.io/vue-pages/` 成功部署！\\n\\n> 每一次修改后都要重新打包，切换分支拷贝dist文件夹，实属麻烦，能不能让`GitHub`自动检测`push`动作,自动进行打包部署吗？那就是`GitHub Actions`的工作了.\\n\\n### 三. GitHub Actions\\n\\n#### 什么是`GitHub Actions`?\\n\\n`GitHub Actions`是`GitHub`推出的一款持续集成**（CI/CD）**服务，它给我们提供了虚拟的服务器资源，让我们可以基于它完成自动化测试、集成、部署等操作。这里简单介绍一下它的几个基本概念，更多内容可以去官网[查看](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ffeatures%2Factions \\\"https://github.com/features/actions\\\")\\n\\n#### 基本概念\\n\\n-   `Workflows（工作流程）` 持续集成的运行过程称为一次工作流程，也就是我们项目开始自动化部署到部署结束的这一段过程可以称为工作流程.\\n-   `job （任务）` 一个工作流程中包含多个任务，简单来说就是一次自动部署的过程需要完成一个或多个任务.\\n-   `step（步骤）` 部署项目需要按照一个一个的步骤来进行，每个`job`由多个`step`构成.\\n-   `action（动作）` 每个步骤`step`可以包含一个或多个动作，比如我们在一个步骤中执行打包命令这个Action.\\n\\n#### 语法简介\\n\\n-   **name** `name`字段是`workflow`的名称。如果省略该字段，默认为当前`workflow`的文件名.\\n\\n```\\nname: GitHub CI\\n复制代码\\n```\\n\\n-   **on** `on`字段指定触发`workflow`的条件，通常是某些事件,比如代码推送`push`,拉取`pull_request`,可以是事件的数组.\\n\\n```\\non: push\\nor\\non: [push, pull_request]\\n复制代码\\n```\\n\\n指定触发事件时，可以限定分支或标签:\\n\\n```\\non:\\n  push:\\n    branches:    \\n      - master\\n复制代码\\n```\\n\\n上面代码表示：只有`master`分支发生`push`事件时，才会触发`workflow`.\\n\\n-   **jobs** `workflow`的核心就是`jobs`，任务`job`放在`jobs`这个集合下，每一个`job`都有`job_id`，用`job_id`标识一个具体任务\\n-   `jobs.<job_id>.name` 任务说明\\n\\n```\\njobs:\\n  my_first_job: // job_id\\n    name: My first job \\n  my_second_job:// job_id\\n    name: My second job\\n复制代码\\n```\\n\\n上面的`jobs`字段包含两项任务，`job_id`分别是`my_first_job`和`my_second_job`。\\n\\n-   `jobs.<job_id>.runs-on` `runs-on`字段指定运行所需要的虚拟机环境,它是必填字段。\\n\\n```\\nruns-on: ubuntu-18.04\\n复制代码\\n```\\n\\n`GitHub Actions`给我们提提供的运行环境主要有以下几种： **ubuntu-latest**，**ubuntu-18.04或ubuntu-16.04** **windows-latest，windows-2019或windows-2016** **macOS-latest或macOS-10.14**\\n\\n-   `jobs.<job_id>.steps` 任务步骤，一个`job`可以包含多个步骤，我们需要分为多个步骤来完成这个任务，每个步骤包含下面三个字段：\\n\\n```\\njobs.<job_id>.steps.name：步骤名称。\\njobs.<job_id>.steps.run：该步骤运行的命令或者 action。\\njobs.<job_id>.steps.env：该步骤所需的环境变量。\\n复制代码\\n```\\n\\n#### 使用介绍\\n\\n-   新建.yml文件 点击主页`Actions` -> `New workflow` -> `set up a workflow yourself`，当然你也可以选择一个模板，点击`start commit`则会自动在我们项目目录下新建`.github/workflows/main.yml`文件. ![pic](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0acaf721bc34661b0df0ac53f2621ec~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n整个`workflow`的核心就是`yml`脚本的书写。如果你需要某个`action`，不必自己写复杂的脚本，直接引用他人写好的 `action`即可，整个持续集成过程，就变成了一个`actions`的组合，你可以在`GitHub`的[官方市场](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmarketplace%3Ftype%3Dactions \\\"https://github.com/marketplace?type=actions\\\")，可以搜索到他人提交的`actions`. 下面是我们要自动发布`GitHub pages`所写的脚本：\\n\\n```\\nname: CI Github Pages\\non:\\n  #监听push操作\\n  push:\\n    branches:\\n      - main # 这里只配置了main分支，所以只有推送main分支才会触发以下任务\\njobs:\\n  # 任务ID\\n  build-and-deploy:\\n    # 运行环境\\n    runs-on: ubuntu-latest\\n    # 步骤\\n    steps:\\n      # 官方action，将代码拉取到虚拟机\\n      - name: Checkout  ️ \\n        uses: actions/checkout@v3\\n\\n      - name: Install and Build   # 安装依赖、打包，如果提前已打包好无需这一步\\n        run: |\\n          npm install\\n          npm run build\\n\\n      - name: Deploy   # 部署\\n        uses: JamesIves/github-pages-deploy-action@v4.3.3\\n        with:\\n          branch: gh-pages # 部署后提交到那个分支\\n          folder: dist # 这里填打包好的目录名称\\n复制代码\\n```\\n\\n上面整个`workflow`的说明：\\n\\n-   只有当`main`分支有新的`push`推送时候才会执行整个`workflow`.\\n-   整个`workflow`只有一个`job`,`job_id`是`build-and-deploy`,`name`被省略.\\n-   `job` 有三个`step`： 第一步是`Checkout`,获取源码，使用的`action`是`GitHub`官方的`actions/checkout`.\\n-   第二步：`Install and Build`,执行了两条命令：`npm install`,`npm run build`,分别安装依赖与打包应用.\\n-   第三步：`Deploy` 部署，使用的第三方`action`：`JamesIves/github-pages-deploy-action@v4.3.3`,它有两个参数：分别是`branch`、`folder`，更多关于这个`action`的详情可以去[查看](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmarketplace%2Factions%2Fdeploy-to-github-pages \\\"https://github.com/marketplace/actions/deploy-to-github-pages\\\").\\n\\n> 当点击**`Start commit`**，`GitHub Actions` 会自动运行`workflow`. 修改工程文字欢迎文字：\\n\\n```\\n<HelloWorld msg=\\\"You did it!\\\" />\\n复制代码\\n```\\n\\n改为:\\n\\n```\\n<HelloWorld msg=\\\"GitHub Actions CI Succeed!\\\" />\\n复制代码\\n```\\n\\n`push`可以点击`Actions`查看工作流的运行情况 ![flow1](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb66815d9c6147d1842babdbf25d490a~tplv-k3u1fbpfcp-zoom-1.image) 当这个黄色加载动画变成绿色后表示`workflow`运行完成，看下最终效果： ![flow2](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94b7d0751cd04ba294bd5e69b1ef0c30~tplv-k3u1fbpfcp-zoom-1.image) 达到了自动部署的目的.\\n\\n### 四. 设置`Custom domain`\\n\\n其实经过上面的三步已经可以实现自动部署的目的了，但是还是有点瑕疵。我们部署后的项目地址是：`https://<用户名>.github.io/vue-pages/`,域名还是`GitHub`的,能不能改成我们自己的专属域名呢？比如改成`http://<用户名>.com/`,那就需要设置`Custom domain`了。\\n\\n#### 1. 购买域名\\n\\n如果想将项目地址改成自己的专属域名，首先需要你去购买一个域名，目前[阿里云](https://link.juejin.cn?target=https%3A%2F%2Fwanwang.aliyun.com%2Fdomain%2Fsearchresult%2F \\\"https://wanwang.aliyun.com/domain/searchresult/\\\"),[腾讯云](https://link.juejin.cn?target=https%3A%2F%2Fdnspod.cloud.tencent.com \\\"https://dnspod.cloud.tencent.com\\\")都支持域名的购买，搜索自己喜欢的域名直接付款就好了。 ![domain](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/08d79c0762ff4f339f076a8e17bb3b24~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n#### 2. 购买域名后，还需要我们进行实名认证以及备案，按照平台的提示进行操作就好了，这里不再涉及.\\n\\n#### 3. 进行DNS解析配置\\n\\n这里以阿里云为例，打开域名解析控制台，点击解析按钮 ![pic](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6846fafec449448691ed8c921b1564c0~tplv-k3u1fbpfcp-zoom-1.image) 点击添加记录按钮，将下面两种类型的记录值添加上，记录类型是：`CNAME`，记录值就是你`GitHub`的主域名. ![feak](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f89f6ddb04284696b94ddfd06c9057d1~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n#### 4. 设置`Custom domain`\\n\\n返回到项目的`GitHub pages`设置页面，将我们购买的域名添加在`Custom domain`中，点击`save`，可以看到`pages`的地址变成了我们自己的域名，访问它就会看到你的网站了. ![pic](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e849998812a5464b9d41fa345702cd7a~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n### 五. 小结\\n\\n`GitHub Actions`给我们提供了一站式的自动化部署体验，加上`Custom domain`的设置，完全可以用于搭建我们的个人博客，最重要的是这完全免费. 你也可以用它来部署其他框架的项目，当然这里的重点是的`yml`脚本的书写.\\n\\n一些参考：\\n\\n[pages.github.com](https://link.juejin.cn?target=https%3A%2F%2Fpages.github.com \\\"https://pages.github.com\\\")\\n\\n[github.com/features/ac…](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ffeatures%2Factions \\\"https://github.com/features/actions\\\")\\n\\n[blog.csdn.net/formula1000…](https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fformula10000%2Farticle%2Fdetails%2F98946098 \\\"https://blog.csdn.net/formula10000/article/details/98946098\\\")\\n\\n  \\n"
    },
    {
        "article_id": "7174360917864349732",
        "cover_image": "https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/203670b675544a3591ddd7e1796d2f2e~tplv-k3u1fbpfcp-watermark.image?",
        "title": "卷算法？来我教你怎么吊打面试官💪",
        "brief": "最近两年，行业内卷严重，算法慢慢成为面试的高频问题。本文将列出一份大致的学习路线，全部练完能够应付大多数的面试场景，同时也能提高在高压状态下编程和思考、解决问题的能力。",
        "user_name": "断律绎殇",
        "view_count": 13558,
        "collect_count": 103,
        "comment_count": 15,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/357431725172edb15df0802ab7aaeebd~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: condensed-night-purple\\n---\\n> 作者介绍：断律绎殇（笔名），六年码龄，四年算法竞赛经验（主要是acm和天梯赛），曾获两次省一及其他奖项若干。（避免被杠还是多说几句：以上介绍仅证明本人具有一定算法能力，算不上大佬，比我厉害的人还有很多很多，当初亚洲区域赛清华的队伍坐我们旁边，我们还在讨论题目翻译旁边在讨论晚上吃什么的时候，我就清晰地认识到了自己只是acm打铁蒟蒻）\\n\\n## 前言\\n\\n最近两年，行业内卷严重，算法慢慢成为面试的高频问题。本文将列出一份大致的学习路线，全部练完能够应付大多数的面试场景，同时也能提高在高压状态下编程和思考、解决问题的能力。\\n\\n引用b站大佬CodeSheep的经典名言：\\n\\n**徒手撕源码 光脚造轮子 闭眼深优化 吊打面试官**\\n\\n## 学习的收获\\n1. get新技能-算法能力；\\n2. 追求高性能、低开销解决问题的思维习惯；\\n3. 培养思考问题的全面性，养成少写甚至不写bug的好习惯；\\n4. 其他不可言传的隐性成长...\\n5. 吊打面试官\\n\\n# 学习路线\\n\\n### tips\\n\\n算法学习推荐使用c++语言练习，有其他语言基础学c一般一下午就能学会，后端大佬如果实在不习惯可以使用java。\\n\\n\\n## 模拟、枚举和贪心\\n\\n模拟\\n\\n[P1042 [NOIP2003 普及组] 乒乓球 - 细节](https://www.luogu.com.cn/problem/P1042)\\n\\n[P2670 [NOIP2015 普及组] 扫雷游戏 - 规则](https://www.luogu.com.cn/problem/P2670)\\n\\n[P1563 [NOIP2016 提高组] 玩具谜题 - 记录](https://www.luogu.com.cn/problem/P1563)\\n\\n[P1143 进制转换 - 模拟运算](https://www.luogu.com.cn/problem/P1143)\\n\\n枚举\\n\\n[POJ 1753 Flip Game](http://poj.org/problem?id=1753)\\n\\n[POJ 2965 The Pilots Brothers' refrigerator](http://poj.org/problem?id=2965)\\n\\n贪心\\n\\n[POJ 百练 4151 电影节](http://poj.org/problem?id=4151)\\n\\n[POJ 3190 Stall Reservations](http://poj.org/problem?id=3190)\\n\\n[POJ 1328 Radar Installation](http://poj.org/problem?id=1328)\\n\\n[毒瘤xor （按位贪心）](https://ac.nowcoder.com/acm/problem/18979)\\n\\n## 递归、分治\\n\\n[[NOIP2002 普及组] 选数](https://www.luogu.com.cn/problem/P1036)\\n\\n[[NOIP2002 普及组] 过河卒](https://www.luogu.com.cn/problem/P1002)\\n\\n[[USACO17JAN]Secret Cow Code S](https://www.luogu.com.cn/problem/P3612)\\n\\n\\n## 二分、三分、01分数规划\\n\\n二分查找\\n\\n[NC235558 牛可乐和魔法封印](https://ac.nowcoder.com/acm/problem/235558\\n)\\n\\n二分答案\\n\\n[NC24017 [USACO 2016 Jan S]Angry Cows](https://ac.nowcoder.com/acm/problem/24017)\\n\\n[NC16462 [NOIP2015]跳石头](https://ac.nowcoder.com/acm/problem/16462\\n)\\n\\n三分\\n\\n[NC20276 [SCOI2010]传送带](https://ac.nowcoder.com/acm/problem/20276\\n)\\n\\n01分数规划\\n\\n[NC14662 小咪买东西](https://ac.nowcoder.com/acm/problem/14662\\n)\\n\\n## 栈、队列\\n\\n栈\\n\\n[NC14893 栈和排序](https://ac.nowcoder.com/acm/problem/14893\\n)\\n\\n队列\\n\\n[NC13822 Keep In Line](https://ac.nowcoder.com/acm/problem/13822\\n)\\n\\n双端队列\\n\\n[NC14661 简单的数据结构](https://ac.nowcoder.com/acm/problem/14661\\n)\\n\\n\\n## 并查集\\n\\n[Party](https://www.luogu.com.cn/problem/CF177C1)\\n\\n[炸铁路 - 洛谷](https://www.luogu.com.cn/problem/P1656 \\\"炸铁路 - 洛谷\\\")\\n\\n[[SCOI2005]繁忙的都市 - 洛谷](https://www.luogu.com.cn/problem/P2330 \\\"[SCOI2005]繁忙的都市 - 洛谷\\\")\\n\\n[P1396 营救 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1396 \\\"P1396 营救 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\\\")\\n\\n\\n并查集\\n[NC23803 DongDong认亲戚](https://ac.nowcoder.com/acm/problem/23803)\\n\\n\\n扩展域并查集\\n\\n[食物链](http://poj.org/problem?id=1182)\\n\\n[Mahmoud and a Dictionary](http://codeforces.com/problemset/problem/766/D)\\n\\n## 搜索\\n\\nDFS\\n\\n[NC15128 老子的全排列呢](https://ac.nowcoder.com/acm/problem/15128)\\n\\n[NC235813 N皇后问题](https://ac.nowcoder.com/acm/problem/235813)\\n\\n[NC24739 Lake Counting](https://ac.nowcoder.com/acm/problem/24739)\\n\\nBFS\\n\\n[01迷宫](https://www.luogu.org/problemnew/show/P1141)\\n\\n[NC15136 迷宫](https://ac.nowcoder.com/acm/problem/15136)\\n\\n[NC201613 Jelly](https://ac.nowcoder.com/acm/problem/201613)\\n\\n双向广搜\\n\\n[NC15665 maze](https://ac.nowcoder.com/acm/problem/15665)\\n\\n搜索剪枝\\n\\n[NC16857 [NOI1999]生日蛋糕](https://ac.nowcoder.com/acm/problem/16857)\\n\\n\\n## 递推\\n\\n[NC235911 走楼梯](https://ac.nowcoder.com/acm/problem/235911)\\n\\n线性dp\\n\\n[NC16810 [NOIP1999]拦截导弹](https://ac.nowcoder.com/acm/problem/16810)\\n\\n[NC16664 [NOIP2004]合唱队形](https://ac.nowcoder.com/acm/problem/16664)\\n\\n## 背包问题\\n\\n01背包\\n\\n[P1048 [NOIP2005 普及组] 采药](https://www.luogu.com.cn/problem/P1048)\\n\\n完全背包\\n\\n[NC21467 [NOIP2018]货币系统](https://ac.nowcoder.com/acm/problem/21467)\\n\\n多重背包\\n\\n[NC235950 多重背包](https://ac.nowcoder.com/acm/problem/235950)\\n\\n分组背包\\n\\n[NC16671 [NOIP2006]金明的预算方案](https://ac.nowcoder.com/acm/problem/16671)\\n\\n## DP\\n\\n\\n区间dp\\n\\n[[NOIP2006 提高组] 能量项链](https://www.luogu.com.cn/problem/P1063)\\n\\n[[NOI2009] 二叉查找树](https://www.luogu.com.cn/problem/P1864)\\n\\n树形dp\\n\\n[[ZJOI2007] 时态同步](https://www.luogu.com.cn/problem/P1131 \\\"[ZJOI2007] 时态同步\\\")\\n\\n[[USACO10MAR] Great Cow Gathering G](https://www.luogu.com.cn/problem/P2986)\\n\\n[[USACO08JAN]Cell Phone Network G](https://www.luogu.com.cn/problem/P2899)\\n\\n状压dp\\n\\n[[FJOI2007] 轮状病毒](https://www.luogu.com.cn/problem/P2144)\\n\\n[[ZJOI2017] 树状数组](https://www.luogu.com.cn/problem/P3688)\\n\\n## 图论\\n\\n最短路\\n\\n[【模板】单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)\\n\\n[[SCOI2007]k短路](https://www.luogu.com.cn/problem/P4467)\\n\\n[[JLOI2011] 飞行路线](https://www.luogu.com.cn/problem/P4568)\\n\\n最短路图\\n\\n[NC19987 [HAOI2012]ROAD](https://ac.nowcoder.com/acm/problem/19987)\\n\\n[NC16416 [NOIP2017]逛公园](https://ac.nowcoder.com/acm/problem/16416)\\n\\n差分约束\\n\\n[NC20284 [SCOI2011]糖果](https://ac.nowcoder.com/acm/problem/20284)\\n\\n最小生成树\\n\\n[NC17509 挖沟](https://ac.nowcoder.com/acm/problem/17509)\\n\\n[NC15108 道路建设](https://ac.nowcoder.com/acm/problem/15108)\\n\\n[NC53074 Forsaken喜欢独一无二的树](https://ac.nowcoder.com/acm/problem/53074)\\n\\n\\n## 数论\\n\\n[最接近的分数](https://www.luogu.com.cn/problem/P1298)\\n\\n[NC14399 素数判断](https://ac.nowcoder.com/acm/problem/14399)\\n\\n[NC235228 素数的个数](https://ac.nowcoder.com/acm/problem/235228)\\n\\n[NC16710 最大公约数(lcm)](https://ac.nowcoder.com/acm/problem/16710)\\n\\n[NC23050 华华对月月的忠诚](https://ac.nowcoder.com/acm/problem/23050)\\n\\n### 组合数学：\\n\\n排列组合\\n\\n[[NOIP2011]计算系数](https://ac.nowcoder.com/acm/problem/16596)  \\n\\n[[HAOI2012]容易题](https://ac.nowcoder.com/acm/problem/19989)  \\n\\n[[HAOI2016]放棋子](https://ac.nowcoder.com/acm/problem/19999)  \\n\\n[[SCOI2010]字符串](https://ac.nowcoder.com/acm/problem/20277)\\n\\n容斥\\n\\n[大水题](https://ac.nowcoder.com/acm/problem/15079)  \\n\\n[青蛙](https://ac.nowcoder.com/acm/problem/236191)  \\n\\n[最后的晚餐(dinner)](https://ac.nowcoder.com/acm/problem/19857)\\n\\n\\n线性代数\\n\\n[愉快的递推式](https://ac.nowcoder.com/acm/problem/25354)  \\n\\n[又见斐波那契](https://ac.nowcoder.com/acm/problem/15666)\\n\\n\\n概率题\\n\\n[Happy Running](https://ac.nowcoder.com/acm/problem/15532)  \\n\\n[分蛋糕](https://ac.nowcoder.com/acm/problem/236236)\\n\\n数论分块\\n\\n[因数个数和](https://ac.nowcoder.com/acm/problem/17450) \\n\\n[小G的约数](https://ac.nowcoder.com/acm/problem/218398)  \\n\\n[浅尝辄止](https://ac.nowcoder.com/acm/problem/204916)\\n\\n\\n## 线段树\\n\\n[区区区间](https://ac.nowcoder.com/acm/problem/200195)  \\n\\n[数据结构](https://ac.nowcoder.com/acm/problem/19246)  \\n\\n[整数序列](https://ac.nowcoder.com/acm/problem/17877)  \\n\\n[序列求和](https://ac.nowcoder.com/acm/problem/236242)  \\n\\n[数星星 Stars](https://ac.nowcoder.com/acm/problem/50428)  \\n\\n[[SDOI2015]道路修建 线段树+kruskal](https://ac.nowcoder.com/acm/problem/20380)  \\n\\n[Stars in Your Window](https://ac.nowcoder.com/acm/problem/51112)\\n\\n## 树状数组\\n\\n[华华开始学信息学](https://ac.nowcoder.com/acm/problem/23054)  \\n\\n[[HEOI2012]采花](https://ac.nowcoder.com/acm/problem/20545) \\n\\n[求逆序数](https://ac.nowcoder.com/acm/problem/208813)\\n\\n\\n## LCA模板题\\n\\nDFS序\\n\\n[树（dfs序+区间dp）](https://ac.nowcoder.com/acm/problem/13611)  \\n\\n[求和](https://ac.nowcoder.com/acm/problem/204871)  \\n\\n[Alliances](https://ac.nowcoder.com/acm/problem/13950)  \\n\\n[选点](https://ac.nowcoder.com/acm/problem/22494)  \\n\\n[Colorful Tree](https://ac.nowcoder.com/acm/problem/200179)  \\n\\n[[HAOI2015]树上操作](https://ac.nowcoder.com/acm/problem/19995)\\n\\n### 树上倍增\\n\\n[货车运输](https://ac.nowcoder.com/acm/problem/16527)  \\n\\n[树和序列](https://ac.nowcoder.com/acm/problem/236244)  \\n\\n[牛可乐和公平点](https://ac.nowcoder.com/acm/problem/235654) \\n\\n### 树链剖分\\n\\n[[HAOI2015]树上操作](https://ac.nowcoder.com/acm/problem/19995)  \\n\\n[[ZJOI2008]树的统计COUNT](https://ac.nowcoder.com/acm/problem/20477)  \\n\\n[石子游戏2](https://ac.nowcoder.com/acm/problem/236249)\\n\\n\\n持续更新中...\\n\\n本文正在参加[「金石计划 . 瓜分6万现金大奖」](https://juejin.cn/post/7162096952883019783 \\\"https://juejin.cn/post/7162096952883019783\\\")\\n"
    },
    {
        "article_id": "7189580059399684154",
        "cover_image": "https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7fdeb2e59f2e459b8125b9a5f13184f6~tplv-k3u1fbpfcp-watermark.image?",
        "title": "Vue3源码分析(8)-调度器与watch原理",
        "brief": "本文主要内容 学习Vue3的调度器原理。 了解nextTick的实现、为何在nextTick中可以获取到修改后的DOM属性。 pre、post、和普通任务的执行过程。 watch的实现原理。 调度器 ",
        "user_name": "猪猪爱前端",
        "view_count": 572,
        "collect_count": 2,
        "comment_count": 1,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/bdc95d8ec7a570042b06e2d94aaaf8d4~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: orange\\n---\\n## 本文主要内容\\n- 学习`Vue3`的调度器原理。\\n- 了解`nextTick`的实现、为何在`nextTick`中可以获取到修改后的`DOM属性`。\\n- `pre、post、和普通任务`的执行过程。\\n- `watch`的实现原理。\\n## 调度器\\n### 1.添加任务(queueJobs)\\n- 调度器想要运转需要添加任务到调度器队列当中,我们需要知道`Vue调度器队列`一共有两种,分别为`queue`、`pendingPostFlushCbs`。\\n- `queue`:装载前置任务和普通任务的队列。\\n- `pendingPostFlushCbs`:装载后置任务的队列。\\n\\n下面我们来看看对于前置任务和普通任务添加到`queue`中的函数`queueJobs`。\\n```js\\n//递归:当前父亲正在执行一个任务,在执行任务\\n//期间又添加了一个新的任务,这个新的任务与当前\\n//执行的任务是同一个任务,跳过去重的检验\\n//如果不允许递归,那么任务不会被添加到队列中\\nfunction queueJob(job) {\\n  //job自身允许递归,那么跳过去重检查(只跳过当前执行任务的去重检查)\\n  if (\\n    !queue.length ||\\n    !queue.includes(\\n      job,\\n      isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex\\n    )\\n  ) {\\n    //如果任务没有id代表没有优先级\\n    //放到任务队列的最后面\\n    if (job.id == null) {\\n      queue.push(job);\\n    }\\n    //利用二分法找到任务优先级需要插入的位置\\n    else {\\n      queue.splice(findInsertionIndex(job.id), 0, job);\\n    }\\n    //执行任务\\n    queueFlush();\\n  }\\n}\\n```\\n- 这里我们需要知道一个概念-->`递归`,这里的`递归`是指:当前正在执行的任务和需要添加的任务是同一个任务,如果设置了需要递归`(job.allowRecurse=true)`那么就允许这个任务进入`queue队列`中,否则不允许进入。\\n- `job`:我们还需要知道一个任务的格式。首先`job必须是一个函数`,他还可以具有以下属性。\\n```js\\nconst job = function(){}\\njob.id:Number //用于设置当前任务的优先级越小的值优先级越高。\\njob.allowRecurse:Boolean //是否允许递归。\\njob.pre:Boolean //用于判断是否是前置任务。\\njob.active:Boolean //当前任务是否可以执行。为false在执行阶段跳过执行。\\n```\\n- `queueJobs`执行流程:根据任务的`id(优先级)`利用`二分法`找到需要插入的位置,插入到`queue队列`当中,调用`queueFlush`推入执行任务的函数到微任务队列。\\n\\n### 2.二分法找到插入位置(findInsertionIndex)\\n- 这个函数比较简单,大家看看代码就可以啦！\\n```js\\n//找到插入的位置\\n//例如[1,2,3,8,9,10,100]\\n//当前插入的id为20\\n//插入后应该为[1,2,3,8,9,10,20,100]\\n//也就是说最终返回的start=6\\n//插入流程解析:\\n//1.假设当前执行到第二个任务即flushIndex=2\\n//那么start = 2;end = 7;middle=4;\\n//    middleJobId=9;9<20 start=5;\\n//继续循环:middle=6;middleJobId=100;end=6\\n//结束循环start = 6;这就是需要插入的位置\\nfunction findInsertionIndex(id) {\\n  let start = flushIndex + 1;\\n  let end = queue.length;\\n  while (start < end) {\\n    // 1000>>>1=>100 8=>4\\n    // 1100>>>1=>110 12=>6\\n    // 1010>>>1=>101 10=>5\\n    // 1001>>>1=>100 9=>4\\n    //计算出中间值,向下取整\\n    const middle = (start + end) >>> 1;\\n    //获取job的id\\n    const middleJobId = getId(queue[middle]);\\n    middleJobId < id ? (start = middle + 1) : (end = middle);\\n  }\\n  return start;\\n}\\n\\n//获取当前任务的id\\nconst getId = (job) => (job.id == null ? Infinity : job.id);\\n```\\n### 3.将执行任务的函数推入微任务队列(queueFlush)\\n```js\\nfunction queueFlush() {\\n  //当前没有执行任务且没有任务可执行\\n  if (!isFlushing && !isFlushPending) {\\n    //等待任务执行\\n    isFlushPending = true;\\n    //将flushJobs放入微任务队列\\n    currentFlushPromise = resolvedPromise.then(flushJobs);\\n  }\\n}\\n```\\n- `isFlushing`:判断当前是否正在执行任务。\\n- `isFlushPending`:判断当前是否有等待任务,任务的执行是一个**微任务**,它将会被放到**微任务队列**,那么对于**渲染主线程**来说,当前还没有执行这个微任务,在执行这个微任务之前都属于`等待阶段`。\\n- `queueFlush`执行流程:判断当前是否没有执行任务、且**任务队列**当中没有任务,如果是那么设置当前为`等待阶段`。最后将`flushJobs(执行任务的函数)`推入**微任务队列**。\\n### 4.执行普通任务(flushJobs)\\n```js\\nfunction flushJobs(seen) {\\n  isFlushPending = false; //当前不是等待状态\\n  isFlushing = true; //当前正在执行任务\\n  seen = seen || new Map();\\n  //原文译文:\\n  //在flush之前对queue排序这样做是为了:\\n  //1.组件更新是重父组件到子组件(因为父组件总是在子组件之前创建\\n  //所以父组件的render副作用将会有更低的优先级\\n  //2.如果子组件在父组件更新期间并未挂载,那么可以跳过\\n  queue.sort(comparator);\\n  //监测当前任务是否已经超过了最大递归层数\\n  const check = (job) => checkRecursiveUpdates(seen, job);\\n  try {\\n    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {\\n      const job = queue[flushIndex];\\n      if (job && job.active !== false) {\\n        if (check(job)) {\\n          continue;\\n        }\\n        callWithErrorHandling(job, null, 14);\\n      }\\n    }\\n  } finally {\\n    //执行完所有的任务之后,初始化queue\\n    //调用post任务,这些任务调用完折后\\n    //可能在执行这些任务的途中还有新的\\n    //任务加入所以需要继续执行flushJobs\\n    flushIndex = 0;\\n    queue.length = 0;\\n    flushPostFlushCbs(seen);\\n    isFlushing = false;\\n    currentFlushPromise = null;\\n    if (queue.length || pendingPostFlushCbs.length) {\\n      flushJobs(seen);\\n    }\\n  }\\n}\\n```\\n- `seen`:这是一个`Map`,用于缓存`job`的**执行次数**,如果超过了`RECURSION_LIMIT`的执行次数,将会警用户。\\n- `RECURSION_LIMIT`:`Vue`默认值为`100`。这个值不可以让用户修改(常量值)。\\n- `flushJobs`执行流程:获取`queue`队列中的每一个任务,检测这个任务是否嵌套执行了`100`次以上,超过了则**警告用户**。然后执行当前任务直到`flushIndex === queue.length`。**(queue的长度可能会持续增加)**。调用`flushPostFlushCbs`执行后置队列的任务。\\n- 由于在执行后置队列任务的时候可能又向`queue`中添加了新的任务,那么就需要执行完后置队列后再调用`flushJobs`。\\n\\n### 5.添加后置任务(queuePostFlushCb)\\n```js\\nfunction queuePostFlushCb(cb) {\\n  if (!shared.isArray(cb)) {\\n    if (\\n      !activePostFlushCbs ||\\n      !activePostFlushCbs.includes(\\n        cb,\\n        cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex\\n      )\\n    ) {\\n      pendingPostFlushCbs.push(cb);\\n    }\\n  } else {\\n    pendingPostFlushCbs.push(...cb);\\n  }\\n  queueFlush();\\n}\\n```\\n- 与添加普通任务到队列中一样,添加完成后调用`queueFlush`开启调度。\\n\\n### 6.queuePostRenderEffect\\n```js\\nfunction queueEffectWithSuspense(fn, suspense) {\\n  //对suspense的处理,暂时不详细解释\\n  if (suspense && suspense.pendingBranch) {\\n    if (shared.isArray(fn)) {\\n      suspense.effects.push(...fn);\\n    } else {\\n      suspense.effects.push(fn);\\n    }\\n  } else {\\n    //如果是普通的任务则放入后置队列\\n    queuePostFlushCb(fn);\\n  }\\n}\\n```\\n- 如果传递了`suspense`那么调用`suspense的api`。\\n- 没有传递`suspense`当作一般的**后置任务**即可。\\n\\n### 7.执行后置队列任务(flushPostFlushJobs)\\n```js\\nfunction flushPostFlushCbs(seen) {\\n  if (pendingPostFlushCbs.length) {\\n    //克隆等待执行的pendingPost\\n    const deduped = [...new Set(pendingPostFlushCbs)];\\n    pendingPostFlushCbs.length = 0; //设置为0\\n    //当前函数是后置队列的任务发起的,那么不能\\n    //直接运行任务,而是将任务放到avtivePostFlushCbs任务之后\\n    if (activePostFlushCbs) {\\n      activePostFlushCbs.push(...deduped);\\n      return;\\n    }\\n    activePostFlushCbs = deduped;\\n\\n    seen = seen || new Map();\\n    //排序(post依然有优先级)\\n    activePostFlushCbs.sort((a, b) => getId(a) - getId(b));\\n    for (\\n      postFlushIndex = 0;\\n      postFlushIndex < activePostFlushCbs.length;\\n      postFlushIndex++\\n    ) {\\n      //检测执行深度\\n      if (checkRecursiveUpdates(seen, activePostFlushCbs[postFlushIndex])) {\\n        continue;\\n      }\\n      //调用这个postJob\\n      activePostFlushCbs[postFlushIndex]();\\n    }\\n    //初始化\\n    activePostFlushCbs = null;\\n    postFlushIndex = 0;\\n  }\\n}\\n```\\n- `flushPostFlushCbs`执行流程:和`flushJobs`差不多,拿到`pendingPostFlushCbs`队列中的任务并执行他们,在执行完成后初始化`postFulshIndex指针`。\\n- 之所以后置队列一定会在完成普通任务和前置任务后执行,是因为无论你是通过`queueJobs`添加任务发起调度还是通过`queuePostFlushCb`添加任务发起调度,都总是调用`flushJobs`,而在`flushJobs`的实现中,总是**先清空`queue`队列在执行`pendingPostFlushCbs`**。\\n- `activePostFlushCbs`作用:想象一个场景,如果我直接通过调用`flushPostFlushJobs`发起调度那么任务将不会是异步的,并且会打乱调度器的执行顺序,所以有了这个属性。若当前已经存在了`activePostFlushCbs`表示正在执行后置队列的任务,在任务中调用`flushPostFlushJobs`并不会直接执行,而是会把`pendingPostFlushcbs`中的任务放到`avtivePostFlushCbs`任务的后面。这样就保证了调度器的顺序执行。\\n### 8.执行前置任务队列(flushPreFlushCbs)\\n```js\\nfunction flushPreFlushCbs(seen, i = isFlushing ? flushIndex + 1 : 0) {\\n  seen = seen || new Map();\\n  for (; i < queue.length; i++) {\\n    const cb = queue[i];\\n    if (cb && cb.pre) {\\n      if (checkRecursiveUpdates(seen, cb)) {\\n        continue;\\n      }\\n      queue.splice(i, 1);\\n      i--;\\n      cb();\\n    }\\n  }\\n}\\n```\\n- 添加前置任务的方法:对添加的`任务函数Job`添加`pre属性`。\\n```js\\njob.pre = true\\n```\\n- 这里需要注意,对于前置任务和普通任务都会被添加到`queue`当中,如果调用的`flushJobs`触发任务执行,那么前置任务和普通任务都会被执行。**他们的执行顺序为高优先级的先执行(id小的先执行)。相同优先级的前置任务先执行**。\\n- `flushPreFlushCbs`执行流程:在`queue`中找到带有`pre`属性的任务,执行并在`queue`中删除这个任务。\\n- 对于处于执行后置任务的状态,同时调用了`flushPostFlushCbs`发起后置任务的调度,那么会将新增的任务加到`activePostFlushCbs`中。但是对于前置任务是不需要这么做的,如果通过调用`flushPreFlushCbs`发起调度那么前置任务将会是同步执行。我们来看这样一个例子。\\n```js\\nfunction a(){\\n  console.log(222)\\n}\\nfunction b(){\\n  console.log(111)\\n}\\na.pre = true\\nqueueJobs(a)\\nqueueJobs(b)\\nflushPreFlushCbs()\\n//打印:222 111\\n```\\n- 如何理解呢？首先`a任务`是前置任务,`a、b任务`都被添加到了`queue`队列中,同时发起了调度,但是这是一个**微任务**,而当前执行的任务还未执行完成,所以会先调用`flushPreFlushCbs`。那么就会调用前置任务也就是`a任务`。调用完成后**删除queue队列中的a任务**,此时`queue队列`中只有`b任务`了。然后执行微任务,进一步调用`b任务`。\\n\\n### 9.nextTick\\n- 场景:在修改了响应式数据后,想要获取到**最新DOM**上的数据,**因为只修改了相应式数据,目前DOM还未发生改变所以获取不到改变后的DOM属性**。\\n```js\\n<script> \\nimport { nextTick } from 'vue' \\nexport default {  \\n  data() {   \\n    return { count: 0 } }, \\n    methods: { \\n      async increment() { \\n        this.count++ // DOM 还未更新\\n        // 0\\n        console.log(document.getElementById('counter').textContent)\\n        await nextTick() // DOM 此时已经更新 \\n        console.log(document.getElementById('counter').textContent) // 1 \\n        } \\n     } \\n } \\n </script>\\n <template> \\n   <button id=\\\"counter\\\" @click=\\\"increment\\\">{{ count }}</button> \\n </template>\\n```\\n- `nextTick`实现:\\n```js\\nfunction nextTick(fn) {\\n  const p = currentFlushPromise || resolvedPromise;\\n  return fn ? p.then(this ? fn.bind(this) : fn) : p;\\n}\\n\\n```\\n- `currentFlushPromise`:在调用queueFlush时会创建一个微任务,将flushJobs推入微任务队列。\\n```js\\nfunction queueFlush() {\\n  if (!isFlushing && !isFlushPending) {\\n    isFlushPending = true;\\n    currentFlushPromise = resolvedPromise.then(flushJobs);\\n  }\\n}\\n```\\n- `resolvedPromise`:状态为`fulfilled`的`Promise`。\\n- 如果当前队列中没有任务则`p=resolvedPromise`,直接将`fn`推入**微任务队列**。因为调度器队列中无任务所以**不存在DOM**的更新。\\n- 如果当前队列中有任务则`p=currentFlushPromise`,**若当前正在执行`flushJobs`那么`currentFlushPromise`的状态为`fulfilled`则会将`fn`推入微任务队列,当然前提是`flushJobs`已经执行完才有可能执行`fn`,而只要`flushJobs`执行完毕DOM也已经完成了更新。若当前没有执行`flushJobs`,那么`currentFlushPromise`的状态为`pending`,就不可能将`fn`推入微任务队列。综上就保证了`fn`一定在DOM更新后触发**。\\n\\n## 调度器总结\\n- 调度器的调度队列分为后置队列和普通队列。\\n- 普通队列中包含了前置任务和普通任务。如果通过`flushPreFlushCbs`调用那么前置任务为同步任务。执行完成后删除普通队列中相对应的任务。如果通过`flushJobs`调用,那么调用顺序按照优先级高低排列,相同优先级的前置任务先调用。\\n- 后置队列任务一定在普通队列清空后执行。\\n- 普通任务和后置任务为异步,前置任务可能为同步可能为异步。\\n- 在将任务放入队列当中时就已经自动发起了调度,用户可以不通过手动调用。如果手动调用`flushPostFlushCbs`实际上是将任务放到队列中,而不是重新开启调度。\\n\\n## watch用法\\n- 选项式\\n```js\\n<script>\\nexport default {\\n  watch{\\n    a(){},\\n    b:\\\"meth\\\"//在methods中声明的方法\\n    c:{\\n      handler(val,oldVal){},\\n      deep:true,//开启深度监视\\n      immediate:true//立即调用handler\\n    },\\n    \\\"d.a\\\":function(){}\\n  }\\n}\\n</script>\\n```\\n- 函数式\\n```js\\nconst callback = ([aOldVal,aVal],[bOldVal,bVal])=>{}\\n//监听源 监听源发生改变的回调函数 选项\\nwatch([\\\"a\\\",\\\"b\\\"], callback, {\\n  flush: 'post',\\n  onTrack(e) {\\n    debugger\\n  },\\n  deep:true,\\n  immediate:true,\\n})\\n```\\n## 选项式watch Api的实现\\n```js\\n//这一段代码在Vue3源码分析(7)中出现过\\n//不了解的可以看看上一篇文章\\n//对每一个watch选项添加watcher\\nif (watchOptions) {\\n  for (const key in watchOptions) {\\n    createWatcher(watchOptions[key], ctx, publicThis, key);\\n  }\\n}\\n```\\n- 这里的`watchOptions`就是用户写的`选项式api的watch对象`。\\n### 创建watch对象(createWatchr)\\n```js\\nfunction createWatcher(raw, ctx, publicThis, key) {\\n  //可以监听深度数据例如a.b.c\\n  const getter = key.includes(\\\".\\\")\\n    ? createPathGetter(publicThis, key)\\n    : () => publicThis[key];\\n  //raw可以是字符串,会读取methods中的方法\\n  if (shared.isString(raw)) {\\n    const handler = ctx[raw];\\n    if (shared.isFunction(handler)) {\\n      //进行监听\\n      watch(getter, handler);\\n    } else {\\n      warn(`Invalid watch handler specified by key \\\"${raw}\\\"`, handler);\\n    }\\n  }\\n  //如果是函数 监听\\n  else if (shared.isFunction(raw)) {\\n    watch(getter, raw.bind(publicThis));\\n  }\\n  //如果是对象\\n  else if (shared.isObject(raw)) {\\n    //数组遍历,获取每一个监听器在执行createWatcher\\n    if (shared.isArray(raw)) {\\n      raw.forEach((r) => createWatcher(r, ctx, publicThis, key));\\n    }\\n    //对象\\n    else {\\n      //handler可能是字符串重ctx上获取\\n      //也可能是函数\\n      //获取到handler后调用watch\\n      const handler = shared.isFunction(raw.handler)\\n        ? raw.handler.bind(publicThis)\\n        : ctx[raw.handler];\\n      if (shared.isFunction(handler)) {\\n        watch(getter, handler, raw);\\n      } else {\\n        warn(\\n          `Invalid watch handler specified by key \\\"${raw.handler}\\\"`,\\n          handler\\n        );\\n      }\\n    }\\n  } else {\\n    warn(`Invalid watch option: \\\"${key}\\\"`, raw);\\n  }\\n}\\n```\\n- `选项式watch`的键可以是`\\\"a.b.c\\\"`这样的形式也可以是普通的`\\\"a\\\"`形式,它的值可以是字符串,函数,对象,数组。此函数主要对不同形式的参数做重载。最终都是调用`watch`函数。\\n- 对于键为`\\\"a.b\\\"`形式的需要调用`createPathGetter`创建一个getter函数,getter函数返回`\\\"a.b\\\"`的值。\\n- 对于**值为字符串**的我们需要从`methods`中获取对应的方法。因为之前**许多重要属性都代理到ctx**上了所以只需要访问`ctx`即可。\\n- 对于**值为函数**的我们只需要将`key`作为`watch`的第一个参数,值作为`watch`的第二个参数即可。\\n- 对于**值为对象**的获取`handler`作为`watch`第二个参数,将`raw`作为第三个参数(选项)传入`watch`即可。\\n- 对于**值为数组**的,表示需要开启**多个监听**,遍历数组递归调用`createWatcher`即可。\\n### 选项式watch Api总结\\n- 对于`选项式watch Api`本质上还是调用的函数式`watch Api`进行实现的。这里只是做了重载,对于不同的配置传递不同的参数给`watch`。所以接下来我们重点分析函数式`watch Api`的实现。\\n\\n## 函数式watch的实现(下面统称watch)\\n\\n### 1.watch\\n```js\\nfunction watch(source, cb, options) {\\n  //cb必须是函数\\n  if (!shared.isFunction(cb)) {\\n    console.warn();\\n  }\\n  return doWatch(source, cb, options);\\n}\\n```\\n- `source`:监听源,可以是**数组**(代表监听多个变量)。\\n- `cb`:监听源发生改变时,调用的回调函数。\\n- `options`:`watch函数`的可选项。\\n- **如果传递的cb不是函数需要警告用户,这可能导致错误**。\\n### 2.doWatch\\n- 这个函数非常长,也是`watch`的实现核心,我们分多个部分讲解。\\n- **大致原理**:收集`source`中响应式元素包装成`getter`,在`new ReactiveEffect`中传递调用`run`方法执行`getter`就会**收集到依赖**,然后当**触发依赖更新**的时候就会调用`scheduler`,在根据`flush`参数,选择**同步执行**`scheduler`还是加入调度器。\\n```js\\nfunction doWatch(\\n  source, //getter ()=>[监听的数据]\\n  cb, //回调函数\\n  //获取当前watch的选项\\n  { immediate, deep, flush, onTrack, onTrigger } = shared.EMPTY_OBJ\\n) {\\n  //immediate和deep属性必须有cb\\n  if (!cb) {\\n    if (immediate !== undefined) {\\n      warn(\\n        `watch() \\\"immediate\\\" option is only respected when using the ` +\\n          `watch(source, callback, options?) signature.`\\n      );\\n    }\\n    if (deep !== undefined) {\\n      warn(\\n        `watch() \\\"deep\\\" option is only respected when using the ` +\\n          `watch(source, callback, options?) signature.`\\n      );\\n    }\\n  }\\n  //省略第二部分代码\\n }\\n```\\n- 第一部分的代码主要是检测参数。对于没有`cb参数`但是又有`immediate`和`deep`选项的需要警告用户。\\n```js\\n//获取当前实例\\nconst instance = getCurrentInstance();\\nlet getter;\\nlet forceTrigger = false; //强制触发\\nlet isMultiSource = false; //是否多个数据\\n//判断监听的数据是否是ref\\nif (reactivity.isRef(source)) {\\n  getter = () => source.value;\\n  forceTrigger = reactivity.isShallow(source);\\n}\\n//判断数据是否是响应式\\nelse if (reactivity.isReactive(source)) {\\n  getter = () => source;\\n  deep = true;\\n}\\n//判断数据是否是数组\\nelse if (shared.isArray(source)) {\\n  isMultiSource = true;\\n  //source中有一个是响应式的\\n  //就需要触发\\n  forceTrigger = source.some(\\n    (s) => reactivity.isReactive(s) || reactivity.isShallow(s)\\n  );\\n  //()=>[proxy,()=>proxy,ref]\\n  getter = () =>\\n    source.map((s) => {\\n      if (reactivity.isRef(s)) {\\n        return s.value;\\n      } else if (reactivity.isReactive(s)) {\\n        //遍历响应式对象s 这个getter会作为ReactiveEffect的\\n        //第一个参数,在调用run的时候遍历所有的值\\n        //确保能让每一个变量都能收集到effect\\n        return traverse(s);\\n      }\\n      //调用监听的函数\\n      else if (shared.isFunction(s)) {\\n        return callWithErrorHandling(s, instance, 2);\\n      } else {\\n        //提示非法source信息\\n        warnInvalidSource(s);\\n      }\\n    });\\n}\\n//省略第三部分代码\\n```\\n- 如果监听的数据是**ref类型**,包装成`getter`形式。\\n- 如果监听的数据是**reactive类型**,需要设置为**深度监听**。\\n- 如果监听的数据是**数组**,设置变量`isMultiSource=true`表示当前监听了多个变量,同时判断监听的所有数据中是否有相应式对象,如果有就必须强制触发。设置`getter`。\\n- 我们可以发现所有的监听数据源都会被包装成`getter`,**这是因为底层都是调用`reactivity库`的`watchEffect`,而第一个参数必须是函数,当调用这个函数访问到的变量都会收集依赖。所以如果当前元素为`reactive`元素的时候需要遍历这个元素的所有值以便所有的变量都能收集到对应的依赖**。\\n```js\\n//()=>[proxy]传入的是一个函数\\nelse if (shared.isFunction(source)) {\\n  if (cb) {\\n    //让getter为这个函数\\n    getter = () => callWithErrorHandling(source, instance, 2);\\n  } else {\\n    //如果没有回调函数\\n    getter = () => {\\n      if (instance && instance.isUnmounted) {\\n        return;\\n      }\\n      if (cleanup) {\\n        cleanup();\\n      }\\n      return callWithAsyncErrorHandling(source, instance, 3, [onCleanup]);\\n    };\\n  }\\n}\\n//省略第四部分代码\\n```\\n- 如果监听的数据是**函数**,先判断是否有`cb`,如果有`cb`则将监听源函数作为`getter`。\\n- 如果没有传递`cb`,那么这个函数将会作为`getter`和`回调函数cb`。\\n- 我们来详细说说`cleanup`的作用。先来看看官方的测试用例:\\n```js\\nwatch(async (onCleanup) => {\\n  const { response, cancel } = doAsyncWork(id.value)\\n  // `cancel` 会在 `id` 更改时调用\\n  // 以便取消之前\\n  // 未完成的请求\\n  onCleanup(cancel)\\n  data.value = await response\\n})\\n```\\n- 它被用来做副作用清除。**第一次调用`getter`的时候是作为收集依赖,所以`cleanup`为空不执行,然后调用`source函数`,在这个函数中会收到`onCleanup`的参数,如果你在`source`函数中调用了`onCleanup`函数那么`cleanup`将会被赋值。当`id`发生改变之后再次调用`getter函数`(此时作为cb),这时候`cleanup`就会被调用**,也就是官方说的`cancle函数会在id更改时调用`。\\n- 我们继续第四部分代码的分析:\\n```js\\n//不是以上情况,让getter为空函数\\nelse {\\n  getter = shared.NOOP;\\n  //警告\\n  warnInvalidSource(source);\\n}\\n//省略第五部分代码\\n```\\n- 这表示没有需要监听的数据源,将`getter`设置为**空函数**,同时**警告用户**。\\n```js\\nconst INITIAL_WATCHER_VALUE = {}\\n//getter作为参数传入ReactiveEffect\\n//调用run的时候会调用getter,确保\\n//所有的属性都能够收集到依赖\\nif (cb && deep) {\\n  const baseGetter = getter;\\n  getter = () => traverse(baseGetter());\\n}\\nlet cleanup;\\n//调用effect.stop的时候触发这个函数\\nlet onCleanup = (fn) => {\\n  cleanup = effect.onStop = () => {\\n    callWithErrorHandling(fn, instance, 4);\\n  };\\n};\\nlet oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE;\\n//省略第六部分代码\\n```\\n- 对于含有`deep`属性的需要深度遍历,**只要在getter中访问了所有变量的值那么这些值都会收集到依赖**。\\n- 接下来便是`onCleanup`的实现,大家可以按照上面我说的进行理解。\\n- 我们知道在**watch可以监听多个数据**,那么对应的**cb回调函数的参数要收集到这些改变的值**。所以如果监听了多个数据源那么`oldValue`会被设置为`数组`否则为`对象`。\\n```js\\n//回调函数\\n const job = () => {\\n  if (!effect.active) {\\n    return;\\n  }\\n  //传递了cb函数\\n  if (cb) {\\n    //watch([a,b],()=>{})\\n    //newValue=[a,b]\\n    const newValue = effect.run();\\n    //未设置deep属性的\\n    //旧值和新值要发生改变才会调用cb回调函数\\n    if (\\n      deep ||\\n      forceTrigger ||\\n      (isMultiSource\\n        ? newValue.some((v, i) => shared.hasChanged(v, oldValue[i]))\\n        : shared.hasChanged(newValue, oldValue))\\n    ) {\\n      //这里的作用上面我们已经讲过了,不在赘述。\\n      if (cleanup) {\\n        cleanup();\\n      }\\n      callWithAsyncErrorHandling(cb, instance, 3, [\\n        newValue,\\n        oldValue === INITIAL_WATCHER_VALUE ? undefined : oldValue,\\n        onCleanup,\\n      ]);\\n      oldValue = newValue;\\n    }\\n  } else {\\n    //没有cb就只调用getter函数(watchEffect)\\n    effect.run();\\n  }\\n};\\n//省略第七部分代码\\n```\\n- 这个`job`代表的是要传递给`Vue调度器`的任务,所以这是在**创建一个调度器任务**。\\n- 同时还需要注意这个`job`是**监听的变量发生了改变后**才会调用。\\n- 这里的`effect`代表的是`ReactiveEffect类的实例`,如果还不了解这个类的请阅读[Vue3源码分析(2)](https://juejin.cn/post/7147598442301227021)。\\n- 如果没有传递`cb`那么会调用`effect.run()`这个函数会去执行`getter函数`。因为没有传递`cb`所以回调函数就是`getter函数`。\\n- 如果存在`cb`,那么会先调用`getter函数`获取最新的`value`,然后再调用`cb`,**所以不太建议自己将第一个参数写成函数,这样改变值的时候会调用getter和cb两个函数,如果你在getter中写了副作用那么就会多次调用**。\\n- 同样`cleanup`用于清除副作用这里就不再赘述了。\\n```js\\n//只要有cb则允许递归\\njob.allowRecurse = !!cb;\\nlet scheduler;\\n//设置了sync则同步调度,不放入queue进行异步调度(同步)\\nif (flush === \\\"sync\\\") {\\n  scheduler = job;\\n}\\n//设置了post放到DOM渲染之后执行(异步)\\nelse if (flush === \\\"post\\\") {\\n  scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);\\n}\\n//默认值为pre,放入到queue中执行(异步)\\n//带有pre的会在DOM渲染前执行\\nelse {\\n  job.pre = true;\\n  //给当前的job设置优先级\\n  if (instance) job.id = instance.uid;\\n    scheduler = () => queueJob(job);\\n}\\n//省略第八部分代码\\n```\\n- 当监视的数据发生改变的时候会调用`job任务`,但是`job任务`是异步调用还是同步调用是可以通过`flush参数`改变的。\\n- 当**flush为sync**的时候:会同步的执行`job任务`。\\n- 当**flush为post**的时候:会将`job任务`推入后置任务队列,**也就是会等queue队列任务执行完成之后执行**。\\n- 当**flush为pre**的时候:会将`job任务`设置为前置任务,在调用`flushPreFlushCbs`的时候执行。执行完成后删除这个任务。当然如果一直不调用`flushPreFlushCbs`,将会作为普通任务执行,这时候就是**异步**的了。\\n- 最终`getter`和`scheduler`都得到了。他们会作为`reactiveEffect`类的两个参数。第一个为监听的`getter函数`,在这里面访问的值都会收集到依赖,当这些监听的值发生改变的时候就会调用`schgeduler`。\\n```js\\nconst effect = new reactivity.ReactiveEffect(getter, scheduler);\\n//将用户传递的onTrack和onTrigger赋值到effect上\\n//便于在track和trigger的时候调用\\neffect.onTrack = onTrack;\\neffect.onTrigger = onTrigger;\\n//省略第九部分代码\\n```\\n- `onTrack`:是`reactivity库`实现的`api`。当被追踪的时候调用这个函数。\\n- `onTrigger`:当监视的变量改变的时候触发的函数。\\n- 创建`ReactiveEffect实例对象`,对变量进行监视。\\n```js\\n//调用了watch之后\\n//需要立刻执行getter,处理不同的flush参数\\nif (cb) {\\n  if (immediate) {\\n    //有immediate参数立即执行job\\n    job();\\n  }\\n  //否则就只收集依赖调用getter函数\\n  //并且获取监听的变量\\n  else {\\n    oldValue = effect.run();\\n  }\\n}\\n//flush为post需要将收集依赖函数getter\\n//放到postQueue中\\nelse if (flush === \\\"post\\\") {\\n  queuePostRenderEffect(\\n    effect.run.bind(effect),\\n    instance && instance.suspense\\n  );\\n}\\n//没有设置则收集依赖\\nelse {\\n  effect.run();\\n}\\n//省略第十部分代码\\n```\\n- 如果含有`immediate`参数则需要立刻执行`job任务`,否则调用`effect.run()`方法(调用`getter`)**收集依赖**。\\n- 如果`flush`设置为`post`那么**收集依赖的操作也需要移动到后置队列当中**。\\n```js\\n//watch的停止函数,调用后不再依赖更新\\nreturn () => {\\n  effect.stop();\\n};\\n```\\n- `watch`会返回一个方法用于**取消监听**。\\n\\n## watch总结\\n- 为了兼容选项式`watch`处理了不同的配置选项最终调用函数式的watch来实现的监视效果。\\n- `watch`拥有三个参数:`source、cb、options`。\\n- `source`是监听源,可以传递函数,值,数组。但是最后都是包装成`getter函数`。**实现的理念就是通过调用getter函数,访问响应式变量收集依赖,当响应式数据发生改变的时候调用cb**。\\n- `options`中比较重要的配置是`flush`,他决定了何时`收集依赖`和`触发依赖`。当`flush为post`的时候需要知道**收集依赖和触发依赖都将会推入到后置队列当中(DOM更新后触发)**。\\n\\n\\n\\n\\n\\n,\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n"
    },
    {
        "article_id": "7179554590935744569",
        "cover_image": "",
        "title": "Vue2迁移Vue3，如何迁移？",
        "brief": "开启掘金成长之旅！这是我参与「掘金日新计划 · 12 月更文挑战」的第5天，点击查看活动详情 vue2 对比 Vue3 有很多新特性增加，也有很多功能属于破坏性更新。 列举值得关注的新特性 第一个肯定",
        "user_name": "小满zs",
        "view_count": 1965,
        "collect_count": 21,
        "comment_count": 4,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/f406e4f16ef06556e95d7fe50241a5e8~300x300.image",
        "category": "前端",
        "content": "\\n![wallhaven-rrdgp1.jpg](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf52fe54d9e24001b8b2e717b033017b~tplv-k3u1fbpfcp-watermark.image?)\\n\\n开启掘金成长之旅！这是我参与「掘金日新计划 · 12 月更文挑战」的第5天，[点击查看活动详情](https://juejin.cn/post/7167294154827890702 \\\"https://juejin.cn/post/7167294154827890702\\\")\\n\\n**vue2 对比 Vue3 有很多新特性增加，也有很多功能属于破坏性更新。**\\n\\n# 列举值得关注的新特性\\n\\n1. 第一个肯定是组合式API `setup` 以及 `setup语法糖`模式\\n2. 新增的内置组件 `TelePort` 以及 `Suspense`\\n3. 响应式原理的变化从 `Object.defineProperty` 换成了 `proxy`\\n4. 对ts支持比较友好\\n5. 自定义`hooks` 逻辑拆分\\n6. `v-memo` 新指令可以小幅度提升性能\\n\\n# 破坏性更新的API以及功能\\n\\n1. 不在需要手动实例化Vue 废弃了 `new Vue` 这个操作,取而代之的是`createApp`接受一个根组件实例\\n```ts\\nimport { createApp } from 'vue'\\nimport App from './App.vue'\\nconst app = createApp(App).mount('#app')\\n```\\n\\n同时返回的app实例也跟之前不一样\\n废弃了`Vue.config.productionTip` `Vue.extend`\\n\\n具有影响的改动点 之前的`Vue.prototype` 改为 `app.config.globalProperties`\\n\\n```js\\n//2.x \\n//定义全局属性或者方法\\nvue.prototype.xxxxxx\\n//3.x\\napp.config.globalProperties.xxxxxxx\\n```\\n2. `nextTick` nextTick 源码内部不再判断各种兼容性\\n\\n```js\\n//Vue2.x 还在判断 promise MutationObserver setImmediate setTimeout\\nlet timerFunc \\nif (typeof Promise !== 'undefined' && isNative(Promise)) {\\n  const p = Promise.resolve()\\n  timerFunc = () => {\\n    p.then(flushCallbacks)\\n    if (isIOS) setTimeout(noop)\\n  }\\n  isUsingMicroTask = true\\n} else if (!isIE && typeof MutationObserver !== 'undefined' && (\\n  isNative(MutationObserver) ||\\n  MutationObserver.toString() === '[object MutationObserverConstructor]'\\n)) {\\n  let counter = 1\\n  const observer = new MutationObserver(flushCallbacks)\\n  const textNode = document.createTextNode(String(counter))\\n  observer.observe(textNode, {\\n    characterData: true\\n  })\\n  timerFunc = () => {\\n    counter = (counter + 1) % 2\\n    console.log('counter', counter)\\n    textNode.data = String(counter)\\n  }\\n  isUsingMicroTask = true\\n} else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {\\n  timerFunc = () => {\\n    setImmediate(flushCallbacks)\\n  }\\n} else {\\n  timerFunc = () => {\\n    setTimeout(flushCallbacks, 0)\\n  }\\n}\\n//Vue3.x 直接使用promise\\nexport function nextTick<T = void>(\\n  this: T,\\n  fn?: (this: T) => void\\n): Promise<void> {\\n  const p = currentFlushPromise || resolvedPromise\\n  return fn ? p.then(this ? fn.bind(this) : fn) : p\\n}\\n```\\n3. v-model 终极破坏性更新 \\n\\n\\n   2.x 默认的props 是 `value` 3.x 默认为 `modelValue`\\n\\n   2.x emit派发 `input`  3.x默认为`update:modelValue`\\n\\n   同时废除了`sync修饰符` 和 `native修饰符`\\n   \\n   新增了可以使用多v-model 语法，并且可以支持自定义修饰符\\n   \\n   详细请看 [v-model视频教程](https://www.bilibili.com/video/BV1dS4y1y7vd?p=35&vd_source=7313597670b28c3c44c50e326d82d040)\\n\\n   ```js\\n     <template>\\n      <!--废弃-->\\n      <div xxx.sync></div>\\n      <A @click.native></A>\\n      <!--新增多v-model用法以及自定义修饰符-->\\n      <B v-model:xxx='a' v-model:cccc='a' v-model:ddd.yyy.ccc='a'></B>\\n     </template>\\n     export default {\\n      props: {\\n        modelValue: String // 以前是`value：String`\\n      },\\n      emits: ['update:modelValue'],\\n      methods: {\\n        changePageTitle(title) {\\n          this.$emit('update:modelValue', title) // 以前是 `this.$emit('input', title)`\\n        }\\n      }\\n    }\\n   ```\\n   \\n4. `v-for v-if`指令优先级调整\\n\\n    2.x 版本中在一个元素上同时使用 `v-if` 和 `v-for` 时，`v-for` 会优先作用\\n   \\n    3.x 版本中 `v-if` 总是优先于 `v-for` 生效。\\n\\n5. 异步组件\\n\\n    2.x 异步组件直接通过`promise`返回\\n    \\n    3.x 异步组件需要通过`defineAsyncComponent`包裹返回\\n\\n    例子\\n    ```js\\n    //2.x\\n    const asyncModal = () => import('./Modal.vue')\\n    \\n   //3.x\\n   import { defineAsyncComponent } from 'vue'\\n   const asyncModal = defineAsyncComponent(() => import('./Modal.vue'))\\n    ```\\n 6. 生命周期名字改变\\n\\n     `destroyed` 生命周期选项被重命名为 `unmounted`\\n     \\n     `beforeDestroy` 生命周期选项被重命名为 `beforeUnmount`\\n     \\n 7. `transition`组件部分class重命名\\n\\n     `leave-class` 已经被重命名为 `leave-from-class` (在渲染函数中可以写`leaveFromClass`)\\n\\n     `enter-class` 已经被重命名为 `enter-from-class` (在渲染函数中可以写`enterFromClass`)\\n\\n     迁移策略\\n\\n     `.v-enter` 字符串实例替换为 `.v-enter-from`\\n     \\n     `.v-leave` 字符串实例替换为 `.v-leave-from`\\n     \\n 8. 自定义指令破坏性更新\\n\\n      主要是生命周期的替换方便记忆\\n    \\n        2.x\\n        bind - 指令绑定到元素后调用。只调用一次。\\n        inserted - 元素插入父 DOM 后调用。\\n        update - 当元素更新，但子元素尚未更新时，将调用此钩子。\\n        componentUpdated - 一旦组件和子级被更新，就会调用这个钩子。\\n        unbind - 一旦指令被移除，就会调用这个钩子。也只调用一次。\\n\\n        3.x\\n        created - 新增！在元素的 attribute 或事件监听器被应用之前调用。\\n        bind → beforeMount\\n        inserted → mounted\\n        beforeUpdate：新增！在元素本身被更新之前调用，与组件的生命周期钩子十分相似。\\n        update → 移除！该钩子与 updated 有太多相似之处，因此它是多余的。请改用 updated。\\n        componentUpdated → updated\\n        beforeUnmount：新增！与组件的生命周期钩子类似，它将在元素被卸载之前调用。\\n        unbind -> unmounted\\n        \\n\\n# 移除的API以及方法\\n\\n1. `$on`，`$off` 和 `$once` 实例方法已被移除，组件实例不再实现事件触发接口。\\n2.x 会使用这两个方法进行`eventBus`封装在Vue3中移除了，使用`mitt库`代替。\\n\\n2. filters过滤器已经移除\\n\\n    ```js\\n    //2.x\\n    <template>\\n      <h1>Bank Account Balance</h1>\\n      <p>{{ accountBalance | currencyUSD }}</p>\\n    </template>\\n    <script>\\n      export default {\\n        props: {\\n          accountBalance: {\\n            type: Number,\\n            required: true\\n          }\\n        },\\n        filters: {\\n          currencyUSD(value) {\\n            return '$' + value\\n          }\\n        }\\n      }\\n    </script>\\n\\n    //3.x 可以添加一个全局过滤器使用\\n    const app = createApp(App)\\n\\n    app.config.globalProperties.$filters = {\\n      currencyUSD(value) {\\n        return '$' + value\\n      }\\n    }\\n    ```\\n 3. $children 移除\\n \\n     在2.x使用 `$children` 访问子组件实例，Vue3 推荐使用模板引用也就是`ref`访问子组件\\n     \\n 4. 全局函数 `set` 和 `delete` 以及实例方法 `$set` 和 `$delete`。基于代理的变化检测已经不再需要它们了\\n 5. 按键修饰符\\n\\n    2.x config.keyCode 可以自定义按键修饰符\\n\\n    ```js\\n    Vue.config.keyCodes = { f1: 112 }\\n    <input v-on:keyup.f1=\\\"showHelpText\\\" />\\n    ```\\n       在Vue3已经废除 Vue 3 继续支持这一点就不再有意义了。因此，现在建议对任何要用作修饰符的键使用 kebab-cased (短横线) 名称\\n\\n       ```html\\n    <!-- Vue 3 在 v-on 上使用按键修饰符 -->\\n    <input v-on:keyup.page-down=\\\"nextPage\\\">\\n\\n    <!-- 同时匹配 q 和 Q -->\\n    <input v-on:keypress.q=\\\"quit\\\">\\n       ```\\n\\n\\n# 结束语\\n如果有漏掉的欢迎补充，私信联系。祝大家迁移顺畅。\\n\\n\\n"
    },
    {
        "article_id": "7184764149161787453",
        "cover_image": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f8f70fc199024ba1abbaeec9810f1175~tplv-k3u1fbpfcp-watermark.image?",
        "title": "为什么很多程序员都建议使用Linux？",
        "brief": "在知乎上有这么一个问题：为什么很多程序员都建议使用Linux？在这个问题上我其实有挺多想聊的，虽然比不上专门用C/C++编译的工程师了解的那么底层，也比不上运维工程师每天接触Linux，但是我们的工作",
        "user_name": "谢小飞",
        "view_count": 13242,
        "collect_count": 52,
        "comment_count": 32,
        "avatar": "https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/12/9/1603b5820ac466ee~tplv-t2oaga2asx-image.image",
        "category": "阅读",
        "content": "---\\ntheme: cyanosis\\nhighlight: vs2015\\n---\\n\\n\\n\\n\\n　　在知乎上有这么一个问题：为什么很多程序员都建议使用Linux？在这个问题上我其实有挺多想聊的，虽然比不上专门用C/C++编译的工程师了解的那么底层，也比不上运维工程师每天接触Linux，但是我们的工作中还是会接触到不少Linux的，今天我们来讨论一下学习Linux的必要性以及带来的价值。\\n\\n\\n> 本文首发于公众号``【前端壹读】``，更多精彩内容敬请关注公众号最新消息。\\n\\n\\n\\n\\n# 发展历程\\n\\n　　相信对Linux系统有一些了解的童鞋都听过这么一个故事，Linux是一名芬兰的学生Linus Torvalds在Unix系统的基础上开发的，并发布在学校论坛，最后火了起来。但是这么说并不十分的准确，Linux的故事缘起于更早的UNIX系统。\\n\\n## UNIX\\n\\n　　说到Linux，就不能提到大名鼎鼎的``UNIX系统``，在上世纪60年代末的时候，那时候计算机系统还是批处理的，在又大又笨的大型机器上运行，要先将程序卡片装入设备，然后等1个小时后才能取运算的结果。不仅慢，还很废纸。\\n\\n![大型机器](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f5152e2111144f0a1cbfafd87fb127a~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n\\n　　于是美国电话电报公司(下面简称AT&T公司)下面的贝尔实验室联合麻省理工学院及美国通用电气公司本来是打算开发一个大型机上的多人使用、多任务、多层次的操作系统``multics``。但是``multics``这个系统步子迈得太大了，贝尔实验室认为这个项目周期长、成本高，不久就撤资了，各方也陆续退出，项目于是凉凉了。\\n\\n\\n　　但是贝尔实验室下面的两个研究员肯·汤普森（Ken Thompson）和丹尼斯·里奇（Dennis Ritchie）对项目关闭很失望，因为他们在这个系统上开发了一个游戏``太空旅行(Space Travel)``，实验室的其他人员对这个游戏玩得也很上头。\\n\\n\\n![太空旅行游戏](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ec3a2bd1fa5143ad9332027da4ec1ba7~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n　　于是，为了能够``继续玩游戏``，肯·汤普森和丹尼斯·里奇决定自己开发一个操作系统；是的，你没有看错，大神就是大神，出发点都异于常人。肯·汤普森找来了一台五年前老旧的PDP-7小型机，虽然称为小型机，但是也有一间屋子那么大！\\n\\n![PDP-7小型机](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fd317f7a4de241e5b6d0c232e3c9ae36~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n　　正好在这段时间，他老婆带着孩子回娘家住了3个礼拜，也就是说他有整整3个礼拜没有人打扰他的工作。\\n\\n> 这件事告诉了我们,一个男人想要搞大事，老婆不在家是多么的重要！\\n\\n![老婆不在家](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e30b3bc566f49918cf708b44c43ec5b~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n　　在这台机器上，他首先重写了游戏，然后想要开发一个全新的操作系统，由于有之前multics系统的经验，在一个月内他很快完成了内核系统、文件系统、编辑器、编译系统的工作。1969年第一版的UNIX系统正式诞生了。\\n\\n\\n　　在[《UNIX传奇》](https://union-click.jd.com/jdc?e=618%7Cpc%7C&p=JF8BANgJK1olXQUCXVtUD0sSCl8IGloQVQECUV5eDUsTAF9MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksWAmoAHFsQXQUHVFpeFxJSXzI4BVJnPnRgCyQ-CR9DfR1rYQZnCQZeJFJROEonA24JGF8dXAUGU25tCEwnQgEAElsRXzYDZF5aDksXC2sAGFodWgMyU15UOBtFVyZATGslbQUyU15UHE1lQj0cHSklbQYyV24fZkJACmxdG1oWWgMBUVtaDhlHUG1cS1JHWwcAAFpYXEkfM20JGl8cbTY)一书中，提及了UNIX系统的高光时刻，上映于1993年的科幻冒险电影《侏罗纪公园》相信不少同学肯定对这部老电影仍旧印象深刻；其中一个名场面，哈蒙德教授的孙女就是操作UNIX系统，关闭了闸门，从而拯救了一行人，有兴趣可以重温[B站视频片段](https://www.bilibili.com/video/bv1NZ4y1f7m1)。\\n\\n> 这个故事告诉了我们，多学一门操作系统，在关键时刻说不定能够保命。\\n\\n![电影片段截图](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/adfa4396ca9b4b589f6f818f5b343f04~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n　　但是UNIX是由不少使用汇编语言完成的，汇编语言用来编程不够强大，也不具备很好的可移植性，于是1971年丹尼斯·里奇在B语言的基础上开发出了C语言，1973年UNIX也用C语言进行了重写，随后发布了4、5、6几个版本的UNIX。此后，UNIX被政府机关、研究机构、企业、大学纷纷注意，并逐步流行；随着UNIX系统的广泛流行，C语言也成为了最受欢迎的语言之一，一直延续至今。\\n\\n![电影片段UNIX系统界面](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f62934d884245538e9b09580d47c4f4~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n　　一开始AT&T公司也没有把UNIX当回事，毕竟不是正式的项目，况且在操作系统上（multics）还吃过大亏，也就没想拿它卖钱，因此被免费提供给大学使用，甚至直接给V7版本的源码以做研究。\\n\\n　　因此在后面的10年，UNIX在各个学术机构得到广泛应用，甚至许多机构在此源码基础上加以改进，其中最著名的变种之一是由加州大学柏克莱分校开发的BSD产品(Berkeley Software Distribution)，在此基础上又诞生了三条分支：FreeBSD、OpenBSD和NetBSD，就连苹果电脑的内核Darwin所使用的NextSETP也是BSD的衍生版本。\\n\\n\\n　　AT&T公司一看，哟呵，UNIX居然这么火，于是意识到了UNIX巨大的商业价值，不再将UNIX源码授权给学术机构，并对之前的UNIX及其变种声明了版权，后面引发了各种旷日持久的版权纠纷，这是UNIX的后话。\\n\\n\\n![UNIX](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9340da25bde74e7683d8b3d0e2fe24e4~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n\\n## Linux\\n\\n　　时间来到了80年代，随着AT&T公司闭源UNIX系统，在学校里给学生用的操作系统很少；当时计算机主要使用的操作系统有UNIX、MS-DOS和MacOS这几种，UNIX已经开始商用，比较昂贵，仅局限于大型机；MS-DOS系统比较简陋，且源代码被软件厂商严格保密；而MacOS大家肯定也都知道，是专门用在苹果计算机上的系统，而且当时应该没有黑苹果一说。\\n\\n\\n　　1987年当时在荷兰阿姆斯特丹Vrije大学当教授的美国人安迪·塔内鲍姆（AndrewS.Tanenbaum）为了让学生更好的理解操作系统的原理，就仿照BSD的源代码，编写了一个类UNIX系统，取名为``MINIX``，意为迷你的UNIX，并且开放全部代码给大学教学和研究用；既然是MINI，它的代码体量也是比较小的，全部代码共约12000行，而且只是一个教学工具，没有什么实际的应用价值。\\n\\n\\n　　1991年，我们的主人公Linus Torvalds（简称Linus）在芬兰赫尔辛基大学期间，开始对UNIX产生了浓厚的兴趣；在校期间，由于Linus经常要用他的终端仿真器（Terminal Emulator）去访问大学主机上的新闻组和邮件，他对MINIX只允许在教育上使用很不满，同时也为了方便读写和下载文件，他开始写属于自己的类UNIX系统；在一个暑假没日没夜的开发中，最终开发出了Linux的第一个内核（0.02版），并取名``Linus' Minix``，后来改名为Linux。\\n\\n\\n\\n\\n　　1991年10月Linus在Minix新闻组发布消息，对外宣布Linux内核的诞生，并公开了内核源码；公开后Linux因为结构清晰、功能简洁，一经发布立即收受好评；后来在很多热心支持者的帮助下，经过多次版本升级迭代，终于在1994年3月，Linux1.0正式发布。\\n\\n　　Linux的标志和吉祥物是一只叫做Tux的企鹅，它的由来是因为Linus之前在澳洲时，在动物园里曾被一只企鹅咬了一口，便选择了企鹅作为Linux的标志。\\n\\n\\n![Linux的Logo](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb2ab987e28249ac9f85ff0b54d82113~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n\\n　　如同当初汤普森和里奇没有想到UNIX系统的成功一样，Linus也没有想到自己花了一个暑假做着玩的内核系统，竟然能以商品化操作系统的形态，运行在今天全球数十亿台设备上。\\n\\n\\n　　在Linux的官网，有这么一篇文章，[什么是Linux](https://www.linux.com/what-is-linux/)，详细的介绍了Linux的功能、内核每个部分作用，以及为什么我们要使用Linux，感兴趣的童鞋可以看看。\\n\\n\\n\\n## Linux与UNIX的区别和联系\\n\\n　　我们上面提到了一个词：``类UNIX系统``，那什么是类UNIX系统呢？\\n\\n> 类UNIX系统是指继承UNIX的设计风格演变出来的系统。\\n\\n\\n　　类UNIX系统就是长得像UNIX、但实际不是UNIX的系统；其实本质上就是``借鉴``了UNIX系统的界面、特性（多用户、多任务等），但是没有直接抄人家的源代码，毕竟人家是有版权限制的，因此更多是思想理念上的传承。上面提到的BSD、MINIX系统，以及Linux系统都属于类UNIX系统。由于UNIX标准认定价格昂贵，所以目前唯一获得UNIX标准认定的为苹果的MACOS系统。\\n\\n　　Linux系统和UNIX系统主要有以下区别：\\n\\n1. 开源性：UNIX是闭源的，Linux是开源的。\\n2. 跨平台性：UNIX系统大多是与硬件配套的，只能在工作站或小型机上运行，且价格昂贵；而Linux则可运行在多种硬件平台上。\\n\\n\\n\\n# Linux发行版\\n\\n\\n　　我们很多时候都能看到``Linux发行版``这个词，或者又看到说``Linux内核``怎么样，很多同学容易混淆这两个概念。其实当初Linus开发的Linux只是一个``内核``，是一个提供设备驱动、文件系统、进程管理、网络通信等功能的系统软件，是硬件和软件之间进行通信的桥梁，内核并不是一套完整的操作系统；我们可以把内核理解为手机的芯片，有了芯片，手机的各个功能才能运行起来，因此内核是整个操作系统的核心。我们在[The Linux Kernel Archives网站](https://kernel.org)可以下载到各种版本的Linux内核，并且对其进行编译。\\n\\n> 内核是操作系统重要组成部分，接近于物理硬件，不是操作系统。\\n\\n　　我们常说的``Linux系统``，其实更多说的是广义上``Linux众多的发行版``，因为你并不会直接去操作系统的内核。发行版是指一些组织或厂商将Linux的内核与各种软件、软件包管理器等封装起来，并提供系统安装界面、系统配置和桌面环境等，构成了Linux的发行版。相当于小米、VIVO的手机厂商，将芯片集成到手机里，装上屏幕、外壳、扬声器、电池等等部件，然后把手机整个的卖给你。\\n\\n\\n　　Linux的各个发行版使用的是同一个Linux内核（内核版本可能有差异），因此在内核层不存在什么兼容性问题；每个发行版有不一样的感觉，只是在发行版的最外层（比如界面、包管理器）才有所体现。\\n\\n\\n> uname -srm命令可以查看Linux系统的内核版本号。\\n\\n\\n　　Linux的发行版本有很多，其大体可以分为两类：\\n\\n* 商业公司维护的商业版本，以著名的Red Hat为代表；\\n* 社区组织维护的免费版本，以Debian、Ubuntu为代表。\\n\\n　　有些同学可能会开始疑惑了，上面不是说Linux是开源的吗？为什么还会有商业版？是的，Linux内核是开源的，但是``开源不等于免费``，商业版收费的是它的商业服务和支持。\\n\\n　　比如Red Hat虽然使用的都是开源软件，但是付出了很多人工将成千上万的开源软件整合成一个系统，并且保证软件间的兼容性稳定性，提供后续的支持、维护以及升级服务，因此它是收费的；如果你氪金氪了足够多，比如购买他们的高级服务，你甚至可以让Red Hat的工程师现场过来给你解决问题。\\n\\n![氪金玩家](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/69be8e18e6c14ebe9055755a93ab1300~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n\\n　　很多同学可能还是觉得开源收费不太能理解，但其实如果你去尝试编译多个开源软件，或者在操作系统时遇到一些莫名其妙的错误，然后你花费几天找遍github、stackoverflow和Google也没有找到问题而苦恼时，你会觉得如果有人能够帮你解决问题是一件非常高兴的事。更何况企业项目在运行时往往都会追求快速上线，计时按照天甚至小时，这个时候快速解决问题就显得非常的重要；这点费用对于企业来说是非常划算的。\\n\\n> 这件事告诉了我们，天下没有免费的午餐，免费往往是最贵的。\\n\\n\\n　　下面我们简单介绍几个常见的Linux发行版本。\\n\\n\\n## Red Hat\\n\\n\\n　　Red Hat（红帽公司）创建于1993年，是一家开源解决方案供应商，部位于美国北卡罗来纳州的罗利市。\\n\\n　　1993年，Bob Young 成立了ACC公司，这家公司主要是做邮购业务，主营业务是出售Linux和Unix的软件附件。1994年，Marc Ewing创建了自己的Linux发行版，并将其命名为：红帽Linux，Ewing在就读卡内基·梅隆大学期间曾经戴着一顶红色的康奈尔大学长曲棍球帽子，这是他的祖父赠送给他的。Young在1995年收购了Ewing的企业，两者合并成为红帽软件公司，由Young担任首席执行官。\\n\\n\\n\\n　　Red Hat公司的产品主要包括RHEL（Red Hat Enterprise Linux，收费版本）和 CentOS（RHEL 的社区克隆版本，免费版本）、Fedora Core（由 Red Hat 桌面版发展而来，免费版本）。\\n\\n\\n## Fedora\\n\\n\\n　　Fedora Linux是由Fedora项目社区开发、红帽公司赞助，目标是创建一套新颖、多功能并且自由的操作系统。\\n\\n　　Fedora对于用户而言，是一套功能完备、更新快速的免费操作系统；而对赞助者Red Hat公司而言，它是许多新技术的测试平台，因此它的稳定性不如Centos。\\n\\n\\n\\n\\n\\n## CentOS\\n\\n\\n　　CentOS可以理解为是基于Red Hat商业版系统的社区编译重发布版，完全开源免费，因此相较于其他一些免费的Linux发行版会更加稳定，也因此一般企业里常用作服务器操作系统。\\n\\n\\n\\n\\n\\n## Debian\\n\\n　　Debian是目前世界最大的非商业性Linux发行版之一，是由世界范围1000多名计算机业余爱好者和专业人员在业余时间制做。\\n\\n\\n\\n\\n## Ubuntu\\n\\n\\n　　Ubuntu是``基于Debian发展``而来，界面友好，容易上手，对硬件的支持非常全面，是目前最适合做桌面系统的Linux发行版，而且Ubuntu的所有发行版都免费提供，也是笔者个人非常喜欢的一个Linux发行版。\\n\\n\\n　　Ubuntu的创始人马克·沙特尔沃思(Mark Shuttleworth)是一名有传奇色彩的南非人，他在大学毕业后创建了一家安全咨询公司，后以5.75亿美元被收购，一跃成为南非本地的富翁。2002年马克自费乘坐罗斯联盟号飞船，在国际空间站中度过了8天的时光，之后创立了Ubuntu社区。他说太空的所见正是他创立Ubuntu的精神所在。Ubuntu这个词也是来源自非洲一个部落，意思是\\\"人性\\\"\\\"我的存在是因为大家的存在\\\"，是非洲传统的一种价值观。\\n\\n\\n![Ubuntu官网](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e57ab74175c44532adfbd4a02f013a7f~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n\\n　　作为Linux发行版中的后起之秀，Ubuntu在短短几年时间里便迅速成长为从Linux初学者到实验室用计算机/服务器都适合使用的发行版。\\n\\n\\n\\n## 如何选择\\n\\n　　Linux系统的发行版有很多，就不逐一介绍了，在[《Linux从入门到精通》](https://union-click.jd.com/jdc?e=618%7Cpc%7C&p=JF8BANkJK1olXQYFV1pfDkIfBF8IGloQVQcCVldZAE8XCl9MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksWAmoAGlsXVAIKUF5UFxJSXzI4UidMBEABCzY4axdCfTlBeFpyKXEGAlJROEonA24JGF8dXAUGU25tCEwnQgEPGV8WWgYyVW5dD00UCmwIHVoSXQ4EZFldAXtHUTtBUwwlbTYBZFldAV8RcS5aD11nbTYCZF1tSiVHAmgOS1xHCQUHXVhYDE8UC2cJTFsWClIBXFtfW0IQU18KGloRVDYy)一书中整理了不同的发行版；我们如何来选择不同特性的版本呢？\\n\\n\\n1. 如果你需要一个服务器系统，想要一个比较稳定的服务器，可以选择CentOS或者RHEL。\\n2. 如果你需要桌面系统，既不想用盗版，也不想在系统配置上浪费太多时间，可以选择Ubuntu。\\n3. 如果你喜欢折腾新功能特性可选Fedora。\\n\\n\\n\\n# Linux的优势\\n\\n\\n　　相信计算机科班出身的同学在大学里都会接触一门课程：计算机操作系统，笔者在大学里，这门课老师让用过一段的时间的Ubuntu开发，做做作业，当时觉得命令行shell就像深不见底的黑洞，太麻烦了，完全没有图形化界面来的方便快捷；但是工作了一段时间，接触了一下Linux系统，熟悉命令行之后，哎，真香，比Windows好用多了。\\n\\n\\n\\n\\n　　简单介绍一下，笔者也算是Linux系统中度用户吧，个人桌面系统主力虽然是Windows 10，主要是由于之前系统存了很多文件资料等；目前转向使用Ubuntu 22.04系统；自己将家用闲置的一台电脑改造成为家用nas系统，搭载CentOS 7，因此改造的过程中接触了不少Linux系统的命令，于是就开始自学并喜欢上。\\n\\n\\n　　我相信很多童鞋开始学习和使用Linux系统应该和我一样，主要是在工作中开始的，因为毕竟Linux系统下娱乐、游戏、社交功能有限，全面使用Linux系统会带来一定的限制（主要是没有微信），我平时也是将Linux系统作为日常工作和编程开发的一个补充。\\n\\n> PS：steam平台也支持Ubuntu了，QQ推出了全新的Linux3.0版本。\\n\\n\\n　　下面简单的介绍几个觉得使用Linux系统的个人推荐看法吧，仅供参考。\\n\\n\\n## 界面优雅美观\\n\\n　　常言道：始于颜值，陷于才华；看惯了Windows下千篇一律的图标，说实话，使用Ubuntu 22有一部分原因确实是被它的界面所吸引的。\\n\\n![Windows图标](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1524973dd79c4eaebda07c2f95fb935f~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n\\n　　打开Ubuntu系统，我们会发现，整体的风格非常简洁优雅。\\n\\n![Ubuntu桌面](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/67611841929344daa5263fb08cd7b4ec~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n\\n　　很多刚从Windows转过来的小伙伴（包括我自己），一开始接触Ubuntu桌面，会常常感觉不习惯，经常会疑惑：\\n\\n\\n> 桌面的那些我的电脑、回收站等图标都去哪了？\\n\\n\\n　　包括在安装完很多应用后，我们发现这些应用也不会在桌面留下任何痕迹，没有Windows软件那种安装完后，还要死皮赖脸的请求你创建桌面快捷方式，还给你默认勾选；只要一不留神，你的桌面说不定就多了三四个不常用的图标。\\n\\n\\n　　因此在Windows系统，我们用过一段时间后会有各式各样繁杂的图标存在；但是Ubuntu就不会有这样的烦恼，用了几个月，我的桌面也仅仅只有刚开始的主目录文件夹存在，加上Foxit Reader创建的一个图标，仅此而已。\\n\\n\\n　　Ubuntu界面的设计者考虑到，大部分用户在工作时，桌面上的图标几乎都是被应用窗口遮住，把窗口移开来查找想要的应用是一件非常痛苦的事，因此停用了桌面图标，改用在应用程序中提供了入口；点击右下角的按钮，我们可以看到所有的程序。\\n\\n![所有应用程序](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b7e68880451541dcb4325537779cb984~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n\\n　　对于一些常用的程序，我们可以将它固定到下方的程序坞中，方便随时访问。Ubuntu给了我们一个干净的环境，让我们能够更专注于当前的工作环境，更少被其他弹框打扰；因此更适合用来干活。\\n\\n\\n\\n## 开源\\n\\n　　开源带来的一大显而易见的好处就是，你不用每次安装完系统去找各种Windows激活工具了，相信很多小伙伴都有装完系统被下面各种软件支配的恐惧，不装的话系统各种提示，装了又怕有风险。\\n\\n\\n　　开源意味着使用者可以免费自由使用、查看和修改系统的源代码，这种完全开放透明的架构对于政府机构或者特殊需求的组织等来说是非常重要的。\\n\\n\\n　　同时你会发现Linux系统有广泛的硬件支持，甚至可以拿出一台上个世纪老旧的intel奔腾3处理器来运行也能很流畅；正是得益于开源的特点，很多程序员不断地向Linux社区提供代码，使得Linux有着丰富的设备驱动资源，对主流硬件有着很好的支持，几乎能运行在所有主流的处理器上。\\n\\n\\n　　在[超赞的Linux软件](https://alim0x.gitbooks.io/awesome-linux-software-zh_cn/content/)这篇文章中，作者整理了非常多Linux中开源的软件，也都是日常很实用的软件。\\n\\n\\n\\n## 系统安全稳定\\n\\n\\n　　系统安全稳定之于电脑，如同法律对于人们，是最基本的要求和准则。大多数小伙伴应该也是从Windows开始接触计算机和网络的，因此觉得Windows也能满足日从的工作需求。但客观来说，在安全性、高性能方面，Windows相比Linux依然有不小的差距。\\n\\n\\n　　使用Windows过程中相信大家在日常中会遇到不少卡顿、蓝屏的情况发生；笔者在之前的公司就遇到IT装完系统，一段时间经常蓝屏死机的情况发生，然后数次重装系统，这在办公时是及其痛苦的。\\n\\n\\n![Windows蓝屏](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/264d1e1383f548eb93a404b734139358~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n\\n　　但是Linux系统极少出现卡顿情况，除非你运行多个大型的软件。在我实际的体验中，在同一配置的电脑中，运行相同多软件的情况下，Linux系统的流畅度是明显优于Windows电脑的。\\n\\n\\n　　在Windows中，我们经常会遇到磁盘空间不够的情况，尤其是C盘空间，很多软件都会默认安装到C盘（比如Chrome），或者将缓存文件放到C盘，过一段时间就需要清理；但在Linux系统中不需要。\\n\\n\\n　　首先Linux系统安装完成后，本身不会占用太多的磁盘空间，占用较少的资源；其次Linux系统自身的``树形目录结构``已经将每个文件的位置规范了，/home是用户目录，/usr软件目录等等进行划分，我们可以将硬盘格式成一个区，然后直接挂载根目录。\\n\\n\\n![树形目录结构](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f878a19448f245d8b8adadb364fd93c9~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n\\n　　正是由于Linux系统的安全稳定高效，因此Linux天然适合用来做服务器；无论是企业级的大型服务器，还是最近流行的家用nas系统；无论是你用的手机操作系统，还是看家用大屏电视机，亦或是小巧的机顶盒，Linux系统出现在生活中的各个角落。\\n\\n\\n## 总结\\n\\n\\n　　要想学好Linux，不能只记住几个命令，最好的方式是为自己搭建一个Linux的环境，在真实的环境下进行学习；Ubuntu就是一个比较适合初学者的发行版；如果怕装系统麻烦，最简单的方式是在Windows10下安装Ubuntu子系统体验，参考[安装教程](\\nzhuanlan.zhihu.com/p/62658094)，不过有一些命令会被阉割。\\n\\n\\n　　如果手头有闲置移动硬盘，想要真实体验一下Ubuntu系统（虚拟机体验不好），又不想舍弃Windows系统，可以将Ubuntu环境安装到移动硬盘，打造自己的个人移动工作平台；这样你不管是在办公室还是回家干活，只需要随身携带一块小小的硬盘就能轻松将工作用到的所有资料打包带走，保持工作的进度和环境。\\n\\n\\n　　刚装完系统，看着空荡荡的桌面，你可能会不知所措，可能会迷茫[Ubuntu系统下可以做什么？](https://www.zhihu.com/question/19963978)；双击安装exe不再存在了，而是通过命令行来安装，甚至连接网络也要敲命令，当你熟悉命令行的环境后，你会发现这是一种高效的方式，也是另一种的体验。借用一位知乎前辈的话：\\n\\n\\n> Windows为不知道自己正在做什么的人设计，Linux为知道自己要做什么，正在做什么的人设计。\\n\\n\\n　　在这里，你可以做任何事，你可以热衷于更换各种酷炫的桌面和主题，也可以享受学习带来的无穷乐趣；先是命令，再是shell脚本，搭建服务器，学习数据库，部署自己的网站等等；我相信，你也会喜欢上这个简洁而优雅的开源世界。\\n  \\n  \\n如果觉得写得还不错，敬请关注我的<a href=\\\"//juejin.im/user/580038cebf22ec0064bd0b2d\\\" style=\\\"color:#f63;text-decoration:none;\\\">掘金主页</a>。更多文章请访问<a href=\\\"https://xieyufei.com\\\" style=\\\"color:#f63;text-decoration:none;\\\">谢小飞的博客</a>\\n\\n"
    },
    {
        "article_id": "7187310000333652005",
        "cover_image": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c1c7780a8784d79a3b8d1817479972f~tplv-k3u1fbpfcp-watermark.image?",
        "title": "这一年，我终于成为了一名真正的前端",
        "brief": "「回顾2022，展望2023，我正在参与2022年终总结征文大赛活动」 前言 时间很快，2022年一整年好像都很忙，也终于从学生过渡到了一名社会人。",
        "user_name": "一只囡狗",
        "view_count": 3088,
        "collect_count": 11,
        "comment_count": 52,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/68874522368477d12f8436be0a3de143~300x300.image",
        "category": "代码人生",
        "content": "---\\ntheme: fancy\\n---\\n\\n「回顾2022，展望2023，我正在参与[2022年终总结征文大赛活动](https://juejin.cn/post/7172462429929111559 \\\"https://juejin.cn/post/7172462429929111559\\\")」\\n\\n## 前言\\n\\n时间很快，2022年一整年好像都很忙，也终于从学生过渡到了一名社会人\\n\\n2022上半年，大四，独自一人去杭州实习，孤独，但在杭州实习的那几个月，是我成长最快的几个月。\\n\\n2022下半年，毕业，拒绝掉转正offer，拒绝掉对于应届生来说可观的薪资。回成都找了一份离家近，但是薪资少一半的工作，理想中就是钱少事少，下班后能开启新生活的工作，但事实真的如此吗？好多同学、长辈问过我后不后悔，~~当然后悔了，肠子都悔青了，属于是亲身体会了什么叫卷，什么叫钱少事情多压力大，再不涨薪已经准备提桶跑路了~~。我说：不后悔，毕竟成长了。\\n\\n\\n## 打工人的眼泪\\n\\n见过凌晨五点的成都吗，我见过，那时候我刚下班。但是第二个月看着我四位数的工资的时候，我还是没忍住骂了一句：wtf？我为什么不去送外卖？\\n\\n<img src=\\\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9293bd9c0db3447393680006836ea7fb~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\" width=\\\"50%\\\" />\\n\\n我真的不想把一个原本完美的毕业人设硬生生的过成了一个需要从低薪摸爬滚打上去的人设，但事实是，我好像在第二条路上越走越远。看看现在的自己，确实是有点`奋斗逼（贬义）`的模样（伤感）。\\n\\n\\n## 不可忽略的成长\\n\\n不可否认的是，这一年，我通过自己的努力从一个前端小白变成了一个可以独当一面的初级前端工程师。\\n\\n因为大学的专业是`数字媒体技术`，大一大二学完计算机科班相关知识后，大三主攻的方向有三个：J2EE，游戏开发，动画。\\n\\n在没经历过秋招的摧残之前，我还沉迷于游戏开发，3d建模，剪视频，做动画。秋招的时候信心满满的投简历，但悲惨的结果就是秋招**0 offer**（真不怪专业，怪我菜）。看到隔壁`软件工程`的同学秋招收获满满，想到自己做游戏开发也接触过脚本语言，于是一个从来没接触过web开发的焦虑的大四应届生果断入坑了web前端。\\n\\n**回顾我的2022，大概是这样的：**\\n\\n- 1月 在系统学习了两个月前端基础知识（b站，红宝书，付费课程）的基础上，狂刷面试题。\\n\\n- 2月 继续狂刷面试题，自学vue3框架，做了一个很简单的后台管理系统（vue3+axios+element plus）。凭借这个项目找到了我的第一份正式的实习\\n\\n- 3月-5月 独自前往杭州实习，开始接触企业级项目，学会了git操作，css预编译sass，响应式布局，学会去封装组件，学会用node.js(egg.js框架)。与此同时，利用我的所有空闲时间去做毕业设计（原生微信小程序+mysql+nodejs+vue3后台管理系统）那段时间每天只能睡4-5个小时，睁开眼睛就要开始敲代码，但不得不说，这是我成长最最最快的三个月。\\n\\n- 6月 回到成都远程办公，完成我的毕业论文，顺利答辩，顺利毕业，转正，离职，毕业旅行。\\n\\n- 7月 毕业旅行完回成都找工作，因为7月只能参加社招，社招跟校招相比薪资待遇没那么好，但竞争不大。凭借之前的实习经验和看得过去的毕设一周拿到了三份offer（所以2023届的学弟学妹真的不要焦虑！），7月中旬入职，成为一名正式的前端开发工程师。\\n\\n- 8月 第一次接触大屏开发，因为项目压力很大，自己也有很多不熟悉的东西，经常加班到凌晨。（抗压能力++\\n\\n- 9月 第一次独立搭建项目，这段时间成长也很快。从0搭建一个项目与在一个大项目里面写功能写组件的差别很大！要考虑的东西非常多，从目录结构到变量命名都需要注意。这段时间我开始学习工程化，架构搭建的知识。了解vite的一些配置，开始注意一些代码规范（eslint，prettier），提交规范（commitlint）。也开始尝试使用TypeScript （独立开发能力++\\n\\n- 10月 可视化开发，开始熟悉echarts相关知识，转正。（新技能++\\n\\n- 11月 普通中后台项目的开发，之前的项目维护。与此同时，公司开发流程逐渐规范，对代码质量也有了一些要求，开始更注重代码的规范。公司有了技术分享会，前端后端一起学习分享，学到了一些工具的使用，大多都是在学校学不到的东西，收获很大，工作效率有了一定程度的提升。（代码整洁度++ 新技能++\\n\\n- 12月 继续之前项目的维护，新的项目开始使用公司更规范更统一的脚手架搭建。这个时候了解了一些自动化ci部署，github action的使用。同时开始总结知识，写了几篇~~质量不高的~~博客。并开始尝试研究[Git flow](https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow)。\\n\\n以上就是我这一年，从一个前端小白进化成一名初初初初级前端的过程，过程中很感谢大佬们正确的引导，虽然一直都是项目驱动成长，没有构建出完整的知识体系，但也算是入行了吧。可以给想要成为前端er的学弟学妹们一点点参考\\n\\n## 2022年值得记录的瞬间\\n\\n来杭州的第一天，感叹阿里人周末也要加班。\\n\\n<img src=\\\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f8da0ea0c214d6b9e03b07a4e8a11fa~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\" width=\\\"50%\\\" />\\n\\n第一次做自我介绍\\n\\n<img src=\\\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/afeb74a067ea418d8461f8506caead8c~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\" width=\\\"50%\\\" />\\n\\n\\n通宵肝毕设的日子\\n\\n<img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/55f563c4538941cf9ab5af8d1bb0d760~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\" width=\\\"70%\\\" />\\n\\n\\n成为一名合格的铲屎官，小猫名字叫**缓存**，现在已经八斤啦\\n\\n<img src=\\\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f880706b57604c999a76da2650879cd5~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\" width=\\\"50%\\\" />\\n\\n回成都后加班成为了日常便饭\\n\\n<img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/807a5fda37284e4e86d116682f57351e~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\" width=\\\"50%\\\" />\\n\\n2022给我带来了很多新奇的体验，浅浅分享一小部分最最值得纪念的瞬间。\\n## 关于2023的期望\\n\\n立一点关于2023的flag：\\n- 需要更加熟练已有的技能\\n- 根据[前端roadmap](https://roadmap.sh/frontend/)点亮更多技能。\\n- 学习框架原理、库、网络、性能、浏览器、协议、工程化、node相关知识，完善知识体系，不需要全部深入，但要尽可能了解，提升知识广度。\\n- 懂业务，深入业务，能解决业务痛点，更好的实现自己的价值\\n- 学会做饭\\n- 找个对象\\n\\n最后最后：\\n\\n> 希望自己：严于律己，减少焦虑\\n> \\n> 希望公司：减少加班，工资翻番\\n"
    },
    {
        "article_id": "7189291398779109431",
        "cover_image": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c88bd29bc7dc4563b0d12fc0ade97fcb~tplv-k3u1fbpfcp-watermark.image?",
        "title": "我的2022",
        "brief": "前言 时光飞逝，光阴荏苒，2022不知不觉已结束。回想这一年里发生的事情，有辛酸不易，有困难重重，也有雨过天晴。简单总结下我的2022，无论过往如何终将逝去，愿我们在2023越来越好！",
        "user_name": "劼哥stone",
        "view_count": 1199,
        "collect_count": 1,
        "comment_count": 1,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/49f86dc1cd797f31afbae5eb4cd7f9a0~300x300.image",
        "category": "代码人生",
        "content": "「回顾2022，展望2023，我正在参与[2022年终总结征文大赛活动](https://juejin.cn/post/7172462429929111559 \\\"https://juejin.cn/post/7172462429929111559\\\")」\\n\\n## 前言\\n时光飞逝，光阴荏苒，2022不知不觉已结束。回想这一年里发生的事情，有辛酸不易，有困难重重，也有雨过天晴。简单总结下我的2022，无论过往如何终将逝去，愿我们在2023越来越好！  \\n\\n## 一、保持身体健康\\n健康好比数字1，家庭、孩子、事业、金钱都是0。失去了1，后面的0便毫无意义。1做好了，后面的0越多越富有。道理大家都懂，但就是很难做好。  \\n\\n年初定下每周运动3次的目标，当互联网裁员潮+35岁中年危机同时来袭，真的完全提不起运动的兴致，作息也变得不太规律。通过多学习、多总结、多沉淀，加上工作上取得了一定的成绩，自己的焦虑也就慢慢消散了，逐步开始每周打羽毛球等运动。  \\n\\n年底新冠疫情政策突发放开，病毒传播速度极快，我认识的所有人几乎在一个月内都“羊过”。虽然专家说99%都是轻症，但新闻上重症也不少，为了避免我上班把病毒带回家，便一直跟家人分开住，直到家里所有人都羊了，就我一人还没羊，我大概就是那个“天选打工人”吧。  \\n\\n## 二、工作节奏放缓\\n2022年的工作节奏相比2021进一步放缓，大多能在22点前下班了（2020年是0点后、2021年是23点后）。工作节奏放缓最主要有3个原因：一是产品越来越稳定，救火时间大幅减少；二是因为新冠疫情导致很多工厂停工；三是由于夏季高温干旱，全国各个省份都在实行限电，很多工厂也因此受影响。  \\n\\n## 三、项目开花结果\\n2020年基于水泥行业从0到1孵化了工业大脑智能优化控制系统AICS。  \\n\\n2021年持续打磨AICS产品核心能力，并从点到面沉淀了不少行业解决方案。  \\n\\n2022年重点做规模化复制，我们做的事情被央视点赞，我所负责的水泥行业也终于开花结果。  \\n\\n1、[央视点赞！阿里云奔赴工业生产“第一线”](https://mp.weixin.qq.com/s/V3kZpXZtBXyGEUyaIcYZ5Q)  \\n2、[再减碳6万余吨！牵手华新水泥，打造低碳制造新系统](https://mp.weixin.qq.com/s/B6K5mEI6RkA_TpGAVg2QWA)\\n\\n## 四、持续学习成长\\n项目中遇到了K8s多节点集群资源调度不均衡问题，深入学习K8s调度相关的源码。  \\n\\n工作中遇到大数据处理场景，整体熟悉了大数据技术栈，并对ClickHouse做了性能分析。  \\n\\n工作中为提升资源利用率和调度性能，学习了Hadoop和Flink的资源和计算调度核心架构。  \\n\\n参加了软考高级职称，利用业余时间备考了一个月，比较可惜的是上午的选择题差2分通过。  \\n\\n2022全年公发了6篇公众号，具体如下：  \\n\\n1、[我的2021](https://mp.weixin.qq.com/s?__biz=MzIyNjE0MzU1OQ==&mid=2650101398&idx=1&sn=fd6475984ef0020b2ccbb062983d949f&chksm=f0750abec70283a874283871de473ae732c4bbc568b4ea052c44594da88e1c40fe8c2fd28a28#rd)  \\n2、[初识工业互联网](https://mp.weixin.qq.com/s?__biz=MzIyNjE0MzU1OQ==&mid=2650101416&idx=1&sn=df4ffb63fa7ddb51ce31e9dc5a9568ac&chksm=f0750a80c70283968cd506593b2aa2e6c80f08de666c1c8aff6097cb2cf9c989fe4c35e50b79#rd)  \\n3、[深入浅出PID算法](https://mp.weixin.qq.com/s?__biz=MzIyNjE0MzU1OQ==&mid=2650101507&idx=1&sn=32534a33cd6092fd378b73557162e239&chksm=f0750b2bc702823dac9d109d8ee29bba4d59fdd55bef7e2c979ed3af51c6d1a6f9df701eea35#rd)  \\n4、[解决k8s调度不均衡问题](https://mp.weixin.qq.com/s?__biz=MzIyNjE0MzU1OQ==&mid=2650101535&idx=1&sn=0f78fa3c59fba31bc05da66041019aee&chksm=f0750b37c70282215db4e9fe2413f9c24cc69f6bae007daaab36b0a222d0f4d07440402d8a0c#rd)  \\n5、[记一次 ClickHouse 性能测试](https://mp.weixin.qq.com/s?__biz=MzIyNjE0MzU1OQ==&mid=2650101582&idx=1&sn=b667c2078b6cd55e06eb011c65c8ae75&chksm=f0750b66c70282708c60bc003afacd983531c6a4e15af3c0d30d2b4d00c5ef355676e2d03866#rd)  \\n6、[2022下半年《软考-系统架构设计师》备考经验分享](https://mp.weixin.qq.com/s?__biz=MzIyNjE0MzU1OQ==&mid=2650101595&idx=1&sn=2f6c3d30a0b890b652129ca0d8f78921&chksm=f0750b73c7028265f4e055e875144be7fb757db4355313e9e43ecdb52a6baed643d054e58cfc#rd)  \\n\\n虽然没有完成月更目标，但相比2021年的2篇，也算是有亿点进步，2023年再接再厉。  \\n\\n## 五、2023年目标\\n健康：每天睡眠7小时，每周尽量运动，体重控制在125左右。  \\n\\n工作：持续打磨产品，完成技术架构演进，帮助团队完成更大的业务目标。  \\n\\n成长：通过软考高级，公众号争取月更，提高英语水平，尝试录制短视频。  \\n\\n> PS：关注公众号【劼哥舍】，我们一起学习成长。  "
    },
    {
        "article_id": "7183718559053250615",
        "cover_image": "",
        "title": "图解设计模式（16种）",
        "brief": "入行几年，可能发现除了发布订阅者模式和单例模式知道些外，其他的模式只是对其名称有所耳闻，只知其名，不知其义。好像这丝毫不影响我搬砖，那么学习总结设计模式的意义在哪里？",
        "user_name": "qb",
        "view_count": 4113,
        "collect_count": 163,
        "comment_count": 15,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/e40655a4d62c0313136fc23d36050e80~300x300.image",
        "category": "前端",
        "content": "入行几年，可能发现除了发布订阅者模式和单例模式知道些外，其他的模式只是对其名称有所耳闻，`只知其名，不知其义`。\\n\\n好像这丝毫不影响我搬砖，那么学习总结`设计模式的意义`在哪里？\\n\\n就好比，盖了个新房，十年八年的屋顶也不会漏雨。但是，万一哪一天，有块瓦破了，需要去屋顶换瓦，那么这个时候，梯子没有，瓦片没有。看着滴滴答答的雨水，是不是莫名的心酸。这个时候，就想，有梯子有瓦片该多好。\\n\\n学习设计模式，就是在晴天准备梯子和瓦片，用不到则已，万一用到了，我们就可以踩着梯子换瓦片。\\n\\n那么该`如何学习设计模式`呢？\\n\\n几年前遇到了某个问题，现在想起，可能具体代码实现是忘记了。但是解决问题的思路，大概还是能七七八八的记起来的。\\n\\n所以，我认为学习设计模式的思想更为重要，具体的实现，每个设计模式可能不止一种实现方式。比如状态模式，我们可以通过修改对象状态进行状态切换，但是，也可以利用数组天然的有序性进行具体行为的组装。\\n\\n本文一万三千字符，阅读比较耗时，可以在右侧点击目录进入具体的设计模式。下面开始正文...\\n\\n## 一、定义\\n是软件设计过程中针对特定问题简洁优雅的解决方案。\\n\\n是经过大量实际项目在很长时间中验证得到的最佳实践。\\n\\n是软件开发前辈在成功和失败中总结的智慧传承。\\n## 二、比喻\\n听到`庄周梦蝶`的成语，就能能感受到庄周和蝴蝶不分你我的优美意境。\\n\\n听到`庖丁解牛`的成语，我们会为庖丁娴熟的技能由衷的赞叹。\\n\\n听到`海市蜃楼`的成语，就知道是一个虚无缥缈的事物。\\n\\n当听到`单例模式`，就知道该模式指的是全局只创建一个实例。\\n\\n当听到`发布订阅模式`，就知道是用来解决事件发布者和事件监听者之间时间解耦关系。\\n\\n当听到`中介者模式`，就知道是用来解耦多个对象之间错综复杂的交互关系。\\n\\n`所以，成语之于成语背后的故事。就如，模式之于背后的解决方案。`\\n\\n## 三、使用时机\\n如果设计模式使用不合时宜，会出现`似是而非、张冠李戴`的情况。\\n\\n如果能深刻的理解各个设计模式的原理，那么就相当于掌握了`大用小用之辩，方可游刃有余`。\\n\\n## 四、使用原则\\n区分可变与不可变的部分，并将变化的地方进行封装。\\n\\n## 五、区分方式\\n设计模式区分不在于其实现方式，而在于其解决的问题场景。\\n\\n## 六、按照结构分类\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/95bd5c5ebe9941b7b4f072b1e001bcdd~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## 七、图示和简单案例说明\\n\\n### （一）创建型\\n#### 1、原型模式\\n我们知道`JavaScript`中几乎所有的数据都是对象，即使不是，通过包装类`Number`、`Boolean`和`String`进行转换。\\n\\n而且，对象的产生可以通过`new 构造函数`的方式产生。那么，构造函数可以通过属性`prototype`的属性，为其定义属性或者方法。\\n\\n通过`new`可以产生多个对象，每个对象都可以访问构造函数`prototype`上的属性和方法。\\n\\n这种模式就可以称为`原型模式`，因为是通过构造函数创建实例对象，`原型模式`属于创建型模式。\\n\\n可以参照如下流程图：\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7885a99adb2f419c9c176f2b210dd473~tplv-k3u1fbpfcp-watermark.image?)\\n\\n举个简单的例子：\\n```\\nvar Person = function (name, hobby) {\\n    this.name = name;\\n    this.hobby = hobby;\\n}\\nPerson.prototype.basicInfo = {\\n    'address': '北京市 海淀区',\\n    'school': '某某大学',\\n    'major': '计算机',\\n}\\n\\nPerson.prototype.sayHi = function () {\\n    console.log('大家好，我是' + this.name, '我的爱好是' + this.hobby);\\n}\\n\\nvar perosn1 = new Person('张三', '踢足球')\\nperosn1.sayHi();\\nconsole.log(perosn1.basicInfo);\\n\\nvar person2 = new Person('李四', '玩游戏')\\nperson2.sayHi();\\nconsole.log(perosn1.basicInfo);\\n\\nvar person3 = new Person('王五', '下象棋')\\nperson3.sayHi();\\nconsole.log(perosn1.basicInfo);\\n\\nvar person4 = new Person('赵六', '看电影')\\nperson4.sayHi();\\nconsole.log(perosn1.basicInfo);\\n```\\n当前例子中，构造函数是`Person`，原型上定义了公共的基本信息`basicInfo`和方法`sayHi`。通过`new`的方式，创建了`person1`、`person2`、`person3`和`person4`。每个对象都可以执行方法`sayHi`，也可以打印公共属性`basicInfo`。\\n\\n#### 2、单例模式\\n\\n一个环境中有且只有一个实例，并且当前环境可以访问到它。\\n\\n往小了说，当前环境可以是一个函数作用域、块级作用域。往大了说可以是全局`window`或者`global`环境。\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/489d186ed5fa43828eecdbf56c47a584~tplv-k3u1fbpfcp-watermark.image?)\\n\\n举个简单的例子：\\n```\\n// 定义可以表示单例模式函数\\nvar SingleInstanceMode = function (fn) {\\n    var instance;\\n    return function () {\\n        return instance || (instance = fn.call(this, arguments))\\n    }\\n}\\n// 定义产生实例的目标函数\\nvar targetFn = function () {\\n    return {\\n        info: '这是唯一一个实例'\\n    }\\n}\\n// 将目标函数传入单例模式中\\nvar createSingleInstance = SingleInstanceMode(targetFn)\\n\\n// 创建实例1\\nvar instance1 = createSingleInstance();\\n// 创建实例2\\nvar instance2 = createSingleInstance();\\n// 判断两实例是否相等\\nconsole.log(instance1 === instance2) // true: 表示全局只有唯一一个实例\\n```\\n当前例子中首先定义可表示单例模式的函数，函数中通过闭包的方式锁定变量`instance`，在执行创建单例的函数时，如果环境中已经存在一个实例则直接返回，否则才去进行实例的创建。这就是单例模式的一种实现方式。\\n\\n#### 3、工厂模式\\n工厂模式指的是，批量创建对象的时候可以避免使用`new` + `构造函数`的方式去暴露创建对象的行为，而是通过工厂模式将创建对象的行为隐藏到工厂函数内部，不仅可以批量的生产对象，而且还可以通过传入参数改变产出产品的形态。\\n\\n画个工厂简单的流程图如下：\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/447e21345c2749c68dc764e249606648~tplv-k3u1fbpfcp-watermark.image?)\\n\\n这里我们不需要关注车间一、二、三和四具体是咋操作的，只需要关系工厂入口我们输入的参数，和工厂出口产出的产品，举个例子如下：\\n```\\n// 定义可以生产服装的工厂\\nvar factory = function (type, height) {\\n    // 定义衬衫、短裤和皮夹克的车间\\n    var workshop = {\\n        1: function (height) {\\n            var obj = new Object()\\n            obj.name = '衬衫'\\n            obj.height = height;\\n            return obj;\\n        },\\n        2: function (height) {\\n            var obj = new Object()\\n            obj.name = '短裤'\\n            obj.height = height;\\n            return obj;\\n        },\\n        3: function (height) {\\n            var obj = new Object()\\n            obj.name = '皮夹克'\\n            obj.height = height;\\n            return obj;\\n        },\\n        4: function (height) {\\n            var obj = new Object()\\n            obj.name = '西装'\\n            obj.height = height;\\n            return obj;\\n        },\\n    }\\n    // 不同的车间进行不同的服装生成\\n    return workshop[type](height)\\n}\\n// 每个车间先生成一件衣服试试机器\\nvar shirt1 = factory(1, '175cm')\\nvar shorts1 = factory(2, '178cm')\\nvar jacket1 = factory(3, '180cm')\\nvar suit1 = factory(4, '185cm')\\n\\n// 机器试着没问题，再批量生成一批衬衫\\nvar shirt1 = factory(1, '172cm')\\nvar shirt2 = factory(1, '173cm')\\nvar shirt3 = factory(1, '174cm')\\nvar shirt4 = factory(1, '175cm')\\nvar shirt5 = factory(1, '176cm')\\nvar shirt6 = factory(1, '177cm')\\nvar shirt7 = factory(1, '178cm')\\nvar shirt8 = factory(1, '179cm')\\n```\\n当前例子中，我们不必知道工厂内部各个车间的具体情况，只需要知道服装编号`1`代表`衬衫`、`2`代表`短裤`、`3`代表`皮夹克`、`4`代表`西装`，然后再告诉工厂穿衣者的身高，即可批量生成出一批衬衫。\\n\\n当然我们也可以根据实际需求对工厂内部进行改造，改造成为我们需要的工厂。\\n\\n### （二）结构型\\n#### 4、装饰者模式\\n\\n先举个例子作为引子，假如小帅刚造了一个手机。\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/82e79bcc67aa4e25a3457b48a3cbf7f3~tplv-k3u1fbpfcp-watermark.image?)\\n\\n小帅看着不够帅，于是加了个带有“帅”字的吊坠。\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4bf4a5a4944b48278e8f6054f5850abe~tplv-k3u1fbpfcp-watermark.image?)\\n\\n其实这个吊坠有没有，手机的功能丝毫不受影响。有了吊坠，小帅觉得会手机看起来更“帅”一点点，手机还是那个手机，人机交互窗口还是窗口触摸屏，并没有变成古老的按键方式。（人机交互的屏幕即是人和手机交互的接口）\\n\\n> 装饰者模式以其不改变原对象，并且与原对象有着相同接口的特点，广泛应用于日常开发和主流框架的功能中。\\n\\n假如我们开发了一个移动端网页，有图书搜索、小游戏、音频播放和视频播放等主要功能，初期，我们并不知道这几个功能用户的使用规律。\\n\\n有一天，产品经理说，我想要各个功能用户的使用规律，并且通过echarts绘制折线图和柱状图，能加吗？\\n\\n这就加......\\n\\n起初:\\n\\n```\\n<button id=\\\"smallGameBtn\\\">小游戏</button>\\n<script>\\n    var enterSmallGame = function () {\\n        console.log('进入小游戏')\\n    }\\n    document.getElementById('smallGameBtn').onclick = enterSmallGame;\\n</script>\\n```\\n通过装饰者模式增加数据埋点之后:\\n```\\n<button id=\\\"smallGameBtn\\\">小游戏</button>\\n<script>\\n     Function.prototype.after= function (afterFn) {\\n        var selfFn = this;\\n        return function () {\\n            var ret = selfFn.apply(this, arguments)\\n            afterFn.apply(this.arguments)\\n            return ret\\n        }\\n    }\\n    var enterSmallGame = function () {\\n        console.log('进入小游戏')\\n    }\\n\\n    var dataLog = function () {\\n        console.log('数据埋点')\\n    }\\n\\n    enterSmallGame = enterSmallGame.after(dataLog)\\n\\n    document.getElementById('smallGameBtn').onclick = enterSmallGame;\\n</script>\\n```\\n\\n定义`Function.prototype.after`函数，其中通过闭包的方式缓存`selfFn`，然后返回一个函数，该函数首先执行`selfFn`，再执行`afterFn`，这里也很清晰的可以看出两个函数的执行顺序。\\n\\n在当前例子中，首先执行进入小游戏的功能，然后，再执行数据埋点的功能。\\n\\n可以看出，加了数据埋点，执行函数是`enterSmallGame`，不加也是。同时，也未对原始函数`enterSmallGame`内部进行修改。\\n\\n#### 5、代理模式\\n先举个例子作为引子，我们的本体是计算器，每天会进行大量的计算。\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/529f6c10059e4caaaa159213a0d7b1da~tplv-k3u1fbpfcp-watermark.image?)\\n\\n我们发现也会有不少重复的计算，我们引入一个代理。\\n\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/956b416fe36041cbb23e511853e4c9c9~tplv-k3u1fbpfcp-watermark.image?)\\n\\n图示中，访问代理进行数据的计算，如果是重复的计算，缓存代理直接返回结果。如果是首次计算，缓存代理将其传递给本体进行计算。\\n\\n> 当本体处于保护、缓存、虚拟或者过滤等情况下时，一个数据不适合被访问或者一个方法不能被直接调用，可以采用代理模式，先创建一个代理（本体对象或者方法的替身），作为访问者和本体之间的中介或者桥梁。\\n\\n再通过代码对比只是用本体进行计算，和使用代理方式进行计算的异同。\\n\\n```\\n// 本体计算乘积\\nvar mult = function(){\\n    var a = 1; \\n    for ( var i = 0, l = arguments.length; i < l; i++ ){ \\n        a = a * arguments[i]; \\n    } \\n    return a; \\n}; \\n// 代理计算乘积\\nvar proxyMult = (function(){ \\n    var cache = {}; \\n    return function(){ \\n        var args = Array.prototype.join.call( arguments, ',' ); \\n        if ( args in cache ){ \\n            return cache[ args ]; \\n        } \\n        return cache[ args ] = mult.apply( this, arguments ); \\n    } \\n})(); \\n```\\n以上是本体和代理，都可以通过传递参数计算乘积，有以下两种访问方式：\\n- 本体计算乘积\\n```\\nconsole.log(mult( 1, 2, 3, 4 )); // 24\\n```\\n计算会得出24的乘积，如果再次计算会再次进行计算，如果数据量比较大的话，会重复计算；\\n- 代理计算乘积\\n```\\nconsole.log(proxyMult( 1, 2, 3, 4 )); // 24\\n```\\n第一次计算会计算出24的乘积，并将其存到cache中，如cache[\\\"1,2,3,4\\\"] = 24,第二次计算的时候，发现cache中有键为\\\"1,2,3,4\\\"的乘积，无需重复计算，直接返回。\\n\\n#### 6、适配器模式\\n先举个两实体不匹配例子：\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f87c6b19509467b9019bbb390adde3b~tplv-k3u1fbpfcp-watermark.image?)\\n\\n假如这两块要契合在一起，怎么办？\\n\\n咱们先给A实体造个适配器，如下：\\n\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/671c81ac22d94e1aae0b2552eeb04fa6~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n再把A实体往右推一下：\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a87e12fff52c4b5787878bd42fadee5f~tplv-k3u1fbpfcp-watermark.image?)\\n\\n通过适配器，咱们就把A实体和B实体结合到了一起了。\\n\\n> 适配器模式是用来解决两个软件实体之间不兼容的问题的设计模式。可以在不改变实体内部结构的情况下，在其中一个实体外层包装一个适配器，再去将两个实体进行配合使用。\\n\\n再看适配器在代码中的例子：有个实体A，需要将实体A传入实体B中，实体B返回其`name`对应的数据，包含名称、地址和年龄。\\n\\n\\n```\\n// 实体A\\nvar instanceA = [{\\n        name: '张三',\\n        address: '北京',\\n        age: 20,\\n    },\\n    {\\n        name: '李四',\\n        address: '天津',\\n        age: 25,\\n    },\\n    {\\n        name: '王五',\\n        address: '河北',\\n        age: 30,\\n    }\\n]\\n// 实体B\\nvar instanceB = function (data, name) {\\n    return data[name]\\n}\\n// 实体A在实体B中进行调用\\nconsole.log(instanceB(instanceA, '张三')) // undefined\\n```\\n\\n这里先定义实体A作为数据，定义实体B作为调用函数，将实体A放入实体B中，我们执行可以发现返回的是`undefined`。\\n\\n此时，我们定义一个适配器。\\n\\n```\\nvar dataAdapter = function (arr) {\\n    return arr.reduce((accumulator, currentValue) => {\\n        accumulator[currentValue['name']] = currentValue\\n        return accumulator\\n    }, {})\\n}\\n```\\n通过适配器，将数组对象转换成`name`作为`key`，`{name:xxx, address:xxx, age:xxx}`作为`value`的对象。\\n\\n然后，将实体A进行适配器的处理，再塞入到实体B中。\\n```\\nconsole.log(instanceB(dataAdapter(instanceA), '张三')) // {\\\"name\\\": \\\"张三\\\", \\\"address\\\": \\\"北京\\\", \\\"age\\\": 20}\\n```\\n这样，通过适配器`dataAdapter`，就可以将实体A在实体B进行使用，实现了两个不同实体之间不兼容的问题。\\n#### 7、组合模式\\n搬了一天砖后，拖着疲惫的身体回家，打开家门...\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4e83c9c32e144deebd9037e981fdce19~tplv-k3u1fbpfcp-watermark.image?)\\n\\n从图中可以看出，开烤箱后的组合行为是烤面包和烤肠。\\n\\n进厨房后的组合行为，是开烤箱后的组合行为、煮鸡蛋和煮咖啡共同组成。\\n\\n回家后的行为，是由关门、开灯、进厨房的组合行为和打开电视共同组成。\\n\\n这样，就可以组成一颗行为树，但是，可以发现，蓝色区域是多个行为的组合，而非行为的自身执行，真正的执行由具体的行为动作完成。\\n\\n我们先定义一个可以返回组合行为对象添加和执行的函数：\\n```\\nvar JointCommand = function () {\\n    return {\\n        commandList: [],\\n        add: function (command) {\\n            this.commandList.push(command)\\n        },\\n        execute: function () {\\n            for (let i = 0, command; command = this.commandList[i++];) {\\n                command.execute();\\n            }\\n        }\\n    }\\n}\\n```\\n`JointCommand`执行后返回的对象表示组合对象，`commandList`表示命令或者行为的组合，`add`用来为组合命令添加命令，`execute`表示组合对象的执行，本质上是调用组合命令列表中的`command.execute()`。\\n\\n其中，`command`也可能是组合对象，执行组合对象的时候，该列表层后续的`command`暂时不执行。会以深度遍历的方式，先执行组合对象的列表命令。依次类推，最终的叶子对象执行完后将执行权交给父级，层层向上，最终会完成整棵树的命令执行。\\n\\n下面我们先从整棵树的叶子对象开始进行分析。\\n\\n**（1）开烤箱后的行为**\\n\\n```\\n// 烤面包和烤肠\\nvar cookieToattCommand = {\\n    execute: function () {\\n        console.log('烤面包')\\n    }\\n}\\nvar roastSausageCommand = {\\n    execute: function () {\\n        console.log('烤香肠')\\n    }\\n}\\n// 开烤箱后的组合行为\\nafterOpenOvenCommand = JointCommand();\\nafterOpenOvenCommand.add(cookieToattCommand);\\nafterOpenOvenCommand.add(roastSausageCommand);\\n```\\n定义烤面包和烤肠的单个对象，包含`execute`方法。\\n\\n再执行`JointCommand`返回打开烤箱组合对象。\\n\\n最后通过`afterOpenOvenCommand.add(cookieToattCommand)`和`afterOpenOvenCommand.add(roastSausageCommand)`的方式为打开烤箱后的组合对象添加烤面包和烤香肠命令。\\n\\n**（2）进入厨房后的行为**\\n```\\nvar boiledEggCommand = {\\n    execute: function () {\\n        console.log('煮鸡蛋')\\n    }\\n}\\nvar makeCoffeeCommand = {\\n    execute: function () {\\n        console.log('煮咖啡')\\n    }\\n}\\n// 进入厨房后的组合行为\\nafterEnterKitchenCommand = JointCommand();\\n\\nafterEnterKitchenCommand.add(afterOpenOvenCommand);\\nafterEnterKitchenCommand.add(boiledEggCommand);\\nafterEnterKitchenCommand.add(makeCoffeeCommand);\\n```\\n定义煮鸡蛋和煮咖啡的单个对象，包含`execute`方法。\\n\\n再执行`JointCommand`返回进入厨房组合对象。\\n\\n和打开烤箱不同的地方在于，通过`afterEnterKitchenCommand.add(afterOpenOvenCommand)`的方式为`commandList`添加的是打开烤箱后的组合对象。\\n\\n最后通过`afterEnterKitchenCommand.add(boiledEggCommand)`和`afterEnterKitchenCommand.add(makeCoffeeCommand)`的方式为进入厨房后的组合对象添加煮鸡蛋和煮咖啡命令。\\n\\n**（3）回家后的行为**\\n```\\nvar closeDoorCommand = {\\n    execute: function () {\\n        console.log('关门')\\n    }\\n}\\nvar turnOnLightCommand = {\\n    execute: function () {\\n        console.log('开灯')\\n    }\\n}\\nvar turnOnTvCommand = {\\n    execute: function () {\\n        console.log('打开电视')\\n    }\\n}\\n// 回家后的组合行为\\nafterGoHomeCommand = JointCommand();\\nafterGoHomeCommand.add(closeDoorCommand);\\nafterGoHomeCommand.add(turnOnLightCommand);\\nafterGoHomeCommand.add(afterEnterKitchenCommand);\\nafterGoHomeCommand.add(turnOnTvCommand);\\n```\\n\\n定义关门、开灯和打开电视的单个对象，包含`execute`方法。\\n\\n再执行`JointCommand`返回回家后的组合对象。\\n\\n最后通过`afterGoHomeCommand.add(closeDoorCommand)`、`afterGoHomeCommand.add(turnOnLightCommand)`、`afterGoHomeCommand.add(afterEnterKitchenCommand)`和`afterEnterKitchenCommand.add(turnOnTvCommand)`的方式为回家后的组合对象添加`关门`、`开灯`、`进入厨房组合对象`和`打开电视`。\\n\\n这里需要注意，进入厨房后的组合对象已经是一棵树了，是回家后组合对象的子树。\\n\\n当执行`afterGoHomeCommand.execute()`后的执行结果是：\\n\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f9c9a80137c4003afae38f90c1a048e~tplv-k3u1fbpfcp-watermark.image?)\\n\\n深度遍历流程图如下：\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/505c248cc8a148f681bb44f07c53dcc2~tplv-k3u1fbpfcp-watermark.image?)\\n\\n**小结**\\n\\n组合模式，在执行根组合对象、节点组合对象和叶子对象时都是`execute`，也就说不管从哪里开始，都可以执行`execute`，这让组合模式的使用变得简单。访问者几乎没有上手成本。简单得像摁个按钮，只需要知道开灯、开电视、开烤箱、咖啡机等设备的开关一样。\\n\\n可以通过`afterEnterKitchenCommand.execute()`进行进入厨房后的组合行为执行。\\n\\n可以通过`afterOpenOvenCommand.execute()`进行打开烤箱后的组合行为执行。\\n\\n也可以通过`turnOnLightCommand.execute()`和`turnOnTvCommand.execute()`进行叶子对象的执行，分别执行了开灯和打开电视的命令。\\n\\n最后抽象组合模式的树形结构：\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc90b8cd602e474d87257f2475ecbc70~tplv-k3u1fbpfcp-watermark.image?)\\n\\n> 组合模式表示的是局部和整体的关系，局部和整体的关系往往是通过树来描述的。树我们知道由根、枝干和叶子构成，同样，抽象的树也是由根节点，节点和叶子节点构成。\\n\\n#### 8、享元模式\\n> 享元模式是一种用于性能优化的模式，其主要方式是通过运用共享技术来实现复杂对象总量的减少。将结构整体合理划分内部状态和外部状态，内部状态是那种不变化的，稳定的，也可以称之为`享元`，外部状态是那种变化的，不定的。\\n\\n先举个例子：餐馆，如果使用一次性筷子，就餐次数增加一次，就需要多一双筷子。\\n\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c75670528b934228a667d82e1a74a9e5~tplv-k3u1fbpfcp-watermark.image?)\\n\\n那么，假如每天`500`个就餐次数，一年就是`500 × 365 = 182500`。\\n\\n用代码实现一次性筷子的创建和销毁情况：\\n```\\n// 筷子序列号\\nvar serialNumber = 1;\\n// 筷子构造函数\\nvar Chopsticks = function (serialNumber) {\\n    this.serialNumber = serialNumber;\\n}\\n// 筷子管理\\nvar chopsticksManager = (function () {\\n    var outerData = []\\n    return {\\n        add: function (count) {\\n            for (var i = 0; i < count; i++) {\\n                outerData.push(new Chopsticks(serialNumber++))\\n            }\\n            return outerData;\\n        },\\n        destroy: function () {\\n            while (outerData.length) {\\n                outerData.pop();\\n            }\\n        },\\n    }\\n})()\\n// 一次性筷子的创建\\nvar chopsticksArr = chopsticksManager.add(182500)\\n// 一次性筷子的销毁\\nchopsticksManager.destroy()\\n```\\n在当前例子中，我们定义了筷子构造函数，然后通过`chopsticksManager`进行筷子的管理。我们不考虑筷子分批次创建和分批次销毁的情况，我们汇总成一次进行处理。通过`chopsticksArr = chopsticksManager.add(182500)`的方式去创建`182500`双筷子，使用后，再通过`chopsticksManager.destroy()`的方式去销毁筷子，这个过程中我们进行了`182500`次筷子的创建。\\n\\n为了减少一次性筷子，使用公筷，我们定义`1000`双公筷。\\n\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b59d2fef89a46b287ba0ecefab3d8c2~tplv-k3u1fbpfcp-watermark.image?)\\n\\n用代码实现使用公筷后，使用公筷和公筷回收的情况：\\n```\\n// 筷子序列号\\nvar serialNumber = 1;\\n// 筷子构造函数\\nvar Chopsticks = function (serialNumber, type) {\\n    this.serialNumber = serialNumber; // 公筷序列号\\n    this.type = type; // 这双公筷的使用状态\\n}\\n// 筷子管理\\nvar chopsticksManager = (function () {\\n    var innerData = [] // 提升为内部状态的享元池\\n    var recycleData = [] // 公筷回收池\\n    return {\\n        // 创建公筷\\n        add: function (count) {\\n            for (var i = 0; i < count; i++) {\\n                innerData.push(new Chopsticks(serialNumber++))\\n            }\\n            return innerData;\\n        },\\n        // 使用公筷\\n        use: function (count) {\\n            for (let i = 0; i < count; i++) {\\n                var item = innerData.pop()\\n                item.type = 'hasUsed' // 标注为已经被使用\\n                recycleData.push(item);\\n            }\\n        },\\n        // 回收公筷\\n        recycle: function () {\\n            let recycleDataLength = recycleData.length\\n            for (let i = 0; i < recycleDataLength; i++) {\\n                var item = recycleData.pop()\\n                item.type = 'hasRecycled'; // 标注为已经被回收\\n                innerData.push(item);\\n            }\\n        },\\n    }\\n})()\\n// 公筷创建，公筷创建是日常客流的二倍，以防客流突然增多\\nvar chopsticksArr = chopsticksManager.add(1000);\\n\\n// 有一天客流325\\nchopsticksManager.use(325); // 筷子的使用\\nchopsticksManager.recycle(); // 筷子的回收\\n\\n// 有一天客流732\\nchopsticksManager.use(732); // 筷子的使用\\nchopsticksManager.recycle(); // 筷子的回收\\n\\n// 有一天客流210\\nchopsticksManager.use(210); // 筷子的使用\\nchopsticksManager.recycle(); // 筷子的回收\\n\\n// 日复一日，年复一年，筷子的使用就从公筷池中使用，洗净消毒回收\\n```\\n\\n在当前例子中，我们定义了筷子构造函数，然后通过`chopsticksManager`进行筷子的管理。通过`chopsticksArr = chopsticksManager.add(1000)`的方式去创建`1000`双公筷，通过`chopsticksManager.use(325)`的方式去使用，使用后再通过`chopsticksManager.recycle()`的方式去洗净消毒回收。\\n\\n那么，在整个升级改造过程中，我们节省了超`十八万双`一次性筷子。\\n\\n一次性筷子是没有享元的情况，使用公筷后，`1000`双公筷相当于`1000`个享元，在公筷池中，我们可以进行公筷的取出，和公筷清洗和消毒后的放回。就相当于，我们在享元池中进行享元的取出和放回。\\n\\n### （三）行为型\\n#### 9、策略模式\\n> 策略模式指的是，定义一系列的算法，把它们一个个的封装起来，通过传递一些参数，使他们可以相互替换。\\n\\n举个周末从家去咖啡馆的例子：\\n\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30a02efd7581438bbbb6c1410207475a~tplv-k3u1fbpfcp-watermark.image?)\\n\\n从家去咖啡馆，有跑步、骑行和漫步的方式。也就是说，从家到咖啡馆，有三种策略可选择。\\n\\n##### （1）策略模式的极简实现**\\n\\n通过对象的键值映射关系，定义策略和具体实现之间的关系：\\n```\\nvar strategies = {\\n    A: xxx,\\n    B: yyy,\\n    C: zzz\\n}\\n```\\n其中，`A`、`B`和`C`指的策略名称，`xxx`、`yyy`和`zzz`指的是具体函数（算法）。\\n\\n##### （2）策略模式的简单案例**\\n\\n**① 工具函数**\\n\\n当项目搭建的过程中，可以通过策略模式，封装常用的优化函数防抖和节流。\\n```\\nconst tools = {\\n    throttle: function (fn, time) {\\n        // ...\\n    },\\n    debounce: function (fn,time) {\\n        // ...\\n    },\\n}\\n```\\n**② 提示样式**\\n`vue`框架下页面中的弱提示`toast`样式，也可以根据类型进行样式的预置，比如，先在`style`中定义预置的样式\\n```\\n<style scoped>\\n     /*@style：defaultActive默认状态下的样式*/\\n    .defaultActive {\\n        background-color: rgba(0, 0, 0, 0.8);\\n        color: #fff;\\n    }\\n    /*@style：successActive成功状态下的样式*/\\n    .successActive {\\n        background-color: #f0f9eb;\\n        color: #67c23a;\\n    }\\n    /*@style：infoActive信息状态下的样式*/\\n    .infoActive {\\n        background-color: #f4f4f5;\\n        color: #909399;\\n    }\\n    /*@style：warningActive警告状态下的样式*/\\n    .warningActive {\\n        background-color: #fdf6ec;\\n        color: #e6a23c;\\n    }\\n    /*@style：errorActive错误状态下的样式*/\\n    .errorActive {\\n        background-color: #fef0f0;\\n        color: #f56c6c;\\n    }\\n</style>\\n```\\n利用`vue`的计算属性，将传入的类型和字符串'Active'拼接组成策略，如'defaultActive'、'successActive'、'infoActive'、'warningActive'和'errorActive'\\n```\\n<script>\\n    export default {\\n        computed: {\\n            className () {\\n                return this.type + 'Active'\\n            }\\n        }\\n    };\\n</script>\\n```\\n在`template`视图端进行\\\"策略\\\"和样式的关联\\n```\\n<template>\\n    <div class=\\\"toast\\\" :class=className>\\n        {{msg}}\\n    </div>\\n</template>\\n```\\n##### 小结\\n\\n策略模式，可以利用对象的键值映射关系以及函数是一等公民的特性，以`key`来作为策略名称，以函数作为值定义具体算法，利用这些`javascript`特性可以更为简单的实现策略模式。\\n\\n#### 10、迭代器模式\\n> 迭代器模式，指的是提供一种方法顺序访问一个聚合对象或者数组中的各种元素，而又不暴露该对象的内部表示。\\n\\n##### （1）内部迭代器\\n内部迭代器是自动的，将回调函数传入迭代器进行执行，访问到每一个元素都会执行传入迭代器中的回调函数。\\n\\n模拟内部迭代器如下：\\n```\\n// 定义数组原型上的mapFn内部迭代器\\nArray.prototype.mapFn = function (callback) {\\n    let arr = this;\\n    let newArr = []\\n    for (let i = 0; i < arr.length; i++) {\\n        newArr[i] = callback(arr[i], i, arr)\\n    }\\n    return newArr\\n}\\n// 定义原始数组\\nvar arr = [1, 2, 3, 4, 5];\\n// 定义回调函数\\nvar callback = val => val * 2;\\n// 执行数组的mapFn方法调用回调函数callback\\nvar newArr = arr.mapFn(callback);\\n// 打印返回值\\nconsole.log(newArr)\\n```\\n`callback`函数可以传入三个参数，第一个参数表示当前的值，第二个参数表示当前索引，第三个参数表示正在操作的数组。返回值为新数组。\\n\\n当前例子中，`callback`指的是`val => val * 2`,通过数组的`mapFn`方法执行`callback`函数，返回值为新的数组`newArr`。\\n\\n在实际的使用中，`Array.prototype.mapFn`的内部实现是看不到的，就像我们看不到数组的操作`map`和`forEach`一样，这里如果将`Array.prototype.mapFn`作为黑盒子。就有如下的流程：\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e08b6652286e493dbcde11c8c3bbfada~tplv-k3u1fbpfcp-watermark.image?)\\n\\n##### （2）外部迭代器\\n外部迭代器是非自动的，提供了`next`方法，需要手动的去执行`next()`以进行下一个元素的访问。\\n```\\n// 定义迭代器生成函数\\nfunction makeIterator(array) {\\n    var nextIndex = 0;\\n    return {\\n        next: function () {\\n            return nextIndex < array.length ? {\\n                value: array[nextIndex++],\\n                done: false\\n            } : {\\n                value: undefined,\\n                done: true\\n            };\\n        }\\n    };\\n}\\n// 产生迭代器\\nvar it = makeIterator(['a', 'b']);\\n\\n// 通过迭代器暴露出来的next方法，外部调用迭代器\\nconsole.log(it.next()) // { \\\"value\\\": \\\"a\\\", \\\"done\\\": false }\\nconsole.log(it.next()) // { \\\"value\\\": \\\"b\\\", \\\"done\\\": false }\\nconsole.log(it.next()) // { \\\"value\\\": undefined, \\\"done\\\": true }\\n```\\n`makeIterator`返回`next`方法，每一次执行都会执行下一个迭代。`done`是否迭代结束，`value`是当前迭代获取到的值。如果`done`为`true`，对应的`value`就是`undefined`。\\n\\n在实际的使用中，`makeIterator`的内部实现是看不到的，这里如果将`makeIterator`作为黑盒子。就有如下的流程：\\n\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ced9cb859ff464291f8e5667ea23d0f~tplv-k3u1fbpfcp-watermark.image?)\\n\\n##### 小结\\n目前`JavaScript`已经内置了多种内部迭代器，比如`forEach`、`map`、`filter`和`reduce`等，内部执行回调函数`function(value, index, currentArr){ xxxx }`对每个访问到的元素进行处理。通过`generate`和`yield`配合使用也可以产生外部迭代器，通过`next()`方法进行下一步的执行。\\n#### 11、发布订阅者模式\\n发布订阅者模式，我们从一条古老的街道说起\\n##### （1）有一条古老的街道\\n有一条古老的街道，有一天，开了一个报社，是关于财经的。（定义一个发布者类`Publish`）\\n\\n我们叫它“财经报社”。（实例化时定义报社名称`publisherName`）\\n\\n它有一张订阅者登记表。（实例化时定义一个包含订阅者名称的登记表`watcherLists`）\\n\\n用户登记表可以记录订阅者的名字。（添加订阅者名的方法`addWatcher`）\\n\\n送报员把报纸送到每一个订阅者手里。（通知订阅者的方法`notify`）\\n\\n订阅者不订阅时，报社可以移出订阅者的名字。（移出订阅者的方法`removeWatcher`）\\n\\n报社万一哪天关门时，会清空订阅者列表。（清空订阅者的方法`清空发布者列表`）\\n\\n上面的每一句话，都代表了一个伪代码，下面具体实现一个发布者类：\\n\\n```\\nclass Publish {\\n    constructor(publisherName) {\\n         // 发布者名称\\n        this.publisherName = publisherName;\\n         // 订阅者列表\\n        this.watcherLists = []\\n    }\\n    // 添加订阅者\\n    addWatcher(watcher) {\\n        this.watcherLists.push(watcher)\\n    }\\n    // 通知订阅者\\n    notify() {\\n        const watcherLists = this.watcherLists.slice()\\n        for (let i = 0, l = watcherLists.length; i < l; i++) {\\n            watcherLists[i].update()\\n        }\\n    }\\n    // 移除订阅者\\n    removeWatcher(watcherName) {\\n        if (!this.watcherLists.includes(watcherName)) {\\n            return;\\n        }\\n        for (let i = 0; i < this.watcherLists.length; i++) {\\n            if (this.watcherLists[i].watcherName === watcherName) {\\n                this.watcherLists[i].removePublishers(this.publisherName)\\n                this.watcherLists.splice(i, 1)\\n            }\\n        }\\n    }\\n    // 清空订阅者列表\\n    clearWatchers() {\\n        const watcherLists = this.watcherLists.slice()\\n        for (let i = 0, l = watcherLists.length; i < l; i++) {\\n            watcherLists[i].removePublishers(this.publisherName)\\n        }\\n\\n        this.watcherLists = []\\n    }\\n}\\n```\\n\\n财经报馆开业，我们`new`个报馆实例。\\n```\\nconst financialNewspaper = new Publish('财经报社')\\n```\\n##### （2）来了两个财经爱好者\\n有一天来了两个财经爱好者。（定义一个订阅者类`Watcher`）\\n\\n订阅者是有名称的。（实例化时定义报社名称`watcherName`）\\n\\n订阅者订阅的可能不止一家报社。（实例化时定义一个包含报社（发布者）的笔记本`publishers`）\\n\\n订阅者收到报纸后的行为。（实例时定义定义订阅者的行为（事件）`fn`）\\n\\n订阅者是通过什么样的方式接收报纸的。（定义接收报纸（发布者发布的消息）的途径，这里统一为信箱方式`update`）\\n\\n订阅者可以订阅其他报社的报纸。（添加发布者的方式`addPublisher`）\\n\\n订阅者也可以取消某家报社的报纸。（移除发布者的方式`removePublishers`）\\n\\n订阅者离开这条街道时，清空报社名称的笔记本。（清空发布者列表`clearPublishers`）\\n\\n上面的每一句话，都代表了一个伪代码，下面具体实现一个订阅者类：\\n```\\nclass Watcher {\\n    constructor(watcherName, fn) {\\n        this.watcherName = watcherName; // 订阅者名称\\n        this.publishers = [] // 发布者列表\\n        this.fn = fn // 监听者收到消息后的反应（事件）\\n    }\\n    // 更新自身事件(行为)\\n    update() {\\n        this.fn();\\n    }\\n    // 添加发布者\\n    addPublisher(publisher) {\\n        this.publishers.push(publisher)\\n    }\\n    // 移除发布者\\n    removePublishers(publisherName) {\\n        if (!this.publishers.includes(publisherName)) {\\n            return;\\n        }\\n        for (let i = 0; i < this.publishers.length; i++) {\\n            if (this.publishers[i].publisherName === publisherName) {\\n                this.publishers[i].removeWatcher(this.watcherName) // 通知发布者删除订阅者\\n                this.publishers.splice(index, 1) // 从发布者列表中清除发布者\\n            }\\n        }\\n    }\\n    // 清空发布者列表\\n    clearPublishers() {\\n        const publishers = this.publishers.slice()\\n        for (let i = 0, l = publishers.length; i < l; i++) {\\n            publishers[i].removeWatcher(this.watcherName)\\n        }\\n\\n        this.publishers = []\\n    }\\n}\\n```\\n关于订阅者，我们`new`两个订阅者实例。\\n```\\nconst watcherA = new Watcher('watcherA', function () {\\n    console.log('喝着茶，看着报纸')\\n})\\n// 定义订阅者B\\nconst watcherB = new Watcher('watcherB', function () {\\n    console.log('大清早，晨读报纸')\\n})\\n```\\n\\n财经报刊添加了两个订阅者`watcherA`和`watcherB`。\\n```\\nfinancialNewspaper.addWatcher(watcherA)\\nfinancialNewspaper.addWatcher(watcherB)\\n// 可以打印发布者和发布者收集的订阅者列表\\nconsole.log(financialNewspaper, financialNewspaper.watcherLists);\\n```\\n\\n\\n两个细心的订阅者把财经报刊记录在了小本本上。\\n```\\nwatcherA.addPublisher(financialNewspaper);\\nwatcherB.addPublisher(financialNewspaper);\\n// 可以打印订阅者和订阅者订阅的报刊种类\\nconsole.log(watcherA, watcherA.publishers);\\nconsole.log(watcherB, watcherB.publishers);\\n```\\n##### （3）订阅者收到报纸\\n第二天，送报员就把报纸投进了门口邮箱（相当于财经报刊进行了消息发布）\\n```\\nfinancialNewspaper.notify()\\n// watcherA和watcherB收到报纸（消息）后，就触发了他们的行为\\n// watcherA：'喝着茶，看着报纸'\\n// watcherB：'大清早，晨读报纸'\\n```\\n##### （4）财经报社又来了个订阅者\\n有一天财经报社来了个`watcherC`，也订阅了报刊。\\n\\n我们再`new`个订阅者`watcherC`:\\n```\\nconst watcherC = new Watcher('watcherC', function () {\\n    console.log('大晚上，熬夜看报纸')\\n})\\n```\\n报社把订阅者`watcherC`记录在了登记表上。\\n```\\nfinancialNewspaper.addWatcher(watcherC)\\n```\\n\\n同样细心的订阅者`watcherC`也把财经报社记录在了小本本上。\\n```\\nwatcherC.addPublisher(financialNewspaper);\\n```\\n\\n##### （5）街道上又开了家体育类报社\\n有一天街道上又开了个体育报社。\\n\\n我们先`new`一个体育报社。\\n```\\nconst sportsNewspaper = new Publish('体育报社')\\n```\\n`watcherA`和`watcherC`也是体育爱好者，所以订阅了体育报刊。\\n\\n体育报社需要登记两个订阅者的姓名。\\n```\\nsportsNewspaper.addWatcher(watcherA)\\nsportsNewspaper.addWatcher(watcherC)\\n```\\n\\n这两订阅者，又各自把体育报社记录在了小本本上。\\n```\\nwatcherA.addPublisher(sportsNewspaper);\\nwatcherC.addPublisher(sportsNewspaper);\\n\\n```\\n##### （6）有订阅者取消体育报刊的报纸\\n订阅者`watcherC`本来不喜欢运动，起初订阅体育报刊纯粹为了凑热闹，三天的劲头已过，他决定取消体育报刊的报纸。\\n```\\nwatcherC.removePublishers('sportsNewspaper')\\n```\\n##### （7）有订阅者要离开这条街道\\n有一天，`watcherA`要出国留学，所以就从小本本上划掉了记录的报刊名称，并且通知报社取消报纸的订阅，第二天，送报员就没再给`watherA`送报纸。\\n```\\nwatcherA.clearPublishers()\\n```\\n\\n这里`watcherC`清掉小本本上名称的同时，也会通知到报社，体育报社和财经报社同样会在等级表上清除`watcherC`的名称。\\n```\\nclearPublishers() {\\n    const publishers = this.publishers.slice()\\n    for (let i = 0, l = publishers.length; i < l; i++) {\\n        publishers[i].removeWatcher(this.watcherName)\\n    }\\n\\n    this.publishers = []\\n}\\n```\\n##### （8）有报社要关门\\n岁月如梭，多年过去啦。\\n\\n随着移动互联网的兴起，纸媒受到影响，这条街道的财经报社决定关门。\\n```\\nfinancialNewspaper.clearWatchers()\\n```\\n\\n第二天就不再给登记表上的订阅者送报啦，订阅者收到消息后，从小本本上划掉了财经类报刊的名字。\\n```\\nclearWatchers() {\\n    const watcherLists = this.watcherLists.slice()\\n    for (let i = 0, l = watcherLists.length; i < l; i++) {\\n        watcherLists[i].removePublishers(this.publisherName)\\n    }\\n\\n    this.watcherLists = []\\n}\\n```\\n\\n*这里描述了发布者的产生、订阅者的产生、发布者发布消息的方式、订阅者接受消息的途径、订阅者接收到消息的行为、发布者的新增、订阅者的新增、发布者的离开和订阅者的离开等关系和逻辑。代码具体的执行结果，还需要学友自行运行验证。*\\n\\n##### 小结\\n发布订阅者模式又叫观察者模式，它定义了对象间的一种一对多的关系。这种关系，既指一个发布者可以对应多个订阅者，又可以指一个订阅者也订阅多个发布者的消息。\\n\\n#### 12、命令模式\\n> 命令者模式，指的是执行主体可以执行某些特定事件，并且，支持队列等待、调起执行和事件撤销等行为。\\n\\n假如有个五子棋的场景，黑棋是真人，白棋是电脑，黑棋先落子，可以悔棋。\\n\\n我们先来定义一个执行者主体类：\\n```\\nclass CommandSubject {\\n    constructor(name) {\\n        // 命令执行者\\n        this.executer = name;\\n        // 命令所在位置的列表\\n        this.posList = []\\n        // 演算步骤\\n        this.computedStep = []\\n    }\\n\\n    // 命令执行函数\\n    execute(pos /*落子位置*/ ) {\\n        // 执行命令\\n        console.log(`棋子落在了[${pos[0]}, ${pos[1]}]的位置`)\\n        // 记录位置\\n        this.posList.push(pos)\\n    }\\n    // 撤回操作\\n    undo(step /* 撤回步数*/ ) {\\n        // 撤回命令\\n        for (let i = 0; i < step; i++) {\\n            // 撤回的位置\\n            const pos = this.posList.pop();\\n            console.log()\\n            // 撤回的操作\\n            console.log(`撤回[${pos[0]}, ${pos[1]}]位置的棋子`)\\n        }\\n    }\\n    // 执行演算步骤\\n    executeComputedCommand() {\\n        // 请自行实现吆\\n    }\\n\\n}\\n```\\n我们`new`一个黑棋执行者。\\n```\\nvar blackSubject = new CommandSubject('黑棋执行者');\\n```\\n假如黑棋执行者，和电脑共对弈 `4` 步。\\n```\\nblackSubject.execute([3, 4])\\nblackSubject.execute([4, 2])\\nblackSubject.execute([5, 3])\\nblackSubject.execute([5, 4])\\nconsole.log(blackSubject.posList)\\n```\\n此时的局势如图：\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6deaefecd5744ebaa9a49aad399c65f1~tplv-k3u1fbpfcp-watermark.image?)\\n\\n黑棋执行者觉得下错了，想悔棋 `2` 步。\\n```\\nblackSubject.undo(2)\\n```\\n此时的局势如图：\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/049d40dbb29b4e428c16c8c157bc1357~tplv-k3u1fbpfcp-watermark.image?)\\n\\n下棋时可能我们还会想一下接下来会走那几步，涉及到演算，假如我们演算了 `3` 步，那么这 `3` 步不是一下就落子的，而是等白棋落子后，黑棋执行者才能落子，这就是命令执行的队列问题。请自行实现吆~\\n\\n如果感兴趣，也可以再`new`一个白棋执行者，互动下棋吆~\\n\\n#### 13、模板方法模式\\n模板方法模式由父类和子类构成，通过父类确定整个系统的执行流程，子类负责具体的流程实现，可以通过继承的方式重写父类的某些方法，但是不能改变功流程的执行顺序。体现了抽象与实现分离编程思想。\\n\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/54e5603b5d08408e855ed74220932c98~tplv-k3u1fbpfcp-watermark.image?)\\n\\n图中，父类控制了整个系统的执行流程，子类负责具体的流程实现。\\n\\n##### （1）经典案例饮料冲制流程\\n我们知道，冲制饮料一般有以下步骤：<br>\\n①把水煮沸<br>\\n②用沸水冲泡饮料<br>\\n③把饮料倒进杯子<br>\\n④加调料<br>\\n示例代码：<br>\\n\\n        // 父类：实现泡制饮料的子类功能的流程，本次功能有4个流程，如下：\\n        var Beverage = function () {}\\n        // 然后，我们梳理冲制饮料的流程\\n        Beverage.prototype.boilWater = function () {\\n            console.log('公共流程：把水煮沸')\\n        }\\n        Beverage.prototype.brew = function () {\\n            throw new Error( '子类必须重写 brew 方法' );\\n        }\\n        Beverage.prototype.pourInCup = function () {\\n            throw new Error( '子类必须重写 pourInCup 方法' );\\n        }\\n        Beverage.prototype.addCondiments = function () {\\n            throw new Error( '子类必须重写 addCondiments 方法' );\\n        } \\n        // 冲制饮料\\n        Beverage.prototype.init = function () {\\n            this.boilWater();\\n            this.brew();\\n            this.pourInCup();\\n            this.addCondiments();\\n        }\\n        // 子类：具体实现泡制一杯茶的的流程\\n        var Tea = function () {}\\n        Tea.prototype = new Beverage();\\n        Tea.prototype.brew = function () {\\n            console.log('用水泡茶');\\n        }\\n        Tea.prototype.pourInCup = function () {\\n            console.log('将茶倒进杯子');\\n        }\\n        Tea.prototype.addCondiments = function () {\\n            console.log('加冰糖');\\n        }\\n        var tea = new Tea();\\n        tea.init()\\n&emsp;&emsp;从以上例子可以看出，父类已经制定了泡制饮料的流程，并且确定了不管哪种饮料都需要把水煮沸的公共方法`boilWater`，至于`brew`、`pourInCup`和`addCondiments`泡制茶、黑咖啡、牛奶和豆浆等饮料都有所不同，由子类去具体实现。\\n\\n抽象的父类已经产生，接下来就是泡制茶的子类的具体实现，子类首先继承父类的泡制饮料的确定流程。其中，将水烧开继承父类，`brew`、`pourInCup`和`addCondiments`方法由子类进行重写，至此，泡茶的流程已经完成，黑咖啡、牛奶和豆浆等饮料同理。\\n\\n以上例子执行结果是：\\n\\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/752b89b2caa245c5a575097f7ca49208~tplv-k3u1fbpfcp-watermark.image)\\n\\n##### （2）框架案例`vue`的主流程\\n`vue2.0`是最受欢迎的前端框架之一，以其小而美的特点，成为众多前端小伙伴的首选。使用`vue`的过程中，全局方法的定义、生命周期的使用、组件的封装和路由的实现等都感觉隐隐约约都被一种力量牢牢锁定，`vue`各个功能在使用的过程有序进行着。翻看`vue`源码时才发现：\\n```\\nimport { initMixin } from './init'\\nimport { stateMixin } from './state'\\nimport { renderMixin } from './render'\\nimport { eventsMixin } from './events'\\nimport { lifecycleMixin } from './lifecycle'\\nimport { warn } from '../util/index'\\n\\nfunction Vue (options) {\\n  if (process.env.NODE_ENV !== 'production' &&\\n    !(this instanceof Vue)\\n  ) {\\n    warn('Vue is a constructor and should be called with the `new` keyword')\\n  }\\n  this._init(options)\\n}\\n// Vue类由各种initMixin、stateMixin、eventsMixin、lifecycleMixin和renderMixin的方法有序的混入各种功能\\ninitMixin(Vue)\\nstateMixin(Vue)\\neventsMixin(Vue)\\nlifecycleMixin(Vue)\\nrenderMixin(Vue)\\n\\nexport default Vue\\n```\\n我们发现，`Vue`本质上是一个构造函数，在其`new`的时候，会执行内部唯一的初始化方法`this._init`。\\n\\n初始化方法在`initMixin`中实现：\\n```\\n\\n  Vue.prototype._init = function (options?: Object) {\\n    const vm: Component = this\\n    // ...\\n    initLifecycle(vm)\\n    initEvents(vm)\\n    initRender(vm)\\n    callHook(vm, 'beforeCreate')\\n    initInjections(vm) // resolve injections before data/props\\n    initState(vm)\\n    initProvide(vm) // resolve provide after data/props\\n    callHook(vm, 'created')\\n    // ...\\n    if (vm.$options.el) {\\n      vm.$mount(vm.$options.el)\\n    }\\n  }\\n}\\n```\\n可以看出，初始化`this._init`方法是由如图的一些方法确定有序执行的。`vue`的创建过程中的初始化方法`this_init`就是一种模板方法模式。\\n\\n##### 小结\\n模板方法模式是众多设计模式之一，解决的主要业务场景是父类创建确定的子类功能或者任务的执行流程，子类继承的时候可以重写父类的某些方法。\\n\\n#### 14、职责链模式\\n> 职责链模式，指的是由拥有处理能力的职责节点对象组成一个链条，一个请求从链条的开始或者中间进入，都有机会被后续的职责节点对象处理。进入职责链的请求，会沿着后续链条被传递，直到请求被处理才会终止传递。\\n\\n身在帝都，每天挤地铁去搬砖，发现月初、月中和月末地铁的票价都不一样。\\n\\n查看规则才发现，乘车消费超过`150元`打五折，超过`100元`打八折，不足`100元`不打折。\\n\\n这里通过职责链模拟一个处理订单金额的功能，该方法传入消费总金额和当前车程的常规票价。\\n\\n先看流程图：\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a8500341a8b84043bd62e08e09c96f94~tplv-k3u1fbpfcp-watermark.image?)\\n\\n先进入总消费大于`150元`的流程，当前消费金额是否大于`150元`，返回金额，请求结束。如果不是，进入下一个总消费大于`100元的`流程。\\n\\n进入总消费大于`100元`的流程，当前消费金额是否大于`100元`，返回金额，请求结束。如果不是，进入下一个总消费不足`100元的`流程。\\n\\n在总消费不足`100元的`流程中，所有的请求都会被处理。\\n\\n下面进行具体的代码实现：\\n```\\n// 1、定义各职责节点对象\\n// 定义超过150元的职责节点对象\\nvar consumption150 = function (consumption, fare) {\\n    if (consumption > 150) {\\n        console.log(`地铁总消费大于150元，本次${fare}元的票价折扣价${fare * 0.5}`);\\n    } else {\\n        return 'nextProcess'; // 传递给下一个流程\\n    }\\n};\\n// 定义超过100元的职责节点对象\\nvar consumption100 = function (consumption, fare) {\\n    if (consumption > 100) {\\n        console.log(`地铁总消费大于100元，本次${fare}元的票价折扣价${fare * 0.8}`);\\n    } else {\\n        return 'nextProcess'; // 传递给下一个流程\\n    }\\n};\\n// 定义不足100元的职责节点对象\\nvar consumptionNormal = function (consumption, fare) {\\n    console.log(`地铁总消费不足100元，本次${fare}元的票价依然收费${fare}元`);\\n};\\n\\n// 2、设置链条构造函数\\nvar Chain = function (selfFn) {\\n    this.selfFn = selfFn; // 自身函数\\n    this.process = null; // 下一个职责节点\\n};\\nChain.prototype.setNextProcess = function (process) {\\n    return this.process = process; // 设置当前节点对象的下一个节点对象\\n};\\nChain.prototype.handleRequest = function () {\\n    // 执行自身函数，并返回执行结果\\n    var ret = this.selfFn.apply(this, arguments);\\n    // 返回nextProcess表示当前职责节点不能处理请求，此时将请求交个下一个职责节点\\n    if (ret === 'nextProcess') {\\n        return this.process && this.process.handleRequest.apply(this.process, arguments);\\n    }\\n    return ret;\\n};\\n// 创建节点，包含自身selfFn和是否成功请求的标志nextProcess\\nvar chainconsumption150 = new Chain(consumption150);\\nvar chainconsumption100 = new Chain(consumption100);\\nvar chainconsumptionNormal = new Chain(consumptionNormal);\\n\\n// 3、设置节点间的链条关系，形成职责链\\nchainconsumption150.setNextProcess(chainconsumption100);\\nchainconsumption100.setNextProcess(chainconsumptionNormal);\\n```\\n##### （1）职责链可以从任意节点进入\\n现在可以通过`chainconsumption150.handleRequest(120, 8)`的方式进入到职责链的第一个职责节点对象中。\\n\\n也可以通过`chainconsumption100.handleRequest(120, 8)`的方式进入到职责链的第二个职责节点对象中。\\n\\n##### （2）职责链可以进行扩展\\n假如，总消费超过`300元`以后，可以打四折。\\n\\n①定义职能节点对象\\n```\\nvar consumption300 = function (consumption, fare) {\\n    if (consumption > 300) {\\n        console.log(`地铁总消费大于300元，本次${fare}元的票价折扣价${fare * 0.4}`);\\n    } else {\\n        return 'nextProcess'; // 传递给下一个流程\\n    }\\n};\\n```\\n②创建链条节点\\n\\n```\\nvar chainconsumption300 = new Chain(consumption300);\\n```\\n③把节点塞入到链条中\\n```\\nchainconsumption300.setNextProcess(chainconsumption150);\\n```\\n\\n##### 小结\\n职责链模式，支持链条长度的扩展，也支持在链条中进入的位置。\\n\\n#### 15、中介者模式\\n> 中介者模式的作用就是解决对象与对象之间错综复杂的交互关系，增加一个中介者以后，所有相关的对象都通过中介者对象来通信，当一个对象发生改变后，只需要通知中介者对象即可。\\n\\n##### （1）一个卖主，多个买主\\n假设有`卖家A`有一套`面积：100平米，价格：20000元/平米`的房子急需出售，他目前知道有三个买主在找房，对应关系如图：\\n\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3fa9432920e4ca4bcec8f33f977b28e~tplv-k3u1fbpfcp-watermark.image?)\\n\\n通过代码实现卖家找买家：\\n```\\n// 卖家类\\nvar Seller = function (name, info) {\\n    this.name = name;\\n    this.info = info;\\n}\\n// 卖家找买家的函数\\nSeller.prototype.match = function (buyer) {\\n    // 定义买家要求\\n    const buyerDemand = buyer.demand;\\n    // 获取需求数字\\n    const reg = /\\\\d+/\\n    // 1、买家的要求\\n    let buyerRequestArea = buyerDemand.area.match(reg);\\n    buyerRequestArea = parseInt(buyerRequestArea);\\n    let buyerRequestprice = buyerDemand.price.match(reg);\\n    buyerRequestprice = parseInt(buyerRequestprice);\\n    // 2、卖家的条件\\n    let sellerOwnArea = this.info.area.match(reg);\\n    sellerOwnArea = parseInt(sellerOwnArea);\\n    let sellerOwnprice = this.info.price.match(reg);\\n    sellerOwnprice = parseInt(sellerOwnprice);\\n    return sellerOwnArea >= buyerRequestArea && sellerOwnprice <= buyerRequestprice;\\n}\\n// 买家类\\nvar Buyer = function (name, demand) {\\n    this.name = name;\\n    this.demand = demand;\\n}\\n\\n// 定义卖家\\nvar sellA = new Seller('卖家A', {\\n    area: '100平米', // 卖家尺寸\\n    price: '20000元/平米' // 卖家要价\\n});\\n\\nvar buyerX = new Buyer('买家X', {\\n    area: '110平米', // 买家要求尺寸\\n    price: '10000元/平米' // 买家最高愿意支付\\n})\\nvar buyerY = new Buyer('买家Y', {\\n    area: '120平米', // 买家要求尺寸\\n    price: '30000元/平米' // 买家最高愿意支付\\n})\\nvar buyerZ = new Buyer('买家Z', {\\n    area: '99平米', // 买家要求尺寸\\n    price: '30000元/平米' // 买家最高愿意支付\\n})\\n// 卖家开始找买主\\nconsole.log(sellA.match(buyerX)); // true：没找到\\nconsole.log(sellA.match(buyerY)); // true：没找到\\nconsole.log(sellA.match(buyerZ)); // true：找到了\\n```\\n\\n当前例子中，先定义卖家类，并为卖家定义`match`方法去匹配买家，如果其售卖面积大于买家要求，且售卖价格低于买家最高愿意支付，我们认为该买主是意向客户。\\n\\n当前例子中刚好找到第三个`买家Z`的时候，就找到了。但是实际情况可能是找了几十个也没找到合适的意向客户。\\n\\n##### （2）多个卖主，多个买主\\n假设又有`卖主B`和`卖主C`也加入了卖方行列中，此时的对应关系如图：\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36c9c03734d3421fa5c603845d460fa3~tplv-k3u1fbpfcp-watermark.image?)\\n\\n如果，我们依然按照以上的方式为`卖主B`和`卖主C`寻找`买主`，那么，此时的对应关系就已经开始复杂起来。如果有成千上万个`卖主`和`买主`在进行交易的匹配，交易状况就更加复杂，一个卖主可能会和几十个买主沟通筛选，一个买主也可能和几十个卖主沟通筛选。\\n\\n这个时候，就有必要通过中介者模式进行改造了，为了展示主要逻辑，以下去掉价格和平米单价的单位。\\n```\\n// 卖家类\\nvar Seller = function (name, info) {\\n    this.name = name;\\n    this.info = info;\\n}\\n\\n// 买家类\\nvar Buyer = function (name, demand) {\\n    this.name = name;\\n    this.demand = demand;\\n}\\n\\n// 引入中介者\\nvar broker = (function () {\\n    var sellerList = [];\\n    var buyerList = [];\\n    var operations = {}\\n    operations.addSellers = function (seller) {\\n        sellerList.push(seller)\\n    }\\n\\n    operations.addBuyers = function (buyer) {\\n        buyerList.push(buyer)\\n    }\\n\\n    operations.findBuyer = function (seller) {\\n        const result = []\\n        // 遍历所有的买家\\n        buyerList.map(v => {\\n            console.log(v.demand, seller);\\n            if (seller.info.price <= v.demand.price && seller.info.area >= v.demand.area) {\\n                result.push(v);\\n            }\\n        })\\n        return result\\n    }\\n\\n    operations.findSeller = function (buyer) {\\n        const result = []\\n        // 遍历所有的买家\\n        sellerList.map(v => {\\n            if (v.info.price <= buyer.demand.price && v.info.area >= buyer.demand.area) {\\n                result.push(v);\\n            }\\n        })\\n        return result;\\n    }\\n\\n    return operations;\\n})()\\n\\n// 定义卖家，并将其添加到中介者卖家列表中\\nvar sellA = new Seller('卖家A', {\\n    area: 100, // 卖家尺寸\\n    price: 20000 // 卖家要价\\n});\\nvar sellB = new Seller('卖家B', {\\n    area: 90, // 卖家尺寸\\n    price: 18000 // 卖家要价\\n});\\n\\nvar sellC = new Seller('卖家C', {\\n    area: 120, // 卖家尺寸\\n    price: 22000 // 卖家要价\\n});\\n\\nbroker.addSellers(sellA)\\nbroker.addSellers(sellB)\\nbroker.addSellers(sellC)\\n\\n// 定义买家，并将其添加到中介者买家列表中\\nvar buyerX = new Buyer('买家X', {\\n    area: 110, // 买家要求尺寸\\n    price: 10000 // 买家最高愿意支付\\n})\\nvar buyerY = new Buyer('买家Y', {\\n    area: 80, // 买家要求尺寸\\n    price: 30000 // 买家最高愿意支付\\n})\\nvar buyerZ = new Buyer('买家Z', {\\n    area: 100, // 买家要求尺寸\\n    price: 30000 // 买家最高愿意支付\\n})\\n\\nbroker.addBuyers(buyerX)\\nbroker.addBuyers(buyerY)\\nbroker.addBuyers(buyerZ)\\n```\\n例子中，我们除了定义卖家类和买家类，我们还引入了中介者，中介者拥有卖家信息列表，也拥有买家信息列表。当有卖家需要卖方时，可以将房屋信息和个人姓名留给中介者，中介者将其推入到卖家信息列表中。当有买家需要买房时，可以将购买需求留给中介者，中介者将其推入到买家需求列表中。\\n\\n有一天，`卖家A`告诉中介者，他着急用钱，他的房子着急出手。于是中介者开始帮其寻找买主：\\n```\\nvar buyers = broker.findBuyer(sellA)\\n```\\n\\n有一天，`买家Z`告诉中介者，他现在手头有钱了，想全款买套房。于是中介者开始帮其寻找买主：\\n```\\nvar sellers = broker.findSeller(buyerZ)\\n```\\n##### 小结\\n我们发现，引入中介者以后，卖家和买家再也不用去为寻找买家或者卖家而烦恼，中介者拥有大量的卖主和买主信息，为其快速精准匹配。这大概也是中介这个职业兴起，并且长盛不衰的原因之一。\\n#### 16、状态模式\\n> 状态模式，指的是事物内部状态的变化，会导致事物具体行为的变化。并且，状态的切换可以是循环的。最简单的例子是生活中的开关，基本都是状态模式的使用。\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/958d7c7cec104efb90ddbf36258b61ba~tplv-k3u1fbpfcp-watermark.image?)\\n\\n##### （1）利用实例对象的切换\\n```\\n// 定义灯类\\nvar Light = function () {\\n    this.currState = stateManager.off; // 灯的状态\\n    this.button = null; // 开关\\n};\\nLight.prototype.init = function () {\\n    var button = document.createElement('button'),\\n        self = this;\\n    button.innerHTML = '关灯';\\n    this.button = document.body.appendChild(button);\\n    this.button.onclick = function () {\\n        self.currState.changeState.call(self); // 把请求委托给 stateManager 状态机\\n    }\\n};\\n// 定义灯的状态管理对象\\nvar stateManager = {\\n    off: {\\n        changeState: function () {\\n            this.button.innerHTML = '开灯';\\n            this.currState = stateManager.on;\\n        }\\n    },\\n    on: {\\n        changeState: function () {\\n            this.button.innerHTML = '关灯';\\n            this.currState = stateManager.off;\\n        }\\n    }\\n};\\n// 实例化灯\\nvar light = new Light();\\n// 登初始化\\nlight.init();\\n```\\n在当前例子中，首先定义灯类`Light`，其中有属性`currState`表示当前状态，`button`表示开关。定义的`init`方法会首先创建开关，再为开关绑定切换开关状态的函数`changeState`。\\n\\n定义的状态管理对象中包含属性`off`和`on`的具体行为对象，每个行为的执行都是通过其中的`changeState`函数来实现，该函数触发时就会将当前灯的状态进行切换。\\n##### （2）利用数组的有序性\\n```\\n// 定义灯的类\\nvar Light = function () {\\n    this.currentIndex = 0; // 设置初始索引\\n    this.button = null; // 开关\\n};\\nLight.prototype.init = function () {\\n    var button = document.createElement('button'),\\n        self = this;\\n    button.innerHTML = '关灯';\\n    this.button = document.body.appendChild(button);\\n    this.button.onclick = function () {\\n        excuteStateFn(self);\\n    }\\n};\\n// 定义状态状态切换列表\\nvar stateList = [\\n    function changeState(light) {\\n        light.button.innerHTML = '开灯';\\n    },\\n    function changeState(light) {\\n        light.button.innerHTML = '关灯';\\n    }\\n]\\n// 定义状态切换执行函数\\nfunction excuteStateFn(light) {\\n    light.currentIndex >= stateList.length && (light.currentIndex = 0); // 进行边界状态的控制\\n    stateList[light.currentIndex++](light) // 切换状态\\n\\n}\\n// 实例化灯\\nvar light = new Light();\\n// 灯进行初始化\\nlight.init();\\n```\\n\\n在当前例子中，首先定义灯类`Light`，其中有属性`currentIndex`表示行为对应的索引，`button`表示开关。定义的`init`方法会首先创建开关，再为开关绑定切换开关状态的函数`excuteStateFn(self)`。\\n\\n定义的状态切换列表中`stateList`包含数组元素`off`和`on`的具体行为函数。\\n\\n再定义行为切换执行函数`excuteStateFn`，每个行为的执行都是通过执行当前索引对应的行为函数`stateList[light.currentIndex++](light)`来实现的，通过修改当前索引的值来切换下一次执行的状态索引。\\n##### 小结\\n状态模式的实现不止一种实现思路，可以利用行为函数执行时修改当前实例对象的状态实现，也可以利用数组天然的有序性通过索引的改变指向对应的执行函数，当然，还可能有其他实现方式。只要遵循状态模式`状态的切换可以是循环的`，任何实现都是正确的。\\n\\n## 总结\\n以上简单介绍了十六种设计模式，当然除此之外，还有其他的设计模式。也许，不远的将来，会有新的，被众多人所承认的设计模式产生。\\n\\n通过以上介绍我们可以先略微掌握设计模式的`道`，不断`修道`，终会将设计模式`内化`，在合适的场景，可能会起到事半功倍的效果，扳子、钳子、改锥、电钻我们都有，万一哪天要打个孔，上个螺丝，就变得非常简单。\\n\\n学习设计模式也是，在某些错综复杂的场景中，拿出一两个设计模式思想，高效处理业务难点，就如打个孔，上个螺丝那么简单。\\n\\n参考资料\\n--\\n《JavaScript》设计模式与开发实践\\n\\n写在最后\\n--\\n`2023年`，新的一年，新的征程，希望各位学友`狡兔三窟`，即使被裁也能很快找到下一个`窟`，一起加油。\\n\\n`2023年`，希望自己能够有高质量的文章输出，持续分享。\\n\\n文中纰漏在所难免，`如有纰漏请贵手留言`。\\n\\n本文如有帮助，`点赞`就是对我最大的肯定和支持吆❤\\n\\n\\n"
    },
    {
        "article_id": "7184419253087535165",
        "cover_image": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78c6fe47bc074d678e064d194b9828fb~tplv-k3u1fbpfcp-watermark.image?",
        "title": "微前端方案 qiankun 的样式隔离能不用就别用吧，比较坑",
        "brief": "qiankun 是主流的微前端方案，其他的还有京东的 micro-app、腾讯的 wujie 等。 微前端就是可以一个页面跑多个 vue、react 甚至 jquery 等不同项目，它之间的 JS、C",
        "user_name": "zxg_神说要有光",
        "view_count": 13979,
        "collect_count": 199,
        "comment_count": 57,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/4e9e751e2b32fb8afbbf559a296ccbf2~300x300.image",
        "category": "前端",
        "content": "qiankun 是主流的微前端方案，其他的还有京东的 micro-app、腾讯的 wujie 等。\\n\\n微前端就是可以一个页面跑多个 vue、react 甚至 jquery 等不同项目，它之间的 JS、CSS 相互隔离运行，不会相互影响，但也有通信机制可以通信。\\n\\n那微前端怎么实现呢？\\n\\n其实也简单，一句话就可以说明白：**当路由切换的时候，去下载对应应用的代码，然后跑在容器里。**\\n\\n比如 single-spa，它做的就是监听路由变化，路由切换的时候加载、卸载注册的应用的代码。\\n\\n只不过 single-spa 的入口是一个 js 文件，需要代码里手动指定要加载啥 js、css 等，不方便维护。\\n\\nqiankun 只是对 single-spa 的升级。\\n\\n它升级了啥东西呢？\\n\\n第一个就是入口，改为了 html 作为入口，解析 html，从中分析 js、css，然后再加载，这个是 import-html-entry 这个包实现的。\\n\\n所以你在 qiankun 的 package.json 里可以看到 single-spa 和 import-html-entry 这俩依赖。\\n\\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f84c11fca03d485c988b2730328e0101~tplv-k3u1fbpfcp-watermark.image?)\\n\\n加载之后呢？\\n\\n自然是放容器里运行呀。\\n\\n这个容器 single-spa 也没做，qiankun 做了。\\n\\n它是把 js 代码包裹了一层 function，然后再把内部的 window 用 Proxy 包一层，这样内部的代码就被完全隔离了，这样就实现了一个 JS 沙箱。\\n\\n这部分代码在 import-html-entry 里，也就是加载后的 js 就被包裹了一层：\\n\\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/539dfe4a030142f096c6952336ec82e4~tplv-k3u1fbpfcp-watermark.image?)\\n\\n原理很容易理解，就是 function 包裹了一层，所以代码放在了单独作用域跑，又用 with 修改了 window，所以 window 也被隔离了。\\n\\n这是 qiankun 的 JS 沙箱实现方案，其他的微前端方式实现沙箱可能用 iframe、web components 等方式。\\n\\n微前端方案的功能就那一句话：当路由切换的时候，去下载对应应用的代码，然后跑在容器里。只不过这个容器的实现方案有差异。\\n\\n此外，还要设计一套通信机制，这个倒是很容易。\\n\\n除了 JS 隔离，还有 CSS 的隔离，不得不说，qiankun 的样式隔离是真的坑，也是我这主要想吐槽的点。\\n\\n哪里坑呢？\\n\\n跑一下就知道了。\\n\\n把 qiankun 代码 clone 下来，它有 examples，我们用这个来测：\\n\\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/12bebdc67e47401f98ffa91c61d34c0e~tplv-k3u1fbpfcp-watermark.image?)\\n\\n安装依赖，然后执行 examples:install 和 examples:start-multiple 这俩 npm scripts。\\n\\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ed9968947bb468d8b543504c2730d5a~tplv-k3u1fbpfcp-watermark.image?)\\n\\n跑起来是这样的：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f01b22b1be3438b9a470bf936393a41~tplv-k3u1fbpfcp-watermark.image?)\\n\\n在 react15 项目下引入 button 和 modal 这俩 antd 组件：\\n\\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e5b251adb8a42bab00242362b9b3317~tplv-k3u1fbpfcp-watermark.image?)\\n\\n然后再跑一下：\\n\\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a575f8a88bda4607b39860efbd351000~tplv-k3u1fbpfcp-watermark.image?)\\n\\n大家可能会说，这很对呀，有什么问题？\\n\\n那是因为现在是没启用 css 隔离的,所有的 css 都在全局：\\n\\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dbd3e52219394aaeab7a88c8f514825a~tplv-k3u1fbpfcp-watermark.image?)\\n\\n这样各应用的样式会相互影响，比如主应用和子应用。\\n\\n比如，我们在主应用 main 里加一个样式：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dcb22deb29be45f7a437e720183a98c4~tplv-k3u1fbpfcp-watermark.image?)\\n\\n子应用会受到影响：\\n\\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b66d76824b614b919c9b1df9cb50a784~tplv-k3u1fbpfcp-watermark.image?)\\n\\n在子应用 react15 加一个样式：\\n\\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f004658cc89f4c258f71b46d5360a53c~tplv-k3u1fbpfcp-watermark.image?)\\n\\n其他应用也会受到影响：\\n\\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b85719e8b5d4478fb3ca7644d6a22db9~tplv-k3u1fbpfcp-watermark.image?)\\n\\n这样的微前端项目那还了得？各个应用样式都会相互影响。\\n\\n除非命名给错开，通过 bem 等命名方案。\\n\\n但这不靠谱，还是得通过框架层面解决。\\n\\nqiankun 提供了两种样式隔离方案：shadow dom 和自己实现的 scoped。\\n\\nshadow dom 是 web components 技术的一部分，其实就一个 attachShadow 的 api：\\n\\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3251994558df460798c01e120134b6fa~tplv-k3u1fbpfcp-watermark.image?)\\n\\nweb components 添加内容的时候，不直接 appendChild，而是先 attach 个 shadow，然后再在下面 appendChild。\\n\\n效果就是这样的：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8d3000b56d284759bd308d9a62dd1b3c~tplv-k3u1fbpfcp-watermark.image?)\\n\\nqiankun 要在加载子应用的时候指定 strictStyleIsolation 才会开启这种样式隔离：\\n\\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/734452fb90794b80835838eb0bfa0409~tplv-k3u1fbpfcp-watermark.image?)\\n\\n那加了一层 shadow dom 有什么用呢？\\n\\n试下就知道了：\\n\\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dcfb1fe8dd474bc39a6c7253cbeff17e~tplv-k3u1fbpfcp-watermark.image?)\\n\\n还是一样的代码，但是运行结果不一样了。\\n\\n首先，父应用设置的那个绿色背景样式没有生效：\\n\\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3932ff437933455cb3515f249a621c70~tplv-k3u1fbpfcp-watermark.image?)\\n\\n说明有了一层 shadow dom 以后，外界影响不了 shadow dom 内的样式。\\n\\n然后，外面这些按钮也没有变红了：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d925b870b60a46f1978bf46f419d5eb5~tplv-k3u1fbpfcp-watermark.image?)\\n\\n说明 shadow dom 内的样式也影响不了外界。\\n\\n那为啥弹窗会变成这样呢？样式全没了：\\n\\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b003f28fc226473693591179c489a14d~tplv-k3u1fbpfcp-watermark.image?)\\n\\n因为弹窗默认是挂在 body 上的，也就不在 shadow dom 里了，那 shadow dom 里给它加的样式自然就不生效了。\\n\\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8da44cfef9964cf488dd16a849b1ab36~tplv-k3u1fbpfcp-watermark.image?)\\n\\n为啥弹窗要挂在 body 下，这个是为了避免被父元素的样式影响，比如父元素设置了 display:none，那这个弹窗是不是就死活弹不出来了？\\n\\n还有样式也会被父元素继承过来的样式影响。\\n\\n所以干脆独立出来，放到 body 下。\\n\\n问题找到了，是 shadow dom 导致的，**shadow dom 样式影响不了外界，外界样式也影响不了 shadow dom 内的元素。** \\n\\n也不能说是 shadow dom 有问题，人家本来就是这么设计的，只不过用来做微前端样式隔离还是不够的。\\n\\n弹窗的样式问题怎么解决？\\n\\n是通过通信机制把弹窗样式传过去么？那是不是改造成本又增加了？\\n\\n所以 qiankun 的 shadow dom 的样式隔离方案是有问题的。\\n\\n再来看另一种，这种是实验性的，所以叫 experimentalStyleIsolation：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4680be6ab64a4a05b3372adfd5606658~tplv-k3u1fbpfcp-watermark.image?)\\n\\n它是怎么做的样式隔离呢？\\n\\n借鉴了 scoped css 的思路。\\n\\n也就是对所有样式加了一层 data-qiankun=“应用名” 的选择器来隔离：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/67cadf9d39564ae1aae85481133e5a10~tplv-k3u1fbpfcp-watermark.image?)\\n\\n这样其他应用的样式能影响子应用了，但是子应用的样式还是影响不了父应用，看上面的弹窗就知道了。\\n\\n为什么呢？\\n\\n因为所有的样式都加了 data-qiankun 的限制，那就影响不了子应用外部了，所以挂在 body 的弹窗还是加不了样式。\\n\\n有同学说，那支持声明 global 样式不就行了？\\n\\n问题就在这，qiankun 并没有实现这个功能。\\n\\n而且如果要在 qiankun 里实现全部的 scoped css 功能，那为啥不直接用 scoped css 或者类似的 css modules 呢？\\n\\nscoped css 是 vue loader 实现的组件级样式隔离方案，用起来只要给单文件组件的 style 加一个 scoped 属性：\\n\\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc90dc8801e249b9986526169a0b721c~tplv-k3u1fbpfcp-watermark.image?)\\n\\ncss 选择器就会加上 data-xx 的修饰，这样就限制了样式只会在组件范围内生效。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f9296b52b1a840b1bf57161071e9929f~tplv-k3u1fbpfcp-watermark.image?)\\n\\n只会在最后一个选择器加 data-xxx，因为这样足够了：\\n\\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36542e0859a44c7392944542753ba519~tplv-k3u1fbpfcp-watermark.image?)\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/444ecabae4464b63afc4d455b36837e9~tplv-k3u1fbpfcp-watermark.image?)\\n\\n此外它还支持 /deep/ 给子元素传样式：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87d148b129f940d683c816cc0fb5e11c~tplv-k3u1fbpfcp-watermark.image?)\\n\\n这样 deep 后面的样式是不带 data-xx 的，可以影响子组件：\\n\\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e91c6e12e543422baf15cd45655507dd~tplv-k3u1fbpfcp-watermark.image?)\\n\\n此外，也可以再开一个 style 标签写全局的样式：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e9664585ee54f9fa4d9542c11741495~tplv-k3u1fbpfcp-watermark.image?)\\n\\n综上，**scoped css 支持组件级别样式隔离，还能传样式给子组件、设置全局样式等。**\\n\\n功能上比 qiankun 的那个应用级样式隔离完善多了。\\n\\n有了 scoped css，还需要 qiankun 的样式隔离么？\\n\\n完全不用。\\n\\n再来看 css modules，react 项目基本都用这个。\\n\\ncss modules 是 css-loader 实现的功能，开启也是相当简单：\\n\\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/28fe0ea8b2884b8c9fe25f3e09c31ec7~tplv-k3u1fbpfcp-watermark.image?)\\n\\n比如这样的样式：\\n\\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af4a87d1c36b4673a782f32eca8da201~tplv-k3u1fbpfcp-watermark.image?)\\n\\n开启后就会变成这样：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87260189d3ba4fccbce7c477501a63be~tplv-k3u1fbpfcp-watermark.image?)\\n\\n在选择器名字上加了 hash。\\n\\n那么问题来了，scoped css 是多了一个属性选择器而已，本身的 class name 没变：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5115e71c8b5c489c8d4157658f0b17df~tplv-k3u1fbpfcp-watermark.image?)\\n\\n所以 class name 该怎么设怎么设，不受影响。\\n\\n但是 css modules 是改变 class name 本身，加上了 hash：\\n\\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45787d553531433692eaf7bf50c153bd~tplv-k3u1fbpfcp-watermark.image?)\\n\\n这时候还按照原来的方式写 class name 可以么？\\n\\n不可以了。\\n\\n因为最终的 class name 是编译后才生成的，所以要改成这样的方式：\\n\\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe4e3daef058417ab86789c0dafc2a82~tplv-k3u1fbpfcp-watermark.image?)\\n\\n动态引入 className，这样编译生成最终的 className 时就会替换这里。\\n\\n你还可以加个 :global() 把某个选择器变为全局的：\\n\\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f2805af7b7444512944fa04da823cc91~tplv-k3u1fbpfcp-watermark.image?)\\n\\n这样就相当于 scoped css 的 /deep/ 和全局样式功能了。\\n\\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ac094a29a114f799fd752161020779c~tplv-k3u1fbpfcp-watermark.image?)\\n\\n一般都这样用：\\n\\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1655b2a257e540c3b66d259cb5630fd8~tplv-k3u1fbpfcp-watermark.image?)\\n\\n顶层 class name 用 css modules 加上 hash，内部的 class name 该怎么用怎么用：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c7a7a3dc6be54a7cbce2cc6b08484b9d~tplv-k3u1fbpfcp-watermark.image?)\\n\\n生成的 css 是这样的：\\n\\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1843946e441b47dfb7cb5cec5544d1e8~tplv-k3u1fbpfcp-watermark.image?)\\n\\n既达到了组件样式隔离的目的，写起来还简单。\\n\\n综上，**css modules 和 scoped css 差不多，都能实现组件级别样式隔离，能设置子组件和全局样式。只是实现方式不同，导致了使用起来也有差异。**\\n\\n不管是 css modules 还是 scoped css 都比 qiankun 自带的样式隔离方案好用的多，那为什么微前端框架还要实现样式隔离呢？直接让应用自己去用 css modules 或者 scoped css 不就行了？\\n\\n那是因为还有一些别的项目，比如 jquery 项目，你怎么用 css modules？就算用，是不是要改造，改造成本又上去了。\\n\\n所以微前端框架还是要做样式隔离的。\\n\\n只是现在的应用，不管是 vue 还是 react 基本都开启了组件级别样式隔离，qiankun 自带的样式隔离问题太多了，不如不用。\\n\\n## 总结\\n\\n微前端就是在路由变化的时候，加载对应应用的代码，并在容器内跑起来。\\n\\nqiankun、wujie、micro-app 的区别主要还是实现容器（或者叫沙箱）上有区别，比如 qiankun 是 function + proxy + with，micro-app 是 web components，而 wujie 是 web components 和 iframe。\\n\\n流程都是差不多的。\\n\\nqiankun 做了样式隔离，有 shadow dom 和 scoped 两种方案，但都有问题：\\n\\n- shadow dom 自带样式隔离，但是 shadow dom 内的样式和外界互不影响，导致挂在弹窗的样式会加不上。父应用也没法设置子应用的样式。\\n- scoped 的方案是给选择器加了一个 data-qiankun='应用名' 的选择器，这样父应用能设置子应用样式，这样能隔离样式，但是同样有挂在 body 的弹窗样式设置不上的问题，因为 qiankun 的 scoped 不支持全局样式\\n\\n而 react 和 vue 项目本身都会用 scoped css 或者 css modules 的组件级别样式隔离方案，这俩方案都支持传递样式给子元素、设置全局样式等，只是实现和使用方式不同。\\n\\n现在的 vue、react 项目基本都做了组件样式隔离了，有点全局样式也是可控的，真没必要用 qiankun 的那个。\\n\\nqiankun 的样式隔离方案比较坑，能不用就别用吧。\\n\\n"
    },
    {
        "article_id": "7188338442869473335",
        "cover_image": "https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/130f70532fc84f2894f66ca49b62a8dd~tplv-k3u1fbpfcp-watermark.image?",
        "title": "你的useCallback和useMemo用对了吗",
        "brief": "--- theme: fancy --- 现实很多项目存在大量的useMemo和useCallback，大多数的使用并没有起到实际作用，使得项目的渲染效率更低了。 我们在应用程序中使用useMemo和",
        "user_name": "糖瓶",
        "view_count": 2591,
        "collect_count": 14,
        "comment_count": 0,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/cdba6e55b585acdc0ef050d79c8d3872~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: fancy\\n---\\n现实很多项目存在大量的useMemo和useCallback，大多数的使用并没有起到实际作用，使得项目的渲染效率更低了。\\n\\n我们在应用程序中使用useMemo和useCallback这两个Hook，主要是因为想要缓存结果：\\n\\n1.  缓存props值，防止重复渲染。\\n1.  缓存复杂的计算，避免重复计算。\\n\\n**所以我们经常这样使用这两个Hook：**\\n\\n## 缓存值\\n\\nuseMemo 缓存value，防止重新渲染。以下是伪代码：\\n\\n```\\nconst AppItem = ({item, data}) => <button>{item.val + newDate}</button>\\n\\nconst App = ({data}) => {\\n  const newDate = useMemo(() => data.value, [data.value])\\n  \\n  return (\\n    <>\\n      {\\n        list.map(item => {\\n          return <AppItem key={item.id} item={item} data={newDate} />\\n        })\\n      }\\n    </>\\n  )\\n}\\n```\\n\\n## 缓存函数\\n\\nuseCallback缓存click 事件，防止重复渲染。以下是伪代码：\\n\\n```\\nconst AppItem = ({item, data, onClick}) => <button onClick={onClick}>{item.val + newDate}</button>\\n\\nconst App = ({data}) => {\\n  const newDate = useMemo(() => data.value, [data.value])\\n\\n  const onClick = useCallback(() => {\\n    // ...\\n  }, [])\\n  \\n  return (\\n    <>\\n      {\\n        list.map(item => {\\n          return <AppItem key={item.id} item={item} data={newDate} onClick={onClick} />\\n        })\\n      }\\n    </>\\n  )\\n}\\n```\\n\\n**上述是我们经常见到的场景。但是这样使用就一定是正确的吗？答案是否定的**。之前写过一篇React为什么会重新渲染的文章。这里在解释下。\\n\\n## 组件为什么会重新渲染\\n\\n重新渲染其中一个原因就是：state 或者 props 发生变化时。所以我们很天真的认为只要state或者props不变，组件就不会重新渲染了。\\n\\n组件的重新渲染还有一个原因，我们知道但是经常在我们写代码的时候会忽略的原因：就是他的父组件重新渲染了。父组件渲染了，我们只在子组件内部缓存值或者函数是没有作用的。\\n\\n看一个例子：\\n\\n```\\nconst App = () => {\\n\\tconst [count, setCount] = useState(0)\\n  \\n  return (\\n    <>\\n      <button onClick={() => setCount(count+1)}>点我</button>\\n      <OtherComp />\\n    </>\\n  )\\n}\\n```\\n\\n我们可以看到：点击按钮，App组件重新渲染，他的子组件OtherComp虽然没有任何的state或者props变化，但是他也重新渲染了。如果这个子组件也有子组件，以此类推，就会形成一条渲染链。\\n\\n但是我们不是经常这样写吗：在这个组件中使用缓存手段。\\n\\n```\\nconst App = ({val}) => {\\n\\tconst [count, setCount] = useState(0)\\n\\n  const onClick = useCallback(() => {\\n    // ...\\n  }, [])\\n\\n  const data = useMemo(() => val, [val])\\n  \\n  return (\\n    <>\\n      <button onClick={() => setCount(count+1)}>点我</button>\\n      <OtherComp onClick={onClick} data={data} />\\n    </>\\n  )\\n}\\n```\\n\\n这样并不会阻止子组件的重新渲染。怎样解决呢？当然是还要缓存子组件了。\\n\\n```\\nconst OtherCompMemo = React.memo(OtherComp)\\n\\nconst App = ({val}) => {\\n\\tconst [count, setCount] = useState(0)\\n\\n  const onClick = useCallback(() => {\\n    // ...\\n  }, [])\\n\\n  const data = useMemo(() => val, [val])\\n  \\n  return (\\n    <>\\n      <button onClick={() => setCount(count+1)}>点我</button>\\n      <OtherCompMemo onClick={onClick} data={data} />\\n    </>\\n  )\\n}\\n```\\n\\n现在React会识别props没有变化，onClick 和 data也被缓存了，所以需要配合使用。\\n\\n## 缓存复杂的计算\\n\\n根据React文档：useMemo是用来缓存复杂计算的。假设有一个100000项的数组需要排序操作，此时我们应该缓存复杂的计算：\\n\\n```\\nconst dataList = ({data}) => {\\n\\n  const contentNode = useMemo(() => {\\n    return data.map(item => {\\n        return <div key={item}>{item}</div>\\n      })\\n  }, [data, sort]);\\n\\n  return contentNode;\\n}\\n```\\n\\n## 什么是复杂的计算\\n\\n1.  你可以通过 preformance.now() 进行计算消耗的时间。\\n1.  React官方的开发工具中的profiler 记录查看，记录里会显示复杂的计算。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aed93936f75d43fba838d656e52c5028~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n## 何时进行优化呢\\n\\n1.  如果你可以通过组织代码结构来提高性能，那就没有必要使用useCallback和useMemo。\\n1.  如果你不知道使用useCallback和useMemo能否带来更大的好处，就不需要使用它们，因为使用它们也需要消耗性能。\\n\\n## 总结\\n\\n-   useMemo和useCallback只是针对重新渲染才是有帮助的，对第一次的渲染是有害的，消耗性能的。\\n-   大多数情况下，单独使用useMemo和useCallback或memo是没有帮助的，需要结合父组件具体情况来看。\\n-   其实大多数情况下，我们并不需要这两个hook，使用它们只会影响初始化的渲染。\\n"
    },
    {
        "article_id": "7184435249181376568",
        "cover_image": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d43a8db209341bab431516950cce17a~tplv-k3u1fbpfcp-watermark.image?",
        "title": "再探DDD以及美团的“野路子”",
        "brief": "前言 之前我写过一篇关于DDD文章，大白话之辩论DDD，阿里面试中台化理解，这次心血来潮是因为最近在看掘金的一个关于领域设计的课程，然后下面谈谈我读后感，以及在我现实项目里面究竟用到哪些内容，最后还有",
        "user_name": "大鸡腿同学",
        "view_count": 15677,
        "collect_count": 61,
        "comment_count": 9,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/b8b82e41a702943a5442964c471f02e5~300x300.image",
        "category": "后端",
        "content": "---\\ntheme: smartblue\\n---\\n\\n# 前言\\n---\\n\\n之前我写过一篇关于DDD文章，[大白话之辩论DDD，阿里面试中台化理解](https://juejin.cn/post/7099492996244045831)，这次心血来潮是因为最近在看掘金的一个关于领域设计的课程，然后下面谈谈我读后感，以及在我现实项目里面究竟用到哪些内容，最后还有今天看的美团的一篇 [广告平台化的探索与实践](https://tech.meituan.com/2022/03/03/exploration-and-practice-of-advertising-engine-platforming.html)，可以发现路子挺野的，因为我还没到那个层次能驾驭他这种设计方式，后面也会讲到，感兴趣的同学赶紧搬个椅子听听～\\n\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c659f4c9527408eb6969894006369b6~tplv-k3u1fbpfcp-watermark.image?)\\n\\n# 掘金课程相关感受\\n---\\n\\n[深入浅出 DDD](https://juejin.cn/book/7049273428938850307/section)就是这个课程，接下来我会大概讲下里面的内容，然后说下我的感受，最后谈谈我现在项目所做的领域改造，以及还有哪些缺陷需要改进。\\n\\n## 课程内容\\n\\n课程内容就是按照概念、然后分点举例子介绍，然后最后也有自己的demo，可以说适合小白入门的课程。但是属于入门级别的，明白我意思吗，深入一层在实际项目里面应用是如何的效果，究竟我项目哪些地方要做这样的改造，还是说全盘采用DDD理念，文章比较少钱探讨的。\\n\\n## 我目前项目关于领域改造\\n\\n我们项目从一开始就决定采用领域模式设计方式，当然也是第一次接触，有些概念是不太清晰的，下面大致讲下。首先我们采用**经典四层的DDD架构**，为什么呢？因为很多中间件基本是固定的，没有必要去依赖倒置，这种架构跟传统的mvc比较相似，**接口层、应用层、领域层、基础设施层**。\\n\\n应用层一开始不理解，所以很薄的一层，后面的话明白是**服务编排**的作用，会做领域之间的编排。如果是那种直接一个领域搞定的，就通过领域服务处理即可。传统设计最复杂最多代码的就是服务实现类，虽然这个项目是按照领域来划分，但是没有去改变这个现状，所以导致**实现类逻辑会杂**。\\n\\n顺下来，到dto跟中间转换，我们也是直接beanutils去复制参数，并没有采用防腐层那种去隔开，然后像数据库entity，ddd里面概念叫实体po，一般跟业务转换需要仓储层来转换，我们也是直接拿entity用，下面我再详细说这样做的原因。\\n\\n对于外部http请求、rpc请求，采用**防腐层**acl去隔开，当然这里采用策略模式，不管是适配器模式还是什么模式，这里本质就是为了将系统跟外部隔开，就是系统需要什么东西，外部提供什么，而不是外部有什么我拿什么，减少强依赖。\\n\\n类里面字段逻辑，还是采用**贫血模型**，受之前开发思路的影响。\\n\\n**缺陷**\\n\\n1. 领域层逻辑很多，比较杂。\\n\\n解决方案：按照业务包再分包，比如说商品领域，mybatis下面会有spu、sku、他们之间绑定关系，还有一些附加的东西，这些都是有自己servicImpl对吧，再加一个商品领域模型，这个抽出来一个模块，这就很清晰，哪个模块对应什么servicImpl，不然可能需要看代码注释半天才知道这是之前做过什么需求。\\n\\n2. 没有仓储层转换\\n\\nA: 这个不算缺陷，我们采用mybatis-plus自带封装service，本身自带来很多基本crud，为啥你非要自己重写呢？其次没有做po跟业务类转换，原因是不可能一步到位，可能这个业务需要这个参数，另一个业务需要另一个参数，所以就是都给，按需自己在领域层处理\\n\\n3. 没有去实现值对象、实体、聚合根这些区分\\n\\nA: 原因也很简单，目前阶段没有必要上到这个程度。有些扩展性要求很高的需求可以这么搞，比如我们公司基础服务里面有个商品服务，里面会经常变动字段，这时候就需要上这玩意了。值对象是不变的东西，实体是包含整个对象生命周期的字段还有字段逻辑。对于变动很大的需求就好办了，不变了可能就是商品code，对于spu、sku信息是会改变的，可以放在实体里头，有些新加一些额外的字段，比如优化价格，我们可以通过聚合类方式加上去，当我们不需要的时候，不会影响这些不变的内容，这是好处。\\n\\n# DDD思想（进阶）\\n\\n\\n\\n## 核心思想\\n\\n**高内聚、低耦合**，这个就是领域设计的核心思想。我们从架构上，比如说**六边形架构**，外层都是适配器，低耦合；比如**应用层服务编排**，也是为了隔开服务之间依赖，还是低耦合；**防腐层**是为了跟外部接口隔开，防止接口改动影响内部实现方式，也是低耦合；再到**各层的转换**，dto到业务bo，bo到po，层层转换，都是为了将他们隔开，字段不用全部输出，也是**低耦合**。\\n\\n**高内聚**体现：采用**充血模型**，将字段的逻辑放在类里面，而不是在功能实现逻辑里头。这样的好处是什么呢？就是代码复用率，比如说a字段在逻辑b、c中都有，如果哪天需求变了，需要改动的地方一多就容易错，其次是提高代码复用率，也就是高内聚。\\n\\n## 因需取材\\n\\n我见过很多上来就是全套搬DDD的东西，有点为了技术而技术，作为研发人，我觉得应该理解为啥会有这种思想的出现，什么时候我们才需要去应用它，那我项目没有全盘采用算不算DDD呢？也算，就是我们下面要讲的什么情况下需要做这层改造。\\n\\n讲讲架构东西，从一开始是单体服务，当业务上来之后，机器扛不住，需要横向还有纵向去提升整个系统服务能力，业务逻辑也会开始复杂起来，混乱不堪，这时开始有soa面向服务的治理，将这些功能按照业务模块来划分，分割成单独的机器，这样可以提高单独模块的服务能力；再到后来有了ddd领域设计思想，我觉得它是针对saas去做设计的，如果你按照paas去拆分了，其实没有所谓的再去定义领域了，这时会出现聚合层那些。对于saas里面会夹杂很多领域，如果整在一块会跟炒面一样混乱，ddd就是为了解决这个场景的。\\n\\n**什么时候要用到？**\\n\\n当系统业务已经复杂到影响开发，或者说一开始做项目的时候这个业务就是比较复杂，经常变动需求那种，就要这样设计。这让我想起之前面阿里的时候，面试官问我，mysql跟redis去区别是什么，什么时候要用redis？最后我去百度一下，mysql在200以上并发的时候性能越来越差，这时可以上redis。\\n\\n同样的道理，我们需要观察系统里面的东西是否已经达到需要拆分的级别，**而不是强行为了技术而技术**。\\n\\n举个栗子：\\n\\n1、对于外部http请求，我们有个报单的功能，需要对n多家供应商，如果你在一个方法里面写，那就翘翘了，一直叠加上去。这时采用设计模块策略模式，根据供应商编号进行不同报单请求，这就是防腐层思路。\\n\\n2、当领域层很多service，这时新人接手的时候上手很慢，你需要跟它讲什么表，什么类，这时我们再根据业务再分包，那就很清楚了。这个是不是高内聚体现，对于新人上手也是提效的，这才是有意义的。\\n\\n3、对于各层转换，我们项目是没有做一层特殊处理的，直接逻辑里面转，原因是没有必要去隔开。因为我们很多逻辑都是直接复制两个类的字段，没有做复杂的逻辑处理，他们之间强耦合就强呗。但是对于一些公共方法，我们确实是可以这么做，因为避免各个方法都去重写逻辑，增加bug风险。\\n\\n4、如果全套按照ddd去设计，可以去统计下代码量有多少，直接翻上去，对于打包cicd是有影响的，对开发也没有所谓的提效。\\n\\n> 这就是我为什么说掘金那课程是初级，因需取材这方面没有展开太多。\\n\\n# 美团的“野路子”\\n\\n---\\n\\n今天看到美团年度最佳文章展示，我看到里面一篇# [广告平台化的探索与实践](https://tech.meituan.com/2022/03/03/exploration-and-practice-of-advertising-engine-platforming.html)，然后仔细阅读之后，觉得路子太野了，因为我驾驭不了。\\n\\n它这一篇文章跟ddd很多思想是一致的，所以大家要用心的体会，而不是被浅层的皮毛所限制了思路。\\n\\n\\n<img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33302d33b465465e8f812de83dcd94da~tplv-k3u1fbpfcp-watermark.image\\\"  width=\\\"800\\\"  align=\\\"bottom\\\" />\\n\\n大家想起什么了嘛，值对象、实体的思想，就是把不变、扩展的拆开。\\n\\n\\n<img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f2f38d2c550447019e841df78b504850~tplv-k3u1fbpfcp-watermark.image\\\"  width=\\\"800\\\"  align=\\\"bottom\\\" />\\n\\n这个是什么思想呢？模块化思想，流程化思想，这是对业务熟悉基础归纳出来的，也是工程师很重要的能力。模块化有多重要，比如说当你要改变东西的时候，我只需要加或者减少、或者变更模块即可，而不是像印度电线杆一样找半天都不知道需要改哪根电线。\\n\\n## 路子很野的地方\\n\\n<img src=\\\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6dec50a179ad406fb5e4834fa342a737~tplv-k3u1fbpfcp-watermark.image\\\"  width=\\\"800\\\"  align=\\\"bottom\\\" />\\n\\n首先这是什么？就是应用层的服务编排嘛，但是什么区别呢？它是在外部的，有点像聚合层，但是聚合层一般是一个服务去调其他服务整合数据，这个还能通过界面编排，老六了。我说个场景你就明白了，低代码平台，这是跟我做过一个项目很相似的。\\n\\n里面也是接口编排，然后对结果进行处理，然后返回。有个我吐槽最多的，就是数据处理上比传统会麻烦，比如说我写段逻辑，可能java我很快就写完了，对于低代码平台我还要用js代码，golang代码处理，对于java开发同学是降效的，所以这块我不清楚美团是怎么去实现逻辑处理的，理论上也可以写java代码去整合不同模块数据。\\n\\n## 这样做的意义\\n\\n上面我们也提到了不要为了技术而去应用技术，美团这么做为了让pm、测试、研发都能直观知道广告业务里面有哪些策略，分别实现什么功能，特别是新人入手的时候，所以这里有个业务采集，对于已经实现的东西进行上报，qa同学也知道我需要测试的内容范围。\\n\\n对于一般公司来设计： 就是新增一层聚合层，还无法实现调度引擎比较前沿的设计，当然对于一般公司已经够用了，所以说美团这样设计比较“野”，褒义词。\\n\\n# 总结\\n---\\n\\n希望大家在学习完ddd基础知识基础上，在对业务一定熟悉程度上，因虚取材，这样才能真正发挥它的作用。然后我们通过美团的技术方案，知道思想是更加重要的，而不是局限于形式上，它是我见过不一样的聚合层，或者说服务编排，当然也是我见过的只是没想到会以这样形式呈现（低代码平台）。\\n\\n\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d01014340e344b8aef79050551b4bbd~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n"
    },
    {
        "article_id": "7166606179261480967",
        "cover_image": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5bd39e8773754d56b051ec1ca7a3318c~tplv-k3u1fbpfcp-watermark.image?",
        "title": "我修复了一个 Vite Bug，让我的项目首屏性能提高了 25%",
        "brief": "项目升级 Vite3.x 后，首次进入页面，页面的首屏时间非常的长，且一定会刷新整个页面。修复前的页面首屏时间为 1m06s，修复后为 45s，性能提升了 25%",
        "user_name": "candyTong",
        "view_count": 10726,
        "collect_count": 139,
        "comment_count": 25,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/33a18c832ad717525f8abda8b4b03a52~300x300.image",
        "category": "前端",
        "content": "***本文正在参加[「金石计划 . 瓜分6万现金大奖」](https://juejin.cn/post/7162096952883019783 \\\"https://juejin.cn/post/7162096952883019783\\\")***\\n\\n一次偶然的机会，我将项目（基于 [tdesign-vue-next-starter](https://tdesign.tencent.com/starter/vue-next/#/dashboard/base) ）由 `Vite 2.7` 升级成 `Vite 3.x` 后，发现首次运行 Vite dev 构建，**页面首屏时间非常长**，且一定会**整个页面刷新**一次。而第二次进入则不再刷新页面。\\n\\n充满好奇心的我，决定研究一下为什么 Vite.3.x 会有这么一个负优化，于是我仔细研究源码，最终发现了问题的根源，并给 Vite 提交了修复的代码\\n\\n![image-20221115223200740](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/546bd7c4e73e4000935c2559b404164e~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n大概测了一下，修复前的页面首屏时间为 1m06s，修复后为 45s，性能提升了 25%\\n\\n\\n\\n# 问题详情\\n\\n> 升级 Vite3.x 后的代码放到了[该仓库](https://github.com/candy-Tong/tdesign-vue-next-starter-candy)，感兴趣的同学可以自行调试\\n\\n项目升级 `Vite3.x` 后，首次进入页面，页面的首屏时间非常的长，且一定会刷新整个页面，这个问题只有在没有 Vite 缓存情况下出现。\\n\\n因为我们可以通过以下方式复现：\\n\\n```shell\\nvite --force\\n```\\n\\n![image-20221106203410506](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b97537e5be6944bf8ddc49034f8f2b0e~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n从日志中，可以初步判断出，Vite 在运行过程中，**发现了新的依赖**，然后重新执行预构建，再刷新页面。\\n\\n因此我们需要更多的信息，要打印更多的运行 log，**以清楚 Vite 的运行状态**。这里我们可以通过设置 `DEBUG` 环境变量，来输出更多的关于依赖构建相关的日志：\\n\\n```shell\\n# vite:deps 是指过滤出依赖预构建的日志\\n# force 代表不使用之前构建的缓存，以确保每次都能复现问题\\ncross-env DEBUG=vite:deps vite --force\\n```\\n\\n运行结果如下：![image-20221106212253161](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df0c483dd5204cb4a9af898c9f47cb89~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n我们来仔细看一下日志信息：\\n\\n![image-20221106212637079](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/785bb10ba7a54eb0ad157f1d1d599ad2~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n仅仅从日志的字面意思，我们可以得出以下信息：\\n\\n1. Dev server 启动\\n2. 依赖扫描，扫描出了项目中使用了哪些依赖。这里**扫描到的依赖是不全的**\\n3. 访问页面后，**发现新的依赖**（lodash/union），重新执行依赖构建\\n4. 又**发现新的依赖**（echarts/charts、echarts/renderer 等），又重新执行依赖构建\\n5. 刷新页面\\n\\n看起来就是因为依赖扫描的时候，有很多**依赖没有被扫描出来**，那么这些**依赖没有被预构建**。导致运行代码时，**多次发现新的依赖**（没有进行预构建），导致又要重新执行预构建，最后还刷新了页面。\\n\\n\\n\\n因此可能问题的根源是：**Vite 的依赖扫描没有扫描到所有的依赖**。\\n\\n\\n\\n# Vite 的依赖扫描\\n\\n这块涉及到 Vite 依赖扫描的相关知识，恰好之前就研究过这个内容，还写了一篇文章：[《五千字深度解读 Vite 的依赖扫描》](https://juejin.cn/post/7129160452377935903)，这里总结一下：\\n\\n1. 用 esbuild 打包一遍整个项目\\n2. 打包过程中**遇到 `import` 语句，就把 `import` 的内容记录下来**，例如 import Vue，就记录 `Vue` 到数组中\\n3. 最后**只留下实际路径为 `node_module` 中的依赖**，这些代码就是第三方依赖。\\n\\n\\n\\n假如有如下的模块依赖树，则扫描到的依赖就是 `vue` 和 `axios`\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c2a6a3a6eb3149b0aba8305841a62f26~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n模块依赖树是利用模块中的 **`import` 语句**（静态 import、动态 import 均可），将各个**模块连接**起来的。\\n\\nVite 文档也同时指出，**Vite 默认的依赖发现为启发式，可能并不总是可取**\\n\\n> 什么时候 Vite 的依赖发现不可靠呢？\\n\\n**当源代码中没有 `import` 语句，但经过代码编译转换后才有 `import` 语句**，这种情况，Vite 无法依赖扫描。只能在浏览器请求模块，Vite 转换后，**在运行时发现新依赖**。\\n\\n\\n\\n# 提出和验证猜想\\n\\n我们看看项目中的模块依赖树（节选）：\\n\\n![image-20221113102302363](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b6c96336bc14843a013ba4fc520f180~tplv-k3u1fbpfcp-zoom-1.image)\\n\\nrouter.ts 的部分代码如下：\\n\\n```js\\n// 自动导入modules文件夹下所有ts文件\\n// glob 和 globEager 作用相同，只是转化后，是动态引入还是静态引入的区别\\nconst modules = import.meta.globEager('./modules/**/*.ts');\\n```\\n\\n这是一种很常见的用法，所有的 vue-router 配置写到 modules 文件夹下，然后 router.ts 自动引入该文件的所有模块，然后传给 vue-router。\\n\\n整个项目中，除了 `router.ts` 中使用 `glob` 特性进行引入模块外，其他模块均使用静态 import 或动态 import 语句引入模块。因此依赖扫描流程中，**唯一可能出现问题的，就是在依赖扫描阶段 `glob` 没有进行转换**。\\n\\n\\n\\n要想验证 Vite3.x 在依赖扫描阶段没有转换 `glob`，只需要在 Vite2.x 中找到转换代码，而在 Vite3.x 中找不到即可。\\n\\n经过考证，我从这个 [pull request](https://github.com/vitejs/vite/pull/7537/files#diff-00039b783552b3f2a608918986716e01b1a71996da1a8ad5493a102a1e969d7bL470-L483) 中得知，Vite3.x 重构了 `import.meta.glob` 的转换，但却删除对 JS 代码中 `glob` 的转换，从而导致依赖扫描不全。\\n\\n![image-20221115225401671](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/74f715ba56734c70b86872443dc36e18~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n知道问题之后，我们只要将 `glob` 的转换逻辑加上即可\\n\\n> 如何修复，这个过程就不细说了，因为也不需要关心了，说多了反而让文章更难理解。\\n\\n为了进一步了解 Vite 的运行机制，我们研究一下这个问题：\\n\\n**为什么依赖扫描不全，会导致后面的一系列问题（依赖重新构建、页面刷新）**？\\n\\n\\n\\n\\n\\n# 依赖扫描不全后的运行过程\\n\\n我们需要对照运行日志和模块依赖树，来解析依赖扫描不全后的 Vite 的整个运行过程：\\n\\n![image-20221106212637079](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/667ddaedb6c44afaac4d9288a0f4f07f~tplv-k3u1fbpfcp-zoom-1.image)![image-20221113102302363](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1fbca73465d24c3cb05b63f6705ecd3b~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n1. `import.meta.glob` 没有被转换，Vite 认为 router.ts 下只有 Login.vue，Login.vue 下的依赖被 Vite 发现，但 base.ts 等模块及其嵌套使用的依赖，并没有被扫描到\\n2. 第一次依赖预构建完成\\n3. 访问页面，执行时，请求 router.ts 页面，router.ts 被 Vite 转换\\n4. 浏览器执行 router.ts 代码，**动态 import** base.ts，在浏览器**运行时才知道有 base.ts 模块**\\n5. 请求 base.ts，Vite 转换 base.ts 并返回\\n6. 执行 base.ts 代码，请求**静态 import** Layout.vue ，Vite **发现新依赖** echarts/charts 等， 重新执行依赖预构建\\n7. 第二次依赖预构建完成\\n8. 浏览器执行 base.ts 的代码，发现有**动态 import** dashboard.vue 模块\\n9. 请求 dashboard.vue 及其嵌套的模块，发现新依赖 `echart/charts`，重新执行依赖预构建\\n10. 第三次依赖预构建完成\\n\\n> 以下是这一过程的图示，从第 3 点开始画的\\n\\n![image-20221113202945953](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1bd131acc1ab4554bacd866a813417b9~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n> 静态 import 和动态 import 的区别？\\n\\n静态 import：**阻塞代码执行**，必须要等 import 的模块加载完成，才会执行当前模块的代码\\n\\n动态 import：**异步加载模块**，不阻塞当前模块代码执行。\\n\\n我们来看下面这个片段。\\n\\n![image-20221115232028452](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c4eb241c87774ce1bdd996a5d0578bb7~tplv-k3u1fbpfcp-zoom-1.image)\\n\\nbase.ts 是静态 import Layout.vue 的，因此 base.ts 必须要**等它嵌套的依赖加载完成**，才会执行。但由于嵌套的 SiderNav 依赖了 `lodash/union`，`lodash/union` 又必须等构建完成，才能返回。\\n\\n因此 base.ts、Layout.vue、SiderNav.vue 三个模块都被阻塞了。\\n\\n\\n\\n再来看这个片段：\\n\\n![image-20221115232423683](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4bee1647d9064ec6bec31d326a17c940~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n当 base.ts 代码运行时，才发现有动态的 import dashboard.vue，在请求 dashboard.vue 过程中，又发现了新的依赖 `echart/charts`，又需要重新预构建。\\n\\n结合这两个片段，我们会发现**这两次发现新依赖，并没有办法合成一次构建，即使 Vite 有延迟执行重新构建的能力**\\n\\n因为发现新依赖 `lodash/union`，base.ts 是被阻塞的，无法执行代码，这就无法知道需要请求 dashboard.vue，也就无法知道有新的依赖  `echart/charts`\\n\\n这就是**依赖扫描不全导致的严重后果**：由于静态 import 阻塞代码执行，导致运行过程中多次发现新依赖，多次重新预构建。\\n\\n因此这次的修复，其实对性能提升远远大于 25%，原因有以下两点：\\n\\n1. 运行过程中还会发现新的依赖，导致重新预构建\\n2. 依赖扫描完整后，扫描出非常多的依赖，所有的这些依赖构建时间为 40s；而没修复前，仅仅扫描出少量的依赖，构建时间仅仅不到 10s。两者构建的依赖数量本身就相差较大的。\\n\\n\\n\\n> 每次发现新的依赖，必须重新构建吗？\\n\\n**必须重新构建**\\n\\n[官方文档](https://cn.vitejs.dev/guide/dep-pre-bundling.html#the-why)提到了， Vite 构建的两个目的：\\n\\n1. **CommonJS 和 UMD 兼容性:** 开发阶段中，Vite 的开发服务器将所有代码视为原生 ES 模块。因此，Vite 必须先将作为 CommonJS 或 UMD 发布的依赖项转换为 ESM。\\n2. **性能：** Vite 将有许多内部模块的 ESM 依赖关系转换为单个模块，以提高后续页面加载性能。\\n\\n\\n\\n因此**新的依赖，必须要等构建完成才能返回，期间会造成阻塞**\\n\\n\\n\\n> 为什么只有最后一次依赖预构建才会刷新页面？\\n\\n我们来看看三次构建的产物（节选）：\\n\\n![image-20221115233619112](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13260dba4ba345198f554da57d82c43c~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n1. 第一次构建，有 `echart/core` 和 `lodash/keys`\\n2. 第二次构建，新发现了 `lodash/union`，该依赖跟原有依赖，**没有任何公共代码**，因此打包的产物也**不会相互依赖**\\n3. 第三次构建，新发现了 `echart/charts`，它与 `echart/core` 有公共的依赖，打包产物会多了一份公共的代码，它们都依赖这份公共代码。\\n\\n\\n\\n第三次构建与第二次构建对比， `echart/core` **的模块文件已经被改变**（原来自己所有代码都在一个模块，现在公共代码被抽离），**原先浏览器拉取的 `echart.core` 代码已经是失效的代码**，这时候只能刷新页面，让浏览器重新拉取最新的 `echart/core`\\n\\nVite 实际上会根据打包前后的 file hash，来决定是否需要刷新页面，**如果所有依赖的构建前后文件 hash 没有被改变，则不会刷新页面**，例如第二次构建，只新增了 `lodash/union`，其他模块没有被改变。\\n\\n\\n\\n# 总结\\n\\n文章就写到这了，第一次给 Vite 贡献代码，的确有点小激动。虽然是一个小小的 bug，但实际上过程是充满坎坷的，每一个小小的问题都能研究几天，但最后回顾起来，这个过程学到了很多收获还是非常大的。\\n\\n\\n\\n如果这篇文章对您有所帮助，**可以点赞加收藏**👍，您的鼓励是我创作路上的最大的动力。也可以关注我的公众号订阅后续的文章：**[Candy 的修仙秘籍](https://link.juejin.cn/?target=https%3A%2F%2Fp3-juejin.byteimg.com%2Ftos-cn-i-k3u1fbpfcp%2F28e3ed86c0584e78b42b35dd4776e780~tplv-k3u1fbpfcp-zoom-1.image)**（点击可跳转）\\n\\n\\n# 关联阅读\\n\\n+ [《五千字深度解读 Vite 的依赖扫描》](https://juejin.cn/post/7129160452377935903)\\n+ [《快速理解 Vite 的依赖预构建》](https://juejin.cn/post/7139430132762017800)\\n\\n更多内容可以查看我的专栏：[《Vite 设计与实现》](https://www.zhihu.com/column/c_1507478686157058048)\\n"
    },
    {
        "article_id": "7189258947688136764",
        "cover_image": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d72bfb9a343545bd96579ce285eff2b0~tplv-k3u1fbpfcp-watermark.image?",
        "title": "请求量突增一下，系统有效QPS为何下降很多？",
        "brief": "最近我观察到一个现象，当服务的请求量突发的增长一下时，服务的有效QPS会下降很多，有时甚至会降到0，这种现象网上也偶有提到，但少有解释得清楚的，所以这里来分享一下问题成因及解决方案。",
        "user_name": "扣钉日记",
        "view_count": 1019,
        "collect_count": 7,
        "comment_count": 0,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/33aa0a85a7d4d5078a45e80d745bc089~300x300.image",
        "category": "后端",
        "content": "> 原创：扣钉日记（微信公众号ID：codelogs），欢迎分享，转载请保留出处。  \\n### 简介  \\n最近我观察到一个现象，当服务的请求量突发的增长一下时，服务的有效QPS会下降很多，有时甚至会降到0，这种现象网上也偶有提到，但少有解释得清楚的，所以这里来分享一下问题成因及解决方案。  \\n\\n### 队列延迟  \\n目前的Web服务器，如Tomcat，请求处理过程大概都类似如下：  \\n![image_2023-01-15_20230115173654](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e320049c4b22482d87f00a4edbdce393~tplv-k3u1fbpfcp-zoom-1.image)  \\n这是Tomcat请求处理的过程，如下：  \\n1. Acceptor线程：线程名类似http-nio-8080-Acceptor-0，此线程用于接收新的TCP连接，并将TCP连接注册到NIO事件中。  \\n2. Poller线程：线程名类似http-nio-8080-ClientPoller-0，此线程一般有CPU核数个，用于轮询已连接的Socket，接收新到来的Socket事件（如调用端发请求数据了），并将活跃Socket放入exec线程池的请求队列中。  \\n3. exec线程：线程名类似http-nio-8080-exec-0，此线程从请求队列中取出活跃Socket，并读出请求数据，最后执行请求的API逻辑。  \\n\\n这里不用太关心`Acceptor`与`Poller`线程，这是nio编程时常见的线程模型，我们将重点放在exec线程池上，虽然Tomcat做了一些优化，但它还是从Java原生线程池扩展出来的，即有一个任务队列与一组线程。  \\n\\n当请求量突发增长时，会发生如下的情况：  \\n1. 当请求量不大时，任务队列基本是空的，每个请求都能得到及时的处理。  \\n2. 但当请求量突发时，任务队列中就会有很多请求，这时排在队列后面的请求，就会被处理得越晚，因而请求的整体耗时就会变长，甚至非常长。  \\n\\n可是，exec线程们还是在一刻不停歇的处理着请求的呀，按理说服务QPS是不会减少的呀！  \\n\\n简单想想的确如此，但调用端一般是有超时时间设置的，不会无限等待下去，当客户端等待超时的时候，这个请求实际上Tomcat就不用再处理了，因为就算处理了，客户端也不会再去读响应数据的。  \\n![image_2023-01-15_20230115175826](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af137a63879842d98aca847155627bc9~tplv-k3u1fbpfcp-zoom-1.image)  \\n因此，当队列比较长时，队列后面的请求，基本上都是不用再处理的，但exec线程池不知道啊，它还是会一如既往地处理这些请求。  \\n\\n当exec线程执行这些已超时的请求时，若又有新请求进来，它们也会排在队尾，这导致这些新请求也会超时，所以在流量突发的这段时间内，请求的有效QPS会下降很多，甚至会降到0。  \\n\\n这种超时也叫做队列延迟，但队列在软件系统中应用得太广泛了，比如操作系统调度器维护了线程队列，TCP中有backlog连接队列，锁中维护了等待队列等等。  \\n\\n因此，很多系统也会存在这种现象，平时响应时间挺稳定的，但偶尔耗时很高，这种情况有很多都是队列延迟导致的。  \\n\\n### 优化队列延迟  \\n知道了问题产生的原因，要优化它就比较简单了，我们只需要让队列中那些长时间未处理的请求暂时让路，让线程去执行那些等待时间不长的请求即可，毕竟这些长时间未处理的请求，让它们再等等也无防，因为客户端可能已经超时了而不需要请求结果了，虽然这破坏了队列的公平性，但这是我们需要的。  \\n\\n对于Tomcat，在springboot中，我们可以如下修改：  \\n使用WebServerFactoryCustomizer自定义Tomcat的线程池，如下：  \\n```java\\n@Component\\npublic class TomcatExecutorCustomizer implements WebServerFactoryCustomizer<TomcatServletWebServerFactory> {\\n    @Resource\\n    ServerProperties serverProperties;\\n\\n    @Override\\n    public void customize(TomcatServletWebServerFactory factory) {\\n        TomcatConnectorCustomizer tomcatConnectorCustomizer = connector -> {\\n            ServerProperties.Tomcat.Threads threads = serverProperties.getTomcat().getThreads();\\n            TaskQueue taskqueue = new SlowDelayTaskQueue(1000);\\n            ThreadPoolExecutor executor = new org.apache.tomcat.util.threads.ThreadPoolExecutor(\\n                    threads.getMinSpare(), threads.getMax(), 60L, TimeUnit.SECONDS,\\n                    taskqueue, new CustomizableThreadFactory(\\\"http-nio-8080-exec-\\\"));\\n            taskqueue.setParent(executor);\\n            ProtocolHandler handler = connector.getProtocolHandler();\\n            if (handler instanceof AbstractProtocol) {\\n                AbstractProtocol<?> protocol = (AbstractProtocol<?>) handler;\\n                protocol.setExecutor(executor);\\n            }\\n        };\\n        factory.addConnectorCustomizers(tomcatConnectorCustomizer);\\n    }\\n}\\n```\\n注意，这里还是使用的Tomcat实现的线程池，只是将任务队列TaskQueue扩展为了SlowDelayTaskQueue，它的作用是将长时间未处理的任务移到另一个慢队列中，待当前队列中无任务时，再把慢队列中的任务移回来。  \\n\\n为了能记录任务入队列的时间，先封装了一个记录时间的任务类RecordTimeTask，如下：  \\n```java\\n@Getter\\npublic class RecordTimeTask implements Runnable {\\n    private Runnable run;\\n    private long createTime;\\n    private long putQueueTime;\\n\\n    public RecordTimeTask(Runnable run){\\n        this.run = run;\\n        this.createTime = System.currentTimeMillis();\\n        this.putQueueTime = this.createTime;\\n    }\\n    @Override\\n    public void run() {\\n        run.run();\\n    }\\n\\n    public void resetPutQueueTime() {\\n        this.putQueueTime = System.currentTimeMillis();\\n    }\\n\\n    public long getPutQueueTime() {\\n        return this.putQueueTime;\\n    }\\n}\\n```\\n然后队列的扩展实现如下：  \\n```java\\npublic class SlowDelayTaskQueue extends TaskQueue {\\n    private long timeout;\\n    private BlockingQueue<RecordTimeTask> slowQueue;\\n\\n    public SlowDelayTaskQueue(long timeout) {\\n        this.timeout = timeout;\\n        this.slowQueue = new LinkedBlockingQueue<>();\\n    }\\n\\n    @Override\\n    public boolean offer(Runnable o) {\\n        // 将任务包装一下，目的是为了记录任务放入队列的时间\\n        if (o instanceof RecordTimeTask) {\\n            return super.offer(o);\\n        } else {\\n            return super.offer(new RecordTimeTask(o));\\n        }\\n    }\\n\\n    public void pullbackIfEmpty() {\\n        // 如果队列空了，从慢队列中取回来一个\\n        if (this.isEmpty()) {\\n            RecordTimeTask r = slowQueue.poll();\\n            if (r == null) {\\n                return;\\n            }\\n            r.resetPutQueueTime();\\n            this.add(r);\\n        }\\n    }\\n\\n    @Override\\n    public Runnable poll(long timeout, TimeUnit unit) throws InterruptedException {\\n        pullbackIfEmpty();\\n        while (true) {\\n            RecordTimeTask task = (RecordTimeTask) super.poll(timeout, unit);\\n            if (task == null) {\\n                return null;\\n            }\\n            // 请求在队列中长时间等待，移入慢队列中\\n            if (System.currentTimeMillis() - task.getPutQueueTime() > this.timeout) {\\n                this.slowQueue.offer(task);\\n                continue;\\n            }\\n            return task;\\n        }\\n    }\\n\\n    @Override\\n    public Runnable take() throws InterruptedException {\\n        pullbackIfEmpty();\\n        while (true) {\\n            RecordTimeTask task = (RecordTimeTask) super.take();\\n            // 请求在队列中长时间等待，移入慢队列中\\n            if (System.currentTimeMillis() - task.getPutQueueTime() > this.timeout) {\\n                this.slowQueue.offer(task);\\n                continue;\\n            }\\n            return task;\\n        }\\n    }\\n}\\n```\\n逻辑其实挺简单的，如下：  \\n1. 当任务入队列时，包装一下任务，记录一下入队列的时间。  \\n2. 然后线程从队列中取出任务时，若发现任务等待时间过长，就将其移入慢队列。  \\n3. 而pullbackIfEmpty的逻辑，就是当队列为空时，再将慢队列中的任务移回来执行。  \\n\\n为了将请求的队列延迟记录在access.log中，我又修改了一下Task，并加了一个Filter，如下：  \\n1. 使用ThreadLocal将队列延迟先存起来  \\n```java\\n@Getter\\npublic class RecordTimeTask implements Runnable {\\n    private static final ThreadLocal<Long> WAIT_IN_QUEUE_TIME = new ThreadLocal<>();\\n\\n    private Runnable run;\\n    private long createTime;\\n    private long putQueueTime;\\n    public RecordTimeTask(Runnable run){\\n        this.run = run;\\n        this.createTime = System.currentTimeMillis();\\n        this.putQueueTime = this.createTime;\\n    }\\n    @Override\\n    public void run() {\\n        try {\\n            WAIT_IN_QUEUE_TIME.set(System.currentTimeMillis() - this.createTime);\\n            run.run();\\n        } finally {\\n            WAIT_IN_QUEUE_TIME.remove();\\n        }\\n    }\\n\\n    public void resetPutQueueTime() {\\n        this.putQueueTime = System.currentTimeMillis();\\n    }\\n\\n    public long getPutQueueTime() {\\n        return this.putQueueTime;\\n    }\\n\\n    public static long getWaitInQueueTime(){\\n        return ObjectUtils.defaultIfNull(WAIT_IN_QUEUE_TIME.get(), 0L);\\n    }\\n}\\n```\\n2. 再在Filter中将队列延迟取出来，放入Request对象中  \\n```java\\n@WebFilter\\n@Component\\npublic class WaitInQueueTimeFilter extends HttpFilter {\\n\\n    @Override\\n    public void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws\\n                                                                                                      IOException,\\n                                                                                                      ServletException {\\n        long waitInQueueTime = RecordTimeTask.getWaitInQueueTime();\\n        // 将等待时间设置到request的attribute中，给access.log使用\\n        request.setAttribute(\\\"waitInQueueTime\\\", waitInQueueTime);\\n\\n        // 如果请求在队列中等待了太长时间，客户端大概率已超时，就没有必要再执行了\\n        if (waitInQueueTime > 5000) {\\n            response.sendError(503, \\\"service is busy\\\");\\n            return;\\n        }\\n        chain.doFilter(request, response);\\n    }\\n\\n}\\n```\\n3. 然后在access.log中配置队列延迟  \\n```yml\\nserver:\\n  tomcat:\\n    accesslog:\\n      enabled: true\\n      directory: /home/work/logs/applogs/java-demo\\n      file-date-format: .yyyy-MM-dd\\n      pattern: '%h %l %u %t \\\"%r\\\" %s %b %Dms %{waitInQueueTime}rms \\\"%{Referer}i\\\" \\\"%{User-Agent}i\\\" \\\"%{X-Forwarded-For}i\\\"'\\n```\\n注意，在access.log中配置`%{xxx}r`表示取请求xxx属性的值，所以，`%{waitInQueueTime}r`就是队列延迟，后面的ms是毫秒单位。  \\n\\n### 优化效果  \\n我使用接口压测工具wrk压了一个测试接口，此接口执行时间100ms，使用1000个并发去压，1s的超时时间，如下：  \\n```bash\\nwrk -d 10d -T1s --latency http://localhost:8080/sleep -c 1000\\n```\\n然后，用arthas看一下线程池的队列长度，如下：  \\n```bash\\n[arthas@619]$ vmtool --action getInstances \\\\\\n    --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader \\\\\\n    --className org.apache.tomcat.util.threads.ThreadPoolExecutor \\\\\\n    --express 'instances.{ #{\\\"ActiveCount\\\":getActiveCount(),\\\"CorePoolSize\\\":getCorePoolSize(),\\\"MaximumPoolSize\\\":getMaximumPoolSize(),\\\"QueueSize\\\":getQueue().size()} }' \\\\\\n    -x 2\\n```\\n![image_2023-01-16_20230116003607](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca74711744dd43d1af7d6d513b050a1c~tplv-k3u1fbpfcp-zoom-1.image)  \\n可以看到，队列长度远小于1000，这说明队列中积压得不多。  \\n\\n再看看access.log，如下：  \\n![image_2023-01-15_20230115233508](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33e0622bf39c4a919624e086eb699265~tplv-k3u1fbpfcp-zoom-1.image)  \\n可以发现，虽然队列延迟任然存在，但被控制在了1s以内，这样这些请求就不会超时了，Tomcat的有效QPS保住了。  \\n\\n而最后面那些队列延迟极长的请求，则是被不公平对待的请求，但只能这么做，因为在请求量超出Tomcat处理能力时，只能牺牲掉它们，以保全大局。  "
    },
    {
        "article_id": "7189510686760779833",
        "cover_image": "",
        "title": "GitHub Actions 自动部署前端 Vue 项目",
        "brief": "一. 概述 作为前端技术人员，如果要部署一个项目大体要经过：代码开发、代码推送、打包dist文件、scp到服务器、服务器nginx配置、完成部署这几个流程，现实中我们希望项目部署尽可能自动且简单，因此",
        "user_name": "QiShare",
        "view_count": 1716,
        "collect_count": 17,
        "comment_count": 1,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/b176959d34f2461d1748d1af51dc0c8c~300x300.image",
        "category": "前端",
        "content": "### 一. 概述\\n\\n作为前端技术人员，如果要部署一个项目大体要经过：`代码开发`、`代码推送`、`打包dist文件`、`scp到服务器`、`服务器nginx配置`、`完成部署`这几个流程，现实中我们希望项目部署尽可能自动且简单，因此诞生了各种`CI/CD`工具，比如：`Jenkins`、`gitlab ci`、`gitlab runner`等，其实我们最熟悉的 `GitHub` 也提供了`CI/CD` 的能力：`GitHub Actions`,它于2019年11月正式发布，现已经支持多种的语言和框架：**Node.js, Python, Java, PHP, Ruby, Go, Rust, C/C++, .NET, Android, iOS**.当然在利用`GitHub Actions`自动部署项目之前，先要利用`GitHub Pages`来发布我们的前端项目。\\n\\n### 二. GitHub Pages\\n<img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3c64055d94a461fa5218d4cc9235be1~tplv-k3u1fbpfcp-zoom-1.image\\\" alt=\\\"github pages\\\" style=\\\"zoom:35%;\\\" />\\n\\n什么是 `GitHub Pages`？官网的介绍：**Websites for you and your projects.Hosted directly from your GitHub repository. Just edit, push, and your changes are live.** 说的很明确了，可以利用它,将我们托管在 `GitHub` 仓库的项目部署为一个可以对外访问的网站，免去了我们自己购买与配置服务器的麻烦。\\n\\n* **首先创建一个项目**，以Vue项目为例，利用 Vue 脚手架创建一个项目 \\n```bash\\nnpm init vue@latest\\n```\\n\\n这里假设你已经熟悉了 Vue 项目创建，如果不熟悉Vue可以去[查看](https://cn.vuejs.org/guide/quick-start.html#creating-a-vue-application)\\n执行如下命令：\\n\\n```bash\\n> cd <your-project-name>\\n> npm install\\n> npm run dev\\n```\\n运行后在浏览器中打开本地地址，得到如下页面：\\n<img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f46488402cb343f7b4469c4b9006e179~tplv-k3u1fbpfcp-zoom-1.image\\\" alt=\\\"vue\\\" style=\\\"zoom:60%;\\\" />\\n\\n* **在`GitHub`上创建一个新的`Repository`,将项目上传到`GitHub`仓库**\\n```bash\\ngit init\\ngit add .\\ngit commit -m \\\"备注信息\\\"\\ngit remote add origin 你的远程仓库地址\\ngit push -u origin master\\n```\\n* **配置 `GitHub Actions`**\\n  回到`GitHub`,点击`Setting`->`Pages`，看到如下界面\\n  <img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cca3a50ca2c04600b8d946095e348d4e~tplv-k3u1fbpfcp-zoom-1.image\\\" alt=\\\"github\\\" style=\\\"zoom:65%;\\\" />\\n  <img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70662fb3095347df94f217eecba5f2d6~tplv-k3u1fbpfcp-zoom-1.image\\\" alt=\\\"github\\\" style=\\\"zoom:40%;\\\" />\\n  并没有展示网址，别急！此时还需要我们去新建一个名为**gh-pages**的分支，创建完成后再次打开`Pages`，可以看到页面发生了变化\\n  <img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/efc1ba32f0a341aab986f465428e6477~tplv-k3u1fbpfcp-zoom-1.image\\\" alt=\\\"github\\\" style=\\\"zoom:40%;\\\" />\\n> **Source**: 选择`Deploy from a branch`, **Branch**：`github pages` 默认只能识别项目根目录的 `index` 文件，我们这里选择新建的`gh-pages`的`root`根目录，意思是去这个分支的根目录加载`index.html`文件.\\n* **打包应用，并发布到 `gh-pages` 分支**\\n  打包应用，执行`npm run build` ，在项目根目录下得到打包后的产物`dist`文件夹,\\n\\n  <img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/177afc8b3375459c842b1cdee92cce0c~tplv-k3u1fbpfcp-zoom-1.image\\\" alt=\\\"截屏2022-11-18 17.53.12\\\" style=\\\"zoom:50%;\\\" />\\n\\n  切换当前分支到`gh-pages`,并且将原有内容全部删除, 最后将`dist`文件夹下的内容全部拷贝到`gh-pages`上，push到远端. \\n<img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a84f74fc73ab4d8a848f749ebed82cb9~tplv-k3u1fbpfcp-zoom-1.image\\\" alt=\\\"pic\\\" style=\\\"zoom:30%;\\\" />\\n再次点击`Setting`->`Pages` ,稍等一会儿，下面出现了一个网址,这就是项目线上地址\\n<img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8df101b7a8b2413c82de16d4c7de7cce~tplv-k3u1fbpfcp-zoom-1.image\\\" alt=\\\"pci1\\\" style=\\\"zoom:50%;\\\" />\\n\\n* **遇到问题**\\n点击查看网址，并没有像我们预期的那样展示页面，而是一片空白。打开调试版查看错误信息：\\n<img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/82844f1043fb4cfe90beedae10300ed5~tplv-k3u1fbpfcp-zoom-1.image\\\" alt=\\\"pic02\\\" style=\\\"zoom:50%;\\\" />\\n如果有项目部署经验的一看就知道是怎么回事了，这是打包编译后的文件路径配置有问题，资源文件`css`、`js`，加载的路径地址不对，加载的是根路径\\n`https://<用户名>.github.io/assets/index.bf782a5b.js`,而我们的资源文件在`/vue-pages/`目录下，所以当然报错`404`，修复也很简单，如果你的Vue项目是基于 Vite 的构建的，需要修改`vite.config.js`，添加`base:'./'`\\n```jsx\\nexport default defineConfig({\\n  plugins: [vue(), vueJsx()],\\n  base:'./',// 将根路径换成相对路径\\n  resolve: {\\n    alias: {\\n      \\\"@\\\": fileURLToPath(new URL(\\\"./src\\\", import.meta.url)),\\n    },\\n  },\\n})\\n```\\n如果是基于`webpack`构建，修改`vue.config.js`添加`publicPath: './'`.\\n```jsx\\nmodule.exports = {\\n  /**\\n   * publicPath 默认是 / 是根路径，这个是指服务的根路径：https://xxx.github.io/，发布后会从这个路径下找 js.css 等资源，而生成的网站路径是这个 https://xxx.github.io/Vue-Element/，显然是找不到的\\n   * 我们需要修改为 相对路径'./' 或是‘.’ 或是 直接设置的项目子路径 :/项目名称/ 就可找到资源了\\n   */\\n  publicPath: './',\\n  outputDir: 'dist', // dist\\n  assetsDir: 'static',\\n  lintOnSave: process.env.NODE_ENV === 'development',\\n  productionSourceMap: false,\\n...\\n```\\n重新打包，将`dist`文件夹下内容拷贝到`gh-pages`分支下，并重新打开`pages`链接：`https://<用户名>.github.io/vue-pages/`\\n成功部署！\\n\\n> 每一次修改后都要重新打包，切换分支拷贝dist文件夹，实属麻烦，能不能让`GitHub`自动检测`push`动作,自动进行打包部署吗？那就是`GitHub Actions`的工作了.\\n### 三. GitHub Actions\\n#### 什么是`GitHub Actions`?\\n`GitHub Actions`是`GitHub`推出的一款持续集成**（CI/CD）**服务，它给我们提供了虚拟的服务器资源，让我们可以基于它完成自动化测试、集成、部署等操作。这里简单介绍一下它的几个基本概念，更多内容可以去官网[查看](https://github.com/features/actions)\\n\\n#### 基本概念\\n* `Workflows（工作流程）`\\n持续集成的运行过程称为一次工作流程，也就是我们项目开始自动化部署到部署结束的这一段过程可以称为工作流程.\\n\\n* `job （任务）`\\n一个工作流程中包含多个任务，简单来说就是一次自动部署的过程需要完成一个或多个任务.\\n\\n* `step（步骤）`\\n部署项目需要按照一个一个的步骤来进行，每个`job`由多个`step`构成.\\n\\n* `action（动作）`\\n每个步骤`step`可以包含一个或多个动作，比如我们在一个步骤中执行打包命令这个Action.\\n\\n#### 语法简介\\n* **name**\\n`name`字段是`workflow`的名称。如果省略该字段，默认为当前`workflow`的文件名.\\n```yaml\\nname: GitHub CI\\n```\\n* **on**\\n`on`字段指定触发`workflow`的条件，通常是某些事件,比如代码推送`push`,拉取`pull_request`,可以是事件的数组.\\n```yaml\\non: push\\nor\\non: [push, pull_request]\\n```\\n指定触发事件时，可以限定分支或标签:\\n```yaml\\non:\\n  push:\\n    branches:    \\n      - master\\n```\\n上面代码表示：只有`master`分支发生`push`事件时，才会触发`workflow`.\\n\\n* **jobs**\\n  `workflow`的核心就是`jobs`，任务`job`放在`jobs`这个集合下，每一个`job`都有`job_id`，用`job_id`标识一个具体任务\\n* `jobs.<job_id>.name`\\n  任务说明\\n```yaml\\njobs:\\n  my_first_job: // job_id\\n    name: My first job \\n  my_second_job:// job_id\\n    name: My second job\\n```\\n上面的`jobs`字段包含两项任务，`job_id`分别是`my_first_job`和`my_second_job`。\\n\\n* `jobs.<job_id>.runs-on`\\n  `runs-on`字段指定运行所需要的虚拟机环境,它是必填字段。\\n\\n```yaml\\nruns-on: ubuntu-18.04\\n```\\n`GitHub Actions`给我们提提供的运行环境主要有以下几种：\\n**ubuntu-latest**，**ubuntu-18.04或ubuntu-16.04**\\n**windows-latest，windows-2019或windows-2016**\\n**macOS-latest或macOS-10.14**\\n\\n* `jobs.<job_id>.steps`\\n  任务步骤，一个`job`可以包含多个步骤，我们需要分为多个步骤来完成这个任务，每个步骤包含下面三个字段：\\n\\n```jsx\\njobs.<job_id>.steps.name：步骤名称。\\njobs.<job_id>.steps.run：该步骤运行的命令或者 action。\\njobs.<job_id>.steps.env：该步骤所需的环境变量。\\n```\\n#### 使用介绍\\n* 新建.yml文件\\n点击主页`Actions` -> `New workflow` -> `set up a workflow yourself`，当然你也可以选择一个模板，点击`start commit`则会自动在我们项目目录下新建`.github/workflows/main.yml`文件.\\n<img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/beb05aa183be4efbb7f8d256ddf4ac8d~tplv-k3u1fbpfcp-zoom-1.image\\\" alt=\\\"pic\\\" style=\\\"zoom:40%;\\\" />\\n\\n整个`workflow`的核心就是`yml`脚本的书写。如果你需要某个`action`，不必自己写复杂的脚本，直接引用他人写好的 `action`即可，整个持续集成过程，就变成了一个`actions`的组合，你可以在`GitHub`的[官方市场](https://github.com/marketplace?type=actions)，可以搜索到他人提交的`actions`. 下面是我们要自动发布`GitHub pages`所写的脚本：\\n\\n```yaml\\nname: CI Github Pages\\non:\\n  #监听push操作\\n  push:\\n    branches:\\n      - main # 这里只配置了main分支，所以只有推送main分支才会触发以下任务\\njobs:\\n  # 任务ID\\n  build-and-deploy:\\n    # 运行环境\\n    runs-on: ubuntu-latest\\n    # 步骤\\n    steps:\\n      # 官方action，将代码拉取到虚拟机\\n      - name: Checkout  ️ \\n        uses: actions/checkout@v3\\n\\n      - name: Install and Build   # 安装依赖、打包，如果提前已打包好无需这一步\\n        run: |\\n          npm install\\n          npm run build\\n\\n      - name: Deploy   # 部署\\n        uses: JamesIves/github-pages-deploy-action@v4.3.3\\n        with:\\n          branch: gh-pages # 部署后提交到那个分支\\n          folder: dist # 这里填打包好的目录名称\\n```\\n上面整个`workflow`的说明：\\n* 只有当`main`分支有新的`push`推送时候才会执行整个`workflow`.\\n* 整个`workflow`只有一个`job`,`job_id`是`build-and-deploy`,`name`被省略.\\n* `job` 有三个`step`： 第一步是`Checkout`,获取源码，使用的`action`是`GitHub`官方的`actions/checkout`.\\n* 第二步：`Install and Build`,执行了两条命令：`npm install`,`npm run build`,分别安装依赖与打包应用.\\n* 第三步：`Deploy` 部署，使用的第三方`action`：`JamesIves/github-pages-deploy-action@v4.3.3`,它有两个参数：分别是`branch`、`folder`，更多关于这个`action`的详情可以去[查看](https://github.com/marketplace/actions/deploy-to-github-pages).\\n\\n> 当点击**`Start commit`**，`GitHub Actions` 会自动运行`workflow`. 修改工程文字欢迎文字：\\n```jsx\\n<HelloWorld msg=\\\"You did it!\\\" />\\n```\\n改为:\\n```jsx\\n<HelloWorld msg=\\\"GitHub Actions CI Succeed!\\\" />\\n```\\n`push`可以点击`Actions`查看工作流的运行情况\\n<img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ece9baf68a7342d696c817023fac493f~tplv-k3u1fbpfcp-zoom-1.image\\\" alt=\\\"flow1\\\" style=\\\"zoom:30%;\\\" />\\n当这个黄色加载动画变成绿色后表示`workflow`运行完成，看下最终效果：\\n<img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/415a00e1f1a8412288301e8d99cd31d0~tplv-k3u1fbpfcp-zoom-1.image\\\" alt=\\\"flow2\\\" style=\\\"zoom:50%;\\\" />\\n达到了自动部署的目的.\\n\\n### 四. 设置`Custom domain`\\n其实经过上面的三步已经可以实现自动部署的目的了，但是还是有点瑕疵。我们部署后的项目地址是：`https://<用户名>.github.io/vue-pages/`,域名还是`GitHub`的,能不能改成我们自己的专属域名呢？比如改成`http://<用户名>.com/`,那就需要设置`Custom domain`了。\\n#### 1. 购买域名\\n如果想将项目地址改成自己的专属域名，首先需要你去购买一个域名，目前[阿里云](https://wanwang.aliyun.com/domain/searchresult/),[腾讯云](https://dnspod.cloud.tencent.com)都支持域名的购买，搜索自己喜欢的域名直接付款就好了。\\n![domain](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ba16b1c9809485aae71022db7858f59~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n#### 2. 购买域名后，还需要我们进行实名认证以及备案，按照平台的提示进行操作就好了，这里不再涉及.\\n\\n#### 3. 进行DNS解析配置\\n这里以阿里云为例，打开域名解析控制台，点击解析按钮\\n<img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a4d6022f7174783aa30a258465dded1~tplv-k3u1fbpfcp-zoom-1.image\\\" alt=\\\"pic\\\" style=\\\"zoom:30%;\\\" />\\n点击添加记录按钮，将下面两种类型的记录值添加上，记录类型是：`CNAME`，记录值就是你`GitHub`的主域名.\\n<img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ad20832acd44aa4a80853381a290b3f~tplv-k3u1fbpfcp-zoom-1.image\\\" alt=\\\"feak\\\" style=\\\"zoom:40%;\\\" />\\n\\n#### 4. 设置`Custom domain`\\n返回到项目的`GitHub pages`设置页面，将我们购买的域名添加在`Custom domain`中，点击`save`，可以看到`pages`的地址变成了我们自己的域名，访问它就会看到你的网站了.\\n<img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c90378dfce3438a8ee93d3ee2353916~tplv-k3u1fbpfcp-zoom-1.image\\\" alt=\\\"pic\\\" style=\\\"zoom:50%;\\\" />\\n\\n### 五. 小结\\n\\n`GitHub Actions`给我们提供了一站式的自动化部署体验，加上`Custom domain`的设置，完全可以用于搭建我们的个人博客，最重要的是这完全免费. 你也可以用它来部署其他框架的项目，当然这里的重点是的`yml`脚本的书写.\\n\\n\\n一些参考：\\n\\nhttps://pages.github.com\\n\\nhttps://github.com/features/actions\\n\\nhttps://blog.csdn.net/formula10000/article/details/98946098\\n"
    },
    {
        "article_id": "7188728954012844069",
        "cover_image": "https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cfab348baa54b82b5aeabc8fe1c6c16~tplv-k3u1fbpfcp-watermark.image?",
        "title": "elasticsearch实现基于拼音搜索",
        "brief": "一般情况下，有些搜索需求是需要根据拼音和中文来搜索的，那么在elasticsearch中是如何来实现基于拼音来搜索的呢？可以通过elasticsearch-analysis-pinyin来实现",
        "user_name": "huan1993",
        "view_count": 2497,
        "collect_count": 24,
        "comment_count": 3,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/c7e060db76ec24b59e40b9ee84bbbdbd~300x300.image",
        "category": "后端",
        "content": "# 1、背景\\n一般情况下，有些搜索需求是需要根据`拼音`和`中文`来搜索的，那么在`elasticsearch`中是如何来实现基于`拼音`来搜索的呢？可以通过`elasticsearch-analysis-pinyin`分析器来实现。\\n\\n# 2、安装拼音分词器\\n\\n```shell\\n# 进入 es 的插件目录\\ncd /usr/local/es/elasticsearch-8.4.3/plugins\\n# 下载\\nwget https://github.com/medcl/elasticsearch-analysis-pinyin/releases/download/v8.4.3/elasticsearch-analysis-pinyin-8.4.3.zip\\n# 新建目录\\nmkdir analysis-pinyin\\n# 解压\\nmv elasticsearch-analysis-pinyin-8.4.3.zip analysis-pinyin && cd analysis-pinyin && unzip elasticsearch-analysis-pinyin-8.4.3.zip && rm -rvf elasticsearch-analysis-pinyin-8.4.3.zip\\ncd ../ && chown -R es:es analysis-pinyin\\n# 启动es\\n/usr/local/es/elasticsearch-8.4.3/bin/elasticsearch -d\\n```\\n# 3、拼音分词器提供的功能\\n[拼音分词器提供如下功能](https://github.com/medcl/elasticsearch-analysis-pinyin/tree/v8.4.3)\\n![拼音分词器提供的功能](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/091c985c1f8a4787afde674cac55c680~tplv-k3u1fbpfcp-zoom-1.image)\\n`每个选项的含义` 可以通过 文档中的例子来看懂。\\n\\n# 4、简单测试一下拼音分词器\\n## 4.1 dsl\\n```\\nGET _analyze\\n{\\n  \\\"text\\\": [\\\"我是中国人\\\"],\\n  \\\"analyzer\\\": \\\"pinyin\\\"\\n}\\n\\n```\\n\\n` \\\"analyzer\\\": \\\"pinyin\\\"` 此处的`pinyin`是拼音分词器自带的。\\n\\n## 4.2 运行结果\\n![运行结果](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36d819fc130443c3a4b363013a9968a3~tplv-k3u1fbpfcp-zoom-1.image)\\n`从图片上，实现了拼音分词，但是这个不一定满足我们的需求，比如没有中文了，单个的拼音(比如：wo)是没有什么用的，需要对拼音分词器进行定制化。`\\n\\n# 5、es中分词器的组成\\n在`elasticsearch`中分词器`analyzer`由如下三个部分组成：  \\n\\n1.  `character filters：` 用于在`tokenizer`之前对文本进行处理。`比如：`删除字符，替换字符等。\\n2. `tokenizer：`  将文本按照一定的规则分成独立的token。即实现分词功能。 \\n3. `tokenizer filter：` 将`tokenizer`输出的词条做进一步的处理。`比如：` 同义词处理，大小写转换、移除停用词，拼音处理等。\\n\\n![处理流程](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71f13def461c4d878b52e1bdc9c3538c~tplv-k3u1fbpfcp-zoom-1.image)\\n# 6、自定义一个分词器实现拼音和中文的搜索\\n`需求：` 自定义一个分词器，即可以实现拼音搜索，也可以实现中文搜索。\\n \\n## 1、创建mapping\\n```\\nPUT /test_pinyin\\n{\\n  \\\"settings\\\": {\\n    // 分析阶段的设置\\n    \\\"analysis\\\": {\\n      // 分析器设置\\n      \\\"analyzer\\\": {\\n        // 自定义分析器，在tokenizer阶段使用ik_max_word，在filter上使用py\\n        \\\"custom_analyzer\\\": {\\n          \\\"tokenizer\\\": \\\"ik_max_word\\\",\\n          \\\"filter\\\": \\\"custom_pinyin\\\"\\n        }\\n      },\\n      // 由于不满足pinyin分词器的默认设置，所以我们基于pinyin\\n      // 自定义了一个filter，叫custom_pinyin，其中修改了一些设置\\n      // 这些设置可以在pinyin分词器官网找到\\n      \\\"filter\\\": {\\n        \\\"custom_pinyin\\\": {\\n          \\\"type\\\": \\\"pinyin\\\",\\n          // 不会这样分：刘德华 > [liu, de, hua]\\n          \\\"keep_full_pinyin\\\": false,\\n          // 这样分：刘德华 > [liudehua]\\n          \\\"keep_joined_full_pinyin\\\": true,\\n          // 保留原始token（即中文）\\n          \\\"keep_original\\\": true,\\n          // 设置first_letter结果的最大长度，默认值：16\\n          \\\"limit_first_letter_length\\\": 16,\\n          // 当启用此选项时，将删除重复项以保存索引，例如：de的> de，默认值：false，注意：位置相关查询可能受影响\\n          \\\"remove_duplicated_term\\\": true,\\n          // 如果非汉语字母是拼音，则将其拆分为单独的拼音术语，默认值：true，如：liudehuaalibaba13zhuanghan- > liu，de，hua，a，li，ba，ba，13，zhuang，han，注意：keep_none_chinese和keep_none_chinese_together应首先启用\\n          \\\"none_chinese_pinyin_tokenize\\\": false\\n        }\\n      }\\n    }\\n  },\\n  // 定义mapping\\n  \\\"mappings\\\": {\\n    \\\"properties\\\": {\\n      \\\"name\\\": {\\n        \\\"type\\\": \\\"text\\\",\\n        // 创建倒排索引时使用的分词器\\n        \\\"analyzer\\\": \\\"custom_analyzer\\\",\\n        // 搜索时使用的分词器，搜索时不使用custom_analyzer是为了防止 词语的拼音一样，但是中文含义不一样，导致搜索错误。 比如： 科技 和 客机，拼音一样，但是含义不一样\\n        \\\"search_analyzer\\\": \\\"ik_smart\\\"\\n      }\\n    }\\n  }\\n}\\n```\\n**注意：**  \\n可以看到 我们的 `name`字段 使用的分词器是 `custom_analyzer`，这个是我们在上一步定义的。但是搜索的时候使用的是 `ik_smart`，这个为甚么会这样呢？  \\n假设我们存在如下2个文本 `科技强国`和 `这是一架客机`， 那么`科技`和`客机`的拼音是不是就是一样的。 这个时候如果搜索时使用的分词器也是`custom_analyzer`那么，搜索`科技`的时候`客机`也会搜索出来，这样是不对的。因此在搜索的时候中文就以中文搜，拼音就以拼音搜。\\n\\n```\\n{\\n  \\\"name\\\": {\\n    \\\"type\\\": \\\"text\\\",\\n    \\\"analyzer\\\": \\\"custom_analyzer\\\",\\n    \\\"search_analyzer\\\": \\\"ik_smart\\\"\\n  }\\n}\\n```\\n当 `analyzer`和`search_analyzer`的值都是`custom_analyzer`，搜索时也会通过拼音搜索，这样的结果可能就不是我们想要的。\\n\\n## 2、插入数据\\n\\n```\\nPUT /test_pinyin/_bulk\\n{\\\"index\\\":{\\\"_id\\\":1}}\\n{\\\"name\\\": \\\"科技强国\\\"}\\n{\\\"index\\\":{\\\"_id\\\":2}}\\n{\\\"name\\\": \\\"这是一架客机\\\"}\\n{\\\"index\\\":{\\\"_id\\\":3}}\\n```\\n\\n## 3、搜索数据\\n![搜索数据](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c79bb10f496d40f4960845b6f470bdd2~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n# 7、参考文档\\n1、[https://github.com/medcl/elasticsearch-analysis-pinyin/tree/master](https://github.com/medcl/elasticsearch-analysis-pinyin/tree/master)\\n\\n\\n \\n"
    },
    {
        "article_id": "7189525601458815034",
        "cover_image": "",
        "title": "扩散模型课程第一单元第二部分：扩散模型从零到一",
        "brief": "前言 于 11 月底正式开课的扩散模型课程正在火热进行中，在中国社区成员们的帮助下，我们组织了「抱抱脸中文本地化志愿者小组」并完成了扩散模型课程的中文翻译，感谢 @darcula1993、@XhrLe",
        "user_name": "HuggingFace",
        "view_count": 571,
        "collect_count": 0,
        "comment_count": 0,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/4669bc7b9b4076c357aa5e2213898f1b~300x300.image",
        "category": "人工智能",
        "content": "前言\\n----\\n\\n于 11 月底正式开课的扩散模型课程正在火热进行中，在中国社区成员们的帮助下，我们组织了「抱抱脸中文本地化志愿者小组」并完成了扩散模型课程的中文翻译，感谢 @darcula1993、@XhrLeokk、@hoi2022、@SuSung-boy 对课程的翻译！\\n\\n如果你还没有开始课程的学习，我们建议你从 [第一单元：扩散模型简介](https://juejin.cn/post/7189230674635653157) 开始。\\n\\n扩散模型从零到一\\n--------\\n\\n这个 Notebook 我们将展示相同的步骤（向数据添加噪声、创建模型、训练和采样），并尽可能简单地在 PyTorch 中从头开始实现。然后，我们将这个「玩具示例」与 diffusers 版本进行比较，并关注两者的区别以及改进之处。这里的目标是熟悉不同的组件和其中的设计决策，以便在查看新的实现时能够快速确定关键思想。\\n\\n**让我们开始吧！**\\n\\n有时，只考虑一些事务最简单的情况会有助于更好地理解其工作原理。我们将在本笔记本中尝试这一点，从“玩具”扩散模型开始，看看不同的部分是如何工作的，然后再检查它们与更复杂的实现有何不同。\\n\\n你将跟随本文的 Notebook 学习到\\n\\n*   损坏过程（向数据添加噪声）   \\n*   什么是 UNet，以及如何从零开始实现一个极小的 UNet  \\n*   扩散模型训练 \\n*   抽样理论 \\n\\n然后，我们将比较我们的版本与 diffusers 库中的 DDPM 实现的区别\\n\\n*   对小型 UNet 的改进  \\n*   DDPM 噪声计划 \\n*   训练目标的差异\\n*   timestep 调节\\n*   抽样方法\\n    \\n\\n这个笔记本相当深入，如果你对从零开始的深入研究不感兴趣，可以放心地跳过！\\n\\n还值得注意的是，这里的大多数代码都是出于说明的目的，我不建议直接将其用于您自己的工作（除非您只是为了学习目的而尝试改进这里展示的示例）。\\n\\n准备环境与导入：\\n--------\\n\\n```\\n!pip install -q diffusers\\n\\n```\\n```\\nimport torch\\nimport torchvision\\nfrom torch import nn\\nfrom torch.nn import functional as F\\nfrom torch.utils.data import DataLoader\\nfrom diffusers import DDPMScheduler, UNet2DModel\\nfrom matplotlib import pyplot as plt\\n\\ndevice = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\")\\nprint(f'Using device: {device}')\\n```\\n\\n数据\\n----\\n\\n在这里，我们将使用一个非常小的经典数据集 mnist 来进行测试。如果您想在不改变任何其他内容的情况下给模型一个稍微困难一点的挑战，请使用 `torchvision.dataset`，FashionMNIST 应作为替代品。\\n\\n```\\ndataset = torchvision.datasets.MNIST(root=\\\"mnist/\\\", train=True, download=True, transform=torchvision.transforms.ToTensor())\\n```\\n```\\ntrain_dataloader = DataLoader(dataset, batch_size=8, shuffle=True)\\n```\\n```\\nx, y = next(iter(train_dataloader))\\nprint('Input shape:', x.shape)\\nprint('Labels:', y)\\nplt.imshow(torchvision.utils.make_grid(x)[0], cmap='Greys');\\n```\\n\\n该数据集中的每张图都是一个数字的 28x28 像素的灰度图，像素值的范围是从 0 到 1。\\n\\n损坏过程\\n----\\n\\n假设你没有读过任何扩散模型的论文，但你知道这个过程会增加噪声。你会怎么做？\\n\\n我们可能想要一个简单的方法来控制损坏的程度。那么，如果我们要引入一个参数来控制输入的“噪声量”，那么我们会这么做：\\n\\n`noise = torch.rand_like(x)`\\n\\n`noisy_x = (1-amount)*x + amount*noise`\\n\\n如果 amount = 0，则返回输入而不做任何更改。如果 amount = 1，我们将得到一个纯粹的噪声。通过这种方式将输入与噪声混合，我们将输出保持在相同的范围（0 to 1）。\\n\\n我们可以很容易地实现这一点（但是要注意 tensor 的 shape，以防被广播 (broadcasting) 机制不正确的影响到）：\\n\\n```\\ndef corrupt(x, amount):\\n  \\\"\\\"\\\"Corrupt the input `x` by mixing it with noise according to `amount`\\\"\\\"\\\"\\n  noise = torch.rand_like(x)\\n  amount = amount.view(-1, 1, 1, 1) # Sort shape so broadcasting works\\n  return x*(1-amount) + noise*amount \\n```\\n\\n让我们来可视化一下输出的结果，以了解是否符合我们的预期：\\n\\n```\\n# Plotting the input data\\nfig, axs = plt.subplots(2, 1, figsize=(12, 5))\\naxs[0].set_title('Input data')\\naxs[0].imshow(torchvision.utils.make_grid(x)[0], cmap='Greys')\\n\\n# Adding noise\\namount = torch.linspace(0, 1, x.shape[0]) # Left to right -> more corruption\\nnoised_x = corrupt(x, amount)\\n\\n# Plottinf the noised version\\naxs[1].set_title('Corrupted data (-- amount increases -->)')\\naxs[1].imshow(torchvision.utils.make_grid(noised_x)[0], cmap='Greys');\\n```\\n\\n当噪声量接近 1 时，我们的数据开始看起来像纯随机噪声。但对于大多数的噪声情况下，您还是可以很好地识别出数字。你认为这是最佳的吗？\\n\\n模型\\n----\\n\\n我们想要一个模型，它可以接收 28px 的噪声图像，并输出相同形状的预测。一个比较流行的选择是一个叫做 UNet 的架构。最初被发明用于医学图像中的分割任务，UNet 由一个“压缩路径”和一个“扩展路径”组成。“压缩路径”会使通过该路径的数据被压缩，而通过“扩展路径”会将数据扩展回原始维度（类似于自动编码器）。模型中的残差连接也允许信息和梯度在不同层级之间流动。\\n\\n一些 UNet 的设计在每个阶段都有复杂的 blocks，但对于这个玩具 demo，我们只会构建一个最简单的示例，它接收一个单通道图像，并通过下行路径上的三个卷积层（图和代码中的 down\\\\_layers）和上行路径上的 3 个卷积层，在下行和上行层之间具有残差连接。我们将使用 max pooling 进行下采样和 `nn.Upsample` 用于上采样。某些比较复杂的 UNets 的设计会使用带有可学习参数的上采样和下采样 layer。下面的结构图大致展示了每个 layer 的输出通道数：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0466df449b3645e4b318486c80e698e7~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n代码实现如下：\\n\\n```\\nclass BasicUNet(nn.Module):\\n  \\\"\\\"\\\"A minimal UNet implementation.\\\"\\\"\\\"\\n  def __init__(self, in_channels=1, out_channels=1):\\n    super().__init__()\\n    self.down_layers = torch.nn.ModuleList([ \\n      nn.Conv2d(in_channels, 32, kernel_size=5, padding=2),\\n      nn.Conv2d(32, 64, kernel_size=5, padding=2),\\n      nn.Conv2d(64, 64, kernel_size=5, padding=2),\\n    ])\\n    self.up_layers = torch.nn.ModuleList([\\n      nn.Conv2d(64, 64, kernel_size=5, padding=2),\\n      nn.Conv2d(64, 32, kernel_size=5, padding=2),\\n      nn.Conv2d(32, out_channels, kernel_size=5, padding=2), \\n    ])\\n    self.act = nn.SiLU() # The activation function\\n    self.downscale = nn.MaxPool2d(2)\\n    self.upscale = nn.Upsample(scale_factor=2)\\n\\n  def forward(self, x):\\n    h = []\\n    for i, l in enumerate(self.down_layers):\\n      x = self.act(l(x)) # Through the layer n the activation function\\n      if i < 2: # For all but the third (final) down layer:\\n        h.append(x) # Storing output for skip connection\\n        x = self.downscale(x) # Downscale ready for the next layer\\n              \\n    for i, l in enumerate(self.up_layers):\\n      if i > 0: # For all except the first up layer\\n        x = self.upscale(x) # Upscale\\n        x += h.pop() # Fetching stored output (skip connection)\\n        x = self.act(l(x)) # Through the layer n the activation function\\n            \\n    return x\\n\\n```\\n\\n我们可以验证输出 shape 是否如我们期望的那样与输入相同：\\n\\n```\\nnet = BasicUNet()\\nx = torch.rand(8, 1, 28, 28)\\nnet(x).shape\\n\\n```\\n```\\ntorch.Size([8, 1, 28, 28])\\n\\n```\\n\\n该网络有 30 多万个参数：\\n\\n```\\nsum([p.numel() for p in net.parameters()])\\n\\n```\\n```\\n309057\\n\\n```\\n\\n您可以尝试更改每个 layer 中的通道数或尝试不同的结构设计。\\n\\n训练模型\\n----\\n\\n那么，模型到底应该做什么呢？同样，对这个问题有各种不同的看法，但对于这个演示，让我们选择一个简单的框架：给定一个损坏的输入 `noisy_x`，模型应该输出它对原本 `x` 的最佳猜测。我们将通过均方误差将预测与真实值进行比较。\\n\\n我们现在可以尝试训练网络了。\\n\\n*   获取一批数据\\n*   添加随机噪声\\n*   将数据输入模型\\n*   将模型预测与干净图像进行比较，以计算 loss\\n*   更新模型的参数\\n\\n你可以自由进行修改来尝试获得更好的结果！\\n\\n```\\n# Dataloader (you can mess with batch size)\\nbatch_size = 128\\ntrain_dataloader = DataLoader(dataset, batch_size=batch_size, shuffle=True)\\n\\n# How many runs through the data should we do?\\nn_epochs = 3\\n\\n# Create the network\\nnet = BasicUNet()\\nnet.to(device)\\n\\n# Our loss finction\\nloss_fn = nn.MSELoss()\\n\\n# The optimizer\\nopt = torch.optim.Adam(net.parameters(), lr=1e-3) \\n\\n# Keeping a record of the losses for later viewing\\nlosses = []\\n\\n# The training loop\\nfor epoch in range(n_epochs):\\n\\n  for x, y in train_dataloader:\\n    # Get some data and prepare the corrupted version\\n    x = x.to(device) # Data on the GPU\\n    noise_amount = torch.rand(x.shape[0]).to(device) # Pick random noise amounts\\n    noisy_x = corrupt(x, noise_amount) # Create our noisy x\\n\\n    # Get the model prediction\\n    pred = net(noisy_x)\\n\\n    # Calculate the loss\\n    loss = loss_fn(pred, x) # How close is the output to the true 'clean' x?\\n\\n    # Backprop and update the params:\\n    opt.zero_grad()\\n    loss.backward()\\n    opt.step()\\n\\n    # Store the loss for later\\n    losses.append(loss.item())\\n\\n    # Print our the average of the loss values for this epoch:\\n    avg_loss = sum(losses[-len(train_dataloader):])/len(train_dataloader)\\n    print(f'Finished epoch {epoch}. Average loss for this epoch: {avg_loss:05f}')\\n\\n# View the loss curve\\nplt.plot(losses)\\nplt.ylim(0, 0.1);\\n\\n```\\n```\\nFinished epoch 0. Average loss for this epoch: 0.026736\\nFinished epoch 1. Average loss for this epoch: 0.020692\\nFinished epoch 2. Average loss for this epoch: 0.018887\\n\\n```\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2de7dd7f7b9446beb9eb3a9b4f9f18c6~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n我们可以尝试通过抓取一批数据，以不同的数量损坏数据，然后喂进模型获得预测来观察结果：\\n\\n```\\n#@markdown Visualizing model predictions on noisy inputs:\\n\\n# Fetch some data\\nx, y = next(iter(train_dataloader))\\nx = x[:8] # Only using the first 8 for easy plotting\\n\\n# Corrupt with a range of amounts\\namount = torch.linspace(0, 1, x.shape[0]) # Left to right -> more corruption\\nnoised_x = corrupt(x, amount)\\n\\n# Get the model predictions\\nwith torch.no_grad():\\n  preds = net(noised_x.to(device)).detach().cpu()\\n\\n# Plot\\nfig, axs = plt.subplots(3, 1, figsize=(12, 7))\\naxs[0].set_title('Input data')\\naxs[0].imshow(torchvision.utils.make_grid(x)[0].clip(0, 1), cmap='Greys')\\naxs[1].set_title('Corrupted data')\\naxs[1].imshow(torchvision.utils.make_grid(noised_x)[0].clip(0, 1), cmap='Greys')\\naxs[2].set_title('Network Predictions')\\naxs[2].imshow(torchvision.utils.make_grid(preds)[0].clip(0, 1), cmap='Greys');\\n\\n```\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/77c749a5ec1c43468da65897c78931cf~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n你可以看到，对于较低的噪声水平数量，预测的结果相当不错！但是，当噪声水平非常高时，模型能够获得的信息就开始逐渐减少。而当我们达到 amount = 1 时，模型会输出一个模糊的预测，该预测会很接近数据集的平均值。模型通过这样的方式来猜测原始输入。\\n\\n取样（采样）\\n------\\n\\n如果我们在高噪声水平下的预测不是很好，我们如何才能生成图像呢？\\n\\n如果我们从完全随机的噪声开始，检查一下模型预测的结果，然后只朝着预测方向移动一小部分，比如说 20%。现在我们有一个噪声很多的图像，其中可能隐藏了一些关于输入数据的结构的提示，我们可以将其输入到模型中以获得新的预测。希望这个新的预测比第一个稍微好一点（因为我们这一次的输入稍微减少了一点噪声），所以我们可以用这个新的更好的预测再往前迈出一小步。\\n\\n如果一切顺利的话，以上过程重复几次以后我们就会得到一个新的图像！以下图例是迭代了五次以后的结果，左侧是每个阶段的模型输入的可视化，右侧则是预测的去噪图像。请注意，即使模型在第 1 步就预测了去噪图像，我们也只是将输入向去噪图像变换了一小部分。重复几次以后，图像的结构开始逐渐出现并得到改善 , 直到获得我们的最终结果为止。\\n\\n```\\n#@markdown Sampling strategy: Break the process into 5 steps and move 1/5'th of the way there each time:\\nn_steps = 5\\nx = torch.rand(8, 1, 28, 28).to(device) # Start from random\\nstep_history = [x.detach().cpu()]\\npred_output_history = []\\n\\nfor i in range(n_steps):\\n  with torch.no_grad(): # No need to track gradients during inference\\n    pred = net(x) # Predict the denoised x0\\n  pred_output_history.append(pred.detach().cpu()) # Store model output for plotting\\n  mix_factor = 1/(n_steps - i) # How much we move towards the prediction\\n  x = x*(1-mix_factor) + pred*mix_factor # Move part of the way there\\n  step_history.append(x.detach().cpu()) # Store step for plotting\\n\\nfig, axs = plt.subplots(n_steps, 2, figsize=(9, 4), sharex=True)\\naxs[0,0].set_title('x (model input)')\\naxs[0,1].set_title('model prediction')\\nfor i in range(n_steps):\\n  axs[i, 0].imshow(torchvision.utils.make_grid(step_history[i])[0].clip(0, 1), cmap='Greys')\\n  axs[i, 1].imshow(torchvision.utils.make_grid(pred_output_history[i])[0].clip(0, 1), cmap='Greys')\\n\\n```\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4cd63b2563ca4286bb3495f0ef1861d3~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n我们可以将流程分成更多步骤，并希望通过这种方式获得更好的图像：\\n\\n```\\n#@markdown Showing more results, using 40 sampling steps\\nn_steps = 40\\nx = torch.rand(64, 1, 28, 28).to(device)\\nfor i in range(n_steps):\\n  noise_amount = torch.ones((x.shape[0], )).to(device) * (1-(i/n_steps)) # Starting high going low\\n  with torch.no_grad():\\n    pred = net(x)\\n  mix_factor = 1/(n_steps - i)\\n  x = x*(1-mix_factor) + pred*mix_factor\\nfig, ax = plt.subplots(1, 1, figsize=(12, 12))\\nax.imshow(torchvision.utils.make_grid(x.detach().cpu(), nrow=8)[0].clip(0, 1), cmap='Greys')\\n\\n```\\n```\\n<matplotlib.image.AxesImage at 0x7f27567d8210>\\n\\n```\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb7a236613ba440d87f21c290ce109a4~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n结果并不是非常好，但是已经出现了一些可以被认出来的数字！您可以尝试训练更长时间（例如，10 或 20 个 epoch），并调整模型配置、学习率、优化器等。此外，如果您想尝试稍微困难一点的数据集，您可以尝试一下 fashionMNIST，只需要一行代码的替换就可以了。\\n\\n与 DDPM 做比较\\n----------\\n\\n在本节中，我们将看看我们的“玩具”实现与其他笔记本中使用的基于 DDPM 论文的方法有何不同: [扩散器简介 Notebook](https://github.com/huggingface/diffusion-models-class/blob/main/unit1/01\\\\_introduction\\\\_to\\\\_diffusers.ipynb)。\\n\\n我们将会看到的\\n\\n*   模型的表现受限于随迭代周期 (timesteps) 变化的控制条件，在前向传导中时间步 (t) 是作为一个参数被传入的\\n*   有很多不同的取样策略可选择，可能会比我们上面所使用的最简单的版本更好\\n*   diffusers `UNet2DModel` 比我们的 BasicUNet 更先进\\n*   损坏过程的处理方式不同\\n*   训练目标不同，包括预测噪声而不是去噪图像\\n*   该模型通过调节 timestep 来调节噪声水平 , 其中 t 作为一个附加参数传入前向过程中。\\n*   有许多不同的采样策略可供选择，它们应该比我们上面简单的版本更有效。\\n    \\n\\n自 DDPM 论文发表以来，已经有人提出了许多改进建议，但这个例子对于不同的可用设计决策具有指导意义。读完这篇文章后，你可能会想要深入了解这篇论文《[Elucidating the Design Space of Diffusion-Based Generative Models](https://arxiv.org/abs/2206.00364)》，它对所有这些组件进行了详细的探讨，并就如何获得最佳性能提出了新的建议。\\n\\n如果你觉得这些内容对你来说太过深奥了，请不要担心！你可以随意跳过本笔记本的其余部分或将其保存以备不时之需。\\n\\n### UNet\\n\\ndiffusers 中的 UNet2DModel 模型比上述基本 UNet 模型有许多改进：\\n\\n*   GroupNorm 层对每个 blocks 的输入进行了组标准化（group normalization） \\n*   Dropout 层能使训练更平滑\\n*   每个块有多个 resnet 层（如果 layers\\\\_per\\\\_block 未设置为 1）\\n*   注意机制（通常仅用于输入分辨率较低的 blocks）\\n*   timestep 的调节。\\n*   具有可学习参数的下采样和上采样块\\n\\n让我们来创建并仔细研究一下 UNet2DModel：\\n\\n```\\nmodel = UNet2DModel(\\n  sample_size=28,           # the target image resolution\\n  in_channels=1,            # the number of input channels, 3 for RGB images\\n  out_channels=1,           # the number of output channels\\n  layers_per_block=2,       # how many ResNet layers to use per UNet block\\n  block_out_channels=(32, 64, 64), # Roughly matching our basic unet example\\n  down_block_types=( \\n    \\\"DownBlock2D\\\",        # a regular ResNet downsampling block\\n    \\\"AttnDownBlock2D\\\",    # a ResNet downsampling block w/ spatial self-attention\\n    \\\"AttnDownBlock2D\\\",\\n  ), \\n  up_block_types=(\\n    \\\"AttnUpBlock2D\\\", \\n    \\\"AttnUpBlock2D\\\",      # a ResNet upsampling block with spatial self-attention\\n    \\\"UpBlock2D\\\",          # a regular ResNet upsampling block\\n  ),\\n)\\nprint(model)\\n\\n```\\n```\\nUNet2DModel(\\n  (conv_in): Conv2d(1, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\\n  (time_proj): Timesteps()\\n  (time_embedding): TimestepEmbedding(\\n    (linear_1): Linear(in_features=32, out_features=128, bias=True)\\n    (act): SiLU()\\n    (linear_2): Linear(in_features=128, out_features=128, bias=True)\\n  )\\n  (down_blocks): ModuleList(\\n    (0): DownBlock2D(\\n      (resnets): ModuleList(\\n        (0): ResnetBlock2D(\\n          (norm1): GroupNorm(32, 32, eps=1e-05, affine=True)\\n          (conv1): Conv2d(32, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\\n          (time_emb_proj): Linear(in_features=128, out_features=32, bias=True)\\n          (norm2): GroupNorm(32, 32, eps=1e-05, affine=True)\\n          (dropout): Dropout(p=0.0, inplace=False)\\n          (conv2): Conv2d(32, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\\n          (nonlinearity): SiLU()\\n        )\\n        (1): ResnetBlock2D(\\n          (norm1): GroupNorm(32, 32, eps=1e-05, affine=True)\\n          (conv1): Conv2d(32, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\\n          (time_emb_proj): Linear(in_features=128, out_features=32, bias=True)\\n          (norm2): GroupNorm(32, 32, eps=1e-05, affine=True)\\n          (dropout): Dropout(p=0.0, inplace=False)\\n          (conv2): Conv2d(32, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\\n          (nonlinearity): SiLU()\\n        )\\n      )\\n      (downsamplers): ModuleList(\\n        (0): Downsample2D(\\n          (conv): Conv2d(32, 32, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1))\\n        )\\n      )\\n    )\\n    (1): AttnDownBlock2D(\\n      (attentions): ModuleList(\\n        (0): AttentionBlock(\\n          (group_norm): GroupNorm(32, 64, eps=1e-05, affine=True)\\n          (query): Linear(in_features=64, out_features=64, bias=True)\\n          (key): Linear(in_features=64, out_features=64, bias=True)\\n          (value): Linear(in_features=64, out_features=64, bias=True)\\n          (proj_attn): Linear(in_features=64, out_features=64, bias=True)\\n        )\\n        (1): AttentionBlock(\\n          (group_norm): GroupNorm(32, 64, eps=1e-05, affine=True)\\n          (query): Linear(in_features=64, out_features=64, bias=True)\\n          (key): Linear(in_features=64, out_features=64, bias=True)\\n          (value): Linear(in_features=64, out_features=64, bias=True)\\n          (proj_attn): Linear(in_features=64, out_features=64, bias=True)\\n        )\\n      )\\n      (resnets): ModuleList(\\n        (0): ResnetBlock2D(\\n          (norm1): GroupNorm(32, 32, eps=1e-05, affine=True)\\n          (conv1): Conv2d(32, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\\n          (time_emb_proj): Linear(in_features=128, out_features=64, bias=True)\\n          (norm2): GroupNorm(32, 64, eps=1e-05, affine=True)\\n          (dropout): Dropout(p=0.0, inplace=False)\\n          (conv2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\\n          (nonlinearity): SiLU()\\n          (conv_shortcut): Conv2d(32, 64, kernel_size=(1, 1), stride=(1, 1))\\n        )\\n        (1): ResnetBlock2D(\\n          (norm1): GroupNorm(32, 64, eps=1e-05, affine=True)\\n          (conv1): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\\n          (time_emb_proj): Linear(in_features=128, out_features=64, bias=True)\\n          (norm2): GroupNorm(32, 64, eps=1e-05, affine=True)\\n          (dropout): Dropout(p=0.0, inplace=False)\\n          (conv2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\\n          (nonlinearity): SiLU()\\n        )\\n      )\\n      (downsamplers): ModuleList(\\n        (0): Downsample2D(\\n          (conv): Conv2d(64, 64, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1))\\n        )\\n      )\\n    )\\n    (2): AttnDownBlock2D(\\n      (attentions): ModuleList(\\n        (0): AttentionBlock(\\n          (group_norm): GroupNorm(32, 64, eps=1e-05, affine=True)\\n          (query): Linear(in_features=64, out_features=64, bias=True)\\n          (key): Linear(in_features=64, out_features=64, bias=True)\\n          (value): Linear(in_features=64, out_features=64, bias=True)\\n          (proj_attn): Linear(in_features=64, out_features=64, bias=True)\\n        )\\n        (1): AttentionBlock(\\n          (group_norm): GroupNorm(32, 64, eps=1e-05, affine=True)\\n          (query): Linear(in_features=64, out_features=64, bias=True)\\n          (key): Linear(in_features=64, out_features=64, bias=True)\\n          (value): Linear(in_features=64, out_features=64, bias=True)\\n          (proj_attn): Linear(in_features=64, out_features=64, bias=True)\\n        )\\n      )\\n      (resnets): ModuleList(\\n        (0): ResnetBlock2D(\\n          (norm1): GroupNorm(32, 64, eps=1e-05, affine=True)\\n          (conv1): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\\n          (time_emb_proj): Linear(in_features=128, out_features=64, bias=True)\\n          (norm2): GroupNorm(32, 64, eps=1e-05, affine=True)\\n          (dropout): Dropout(p=0.0, inplace=False)\\n          (conv2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\\n          (nonlinearity): SiLU()\\n        )\\n        (1): ResnetBlock2D(\\n          (norm1): GroupNorm(32, 64, eps=1e-05, affine=True)\\n          (conv1): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\\n          (time_emb_proj): Linear(in_features=128, out_features=64, bias=True)\\n          (norm2): GroupNorm(32, 64, eps=1e-05, affine=True)\\n          (dropout): Dropout(p=0.0, inplace=False)\\n          (conv2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\\n          (nonlinearity): SiLU()\\n        )\\n      )\\n    )\\n  )\\n  (up_blocks): ModuleList(\\n    (0): AttnUpBlock2D(\\n      (attentions): ModuleList(\\n        (0): AttentionBlock(\\n          (group_norm): GroupNorm(32, 64, eps=1e-05, affine=True)\\n          (query): Linear(in_features=64, out_features=64, bias=True)\\n          (key): Linear(in_features=64, out_features=64, bias=True)\\n          (value): Linear(in_features=64, out_features=64, bias=True)\\n          (proj_attn): Linear(in_features=64, out_features=64, bias=True)\\n        )\\n        (1): AttentionBlock(\\n          (group_norm): GroupNorm(32, 64, eps=1e-05, affine=True)\\n          (query): Linear(in_features=64, out_features=64, bias=True)\\n          (key): Linear(in_features=64, out_features=64, bias=True)\\n          (value): Linear(in_features=64, out_features=64, bias=True)\\n          (proj_attn): Linear(in_features=64, out_features=64, bias=True)\\n        )\\n        (2): AttentionBlock(\\n          (group_norm): GroupNorm(32, 64, eps=1e-05, affine=True)\\n          (query): Linear(in_features=64, out_features=64, bias=True)\\n          (key): Linear(in_features=64, out_features=64, bias=True)\\n          (value): Linear(in_features=64, out_features=64, bias=True)\\n          (proj_attn): Linear(in_features=64, out_features=64, bias=True)\\n        )\\n      )\\n      (resnets): ModuleList(\\n        (0): ResnetBlock2D(\\n          (norm1): GroupNorm(32, 128, eps=1e-05, affine=True)\\n          (conv1): Conv2d(128, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\\n          (time_emb_proj): Linear(in_features=128, out_features=64, bias=True)\\n          (norm2): GroupNorm(32, 64, eps=1e-05, affine=True)\\n          (dropout): Dropout(p=0.0, inplace=False)\\n          (conv2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\\n          (nonlinearity): SiLU()\\n          (conv_shortcut): Conv2d(128, 64, kernel_size=(1, 1), stride=(1, 1))\\n        )\\n        (1): ResnetBlock2D(\\n          (norm1): GroupNorm(32, 128, eps=1e-05, affine=True)\\n          (conv1): Conv2d(128, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\\n          (time_emb_proj): Linear(in_features=128, out_features=64, bias=True)\\n          (norm2): GroupNorm(32, 64, eps=1e-05, affine=True)\\n          (dropout): Dropout(p=0.0, inplace=False)\\n          (conv2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\\n          (nonlinearity): SiLU()\\n          (conv_shortcut): Conv2d(128, 64, kernel_size=(1, 1), stride=(1, 1))\\n        )\\n        (2): ResnetBlock2D(\\n          (norm1): GroupNorm(32, 128, eps=1e-05, affine=True)\\n          (conv1): Conv2d(128, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\\n          (time_emb_proj): Linear(in_features=128, out_features=64, bias=True)\\n          (norm2): GroupNorm(32, 64, eps=1e-05, affine=True)\\n          (dropout): Dropout(p=0.0, inplace=False)\\n          (conv2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\\n          (nonlinearity): SiLU()\\n          (conv_shortcut): Conv2d(128, 64, kernel_size=(1, 1), stride=(1, 1))\\n        )\\n      )\\n      (upsamplers): ModuleList(\\n        (0): Upsample2D(\\n          (conv): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\\n        )\\n      )\\n    )\\n    (1): AttnUpBlock2D(\\n      (attentions): ModuleList(\\n        (0): AttentionBlock(\\n          (group_norm): GroupNorm(32, 64, eps=1e-05, affine=True)\\n          (query): Linear(in_features=64, out_features=64, bias=True)\\n          (key): Linear(in_features=64, out_features=64, bias=True)\\n          (value): Linear(in_features=64, out_features=64, bias=True)\\n          (proj_attn): Linear(in_features=64, out_features=64, bias=True)\\n        )\\n        (1): AttentionBlock(\\n          (group_norm): GroupNorm(32, 64, eps=1e-05, affine=True)\\n          (query): Linear(in_features=64, out_features=64, bias=True)\\n          (key): Linear(in_features=64, out_features=64, bias=True)\\n          (value): Linear(in_features=64, out_features=64, bias=True)\\n          (proj_attn): Linear(in_features=64, out_features=64, bias=True)\\n        )\\n        (2): AttentionBlock(\\n          (group_norm): GroupNorm(32, 64, eps=1e-05, affine=True)\\n          (query): Linear(in_features=64, out_features=64, bias=True)\\n          (key): Linear(in_features=64, out_features=64, bias=True)\\n          (value): Linear(in_features=64, out_features=64, bias=True)\\n          (proj_attn): Linear(in_features=64, out_features=64, bias=True)\\n        )\\n      )\\n      (resnets): ModuleList(\\n        (0): ResnetBlock2D(\\n          (norm1): GroupNorm(32, 128, eps=1e-05, affine=True)\\n          (conv1): Conv2d(128, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\\n          (time_emb_proj): Linear(in_features=128, out_features=64, bias=True)\\n          (norm2): GroupNorm(32, 64, eps=1e-05, affine=True)\\n          (dropout): Dropout(p=0.0, inplace=False)\\n          (conv2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\\n          (nonlinearity): SiLU()\\n          (conv_shortcut): Conv2d(128, 64, kernel_size=(1, 1), stride=(1, 1))\\n        )\\n        (1): ResnetBlock2D(\\n          (norm1): GroupNorm(32, 128, eps=1e-05, affine=True)\\n          (conv1): Conv2d(128, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\\n          (time_emb_proj): Linear(in_features=128, out_features=64, bias=True)\\n          (norm2): GroupNorm(32, 64, eps=1e-05, affine=True)\\n          (dropout): Dropout(p=0.0, inplace=False)\\n          (conv2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\\n          (nonlinearity): SiLU()\\n          (conv_shortcut): Conv2d(128, 64, kernel_size=(1, 1), stride=(1, 1))\\n        )\\n        (2): ResnetBlock2D(\\n          (norm1): GroupNorm(32, 96, eps=1e-05, affine=True)\\n          (conv1): Conv2d(96, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\\n          (time_emb_proj): Linear(in_features=128, out_features=64, bias=True)\\n          (norm2): GroupNorm(32, 64, eps=1e-05, affine=True)\\n          (dropout): Dropout(p=0.0, inplace=False)\\n          (conv2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\\n          (nonlinearity): SiLU()\\n          (conv_shortcut): Conv2d(96, 64, kernel_size=(1, 1), stride=(1, 1))\\n        )\\n      )\\n      (upsamplers): ModuleList(\\n        (0): Upsample2D(\\n          (conv): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\\n        )\\n      )\\n    )\\n    (2): UpBlock2D(\\n      (resnets): ModuleList(\\n        (0): ResnetBlock2D(\\n          (norm1): GroupNorm(32, 96, eps=1e-05, affine=True)\\n          (conv1): Conv2d(96, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\\n          (time_emb_proj): Linear(in_features=128, out_features=32, bias=True)\\n          (norm2): GroupNorm(32, 32, eps=1e-05, affine=True)\\n          (dropout): Dropout(p=0.0, inplace=False)\\n          (conv2): Conv2d(32, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\\n          (nonlinearity): SiLU()\\n          (conv_shortcut): Conv2d(96, 32, kernel_size=(1, 1), stride=(1, 1))\\n        )\\n        (1): ResnetBlock2D(\\n          (norm1): GroupNorm(32, 64, eps=1e-05, affine=True)\\n          (conv1): Conv2d(64, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\\n          (time_emb_proj): Linear(in_features=128, out_features=32, bias=True)\\n          (norm2): GroupNorm(32, 32, eps=1e-05, affine=True)\\n          (dropout): Dropout(p=0.0, inplace=False)\\n          (conv2): Conv2d(32, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\\n          (nonlinearity): SiLU()\\n          (conv_shortcut): Conv2d(64, 32, kernel_size=(1, 1), stride=(1, 1))\\n        )\\n        (2): ResnetBlock2D(\\n          (norm1): GroupNorm(32, 64, eps=1e-05, affine=True)\\n          (conv1): Conv2d(64, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\\n          (time_emb_proj): Linear(in_features=128, out_features=32, bias=True)\\n          (norm2): GroupNorm(32, 32, eps=1e-05, affine=True)\\n          (dropout): Dropout(p=0.0, inplace=False)\\n          (conv2): Conv2d(32, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\\n          (nonlinearity): SiLU()\\n          (conv_shortcut): Conv2d(64, 32, kernel_size=(1, 1), stride=(1, 1))\\n        )\\n      )\\n    )\\n  )\\n  (mid_block): UNetMidBlock2D(\\n    (attentions): ModuleList(\\n      (0): AttentionBlock(\\n        (group_norm): GroupNorm(32, 64, eps=1e-05, affine=True)\\n        (query): Linear(in_features=64, out_features=64, bias=True)\\n        (key): Linear(in_features=64, out_features=64, bias=True)\\n        (value): Linear(in_features=64, out_features=64, bias=True)\\n        (proj_attn): Linear(in_features=64, out_features=64, bias=True)\\n      )\\n    )\\n    (resnets): ModuleList(\\n      (0): ResnetBlock2D(\\n        (norm1): GroupNorm(32, 64, eps=1e-05, affine=True)\\n        (conv1): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\\n        (time_emb_proj): Linear(in_features=128, out_features=64, bias=True)\\n        (norm2): GroupNorm(32, 64, eps=1e-05, affine=True)\\n        (dropout): Dropout(p=0.0, inplace=False)\\n        (conv2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\\n        (nonlinearity): SiLU()\\n      )\\n      (1): ResnetBlock2D(\\n        (norm1): GroupNorm(32, 64, eps=1e-05, affine=True)\\n        (conv1): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\\n        (time_emb_proj): Linear(in_features=128, out_features=64, bias=True)\\n        (norm2): GroupNorm(32, 64, eps=1e-05, affine=True)\\n        (dropout): Dropout(p=0.0, inplace=False)\\n        (conv2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\\n        (nonlinearity): SiLU()\\n      )\\n    )\\n  )\\n  (conv_norm_out): GroupNorm(32, 32, eps=1e-05, affine=True)\\n  (conv_act): SiLU()\\n  (conv_out): Conv2d(32, 1, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\\n)\\n\\n```\\n\\n正如你所看到的，还有更多！它比我们的 BasicUNet 有多得多的参数量：\\n\\n```\\nsum([p.numel() for p in model.parameters()]) # 1.7M vs the ~309k parameters of the BasicUNet\\n\\n```\\n```\\n1707009\\n\\n```\\n\\n我们可以用这个模型代替原来的模型来重复一遍上面展示的训练过程。我们需要将 x 和 timestep 传递给模型（这里我会传递 t = 0，以表明它在没有 timestep 条件的情况下工作，并保持采样代码简单，但您也可以尝试输入 `(amount*1000)`，使 timestep 与噪声水平相当）。如果要检查代码，更改的行将显示为“`#<<<`。\\n\\n```\\n#@markdown Trying UNet2DModel instead of BasicUNet:\\n\\n# Dataloader (you can mess with batch size)\\nbatch_size = 128\\ntrain_dataloader = DataLoader(dataset, batch_size=batch_size, shuffle=True)\\n\\n# How many runs through the data should we do?\\nn_epochs = 3\\n\\n# Create the network\\nnet = UNet2DModel(\\n  sample_size=28,  # the target image resolution\\n  in_channels=1,  # the number of input channels, 3 for RGB images\\n  out_channels=1,  # the number of output channels\\n  layers_per_block=2,  # how many ResNet layers to use per UNet block\\n  block_out_channels=(32, 64, 64),  # Roughly matching our basic unet example\\n  down_block_types=( \\n    \\\"DownBlock2D\\\",  # a regular ResNet downsampling block\\n    \\\"AttnDownBlock2D\\\",  # a ResNet downsampling block with spatial self-attention\\n    \\\"AttnDownBlock2D\\\",\\n  ), \\n  up_block_types=(\\n    \\\"AttnUpBlock2D\\\", \\n    \\\"AttnUpBlock2D\\\",  # a ResNet upsampling block with spatial self-attention\\n    \\\"UpBlock2D\\\",   # a regular ResNet upsampling block\\n  ),\\n) #<<<\\nnet.to(device)\\n\\n# Our loss finction\\nloss_fn = nn.MSELoss()\\n\\n# The optimizer\\nopt = torch.optim.Adam(net.parameters(), lr=1e-3) \\n\\n# Keeping a record of the losses for later viewing\\nlosses = []\\n\\n# The training loop\\nfor epoch in range(n_epochs):\\n\\n  for x, y in train_dataloader:\\n\\n    # Get some data and prepare the corrupted version\\n    x = x.to(device) # Data on the GPU\\n    noise_amount = torch.rand(x.shape[0]).to(device) # Pick random noise amounts\\n    noisy_x = corrupt(x, noise_amount) # Create our noisy x\\n\\n    # Get the model prediction\\n    pred = net(noisy_x, 0).sample #<<< Using timestep 0 always, adding .sample\\n\\n    # Calculate the loss\\n    loss = loss_fn(pred, x) # How close is the output to the true 'clean' x?\\n\\n    # Backprop and update the params:\\n    opt.zero_grad()\\n    loss.backward()\\n    opt.step()\\n\\n    # Store the loss for later\\n    losses.append(loss.item())\\n\\n    # Print our the average of the loss values for this epoch:\\n    avg_loss = sum(losses[-len(train_dataloader):])/len(train_dataloader)\\n    print(f'Finished epoch {epoch}. Average loss for this epoch: {avg_loss:05f}')\\n\\n# Plot losses and some samples\\nfig, axs = plt.subplots(1, 2, figsize=(12, 5))\\n\\n# Losses\\naxs[0].plot(losses)\\naxs[0].set_ylim(0, 0.1)\\naxs[0].set_title('Loss over time')\\n\\n# Samples\\nn_steps = 40\\nx = torch.rand(64, 1, 28, 28).to(device)\\nfor i in range(n_steps):\\n  noise_amount = torch.ones((x.shape[0], )).to(device) * (1-(i/n_steps)) # Starting high going low\\n  with torch.no_grad():\\n    pred = net(x, 0).sample\\n  mix_factor = 1/(n_steps - i)\\n  x = x*(1-mix_factor) + pred*mix_factor\\n\\naxs[1].imshow(torchvision.utils.make_grid(x.detach().cpu(), nrow=8)[0].clip(0, 1), cmap='Greys')\\naxs[1].set_title('Generated Samples');\\n\\n```\\n```\\nFinished epoch 0. Average loss for this epoch: 0.018925\\nFinished epoch 1. Average loss for this epoch: 0.012785\\nFinished epoch 2. Average loss for this epoch: 0.011694\\n\\n```\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d90158a83cc54f35b1f047f371635717~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n这看起来比我们的第一组结果好多了！您可以尝试调整 UNet 配置或更长时间的训练，以获得更好的性能。\\n\\n### 损坏过程\\n\\nDDPM 论文描述了一个为每个“timestep”添加少量噪声的损坏过程。为某些 timestep 给定 , 我们可以得到一个噪声稍稍增加的 :  \\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c4ec5d5734946f3828fb6a06ffdfcfd~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n这就是说，我们取 , 给他一个 的系数，然后加上带有 系数的噪声。这里 是根据一些管理器来为每一个 t 设定的，来决定每一个迭代周期中添加多少噪声。现在，我们不想把这个推演进行 500 次来得到 ，所以我们用另一个公式来根据给出的 计算得到任意 t 时刻的 :  \\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e286c6730e143b09d7ec848de660f9f~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n数学符号看起来总是很吓人！幸运的是，调度器为我们处理了所有这些（取消下一个单元格的注释以检查代码）。我们可以画出 (标记为 `sqrt_alpha_prod`) 和 (标记为 `sqrt_one_minus_alpha_prod`) 来看一下输入 (x) 与噪声是如何在不同迭代周期中量化和叠加的 :\\n\\n```\\n#??noise_scheduler.add_noise\\n\\n```\\n```\\nnoise_scheduler = DDPMScheduler(num_train_timesteps=1000)\\nplt.plot(noise_scheduler.alphas_cumprod.cpu() ** 0.5, label=r\\\"${\\\\sqrt{\\\\bar{\\\\alpha}_t}}$\\\")\\nplt.plot((1 - noise_scheduler.alphas_cumprod.cpu()) ** 0.5, label=r\\\"$\\\\sqrt{(1 - \\\\bar{\\\\alpha}_t)}$\\\")\\nplt.legend(fontsize=\\\"x-large\\\");\\n\\n```\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1246306dfe024439bf175dcc268c4d24~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n一开始 , 噪声 x 里绝大部分都是 x 自身的值  (sqrt\\\\_alpha\\\\_prod ~= 1)，但是随着时间的推移，x 的成分逐渐降低而噪声的成分逐渐增加。与我们根据 `amount` 对 x 和噪声进行线性混合不同，这个噪声的增加相对较快。我们可以在一些数据上看到这一点：\\n\\n```\\n#@markdown visualize the DDPM noising process for different timesteps:\\n\\n# Noise a batch of images to view the effect\\nfig, axs = plt.subplots(3, 1, figsize=(16, 10))\\nxb, yb = next(iter(train_dataloader))\\nxb = xb.to(device)[:8]\\nxb = xb * 2. - 1. # Map to (-1, 1)\\nprint('X shape', xb.shape)\\n\\n# Show clean inputs\\naxs[0].imshow(torchvision.utils.make_grid(xb[:8])[0].detach().cpu(), cmap='Greys')\\naxs[0].set_title('Clean X')\\n\\n# Add noise with scheduler\\ntimesteps = torch.linspace(0, 999, 8).long().to(device)\\nnoise = torch.randn_like(xb) # << NB: randn not rand\\nnoisy_xb = noise_scheduler.add_noise(xb, noise, timesteps)\\nprint('Noisy X shape', noisy_xb.shape)\\n\\n# Show noisy version (with and without clipping)\\naxs[1].imshow(torchvision.utils.make_grid(noisy_xb[:8])[0].detach().cpu().clip(-1, 1),  cmap='Greys')\\naxs[1].set_title('Noisy X (clipped to (-1, 1)')\\naxs[2].imshow(torchvision.utils.make_grid(noisy_xb[:8])[0].detach().cpu(),  cmap='Greys')\\naxs[2].set_title('Noisy X');\\n\\n```\\n```\\nX shape torch.Size([8, 1, 28, 28])\\nNoisy X shape torch.Size([8, 1, 28, 28])\\n\\n```\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8322d3cd0be4cbb867b2363d1d99019~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n在运行中的另一个变化：在 DDPM 版本中，加入的噪声是取自一个高斯分布（来自均值 0 方差 1 的 torch.randn），而不是在我们原始 `corrupt` 函数中使用的 0-1 之间的均匀分布（torch.rand），当然对训练数据做正则化也可以理解。在另一篇笔记中，你会看到 `Normalize(0.5, 0.5)` 函数在变化列表中，它把图片数据从 (0, 1) 区间映射到 (-1, 1)，对我们的目标来说也‘足够用了’。我们在此篇笔记中没使用这个方法，但在上面的可视化中为了更好的展示添加了这种做法。\\n\\n### 训练目标\\n\\n在我们的玩具示例中，我们让模型尝试预测去噪图像。在 DDPM 和许多其他扩散模型实现中，模型则会预测损坏过程中使用的噪声（在缩放之前，因此是单位方差噪声）。在代码中，它看起来像是这样：\\n\\n```\\nnoise = torch.randn_like(xb) # << NB: randn not rand\\nnoisy_x = noise_scheduler.add_noise(x, noise, timesteps)\\nmodel_prediction = model(noisy_x, timesteps).sample\\nloss = mse_loss(model_prediction, noise) # noise as the target\\n\\n```\\n\\n你可能认为预测噪声（我们可以从中得出去噪图像的样子）等同于直接预测去噪图像。那么，为什么要这么做呢？这仅仅是为了数学上的方便吗？\\n\\n这里其实还有另一些精妙之处。我们在训练过程中，会计算不同（随机选择）timestep 的 loss。这些不同的目标将导致这些 loss 的不同的“隐含权重”，其中预测噪声会将更多的权重放在较低的噪声水平上。你可以选择更复杂的目标来改变这种“隐性损失权重”。或者，您选择的噪声管理器将在较高的噪声水平下产生更多的示例。也许你让模型设计成预测 “velocity” v，我们将其定义为由噪声水平影响的图像和噪声组合（请参阅“扩散模型快速采样的渐进蒸馏”- 'PROGRESSIVE DISTILLATION FOR FAST SAMPLING OF DIFFUSION MODELS'）。也许你将模型设计成预测噪声，然后基于某些因子来对 loss 进行缩放：比如有些理论指出可以参考噪声水平（参见“扩散模型的感知优先训练”-'Perception Prioritized Training of Diffusion Models'），或者基于一些探索模型最佳噪声水平的实验（参见“基于扩散的生成模型的设计空间说明”-'Elucidating the Design Space of Diffusion-Based Generative Models'）。\\n\\n一句话解释：选择目标对模型性能有影响，现在有许多研究者正在探索“最佳”选项是什么。目前，预测噪声（epsilon 或 eps）是最流行的方法，但随着时间的推移，我们很可能会看到库中支持的其他目标，并在不同的情况下使用。\\n\\n### 迭代周期（Timestep）调节\\n\\nUNet2DModel 以 x 和 timestep 为输入。后者被转化为一个嵌入（embedding），并在多个地方被输入到模型中。\\n\\n这背后的理论支持是这样的：通过向模型提供有关噪声水平的信息，它可以更好地执行任务。虽然在没有这种 timestep 条件的情况下也可以训练模型，但在某些情况下，它似乎确实有助于性能，目前来说绝大多数的模型实现都包括了这一输入。\\n\\n### 取样（采样）\\n\\n有一个模型可以用来预测在带噪样本中的噪声（或者说能预测其去噪版本），我们怎么用它来生成图像呢？\\n\\n我们可以给入纯噪声，然后就希望模型能一步就输出一个不带噪声的好图像。但是，就我们上面所见到的来看，这通常行不通。所以，我们在模型预测的基础上使用足够多的小步，迭代着来每次去除一点点噪声。\\n\\n具体我们怎么走这些小步，取决于使用上面取样方法。我们不会去深入讨论太多的理论细节，但是一些顶层想法是这样：\\n\\n*   每一步你想走多大？也就是说，你遵循什么样的“噪声计划（噪声管理）”？ \\n*   你只使用模型当前步的预测结果来指导下一步的更新方向吗（像 DDPM，DDIM 或是其他的什么那样）？你是否要使用模型来多预测几次来估计一个更高阶的梯度来更新一步更大更准确的结果（更高阶的方法和一些离散 ODE 处理器）？或者保留历史预测值来尝试更好的指导当前步的更新（线性多步或遗传取样器）？\\n*   你是否会在取样过程中额外再加一些随机噪声，或你完全已知的（deterministic）来添加噪声？许多取样器通过参数（如 DDIM 中的 'eta'）来供用户选择。\\n    \\n\\n对于扩散模型取样器的研究演进的很快，随之开发出了越来越多可以使用更少步就找到好结果的方法。勇敢和有好奇心的人可能会在浏览 diffusers library 中不同部署方法时感到非常有意思，可以查看 [Schedulers 代码](https://github.com/huggingface/diffusers/tree/main/src/diffusers/schedulers) 或看看 [Schedulers 文档](https://huggingface.co/docs/diffusers/main/en/api/schedulers)，这里经常有一些相关的论文。\\n\\n结语\\n----\\n\\n希望这可以从一些不同的角度来审视扩散模型提供一些帮助。这篇笔记是 Jonathan Whitaker 为 Hugging Face 课程所写的，如果你对从噪声和约束分类来生成样本的例子感兴趣。问题与 bug 可以通过 GitHub issues 或 Discord 来交流。\\n\\n致谢第一单元第二部分社区贡献者\\n---------------\\n\\n感谢社区成员们对本课程的贡献:\\n\\n> @darcula1993、@XhrLeokk：魔都强人工智能孵化者，二里街调参记录保持人，一切兴趣使然的 AIGC 色图创作家的庇护者，图灵神在五角场的唯一指定路上行走。\\n>\\n> 感谢茶叶蛋蛋对本文贡献设计素材！  \\n\\n欢迎通过链接加入我们的本地化小组与大家共同交流:  \\n[https://bit.ly/3G40j6U](https://bit.ly/3G40j6U)"
    },
    {
        "article_id": "7188810848968638521",
        "cover_image": "",
        "title": "Mysql执行insert时，不插入重复数据",
        "brief": "今天遇到一个问题：通过sql语句直接实现重复数据不插入，而不用借助逻辑代码进行判断。 通过查询目前有三种方法可以实现。 一、insert ignore into 前提条件：插入的属性列中包含主键或者唯",
        "user_name": "木哈哈木",
        "view_count": 1547,
        "collect_count": 9,
        "comment_count": 5,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/615ce548eadca388ddb30f7d725fa3fb~300x300.image",
        "category": "后端",
        "content": "---\\ntheme: smartblue\\nhighlight: a11y-dark\\n---\\n今天遇到一个问题：通过sql语句直接实现重复数据不插入，而不用借助逻辑代码进行判断。\\n\\n通过查询目前有三种方法可以实现。\\n\\n一、**insert ignore into**\\n\\n前提条件：插入的属性列中包含主键或者唯一索引。\\n\\n用法：和insert into用法一致，插入时需要指定属性列，否则默认全部属性列值。当根据主键或唯一索引判定重复时，直接忽略该条数据，执行下一条。\\n\\n例子：\\n    给表设置了主键和唯一索引（id:主键， serial: 设置了唯一索引)\\n    \\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4e468ff346094ff5b11955934b45f7fe~tplv-k3u1fbpfcp-watermark.image?)\\n\\n-     主键重复\\n    \\n<p align=center><img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/371f0c920b994482877f6d45fa5bce7f~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\"  /></p>\\n因为ID为6的数据已存在，所以受影响行数为0，也就意味着不插入。\\n\\n-     唯一索引重复\\n    \\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/26ac4f4d9644479cab15e587d6f0f0fc~tplv-k3u1fbpfcp-watermark.image?)\\n\\n插入了两天serial一样的数据信息，可以看到受影响行数为1，也就是说在在插入第二条数据的时候重复直接忽视。\\n\\n二、**replace into**\\n\\n前提条件：插入的属性列中包含主键或者唯一索引。\\n\\n用法：和insert into用法一致，插入时需要指定属性列，否则默认全部属性列值。当表中存在重复数据，则先删除此行数据，然后插入新的数据，相当于 `delete + insert`\\n\\n例子：\\n\\n- 主键重复\\n    \\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ea8a05075fe497687d27ca17ebd3204~tplv-k3u1fbpfcp-watermark.image?)\\n`replace into sensor_core(id, range_type, type, serial, name, model) VALUES(10, \\\"LLP\\\",\\\"芯体12\\\",\\\"40110992\\\",\\\"陶瓷压力传感器芯体\\\",\\\"CPS1184-5bar\\\")`\\n\\nID重复，修改了type属性列的数据，执行之后再次查看数据库中的数据，发现数据已变更。\\n\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c6310f465df4d4e9dd11ee69f8669ac~tplv-k3u1fbpfcp-watermark.image?)\\n    \\n- 唯一索引重复\\n\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/04f8be1e240f4890831084ab2ec6dd04~tplv-k3u1fbpfcp-watermark.image?)\\n`replace into sensor_core(id, range_type, type, serial, name, model) VALUES(10, \\\"LLP\\\",\\\"芯体\\\",\\\"40110992\\\",\\\"陶瓷压力传感器芯体\\\",\\\"CPS1184-5bar\\\")`\\n\\nID不同，serial相同，执行sql之后，再次查看数据库中的数据，发现ID已变更。\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/02b60a3c80984619bb4625d8ead1aa3c~tplv-k3u1fbpfcp-watermark.image?)\\n\\n三、**insert into ... on duplicate key update...**\\n\\n前提条件：插入的属性列中包含主键或者唯一索引。\\n\\n用法：该数据库可以以on duplicate key为界限，分为两部分来看。当数据重复时，执行后面的update部分，当数据不存在时，执行insert.\\n\\n例子：\\n\\n- 主键重复\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d26335e0f90140bbbd60d7c8edfde958~tplv-k3u1fbpfcp-watermark.image?)\\n\\n- 唯一索引重复\\n\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4bb4c57ffd664eadb9dd6b4686d864d8~tplv-k3u1fbpfcp-watermark.image?)\\n"
    },
    {
        "article_id": "7175760401701797947",
        "cover_image": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/194c4703d4134303a177a6a6b1347c30~tplv-k3u1fbpfcp-watermark.image?",
        "title": "超详细！10分钟开发一个Vue3的后台管理系统",
        "brief": "前面我“手把手”教大家开发了基于 Vue2 的管理系统，有很多人说 vue2 早就过时了，都 22 年了竟然还有人在用 vue2？简直就是土老帽！",
        "user_name": "知否技术",
        "view_count": 5786,
        "collect_count": 210,
        "comment_count": 34,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/0a5444f57cad13d678f0ec20d64bf00f~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: fancy\\n---\\n\\n\\n***本文正在参加[「金石计划 . 瓜分6万现金大奖」](https://juejin.cn/post/7162096952883019783 \\\"https://juejin.cn/post/7162096952883019783\\\")***\\n\\n前面我“手把手”教大家开发了基于 Vue2 的管理系统：\\n\\n[# 168张图，万字长文，手把手教你开发vue后台管理系统](https://juejin.cn/post/7147456110562115597)\\n\\n有很多人说 vue2 早就过时了，都 22 年了竟然还有人在用 vue2？简直就是个土老帽！\\n\\n“你有说话的权利，但我不认同你的观点。”任何公司的技术架构不是一蹴而就的，而是随着业务的增长不断升级变化的。技术越新，用的人不一定会很多。\\n\\n其实我敢说现在国内跟多公司还在用 vue2，未来 3 年用 vue3 的公司才会越来越多。\\n\\n当然啦，我们要乐于接收新鲜事物，要不断学习不断成长。这次我还是站在前端小白的角度，手把手教大家开发基于 `Vue3` 的管理系统。\\n\\n该系统功能非常简单，包含登录、退出、增删改查基本功能，非常适合新手拿来练习。\\n\\n最后会给出 demo 的完整代码。\\n\\n## 1.项目演示\\n\\n1.登录\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af63064adac04ef5ab448bd86095476a~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n2.首页\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8fbb2f36be545918e44da9b56d3f54d~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n3.用户管理\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/54cccb6290df4645a36c9ab64211685f~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n4.删除用户\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ec12867dc61746eea6473925e911d46a~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n5.查看详情\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/440633b781ff4c27830244bc28ac05df~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n6.退出\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cfcbce04a1bf4b789183815d3cc04e35~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n## 2.技术栈\\n- vue3\\n- vite3\\n- Element Plus\\n\\n## 3.项目搭建\\n\\n本次项目我们使用 `vite` 进行构建。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bedb0085eed3449395fbeb9ab0112fbd~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n\\n和 Vue cli 的效果一样，vite 也是一个构建 vue 项目的脚手架工具。\\n\\n比起 Vue cli，vite 的热更新速度更快，打包构建速度更快。因为它默认安装的插件很少，所以需要自己额外配置。\\n\\n**前提：安装 node 环境**\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d638507719574fa7a21cf44f5479d6dd~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n\\n>使用 vite 创建 vue3 脚手架项目：\\n\\n1.创建项目\\n\\n```css\\n# npm 6.x\\nnpm init vite@latest vue3-zhifou --template vue\\n\\n# npm 7+\\nnpm init vite@latest vue3-zhifou -- --template vue\\n```\\n2.安装依赖\\n\\n```css\\nnpm install\\n```\\n3.启动\\n\\n```css\\nnpm run dev\\n```\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/781bfdeccb78479b978fe6e8460b7da9~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n4.初始化项目\\n\\n修改 App.vue，删除默认的 HelloWorld 组件\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a26f7997a03f42bb97921b83a6db647b~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n## 4.安装配置 Element Plus\\n\\n```css\\n官网：http://element-plus.org/zh-CN/\\n```\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ddb3105fbc0a449d9cba7a626332341e~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n```css\\nnpm install element-plus --save\\n```\\n在 main.js 配置 Element plus\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cad21013750e4662bf2fcf30c67acf96~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n## 5.配置路由\\n\\n```css\\nnpm install vue-router --save \\n```\\n在 src 文件夹下新建 router 文件夹，然后新建 index.js\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/375a7eef2a6e4cdcb3c6d9dc0f8044e5~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n在 main.js 中配置路由\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/15d629468c774cf0a3af86c1e1354dc5~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n## 6.安装配置 Axios\\n\\n```css\\nnpm i axios -- save\\n```\\n在 src 文件夹下新建 utils 文件夹，在 utils 文件夹下新建 http 文件夹，然后 新建 axios.js 和 http.js。\\n\\n1. `axios.js`：主要用来创建 axios 实例、拦截请求和响应。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43be5081cdd84ecc911b939cd6c70ed3~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/85296f07c61849f2af11786d324c64af~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n2.`http.js`：主要用来封装各种请求：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89bb2a0104d14ad8a9bdd1b3bc167d00~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n3.配置跨域\\n\\n在 vite.config.js 配置跨域：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ae5c7188c174aa9b383e9119144a9ee~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n`target` 是后台接口地址。\\n\\n`/api `就是 axios 实例的 `baseURL` 属性。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2565808e23434b49b66eb844f5d01266~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n## 7.登录\\n\\n1.在 /router/index.js 中配置登录的路由：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ddd61d53a8b146fa87fd1ee08a5e3160~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n然后在 view 文件夹下新建 Login.vue\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d0c389d5ff084a2c91da89f7f87bb581~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n2.搭建登录页面\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1507a38fe97b42b083f28d6152e71e13~tplv-k3u1fbpfcp-watermark.image?)\\n登录页面主要使用了 Element plus 的 Container 布局容器、卡片、表单以及 Icon 图标。\\n\\n3.配置 Icon 图标\\n\\n在登录页面的头部，我们主要使用了 Icon 图标。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7fb2b481c3eb466cbb03d52cd1ecc8dc~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n在 Element plus 中，Icon 需要单独配置：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aabcc182390a4019b1abc518fcf9264b~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n4.配置登录表单\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4cae2c003c604528b3e0b86eecf33930~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n绑定表单属性\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f905ad5b67f94e03b2286f07c865942c~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n在 `vue3.2` 之后，我们不需要在 setup() 方法里面写一堆返回值了，只需要在 script 标签上面加一个 setup 属性，变量和方法默认会导出。\\n\\n5.新建接口方法\\n\\n在 src 文件夹下新建 api 文件夹，然后新建 user.js。\\n\\nuser.js 里面就是对应的后台接口。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e71ad2d292b64f8c9f742f631c254933~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n在 Login.vue 中导入\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/780215dfb0ff405cb568877fd2b8fdd5~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n6.登录校验\\n\\n新建校验规则\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b1c30c94e4545858e59f7ede752f06d~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n绑定 el-form 的 ref 属性，**切记名字要一样。**\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c621517a8a44ab3b1a5f19f794c2822~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n登录校验：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/32f85cf902df4d2e8da5f09336ad87a7~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n因为 ref() 返回的是一个对象，所以需要用 ruleFormRef.value 获取值。\\n\\n7.登录跳转\\n\\n在 vue3 中没有 `this` 变量了，所以页面跳转需要导入 route\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4dbdc18ad5e64d75b6a5f34d89592795~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n8.消息提示\\n\\n在 Element plus 消息提示换成了 ElMessage，需要我们在页面单独导入：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fba47f129a6b44da838a256e3dd4825b~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n9.重置表单\\n\\n```css\\nconst resetForm = () => {\\n  if (!ruleFormRef) return;\\n  ruleFormRef.value.resetFields();\\n};\\n```\\n## 8.后台主页\\n\\n后台主页主要使用了 Element plus 的 Container 布局容器、导航、下拉菜单。\\n\\n1.修改路由\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5021a9c9d994f4196b7f717cc6210c2~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n2.在 view 文件夹下面新建 Home.vue\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f41a5558b8b40ffa94f03036283fbd5~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n3.配置菜单\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/830c67c38a6d41d1aea9f3785637af76~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n4.配置 router-view\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/73d4fc65ee7d432989901f845f44335c~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n5.激活菜单功能\\n\\n主要是使用 sessionStorage 存储当前跳转的路径：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/65a3d8c4348843f3bb8099e687cb6a3f~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n6.首页\\n\\n跳转到后台主页的时候，默认跳转到首页\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5da9b02b61cc4fbface373c61b445c3e~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d5d1b90668c4fcfaac6c1bc85d798c1~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n## 9.用户列表\\n\\n1.修改路由\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94e0d659d4ac4460ab26d472e4f46731~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n2.在 view 文件夹下面新建 user 文件夹，这个文件夹主要用来存放用户的页面：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2a5f11df6124dde85ef866ddabe891b~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n3.开发用户列表页面\\n\\n用户列表页面主要使用了 Element plus 的输入框、表格、分页组件\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c6257e5533e14e3d924af463656b2901~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n4.绑定搜索条件、表格数据、分页数据\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b82a5601f57b43b7a3f98c1b9e66b379~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n5.导入用户接口，绑定用户列表相关方法\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8ea0c21bde94b35a3ce104c66f47fe4~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n因为刚进入用户页面需要展示用户列表数据，根据 vue3 的生命周期，这里在页面加载之后调用获取用户列表的方法：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/04752d729fc14a88904b5fc0335698a0~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n6.Element plus 设置中文\\n\\n引入分页组件，发现全是英文属性名\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45aac6c399c946d9beb0a089b0edd84e~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n这里需要在 main.js 将 Element plus 配置成中文的：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0feed4b99fca46cea64745fe5c62d511~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n## 10.删除\\n\\n删除用户主要使用了 Element plus 的 ElMessageBox 组件：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/edfaef42222e4d26969b5f5fd938cd3a~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9cf7e7279c0244808842255ebc9b517e~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n## 11.用户详情\\n\\n1.修改路由配置\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/343d89f47c7c4bf4b8f018d511d639fa~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n2.跳转用户详情页面\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5abe3c51b19a44fcb8fea7e8bf6a46b4~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n3.新建用户详情页面\\n\\n用户详情页面主要就是获取传递的 id，然后调用用户详情接口获取数据\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8d10badc86ed47cf84c6437987aa9944~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n## 12.退出系统\\n\\n退出系统就是清除缓存，跳转到登录页面\\n\\n```css\\nconst logout = () => {\\n    // 清除缓存\\n    sessionStorage.clear();\\n    router.push(\\\"/login\\\");\\n}\\n```\\n## 13.全局函数\\n\\n- vue3 中没有 Prototype 属性，使用 app.config.globalProperties 去替代\\n- proxy 可以理解为 vue 的代理对象\\n-  getCurrentInstance 方法获取当前组件实例\\n\\n1.新建全局函数\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/285f5ee857424549a0f0dea21a445360~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n2.配置全局函数\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09cb7a3290e842d0903c4075a227e6bc~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n3.导入 proxy\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3fc678dd0a3641b78f2d3f10ec7b73bf~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n4.调用全局函数\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f913bb814efb49eb9260d5dacfb558f8~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n## 14.全局样式\\n\\n在项目的 style.css 文件中写全局样式\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/165c9eb4439a4930a55ac34fff8ea657~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n## 15.总结\\n\\nVue2 的开发方式比较固定，在 data 函数里面写属性，在 methods 函数里面写方法。\\n\\nVue3 却大相径庭，所有的属性和方法都要写在 setup 函数里面。所以相关代码逻辑比较统一、完整。\\n\\n完整代码：\\n\\n```css\\n链接：https://pan.baidu.com/s/16E1QWL21wNf0DM8xEtP2Nw?pwd=1234 \\n提取码：1234 \\n```\\n\\n拿到代码之后，先安装依赖\\n\\n```css\\nnpm install\\n```\\n然后运行项目\\n```css\\nnpm run dev\\n```\\n"
    },
    {
        "article_id": "7189262867453968441",
        "cover_image": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dfd38040aa1a44bcb1d24f7ff9887afd~tplv-k3u1fbpfcp-watermark.image?",
        "title": "UE4 RPG游戏实战开发（一）",
        "brief": "经过短暂对UE的学习，用蓝图完成了一个简单的RPG游戏Demo,接下来就对这期间的学习过程做一个复盘，一是让自己再加深一下印象，二是也给有需要的人一个参考。 角色篇 从哪里获取资源 1.虚幻商城 2.",
        "user_name": "HelloWorld杰少",
        "view_count": 320,
        "collect_count": 3,
        "comment_count": 1,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/a2a6fc558f01bff9d77f9039b18debc1~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: channing-cyan\\n---\\n经过短暂对UE的学习，用蓝图完成了一个简单的RPG游戏Demo,接下来就对这期间的学习过程做一个复盘，一是让自己再加深一下印象，二是也给有需要的人一个参考。\\n\\n## 角色篇\\n\\n### 从哪里获取资源\\n\\n1.虚幻商城\\n\\n2.Mixamo：https://www.mixamo.com/#/\\n\\n3.Sketchfab:https://sketchfab.com/\\n\\n在 Mixamo 中选择喜欢的角色，然后再将其所需要的动画一并下载下来，例如静止，走路，慢跑，快跑，后退，跳跃等动作。下载动画的时候记住勾选 In Place 不然动画会出现瞬移的 bug, 选项 skin 为 without skin。\\n\\n![image](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/21e4dc0d9c7c4f6da2850b76149c7ac2~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n\\n## 动画篇\\n\\n1.新建一个文件夹 Components, 右键导入 skeleton\\n\\n2.新建一个文件夹 Animations, 右键导入动画，选择对应的骨骼\\n\\n3.创建一个融合动画（Blend Space\\n1D），用于角色的各种移动，取名例如 PlayerMove_BS\\n\\n![image](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da40d887b6a64bf2a452d3c3976e9e62~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n4.打开添加角色移动的动画（stand, walk, running）保存\\n\\n5.创建动画蓝图\\n![image](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/beca4764ecea4f6692abc73e251e9762~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n6.打开动画蓝图，添加一个 new status machine(状态机) -> Default slot ,并连接上 Output Pose, 打开新的状态机，添加一个新状态 Base, 打开 Base, 连接我们之前创建的融合动画\\n\\n![image](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e07d6784937455ead2d84ed840068c2~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n![image](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/944e259a2a0e4d559ca967e45ce182b3~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n![image](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd42a40355ab425c9acecf01ced200e3~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n7.给动画添加一个 Speed, 打开动画蓝图的 Event Graph, 给 Speed 赋值\\n\\n![image](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d3ca0cce0aa247e8be1af0fab8c161a8~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n8.在将 Speed 传值给状态机\\n\\n![image](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/764a239c6b364fd5a21a1e6f06f62f75~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n9.回到角色蓝图的视口，选择对应的骨骼和骨骼动画，切回场景中，我们自定义的任务就跑起来了\\n\\n![image](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9997c05657fc46a3ad5d545f891125a9~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n10.如果要在场景中指定角色，可以执行如下操作：将角色拖入场景中->选择角色->Details->在搜索栏中输入poss->Auto Possess Player 选为Player 0\\n\\n **我是杰少，如果您觉的我写的不错，那请给我 **点赞+评论+收藏** 后再走哦！**\\n\\n**往期文章：**\\n- [UE4 如何用命令行来打包你的游戏](https://juejin.cn/post/7163561864071217183)\\n- [UE4：来为我们的角色制作一个血条吧](https://juejin.cn/post/7156867596850036767)\\n- [使用 Google Breakpad 来助力解决程序崩溃](https://juejin.cn/editor/drafts/7130819289803653128)\\n- [UE4 多人游戏服务器探索](https://juejin.cn/editor/drafts/7118977305858277412)\\n- [使用虚幻引擎自动化工具实现自动化部署](https://juejin.cn/editor/drafts/7095681383351681038)\\n- [如何在 UE4 中制作一扇自动开启的大门](https://juejin.cn/editor/drafts/7083289727268290574)\\n- [如何在 UE4 中用代码去控制角色移动](https://juejin.cn/editor/drafts/7081045461729017869)\\n- [如何给 UE4 场景添加游戏角色](https://juejin.cn/editor/drafts/7080302876341305381)\\n- [UE4：Android 平台开发实践指南](https://juejin.cn/post/7068510988378570783)\\n- [UE4 开发避坑指南（持续更新）](https://juejin.cn/editor/drafts/7065135005466361887)\\n\\n\\n**请你喝杯 ☕️ 点赞 + 关注哦～**\\n\\n1.  阅读完记得给我点个赞哦，有👍 有动力\\n1.  关注公众号--- [HelloWorld杰少](https://link.juejin.cn?target=https%3A%2F%2Fp1-jj.byteimg.com%2Ftos-cn-i-t2oaga2asx%2Fgold-user-assets%2F2020%2F7%2F4%2F17318f81cd4e34e9~tplv-t2oaga2asx-image.image \\\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/4/17318f81cd4e34e9~tplv-t2oaga2asx-image.image\\\")，第一时间推送新姿势\\n\\n> 最后，创作不易，如果对大家有所帮助，希望大家点赞支持，有什么问题也可以在评论区里讨论😄～**"
    },
    {
        "article_id": "7189845718470213693",
        "cover_image": "",
        "title": "NodeJs 内存泄漏排查经验总结",
        "brief": "「回顾2022，展望2023，我正在参与2022年终总结征文大赛活动」 在 Nodejs 服务端开发的场景中，内存泄漏 绝对是最令人头疼的问题； 掌握有效的 内存泄漏排查时Node工程师的最核心的能力",
        "user_name": "弈方",
        "view_count": 790,
        "collect_count": 2,
        "comment_count": 0,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/b385edd21929ca6900450826bba541ee~300x300.image",
        "category": "阅读",
        "content": "「回顾2022，展望2023，我正在参与[2022年终总结征文大赛活动](https://juejin.cn/post/7172462429929111559)」\\n\\n## 前言\\n在 `Nodejs` 服务端开发的场景中，`内存泄漏` 绝对是最令人头疼的问题；\\n但是只要项目一直在开发迭代，那么出现 `内存泄漏` 的问题绝对不可避免，只是出现的时间早晚而已。所以系统性掌握有效的 `内存泄漏` 排查方法是一名`Nodejs` 工程师最基础、最核心的能力。\\n\\n内存泄漏处理的难点就是如何能在无数的功能、函数中找到具体是哪一个功能中的哪一个函数的第多少行到多少行引起了内存泄漏。\\n很遗憾目前市面上没有能够轻松定位内存泄漏的工具，所以很多初次遇到这种问题的工程师会感到茫然，一下子不知道该如何处理。\\n这里我以22年的一次排查 `内存泄漏` 的案例分享一下我的处理思路。\\n\\n## 问题描述  \\n`2022 Q4` 某天，研发用户群中反馈我们的研发平台不能访问，后台中出现了大量的异常任务未完成。\\n第一反应就是可能出现了内存泄漏还好服务接入了监控（`prometheus` + `grafana`）,在`grafana` 监控面板中发现在 10.00 后内存一直在涨没有下来过出现了明显的数据泄漏。\\n\\n![DX 内存泄漏监控图.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9485438393ba4b289bb16798f20c7af1~tplv-k3u1fbpfcp-watermark.image?)\\n\\n> **说明**：\\n> + `process memory`: `rss` (Resident Set Size)，进程的常驻内存大小。\\n> + `heapTotal`: V8 堆的总大小。\\n> + `heapUsed`: V8 堆已使用的大小。\\n> + `external`: V8 堆外的内存使用量。  \\n> \\n> 在 `Nodejs` 中可以调用全局方法 `process.memoryUsage()` 获取这些数据其中 `heapTotal` 和 `heapUsed` 是 V8 堆的使用情况，V8 堆是 `Node.js` 中 JavaScript 对象存储的地方。而 `external` 则表示非 V8 堆中分配的内存，例如 C++ 对象。`rss` 则是进程所有内存的使用量。一般看监控数据的时候重点关注 `heapUsed` 的指标就行了\\n\\n\\n## 内存泄漏类型\\n内存泄漏主要分为：\\n+ 全局性泄漏\\n+ 局部性泄漏\\n> 其实不管是全局性内存泄漏还是局部性的内存泄漏，要做的都是尽可能缩小排除范围。\\n\\n## 全局性内存泄漏\\n全局性内容泄漏出现一般高发于：`中间件`与`组件`中，这种类型的内存泄漏排查起来也是最简单的。\\n\\n很遗憾我在 `2022 Q4` 中遇到的内存泄漏不属于这个类型，所以还得按照局部性泄漏的思路进行分析。\\n\\n### 二分法排查\\n这种类型我就不讲其它科学的分析方法了，这种情况下我认为使用二分法排查是最快的。  \\n\\n\\n**流程流程**：\\n1. 先注释一半的代码（减少一半`中间件`、`组件`、或其它公用逻辑的使用）\\n2. 随便选择一个接口或新写一个测试接口进行压测\\n3. 如果出现内存泄漏，那么泄漏点就在当前使用的代码之中，若没有泄漏则泄漏点出现在\\n4. 然后一直循环往复上述流程大约 20 ~ 60 min 一定可以定位到内存泄漏的详细位置\\n\\n> 2020 年的时候我在做基于 `Nuxt` SSR 应用时，上线前压测发现应用内存泄漏，判断定为全局性的泄漏之后，采用二分法排查大约花了 30min 就成功定位了问题。  \\n> 当时泄漏的原因是我们在服务端使用 `axios` 导致的泄漏，后来统一 `axios` 相关的全换成 `node-fetch` 后就解决了,从此换上了 `axios PDST` 后来绝对不会在 `Node` 服务中使用 `axios` 了 \\n\\n## 局部性内存泄漏排查\\n大多数内存泄漏的情况都是局部性的泄漏，泄漏点可能存在与某个`中间件`、某个`接口`、某个`异步任务`中，由于这样的特性它的排查难度也较大。这种情况都会做 `heapdump` 进行分析。\\n\\n这里主要讲我这个案例中的思路关于`heapdump`的详细说明我放在下个段落，\\n\\n> `Heap Dump` :堆转储, 后面部分都使用 `heapdump` 表示，做 `heapdump` 的工具和教程也非常多比如：chrome、vscode、heapdump 这个开源库。我用的 heapdump 库做的网上教程非常多这里不展开了。\\n\\n> 局部性内存泄漏排查需要一定的内存泄漏排查经验，每次遇到都把它当成对自己的一次磨砺，这样的经验积累多了以后排查内存泄漏问题会越来越快。\\n\\n### 1. 确定内存泄漏出现的时间范围\\n这一点非常重要，明确了这一点可以大幅度缩小排查范围。  \\n经常会出现这种情况，这个迭代做了A、B、C 三个功能，压测时或上线后出现了内存泄漏。那么就可以直接锁定，内存泄漏发生小这三个新的功能之中。这种情况下就不需要非常麻烦的去生产做 `heapdump` 我们在本地通过一些工具就可以很轻松的分析定位出内存泄漏点。\\n\\n由于我们 `20年Q4` 的一些特殊情况，当我们发现存在内存泄漏的时候已经很难确定内存泄漏初次出现在什么时间点了，只能大概锁定在 1 月的时间内。这一个月中我们又经历了一个大版本迭代，如果一一排查这些功能与接口成本必然非常高。\\n所以还需要结合更多的数据进行进一步分析\\n\\n### 2. 采集 heapdump 数据\\n+ 生产启动时 `node` 添加 `--expose-gc`,这个参数会向全局注入 `gc()` 方法，方便手动触发 GC 获取更准确的`堆快照`数据\\n+ 这里我加入了两个接口并带上了自己的专属权限，\\n  - 手动触发 GC\\n  - 打印堆快照\\n+ `heapdump`\\n  - 项目启动后第一次打印快照数据\\n  - 内存上涨 100M 后：先触发 GC，再第二次打印堆快照数据\\n  - 内存接近临界时再次触发 GC 然后打印堆快照\\n\\n**采集堆快照数据时需要特别注意的一些点！**\\n> + 在 `heapdump`时 Node 服务会中断，根据当时服务器内存大小这个时间会在 2 ～ 30min 左右。在生产环境做 `heapdump` 需要和运维一起制定合理的策略。我在这里是使用了主、备两个 `pod`, 当主 `pod` 停掉之后，业务请求会通过负载均衡到备用 `pod` 由此保障生产业务的正常进行。（这个过程必定是一个与运维密切配合的过程，毕竟 `heapdump` 玩抽还需要通过他们拿到服务器中`堆快照`文件）\\n> + 上述接近临界点打印快照只是一个模糊的描述，如果你试过就知道等非常接近临界点再打印内存快照就打印不出来了。所以接近这个度需要自己把握。\\n> + 做至少 3 次 `heapdump`（实际上为了拿到最详细的数据我是做了 5 次）\\n\\n\\n### 3. 结合监控面板的数据进行分析\\n需要你的应用服务接入监控，我这里应用是使用`prometheus` + `grafana` 做的监控, 主要监控服务的以下指标\\n\\n+ `QPS` (每秒请求访问量) ，请求状态，及其访问路径\\n+ `ART` (平均接口响应时间) 及其访问数据\\n+ `NodeJs` 版本\\n+ `Actice Handlers`(句柄)\\n+ `Event Loop Lag` (事件滞后)\\n+ 服务进程重启次数\\n+ CPU 使用率\\n+ 内存使用：`rss`、`heapTotal`、`heapUsed`、`external`、`heapAvailableDetail`\\n\\n\\n> 只有 `heapdump` 数据是不够的，`heapdump` 数据非常晦涩，就算在可视化工具的加持下也难以准确定位问题。这个时候我是结合了 `grafana` 的一些数据一起看。\\n\\n### 我的分析处理结果\\n由于当时的对快照数据丢失了，我这里模拟一下当时的场景。  \\n1. 通过 `grafana` 监控面看看到内存一直在涨一直下不来，但同时我也注意到，服务中的`句柄`数也在疯涨一直不掉。   \\n ![DX 内存泄漏监控图2.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f834c68924640309c80ff7f62e86576~tplv-k3u1fbpfcp-watermark.image?)\\n\\n2. 这是我回顾了一下出现泄漏的那一个月中新增的功能怀疑可能是在使用 `bull` 消息队列组件造成的内存泄漏。先去分析了相关应用代码，但并看不出那里写的有问题导致了内存泄漏,\\n结合 1 中句柄泄漏的问题感觉是在使用 `bull` 后需要手动的去释放某些资源，在这个时候还不太确定具体原因。\\n\\n3. 然后对 5 次的 `heapdunmp` 数据进行了分析，数据导入 `chrome` 对 5 次堆快照进行对比后，发现每次创建队列后 TCP、Socket、EventEmitter 的事件都没有被释放到。到这里基本可以确定是由于对 `bull` 的使用不规范导致的。在 `bull` 通常不会频繁创建队列，队列占用的系统资源并不会被自动释放，若有需要，需手动释放。  \\n![heapdum分析.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab1da9b8dfb04a7083ec1b3d9c5effb5~tplv-k3u1fbpfcp-watermark.image?)\\n\\n4. 在调整完代码后重新进行了压测，问题解决。\\n\\n> Tips: Nodejs 中的`句柄`是一种指针，指向底层系统资源（如文件、网络连接等）。句柄允许 Node.js 程序访问和操作这些资源，而无需直接与底层系统交互。句柄可以是整数或对象，具体取决于 Node.js 库或模块使用的句柄类型。常见`句柄`:\\n> + `fs.open()` 返回的文件句柄\\n> + `net.createServer()` 返回的网络服务器句柄\\n> + `dgram.createSocket()` 返回的 UDP socket 句柄\\n> + `child_process.spawn()` 返回的子进程句柄\\n> + `crypto.createHash()` 返回的哈希句柄\\n> + `zlib.createGzip()` 返回的压缩句柄 \\n\\n\\n## heapdump 分析总结\\n通常很多人第一次拿到`堆快照`数据是懵的，我也是。在看了网上无数的分析技巧结合自身实战后总结了一些比较好用的技巧，一些基础的使用教程这里就不讲了。这里主要讲数据导入 `chrome` 后如何看图；\\n\\n### Summary 视图 \\n![Summary视图.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a8e4c033f16c40a1ac8e3930252e1822~tplv-k3u1fbpfcp-watermark.image?)\\n看这个视图的时候一般会先对 Retained Size 进行排查，然后观察其中对象的大小与数量，有经验的工程师，可以快速判断出某些对象数量异常。在这个视图中除了关心自己定义的一些对象之外，\\n一些容易发生内存泄漏的对象也需要注意如：\\n+ `TCP`\\n+ `Socket`\\n+ `EventEmitter`\\n+ `global`\\n\\n### Comparison 视图\\n如果通过 `Summary` 视图, 不能定位到问题这时我们一般会使用 `Comparison` 视图。通过这个视图我们能对比两个堆快照中对象个数、与对象占有内存的变化；\\n通过这些信息我们可以判断在一段时间（某些操作）之后，堆中的对象与内存变化的数值，通过这些数值我们可以找出一些异常的对象。通过这些对象的名称属性或作用可以缩小我们内存泄漏的排查范围。  \\n\\n在 `Comparison` 视图中选择两个堆快照，并在它们之间进行比较。您可以查看哪些对象在两个堆快照之间新增，哪些对象在两个堆快照之间减少，以及哪些对象的大小发生了变化。\\n`Comparison` 视图还允许查看对象之间的关系，以及对象的详细信息，如类型、大小和引用计数。通过这些信息，可以了解哪些对象是导致内存泄漏的原因。\\n\\n\\n![Comparison视图.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df129e30ec054c87b896f6dffdd384d6~tplv-k3u1fbpfcp-watermark.image?)\\n\\n### Containment 视图\\n显示了对象之间的所有可达的引用关系。每个对象都被表示为一个圆点，并由一条线条连接到它的父对象。通过这种方式可以查看对象之间的层次关系，并了解哪些对象是导致内存泄漏的原因。\\n\\n![Containment视图2.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/125430b59b00405aa15a362f27a4e7c5~tplv-k3u1fbpfcp-watermark.image?)\\n### Statistics 视图\\n这个图很简单不展开讲了\\n![Statistics视图.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3184e98956814b30be82390313a48f72~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## 内存泄漏场景\\n+ 全局变量：全局变量不会被回收\\n+ 缓存：使用了内存密集型的第三方库如 `lru-cache` 存的太多就会导致内存不够用，在 Nodejs 服务中建议使用 `redis` 替代 `lru-cache`\\n+ 句柄泄漏：调用完系统资源没有释放\\n+ 事件监听\\n+ 闭包\\n+ 循环引用\\n\\n\\n## 总结\\n1. 服务需要接入监控，方便第一时间确定问题类型\\n2. 判断内存泄漏是全局性的还是局部性的\\n3. 全局性内存泄漏使用二分法快速排查定位\\n4. 局部内存泄漏  \\n    - 确定内存泄漏出现时间点，快速定位问题功能\\n    - 采堆快照数据，至少 3 次\\n    - 结合监控数据、堆快照数据、与出现泄漏事时间点内的新功能对内存泄漏点进行定位\\n\\n> 遇到内存泄漏的问题不要畏惧，多积累内存泄漏问题的排查经验处理经验多了找起来就非常快了。每次解决之后做复盘总结回头再多看看 `堆快照` 数据利于更快的积累相关经验\\n\\n## 其它\\n+ 压测工具：wrk\\n\\n"
    },
    {
        "article_id": "7189555817534718011",
        "cover_image": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b9eff3a8c294865bb9c4af20a95a106~tplv-k3u1fbpfcp-watermark.image?",
        "title": "【论文复现】针对yoloV5-L部分的YoloBody部分重构（Slim-neck by GSConv）",
        "brief": "本文将着重于实操讲解，对于yolov5-l的网络主题部分进行重构，因此将省略掉原理部分的讲解。若读者对原理部分感兴趣的话可以参考论文【1】中的方法进行构建网络主体部分。",
        "user_name": "小小杨树",
        "view_count": 654,
        "collect_count": 0,
        "comment_count": 3,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/ded9131d7ce92e62ddbbe8c85eba197b~300x300.image",
        "category": "人工智能",
        "content": "---\\ntheme: nico\\nhighlight: atelier-forest-dark\\n---\\n## 前言\\n&emsp;&emsp;本文将着重于实操讲解，对于yolov5-l的网络主题部分进行重构，因此将省略掉原理部分的讲解。若读者对原理部分感兴趣的话可以参考论文【1】中的方法进行构建网络主体部分。本文中的网络主体架构是从**bubbliiiing**的 yoloV5 中剥离出来的结构。\\n\\n&emsp;&emsp;结合了论文中的流程参数图以及**bubbliiiing**的 yoloV5 的YoloBody部分进行重构，大家可以自行更换掉YoloBody部分代码进行实验。代码在结尾部分。\\n\\n## 函数拆解\\n&emsp;&emsp;下图中的左侧表格中为论文中提出的方法，右侧为官方原版的yoloV5中的YoloBody部分，分析左右两表中的差异，我们可以根据论文中的[连接](https://github.com/alanli1997/slim-neck-by-gsconv)，将GSConv和VoV-GSCSP提取出来进行实验分析使用方法以及作用（SPPF&Concat&Upsample函数作用相同）：\\\\\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f5a721bdea44d2dbb0661e52c4bc60c~tplv-k3u1fbpfcp-watermark.image?)\\n\\n### GSConv函数\\n```\\nimport torch\\nimport torch.nn as nn\\nimport torch.nn.functional as F\\n\\n\\ndef autopad(k, p=None):  # kernel, padding\\n    # Pad to 'same'\\n    if p is None:\\n        p = k // 2 if isinstance(k, int) else [x // 2 for x in k]  # auto-pad\\n    return p\\n\\nclass Mish(nn.Module):\\n    def __init__(self):\\n        super().__init__()\\n\\n    def forward(self,x):\\n        x = x * (torch.tanh(F.softplus(x)))\\n        return x\\n\\nclass Conv(nn.Module):\\n    # Standard convolution\\n    def __init__(self, c1, c2, k=1, s=1, p=None, g=1, act=True):  # ch_in, ch_out, kernel, stride, padding, groups\\n        super().__init__()\\n        self.conv = nn.Conv2d(c1, c2, k, s, autopad(k, p), groups=g, bias=False)\\n        self.bn = nn.BatchNorm2d(c2)\\n        self.act = Mish() if act else nn.Identity()\\n\\n\\n    def forward(self, x):\\n        return self.act(self.bn(self.conv(x)))\\n\\n    def forward_fuse(self, x):\\n        return self.act(self.conv(x))\\n\\nclass GSConv(nn.Module):\\n    # GSConv https://github.com/AlanLi1997/slim-neck-by-gsconv\\n    def __init__(self, c1, c2, k=1, s=1, g=1, act=True):\\n        super().__init__()\\n        c_ = c2 // 2\\n        self.cv1 = Conv(c1, c_, k, s, None, g, act)\\n        self.cv2 = Conv(c_, c_, 5, 1, None, c_, act)\\n\\n    def forward(self, x):\\n        x1 = self.cv1(x)\\n        x2 = torch.cat((x1, self.cv2(x1)), 1)\\n        # shuffle\\n        # y = x2.reshape(x2.shape[0], 2, x2.shape[1] // 2, x2.shape[2], x2.shape[3])\\n        # y = y.permute(0, 2, 1, 3, 4)\\n        # return y.reshape(y.shape[0], -1, y.shape[3], y.shape[4])\\n\\n        b, n, h, w = x2.data.size()\\n        b_n = b * n // 2\\n        y = x2.reshape(b_n, 2, h * w)\\n        y = y.permute(1, 0, 2)\\n        y = y.reshape(2, -1, n // 2, h, w)\\n\\n        return torch.cat((y[0], y[1]), 1)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    base_channels = 64\\n    P3Shape = (1, 256, 80, 80)\\n    P3 = torch.ones(P3Shape)\\n\\n    gsc = GSConv(base_channels * 4, base_channels * 4, 3, 2)\\n    P = gsc(P3)\\n    print(P.shape)\\n```\\n&emsp;&emsp;通过上述的代码我们可以得到在GSConv的输入参数这边输入的维度为256,当k=3,s=2时，H和S将会降一半;当H和S为默认的1时则不变。\\n### VoV-GSCSP函数\\n&emsp;&emsp;VoV-GSCSP函数是建立在GSConv函数上演变而来的，我们结合论文中的流程参数表可知，在VoV-GSCSP函数中我们仅需要确保输出与输出即可。\\n```\\nclass GSBottleneck(nn.Module):\\n    # GS Bottleneck https://github.com/AlanLi1997/slim-neck-by-gsconv\\n    def __init__(self, c1, c2, k=3, s=1, e=0.5):\\n        super().__init__()\\n        c_ = int(c2*e)\\n        # for lighting\\n        self.conv_lighting = nn.Sequential(\\n            GSConv(c1, c_, 1, 1),\\n            GSConv(c_, c2, 3, 1, act=False))\\n        self.shortcut = Conv(c1, c2, 1, 1, act=False)\\n\\n    def forward(self, x):\\n        return self.conv_lighting(x) + self.shortcut(x)\\n\\nclass VoVGSCSP(nn.Module):\\n    # VoVGSCSP module with GSBottleneck\\n    def __init__(self, c1, c2, n=1, shortcut=True, g=1, e=0.5):\\n        super().__init__()\\n        c_ = int(c2 * e)  # hidden channels\\n        self.cv1 = Conv(c1, c_, 1, 1)\\n        self.cv2 = Conv(c1, c_, 1, 1)\\n        # self.gc1 = GSConv(c_, c_, 1, 1)\\n        # self.gc2 = GSConv(c_, c_, 1, 1)\\n        # self.gsb = GSBottleneck(c_, c_, 1, 1)\\n        self.gsb = nn.Sequential(*(GSBottleneck(c_, c_, e=1.0) for _ in range(n)))\\n        self.res = Conv(c_, c_, 3, 1, act=False)\\n        self.cv3 = Conv(2 * c_, c2, 1)  #\\n\\n    def forward(self, x):\\n        x1 = self.gsb(self.cv1(x))\\n        y = self.cv2(x)\\n        return self.cv3(torch.cat((y, x1), dim=1))\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    base_channels = 64\\n    P3Shape = (1, 256, 80, 80)\\n    P3 = torch.ones(P3Shape)\\n\\n    VOV = VoVGSCSP(base_channels * 4, base_channels * 4)\\n    P = VOV(P3)\\n```\\n\\n## YoloBady构造\\n&emsp;&emsp;由上述的网络基础函数部分的构建结合yoloV5经过 **backbone** 层后得到的feat1、feat1和 feat1（也即：P5、P4和P3）到最后网络的输出部分，可以得到从输入部分的H和W是保持同P层相同，那么可以结合论文中的流程参数图以及输入输出的关系得到如下的流程参数图。\\\\\\n![head.jpg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad0476fc1c714a36a3d28a30ed53ac71~tplv-k3u1fbpfcp-watermark.image?)\\n\\n&emsp;&emsp;根据上文中流程表格参数图，我在重构的过程中省略了S=3的设定（本人的显存不够），另外根据论文中的流程示意图，我暂时无法没有找到下图中的红圈部分的参数，若大家需要可以自行添加，输入输出保持不变即可。\\\\\\n![v5.jpg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6bb4126d9dad4ee68c0fae5edf50b899~tplv-k3u1fbpfcp-watermark.image?)\\n![参数图.jpg](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/07908b856165422a936c10066f4727fa~tplv-k3u1fbpfcp-watermark.image?)\\n\\n### YoloBody部分\\n```\\nfrom torch import nn\\nfrom nets.CSPdarknet import CSPDarknet, SPPF, Concat, GSConv, VoVGSCSP\\n\\n\\nclass YoloBody(nn.Module):\\n    def __init__(self, anchors_mask, num_classes, phi, pretrained=False, input_shape=[640, 640]):\\n        super(YoloBody, self).__init__()\\n        depth_dict = {'n': 0.33, 's': 0.33, 'm': 0.67, 'l': 1.00, 'x': 1.33, }\\n        width_dict = {'n': 0.25, 's': 0.50, 'm': 0.75, 'l': 1.00, 'x': 1.25, }\\n        dep_mul, wid_mul = depth_dict[phi], width_dict[phi]\\n\\n        base_channels = int(wid_mul * 64)  # 64\\n        base_depth = max(round(dep_mul * 3), 1)  # 3\\n        # -----------------------------------------------#\\n        #   输入图片是640, 640, 3\\n        #   初始的基本通道是64\\n        # -----------------------------------------------#\\n        self.backbone = CSPDarknet(base_channels, base_depth, phi, pretrained)\\n\\n        self.upsample = nn.Upsample(scale_factor=2, mode=\\\"nearest\\\")\\n        self.concat = Concat(dimension=1)\\n        self.SPPF = SPPF(base_channels * 16, base_channels * 16)  # 1024 ---> 1024\\n        self.P5GSConv = GSConv(base_channels * 16, base_channels * 8)  # 1,1024,20,20 ---> 1,512,20,20\\n        self.P4VoV = VoVGSCSP(base_channels * 16, base_channels * 8)  # 1,512,40,40 ---> 1,1024,40,40\\n        \\\"\\\"\\\"\\n        self.P4VoV = nn.Sequential(VoVGSCSP(base_channels * 16, base_channels * 8),\\n                           VoVGSCSP(base_channels * 8, base_channels * 8),\\n                           VoVGSCSP(base_channels * 8, base_channels * 8))\\n        \\\"\\\"\\\"\\n\\n        self.P4GSConv = GSConv(base_channels * 8, base_channels * 4)  # 1,512,40,40 ---> 1,256,40,40\\n        self.Head1VoV = VoVGSCSP(base_channels * 8, base_channels * 4)  # 1,512,80,80 ---> 1,256,80,80\\n        \\\"\\\"\\\"\\n        self.Head1VoV = nn.Sequential(VoVGSCSP(base_channels * 8, base_channels * 4),\\n                                      VoVGSCSP(base_channels * 4, base_channels * 4),\\n                                      VoVGSCSP(base_channels * 4, base_channels * 4))\\n        \\\"\\\"\\\"\\n        self.P3GSConv = GSConv(base_channels * 4, base_channels * 4, 3, 2)  # 1,256,80,80 ---> 1,256,40,40\\n        self.Head2VoV = VoVGSCSP(base_channels * 8, base_channels * 8)  # 1,512,40,40 ---> 1,512,40,40\\n        \\\"\\\"\\\"\\n        self.Head2VoV = nn.Sequential(VoVGSCSP(base_channels * 8, base_channels * 8),\\n                              VoVGSCSP(base_channels * 8, base_channels * 8),\\n                              VoVGSCSP(base_channels * 8, base_channels * 8))\\n        \\\"\\\"\\\"\\n        self.Head2GSConv = GSConv(base_channels * 8, base_channels * 8, 3, 2)  # 1,512,40,40 ---> 1,512,20,20\\n        self.Head3VoV = VoVGSCSP(base_channels * 16, base_channels * 16)  # 1,1024,20,20 ---> 1,1024,20,20\\n\\n        \\\"\\\"\\\"\\n        self.Head3VoV = nn.Sequential(VoVGSCSP(base_channels * 16, base_channels * 16),\\n                                        VoVGSCSP(base_channels * 16, base_channels * 16),\\n                                        VoVGSCSP(base_channels * 16, base_channels * 16))\\n        \\n        \\\"\\\"\\\"\\n        self.yolo_head_P3 = nn.Conv2d(base_channels * 4, len(anchors_mask[2]) * (5 + num_classes), 1)\\n        self.yolo_head_P4 = nn.Conv2d(base_channels * 8, len(anchors_mask[1]) * (5 + num_classes), 1)\\n        self.yolo_head_P5 = nn.Conv2d(base_channels * 16, len(anchors_mask[0]) * (5 + num_classes), 1)\\n\\n    def forward(self, x):\\n        P3, P4, P5 = self.backbone(x)\\n        P5 = self.SPPF(P5)\\n        P5 = self.P5GSConv(P5)\\n        P5_Up = self.upsample(P5)\\n\\n        P4 = self.concat([P4, P5_Up])\\n        P4 = self.P4VoV(P4)\\n        P4 = self.P4GSConv(P4)\\n        P4_Up = self.upsample(P4)\\n\\n        P3 = self.concat([P3, P4_Up])\\n        head1 = self.Head1VoV(P3)\\n        P3 = self.P3GSConv(head1)\\n        P34_Cat = self.concat([P3, P4])\\n        head2 = self.Head2VoV(P34_Cat)\\n        PHG = self.Head2GSConv(head2)\\n        PHG_Cat = self.concat([PHG, P5])\\n        head3 = self.Head3VoV(PHG_Cat)\\n\\n        Out1 = self.yolo_head_P3(head1)  # 1,255,80,80\\n        Out2 = self.yolo_head_P4(head2)  # 1,255,40,40\\n        Out3 = self.yolo_head_P5(head3)  # 1,255,20,20\\n\\n        return Out3, Out2, Out1\\n\\n\\n# if __name__ == \\\"__main__\\\":\\n#     anchors_mask = [[6, 7, 8], [3, 4, 5], [0, 1, 2]]\\n#     num_classes = 80\\n#     phi = 's'\\n#     model = YoloBody(anchors_mask, num_classes, phi, pretrained=False)\\n#     x = torch.ones((1, 3, 640, 640))\\n#     Out3, Out2, Out1 = model(x)\\n#     print()\\n```\\n    \\n    \\n\\n## 结尾\\n&emsp;&emsp;由于本人能力有限若文中有纰漏还请多多指正，感谢大家的阅读，希望本文对大家有所帮助,需要代码可以进入[我的仓库](https://github.com/kivenyangming/yoloV5-pytorch-bubbliiiing-GSConv)自取。结合bubbliiiing的代码和我重构的YoloBady即可。\\n### 参考：\\n\\n[1] 《Slim-neck by GSConv: A better design paradigm of detector architectures for autonomous vehicles》\\n[2] https://github.com/alanli1997/slim-neck-by-gsconv \\\\\\n[3] https://link.juejin.cn/?target=https%3A%2F%2Farxiv.org%2Fabs%2F2206.02424"
    },
    {
        "article_id": "7184963782882361405",
        "cover_image": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8df7c518f6fe4210af8a94bb29df6fbe~tplv-k3u1fbpfcp-watermark.image?",
        "title": "2022：被裁后的躺平平🔥",
        "brief": "一年一度的年终总结，象征着结束，也意味着开始。2022，绝对躺平平的一年，2023，flag先立起来！",
        "user_name": "俊劫",
        "view_count": 10825,
        "collect_count": 33,
        "comment_count": 90,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/62d0aa4e22afcaea41153a3b73695a5a~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: nico\\n---\\n「回顾2022，展望2023，我正在参与[2022年终总结征文大赛活动](https://juejin.cn/post/7172462429929111559)」\\n\\n> 去年的年终总结：[2021 从跳槽到被裁](http://alexjjwu.fun/pages/91bad3266146c/)，也要和2022说再见了，做个总结吧\\n>\\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8a46185ae944fc3bdef826827660396~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)\\n## 一、裁员 \\n\\n1月底经历了裁员，有兴趣的可以看另外一篇：[【逃离一线】被裁后的面经与感慨](https://juejin.cn/post/7098173433548111885) \\n\\n234三个月就是减肥、复习、面试：[【面试】2022被裁之后的面经-详细篇](https://juejin.cn/post/7098173433548111885) \\n\\n4月底因为各种原因，从杭州来到了武汉，开起了躺平的一年。2022实际工作日5月-12月，8个月。群里也有很多老哥，持续躺的更久的，覆巢之下安有完卵。\\n\\n有兴趣的可私聊加vx：V798595965 进群摸鱼，也可以直接 [点击扫码加V](http://alexjjwu.fun/img/wechat.png)，关注俊劫个人公众号，看更多个人动态[点击关注](http://alexjjwu.fun/img/wx-global.png)\\n\\n## 二、工作对比\\n\\n看一张工作对比图\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c3a2c4f3a8f471fa36769e70a5cdb25~tplv-k3u1fbpfcp-watermark.image?)\\n\\n简单计算一下，2021全年在用企微，2022用了8个月，2021平均每月4887次，2022平均每月445次\\n> 月平均工作量对比：4887/445 ≈ 11 倍！\\n\\n在上家简直是打工黑奴啊，工作量是现在的11倍，工资差不多。并且杭州房子均价4W，武汉2W，恐怖如斯\\n\\n\\n看到在掘金去年的留言条，也算是完成了\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5f1894d671f4759938b59619c0086dc~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## 三、躺平\\n这算是自己2022的主体关键词了，真躺的平平的，啥也没干，啥也没学，有时间就找乐子。下面讲讲都是怎么躺的：\\n\\n### 游戏\\n用Mac版腾讯start云游戏玩，只玩英雄联盟这一个端游。被ELO整成老喷子一个了，也在这上面浪费了很长时间，现在弃游了。本来准备用新手机玩手游的，玩了几把，发现已经没兴趣了。。。\\n\\n### 骑行\\n拼多多278块钱买的山地车，能骑就行。上班1km，夏天就骑车，冬天就步行。没事就去周边各个地方逛街，跟个街溜子一样，看到啥没见过的都要去看看😅\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/83558a18eda64954a72c8e87e7370c51~tplv-k3u1fbpfcp-watermark.image?)\\n\\n### 刷抖音\\n2022年，真的是刷了超级超级长的抖音\\n\\n看图就知道了，啥也不说了，已经开了APP每日限额，督促自己少刷点。戒掉是不可能戒掉的，晚上和女朋友睡前一起刷刷，聊聊天，毕竟异地。\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/67274dc7b682410e80ccd99228493632~tplv-k3u1fbpfcp-watermark.image?)\\n\\n### 看片\\n\\n写一些记得住的，记不住的就不想了\\n\\n1. 【隐入尘烟】：我心中2022国内最佳了，看之前不知道什么类型，拉女朋友一起看的，看完哭死😭。有人说这电影是在放大苦难，可这就是我们小时候的经历，也是现在大西北的实况\\n2. 【阿凡达2水之道】：特效依旧无敌，剧情就不说了，有点无聊\\n3. 【烈日灼心】：邓超主演，国内悬疑片，中规中矩\\n4. 【生化危机全系列、变形金刚系列、黑衣人系列】等老片：用朋友的Pico VR看的，体验还不错，特别是深田咏美系列，懂得都懂，hhh \\n5. 【坏蛋联盟】：国外的动漫，挺不错的，中间动不动就尬舞，有印度片那味\\n6. 【坠落】：看到最后变成了恐怖片。。。\\n7. 【头七】：台湾恐怖片，感觉一般，不恐怖，剧情也就那样\\n8. 【咒】：台湾恐怖片，还不错，推荐\\n9. 【独行月球】：含腾量100%，非常不错\\n10. 【狼狩猎】：看的有点无语，看媒体号宣传以为多好看，烂片一个\\n11. 【西线无战事】：讲述一个大兵从热爱到恐惧的过程，不错，结局比较遗憾\\n12. 【新·奥特曼】：周年纪念作品，特效不错，满足了小时候看高清奥特曼的梦想，就是剧情老一套，没啥亮点\\n13. 【壮志凌云2：独行侠】：阿汤哥YYDS\\n14. 【铁血战士：猎物】：烂片，演员都是rz\\n15. 。。。\\n\\n## 四、掘金\\n\\n### 文章\\n文章写了五篇，停更5个月了，后面的5个月，掘金粉丝、公众号粉丝增长缓慢。之前计划的做好自媒体也没能做下去，很遗憾，没把握住第一批被裁员的热度，如果从那个时候做短视频，自媒体，可能现在也不会躺的这么平\\n- [七夕给女朋友看这个，感动哭了😭](https://juejin.cn/editor/drafts/7127244736355631135)\\n- [你一个开发还搞不懂测试？速来🔥](https://juejin.cn/post/7124897639136493599) \\n- [超极速的Vue3上手指北🔥](https://juejin.cn/post/7122760155707473956)\\n- [聊一聊web图片小知识 ](https://juejin.cn/post/7116715255404691493/) \\n- [【逃离一线】被裁后的面经与感慨](https://juejin.cn/post/7098173433548111885) \\n\\n### 数据\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d832b6167dde42e8a106f3941c01be79~tplv-k3u1fbpfcp-watermark.image?)\\n\\n### 年度总结\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba48e939470447c2a93a98ea32ebcdc9~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## 五、杂七杂八\\n### 买房\\n来武汉看了几套，十一的时候也让女朋友一起来看了。有一套江夏区的6层小洋房，113平到手100平，精装修单价1.5w，很心动，当时想直接买了算了。但是想想房价从我来武汉，就一直跌的不停。利率从刚来武汉的5.6跌到现在年底3.9，不想接盘，不想站岗，不想买了几个月以后，又降很多。同事19年买的，利率很高加上现在他买的那个小区降价+送车位，血亏几十万。几年工白打，是我我直接开摆，谁受得了。但是对我这种没房的人来说，我又希望房价一直降。它一直降，我又不敢买，就很矛盾。\\n\\n所以之前说的今年买房计划，就G了\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f318e57acd534b29a027b64f55d47a12~tplv-k3u1fbpfcp-watermark.image?)\\n\\n### 工作\\n部门业务比较少，做了大量的技术调研工作，都是写写demo，写写文档。做的需求也很少，基本没有加过班，相比之前在某赞，周124九点下班、在某云一周体验卡，标准995的内卷，现在确实是轻松了很多。\\n\\n时间多并没有带来更多的学习和成长，因人而异，没有压力就没有动力。我怕我太卷，卷到其他人，这样也不好。我怕我不卷，对自己的成长也是个问题。时间久了，伴随而来的就是焦虑，今年也做了一些东西，但是对自己而言，摸鱼划水的时间没有利用起来，很遗憾。\\n\\n因为部门业绩不是很好，2023年的工作又是什么样子，可能变动会比较大，领导也和我说了要好好提升自己的能力，抓住机会，所以完全不慌🫥冲就完了\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db1cb899e03b413e95367864f186dfc6~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n### 感情\\n大学谈的女朋友到现在毕业三年了，久不久呢，毕竟有的朋友都是七八年起步的，我姐谈了12年，今年才结婚。我为什么还没有结果呢？无非就是那三件套：车、房、彩礼\\n\\n异地恋8个月了，期间要不是我去杭州，要不就是她来武汉。姐姐结婚的时候也带她去过我家，也趁着国庆节去过她家，不出意外的话，今年过年会订婚，明年会结婚。\\n\\n你要问我幸福吗？8个月自己住个小单间，自己一个人的空间想干嘛干嘛，周末没事的时候，自己想去哪去哪。女朋友生气的时候也折磨不到我，我现在愈发的享受现在一个人的时光。可能是之前在一起久了，腻了？也可能是重新获取了自由，报复性过个瘾？\\n\\n曝光一下\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c414f443e63449ab9e0a3b784566506~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n## 六、2023 flag\\n有志之人立常志，无志之人常立志。我就是妥妥的后者，但是人总不能因为觉得做不成就不去做。详细的就不写了，写个大概🌚\\n\\n### 掘金文章\\n- 每个月最少一篇\\n\\n### 专业学习\\n- 每个月最少一门专业课程学习，和上面结合可输入文章\\n\\n### 英语学习\\n- 利用早睡早起，拉女朋友一起背单词，练口语\\n\\n### 理财\\n- 2022年理财被债券坑了一把\\n- 2023，基金+稳定理财\\n- 收益率这个东西，我也定不好，还得好好学学\\n\\n### 习惯\\n- 早睡早起\\n- 手机瘾：让我脑子停止思考的APP，都得限制\\n- 如果某天刷了1小时的抖音，那么必须去B站看学习视频2小时或更多\\n- 减肥：吃 & 运动\\n- 。。。\\n\\n> - xdm，jmm  有兴趣的可私聊加vx：V798595965 进群摸鱼\\n> - 也可以直接 [点击扫码加V](http://alexjjwu.fun/img/wechat.png)，关注俊劫个人公众号，看更多个人动态[点击关注](http://alexjjwu.fun/img/wx-global.png)\\n\\n\\n## 七、往期回顾\\n- [七夕给女朋友看这个，感动哭了😭](https://juejin.cn/editor/drafts/7127244736355631135) 100+ 👍🏿\\n- [你一个开发还搞不懂测试？速来🔥](https://juejin.cn/post/7124897639136493599) 100+ 👍🏿\\n- [超极速的Vue3上手指北🔥](https://juejin.cn/post/7122760155707473956) 130+ 👍🏿\\n- [聊一聊web图片小知识 ](https://juejin.cn/post/7116715255404691493/) 100+ 👍🏿\\n- [【逃离一线】被裁后的面经与感慨](https://juejin.cn/post/7098173433548111885) 350+ 👍🏿\\n- [一篇搞定【web打印】知识点](https://juejin.cn/post/6985030118758416391) 90+ 👍🏿\\n- [一篇够用的TypeScript总结](https://juejin.cn/editor/drafts/6979800157164404767) 800+ 👍🏿\\n- [一名 vueCoder 总结的 React 基础](https://juejin.cn/post/6960556335092269063) 240+ 👍🏿\\n- [Vue 转 React不完全指北](https://juejin.cn/post/6953482028188860424) 900+ 👍🏿\\n- [跳槽人速来，面经&资源分享](https://juejin.cn/post/6942988170208215076) 1300+ 👍🏿\\n- [一年半前端人的求职路](https://juejin.cn/post/6940058373534515237) 350+ 👍🏿\\n- [vue2.x高阶问题，你能答多少](https://juejin.cn/post/6921911974611664903) 500+ 👍🏿\\n- [聊一聊前端性能优化](https://juejin.cn/post/6921911974611664903) 1700+ 👍🏿\\n- [Egg + Puppeteer 实现Html转PDF(已开源)](https://juejin.cn/post/6907500437134376974) 70+ 👍🏿\\n\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5af9bf6725d04b2999980c11a821a994~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n\\n\\n\\n\\n\\n\\n"
    },
    {
        "article_id": "7187669395697729592",
        "cover_image": "",
        "title": "Go的ORM也太拉跨了吧，赶紧给他封装一下",
        "brief": "去年慢慢开始接触了Go语言，也在公司写了几个Go的生产项目。我是从Java转过来的。（其实也不算转，公司用啥，我用啥）在这个过程中，老是想用Java的思维写Go，在开始的一两个月，那是边写边吐槽。",
        "user_name": "Afu",
        "view_count": 4226,
        "collect_count": 37,
        "comment_count": 40,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/6d75b9edb7d380ebb77aaba11aeaf25a~300x300.image",
        "category": "后端",
        "content": "---\\ntheme: juejin\\n---\\n## 背景\\n\\n去年慢慢开始接触了Go语言，也在公司写了几个Go的生产项目。我是从Java转过来的。（其实也不算转，公司用啥，我用啥）在这个过程中，老是想用Java的思维写Go，在开始的一两个月，那是边写边吐槽。\\n\\n丑陋的错误处理，没有流式处理，还竟然没有泛型，框架生态链不成熟，没有一家独大的类似Spring的框架。（其实现在写了快一年的Go，Go还是挺香的，哈哈）\\n\\n今天，我来聊一下，我在我在写Go过程中用的最多orm框架gorm。\\n\\n## Java的orm\\n\\n写过Java的基本都知道Mybatis，Mybatis-plus。\\n\\n在Mybatis-plus中操作单表非常方便，通过QueryWrapper，对于单表的操作非常的丝滑，没有任何的思维负担。\\n\\n类似下面这样：\\n\\n```\\n        QueryWrapper<User> queryWrapper = new QueryWrapper<>();\\n        queryWrapper.lambda().eq(User::getUsername,\\\"zhangsan\\\").eq(User::getAge,18);\\n        userMapper.selectList(queryWrapper);\\n```\\n\\n## Go的orm\\n\\n这里的条件查询都需要开发手动来拼接字符串，如果项目比较大的话，就会看到漫天飞的SQL字段，维护起来非常麻烦。\\n\\n```\\n  var users []*User\\n  sqlResult := db.Where(\\\"username = ? and age = ?\\\", \\\"zhangsan\\\", 18).Find(&users)\\n```\\n\\n## 解决方式\\n\\n写了一段时间的Go之后，实在不想每次都写这些字符串拼接了，于是我给gorm封装了一个gorm-plus。\\n\\n这里我使用到了go 1.18的泛型。泛型出了这么久，也该使用上了。\\n\\n其实就是把Mybatis-plus的那套语法借鉴了一下。（好吧，就是抄他的）\\n\\nMybatis-plus对于单表操作提供了非常多的CRUD操作。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13b5b245e2c24212969a28156e747fb2~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n我给gorm-plus 也提供了类似的操作\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d5d9299769b54b91921f1f258d4945ce~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n下面是具体用法\\n\\n下载：\\n\\n```\\ngo get github.com/acmestack/gorm-plus\\n```\\n\\n### 初始化sql\\n\\n```\\nDROP TABLE IF EXISTS `users`;\\nCREATE TABLE `users`  (\\n                          `id` int(0) NOT NULL AUTO_INCREMENT,\\n                          `username` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,\\n                          `password` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,\\n                          `age` int(0) NULL DEFAULT NULL,\\n                          `phone` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,\\n                          `score` int(0) NULL DEFAULT NULL,\\n                          `address` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,\\n                          `dept` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,\\n                          `created_at` datetime(0) NULL DEFAULT NULL,\\n                          `updated_at` datetime(0) NULL DEFAULT NULL,\\n                          PRIMARY KEY (`id`) USING BTREE\\n) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;\\n\\nSET FOREIGN_KEY_CHECKS = 1;\\n```\\n\\n### 连接数据库\\n\\n```\\nvar GormDb *gorm.DB\\n\\nfunc init() {\\n  dsn := \\\"root:123456@tcp(127.0.0.1:3306)/test?charset=utf8mb4&parseTime=True&loc=Local\\\"\\n  var err error\\n  GormDb, err = gorm.Open(mysql.Open(dsn), &gorm.Config{\\n    Logger: logger.Default.LogMode(logger.Info),\\n  })\\n  if err != nil {\\n    log.Fatalln(err)\\n  }\\n  gplus.Init(GormDb)\\n}\\n```\\n\\n### 插入语句\\n\\n```\\n  user := &User{Username: \\\"zhangsan\\\", Password: \\\"123456\\\", Age: 18, Score: 100, Dept: \\\"A部门\\\"}\\n  result := gplus.Insert(user)\\n  fmt.Println(result.RowsAffected)\\n```\\n\\n### 查询语句\\n\\n根据id查询：\\n\\n注意这里需要传入泛型User\\n\\n```\\n  user, resultDb := gplus.SelectById[User](1)\\n  fmt.Println(user, resultDb.RowsAffected)\\n```\\n\\n根据ids查询：\\n\\n```\\n  var ids = []int{1,2}\\n  users, resultDb := gplus.SelectByIds[User](ids)\\n  fmt.Println(users, resultDb.RowsAffected)\\n```\\n\\n条件查询：\\n\\n```\\n  q := gplus.NewQuery[User]()\\n  q.Eq(\\\"username\\\", \\\"zhangsan\\\").Eq(\\\"age\\\",18)\\n  users, resultDb := gplus.SelectList(q)\\n  fmt.Println(users,resultDb.RowsAffected)\\n```\\n\\n对比一下Mybatis-plus写法基本一致了。\\n\\n```\\n        QueryWrapper<User> queryWrapper = new QueryWrapper<>();\\n        queryWrapper.lambda().eq(User::getUsername,\\\"zhangsan\\\").eq(User::getAge,18);\\n        userMapper.selectList(queryWrapper);\\n```\\n\\n更多操作请查看：\\n\\n<https://github.com/acmestack/gorm-plus>\\n\\n## gplus工具\\n\\n其实上面的写法还是需要写数据库的字段名，如果数据库的字段名很多，我们很容易写错，导致不必要的bug产生。\\n\\n一旦名称长，非常容易误写，而且如果有字段名称修改的话，还需要全局搜索一个个地修改，比较麻烦。\\n\\nGo没有提供类似Java的lambad表达式或者C#中 `nameof` 方式直接获取某个对象的字段名称的操作，但是我们可以通过生成代码的方式生成字段名。\\n\\n所有就有了gplus，它作用就是自动识别结构体，把结构体的字段名生成出来。\\n\\n下载使用：\\n\\n```\\ngo install github.com/acmestack/gorm-plus/cmd/gplus@latest\\n```\\n\\n通过 `gplus gen paths=路径`，gplus 会自动识别带有`// +gplus:column=true`注释的结构体，给这个结构体生成字段。\\n\\ngplus 会在输入的路径下面生成 `zz_gen.column.go`文件。\\n\\n例如：\\n\\n在example目录下创建了了一个users.go 目录，执行 `gplus gen paths=./eample`\\n\\nusers.go\\n\\n```\\n// +gplus:column=true\\n\\ntype User struct {\\n  ID        int64\\n  Username  string `gorm:\\\"column:username\\\"`\\n  Password  string\\n  Address   string\\n  Age       int\\n  Phone     string\\n  Score     int\\n  Dept      string\\n  CreatedAt time.Time\\n  UpdatedAt time.Time\\n}\\n```\\n\\nzz_gen.column.go （自动生成的）\\n\\n```\\nvar UserColumn = struct {\\n  ID        string\\n  Username  string\\n  Password  string\\n  Address   string\\n  Age       string\\n  Phone     string\\n  Score     string\\n  Dept      string\\n  CreatedAt string\\n  UpdatedAt string\\n}{\\n  ID:        \\\"id\\\",\\n  Username:  \\\"username\\\",\\n  Password:  \\\"password\\\",\\n  Address:   \\\"address\\\",\\n  Age:       \\\"age\\\",\\n  Phone:     \\\"phone\\\",\\n  Score:     \\\"score\\\",\\n  Dept:      \\\"dept\\\",\\n  CreatedAt: \\\"created_at\\\",\\n  UpdatedAt: \\\"updated_at\\\",\\n}\\n```\\n\\n其实你自己也可以手写这个文件，只不过通过工具生成更加方便而已。\\n\\n有了这个文件，我们的查询就变成这样：\\n\\n```\\n  q := gplus.NewQuery[User]()\\n  q.Eq(UserColumn.Username, \\\"zhangsan\\\").Eq(UserColumn.Age,18)\\n  users, resultDb := gplus.SelectList(q)\\n  fmt.Println(users,resultDb.RowsAffected)\\n```\\n\\n这样维护起来就非常方便了。\\n\\n## 最后\\n\\n更多的用法请查看github地址：\\n\\n<https://github.com/acmestack/gorm-plus>\\n\\n感兴趣的，动动小手指，点个star哈！\\n"
    },
    {
        "article_id": "7182571660003213370",
        "cover_image": "",
        "title": "🌄 JavaScript 的三座大山",
        "brief": "js 作为前端的中坚力量。那么 javascript 三座大山，你知道是哪些呢？ 1️⃣ 作用域和闭包 作用域 指代码当前上下文，控制着变量和函数的可见性和生命周期。最大的作用是隔离变量，不同作用域下",
        "user_name": "vocoWone",
        "view_count": 16340,
        "collect_count": 544,
        "comment_count": 40,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/ef8446f29a78f7523845977922892ffd~300x300.image",
        "category": "前端",
        "content": "js 作为前端的中坚力量。那么 javascript 三座大山，你知道是哪些呢？\\n\\n<img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b003588e87c4d00b3491434c51a245b~tplv-k3u1fbpfcp-zoom-1.image\\\" alt=\\\"\\\">\\n\\n## 1️⃣ 作用域和闭包\\n\\n**`作用域`** 指代码当前上下文，控制着变量和函数的可见性和生命周期。最大的作用是隔离变量，不同作用域下同名变量不会冲突。\\n\\n**`作用域链`** 指如果在当前作用域中没有查到值，就会向上级作用域查询，直到全局作用域，这样一个查找过程所形成的链条就被称之为作用域链。\\n\\n作用域可以堆叠成层次结构，子作用域可以访问父作用域，反之则不行。\\n\\n作用域具体可细分为四种：**`全局作用域`**、**`模块作用域`**、**`函数作用域`**、**`块级作用域`**\\n\\n**全局作用域：** 代码在程序的任何地方都能被访问，例如 window 对象。但全局变量会污染全局命名空间，容易引起命名冲突。\\n\\n**模块作用域：** 早期 js 语法中没有模块的定义，因为最初的脚本小而简单。后来随着脚本越来越复杂，就出现了模块化方案（AMD、CommonJS、UMD、ES6模块等）。通常一个模块就是一个文件或者一段脚本，而这个模块拥有自己独立的作用域。\\n\\n**函数作用域：** 顾名思义由函数创建的作用域。闭包就是在该作用域下产生，后面我们会单独介绍。\\n\\n**块级作用域：** 由于 js 变量提升存在变量覆盖、变量污染等设计缺陷，所以 ES6 引入了块级作用域关键字来解决这些问题。典型的案例就是 let 的 for 循环和 var 的 for 循环。\\n\\n```javascript\\n// var demo\\nfor(var i=0; i<10; i++) {\\n    console.log(i);\\n}\\nconsole.log(i); // 10\\n\\n// let demo\\nfor(let i=0; i<10; i++) {\\n    console.log(i);\\n}\\nconsole.log(i); //ReferenceError：i is not defined\\n```\\n\\n了解完作用域再来谈谈 **`闭包`：** 函数A里包含了函数B，而函数B使用了函数A的变量，那么函数B被称为闭包或者闭包就是能够读取函数A内部变量的函数。\\n\\n可以看出闭包是函数作用域下的产物，闭包会随着外层函数的执行而被同时创建，它是一个函数以及其捆绑的周边环境状态的引用的组合。换而言之，**闭包是内层函数对外层函数变量的不释放**。\\n\\n**闭包的特征：**\\n\\n* 函数中存在函数；\\n* &#x20;内部函数可以访问外层函数的作用域；\\n* 参数和变量不会被 GC，始终驻留在内存中；\\n* 有内存地方才有闭包。\\n\\n所以使用闭包会消耗内存、不正当使用会造成内存溢出的问题，在退出函数之前，需要将不使用的局部变量全部删除。如果不是某些特定需求，在函数中创建函数是不明智的，闭包在处理速度和内存消耗方面对脚本性能具有负面影响。\\n\\n**以下整理了闭包的应用场景：**\\n\\n<pre class=\\\"language-typescript\\\" data-title=\\\"循环中使用\\\"><code class=\\\"lang-typescript\\\"><strong>// demo1 输出 3 3 3\\n</strong>for(var i = 0; i &#x3C; 3; i++) {\\n    setTimeout(function() {\\n        console.log(i);\\n    }, 1000);\\n} \\n// demo2 输出 0 1 2\\nfor(let i = 0; i &#x3C; 3; i++) {\\n    setTimeout(function() {\\n        console.log(i);\\n    }, 1000);\\n}\\n// demo3 输出 0 1 2\\nfor(let i = 0; i &#x3C; 3; i++) {\\n    (function(i){\\n        setTimeout(function() {\\n        console.log(i);\\n        }, 1000);\\n    })(i)\\n}\\n</code></pre>\\n\\n```typescript\\n/* 模拟私有方法 */\\n// 模拟对象的get与set方法\\nvar Counter = (function() {\\nvar privateCounter = 0;\\nfunction changeBy(val) {\\n    privateCounter += val;\\n}\\nreturn {\\n    increment: function() {\\n    changeBy(1);\\n    },\\n    decrement: function() {\\n    changeBy(-1);\\n    },\\n    value: function() {\\n    return privateCounter;\\n    }\\n}\\n})();\\nconsole.log(Counter.value()); /* logs 0 */\\nCounter.increment();\\nCounter.increment();\\nconsole.log(Counter.value()); /* logs 2 */\\nCounter.decrement();\\nconsole.log(Counter.value()); /* logs 1 */\\n```\\n\\n```typescript\\n/* setTimeout中使用 */\\n// setTimeout(fn, number): fn 是不能带参数的。使用闭包绑定一个上下文可以在闭包中获取这个上下文的数据。\\nfunction func(param){ return function(){ alert(param) }}\\nconst f1 = func(1);setTimeout(f1,1000);\\n```\\n\\n```typescript\\n/* 生产者/消费者模型 */\\n// 不使用闭包\\n// 生产者\\nfunction producer(){\\n    const data = new（...）\\n    return data\\n}\\n// 消费者\\nfunction consumer(data){\\n    // do consume...\\n}\\nconst data = producer()\\n\\n// 使用闭包\\nfunction process(){\\n    var data = new (...)\\n    return function consumer(){\\n        // do consume data ...\\n    }\\n}\\nconst processer = process()\\nprocesser()\\n```\\n\\n```typescript\\n/* 实现继承 */\\n// 以下两种方式都可以实现继承，但是闭包方式每次构造器都会被调用且重新赋值一次所以，所以实现继承原型优于闭包\\n// 闭包\\nfunction MyObject(name, message) {\\n  this.name = name.toString();\\n  this.message = message.toString();\\n  this.getName = function() {\\n    return this.name;\\n  };\\n\\n  this.getMessage = function() {\\n    return this.message;\\n  };\\n}\\n// 原型\\nfunction MyObject(name, message) {\\n  this.name = name.toString();\\n  this.message = message.toString();\\n}\\nMyObject.prototype.getName = function() {\\n  return this.name;\\n};\\nMyObject.prototype.getMessage = function() {\\n  return this.message;\\n};\\n```\\n\\n对于闭包的概念好像懂了但又好像缺少了啥？意犹未尽。我也曾也闭包中迷失，但是看完闭包的生命周期让我重新找回自己。\\n\\n<img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/32826c4464ff4b8e86d68606a2a6f68b~tplv-k3u1fbpfcp-zoom-1.image\\\" alt=\\\"一张图看懂闭包的生命周期\\\">\\n\\n学完就来一波牛刀小试\\n\\n```typescript\\nfunction test(a, b){\\n  console.log(b);\\n  return {\\n    test: function(c) {\\n      return test(c,a);\\n    }\\n  }\\n}\\n\\nvar a = test(100);a.test(101);a.test(102);\\nvar b = test(200).test(201).test(202);\\nvar c = test(300).test(301);c.test(302);\\n\\n// undefined  100  100\\n// undefined  200 201\\n// undefined  300 301\\n```\\n\\n## 2️⃣ 原型和原型链\\n\\n有对象的地方就有 **`原型`**，每个对象都会在其内部初始化一个属性，就是prototype(原型)，原型中存储共享的属性和方法。当我们访问一个对象的属性时，js引擎会先看当前对象中是否有这个属性，如果没有的就会查找他的prototype对象是否有这个属性，如此递推下去，一直检索到 Object 内建对象。这么一个寻找的过程就形成了 **`原型链`** 的概念。\\n\\n理解原型最关键的是理清楚\\\\_\\\\_proto\\\\_\\\\_、prototype、constructor三者的关系，我们先看看几个概念：\\n\\n* **\\\\_\\\\_proto\\\\_\\\\_属性**在所有对象中都存在，指向其构造函数的prototype对象；**prototype对象**只存在（构造）函数中，用于存储共享属性和方法；**constructor属性**只存在于（构造）函数的prototype中，指向（构造）函数本身。\\n* 一个对象或者构造函数中的**隐式原型\\\\_\\\\_proto\\\\_\\\\_**的属性值指向其构造函数的**显式原型 prototype** 属性值，关系表示为：`instance.__proto__ === instance.constructor.prototype`\\n* 除了 Object，所有对象或构造函数的 prototype 均继承自 Object.prototype，原型链的顶层指向 null：`Object.prototype.__proto__ === null`\\n* Object.prototype 中也有 constructor：`Object.prototype.constructor === Object`\\n* 构造函数创建的对象（Object、Function、Array、普通对象等）都是 Function 的实例，它们的 \\\\_\\\\_proto\\\\_\\\\_ 均指向 Function.prototype。\\n\\n看起来是不是有点乱？？别慌！！一张图帮你整理它们之间的关系\\n\\n<img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c53c982b06274603a7d99d2b9f49a4e5~tplv-k3u1fbpfcp-zoom-1.image\\\" alt=\\\"原型关系图\\\">\\n\\n相同的配方再来一刀\\n\\n```typescript\\nconst arr = [1, 2, 3];\\narr.__proto__ === Array.prototype; // true\\narr.__proto__.__proto__ === Object.prototype; // true\\nArray.__proto__ === Function.prototype; // true\\n```\\n\\n## 3️⃣ 异步和单线程\\n\\nJavaScript 是 **`单线程`** 语言，意味着只有单独的一个调用栈，同一时间只能处理一个任务或一段代码。队列、堆、栈、事件循环构成了 js 的并发模型，**`事件循环`** 是 JavaScript 的执行机制。\\n\\n为什么js是一门单线程语言呢？最初设计JS是用来在浏览器验证表单以及操控DOM元素，为了避免同一时间对同一个DOM元素进行操作从而导致不可预知的问题，JavaScript从一诞生就是单线程。\\n\\n既然是单线程也就意味着不存在异步，只能自上而下执行，如果代码阻塞只能一直等下去，这样导致很差的用户体验，所以事件循环的出现让 js 拥有异步的能力。\\n\\n<img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7bdd4419989d4bec8ac627480572cf84~tplv-k3u1fbpfcp-zoom-1.image\\\" alt=\\\"事件循环链路图\\\">\\n\\n以上就是关于js三座大山的全部内容。什么？还不懂，告诉我ip地址我顺着网线过去教你！！\\n\\n内容来自[传送门](https://vocowone.gitbook.io/fe-basics/)\\n"
    },
    {
        "article_id": "7178686507559944250",
        "cover_image": "",
        "title": "稳中求进的2022年",
        "brief": "2022 年年初做了一份年度计划，给自己列了 13 条今年完成的事情，除了 1 条完全没有启动之外，其余 12 条或完成，或还在进行中。给自己还定了 5 个核心目标，大部分完成的还是蛮顺利的。",
        "user_name": "咖啡机KFJ",
        "view_count": 798,
        "collect_count": 4,
        "comment_count": 5,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/c153cf98cd8ec474ca0d95f9a8b4c2a8~300x300.image",
        "category": "代码人生",
        "content": "　　「回顾2022，展望2023，我正在参与[2022年终总结征文大赛活动](https://juejin.cn/post/7172462429929111559 \\\"https://juejin.cn/post/7172462429929111559\\\")」\\n  \\n　　2022 年年初做了一份年度计划，给自己列了 13 条今年完成的事情，除了 1 条完全没有启动之外，其余 12 条或完成，或还在进行中。\\n\\n　　给自己还定了 5 个核心目标，除了个别需要与其他组协调的任务进度缓慢之外，大部分完成的还是蛮顺利的。\\n\\n　　下面的思维图列举出了今年做的一些比较重要的事情。\\n　　![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/748810bf441a423bbb6732c1da689a2a~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n　　与 2021 年从 0-1 时的[年终总结](https://www.cnblogs.com/strick/p/15223931.html)略有不同，今年就是在干 4 件事：知识沉淀、提效保质、体验优化和研发标准。\\n\\n## 一、知识沉淀\\n\\n　　知识沉淀就是将有效信息记录在案，这个在去年就已经提出了，今年是持续精进。\\n\\n　　今年不仅自己在维护文档，而且还让组内的成员也一起参与，让他们也能自觉地补充更多的文档。\\n\\n　　最近还学到了个新名词：活文档，就是将记录写在事物本身中，例如代码中的注释、版本提交时的 message 等。\\n\\n　　我们组今年也在进一步规范这类活文档，减少信息障碍。\\n\\n　　5月中旬，公司将之前存放在 wiki 中的文档整体迁移至飞书文档中，我对整体的目录也做了一次细致的归类，便于查看。\\n\\n　　改成飞书后，有个很大的好处，就是可以直接用手机浏览文档了，文档格式也比之前的 confluence 美观。\\n\\n#### 1）工作文档\\n\\n　　工作文档包括项目文档、周会记录等。\\n\\n　　项目文档，是在去年的基础上，持续补充各类信息，例如项目中遇到的难点，新项目的文档说明等。\\n\\n　　还有对之前写的比较模糊的资料，做了一次详细的补充，使文档更有用。\\n\\n　　周会之前只是简单的罗列工作记录，今年制作了几张较为完整的表格，分门别类的记录各种工作内容，并且会附上状态和风险等内容。\\n\\n#### 2）计划规范\\n\\n　　今年补充了几个比较大的计划，例如北极星指标、项目迁移、性能优化、年度计划等。\\n\\n　　北极星指标会在后文中详细说明，项目迁移就是 Node 服务迁移至 Go，jQuery 迁移至 Vue 等。\\n\\n　　性能优化记录了今年的一些优化手段，例如操作日志表优化、导出优化、缓存图像资源等。\\n\\n　　今年一个比较重要的规范是通用组件的默认功能和交互，公司的大部分活动都是基于这些组件研发的。\\n\\n　　在规范之后，就能大大 QA 在测试时的返工，很多时候一些细节就会纠缠很久。\\n\\n　　例如点击封禁账号后，有时候表现会与之前 QA 所想的不同，那么此时她就要与产品和开发核对。\\n\\n#### 3）技术分享\\n\\n　　技术分享在去年也提出过，并且还制订了相应的规范，但是由于是针对技术部所有人的，所以组织一次的周期会比较久。\\n\\n　　并且参与积极度也不是很高，所以今年 2 月份的时候就调整成全公司的人都可参与，但是参与度仍旧低迷。\\n\\n　　再加上三月到六月，整体居家办公，更不能举报全公司的分享会了。所以 3 月份再做一次调整，改成团队内的分享。\\n\\n　　每个人都会轮到，一周一个，技术范围不限制，这次大家都能参与进来，已经进行了 34 场，每场结束后，都会将内容留档。\\n\\n　　大家对此类技术分享并不排斥，都会积极准备，大部分是源码分析和案例分享。\\n\\n#### 4）Code Review\\n\\n　　5 月份的时候发生了几场事故，问题虽然低级，但造成的危害却不小，如何有效的进行规避，在当时我进行了思考。\\n\\n　　我想到的一点就是 Code Review，大家坐下来，一起检查下代码的写法，一起判断业务逻辑是否合理，很容易就能发现那[几个事故中的问题](https://www.cnblogs.com/strick/p/16173134.html)。\\n\\n　　今年不定期的举办了 15 场 Code Review，发现了很多问题，例如逻辑错误、理解误差、写法优化等。\\n\\n　　还有很重要的一个举措就是推广代码注释，成员们普遍对注释比较吝啬，你自己显而易见的写法，别人可能难以理解。\\n\\n　　况且好记性不如烂笔头，注释也能帮助自己理解比较复杂的代码。\\n\\n## 二、提效保质\\n\\n　　在提升效率的同时，保障项目质量，鱼和熊掌不可兼得，是我今年重点在推进的事情。\\n\\n　　在补充人手后，我能有更多的时间抓工具化和流程化的事情。\\n\\n#### 1）工具化\\n\\n　　要想提效，就需要有趁手的工具，今年在去年的基础上，又增加和优化了多种工具。\\n\\n　　BFF 平台在去年就研发完成了，不过在组内并没有马上推广开来，直到今年年初，才陆陆续续开始使用。\\n\\n　　目前新的业务接口基本都会走此平台，线上已有 70 多个接口在稳定运行着。\\n\\n　　[榜单活动配置化](https://www.cnblogs.com/strick/p/15928830.html)是将常用的活动做成可视化配置的形式，目的是减少开发和测试人力，将 2 天的研发时间压缩至 2 小时。\\n\\n　　这个配置协调了 UI 组、产品组、测试组、前端组、数据组一起，制订出了相关规范，已成功运营了 5 场活动。\\n\\n　　为了提升管理后台的开发效率，先后研发了后台编辑器[第一版](https://www.cnblogs.com/strick/p/16085718.html)和[第二版](https://www.cnblogs.com/strick/p/16744656.html)，第一版组员接受度并不理想，第二版已经上线了两个菜单。\\n\\n　　组内成员配合运维组，研发了IP白名单管理，帮助在家办公的同事，可以访问公司内网，降低了进内网的门槛。\\n\\n　　为了规范代码编辑，引入了 ESLint，对冗余代码和会存在隐患的代码进行标注，帮助我们写出更健壮的代码。\\n\\n　　开发了一款 VSCode 智能[索引插件](https://www.cnblogs.com/strick/p/16572344.html)，因为框架写法的原因，使得路由层的代码不能自动跳转到服务层，因此写了插件扩展功能。\\n\\n#### 2）流程优化\\n\\n　　管理后台静态页面的项目发布一直被诟病，因为发布速度太慢了，今年和运维联手，从 12 分钟降低到 5 分 30 秒。\\n\\n　　解决了我们组的心腹大患，终于可以愉快的发布项目了，再也不用干等了。\\n\\n　　组内的另一个成员让测试环境可以自动被发布，只要将代码合并到测试分支，就能进行发布流程，非常方便。\\n\\n　　在发布流水线中，增加核心服务的单元测试，避免线上再出现服务不能访问的重大问题。\\n\\n#### 3）前端监控\\n\\n　　[前端监控系统](https://www.cnblogs.com/strick/p/14574492.html)在去年完成了 0 到 1 的第一步，今年每个月其实都在做维护和优化，目标是让此系统更好用，而不是一个花瓶，具体优化可参考此处。\\n\\n　　今年帮助我们解决了不少线上问题，有的是主动发现，有的是用户上报后，借助该系统将问题定位。\\n\\n　　不定期的维护包括查询条件增加时间快捷键，过滤第三方库的通信，活动页面的通信中增加userId，优化LCP的采样时机，白屏的计算，监控静态资源的请求错误等。\\n\\n　　前端的监控日志为了能与服务端日志相关联，特地在通信时增加全链路日志唯一标识，不再让两端割裂。\\n\\n　　Node 服务中有很多因 console.log() 打印出的无效日志，今年也一并清理，清理后的日志更加整洁清晰，查询日志时少了很多干扰，日志量也骤降几百万。\\n\\n　　为了能及时的收到线上错误，让运维帮忙配置了接口状态码异常（500以上）的飞书告警，规则是同一个接口 1 分钟内连续 5 次状态异常就会发消息告警。\\n\\n　　8 月再次联合运维，将 一套 Node 在线监控系统部署到服务器上，实时查看服务器的性能参数了，例如内存、QPS、CPU 等。\\n\\n#### 4）招聘\\n\\n　　招聘我觉得是个老大难的问题，从去年 11 月就开始了，陆陆续续也面了十几个人，没有找到合适的。\\n\\n　　期间也将招聘信息投稿到大流量公众号、科技周刊，还在 V 站发布了招聘帖子。\\n\\n　　最终转化率最高的是 V 站的帖子，在那边收到了几份简历，最后录用了一名，3 月份正式入职，目前也已经过了试用期。\\n\\n　　今年要招聘两个人，另一个人选也招了好久，远程办公期间发了 3 次 offer，结果有两人来了没几天就走了。\\n\\n　　另一人做了两个多月，自己觉得没有融入主动离职了。我们这边不仅仅要做页面工作，还会涉及些服务端的工作，把工作门槛提高了。\\n\\n　　本来就是小公司，职责范围还广，就更加难招了。最后一个同事举荐了他的一个同事，聊的不错就发 offer 了，熟人好办事。\\n\\n　　8 月底入职，到现在也 3 个多月了，适应能力很强，干活也利索，靠谱的很。\\n\\n　　人员配齐后，无论是工作效率，还是工作质量，都比之前高很多，并且还能承接更多的业务需求。\\n\\n## 三、体验优化\\n\\n　　体验优化也是我今年的一个重点，不仅在易用性上下功夫，还量化了一系列的指标。\\n\\n　　更容易让大家看到努力优化后的成果，提供更稳定更流畅的服务给用户，包括对外的会员和对内的员工。\\n\\n　　大到一个模块，小到一个按钮，都是我们优化的对象。\\n\\n#### 1）项目改造\\n\\n　　管理后台是公司内大部分员工每天办公的系统，为了便于在手机上使用，特地对其做了[响应式改造](https://www.cnblogs.com/strick/p/16112198.html)。\\n\\n　　对项目进行 TypeScript 改造，是为了更好的保障代码质量，目前仅在管理后台中小范围的进行推广。\\n\\n　　为了提升活动页面的加载速度，对其静态资源进行了 CDN 加速，但是在监控系统中发现，有些旧的资源还在被访问，可能是手机缓存或 CDN 没有刷新到。\\n\\n　　对活动页面的脚本也做了针对性的瘦身，分离页面中不需要的第三方库。并且对页面的卡顿、白屏等问题，也都陆续进行了有效优化。\\n\\n#### 2）北极星指标\\n\\n　　北极星指标，也叫第一关键指标，是指在产品的当前阶段与业务/战略相关的核心指标，一旦确立就像北极星一样指引团队向同一个方向前进。\\n\\n　　因为我们组维护着大量的 Node 服务，所以指标中就会包含多个服务端数据。其中慢响应（请求时间大于2秒）作为我们组的北极星指标。\\n\\n　　在[量化日常工作指标](https://www.cnblogs.com/strick/p/16412339.html)后，我们组做了大量的优化工作，将对外业务的慢响应占比控制在万分之二以内。\\n\\n　　在过滤掉不影响用户体验和正常优化后的慢响应，数量从 1.307W 降至 1100 个左右。\\n\\n　　还有一个指标是 SLA（服务水平协议）占比（例如 99.999%），这是对网站可用性的一个保证，百分比中的 9 越多代表服务可用时间越长，越可靠，停机时间越短。\\n\\n　　我们组也持续优化了很多报 500 的接口，基本都是因为 null 或 undefined 引起的，例如 null.map()、undefined.toString() 等。\\n\\n　　500 的接口在修复和过滤不影响用户体验的接口之后，从 2159 降至个位数，目前每天的指标数据都比较稳定。\\n\\n　　除此之外，每个双月还会给协作方提供一份问卷调查，给我们的表现打分，满分 5 分，并且给予我们一定的改进建议。\\n\\n#### 3）性能监控\\n\\n　　去年的[性能监控](https://www.cnblogs.com/strick/p/14578711.html)只有几张折线图，使用率也比较低，今年附加了很多新功能，并且与前端监控可以更好的联动，具体优化可参考此处。\\n\\n　　新增的资源瀑布图可以在出现页面问题时，准确的了解到静态资源的加载情况。\\n\\n　　LCP、FID 和 FCP 是三个今年新增的性能指标，从更多的角度了解页面性能情况。\\n\\n　　分别统计白屏和首屏 1 秒内的数量、1-2 秒内、2-3 秒内、3-4 秒内、4+秒的数量，再用堆叠柱状图呈现。\\n\\n　　在将统计的参数全部计算出来后，为了能更直观的发现性能瓶颈，设计了一张阶段时序图。\\n\\n　　描绘出 TTFB、responseDocumentTime、initDomTreeTime、parseDomTime 和 loadEventTime 所占用的时间。\\n\\n## 四、研发标准\\n\\n　　在去年也推进过技术的升级、统一技术栈和前后端分离，今年完成方面比去年好很多。\\n\\n　　主要就是各个组的人员都补充后，有了更多的资源去支持这类基础工作，不像以前都铺在业务上。\\n\\n#### 1）技术升级\\n\\n　　去年将 UmiJS 升级到 2.0，今年 3 月成功升级到了 3.0，不过官方今年已经推出了 4.0 的稳定版本。\\n\\n　　服务器的 Node 环境，五年来一直是 8.7 版本，去年曾经短暂的升级到 12，但是发现了时区问题，马上就还原了。\\n\\n　　后面人员都铺在业务上，也没时间做升级，一直拖到今年 8 月，才有机会推进升级，一举升到 16.15。\\n\\n　　终于可以使用一些新的 Node 功能和第三方库了，虽然这次升级也遇到了时区问题，但是顺利解决了。\\n\\n#### 2）技术栈统一\\n\\n　　Node 的那些边角料服务今年也没有时间迁移至 Go，ROI（投资回报率）太低，没人重视，一直搁置着。\\n\\n　　6 月制订了前端技术栈统一计划，由我们自己组操控，之前因为历史原因和赶进度，将一些活动页面通过 jQuery 实现。\\n\\n　　现在就要将那些页面改成 Vue，试着先迁移了 3 张常用的活动页面，当前已经迁移完成。\\n\\n#### 3）前后端分离\\n\\n　　前后端分离其实从我进公司就一直挂在嘴巴，但因为客观原因，一直无法推进。\\n\\n　　今年 10 月初终于迎来了正式改造，先在管理后台试点，我们提供权限和操作日志的接口，这样就能适配之前的验签和日志逻辑。\\n\\n　　10 月底顺利上线，目前已经在服务器中稳定运行。\\n\\n　　活动页面的分离，也在稳步进行中，接下来就是我们出页面，服务端出接口，首次先在常用的榜单中试点。"
    },
    {
        "article_id": "7189101003214913596",
        "cover_image": "",
        "title": "9款日志管理工具大比拼，选型必备！",
        "brief": "对于日志管理当前网络上提供了大量的日志工具，今天就给大家分析总结一下这些常用工具的特点，希望对你们在选型时有所帮助，如果有用记得一键三连。 1、Filebeat Filebeat是用于转发和集中日志数",
        "user_name": "码猿技术专栏",
        "view_count": 1414,
        "collect_count": 16,
        "comment_count": 0,
        "avatar": "https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/24/1710d2d313678bc6~tplv-t2oaga2asx-image.image",
        "category": "后端",
        "content": "对于日志管理当前网络上提供了大量的日志工具，今天就给大家分析总结一下这些常用工具的特点，希望对你们在选型时有所帮助，如果有用记得一键三连。\\n\\n> 首发公众号：码猿技术专栏\\n\\n## 1、Filebeat\\n\\nFilebeat是用于转发和集中日志数据的轻量级传送程序。作为服务器上的代理安装，Filebeat监视您指定的日志文件或位置，收集日志事件，并将它们转发到Elasticsearch或Logstash进行索引。\\n\\nFilebeat的工作方式如下：启动Filebeat时，它将启动一个或多个输入，这些输入将在为日志数据指定的位置中查找。对于Filebeat所找到的每个日志，Filebeat都会启动收集器。每个收集器都读取一个日志以获取新内容，并将新日志数据发送到libbeat，libbeat会汇总事件并将汇总的数据发送到您为Filebeat配置的输出。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1145e0a52a2f47f5b6777813ac7f3a21~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n### 1.1 主要特点\\n\\n- 轻量级并且易使用\\n- 模块可用于常见用例（例如 Apache 访问日志）。您可以使用它们来设置 Filebeat、Ingest 和 Kibana 仪表板，只需几个命令\\n\\n### 1.2 价格\\n\\n免费开源\\n\\n### 1.3 优点\\n\\n- 资源使用率低\\n- 良好的性能\\n\\n### 1.4 缺点\\n\\n有限的解析和丰富功能\\n\\n## 2、Graylog\\n\\nGraylog是一个开源的日志聚合、分析、审计、展现和预警工具。功能上和ELK类似，但又比ELK要简单，依靠着更加简洁，高效，部署使用简单的优势很快受到许多人的青睐。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9350660c2c5b4cff87ee2a4f2f1572c8~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n### 2.1 主要特点\\n\\n- 一个包含日志处理所有要素的软件包：收集、解析、缓冲、索引、搜索、分析。\\n- 开源 ELK 堆栈无法提供的其他功能，例如基于角色的访问控制和警报\\n\\n### 2.2 价格\\n\\n免费和开源，不过也有企业版(根据要求提供价格)\\n\\n### 2.3 优点\\n\\n- 在一个软件包中满足大多数集中式日志管理用例的需求\\n- 轻松扩展存储 (Elasticsearch) 和获取通道\\n\\n### 2.4 缺点\\n\\n- 可视化能力是有限的，至少与ELK的Kibana相比是如此\\n- 不能使用整个ELK生态系统，因为他们不能直接访问Elasticsearch API。相反，Graylog有自己的API\\n\\n\\n## 3、LogDNA\\n\\nLogDNA是日志管理领域的新成员。LogDNA可作为SaaS和内部使用，提供所有日志基础:通过syslog和HTTP(S)以及全文搜索和可视化，提供基于代理和无代理的日志收集，并提供清晰且具有竞争力的价格。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/67e73c8c92bf43d0a70be7e182475d94~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n### 3.1 主要特点\\n\\n- 用于在组织外部共享日志的嵌入式视图\\n- 自动解析常用日志格式\\n\\n### 3.2 价格\\n\\n- 免费：无存储\\n- 收费：付费计划起价为每月每GB 1.50 美元，保留 7 天\\n\\n### 3.3 优点\\n\\n- 用于搜索日志的简单 UI，类似于 Papertrail\\n- 易于理解的计划\\n\\n### 3.4 缺点\\n\\n- 可视化能力有限\\n- 保留期取决于计划（从 7 天到 30 天）。用户数量也是如此（最便宜的计划只允许 5 个）\\n\\n## 4、Elasticsearch, Logstash and Kibana (ELK stack or Elastic Stack)\\n\\n![](https://www.java-family.cn/BlogImage/20230114142943.png)\\n\\n### 4.1 主要特点\\n\\nELK堆栈包含了日志管理解决方案所需的大多数工具:\\n\\n- Log shippers：如Logstash和Filebeat\\n- Elasticsearch是一个可扩展的搜索引擎\\n- Kibana作为搜索日志或构建可视化的UI\\n\\n> 关注公众号：码猿技术专栏，回复关键词：1111 获取阿里内部Java性能调优手册！\\n> \\n它在集中日志方面非常流行，有很多关于如何在网络上使用它的教程。有一个庞大的工具生态系统，您可以在基本设置之上使用这些工具，通过警报、基于角色的访问控制等来增强它。我们将在这篇博文中详细介绍这些额外的附加功能，我们将在其中讨论 Elastic Stack 功能的替代方案。\\n\\n- Elasticsearch默认情况下对每个字段进行索引，使搜索速度更快\\n- 通过API和Kibana实现实时可视化\\n- 索引前的数据解析和充实\\n\\n### 4.2 价格\\n\\n- 免费和开源。一些公司提供托管 ELK 的形式，见上文。\\n- 还有 Elastic Cloud，它是云中 ELK 的一种纯粹形式，您主要需要自己管理。\\n\\n### 4.3 优点\\n\\n- 可扩展的搜索引擎作为日志存储\\n- 成熟的log shippers\\n- Kibana 中的 Web UI 和可视化\\n\\n### 4.4 缺点\\n\\n- 在规模上，它可能变得难以维护。这就是 Sematext 提供 ELK 堆栈咨询、生产支持和培训的原因\\n- ELK Stack 的开源版本缺少一些功能，例如基于角色的访问控制和警报。您可以通过商业“Elastic Stack 功能”或其替代品或 Visa Open Distro for Elasticsearch 获得这些功能。\\n\\n## 5、Grafana Loki\\n\\nLoki 及其生态系统是 ELK 堆栈的替代方案，但它做出了不同的权衡。通过仅索引某些字段（标签），它可以具有完全不同的架构。也就是说，主要的写入组件（Ingester）会将大量日志保存在内存中，从而使最近的查询速度更快。\\n\\n随着块变老，它们被写入两个地方：用于标签的键值存储（例如 Cassandra）和用于块数据的对象存储（例如 Amazon S3）。当您添加数据时，它们都不需要后台维护（例如 Elasticsearch/Solr 需要合并）。\\n\\n如果您查询较旧的数据，您通常会按标签和时间范围进行过滤。这限制了必须从长期存储中检索的块的数量。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d403ec700424428fb8b759ce70b04ab2~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n### 5.1 主要特点\\n\\n- 同一 UI 中的日志和指标 (Grafana)\\n- Loki 标签可以与 Prometheus 标签保持一致\\n\\n### 5.2 价格\\n\\n- 免费：免费开源\\n- 收费：还有Grafana Cloud，提供Loki的SaaS服务(也有内部部署的选项)。价格从49美元起，包括100GB的日志存储(30天保留)和3000个度量系列\\n\\n### 5.3 优点\\n\\n- 与 ELK 相比，摄取速度更快：索引更少，无需合并\\n- 小存储占用：较小的索引，数据只写入一次到长期存储（通常具有内置复制）\\n- 使用更便宜的存储（例如 AWS S3）\\n\\n### 5.4 缺点\\n\\n- 与 ELK 相比，较长时间范围内的查询和分析速度较慢\\n- 与 ELK 相比，log shippers选项更少（例如 Promtail 或 Fluentd）\\n- 不如 ELK 成熟（例如更难安装）\\n\\n## 6、Datadog\\n\\nDatadog 是一种 SaaS，最初是作为监控 (APM) 工具，后来还添加了日志管理功能。您可以通过 HTTP(S) 或 syslog，通过现有的日志传送器（rsyslog、syslog-ng、Logstash 等）或通过 Datadog 自己的代理发送日志。\\n\\n它的特点是 Logging without Limits™，这是一把双刃剑：更难预测和管理成本，但您可以获得即用即付定价（见下文）以及您可以存档和从存档中恢复的事实。\\n\\n![](https://www.java-family.cn/BlogImage/20230114143006.png)\\n\\n### 6.1 主要特点\\n\\n- 用于解析和丰富日志的服务器端处理管道\\n- 自动检测常见的日志模式\\n- 可以将日志归档到 AWS/Azure/Google Cloud 存储并在以后重新使用它们\\n\\n### 6.2 价格\\n\\n- 处理起价为每月每GB 0.10 美元（例如 1GB 每天 3 美元）\\n- 处理也适用于从档案中获取，尽管这里的数据是压缩的\\n- 100 万个事件的存储起价为 1.59 美元，为期 3 天（例如，47.7 美元，1GB/天，每个 1K，存储 3 天）\\n\\n### 6.3 优点\\n\\n- 容易搜索，良好的自动完成(基于facet)\\n- 与DataDog指标和跟踪的集成\\n- 负担得起，特别是对于短期保留和/或如果你依靠存档进行一些搜索\\n\\n### 6.4 缺点\\n\\n- 现场不可用。一些用户抱怨成本失控（由于定价灵活）。虽然您可以设置每日处理配额\\n\\n## 7、Logstash\\n\\nLogstash 是一个日志收集和处理引擎，它带有各种各样的插件，使您能够轻松地从各种来源摄取数据，将其转换并转发到定义的目的地。它与 Elasticsearch 和 Kibana 一起是 Elastic Stack 的一部分，这就是为什么它最常用于将数据传送到 Elasticsearch。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef4958d15635422583158905340c2418~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n### 7.1 主要特点\\n\\n- 许多内置的输入、过滤/转换和输出插件\\n- 灵活的配置格式:您可以添加内联脚本，包括其他配置文件等\\n\\n### 7.2 价格\\n\\n- 免费开源\\n\\n### 7.3 优点\\n\\n- 容易开始和移动到复杂的配置\\n- 灵活:Logstash用于各种日志记录用例，甚至用于非日志记录数据\\n- 写得很好的文档和大量的操作指南\\n\\n### 7.4 缺点\\n\\n- 与其他日志shippers相比，资源使用率高\\n- 与替代品相比，性能较低\\n\\n## 8、Fluentd\\n\\n作为一个很好的 Logstash 替代品，Fluentd 是 DevOps 的最爱，特别是对于 Kubernetes 部署，因为它具有丰富的插件库。与 Logstash 一样，它可以将数据结构化为 JSON，并涉及日志数据处理的所有方面：收集、解析、缓冲和输出跨各种来源和目的地的数据。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/278c562e2082497b8a748a50cf077207~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n### 8.1 主要特点\\n\\n- 与库和Kubernetes的良好集成\\n- 大量的内置插件，很容易编写新的\\n\\n### 8.2 价格\\n\\n- 免费开源\\n\\n### 8.3 优点\\n\\n- 良好的性能和资源使用\\n- 良好的插件生态系统\\n- 易于使用的配置\\n- 良好的文档\\n\\n### 8.4 缺点\\n\\n- 解析前没有缓冲，可能会导致日志管道出现背压\\n- 对转换数据的支持有限，就像您可以使用 Logstash 的 mutate 过滤器或 rsyslog 的变量和模板一样\\n\\n## 9、Splunk\\n\\nSplunk 是最早的商业日志集中工具之一，也是最受欢迎的。典型的部署是本地部署 (Splunk Enterprise)，尽管它也作为服务提供 (Splunk Cloud)。您可以将日志和指标发送到 Splunk 并一起分析它们。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e27e6091b85049b4814b5d60a446e067~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n### 9.1 主要特点\\n\\n- 用于搜索和分析的强大查询语言\\n- 搜索时字段提取（在摄取时解析之外）\\n- 自动将经常访问的数据移动到快速存储，将不经常访问的数据自动移动到慢速存储\\n\\n### 9.2 价格\\n\\n- 免费：每天 500MB 数据\\n- 付费计划可应要求提供，但常见问题解答建议 1GB 的起价为 150 美元/月\\n\\n### 9.3 优点\\n\\n- 成熟且功能丰富\\n- 对于大多数用例来说，良好的数据压缩(假设有有限的索引，正如推荐的那样)\\n- 日志和度量在一个屋檐下\\n\\n### 9.4 缺点\\n\\n- 贵\\n- 对于较长的时间范围，查询速度较慢(建议使用有限的索引)\\n- 用于度量存储的效率低于专注于监控的工具\\n"
    },
    {
        "article_id": "7189531956341080124",
        "cover_image": "https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c511a17b46143b3918913762839f93d~tplv-k3u1fbpfcp-watermark.image?",
        "title": "JavaScript中的原型链",
        "brief": "概述 JavaScript 是 Web 的编程语言，简单易学，功能强大，但由于过于灵活设计理念，导致初学者经常一脸懵，本文要谈的是JavaScript中难点之一原型链。 原型链的前世 JavaScri",
        "user_name": "奇舞精选",
        "view_count": 1941,
        "collect_count": 7,
        "comment_count": 2,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/8235463c80ecb19922c8ee10c40a1ca6~300x300.image",
        "category": "前端",
        "content": "> 本文作者为奇舞团前端开发工程师\\n\\n## 概述\\n\\nJavaScript 是 Web 的编程语言，简单易学，功能强大，但由于过于灵活设计理念，导致初学者经常一脸懵，本文要谈的是JavaScript中难点之一原型链。\\n\\n## 原型链的前世\\n\\n### JavaScript的诞生\\n\\n要理解Javascript的原型链的设计思想，必须从它的诞生说起。\\n\\n1994年，网景公司（Netscape）发布了Navigator浏览器0.9版。这是历史上第一个比较成熟的网络浏览器，当时轰动一时。但是这个版本的浏览器只能用来浏览，不具备与访问者互动的能力。比如，如果网页上有一栏\\\"用户名\\\"要求填写，浏览器就无法判断访问者是否真的填写了，只能让客户端将网页全部传回服务端，让服务器端判断是否填写。如果没有填写，服务器端就返回错误，要求用户重新填写，这太浪费时间和服务器资源了。\\n\\n因此，网景公司急需一种网页脚本语言，使得浏览器可以与网页互动。工程师Brendan Eich负责开发这种新语言。他觉得，没必要设计得很复杂，这种语言只要能够完成一些简单操作就够了，比如判断用户有没有填写表单。\\n\\n1994年正是面向对象编程（object-oriented programming）最兴盛的时期，C++是当时最流行的语言，而Java语言的1.0版即将于第二年推出，Sun公司正在大肆造势。\\n\\nBrendan Eich无疑受到了影响，**Javascript里面所有的数据类型都是对象（object）** ，这一点与Java非常相似。但是，他随即就遇到了一个难题，到底要不要设计\\\"继承\\\"机制呢？\\n\\nJavaScript是一门脚本语言，是为了操作网页的，如果只将其作为简易的脚本语言，其实不需要有\\\"继承\\\"机制。但是Javascript里面都是对象，必须有一种机制，可以将对象之间关联起来。所以Brendan Eich最后还是设计了\\\"继承\\\"。\\n\\n但是他不打算引入\\\"类\\\"（class）的概念，因为一旦有了\\\"类\\\"，Javascript就是一种完整的面向对象编程语言了，这好像有点太正式了，Brendan Eich考虑到C++和Java语言都使用new命令生成实例。\\n\\nC++的写法是：\\n\\n```\\nClassName *object = new ClassName();\\n```\\n\\nJava的写法是：\\n\\n```\\nClassName object = new ClassName();\\n```\\n\\n因此，他把new命令引入了Javascript，用来从类（JavaScript中叫原型对象）生成一个实例对象。但是Javascript没有\\\"类\\\"，怎么来表示类（原型对象）呢？\\n\\n这时，他想到C++和Java使用new命令时，都会调用\\\"类\\\"的构造函数（constructor）。他就做了一个简化的设计，在Javascript语言中，new命令后面跟的不是类，而是构造函数。\\n\\n举例来说，现在有一个叫做Person的构造函数，表示人对象的原型（可以理解成java中的类）。\\n\\n```\\nfunction Person(name){\\n\\n   this.name = name;\\n\\n}\\n```\\n\\n对这个构造函数使用new，就会生成一个人对象的实例。\\n\\n```\\nvar pA = new Person('老王');\\n\\nalert(pA.name); // 老王\\n```\\n\\n注意构造函数中的***this关键字***，它就代表了新创建的实例对象。\\n\\n### prototype属性的由来\\n\\n对于面向对象编程语言比如java或者c++来说，用构造函数生成实例对象是无法共享属性和方法，都有其独立的内存区域，互不影响。\\n\\n比如，在Person对象的构造函数中，设置一个实例对象的共有属性race。\\n\\n```\\nfunction Person(name){\\n\\n    this.name = name;\\n\\n     this.race = '汉族';\\n\\n}\\n```\\n\\n然后，生成两个实例对象：\\n\\n```\\nvar pA = new Person('老王');\\nvar pB = new Person('老张');\\n```\\n\\n这两个对象的race属性是独立的，修改其中一个，不会影响到另一个。\\n\\n```\\npA.species = '苗族';\\nalert(pB.species); // 显示\\\"汉族\\\"，不受pA的影响\\n```\\n\\n每一个实例对象，都有自己的属性和方法的副本。\\n\\n按前面new运算符所述，每一个实例对象，都有自己的属性和方法的副本。但此时如果我们想在同类但不同对象间共享数据（继承）怎么办呢，解决此问题的方法就是prototype。\\n\\n考虑到共享数据的问题，Brendan Eich决定为JavaScript的构造函数设置一个prototype属性。\\n\\n这个属性包含一个对象（以下简称\\\"prototype对象\\\"），所有实例对象需要共享的属性和方法，都放在这个对象里面；那些不需要共享的属性和方法，就放在构造函数里面。这里prototype对象有点像C++基类。\\n\\n实例对象一旦创建，将自动引用prototype对象的属性和方法。也就是说，实例对象的属性和方法，分成两种，一种是本地的，另一种是引用的。\\n\\n还是以Person构造函数为例，现在用prototype属性进行改写：\\n\\n```\\nfunction Person(name){\\n\\n  this.name = name;\\n\\n}\\n\\nPerson.prototype = { race : '汉族' };\\n\\n\\nvar pA = new Person('老王');\\n\\nvar pB = new Person('老张');\\n\\n\\nalert(pA.race); // 汉族\\n\\nalert(pB.race); // 汉族\\n```\\n\\n现在，race属性放在prototype对象里，是两个实例对象共享的。只要修改了prototype对象，就会同时影响到两个实例对象。\\n\\n```\\nPerson.prototype.race = '苗族';\\nalert(pA.race); // 苗族\\nalert(pB.race); // 苗族\\n```\\n\\n综上所述，由于所有的实例对象共享同一个prototype对象，那么从外界看起来，而实例对象则好像\\\"继承\\\"了prototype对象一样。\\n\\n这就是Javascript继承机制的设计思想。\\n\\n### 重写prototype属性、方法\\n\\n用过java、c++类语言的都知道，既然有继承，必然有重写。举例说明JavaScript的重写\\n\\n```\\nPerson.prototype.hairColor = 'black';\\nPerson.prototype.eat = function(){\\n    console.log('Person eat')\\n}\\nconsole.log(pA)\\nconsole.log(pB)\\n```\\n\\n控制台输出：\\n\\n![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/40241432faf24b81926b257f563281e2~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n此时我们打印pA、pB，我们惊喜的发现，他们有了属性hairColor和eat方法；实例动态的获得了Person构造函数之后添加的属性、方法，这就是原型意义所在！**可以动态获取，这样可以节省内存。**\\n\\n另外我们还要注意：如果pA将头发染成了黄色，那么hairColor会是什么呢？\\n\\n```\\npA.hairColor = 'yellow'；\\nconsole.log(pA)\\nconsole.log(pB)\\n```\\n\\n控制台输出：\\n\\n![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/632706cbe1684c9487e897d1c60e38d2~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n可以看到，pA的hairColor = 'yellow'， 而pB的hairColor = 'black'；实例对象重写原型上继承的属性、方法，相当于 **“属性覆盖、属性屏蔽”** ，这一操作不会改变原型上的属性、方法，自然也不会改变由统一构造函数创建的其他实例，只有修改原型对象上的属性、方法，才能改变其他实例通过原型链获得的属性、方法。\\n\\n## 继承与原型链\\n\\nJavaScript 中一切皆对象。每个实例对象都有一个私有属性，称之为 **proto**，指向它的构造函数的原型对象（**prototype**）。该原型对象也有一个自己的原型对象（**proto**），层层向上直到一个对象的原型对象为 null。根据定义，null 没有原型，并作为这个**原型链**中的最后一个环节。\\n\\n- 原型链的经典图：\\n\\n![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f89a93488f404d68950fe055184866f1~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n这张图详细的描述了构造函数Function，Object以及它们实例之间的原型关系。\\n\\n**首先得记住并理解几个概念**\\n\\n1. 属性__proto__是一个对象，它有两个属性，constructor和__proto__；\\n\\n2. 原型对象prototype有一个默认的constructor属性，用于记录实例是由哪个构造函数创建；\\n\\n3. 除了Object的原型对象（Object.prototype）的__proto__指向null，其他内置函数的原型对象和自定义构造函数的原型对象的 __proto__都指向Object.prototype\\n\\n   \\n\\n```\\nObject.prototype.__proto__ === null;Array.prototype.__proto__ === Object.prototype;\\n```\\n\\n\\n\\n\\n\\n结合一张pB对象的结构图看就更容易理解了：\\n\\n![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c47c95e0c7040069a4eb9a3460bae8c~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n## 创建对象的方法\\n\\n### 使用语法结构创建\\n\\n```\\nvar p = {name: \\\"老三\\\"};\\n\\n// p 这个对象继承了 Object.prototype 上面的所有属性\\n// Object.prototype 的原型为 null\\n// 此对象原型链如下：\\n// p ---> Object.prototype ---> null\\n\\nvar arr = [1,2,3,4,5];\\n// 数组都继承于 Array.prototype\\n// 原型链如下：\\n// arr ---> Array.prototype ---> Object.prototype ---> null\\n```\\n\\n### 使用构造器创建\\n\\n在 JavaScript 中，构造器其实就是一个普通的函数。当使用 new 操作符 来作用这个函数时，它就可以被称为构造方法（构造函数）。\\n\\n```\\nfunction Animal(name,age) {\\n  this.name = name;\\n  this.age = age;\\n}\\n\\nAnimal.prototype.eat = function(){\\n    console.log('Animal eat')\\n};\\n\\nvar a = new Animal(\\\"cat\\\",1);\\n// a 是生成的对象，他的自身属性有 'name' 和 'age'。\\n// 在 a 被实例化时，a.__proto__ 指向了 Animal.prototype。\\n```\\n\\n### 使用 Object.create 创建\\n\\nECMAScript 5 中引入了一个新方法：Object.create()。可以调用这个方法来创建一个新对象。新对象的原型就是调用 create 方法时传入的第一个参数：\\n\\n```\\nvar a = {name: \\\"老三\\\"};\\n// a ---> Object.prototype ---> null\\n\\nvar b = Object.create(a);\\n// b ---> a ---> Object.prototype ---> null\\nconsole.log(b.name); // 老三 (继承而来)\\n\\nvar c = Object.create(b);\\n// c ---> b ---> a ---> Object.prototype ---> null\\n\\nvar d = Object.create(null);\\n// d ---> null\\nconsole.log(d.hasOwnProperty); // undefined，因为 d 没有继承 Object.prototype\\n```\\n\\n## class关键字\\n\\nECMAScript6 引入了一套新的关键字用来实现 class。使用java、swift等面向对象的语言的开发人员会对这些结构感到熟悉，但它们是不同的。JavaScript 仍然基于原型。这些新的关键字包括 class, constructor，static，extends 和 super。\\n\\n```\\nclass Animal {\\n  constructor(name) {\\n    this.name = name;\\n  }\\n}\\n\\nclass Person extends Animal {\\n  constructor(name,sex) {\\n    super(name);\\n    this.sex = sex;\\n    this.arrs = [1,2,3,4];\\n  }\\n  \\n}\\n\\nvar pC = new Person(\\\"老王\\\",\\\"男\\\");\\n```\\n\\n注意：类的本质还是一个函数，类就是构造函数的另一种写法，JavaScript 中并没有一个真正的 class 原始类型， class 、extends 仅仅只是对原型对象运用语法糖，这样便于程序员理解。\\n\\n```\\nfunction Person(){}\\nconsole.log(typeof Person); //function\\n\\nclass Person extends Animal {\\n  constructor(name,sex) {\\n    super(name);\\n    this.sex = sex;\\n  }\\n  get mysex() {\\n    return this.sex;\\n  }\\n  set mysex(sex) {\\n    this.sex = sex;\\n  }\\n}\\n\\nconsole.log(typeof Person); //function\\n```\\n\\n## 参考\\n\\n轻松理解JS 原型原型链 https://juejin.cn/post/6844903989088092174\\n\\nJavascript继承机制的设计思想 https://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html\\n\\n继承与原型链 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain\\n\\n"
    },
    {
        "article_id": "7187654656368050235",
        "cover_image": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be5f1f1233414076b2a27fe96449f670~tplv-k3u1fbpfcp-watermark.image?",
        "title": "如何快速创建一个稳定的开发环境",
        "brief": "现状 现在的开发模式基本是微服务开发模式，一个服务依赖N个其它服务，一个前端依赖一个N个后端，如果本地要debug的话，将会是一件非常头疼的事，常见的debug模式有以下几种： 好像也没什么问题，也可",
        "user_name": "LiuBin",
        "view_count": 6590,
        "collect_count": 19,
        "comment_count": 1,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/f2e5d2bbb52cb799312aa9c7474ecad0~300x300.image",
        "category": "开发工具",
        "content": "# 现状\\n\\n  现在的开发模式基本是`微服务`开发模式，一个服务依赖`N`个其它服务，一个`前端`依赖一个`N`个后端，如果本地要`debug`的话，将会是一件非常头疼的事，常见的`debug`模式有以下几种：\\n\\n    1. 叫相关开发人员将服务运行起来，然后连接调试\\n    2. 自己将所有代码clone下来，自己在本地运行相关服务\\n    \\n好像也没什么问题，也可以调试，但是弊端也很明显\\n\\n先说`方案1`的弊端\\n\\n> 1. 如果开发某天请假了，你没调试环境了，你还能调试吗？\\n> 2. 如果开发又加了新功能，因为功能是个半成品，不稳定，导致你依赖的接口访问不了，你还能调试吗？\\n    \\n`方案2`的弊端\\n    \\n> 1. 这个要求所有开发要熟悉整个技术栈的环境创建、编译构建相关的知识，比如：前端用的是 vue ，后端开发要安装 nodejs ，要懂一些 npm，vue 啥的，后端用的是 go，前端要安装 go ，要懂 go 的依赖安装，go 编译啥的\\n> 2. 因为有多个服务，服务间如果用了相同端口，就会有端口冲突，改了端口后，相关依赖的服务都要修改，这就要求相关开发要对整个架构、服务依赖非常了解，不然肯定非常折腾\\n\\n上述方案都只是用一些成本比较大的方式提供了一个不太稳定的开发环境\\n\\n# 几个工具\\n## docker\\n\\n要保证开发环境的稳定，就需要一个不可变的基础设施，说到不可变基础设施，肯定就要说一下`docker`了，`docker`用`镜像`解决了`PaaS`标准化的问题，将`PaaS`变成了一个不可变基础设施，这样无论我们在什么操作系统上，创建出来的实例都可以运行起来，配置一样的情况下，提供的服务也是一样的，但`docker`只保证单实例的一致性，我们的服务有N多个，如何将它们建立关联关系并运行起来呢\\n\\n## docker-compose\\n\\n`docker-compose` 可以声明一组服务，指定启动镜像、启动命令、暴露服务端口，可以很好的解决服务编排的问题\\n\\n\\n我们用以下这种服务架构为例子，为每个应用创建一个开发环境\\n\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1eae8874d60f49689c43683429edba9f~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n用 `docker` 镜像来解决服务运行环境问题，每个项目有一个`Dockerfile`、`build-dev-image.sh`文件，用`build-dev-image.sh`来构建当前分支下的代码，并`push`到`docker registry`，依赖项目只需要引用相关版本的镜像就好了\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff9088928ee247d794129a2ebab05711~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n用`docker-compose`来解决服务依赖问题，每个项目都要有一个`docker-compose.yml`文件，声明依赖服务的镜像版本，服务的端口\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/540b799e73e4454fae7276261bfbe685~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n\\n# 构建开发环境 docker 镜像\\n\\n---\\n## 前端\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d89f4ba7150e4ec1bf45232a9a0fd482~tplv-k3u1fbpfcp-watermark.image?)\\n\\n`Dockerfile` 如下：\\n\\n```Dockerfile\\nFROM nginx:1.19.2-alpine\\nCOPY ./dist /usr/share/nginx/html\\n```\\n\\n`build-dev-image.sh` 如下：\\n\\n```shell\\n#!/bin/bash\\npwdStr=`pwd`\\ndirName=${pwdStr##*/}\\nbuildTime=`date '+%Y%m%d%H%M'`\\nharborHost=\\\"docker registry domain\\\"\\nlatestTag=$harborHost/dev/${dirName}:latest\\nbuildTimeTag=$harborHost/dev/${dirName}:${buildTime}\\nharborUser=\\\"dev\\\"\\nharborPasswd=\\\"xxxx\\\"\\n\\nnpm run build\\ndocker build -t $latestTag -t $buildTimeTag .\\ndocker login $harborHost -u\\\"$harborUser\\\" -p\\\"$harborPasswd\\\"\\ndocker push $latestTag\\ndocker push $buildTimeTag\\n\\necho \\\"docker镜像名称： $latestTag\\\"\\necho \\\"docker镜像名称： $buildTimeTag\\\"\\n\\n```\\n\\n`build-dev-image.sh` 主要做了：\\n> 1. 构建 `docker` 镜像\\n> 2. `push` 到 `docker registry`\\n\\n功能开发完了，要联调了，执行一下`build-dev-image.sh`，镜像就构建好了，并 `push` 到镜像仓库了，需要的项目按需取\\n\\n这里输出了两个`tag`，一个是`latest`，一个是用`年月日`的，具体用哪个，看变更频繁度，如果很频繁就用`年月日`的，否则就用`latest`的，这样就不用老是修改`docker-compose.yml`了\\n\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93d8b915d395454db030f88311f95362~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n\\n## 后端\\n\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/488a48e593ae4148bf003a6995ec7052~tplv-k3u1fbpfcp-watermark.image?)\\n\\n`Dockerfile`\\n\\n```Dockerfile\\nFROM alpine:3.11.6\\nCOPY main /app/\\nEXPOSE 8000\\nWORKDIR /app\\nCMD [\\\"/app/main\\\"]\\n```\\n\\n`build-dev-image.sh`\\n\\n```shell\\n#!/bin/bash\\npwdStr=$(pwd)\\ndirName=${pwdStr##*/}\\nbuildTime=$(date '+%Y%m%d%H%M')\\nharborHost=\\\"docker registry domain\\\"\\nlatestTag=$harborHost/dev/${dirName}:latest\\nbuildTimeTag=$harborHost/dev/${dirName}:${buildTime}\\nharborUser=\\\"dev\\\"\\nharborPasswd=\\\"xxxx\\\"\\n\\nGOOS=linux CGO_ENABLED=0 go build -o main main.go\\ndocker build -t $latestTag -t $buildTimeTag .\\ndocker login $harborHost -u\\\"$harborUser\\\" -p\\\"$harborPasswd\\\"\\ndocker push $latestTag\\ndocker push $buildTimeTag\\n\\necho \\\"docker镜像名称： $latestTag\\\"\\necho \\\"docker镜像名称： $buildTimeTag\\\"\\n\\nrm -f main\\n```\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f8df293d77947d880a7d9634edbeb29~tplv-k3u1fbpfcp-watermark.image?)\\n\\n# 服务信息\\n\\n先看下项目信息\\n\\n```mermaid\\ngraph TD\\nexample-front --> examplea --> exampleb\\n```\\n---\\n## exampleb\\n\\n只是简单的输出一个字符串\\n\\n```\\npackage main\\n\\nimport (\\n \\\"log\\\"\\n \\\"net/http\\\"\\n)\\n\\nfunc main() {\\n http.HandleFunc(\\\"/b/api\\\", func(writer http.ResponseWriter, request *http.Request) {\\n  log.Println(request.URL.Path)\\n  writer.Write([]byte(\\\"project b\\\"))\\n })\\n http.ListenAndServe(\\\":8000\\\", nil)\\n}\\n```\\n---\\n## examplea\\n\\n调用`examplab`，并输出一个字符串\\n\\n```\\nconst (\\n // 从配置服务中取\\n PROJECT_B_DOMAIN = \\\"http://exampleb:8000\\\"\\n)\\n\\nfunc main() {\\n http.HandleFunc(\\\"/a/api\\\", func(writer http.ResponseWriter, request *http.Request) {\\n  log.Println(request.URL.Path)\\n  resp, _ := http.Get(PROJECT_B_DOMAIN + \\\"/b/api\\\")\\n  defer resp.Body.Close()\\n  result, _ := io.ReadAll(resp.Body)\\n  writer.Header().Set(\\\"Access-Control-Allow-Origin\\\", \\\"*\\\")\\n  \\n  writer.Write([]byte(\\\"project a<br/>\\\"))\\n  writer.Write(result)\\n })\\n http.ListenAndServe(\\\":8000\\\", nil)\\n}\\n```\\n\\n## example-front\\n\\n调用`examplea`\\n\\n```vue\\n<template>\\n  <div id=\\\"app\\\">\\n    <h1>\\n      Server Response: <br /><span v-html=\\\"resp\\\" style=\\\"color: red\\\"></span>\\n    </h1>\\n  </div>\\n</template>\\n<script>\\nimport axios from \\\"axios\\\";\\nexport default {\\n  name: \\\"App\\\",\\n  data() {\\n    return {\\n      resp: \\\"\\\",\\n    };\\n  },\\n  mounted() {\\n    axios.get(\\\"http://localhost:8000/a/api\\\").then((resp) => {\\n      this.resp = resp.data;\\n    });\\n  },\\n};\\n</script>\\n\\n```\\n\\n\\n# 创建开发环境\\n\\n## example-front\\n\\n`example-front`依赖`examplea`，`examplea`又依赖`exampleb`，所以我们需要两个服务，并暴露`examplea`的端口到宿主机上，供前端调用\\n\\n`docker-compose.yml` 如下：\\n\\n```docker-compose\\nversion: '3'\\nservices:\\n  examplea:\\n    image: {{docker registry domain}}/dev/examplea:latest\\n    ports:\\n      - 8000:8000\\n      \\n  exampleb:\\n    image: {{docker registry domain}}/dev/exampleb:latest\\n```\\n\\n然后运行`docker-compose up`，再执行`npm run serve`，然后打开浏览器就可以看到\\n\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/186c1833cf4b4b1ca3d1ece5ca5f0993~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n为了方便一些，我们可以直接修改 `package.json`的`scripts`，将`docker-compose up -d`加到`serve`上，这样我们直接`npm run serve` 也可以有一个开发环境\\n\\n```package.json\\n\\\"scripts\\\": {\\n    \\\"serve\\\": \\\"docker-compose up -d && vue-cli-service serve\\\",\\n    \\\"build\\\": \\\"vue-cli-service build\\\",\\n    \\\"lint\\\": \\\"vue-cli-service lint\\\"\\n  }\\n```\\n\\n## examplea \\n\\n`docker-compose.yml` 如下：\\n\\n```docker-compose\\nversion: '3'\\nservices:\\n  exampleb:\\n    image: {{docker registry domain}}/dev/exampleb:latest\\n  example-front:\\n    image: {{docker registry domain}}/dev/example-front:latest\\n    ports:\\n      - \\\"8080:80\\\"\\n  examplea:\\n    image: golang:1.19.5\\n    working_dir: \\\"/go/src/examplea\\\"\\n    # 调试模式，请制作一个包含go和delve的镜像\\n#    command: [ \\\"dlv\\\", \\\"debug\\\", \\\"--headless\\\", \\\"--listen=:2345\\\", \\\"--api-version=2\\\", \\\"--accept-multiclient\\\", \\\"main.go\\\" ]\\n    command: [ \\\"go\\\",\\\"run\\\",\\\"main.go\\\" ]\\n    volumes:\\n      - .:/go/src/examplea\\n    depends_on:\\n      - exampleb\\n      - example-front\\n    ports:\\n      - \\\"8000:8000\\\"\\n      - \\\"2345:2345\\\"\\n```\\n\\n这里为了有点区别，输出改成了`debug project a<br/>`\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4727e1ce2f4640fc83b9057114000cb7~tplv-k3u1fbpfcp-watermark.image?)\\n直接 `docker-compose up`，`example-front`将`80`映射成`8080`了，打开浏览器输入`http://localhost:8080`，\\n\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61d0e293ff9740b094cabe9003f512e0~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## exampleb\\n\\n`docker-compose.yml`如下：\\n\\n```docker-compose\\nversion: '3'\\nservices:\\n  examplea:\\n    image: {{docker registry domain}}/dev/examplea:latest\\n    ports:\\n      - \\\"8000:8000\\\"\\n  example-front:\\n    image: {{docker registry domain}}/dev/example-front:latest\\n    ports:\\n      - \\\"8080:80\\\"\\n  exampleb:\\n    image: golang:1.19.5\\n    working_dir: \\\"/go/src/exampleb\\\"\\n    # 调试模式，请制作一个包含go和delve的镜像\\n#    command: [ \\\"dlv\\\", \\\"debug\\\", \\\"--headless\\\", \\\"--listen=:2345\\\", \\\"--api-version=2\\\", \\\"--accept-multiclient\\\", \\\"main.go\\\" ]\\n    command: [ \\\"go\\\",\\\"run\\\",\\\"main.go\\\" ]\\n    volumes:\\n      - .:/go/src/exampleb\\n    depends_on:\\n      - examplea\\n      - example-front\\n    ports:\\n      - \\\"2345:2345\\\"\\n```\\n\\n这里为了有点区别，输出改成了`debug project b<br/>`\\n\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa97788bfcfa45f5a49ef727a89280bf~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63ec6464fef342eea7b217e7ec79cd80~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n# 总结\\n\\n现在各项目只需要执行一下`docker-compose up`或者`npm run serve`就可以有一个稳定的开发环境了，再也不用因为环境的问题，折腾大半天，结果还不一定能折腾出来\\n\\n---\\n\\n`go` 项目也是可以启用 `debug` 模式，只需要找一个或者自己制作一下包含`go`和`delve`的镜像，然后把`command`改成`[ \\\"dlv\\\", \\\"debug\\\", \\\"--headless\\\", \\\"--listen=:2345\\\", \\\"--api-version=2\\\", \\\"--accept-multiclient\\\", \\\"main.go\\\" ]`，并将端口用`ports`映射一下就好了 \\n\\n\\n`goland`用`Go Remote`\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a5b861d3e794a508081e5ee555e87e0~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n看到` API server listening at: [::]:2345`，点击`dubug`就OK了\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac91c78428c74260a0ad33b8548b5c1f~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/860f3ddedb19436b989018d46469319c~tplv-k3u1fbpfcp-watermark.image?)\\n\\n# 事例代码\\n[examplea](https://github.com/iroben/examplea)\\n\\n[exampleb](https://github.com/iroben/exampleb)\\n\\n[example-front](https://github.com/iroben/example-front)\\n\\n`clone`记得替换`docker-compose.yml`的`{{docker registry}}`，修改`build-dev-image.sh`中的`registry`信息"
    },
    {
        "article_id": "7189464995778789434",
        "cover_image": "",
        "title": "从0到1教你用 svelte 和 typescript 实现低代码可视化节点编程语言（一）",
        "brief": "本系列文章将全面介绍如何从零实现一个可视化节点编程语言，包含节点编程的IDE，编译器，解释器，语言内部的数据结构。通过阅读本文，读者可以更深的理解可视化编程的原理。",
        "user_name": "NicolasX",
        "view_count": 492,
        "collect_count": 2,
        "comment_count": 0,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/695cb7de03b8ccdd7ca9314218ac9499~300x300.image",
        "category": "前端",
        "content": "# 引言\\n本系列文章将全面介绍如何从零实现一个可视化节点编程语言，包含节点编程的IDE，编译器，解释器，语言内部的数据结构。通过阅读本文，读者可以更深的理解可视化编程的原理。如果是希望在自己的系统中集成可视化编程语言，也可以从本文获得有价值的信息。\\n\\n# 1 可视化编程语言简介\\n\\n可视化编程语言是通过图形化的符号及它们的连接等图形表达方式来描述数据和逻辑的的编程语言。\\n\\n相对的，我们通常的编程语言，是通过文本的方式表达数据和逻辑。\\n\\n目前编程领域，文本形式的编程语言占据主导地位。不过在一些特定领域里，比如艺术创作领域的软件，游戏设计领域，电路设计领域，自动化等，可视化编程却占据主导的地位。\\n\\n还有一些非严谨用途的领域，比如教育，可视化编程也是占据了主导地位，代表作有 MIT 的scratch。\\n\\n可视化编程语言按照表达的方式可以分为两类：\\n\\n一类是通过拼图的方式，把逻辑块按顺序拼接在一起，代表语言有 MIT scratch和 google blockly\\n\\n\\n![image001.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb94b7f94ba043d4b882db83df12868b~tplv-k3u1fbpfcp-watermark.image?)\\n\\n<p align=center>scratch</p>\\n\\n\\n![image003.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5cc118c0f3f94220933a83ef587fd30f~tplv-k3u1fbpfcp-watermark.image?)\\n\\n<p align=center>blockly</p>\\n\\n\\n\\n另一类是基于节点的可视化编程语言，这个类型的产品比较多，也覆盖了很多领域\\n\\n比如游戏领域，虚幻引擎的 blueprints\\n\\n\\n![image005.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6faf04cbac3b42dcbadcae212e6e3307~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n比如设计领域，三维建模软件 blender 的 nodes\\n\\n\\n\\n![image007.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c4fb48c3ab044506a6036c45476f8caf~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n影视特效软件 houdini\\n\\n\\n![image009.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0422f2f7c9414fd7ad7ff313b2f921c8~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n## 历史\\n\\n可视化编程语言的诞生可以追溯到上个世纪6~70年代。\\n\\n如1968年的 GRaIL\\n\\n\\n![image011.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8804f2d6c5a54f48ba1d20e4c95e5acd~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n<p align=center>GRaIL 1968</p>\\n\\n1975年的Pygmalion：\\n\\n\\n![image013.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a715a2cf7f64aeeac17f9f3f68da526~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n## 优势\\n\\n### 简单直观\\n\\n可视化编程语言一般面向非专业编程领域的人，用于特定领域的逻辑开发。这些用户通常是某个领域的专家，但他们不擅长编程。所以需要提供一种对于他们很直观容易学习使用的方式来设计逻辑，可视化编程就是最好的选择。直观的功能模块，配合功能模块之间的连线，就能表达一定的逻辑。比如多媒体设计的用户一般都是艺术家，他们一般都缺乏编程领域的知识，也不太可能让他们去深入了解编程。再比如，游戏设计，也是类似的情形，在游戏设计的初期，需要快速的进行原型设计，这部分工作一般由游戏策划来完成。在儿童编程教育领域，可视化编程的简单直观，也被作为儿童编程的启蒙工具。\\n\\n### 可配置化\\n\\n每一个可视化节点，都可以有数字输入，选项选择等UI交互，通过改变输入，可以方便的调整逻辑。对于艺术设计这类需要反复调整参数，实时查看效果的场景，就很适合了。在游戏设计领域也有类似的述求。\\n\\n### 丰富的领域能力\\n\\n通常可视化编程语言都是集成在某个特定领域的系统中，供专业人员使用。为了帮助专业人员快速实现功能，可视化编程语言都会集成大量与领域相关的功能模块。这也符合可视化编程语言的初衷，就是为了降低门槛，提升效率。\\n\\n## 缺点\\n\\n### 可扩展性差\\n\\n可视化编程语言由于是基于图形化的块和连线，随着要表达的逻辑的规模变得复杂，所需要的块和连线也会变多，错综复杂。所以其不适合复杂的逻辑开发。\\n\\n### 灵活性差\\n\\n由于可视化编程需要直观简单的呈现，所以其图元不可能设计得很复杂，很灵活，不然会增加使用的难度。但也因为这样，造成了可视化编程不如文本编程灵活。\\n\\n### 不利于版本管理\\n\\n现在的版本管理系统，如 git 等都是基于文本比较的方式进行版本管理，文本天生有版本管理的优势。而可视化编程语言保存的方式是一堆块和线进行序列化后的数据，这些数据很难从字面上理解其意思，虽然也可以用 git 进行版本管理，但其版本比较所展示的差异，会比较难以辨认。\\n\\n\\n# 2 VL 节点编程语言的实现\\n\\n前面大致介绍了可视化编程语言的基本情况。\\n\\n本文着重要实现的是基于节点的可视化编程语言。我们暂且将其命名为 VL 节点编程语言。 VL 代表的是 Visual Language。\\n\\nVL 从虚幻引擎的 blueprints 借鉴了语法表达方式，从 blender nodes 借鉴了样式。\\n\\n之所以从 blueprints 借鉴了语法，是因为 blueprints 在游戏开发领域广泛应用，并且被普遍认可，目前有不少 3A游戏大作都采用了 blueprints 作为部分功能的开发语言。借鉴一款被认可的语言，让 VL 更加具有价值。\\n\\n样式借鉴了 blender nodes 属于笔者个人的喜好。\\n\\nVL 节点编程语言最终的实现效果如下：\\n\\n\\n![image015.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f579be53d0a94a70823cc90617124aa1~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n## 2.1 整体架构\\n\\n\\n![image017.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/27be6caacb1447b6bca0edf707ba0d8b~tplv-k3u1fbpfcp-watermark.image?)\\n\\nVL 语言系统分为4个主要模块，分别是：\\n\\n可视化节点编辑器：\\n\\n编辑器提供可视化编程的操作：包含了节点的创建，移动，连接，修改节点输入输出等操作\\n\\n节点编译器：\\n\\n通过编辑器绘制的逻辑表达，并不能直接作为解释器的输入，需要经过一轮转换让其成为抽象语法树（AST）\\n\\n节点解释器：\\n\\n领域功能函数：\\n\\n## 2.2 技术选型\\n\\nVL 的编辑器使用 svelte + typescript 的技术栈编写而成。\\n\\n由于 VL 是运行在浏览器上，所以 VL 的编译器和运行时，都采用了 typescript 来编写。\\n\\n## 2.3 语法的设计\\n\\nVL 语言是定位为通用编程语言，所以其语法与我们常见的文本编程语言类似。同样包含了流程控制语句，运算符，变量的取值和赋值等。\\n\\n但节点编程语言与文本编程语言有差异的时，节点编程需要用事件来驱动程序的执行，所以 VL 语言也有一系列事件语句。\\n\\n### 2.3.1 节点的结构\\n\\n\\n![image019.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f7a40cadfaf24235bf149ec0cfaeb392~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n每个节点由5个部分组成：\\n\\n- 节点名：表示节点的功能\\n\\n\\n- 流程端口（链接上一个节点）：用于连接上一个语句节点\\n\\n\\n- 流程端口（链接下一个节点）：用于连接下一个语句节点，逻辑将沿着连线执行\\n\\n\\n- 输入端口：类似于函数的入参，可以通过把计算值的节点连接到输入端口，实现值的输入\\n\\n\\n- 输出端口：类似于函数的返回值，可以将输出端口连接到其他节点的输入端口。输出端口也可以用作流程端口，通常出现在流程控制节点上，用于处理多逻辑分支。比如 if 节点，可以有两个分支，truePart 和 falsePart，truePart连接到条件为真的流程的首个节点，同理，falsePart 连接到条件为假的流程的首个节点。\\n\\n### 2.3.2 事件语句\\n\\nbegin 语句：程序逻辑的开始，解释器会找到 begin，并从 begin 开始执行程序。\\n\\n\\n![image021.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/26b42e51190348b091be82f9ffe27781~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n### 2.3.3 变量\\n\\nset value 语句：用于为一个变量赋值。在 VL 里，不需要对变量进行声明，首次赋值相当于一次声明和初始化。\\n\\n\\n![image023.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/580337fb483b46f78e7ec7b771e0ccaa~tplv-k3u1fbpfcp-watermark.image?)\\n\\nget value 语句：负责取得变量的值。\\n\\n\\n![image025.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ec30dd3c98aa448aade604c809ae7fdf~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n\\nconstant：用于定义常量。可以输入字符串，数字等。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8191fed896b04124b7f2ca6ca9e889ee~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n### 2.3.4 运算\\n\\nVL 目前运算包含两种类型：四则运算和比较运算\\n\\nadd 语句：用于计算两个数字的和，类似的节点还有 sub（减法），mul（乘法）， div（除法）， mod（取余） 等语句。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b339f979a4dc41368a95d46050eaaa8c~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n> 语句：用于比较两数的大于关系，类似的节点还有 >=, <, <=, ==, != 等。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/23ccad5282924e6e9e877490b358cfe6~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n### 2.3.5 流程控制语句\\n\\nif node 语句：用于处理判断逻辑，condition 节点连接判断条件节点，接收判断条件的值。\\n\\ntruePart节点连接条件为真的流程， falsePart节点连接条件为假的流程。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/28c5c64c16e44865828ffdaf72e4795b~tplv-k3u1fbpfcp-zoom-1.image)\\n\\nwhile node 语句：用于迭代逻辑，condition 节点连接判断迭代条件节点，loop节点连接循环体\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8be1d58c0e4d4381ba28204cc0bc9fc6~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n### 2.3.6 函数库\\n\\n函数库节点是一系列 VL 语言内置的函数，可以处理数学，绘制图形，输出等功能。\\n\\n这里拿 print 函数做示范：\\n\\nmessage 是 print 的输入端口，用于提供打印的文本\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/62fa1ae3763746e2a4684b4ccd540593~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n## 2.4 数据结构的定义\\n\\n可视化节点语言最核心的数据结构是节点\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/255fbc3ea7544477b29085d1cc235462~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n前文已经详细讲解了节点的图形化表达方式，如图所示。\\n\\n笔者为节点定义了两种数据结构，分别对应于显示在编辑器的节点，及处在运行时的节点。\\n\\n### 2.4.1 编辑器节点定义\\n\\n在编辑器显示的节点，除了需要显示其节点名称，端口名称，还需要端口的连接，及节点的位置，所以可以定义如下的数据结构表示：\\n\\n```typescript\\n// 端口的定义\\nexport type IPort = {\\n  // 端口的名称\\n  name: string;\\n  // 端口往外连接的另一个端口的ID\\n  toPort?: string;\\n  // 端口被连接的另一个端口ID\\n  fromPort?: string;\\n  // 端口的附加数据，通常用于携带端口的输入\\n  data?: string;\\n}\\n\\n// 编辑器节点\\nexport type INode = {\\n  // 节点ID\\n  id: string;\\n  // 节点名称\\n  title: string;\\n  // 输入端口\\n  inPorts: IPort[];\\n  // 输出端口\\n  outPorts: IPort[];\\n  // 节点坐标\\n  x: number;\\n  y: number;\\n}\\n```\\n\\n数据结构的关联关系可以看下图所示\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c4f7abb6f6d452b99557271b834507c~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n每个节点都有两个数组分别保存节点的输入端口和输出端口。\\n\\n两个端口的连接，通过 fromPort 和 toPort 两个字段进行关联，起点端口的 toPort 会指向结点端口，而结点端口 的 fromPort 会指向起点端口。\\n\\n端口的 data 字段用于记录端口的值，通常当端口不通过连接其他节点来获取输入时，可通过输入框获取值，而该值会被保存到 data 字段中。\\n\\n### 2.4.2 运行时节点\\n\\n运行时的节点与编辑器节点一一对应。运行时节点其实就是抽象语法树（AST）节点，它代表 VL 的语义关系。\\n\\n运行时节点的结构更为紧凑，相较于编辑器节点，运行时节点不需要下面的信息：\\n\\n- 节点坐标：坐标信息\\n\\n\\n- 端口信息：端口信息会在编译过程被转换成节点间的关联关系\\n\\n数据结构定义如下：\\n\\n```typescript\\n// 运行时节点\\nexport class IAstNode {\\n  // 节点指令\\n  command: string;\\n  // 指向编辑器节点，用于可视化调试\\n  sourceId?: string;\\n  // 指向流程的下一个节点\\n  nextNode?: IAstNode;\\n  // 指向其他节点，具体的语义随节点指令变化\\n  nodes: IAstNode[];\\n  // 节点数据，与编辑器节点的输入框数据关联\\n  data?: string;\\n}\\n```\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c9b8e00dde24c759e6656c93ae828ca~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n## 2.5 编辑器的实现-画一个程序出来\\n\\n实现节点编辑器，主要是实现下面的功能：\\n\\n- 节点的绘制和拖拽\\n- 端口的连接及连线的绘制\\n\\n\\n### 2.5.1 节点的绘制\\n\\n笔者采用的是 svelte 来开发编辑器，所以节点的绘制，可以通过声明式的模板方式来编写：\\n\\n```\\n<div\\n  class=\\\"node\\\">\\n  <div id={node.id} class=\\\"title\\\">\\n    {node.title}\\n  </div>\\n  <div class=\\\"ports\\\">\\n    <div class=\\\"in-ports\\\">\\n      {#each node.inPorts as port}\\n        <Port name={port.name} nodeId={node.id} />\\n      {/each}\\n    </div>\\n    <div class=\\\"out-ports\\\">\\n      {#each node.outPorts as port}\\n        <Port name={port.name} isOut={true} nodeId={node.id} />\\n      {/each}\\n    </div>\\n  </div>\\n</div>\\n```\\n\\n每一个编辑器节点都会有一个唯一节点ID（node.id）,每一个端口同样也有一个端口ID（port.name）。\\n\\n节点ID和端口ID是实现节点的拖拽的关键，不仅起到识别具体节点的作用，也可以用来区分鼠标拖拽在节点和端口上的不同行为。比如，节点上的拖拽，会使节点发生位移，而对端口的拖拽则是用于连线。\\n\\n### 2.5.2 节点的拖拽\\n\\n节点的拖拽这里采用鼠标的 mousedown, mousemove, mouseup 事件配合实现。\\n\\n其实也可以使用 html 的 draggable， dragstart 等事件实现，但这里为了实现实时拖拽效果，选择了通过鼠标基础事件自行实现拖拽。\\n\\n拖拽的实现逻辑如下：\\n\\n- 当鼠标按下时，判断当前的图形元素是否为节点\\n\\n\\n- 如果是节点，标记当前状态为拖拽中（即 dragging = true），并记录当前移动的节点\\n\\n\\n  - 鼠标移动时，如果状态为拖拽中，根据鼠标移动偏移量，更新节点的坐标（抛出拖拽事件，通知逻辑层根据节点ID和坐标偏移量，更新对应的节点坐标）\\n\\n\\n- 当鼠标释放时，清除拖拽状态（即 dragging = false）\\n\\n鼠标按下：\\n\\n```\\nconst handleMouseDown = (e) => {\\n  // 判断当前图形是否为节点，即 id 符合 node-{num} 这样的规则\\n  if (/^node-\\\\d+$/.test(e?.target?.id)) {\\n    // 标记当前正在拖拽\\n    dragging = true;\\n    // 标记当前移动的节点\\n    movingNode = e.target.id;\\n    return;\\n  }\\n};\\n```\\n\\n鼠标移动：\\n\\n```\\nconst handleMouseMove = (e) => {\\n  // 只有在拖拽状态下，才通知节点移动\\n  if (dragging) {\\n    // 使用 svelte 的事件通知，往父级组件抛出拖拽事件\\n    dispatch(\\\"command\\\", {\\n      cmd: \\\"move\\\",\\n      id: movingNode,\\n      movementX: e.movementX,\\n      movementY: e.movementY,\\n    });\\n  }\\n};\\n```\\n\\n鼠标释放：\\n\\n```\\nconst handleMouseUp = (e) => {\\n  // 清除拖拽状态\\n  dragging = false;\\n};\\n```\\n\\n### 2.5.3 端口的连接\\n\\n端口的连接，使用的机制，与节点拖拽类似，也是响应鼠标按下，移动，释放。\\n\\n区别是，端口连接需要额外处理拖拽过程中临时连线的状态（当用户未将连线连接到另一个端口时，需要展示一条临时的连线）\\n\\n并且，连线中的数据结构，与连线完成的数据结构，是不同的。\\n\\n因为连线中，我们并不清楚另一端的端口，所以最好是记录连线两端的坐标，如下所示\\n\\n```\\nexport type IPoint = {\\n  x: number;\\n  y: number;\\n}\\n\\nexport type IEdge = {\\n  start: IPoint;\\n  end: IPoint;\\n}\\n```\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a0eedb929a447e597e2d056ab75606a~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n而连线完成时，两个端口的信息已知，我们只需要知道端口的连接信息（通过 fromPort, toPort）即可计算出连线。\\n\\n```\\nexport type IPort = {\\n  name: string;\\n  // 指向另一个端口\\n  toPort?: string;\\n  // 指向另一个端口\\n  fromPort?: string;\\n  data?: string;\\n}\\n```\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f8fe1ea0fb9f4a72b12061ea6a6e3aaa~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n连线的逻辑实现如下：\\n\\n- 当鼠标按下时，判断是否为一个端口\\n\\n\\n- 如果是一个端口，设置连线状态 （editingEdge = true）\\n\\n\\n- 当鼠标移动时，如果当前状态为连线状态，获取当前坐标作为连线的终点坐标，并同时逻辑层绘制一条连线\\n\\n\\n- 当鼠标释放时，如果不是一个端口，清除连线状态，销毁临时连线\\n\\n\\n- 当鼠标释放时，如果是一个端口，获取端口信息，与起始端口一起发起端口连接操作\\n\\n\\n- 端口连接操作，首先需要对端口的顺序进行排序，连线方向必须是从输出端口到输入端口，然后发送事件到逻辑层添加端口的关联信息\\n\\n\\n### 2.5.4 连线的绘制\\n\\n连线是使用贝塞尔曲线绘制的，通常在网页端绘制曲线，可以使用 canvas 或者 svg。\\n\\n这里选用的是 svg。svg 声明式的风格，结合 svelte 模板更加和谐。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/145e604eced34cd3b6be2a6f3a3fe461~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n代码如下：\\n\\nedge.svelte\\n\\n```html\\n<script lang=\\\"ts\\\">\\n  export let start: IPoint;\\n  export let end: IPoint;\\n\\n  let d = \\\"\\\";\\n  $: {\\n    let midX = start.x + Math.round((end.x - start.x) / 2);\\n    const { x: x0, y: y0 } = start;\\n    const { x: x1, y: y1 } = end;\\n    d = `M${x0} ${y0} C${midX} ${y0} ${midX} ${y1} ${x1} ${y1}`;\\n  }\\n</script>\\n\\n<path {d} stroke=\\\"white\\\" stroke-width=\\\"2\\\" fill=\\\"transparent\\\" />\\n```\\n\\n根据 edge 组件的入参起点坐标 start 和终点坐标 end，计算出中点，从而计算出两个贝塞尔控制点，通过这四个坐标可以绘制出一条圆滑的贝塞尔曲线。\\n\\n## 2.6 编译器的实现-转换成 AST\\n\\n### 2.6.1 为何需要编译\\n\\n其实我们完成了编辑器的实现后，基本具备了 VL 语言的可视化编辑功能，同时我们也具备了节点需要运行的所有信息，按理说，可以开始编写 VL 的运行时，让它跑起来。\\n\\n但实际上距离运行时还差一步，我们需要编译过程。\\n\\n为何还需要编译，主要是因为前面定义的编辑器节点的数据结构，使用在运行时存在一些缺点，会导致运行时不够高效，比如：冗余的信息（坐标，端口），连接信息更适合用于可视化绘制，而不适合用于运行时，每个端口查找下一个节点，需要先查找下一个端口，在查找其所在的节点。\\n\\n所以需要通过编译，把编辑器节点转换为 AST 节点：\\n\\n- 去除冗余的信息（坐标，端口）\\n\\n- 转换端口连接为 AST 节点的连接，赋予语法属性，比如哪些是流程的下一个节点，哪些是输入节点，哪些是分支节点等\\n\\n### 2.6.1 编译流程\\n\\n编译的流程如下：\\n\\n- 查找 begin 节点，作为第一个编译的节点\\n- 开始编译 begin 节点，获取 begin 节点指向的下一个节点，开始编译下一个节点，并把编译后的 AST 节点关联到 begin AST 节点的 nextNode 字段\\n- 编译一个常规节点时\\n  - 获取其输入节点，先编译成 AST，再放入当前节点 AST 的 nodes 中\\n  - 查找下一个节点，编译后设置到当前 AST 的 nextNode 中\\n  - 设置 sourceId 关联到编辑器节点，方便调试时可视化显示\\n- 直到编译某个节点时，查找不到下一个节点，编译过程结束\\n\\nAST 的关联：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/24858ec2278b4e63a7a105dcfe970c95~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n开始编译：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/686623c756034419b3e384cd9b53ea8a~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n编译节点：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/846e66bbbf3946599a1e6188d575e2aa~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n### 2.6.3 if node 的编译\\n\\n下面以 if node 为例讲解编译的流程\\n\\nif node 总共有 4 个需要处理的节点，分别是：\\n\\n- condition 节点：用于计算条件的值，从而决定接下来的分支是走 true 分支还是 false 分支\\n\\n- true 节点：当条件计算为 true 时，需要跳转的流程节点\\n\\n- false 节点：当条件计算为 false 时，需要跳转的流程节点\\n\\n- next 节点：if 节点包含其 true 逻辑分支或者 false 逻辑分支都执行完之后要继续执行的流程\\n\\n如何对这些节点进行处理并输出 if AST 节点的流程如下所示：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/75af9577e71d4a9f8faf5a9159dbbb59~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n编译后的 AST 结构如下：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ff65963da154dff98541cd7c7342f8a~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n## 2.7 运行时的实现-让它跑起来\\n\\n### 2.7.1 运行机制\\n\\n我们已经完成编译步骤，并且得到 AST 树。\\n\\n如果读者熟悉编译原理，下一步应该会是需要遍历 AST 进行中间代码的输出。\\n\\n但 VL 不这么做，节点编程语言一般不会用在计算密集的任务，所以没必要生成中间代码。\\n\\n可以直接遍历 AST 执行（早期的 ruby 解释器也是这么实现的）\\n\\n### 2.7.2 AST 节点类型\\n\\nAST 节点可以分为两类：\\n\\n- 语句节点：用于函数调用，流程控制\\n\\n- 计算节点：用于值的计算\\n\\n### 2.7.3 语句节点的执行\\n\\n通过编译，我们可以获得一个从 begin 开始构建的 AST 语法树，所以执行的过程，应该是：\\n\\n- 从 begin 节点开始，先执行当前节点的逻辑\\n\\n- 完成后，通过 nextNode 跳转到下一个节点，继续执行\\n\\n- 直到 nextNode 为空时，程序结束。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1b0db8443db427998dc0fae544a1bb1~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n代码如下：\\n\\n```typescript\\nasync function run(ctx: Record<string, any>, ast: IAstNode) {\\n  let cur: IAstNode | undefined = ast;\\n  while (cur) {\\n    switch (cur.command) {\\n      case Command.SetValue:\\n         // process set value\\n        break;\\n\\n      case Command.IfNode:\\n        // process if node\\n        break;\\n      case Command.WhileNode:\\n        // process while node\\n        break;\\n      ...\\n    }\\n    cur = cur.nextNode;\\n  }\\n}\\n```\\n\\n### 2.7.4 计算节点的执行\\n\\n计算节点通常是被动执行，而不是流程中的一个环节。\\n\\n计算节点有四则运算，数值比较等。\\n\\n为何它是被动执行的，举个例子，当 if 节点要知道 codition 的值是多少时，这时候就需要拿到 condition 指向的计算节点，并对计算节点进行求值，再用这个值来决定接下来的流程。\\n\\n计算节点的运行代码如下：\\n\\n```typescript\\nfunction evalNode(ctx: Record<string, any>, ast: IAstNode): Promise<string | boolean | number | undefined> {\\n    switch (ast.command) {\\n      case Command.GetValue:\\n        {\\n          const varName = ast.data!;\\n          return ctx[varName];\\n        }\\n      case Command.Constant:\\n        return ast.data\\n      case Command.Add:\\n        {\\n          const [n1, n2] = ast.nodes;\\n          const v1 = evalNode(ctx, n1!);\\n          const v2 = evalNode(ctx, n2!);\\n          return (Number(v1) + Number(v2))\\n        }\\n      case Command.Sub:\\n        ...\\n      case Command.Mul:\\n        ...\\n      case Command.Div:\\n        ...\\n      case Command.Mod:\\n        ...\\n      case Command.GT:\\n        ...\\n      case Command.GE:\\n        ...\\n      case Command.LT:\\n        ...\\n      case Command.LE:\\n        ...\\n      case Command.Equal:\\n        ...\\n      case Command.NotEqual:\\n        ...\\n    }\\n}\\n```\\n\\nadd 节点取值过程：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/121da060c7b14bd59aecb7e9c79c6970~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n# 3 写点 Demo 试试\\n\\n让我们来编写一些现实中的程序试试 VL 可视化编程语言的能力吧。\\n\\n## 3.1 Hello, World\\n\\n不可避免的 Hello，World\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/594d3c835e7d41998ba2ed38d71042a7~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n运行结果：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7005559aa2e94c69bcda868ea209eed9~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n成功打印出“Hello, Wrold\\\"\\n\\n## 3.2 计算阶乘\\n\\n### 待补充\\n\\n## 3.3 旋转的方块\\n\\n### 待补充\\n\\n# 4 总结\\n\\n至此，我们完成了一个简单的可视化节点编程语言，它具备了节点的可视化编程，编译，运行等基本功能，但距离一个完整的可视化节点编程语言，还缺少了可视化调试，函数定义，FFI，面向对象等功能，只有添加这些功能，才能让其更具实用性。这些功能将留在《从0到1教你用 svelte 和 typescript 实现低代码可视化节点编程语言（二）》里为大家奉上。\\n\\n# 未完待续。。。\\n\\n快过年了，正好有些摸鱼的时间把本系列第二篇文章的内容和其他陈年的技术文章整理一下（摸鱼ing\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n"
    },
    {
        "article_id": "7189823020058279996",
        "cover_image": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/968464cd23ef4aafb2c1004f0d1e32fa~tplv-k3u1fbpfcp-watermark.image?",
        "title": "Nest实战 - 员工模块",
        "brief": "前言 本系列主要通过实现一个后台管理系统作为切入点，帮助掘友熟悉nest的开发套路 本系列作为前后端分离项目，主要讲解nest相关知识，前端项目知识一笔带过 完整的示例代码在最后",
        "user_name": "TYF",
        "view_count": 1502,
        "collect_count": 3,
        "comment_count": 0,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/7c62eb02a8a86feb837c9ea4c3f14ca6~300x300.image",
        "category": "前端",
        "content": "## 前言\\n本系列主要通过实现一个后台管理系统作为切入点，帮助掘友熟悉`nest`的开发套路\\n\\n本系列作为前后端分离项目，主要讲解`nest`相关知识，前端项目知识`一笔带过`\\n\\n完整的示例代码在最后\\n\\n本章属于实战系列第二章，主要讲解员工模块相关内容，包括\\n\\n-   头像上传`本地文件上传`和`阿里oss文件上传`\\n-   头像识别`百度AI识别图像`，部分数据完成`自动填充`\\n-   typeORM 公共字段填充`@BeforeInsert`和`@BeforeUpdate`的使用和注意事项\\n-   扩展 `process.env` 的类型\\n-   数据库相关知识`In` `Like` `分页`\\n-   `Restful`风格的代码开发\\n-   密码`md5` 处理\\n\\n  \\n\\n\\n## 技术栈\\n\\n-   node：19.x\\n-   后端：nest + mysql\\n-   前端：react + redux + antd\\n## 规则\\n- 本系列完全遵循`RestFul`风格进行开发，即`Get` `Post` `Put` `Delete`\\n- 本系列的调用链 `controller`  --> `service` --> `三方服务` ｜ `数据库`\\n- 本系列的三方服务被`消费`时，统一注入到`nest`的`IOC`中，统一风格；其他函数的使用直接调用即可\\n## 员工模块-分页\\n### 介绍\\n- 在本人目前的开发中，分页功能是最常见的功能\\n- 好处\\n    - 服务端： 提升性能，减小内存的压力，查询效率高\\n    - 客户端： 页面渲染快，不然几万个DOM同时`渲染，更改`，页面直接GG\\n### 页面预览\\n- ![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da05d6ad4d8e4ecb838a4891cb624f86~tplv-k3u1fbpfcp-watermark.image?)\\n- ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ee596a172b04f2b8c0a93eef204b153~tplv-k3u1fbpfcp-watermark.image?)\\n- ![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/44f81ce89a8d4ad3a3da6990e7401cbe~tplv-k3u1fbpfcp-watermark.image?)\\n- ![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/993106c33b0e438985dca1cf4aa463d8~tplv-k3u1fbpfcp-watermark.image?)\\n- ![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c83192edc487451184578f740ec33d7d~tplv-k3u1fbpfcp-watermark.image?)\\n### 开发- controller\\n#### 代码\\n- 打开 `EmployeeController`，加入以下代码\\n    ```\\n      @ApiOperation({\\n        summary: '分页',\\n      })\\n      @Get('page')\\n      page(\\n        @Query('page') page: number,\\n        @Query('pageSize') pageSize: number,\\n        @Query('name') name?: string,\\n      ) {\\n        return this.employeeService.page(page, pageSize, name);\\n      }\\n    ```\\n#### 说明\\n- 正常来说，`nest`接收到的所有基本类型的参数类型都是`string`，上一章我们在`AppModule`中加入了全局管道验证，并设置了属性转换功能`transform`为`true`，这样`nest`内部就可以通过`ts`的类型自动转换了\\n    ![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0cc0834a634443f2b625524a020aba73~tplv-k3u1fbpfcp-watermark.image?)\\n    喏，就是这块做的`自动转换`\\n- `@Query装饰器`可以拿到`url`问号（？）后边的参数值\\n- `page`当前页数，最少传`1`\\n- `pageSize` 每页多少条\\n- `name` 用户名，做模糊查询用\\n- 接下来就把接收到的参数传入`EmployeeService`的`page`方法中\\n### 开发- service\\n#### 代码\\n- 打开`EmployeeService`，加入`分页代码`\\n    ```\\n      /**\\n       *\\n       * @param page 页数\\n       * @param pageSize 每页多少条\\n       * @param name 用户名\\n       * @returns 分页\\n       */\\n      async page(page: number, pageSize: number, name = '') {\\n        const [employeeList, total] = await this.employeeRepository.findAndCount({\\n          where: {\\n            name: Like(`%${name}%`),\\n          },\\n          skip: (page - 1) * pageSize,\\n          take: pageSize,\\n        });\\n\\n        return new BasePage(page, pageSize, total, employeeList);\\n      }\\n    ```\\n#### 说明\\n- 上一章中注入了`employeeRepository`，所以这里可以直接调用\\n    ![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf3c455192ad4dd8a30cfd4e35ad125d~tplv-k3u1fbpfcp-watermark.image?)\\n- `employeeRepository.findAndCount`方法返回一个`promise数组`，数组的`第0项`是查询到的对象数组，`第1项`是符合当前条件的总条数\\n- `name`字段默认`空字符串 ''`,不然会被当作`undefind`处理\\n- `where` 中的 `Like` 等同于 `sql` 语句中的 `Like`,`Like(`%${name}%`)`表示`值左右`模糊查询\\n- `skip`表示跳过多少条数据\\n- `take` 表示查询多少条数据，即`(每页多少条)`\\n- `skip` 和`take`对应`sql`中的`LIMIT`关键字\\n- 执行查询操作时，`sql`语句如下所示\\n    ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7dd0426f751b4296b017b809b0d8d3f2~tplv-k3u1fbpfcp-watermark.image?)\\n- 共执行了俩次`sql`语句`第一句`查询列表信息，`第二句`查询总条数\\n- 注意在`第一条sql`语句中，有排序查询\\n    ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bdc35d41398849e4a5bdb2cf2b86ec00~tplv-k3u1fbpfcp-watermark.image?)\\n- `orderBy`关键字，是通过添加到实体类`Employee`文件`Entity装饰器`中实现的，这样只要执行`select`语句的时候,在没有手动添加`updateTime`排序规则的时候，就总会按照`updateTime`的倒序进行排序\\n    ![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e2f19f3014841cebcd57b8d64284b44~tplv-k3u1fbpfcp-watermark.image?)\\n- `page`方法中最后返回了类`BasePage`，`BasePage`只做了一件事情，就是对分页数据进行封装\\n### 开发工具类 - 封装分页数据\\n#### 代码\\n- 新建 `src/common/database/pageInfo.ts`，写入\\n    ```\\n    /**\\n     * 分页数据封装\\n     */\\n    export class BasePage<T> {\\n      constructor(\\n        private page: number,\\n        private pageSize: number,\\n        private total: number,\\n        private records: T[],\\n      ) {}\\n    }\\n\\n    ```\\n#### 说明\\n- 分页数据每个模块都会使用，故进行封装，统一调用即可\\n### 前端开发 - 拦截器处理\\n- ![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e16d22505bf446cb81e52614afbc37d0~tplv-k3u1fbpfcp-watermark.image?)\\n#### 说明\\n- 我们在登陆接口进行了`jwt验证`，故没有添加`@isPublic()装饰器`的接口都需要进行`token`验证\\n- 我们会在登陆页面点击`登陆`的时候,把员工数据写入`redux`中\\n    ![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e2139765072471d97547b6925ec81b0~tplv-k3u1fbpfcp-watermark.image?)\\n- 前端主要注意`拦截器处理`，其他的正常开发即可\\n#### 前端分页 - 效果截图\\n- 全量搜索\\n    ![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ac9aaca6489461793bfbaef094f726b~tplv-k3u1fbpfcp-watermark.image?)\\n- 模糊搜索\\n    ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/349a46fece5648dab0922a1cb8ca5284~tplv-k3u1fbpfcp-watermark.image?)\\n    \\n## 公共模块 - 文件上传/预览\\n### 介绍\\n- 文件上传下载功能比较通用，且为了遵循软件的`单一原则`，所以把它抽离成`基础公共模块`\\n- 如果所示，我们会在`新增` `修改`时使用文件`上传 预览`功能\\n    ![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22a0e036698345a480cf24f80c778674~tplv-k3u1fbpfcp-watermark.image?)\\n### 本地文件上传\\n#### 安装\\n- 安装`@types/multer`提供`ts`类型支持\\n    ```\\n    yarn add @types/multer\\n    ```\\n#### 代码\\n- 终端中执行\\n    ```\\n    nest g module base\\n    nest g service base\\n    nest g controller base\\n    ```\\n- 会生成以下结构文件，当然手动创建也可以，`注意⚠️`手动创建的模块需要`手动引入`到`AppModule`中\\n\\n    ![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0287350f381c43d0808aaef13e9a8089~tplv-k3u1fbpfcp-watermark.image?)\\n- 打开`src/base/base.module.ts`,写入\\n    ```js\\n    import { Module } from '@nestjs/common';\\n    import { MulterModule } from '@nestjs/platform-express';\\n    import { BaseController } from './base.controller';\\n    import { BaseService } from './base.service';\\n    import { diskStorage } from 'multer';\\n    import { checkDirAndCreate } from 'src/common/utils';\\n    import { webcrypto } from 'crypto';\\n    @Module({\\n      imports: [\\n        MulterModule.register({\\n          storage: diskStorage({\\n            destination(req, file, callback) {\\n              const filePath = `public/uploads/${file.mimetype.split('/')[0]}/`;\\n              checkDirAndCreate(filePath);\\n              return callback(null, `./${filePath}`);\\n            },\\n            filename(req, file, callback) {\\n              console.log(req.file);\\n              const suffix = file.originalname.substring(\\n                file.originalname.lastIndexOf('.'),\\n              );\\n              const fileName = Date.now() + '-' + webcrypto.randomUUID() + suffix;\\n              callback(null, fileName);\\n            },\\n          }),\\n          fileFilter(req, file, callback) {\\n            return callback(null, true);\\n          },\\n        }),\\n      ],\\n      controllers: [BaseController],\\n      providers: [BaseService],\\n    })\\n    export class BaseModule {}\\n\\n    ```\\n- 新建`src/common/utils/index.ts`,写入\\n    ```js\\n    import { existsSync, mkdirSync } from 'fs';\\n    /**\\n     * 创建文件夹\\n     * @param filePath 文件路径\\n     */\\n    export const checkDirAndCreate = (filePath: string) => {\\n      const pathArr = filePath.split('/');\\n      let checkPath = '.';\\n      for (let i = 0; i < pathArr.length; i++) {\\n        checkPath += `/${pathArr[i]}`;\\n        if (!existsSync(checkPath)) {\\n          mkdirSync(checkPath);\\n        }\\n      }\\n    };\\n\\n    /**\\n     *\\n     * @param src 文件地址\\n     * @returns 获取文件后缀名\\n     */\\n    export const getFileSuffix = (src: string) => {\\n      return src.substring(src.lastIndexOf('.'));\\n    };\\n\\n    /**\\n     * 类赋值-合并\\n     * @param oldVal 旧值\\n     * @param newVal 新值\\n     */\\n    export function classAssign<T extends object>(oldVal: T, newVal: T): T {\\n      for (const k in newVal) {\\n        oldVal[k] = newVal[k];\\n      }\\n\\n      return oldVal;\\n    }\\n\\n\\n    ```\\n- 新建`src/base/base.controller.ts`,写入\\n    ```js\\n    import {\\n      Controller,\\n      Headers,\\n      Post,\\n      UploadedFile,\\n      UseInterceptors,\\n    } from '@nestjs/common';\\n    import { FileInterceptor } from '@nestjs/platform-express';\\n    import { ApiOperation, ApiTags } from '@nestjs/swagger';\\n    import { isPublic } from 'src/auth/constants';\\n\\n    @ApiTags('公共模块')\\n    @Controller('base')\\n    export class BaseController {\\n      @ApiOperation({\\n        summary: '上传本地',\\n      })\\n      @isPublic()\\n      @Post('/uploadLocal')\\n      @UseInterceptors(FileInterceptor('file'))\\n      uploadLocal(\\n        @UploadedFile() file: Express.Multer.File,\\n        @Headers('host') host: string,\\n      ) {\\n        // 如果是 localhost 就加上http://\\n        if (!host.includes('://')) {\\n          host = `http://${host}`;\\n        }\\n        return `${host}/${file.path}`;\\n      }\\n    }\\n\\n    ```\\n#### 说明\\n- 文件上传请求方式一定为`post`\\n- 前端需要在`headers`中设置`\\\"Content-Type\\\": \\\"multipart/form-data\\\"`来传输二进制文件\\n- 发起`url`为`v1/base/uploadLocal`请求方式为`post`的时候，首先会经过`@isPublic()装饰器`去放行（免认证），然后进入拦截器，传入`FileInterceptor('file')`,这时就会进入`MulterModule.register`方法中，也就是这块\\n    ![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/923ab62ec1444cd2ba2454976af0e827~tplv-k3u1fbpfcp-watermark.image?)\\n- 接着会把文件写到`public`文件夹下\\n    ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d1a5e4eea5b8492397c88a599791a8e8~tplv-k3u1fbpfcp-watermark.image?)\\n- 最后会走到`BaseController`中的`uploadLocal`方法中，接着我们通过装饰器`@Headers('host')`拿到`headers`中的`host`,对`file.path`做拼接后即可返回\\n- 接着，我们用`postman`测试，发现数据已经被成功返回\\n    ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ee0338d1a834faaa88f2e4c1bcca775~tplv-k3u1fbpfcp-watermark.image?)\\n#### 开启静态文件预览\\n- 问题\\n    - 拿到后端返回的图片地址发现无法预览，会被`nest`的拦截器所拦截\\n    ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b98faaeae8764d21a21dcff9e2ed2c97~tplv-k3u1fbpfcp-watermark.image?)\\n- 打开 `src/main.ts`,写入\\n    ```\\n    // 开启静态文件预览\\n      app.useStaticAssets('public', {\\n        prefix: '/public/',\\n      });\\n    ```\\n- 保存文件，刷新浏览器，图片出来了，`完美，收工`\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/49869cd356a9455884860e77f7958b9d~tplv-k3u1fbpfcp-watermark.image?)\\n### 阿里oss文件上传\\n#### 介绍\\n- 阿里云对象存储OSS（Object Storage Service）是一款海量、安全、低成本、高可靠的云存储服务，提供99.9999999999%(12个9)的数据持久性，99.995%的数据可用性。多种存储类型供选择，全面优化存储成本。\\n#### 前置准备 - 购买对象存储OSS\\n- 第一步，打开官网，登录[阿里云](https://www.aliyun.com/)，账号和扫码都可以\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/58043b2940474413a945699014df2839~tplv-k3u1fbpfcp-watermark.image?)\\n- 第二步 选择对象存储OSS\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e55b979916d4a1f9a6ac2ea8c2514c3~tplv-k3u1fbpfcp-watermark.image?)\\n- 第三步，没有购买过OSS的，选择立即购买\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96592bdb99bd439ba131b7ca98e7b172~tplv-k3u1fbpfcp-watermark.image?)\\n- 第四步，买完之后选择管理控制台\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88902c0bf5b448cfbce69e41626662dd~tplv-k3u1fbpfcp-watermark.image?)\\n- 第五步，刚开始进入，`Bucket列表`为空，创建`Bucket`即可\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6156214ef824031a03ba596c11061bd~tplv-k3u1fbpfcp-watermark.image?)\\n- 第六步，填入`Bucket名称`，选择`资源组`，读写权限设置`公共读写`,点击确定即可\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc4afeec8e2a47beaf1ba54061e60d85~tplv-k3u1fbpfcp-watermark.image?)\\n- 第七步，确定后会跳转到这个页面，点击返回即可回到列表页面\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe27672bd88c45029ddd20b4ddfdd9ef~tplv-k3u1fbpfcp-watermark.image?)\\n- 第八步，打开帮助文档\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/14a7674c78cd422bb0d8d4213c01c874~tplv-k3u1fbpfcp-watermark.image?)\\n- 第九步，找到`Nodejs`版本的`文件上传`文档就可以愉快的阅读了\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db0b5343ed9e437b844723ceb0dab5de~tplv-k3u1fbpfcp-watermark.image?)\\n- 第十步，OSS构造函数需要的四个参数`region` `accessKeyId` `accessKeySecret` `bucket`，在这里可以找到\\n- 回到列表页，点`Bucket名称`\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f216c2f3c2a24ac4a5ed839f1307e4df~tplv-k3u1fbpfcp-watermark.image?)\\n- `Bucket名称`就是你的`bucket`\\n- `oss-cn-hangzhou`就是你的`region`\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b4da490e202474c9196a22e1c0214c3~tplv-k3u1fbpfcp-watermark.image?)\\n- 第十一步，点击`accessKey管理`\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/17a2faff26034d8cb10e1797dea359e9~tplv-k3u1fbpfcp-watermark.image?)\\n- 第十二步，选哪个都行，区别就是子用户权限更小些\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/caab522ae67e47539bfba0973c4cd7b5~tplv-k3u1fbpfcp-watermark.image?)\\n- 第十三步，点击`查看sercet`,发送手机验证码，即可获取到`accessKeyId` `accessKeySecret`\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f9b5e592a26443f2bdaf5da0e76b0742~tplv-k3u1fbpfcp-watermark.image?)\\n#### 安装\\n- 安装`ali-oss`\\n    ```\\n    yarn add ali-oss\\n    ```\\n#### 代码\\n- 打开`根目录/.config/.dev.yml`,将配置信息写入配置文件\\n    ```yaml\\n    # 阿里\\n    ALI:\\n      accessKeyId: accessKeyId\\n      accessKeySecret: accessKeySecret\\n      oss:\\n        region: oss-cn-hangzhou\\n        bucket: nest-study-backend\\n\\n    ```\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3e81d7ef54a446ca28971637575e2b8~tplv-k3u1fbpfcp-watermark.image?)\\n- 新建`src/common/ALI/oss.module.ts` 和 `src/common/ALI/oss.service.ts`\\n- 分别写入\\n    ```js\\n    import { Module } from '@nestjs/common';\\n    import { AliOssService } from './oss.service';\\n\\n    @Module({\\n      providers: [AliOssService],\\n      exports: [AliOssService],\\n    })\\n    export class AliOssModule {}\\n\\n    ```\\n    ```js\\n    /* eslint-disable @typescript-eslint/no-var-requires */\\n    import { Injectable } from '@nestjs/common';\\n    import { getConfig } from '../utils/ymlConfig';\\n    import { CustomException } from 'src/common/exceptions/custom.exception';\\n\\n    import { webcrypto } from 'crypto';\\n    import * as path from 'path';\\n    import type { PutObjectResult } from 'ali-oss';\\n    const OSS = require('ali-oss');\\n    const moment = require('moment');\\n\\n    /**\\n     * 阿里  oss  服务\\n     */\\n    @Injectable()\\n    export class AliOssService {\\n      // 通过静态方法获取app实例\\n      static getOssClient() {\\n        const { accessKeyId, accessKeySecret, oss } = getConfig('ALI');\\n        return new OSS({\\n          ...oss,\\n          accessKeyId,\\n          accessKeySecret,\\n        });\\n      }\\n\\n      //   获取oss路径\\n      static getOssPath(suffix: string) {\\n        const ymd: string = moment().format('YYYY/MM/DD');\\n        //   格式  2023/01/17/uuid\\n        return `${ymd}/${webcrypto.randomUUID()}${suffix}`;\\n      }\\n\\n      /**\\n       *\\n       * @param url\\n       * @param suffix\\n       * @returns 上传buffer 到 oss\\n       */\\n      async putLocal(url: string, suffix: string) {\\n        try {\\n          return AliOssService.getOssClient().put(\\n            AliOssService.getOssPath(suffix),\\n            path.normalize(url),\\n          );\\n        } catch (error) {\\n          throw new CustomException(error);\\n        }\\n      }\\n\\n      /**\\n       *\\n       * @param buffer\\n       * @param suffix\\n       * @returns 上传buffer 到 oss\\n       */\\n      async putBuffer(buffer: Buffer, suffix: string): Promise<PutObjectResult> {\\n        try {\\n          return await AliOssService.getOssClient().put(\\n            AliOssService.getOssPath(suffix),\\n            buffer,\\n          );\\n        } catch (error) {\\n          throw new CustomException(error);\\n        }\\n      }\\n\\n      /**\\n       * 删除资源\\n       * @param path 资源文件路径\\n       */\\n      async deleteFile(path: string) {\\n        try {\\n          await AliOssService.getOssClient().delete(path);\\n        } catch (error) {\\n          throw new CustomException(error);\\n        }\\n      }\\n    }\\n    ```\\n- 修改`src/base/base.module.ts`，走oss上传，要注掉`storage`,不然会走本地存储，同时`file.buffer`也拿不到\\n    ```js\\n    import { Module } from '@nestjs/common';\\n    import { MulterModule } from '@nestjs/platform-express';\\n    import { BaseController } from './base.controller';\\n    import { BaseService } from './base.service';\\n    import { diskStorage } from 'multer';\\n    import { checkDirAndCreate } from 'src/common/utils';\\n    import { webcrypto } from 'crypto';\\n    import { AliOssModule } from 'src/common/ALI/oss.module';\\n    import { BaiduFaceModule } from 'src/common/BAIDU/face.module';\\n    @Module({\\n      imports: [\\n        AliOssModule,\\n        BaiduFaceModule,\\n        MulterModule.register({\\n          // storage: diskStorage({\\n          //   destination(req, file, callback) {\\n          //     const filePath = `public/uploads/${file.mimetype.split('/')[0]}/`;\\n          //     checkDirAndCreate(filePath);\\n          //     return callback(null, `./${filePath}`);\\n          //   },\\n          //   filename(req, file, callback) {\\n          //     console.log(req.file);\\n          //     const suffix = file.originalname.substring(\\n          //       file.originalname.lastIndexOf('.'),\\n          //     );\\n          //     const fileName = Date.now() + '-' + webcrypto.randomUUID() + suffix;\\n          //     callback(null, fileName);\\n          //   },\\n          // }),\\n          fileFilter(req, file, callback) {\\n            return callback(null, true);\\n          },\\n        }),\\n      ],\\n      controllers: [BaseController],\\n      providers: [BaseService],\\n    })\\n    export class BaseModule {}\\n\\n    ```\\n- 修改 `src/base/base.controller.ts`增加`uploadOSS`接口\\n    ```\\n    import {\\n      Controller,\\n      Headers,\\n      Post,\\n      UploadedFile,\\n      UseInterceptors,\\n    } from '@nestjs/common';\\n    import { FileInterceptor } from '@nestjs/platform-express';\\n    import { ApiOperation, ApiTags } from '@nestjs/swagger';\\n    import { isPublic } from 'src/auth/constants';\\n    import { getFileSuffix } from '../common/utils/index';\\n    import { AliOssService } from '../common/ALI/oss.service';\\n\\n    @ApiTags('公共模块')\\n    @Controller('base')\\n    export class BaseController {\\n      constructor(private readonly aliOssService: AliOssService) {}\\n      @ApiOperation({\\n        summary: '上传本地',\\n      })\\n      @isPublic()\\n      @Post('/uploadLocal')\\n      @UseInterceptors(FileInterceptor('file'))\\n      uploadLocal(\\n        @UploadedFile() file: Express.Multer.File,\\n        @Headers('host') host: string,\\n      ) {\\n        console.log(host, file);\\n\\n        // 如果是 localhost 就加上http://\\n        if (!host.includes('://')) {\\n          host = `http://${host}`;\\n        }\\n        return `${host}/${file.path}`;\\n      }\\n\\n      @ApiOperation({\\n        summary: '上传阿里OSS',\\n      })\\n      @isPublic()\\n      @Post('/uploadOSS')\\n      @UseInterceptors(FileInterceptor('file'))\\n      async uploadOSS(@UploadedFile() file: Express.Multer.File) {\\n        // oss文件上传\\n        const { url } = await this.aliOssService.putBuffer(\\n          file.buffer,\\n          getFileSuffix(file.originalname),\\n        );\\n\\n        return url;\\n      }\\n    }\\n\\n    ```\\n#### 测试\\n- 老规矩，打开`postman`,输入`localhost:3000/v1/base/uploadOSS`,开始测试\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f0a79020c028432593e1afd905445c47~tplv-k3u1fbpfcp-watermark.image?)\\n- 进入阿里云后台，点击`Bucket`，发现文件上传成功了\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9cef29b40ba145d8b59211717f0352de~tplv-k3u1fbpfcp-watermark.image?)\\n### 小结\\n- 俩种方式都可以实现文件的上传下载\\n- 具体情况看公司喜好，个人建议放到`OSS`,安全而且按量收费也挺合适的\\n- 本次以阿里云为例做了演示，其他云产品自行参考，套路都一样\\n## 公共模块 - 百度人脸识别\\n### 目的\\n- 为了体现产品的智能化（`少的操作做多的事情`）\\n- 实现上传头像，`自动填充`生日和性别\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/543556c9e7034d9f9c3c1997273d7c65~tplv-k3u1fbpfcp-watermark.image?)\\n### 介绍\\n- 快速检测人脸并返回人脸框位置，输出人脸150个关键点坐标，准确识别多种属性信息\\n### 前置准备 - 购买人脸检测产品\\n- 第一步，打开官网，登陆[百度AI](https://ai.baidu.com/),扫码和账号登录都可以\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a24b16a9da54fac9f18e8a966112f52~tplv-k3u1fbpfcp-watermark.image?)\\n- 第二步，选择`人脸检测与属性分析`\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd39863e7c1c455e866b9800f915bf1c~tplv-k3u1fbpfcp-watermark.image?)\\n- 第三步，点击`立即使用`\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/82298b9882fd493a8f25c565ffee83db~tplv-k3u1fbpfcp-watermark.image?)\\n- 第三步，开通`人脸识别`\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb423ed2af344ea2a0d986ec509f0b34~tplv-k3u1fbpfcp-watermark.image?)\\n- 第四步，根据需求，开通对应的功能即可，`注意，开通服务前，需要先进行充值`\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/84ce8f746ed44e8a9f0b82ba8ccec7e8~tplv-k3u1fbpfcp-watermark.image?)\\n- 第五步，订单没有疑问，直接下一步\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88bfbfd62a5545588343cbd29c007f1c~tplv-k3u1fbpfcp-watermark.image?)\\n- 第六步，开通成功后，返回`管理控制台`即可\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c6b040c22654d048b3c869330629f97~tplv-k3u1fbpfcp-watermark.image?)\\n- 发现`人脸检测`服务成功启用\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/60ba543a1b2249cb879da316b2fe2824~tplv-k3u1fbpfcp-watermark.image?)\\n- 第七步，查看`api文档`\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e423c830a326402b89a7faca1460aba1~tplv-k3u1fbpfcp-watermark.image?)\\n- 第八步，找到`NodeSDK`,就可以愉快的阅读了\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f40a91ce158e4d9f84d54ae31abf39e5~tplv-k3u1fbpfcp-watermark.image?)\\n- 第九步，`APP_ID` `APP_KEY` `SECRET_KEY` 可以在这里找到\\n- 账户ID就是`APP_ID`\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4dd1d46f17a4e05ae209cced65c952d~tplv-k3u1fbpfcp-watermark.image?)\\n- `安全认证`中可以拿到`APP_KEY` 和 `SECRET_KEY`\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/24c81aba4c1f4d08ada7e02c24d7a83b~tplv-k3u1fbpfcp-watermark.image?)\\n### 安装\\n- 安装`baidu-aip-sdk`\\n    ```\\n    yarn add baidu-aip-sdk\\n    ```\\n### 代码\\n- 打开`根目录/.config/.dev.yml`,将配置信息写入配置文件\\n    ```yaml\\n    #百度\\n    BAIDU:\\n      appId: appId\\n      accessKey: accessKey\\n      secretKey: secretKey\\n    ```\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d3fe42747db456ab62732f620c418a5~tplv-k3u1fbpfcp-watermark.image?)\\n- 新建`src/common/BAIDU/face.module.ts` 和`src/common/BAIDU/face.service.ts`\\n- 分别写入\\n    ```js\\n    import { Module } from '@nestjs/common';\\n    import { BaiduFaceService } from './face.service';\\n\\n    @Module({\\n      providers: [BaiduFaceService],\\n      exports: [BaiduFaceService],\\n    })\\n    export class BaiduFaceModule {}\\n    ```\\n    \\n    ```js\\n    /* eslint-disable @typescript-eslint/no-var-requires */\\n    import { Injectable } from '@nestjs/common';\\n    import { CustomException } from '../exceptions/custom.exception';\\n    import { getConfig } from '../utils/ymlConfig';\\n    const AipFaceClient = require('baidu-aip-sdk').face;\\n\\n    export interface FaceInfo {\\n      error_code: number;\\n      error_msg: string;\\n      log_id: number;\\n      timestamp: number;\\n      cached: number;\\n      result: {\\n        face_num: number;\\n        face_list: {\\n          face_token: string;\\n          location: {\\n            left: number;\\n            top: number;\\n            width: number;\\n            height: number;\\n            rotation: number;\\n          };\\n          face_probability: number;\\n          angle: {\\n            yaw: number;\\n            pitch: number;\\n            roll: number;\\n          };\\n          age: number;\\n          gender: {\\n            type: 'male' | 'female';\\n            probability: number;\\n          };\\n        }[];\\n      };\\n    }\\n\\n    /**\\n     * 百度人脸识别\\n     */\\n    @Injectable()\\n    export class BaiduFaceService {\\n      // 新建一个对象，建议只保存一个对象调用服务接口\\n      static getFaceClient() {\\n        const { appId, accessKey, secretKey } = getConfig('BAIDU');\\n\\n        return new AipFaceClient(appId, accessKey, secretKey);\\n      }\\n\\n      async getFaceInfo(\\n        imageUrl: string,\\n        imageType = 'URL',\\n        options = {\\n          face_field: 'age,gender',\\n        },\\n      ) {\\n        try {\\n          const faceInfo: FaceInfo = await BaiduFaceService.getFaceClient().detect(\\n            imageUrl,\\n            imageType,\\n            options,\\n          );\\n          return faceInfo;\\n        } catch (error) {\\n          throw new CustomException(error);\\n        }\\n      }\\n    }\\n    ```\\n- 修改`src/base/base.controller.ts`下`uploadOSS`方法，添加调用人脸识别代码\\n    ```js\\n      @ApiOperation({\\n        summary: '上传阿里OSS',\\n      })\\n      @isPublic()\\n      @Post('/uploadOSS')\\n      @UseInterceptors(FileInterceptor('file'))\\n      async uploadOSS(@UploadedFile() file: Express.Multer.File) {\\n        // oss文件上传\\n        const { url, name } = await this.aliOssService.putBuffer(\\n          file.buffer,\\n          getFileSuffix(file.originalname),\\n        );\\n\\n        // 执行人脸识别函数\\n        const faceInfo = await this.baiduFaceService.getFaceInfo(url);\\n        // 如果人脸识别失败，删除阿里云存储的图片\\n        if (faceInfo.error_code !== 0) {\\n          await this.aliOssService.deleteFile(name);\\n          // 返回人脸识别错误提示\\n          throw new CustomException(faceInfo.error_msg);\\n        }\\n        // 返回阿里oss图片地址和人脸识别信息\\n        return { url, ...faceInfo };\\n      }\\n    ```\\n### 说明\\n- `BaiduFaceService`中调用人脸识别的时候，`options`参数的`face_field`参数一定要显式的传入，否则不会返回相关属性\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/64f461a9f5574993b042e2b05617a529~tplv-k3u1fbpfcp-watermark.image?)\\n- 人脸识别失败的图片，直接删除即可，无效的文件会占用资源，毕竟`阿里OSS`是按量收费的\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2dde690d1824c4ca62b5003b1dffe41~tplv-k3u1fbpfcp-watermark.image?)\\n### 测试\\n- 老规矩，打开`postman`,输入`localhost:3000/v1/base/uploadOSS`,开始测试，数据成功返回，`歪瑞古德`\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d3d93c7de65d40b0b4689ea57dd077c7~tplv-k3u1fbpfcp-watermark.image?)\\n## 员工模块 - 新增\\n### 页面预览\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/28334e0b5218423a9e19a883c6679e0b~tplv-k3u1fbpfcp-watermark.image?)\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a7b3914c5264a9d9ae9fadb8f5a17b7~tplv-k3u1fbpfcp-watermark.image?)\\n### 开发 - controller\\n#### 代码\\n- 打开`EmployeeController`,加入以下代码\\n    ```\\n      @ApiOperation({\\n        summary: '创建员工',\\n      })\\n      @Post()\\n      create(@Body() employee: Employee) {\\n        employee.password = md5('123456');\\n        return this.employeeService.create(employee);\\n      }\\n    ```\\n#### 说明\\n- `@Body装饰器`可以获取到 `post`请求 `body`中的数据\\n- 创建初始密码，并对其进行`md5`加密\\n- 将`employee`传入`service`层，进行数据库交互\\n### 开发 - service\\n#### 代码\\n- 打开`EmployeeService`,加入以下代码\\n    ```\\n      /**\\n       *\\n       * @param employee Employee\\n       * @returns 创建员工\\n       */\\n      create(employee: Employee) {\\n        return this.employeeRepository.save(classAssign(new Employee(), employee));\\n      }\\n\\n\\n    ```\\n- 打开`src/types/index.d.ts`，加入对`process.dev`的扩展代码\\n    ```\\n    import { Request } from 'express';\\n    import { Employee } from '../employee/entities/employee.entity';\\n\\n    export type TIdAndUsername = 'id' | 'username';\\n\\n    declare module 'express' {\\n      interface Request {\\n        user: Pick<Employee, TIdAndUsername>;\\n      }\\n    }\\n\\n    declare global {\\n      namespace NodeJS {\\n        interface ProcessEnv {\\n          RUNNING: string;\\n          id: Employee['id'];\\n        }\\n      }\\n    }\\n    ```\\n- 打开`src/auth/strategy/jwt.strategy.ts`,将`employee.id`添加到`process.env`\\n    ```\\n    import { Injectable } from '@nestjs/common';\\n    import { PassportStrategy } from '@nestjs/passport';\\n    import { ExtractJwt, Strategy } from 'passport-jwt';\\n    import { getConfig } from '../../common/utils/ymlConfig';\\n    import { Employee } from '../../employee/entities/employee.entity';\\n    import { TIdAndUsername } from '../../types/index';\\n\\n    @Injectable()\\n    export class JwtStrategy extends PassportStrategy(Strategy) {\\n      constructor() {\\n        super({\\n          // 提供从请求中提取 JWT 的方法。我们将使用在 API 请求的授权头中提供token的标准方法\\n          jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),\\n          //   false 将JWT没有过期的责任委托给Passport模块\\n          ignoreExpiration: false,\\n          //   密钥\\n          secretOrKey: getConfig('JWT')['secret'],\\n        });\\n      }\\n\\n      //  jwt验证\\n      async validate(\\n        payload: Pick<Employee, TIdAndUsername> & { iat: number; exp: number },\\n      ) {\\n        if (!process.env.id) {\\n          process.env.id = payload.id;\\n        }\\n        return {\\n          id: payload.id,\\n          username: payload.username,\\n        };\\n      }\\n    }\\n\\n    ```\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f0cd91e8e6ed472099acc17067506038~tplv-k3u1fbpfcp-watermark.image?)\\n#### 说明\\n- 将传入的数据经过`classAssign`包装后，存入到数据库\\n- `classAssign函数`对值进行和合并处理\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9439afcd1c57406f9f7d4b9f900107fd~tplv-k3u1fbpfcp-watermark.image?)\\n- 由于在`BaseEntity`中添加了`@BeforeInsert` 和 `@BeforeUpdate`俩个装饰器，可以在执行`insert`和`update`之前做前置操作\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/944cd399e89d454d9652a53c80767368~tplv-k3u1fbpfcp-watermark.image?)\\n- 这俩个`装饰器`中，统一处理了`createTime` `updateTime` `createUser` `updateUser`\\n- 如果调用`employeeRepository.save`的时候直接传入`employee`参数，这俩个`前置装饰器`时不会生效的，应为 `employee`中没有`insert`和`update`方法\\n- `sql`语句如下\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99e31fd35b1e4c099db3272194cc2dfe~tplv-k3u1fbpfcp-watermark.image?)\\n- 状态`status`在设计数据库的时候，默认`填充0`，即启用状态\\n## 员工模块 - 根据id查询\\n### 开发 - controller\\n#### 代码\\n- 打开`EmployeeController`,加入以下代码\\n    ```\\n      @ApiOperation({\\n        summary: '根据ID查询',\\n      })\\n      @Get('/:id')\\n      findOne(@Param('id') id: string) {\\n        return this.employeeService.findById(id);\\n      }\\n    ```\\n#### 说明\\n- `@Param装饰器`可以拿到路径上的参数`/employee/1`,即`1`,然后封装到`id`属性中\\n- 将`id`传入`service`层，调用数据库即可\\n### 开发 - service\\n#### 代码\\n- 打开`EmployeeService`,加入以下代码\\n    ```\\n      /**\\n       *\\n       * @param id id\\n       * @returns 根据ID查询\\n       */\\n      async findById(id: string) {\\n        const employee = await this.employeeRepository.findOneBy({ id });\\n        if (!employee) {\\n          throw new CustomException('id不存在');\\n        }\\n        return employee;\\n      }\\n    ```\\n#### 说明\\n- 根据`id`查询数据库，如果没查到数据直接`抛出自定义异常信息`\\n- 有查询数据，直接返回，前端做`数据回显`\\n## 员工模块 - 更新员工\\n### 开发 - controller\\n#### 代码\\n- 打开`EmployeeController`,加入以下代码\\n   ```\\n     @ApiOperation({\\n        summary: '更新',\\n      })\\n      @Put()\\n      update(@Body() employee: Employee) {\\n        return this.employeeService.update(employee);\\n      }\\n   ```\\n#### 说明\\n- 将前端传入的参数直接传入`service`层即可\\n### 开发 - service\\n#### 代码\\n- 打开`EmployeeService`,加入以下代码\\n    ```js\\n       /**\\n       *\\n       * @param employee\\n       * @returns 更新\\n       */\\n      async update(employee: Employee) {\\n        return !!(\\n          await this.employeeRepository.update(\\n            { id: employee.id },\\n            classAssign(new Employee(), employee),\\n          )\\n        ).affected;\\n      }\\n    ```\\n#### 说明\\n- 没有黑魔法，将数据存入数据库即可，然后返回状态 `true` 更新成功， `false`更新失败\\n## 员工模块 - 删除员工\\n### 开发 - controller\\n#### 代码\\n- 打开`EmployeeController`,加入以下代码\\n   ```js\\n    @ApiOperation({\\n        summary: '删除,支持批量操作',\\n      })\\n      @Delete()\\n      del(@Query('ids') ids: string[]) {\\n        return this.employeeService.delete(ids);\\n      }\\n   ```\\n#### 说明\\n- 前端会传入字符串`/ids=1,2,3`这样的格式，由于我们前面添加了`全局管道转换`,`nest`会根据`ts`类型，进行自动转换\\n- 将转换后的数据传入`service`层即可\\n### 开发 - service\\n#### 代码\\n- 打开`EmployeeService`,加入以下代码\\n    ```js\\n         /**\\n       *\\n       * @param ids ids\\n       * @returns 删除\\n       */\\n      async delete(ids: string[]) {\\n        // 只能删除停用的账号\\n        const count = await this.employeeRepository.countBy({\\n          id: In(ids),\\n          status: 1,\\n        });\\n        if (count > 0) {\\n          throw new CustomException('不能删除启用中的账号');\\n        }\\n        return !!(await this.employeeRepository.delete({ id: In(ids) })).affected;\\n      }\\n    ```\\n#### 说明\\n- 启用中的账号是不能删除的，可以通过`count`进行查询\\n- `In`等同`sql`中的 `IN` 关键字\\n## 员工模块 - 设置启用 - 禁用\\n### 开发 - controller\\n#### 代码\\n- 打开`EmployeeController`,加入以下代码\\n   ```js\\n  @ApiOperation({\\n    summary: '启用，禁用,支持批量操作',\\n  })\\n  @Post('status/:status')\\n  setStatus(@Param('status') status: number, @Query('ids') ids: string[]) {\\n    return this.employeeService.setStatus(ids, status);\\n  }\\n   ```\\n#### 说明\\n- 将接收到的`status`和`ids`直接传入`service`层即可\\n### 开发 - service\\n#### 代码\\n- 打开`EmployeeService`,加入以下代码\\n    ```js\\n       /**\\n       *\\n       * @param ids ids\\n       * @returns 设置员工状态  启用 - 禁用\\n       */\\n      async setStatus(ids: string[], status: number) {\\n        const employee = new Employee();\\n        employee.status = status;\\n        return !!(await this.employeeRepository.update({ id: In(ids) }, employee))\\n          .affected;\\n      }\\n    ```\\n#### 说明\\n- 没有黑魔法，直接根据`id`更改`status`即可\\n\\n## 总结\\n\\n-   到现在`nest部分`的员工模块已经全部开发完成\\n-   前置工作比较复杂，需要考虑代码的`健壮性`,以及`阿里云`和`百度AI`的账号产品服务开通\\n-   代码封装完成后，`CRUD`其实就很简单了，\\n-   最后就是需要多理解业务需求，根据业务去拆分、整合代码，尽量遵循`开闭原则`和`单一原则`\\n\\n## 写在最后\\n\\n-   本章主要讲解员工模块，如有问题欢迎在评论区留言\\n-   前端仓库[nest-study-bacnend](https://gitee.com/Tianyf/nest-study-backend)\\n-   `nest`代码已经放在 [gitee](https://link.juejin.cn?target=https%3A%2F%2Fgitee.com%2FTianyf%2Fnest-study%2Ftree%2Fdemo%252Fv4%2F \\\"https://gitee.com/Tianyf/nest-study/tree/demo%2Fv4/\\\") demo/v4分支\\n-   对`mysql`不熟悉的可以看下 [前端玩转mysql](https://juejin.cn/post/6959851582984814623 \\\"https://juejin.cn/post/6959851582984814623\\\")和[Nodejs连接Mysql](https://juejin.cn/post/6960830835087900703#heading-11 \\\"https://juejin.cn/post/6960830835087900703#heading-11\\\") 这俩篇文章\\n-   对Nest语法不熟悉的掘友可以看下[Nest文档](https://link.juejin.cn?target=https%3A%2F%2Fdocs.nestjs.cn%2F9%2Ffirststeps \\\"https://link.juejin.cn?target=https%3A%2F%2Fdocs.nestjs.cn%2F9%2Ffirststeps\\\")和[Midway文档](https://link.juejin.cn?target=https%3A%2F%2Fmidwayjs.org%2Fdocs%2Fintro \\\"https://link.juejin.cn?target=https%3A%2F%2Fmidwayjs.org%2Fdocs%2Fintro\\\")，`搭配服用`效果更佳\\n\\n  \\n"
    },
    {
        "article_id": "7181095134758387773",
        "cover_image": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d70a41ada1242ceb3a5fe754c226356~tplv-k3u1fbpfcp-watermark.image?",
        "title": "欠薪6个月：大龄，掘金，疫情，酒店，转型，前端满两年，搞公司后端两个月，年后离职还是继续等待？",
        "brief": "就在此刻我的状态腰痛万分，如坐针毡，而我的老婆头痛欲裂，还加上恶心呕吐，还好我三岁的孩子只是有点咳嗽，要不然我真的顶不住写这3000多字，在这样的日子写一份年终总结真的太难了",
        "user_name": "那个曾经的少年回来了",
        "view_count": 22246,
        "collect_count": 53,
        "comment_count": 179,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/33ee9fd0589207058522e8b8e86a577b~300x300.image",
        "category": "代码人生",
        "content": "---\\ntheme: vuepress\\nhighlight: tomorrow-night\\n---\\n\\n「回顾2022，展望2023，我正在参与[2022年终总结征文大赛活动](https://juejin.cn/post/7172462429929111559 \\\"https://juejin.cn/post/7172462429929111559\\\")」\\n\\n>大家好，我是 `那个曾经的少年回来了`。10年前我也曾经年轻过，如今已步入被淘汰的年龄，但现在幡然醒悟，所以活在当下，每天努力一点点，来看看2024年的时候自己会是什么样子吧，2024年的前端又会是什么样子，而2024年的中国乃至全球又会变成什么样子，如果你也有想法，那还不赶紧行动起来。期待是美好的，但是更重要的是要为美好而为之奋斗并付诸于行动。\\n\\n喜欢的可以到创作者榜单点点我，估计也没几个人点我哈哈，自己点自己嘞\\n\\n  \\n## 1、前言\\n\\n\\n就跟随着标题一个一个的来总结一下自己的2022吧，绝望中透露着一丝的希望，让我不得不在逆境中重生，寻找新的出路。\\n\\n## 2、欠薪6个月\\n\\n  今年上了12个月的班，但是呢不算12月的工资，竟然还有6个月的工资没发，公司确实欠薪了，而且也非常的难受。怎么办呢？我自己也不清楚，过完年再说吧，希望年前最后一个月还能发点工资吧。\\n\\n## 3、大龄\\n「[88年大龄前端：转行前端不到两年|2022年年中总结](https://juejin.cn/post/7113822932803485709)」\\n\\n这是我在2022年年中的时候总结的文章，那个时候计划2022年下半年输出大概16篇文章，而我下半年真正输出了46篇文章，当然其中有一部分是在我脚骨折只能在家卧床的时候写的，所以从时间上来看有一些水分，但是从完成任务的角度我还是超额完成的，我对自己的表现非常满意，哈哈哈。\\n\\n大龄也许就是一个分水岭，有的人踏过去了，也有的人就此放弃了，还有的人根本不当回事，那么你又是哪一种呢？\\n\\n大龄，没学历，没背景，没资源就只能躺平吗？反正我觉得如果真躺平了，那就是平了，而我选择了继续努力，每天保持不断的学习努力有所成长，就会得到满足，，哪怕一点点，也经得起长时间的积累。\\n## 4、掘金\\n\\n  - 收获最多的地方\\n![1bed61531924d964bbf75dd5d12911f.jpg](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5f0ca9547d0949ee9e29d4c4175d064e~tplv-k3u1fbpfcp-watermark.image?)\\n\\n这里应该是收获最多的地方，55篇这放在任何时候想都不敢想，万万没想到竟然能输出这么多，而且还收获了掘金非常多的礼物，在此感谢掘金，感谢[川哥https://juejin.cn/user/1415826704971918](https://juejin.cn/user/1415826704971918), 不用想肯定是你认识的那个若川视野。\\n\\n\\n![61da0551e864447baa877f208eb0f43.jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c64d78f7c55d4746870aa2e35fc416f8~tplv-k3u1fbpfcp-watermark.image?)\\n\\n这里的礼物只是一部分，还有另外一部分，什么背包帽子，等等的每次收到都非常的开心。\\n\\n![324f7d177af92efe44023043cd25583.jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/86c1d01055fb4de8abc0028990ccc998~tplv-k3u1fbpfcp-watermark.image?)\\n\\n这个创作先锋将我个人还是非常的意外，也是不经意间老婆收到的快递，简直开心到起飞。\\n\\n\\n- 去年在掘金的阅读\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/01c099bb25694cc5a3bd87c2fd281e5c~tplv-k3u1fbpfcp-watermark.image?)\\n\\n2021年一年可以说是入门前端，和众多刚毕业以及毕业一两年的前端的道友们一起在这里不断的收获，这里我个人点赞（共683篇）的文章大多都是研读的文章。\\n\\n- 今年在掘金的阅读\\n\\n![9e851faeebda2eed0f7e074f72d93d3.jpg](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/485538633eed4d68a605b5ef395c1c76~tplv-k3u1fbpfcp-watermark.image?)\\n\\n同时依靠掘金我的github也竟然有了200多的小星星，实属难得\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b0196c7b3a0406fa6a8671f18389bb8~tplv-k3u1fbpfcp-watermark.image?)\\n\\n这里顺便提一下极客时间的学习\\n\\n![0e79faf2e59a08ba062182d24596aed.jpg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c63ca7e3e16e41718bcad8cf41c78b30~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n![212ec2c1481895c931dd57c9f9cbee8.jpg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f0ca465c2eb4ddaa2d6566ccb26bb49~tplv-k3u1fbpfcp-watermark.image?)\\n\\n只能说尽力学对自己有用的，充实自己，其实很多篇我都是反复看，看的自己明明白白的。不过确实也收获到了知识。\\n\\n\\n\\n2022年一年可以说是入门后的腾飞，不断在掘金的引领下，让我在自我思考的摸索中寻找到坚定的方向。同时在川哥的带领下我也能看懂一点牛逼开源项目的源码了，这真的可以说是比较大的突破了。同时可以发现2022年的阅读量会更大一些，由于自己也会进行输出，在输出的过程中其实更需要对知识进行再三确认。\\n\\n## 5、疫情，酒店，转型\\n - 万万没想到就在现在此时此刻，全国所有人正在经历着，或者自己的至亲正在经历着，又或者自己身边的人正在经历着“鼻子封水泥、喉咙吞刀片、内脏咳出胸、”等症状，本来这篇文章准备在12月23日发出来的，但早上一醒来就进入炼狱般的状态了，昨天一天在头痛和发烧中度过的。\\n\\n - 由于公司主营业务便是服务于酒店业务，公司在2020年和2021年的收入有所影响，但总体可控影响不大。但是时间节点来到2021年年底以及2022年的全年，各种突发情况，慢慢的让公司的收入锐减。\\n\\n - 同时公司在2020年也有了初步的判断，需要拓展业务，才有了新的业务赛道，可能是由于决策和对新赛道的陌生，也使得前期大幅投入迟迟达不到预期，迟迟也没有收入，公司也由360多人，一度减员到8月份低谷时期，总人数不到80吧。\\n\\n## 6、前端满两年\\n  - 从2020年9月25日入职公司，开始接触vue2,然后着手公司pc端：vue2+elementui,微信端h5：vue2+vant, 然后android app webview嵌套 vue2+vant,期间也接触了一个react项目\\n  \\n  - 2021年年初开始走上，vite+vue3+echarts大屏项目，相对于熟悉了解了vue2后，直接用vue2的语法来写是没问题的，然后慢慢的也在学习vue3+setup的语法，也将某些组件进行了转换\\n  \\n  - 2021年4月开始一个新的pc项目，采用了qiankun微前端，主应用使用vite+vue3,其他子应用采用vuecli+vue3 + element-plus,刚使用qiankun时，还是遇到了一些问题\\n  \\n  - pc端项目经过几个月的时间，陆续稳定上线，然后期间封装了pc端的json  form表单生成器和json table列表生成器，这两个组件节省了很多PC端重复的工作，以及bug修改，感觉封装出来还是有点成就感的，我的前端兄弟都觉得非常的nice。\\n  \\n  - 搞pc期间还接触了leaflet、leaflet-geoman来给地图打点或者画区域，上手略有难度，但经过几天的摸索熟悉后，能够磕磕绊绊的将需要的功能实现出来了，使用过后感觉这个类库的功能还是非常强大的。\\n  \\n  - 2021年年底开始在原有android app webview的基础上增加新的功能，考虑到对vue3以及qiankun的熟悉，准备添加一个子应用，使用vue3+vant的模式来处理新增的业务功能\\n  \\n  - 此时可着手两个组件的封装，一个当然还是json form表单生成器的，逻辑上跟pc组件是类似的，只是换了一套vant的组件。另外一个相当于pc端的table列表，但是在移动端的h5当中每个列表的样式可能不同，就单独提取了一个模板，加速充血了一波，待组件稳定后，其实大致到了2022年的3月份了。\\n  \\n  - 2022年4月份的时候公司有一个专门数据采集的项目，最终要的功能便是用到了根据json生成form表单的并且对接通用接口，json的生成也是通过页面进行配置。其中难度比较大的便是数据的联动控制显示隐藏，以及数据校验、正则匹配、以及将部分js代码通过界面去编写，前端解析json后再动态执行js代码也是一个不小的难点。\\n\\n  - 另外一个突破便是将vant 列表数据模板，做了两个通用的，根据SQL配置 接口返回通用的数据结构列表，去匹配模板列表。其实这里也有思考通过后台配置，拖拽元素实现列表的一行数据样式展示，但是在渲染的时候我是根据屏幕宽高比去进行等比的展示，但是发现样式会有所变形，主要是通过transform: scale(0.9) 计算出比例，然后填充数值，我猜测可能是我实现的方式还存在问题，等有时间再来看看，主要是我觉得这个思路好像是没问题的。\\n\\n  - 期间5、6月份开始解决vue3 移动端中 列表到详情再返回列表，并且要记录当时的位置的问题，其实解决起来还是蛮麻烦的，当时查阅资料或者水平还不够，没能实现，但是线上的问题又必须要解决，于是硬着头皮看了一下vue3 keppalive组件的源码，其实还是看了蛮久的，看完解决完问题后，我还专门写了一篇小文，一不小心算是上了掘金的头条，真的非常开心。\\n  \\n  - 同时解决微信小程序中嵌套webview场景中的一些小问题，最主要的一个问题其实微信中打开h5页面，如果有使用到localstorage或者cookie，再在微信小程序中嵌套h5页面，那么会存在脏读的问题。我是通过根据window.navigator.userAgent.toLowerCase() 先判断其中是否包含 'miniprogram',有则代表是在微信小程序中，再判断是否包含'micromessenger',有则代表是在微信环境中，这样针对每个环境去设置不同的key，然后在当前环境中使用当前的key就不会产生冲突了。\\n  \\n  - 2022年7月份意外脚骨折在家里呆了三个周吧，然后上下班打车两个月终于摆脱拐杖，不得不说真的是伤筋动骨100天呢。\\n  \\n  - 2022年8月和9月正常开始迭代新的需求和项目的bug修复，期间有指出有新的项目要开始了。由于自己自身的尴尬（原先前端由我来管理的，但是骨折期间和之后发生了一些令人不悦的事情，没办法我直接提出交出去吧），自己也不能闲下来，于是开始新项目的准备，前端我可以干，有时间了也开始参与后端的代码。\\n  \\n## 7、后端两个多月的时间了（从2022年10月至今）\\n  之前使用过.net framework,而公司有个项目正好使用的是.net core，所以上手难度相对较小但由于很久没用，区别还是有的，，最大的区别当然就是跨平台了。于是在今年10月份开始接触.net core，这两个多月的时间下来对公司后端代码也算是有了更加深入的了解。之前的两年时间算是全部都花在了前端代码里。从我现在的角度来看后端，其实思路相对来说也非常的明确。\\n\\n- 熟悉操作linux常用的各种命令，因为要发布测试上线，服务器都是linux\\n\\n- 熟悉基础的后端代码，然后能够独立的实现CRUD增删改查\\n\\n- 熟悉mysql的基本操作，由于数据量比较大，所以对索引的使用也上了一个台阶，要不然严重影响接口的响应时间\\n- 当然还有其他的但是目前来看还只算是皮毛，有待进一步的加强学习\\n    \\n ## 8、年后离职还是继续等待？\\n 关于这个问题其实自己思考过了，看年后一两个月的情况就可以快速决定了。没办法，从现在开始只能说我要时刻准备着，时刻准备让自己拥有更多的技能，能够让自己变得更加强大。\\n ## 9、2023年计划\\n没有目标一切都将是空谈，给自己制定一个切实有效的目标，那么到了来年，可以跟随时间和需求的变化，再随时调整目标。\\n\\n关于前端计划\\n\\n- 继续攻坚前端工程化\\n\\n- 继续攻坚前端组件的封装 \\n- 继续攻坚react的使用和深入，公司项目主要是vue3,自己玩无用武之地\\n\\n关于后端计划\\n\\n- 微服务架构模式学习深入\\n\\n- 消息队列在项目各场景中灵活运用，比如先攻克一个rabbitmq\\n\\n- redis在项目中发挥桥梁的作用\\n\\n- mysql数据库如何在项目中发挥护城墙的作用，把好最后一道关卡\\n\\n- 项目整个架构相关的学习实战\\n\\n所以最后争取吧，一年36篇小作文，也就是每个月三篇，目标不算远大，但好好的去完成也需要一些精力，关键是要对当前的自己要有用处。\\n ## 10、总结\\n  - 35岁真的会被毕业吗？而且是会被永久毕业吗？如果身边的朋友、同学、又或者是同学的朋友、同事的朋友等等真的是大批量的都被毕业了，那么我才会觉得风险是真的来了。\\n\\n  - 现在就是时刻准备着可能要发生的事情，企业如果真不行了，或者自己真的想换工作了，就提前准备不就完事了。\\n  - 说真的每天时间就那么有限，自从你有了家，有了娃，时间就如白驹过隙\\n  \\n  - 没什么负面情绪，如果有的话就转化为正面动力吧\\n  \\n  - 浅层的学习靠输入，深层的学习靠输出：通过几期的学习源码，能深刻感受到自己看一遍和写一遍真的是非常不一样\\n  - 兄弟们加油吧，也许在疫情的催化下底层人民过的将会更加艰苦，多关照一下家里的老年人\\n  \\n  - 在疫情的催化下我们也要重新考虑一下我们的工作和生活方式了\\n\\n - 喜欢的可以到创作者榜单点点我，估计也没几个人点我哈哈，自己点自己嘞\\n\\n\\n "
    },
    {
        "article_id": "7184249126669221946",
        "cover_image": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/16fdbf2bda5845068647fb1146983e1d~tplv-k3u1fbpfcp-watermark.image?",
        "title": "揭秘web3元宇宙千万级项目的财富密码：凭什么一个div卖一千块？",
        "brief": "最近有朋友给我分享了一个元宇宙项目，非常赚钱。它长下面这个样子： 一个 44*44 的 div 小格子，卖价从 100 元到 1300 元不等，越靠上面的格子越贵，因为曝光率越高。你买了这个小格子",
        "user_name": "代码与野兽",
        "view_count": 14441,
        "collect_count": 53,
        "comment_count": 32,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/dac9f5ba3e7b6d8015a9b37536d4ef59~300x300.image",
        "category": "前端",
        "content": "# 基本介绍\\n\\n最近有朋友给我分享了一个元宇宙项目，非常赚钱。它长下面这个样子：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb5dbaef6a7b4773b88dadae35f03f6a~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n一个 44*44 的 div 小格子，卖价从 100 元到 1300 元不等，越靠上面的格子越贵，因为曝光率越高。你买了这个小格子，就可以放一张图片或者文字，别人就可以看到，然后联系你。像这种格子，每个区有 2400 个，每个城市可以有 N 个区，可以通过投票的方式扩张区块。那有多少个城市呢？\\n\\n现实有多少个，这里面就有多少个。截止 2021 年，中国已经有 691 个城市了。2022 年的数据还没出来，我估计会突破 700 个。\\n\\n而且它还可以创建城市，也就意味着它可以无限增长。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f76dcc4e4a0b484bb74645ca5ba36728~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n像这类项目还有很多，属于割韭菜的老玩法了。\\n\\n下面我开始分析一下这类项目。\\n\\n声明一下：不针对这个项目，也不透露项目名字和更多信息，所有相关信息均有特殊处理。如果认出来是哪个项目，也请不要说出来，谢谢。如有雷同，纯属巧合。\\n\\n揭秘项目是一件很伤人的事情，断人财路如杀人父母。\\n\\n但我想让更多人了解更多 Web3 的套路、打破黑箱子、去除魔法、看到本质。防止更多人踩雷当韭菜，我必须这么做。项目方，得罪了！\\n\\n# 技术分析\\n\\n首先科普一下区块链的类型，防止有些人不明白。\\n\\n目前区块链分三种：公链、联盟链、私有链。\\n\\n主要的差异在于去中心化的程度，公链完全公开、完全透明，人人皆可参与，以太坊、比特币都是这类。联盟链半公开、半透明，只能由特定的成员和有限的第三方参与，IBM 的 Fabrice 就是这类。私有链的读写权、记账权都在一个组织手里。不公开也不透明。\\n\\n上述这类项目基本上都是基于私有链进行开发的。\\n\\n现在，关于私有链是什么，你应该有了一个基本印象。什么人最喜欢私有链呢？诈骗团队。\\n\\n三种类型的区块链同样是区块链，但不一定所有基于区块链的应用都是安全的。如果你要入局某个区块链应用，最好选择公链，其次选择联盟链，至于私链，一定要慎之又慎。很多韭菜就是因为分不清链的类型才被割。\\n\\n总结一下，假联盟链和私有链是不可信的。和 Web2 中心化的服务没什么本质上的区别。另外，即使是公链也同样可能存在问题。\\n\\n聊完区块链端，再聊聊前端。\\n\\n可能很多人接触元宇宙的人都听过各种类似这样的宣传：**元宇宙的基础是 3D 和 VR，是立体感、沉浸感、虚拟现实感**。\\n\\n我不能说这是错的，但这不是元宇宙的底层核心逻辑。这从技术角度出发是没问题的，但这些都只是一种交互方式而已，不是必须，传统的交互形式同样不影响赚钱。\\n\\n元宇宙更重要的一个玩法，很多人都不了解，那就是虚拟地产。在虚拟地产中，只要保证这个虚拟资产的唯一性和权利明确就够了。至于虚拟资产对应的是一个 div 还是一个 3D 模型，不重要，真的不重要。\\n\\n只要你买了虚拟土地，就可以在土地上去做你想要做的事。比如打广告，或者像现实世界一样去炒房。\\n\\n这也就是为什么人人都可以写一个 div，你的 div 一文不值，而别人的 div 值上千块的原因。div 不重要，重要的是 div 背后蕴含的东西。\\n\\n**摆脱技术视角，才能看清商业的全貌。**\\n\\n那这种项目难度如何？\\n\\n技术上并不难，这种项目我的团队半个月内就可以做出来。\\n\\n但我们却做不到，为什么呢？\\n\\n这和技术关系就不大了。其实技术一点儿都不重要，重要的是商业模式，也就是下面我要讲的部分。\\n\\n# 商业模式\\n\\n虽然我已经处于 All in Web3 的边缘状态。但我不能回避 Web3 的问题。\\n\\n目前所有 Web3 的项目，实际价值都非常有限。特别像这种打着元宇宙旗号的虚拟地产项目。\\n\\n有任何价值吗？主要的用途就只有打广告而已，除此之外没有任何实际价值。这事儿，放到 Web2 里面做，所需要花费的成本将会远远降低。\\n\\n可能你会想，这种产品，会有人买吗？确实会有人买。\\n\\n这个问题就像是为什么传销这种东西都有人信呢？\\n\\n从技术角度想的话，你永远都想不明白。因为这是理性人的思考。事实是：现实世界里无论多么愚蠢的谎言，总会有人信。\\n\\n这种产品，需要很强的市场营销能力。\\n\\n他们会在非常豪华的酒店举办发布会，会请很多拖儿来渲染气氛，会请一些名人来充当门面，会找一些媒体来进行采访报道。\\n\\n总之，需要把这个一文不值的 div 包装成无价之宝。\\n\\n只要你相信它值钱，它就真的值钱。这个玩法就是资金盘。\\n\\n只有初始用户是不够的，如果用户不能源源不断地增加，那么再好的项目也会逐渐走向死亡。很多 Web3 项目归零，就是因为它的支持者越来越少。所以必须让更多的人加入进来。**Web3 项目，流通性是核心。**\\n\\n怎么让新用户加入呢？让初始支持者去自发地、主动地帮我们推广就可以了。当然这需要利益驱动。比如你分享你的专属链接给你的朋友，你的朋友花了 1000 块买了一块地皮后，平台收 6 成，剩下的 4 成，也就是 400 块就归你了。这和传统的病毒营销一模一样。\\n\\n同时把现实世界炒房的概念挪进虚拟地产中：比如你花 1200 买了个 div，可以继续以 1500 的价格售卖，只要有人愿意买，你就能赚钱。只要有源源不断的人加入进来，虚拟地产就能炒起来。可能炒到几万、几十万都有可能。但背后的真正价值是什么？div 仍旧是一个 div。\\n\\n这个玩法就是传销盘。\\n\\n上面这一套玩法组合起来，就是庞氏骗局、杀猪盘。\\n\\n这也是为什么在大陆做 Web3 很容易游走于法律边缘的原因。\\n\\n国内法律明确禁止通过发行代币或 NFT 进行融资、以及在二级市场炒作是有原因的。\\n\\n大多数 Web3 项目都会和它打擦边球。比如虚拟地产这类项目，虽然它具有 NFT 的属性，但它并不是 NFT，实际上只是购买了平台提供的服务。一旦平台出现问题，钱也就打了水漂。这和传统 Web2 的模式几乎没什么区别。但因为有金融属性在里面，很容易被扣上非法融资的帽子。\\n\\n如果你真的想买 Web3 产品，建议去买有顶级大平台背书的产品。至于哪些是顶级大平台，我就不再举例了，我也不会提供任何投资建议。\\n\\n最后谈下我从自己亲身经历 Web3 血与泪的过去中总结的经验：**不要以为自己看了一些视频、读了一些文章、接触了几个项目，就认为自己很懂 Web3 了。杀猪盘杀的就是这些似懂非懂的猪。** 目前网上大多数讲 Web3 各种分析、趋势的文章、视频都有营销成分。没有自己的理解和判断，Web3 是很难玩明白的。\\n\\n我认为**作为一个开发者，参与 Web3 更合适的渠道是以技术的方式为一些 Web3 公司工作。** 大部分 Web3 的公司都是远程工作方式。不用 996，不用挤地铁，还能拿到高薪。你完全可以在十八线小县城赚美元，进入 work life balance 的状态。最近两年从大厂辞职投入 Web3 阵营的开发者已经屡见不鲜，这或许是告别卷成一团乱麻的传统互联网的新方式。\\n\\n我们是一群立志改变世界的人。而 Web3 是未来世界一大变数，我们想帮助更多人了解并加入 Web3，如果你对 Web3 感兴趣，可以添加我的微信：LZQ20130415，邀你入群，一起沉淀、一起成长、一起拥抱未来。"
    },
    {
        "article_id": "7186859098661453884",
        "cover_image": "",
        "title": "深入理解 go reflect - 反射为什么慢",
        "brief": "我们选择 go 语言的一个重要原因是，它有非常高的性能。但是它反射的性能却一直为人所诟病，本篇文章就来看看 go 反射的性能问题。",
        "user_name": "eleven26",
        "view_count": 7190,
        "collect_count": 17,
        "comment_count": 3,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/63902aab0d2cb93d3bc92df504a1d98d~300x300.image",
        "category": "后端",
        "content": "我们选择 go 语言的一个重要原因是，它有非常高的性能。但是它反射的性能却一直为人所诟病，本篇文章就来看看 go 反射的性能问题。\\n\\n## go 的性能测试\\n\\n在开始之前，有必要先了解一下 go 的性能测试。在 go 里面进行性能测试很简单，只需要在测试函数前面加上 `Benchmark` 前缀，\\n然后在函数体里面使用 `b.N` 来进行循环，就可以得到每次循环的耗时。如下面这个例子：\\n\\n```go\\nfunc BenchmarkNew(b *testing.B) {\\n   b.ReportAllocs()\\n   for i := 0; i < b.N; i++ {\\n      New()\\n   }\\n}\\n```\\n\\n我们可以使用命令 `go test -bench=. reflect_test.go` 来运行这个测试函数，又或者如果使用 goland 的话，直接点击运行按钮就可以了。\\n\\n说明：\\n\\n* 在 `*_test.go` 文件中 `Benchmark*` 前缀函数是性能测试函数，它的参数是 `*testing.B` 类型。\\n* `b.ReportAllocs()`：报告内存分配次数，这是一个非常重要的指标，因为**内存分配相比单纯的 CPU 计算是比较耗时的操作**。在性能测试中，我们需要关注内存分配次数，以及每次内存分配的大小。\\n* `b.N`：是一个循环次数，每次循环都会执行 `New()` 函数，然后记录下来每次循环的耗时。\\n\\n> go 里面很多优化都致力于减少内存分配，减少内存分配很多情况下都可以提高性能。\\n\\n输出：\\n\\n```\\nBenchmarkNew-20    1000000000    0.1286 ns/op   0 B/op   0 allocs/op\\n```\\n\\n输出说明：\\n\\n* `BenchmarkNew-20`：`BenchmarkNew` 是测试函数名，`-20` 是 CPU 核数。\\n* `1000000000`：循环次数。\\n* `0.1286 ns/op`：每次循环的耗时，单位是纳秒。这里表示每次循环耗时 0.1286 纳秒。\\n* `0 B/op`：每次循环内存分配的大小，单位是字节。这里表示每次循环没有分配内存。\\n* `0 allocs/op`：每次循环内存分配的次数。这里表示每次循环没有分配内存。\\n\\n## go 反射慢的原因\\n\\n> 动态语言的灵活性是以牺牲性能为代价的，go 语言也不例外，go 的 interface{} 提供了一定的灵活性，但是处理 interface{} 的时候就要有一些性能上的损耗了。\\n\\n我们都知道，go 是一门静态语言，这意味着我们在编译的时候就知道了所有的类型，而不是在运行时才知道类型。\\n但是 go 里面有一个 `interface{}` 类型，它可以表示任意类型，这就意味着我们可以在运行时才知道类型。\\n但本质上，`interface{}` 类型还是静态类型，只不过它的类型和值是动态的。\\n在 `interface{}` 类型里面，存储了两个指针，一个指向类型信息，一个指向值信息。具体可参考[《go interface 设计与实现》](https://juejin.cn/post/7173965896656879630)。\\n\\n### go interface{} 带来的灵活性\\n\\n有了 `interface{}` 类型，让 go 也拥有了动态语言的特性，比如，定义一个函数，它的参数是 `interface{}` 类型，\\n那么我们就可以传入任意类型的值给这个函数。比如下面这个函数（做任意整型的加法，返回 `int64` 类型）：\\n\\n```go\\nfunc convert(i interface{}) int64 {\\n   typ := reflect.TypeOf(i)\\n   switch typ.Kind() {\\n   case reflect.Int:\\n      return int64(i.(int))\\n   case reflect.Int8:\\n      return int64(i.(int8))\\n   case reflect.Int16:\\n      return int64(i.(int16))\\n   case reflect.Int32:\\n      return int64(i.(int32))\\n   case reflect.Int64:\\n      return i.(int64)\\n   default:\\n      panic(\\\"not support\\\")\\n   }\\n}\\n\\nfunc add(a, b interface{}) int64 {\\n   return convert(a) + convert(b)\\n}\\n```\\n\\n说明：\\n\\n* `convert()` 函数：将 `interface{}` 类型转换为 `int64` 类型。对于非整型的类型，会 panic。（当然不是很严谨，还没涵盖 `uint*` 类型）\\n* `add()` 函数：做任意整型的加法，返回 `int64` 类型。\\n\\n相比之下，如果是确定的类型，我们根本不需要判断类型，直接相加就可以了：\\n\\n```go\\nfunc add1(a, b int64) int64 {\\n   return a + b\\n}\\n```\\n\\n我们可以通过以下的 benchmark 来对比一下：\\n\\n```go\\nfunc BenchmarkAdd(b *testing.B) {\\n   b.ReportAllocs()\\n   for i := 0; i < b.N; i++ {\\n      add(1, 2)\\n   }\\n}\\n\\nfunc BenchmarkAdd1(b *testing.B) {\\n   b.ReportAllocs()\\n   for i := 0; i < b.N; i++ {\\n      add1(1, 2)\\n   }\\n}\\n```\\n\\n结果：\\n\\n```\\nBenchmarkAdd-12         179697526                6.667 ns/op           0 B/op          0 allocs/op\\nBenchmarkAdd1-12        1000000000               0.2353 ns/op          0 B/op          0 allocs/op\\n```\\n\\n我们可以看到非常明显的性能差距，`add()` 要比 `add1()` 慢了非常多，而且这还只是做了一些简单的类型判断及类型转换的情况下。\\n\\n### go 灵活性的代价（慢的原因）\\n\\n通过这个例子我们知道，go 虽然通过 `interface{}` 为我们提供了一定的灵活性支持，但是使用这种动态的特性是有一定代价的，比如：\\n\\n* 我们在运行时才知道类型，那么我们就需要在运行时去做类型判断（也就是通过**反射**），这种判断会有一定开销（本来是确定的一种类型，但是现在可能要在 20 多个类型中匹配才能确定它的类型是什么）。同时，判断到属于某一类型之后，往往需要转换为具体的类型，这也是一种开销。\\n* 同时，我们可能需要去做一些属性、方法的查找等操作（`Field`, `FieldByName`, `Method`, `MethodByName`），这些操作都是在运行时做的，所以会有一定的性能损耗。\\n* 另外，在做属性、方法之类的查找的时候，查找性能取决于属性、方法的数量，如果属性、方法的数量很多，那么查找性能就会相对慢。**通过 index (`Field`, `Method`)查找相比通过 name (`FieldByName`, `MethodByName`)查找快很多，后者有内存分配的操作**\\n* 在我们通过反射来做这些操作的时候，多出了很多操作，比如，简单的两个 `int` 类型相加，本来可以直接相加。但是通过反射，我们不得不先根据 `interface{}` 创建一个反射对象，然后再做类型判断，再做类型转换，最后再做加法。\\n\\n**总的来说，go 的 interface{} 类型虽然给我们提供了一定的灵活性，让开发者也可以在 go 里面实现一些动态语言的特性，**\\n**但是这种灵活性是以牺牲一定的性能来作为代价的，它会让一些简单的操作变得复杂，一方面生成的编译指令会多出几十倍，另一方面也有可能在这过程有内存分配的发生（比如 `FieldByName`）。**\\n\\n## 慢是相对的\\n\\n从上面的例子中，我们发现 go 的反射好像慢到了让人无法忍受的地步，然后就有人提出了一些解决方案，\\n比如：**通过代码生成的方式避免运行时的反射操作，从而提高性能。比如 easyjson**\\n\\n但是这类方案都会让代码变得繁杂起来。我们需要权衡之后再做决定。为什么呢？因为反射虽然慢，但我们要知道的是，如果我们的应用中有网络调用，**任何一次网络调用的时间往往都不会少于 1ms，而这 1ms 足够 go 做很多次反射操作了**。这给我们什么启示呢？如果我们不是做中间件或者是做一些高性能的服务，而是做一些 web 应用，那么我们可以考虑一下性能瓶颈是不是在反射这里，如果是，那么我们就可以考虑一下代码生成的方式来提高性能，如果不是，那么我们真的需要牺牲代码的可维护性、可读性来提高反射的性能吗？优化几个慢查询带来的收益是不是更高呢？\\n\\n## go 反射性能优化\\n\\n如果可以的话，**最好的优化就是不要用反射**。\\n\\n### 通过代码生成的方式避免序列化和反序列化时的反射操作\\n\\n这里以 `easyjson` 为例，我们来看一下它是怎么做的。假设我们有如下结构体，我们需要对其进行 json 序列化/反序列化：\\n\\n```go\\n// person.go\\ntype Person struct {\\n   Name string `json:\\\"name\\\"`\\n   Age  int    `json:\\\"age\\\"`\\n}\\n```\\n\\n使用 `easyjson` 的话，我们需要为结构体生成代码，这里我们使用 `easyjson` 的命令行工具来生成代码：\\n\\n```bash\\neasyjson -all person.go\\n```\\n\\n这样，我们就会在当前目录下生成 `person_easyjson.go` 文件，里面包含了 `MarshalJSON` 和 `UnmarshalJSON` 方法，这两个方法就是我们需要的序列化和反序列化方法。不同于标准库里面的 `json.Marshal` 和 `json.Unmarshal`，这两个方法是不需要反射的，它们的性能会比标准库的方法要好很多。\\n\\n```go\\nfunc easyjsonDb0593a3EncodeGithubComGinGonicGinCEasy(out *jwriter.Writer, in Person) {\\n   out.RawByte('{')\\n   first := true\\n   _ = first\\n   {\\n      const prefix string = \\\",\\\"name\\\":\\\"\\n      out.RawString(prefix[1:])\\n      out.String(string(in.Name))\\n   }\\n   {\\n      const prefix string = \\\",\\\"age\\\":\\\"\\n      out.RawString(prefix)\\n      out.Int(int(in.Age))\\n   }\\n   out.RawByte('}')\\n}\\n\\n// MarshalJSON supports json.Marshaler interface\\nfunc (v Person) MarshalJSON() ([]byte, error) {\\n   w := jwriter.Writer{}\\n   easyjsonDb0593a3EncodeGithubComGinGonicGinCEasy(&w, v)\\n   return w.Buffer.BuildBytes(), w.Error\\n}\\n```\\n\\n我们看到，我们对 `Person` 的序列化操作现在只需要几行代码就可以完成了，但是也有很明显的缺点，生成的代码会很多。\\n\\n性能差距：\\n\\n```go\\ngoos: darwin\\ngoarch: amd64\\npkg: github.com/gin-gonic/gin/c/easy\\ncpu: Intel(R) Core(TM) i7-8700 CPU @ 3.20GHz\\nBenchmarkJson\\nBenchmarkJson-12            3680560          305.9 ns/op      152 B/op         2 allocs/op\\nBenchmarkEasyJson\\nBenchmarkEasyJson-12       16834758           71.37 ns/op         128 B/op         1 allocs/op\\n```\\n\\n我们可以看到，使用 `easyjson` 生成的代码，序列化的性能比标准库的方法要好很多，好了 4 倍以上。\\n\\n### 反射结果缓存\\n\\n> 这种方法适用于需要根据名称查找结构体字段或者查找方法的场景。\\n\\n假设我们有一个结构体 `Person`，其中有 5 个方法，`M1`、`M2`、`M3`、`M4`、`M5`，我们需要通过名称来查找其中的方法，那么我们可以使用 `reflect` 包来实现：\\n\\n```go\\np := &Person{}\\nv := reflect.ValueOf(p)\\nv.MethodByName(\\\"M4\\\")\\n```\\n\\n这是很容易想到的办法，但是性能如何呢？通过性能测试，我们可以看到，这种方式的性能是非常差的：\\n\\n```go\\nfunc BenchmarkMethodByName(b *testing.B) {\\n   p := &Person{}\\n   v := reflect.ValueOf(p)\\n\\n   b.ReportAllocs()\\n   for i := 0; i < b.N; i++ {\\n      v.MethodByName(\\\"M4\\\")\\n   }\\n}\\n```\\n\\n结果：\\n\\n```\\nBenchmarkMethodByName-12         5051679               237.1 ns/op           120 B/op          3 allocs/op\\n```\\n\\n相比之下，我们如果使用索引来获取其中的方法的话，性能会好很多：\\n\\n```go\\nfunc BenchmarkMethod(b *testing.B) {\\n   p := &Person{}\\n   v := reflect.ValueOf(p)\\n\\n   b.ReportAllocs()\\n   for i := 0; i < b.N; i++ {\\n      v.Method(3)\\n   }\\n}\\n```\\n\\n结果：\\n\\n```\\nBenchmarkMethod-12              200091475                5.958 ns/op           0 B/op          0 allocs/op\\n```\\n\\n我们可以看到两种性能相差几十倍。那么我们是不是可以通过 `Method` 方法来替代 `MethodByName` 从而获得更好的性能呢？答案是可以的，我们可以缓存 `MethodByName` 的结果（就是方法名对应的下标），下次通过反射获取对应方法的时候直接通过这个下标来获取：\\n\\n> 这里需要通过 reflect.Type 的 MethodByName 来获取反射的方法对象。\\n\\n```go\\n// 缓存方法名对应的方法下标\\nvar indexCache = make(map[string]int)\\n\\nfunc methodIndex(p interface{}, method string) int {\\n   if _, ok := indexCache[method]; !ok {\\n      m, ok := reflect.TypeOf(p).MethodByName(method)\\n      if !ok {\\n         panic(\\\"method not found!\\\")\\n      }\\n\\n      indexCache[method] = m.Index\\n   }\\n\\n   return indexCache[method]\\n}\\n```\\n\\n性能测试：\\n\\n```go\\nfunc BenchmarkMethodByNameCache(b *testing.B) {\\n   p := &Person{}\\n   v := reflect.ValueOf(p)\\n\\n   b.ReportAllocs()\\n   var idx int\\n   for i := 0; i < b.N; i++ {\\n      idx = methodIndex(p, \\\"M4\\\")\\n      v.Method(idx)\\n   }\\n}\\n```\\n\\n结果：\\n\\n```\\n// 相比原来的 MethodByName 快了将近 20 倍\\nBenchmarkMethodByNameCache-12           86208202                13.65 ns/op            0 B/op          0 allocs/op\\nBenchmarkMethodByName-12                 5082429               235.9 ns/op           120 B/op          3 allocs/op\\n```\\n\\n> 跟这个例子类似的是 Field/FieldByName 方法，可以采用同样的优化方式。这个可能是更加常见的操作，反序列化可能需要通过字段名查找字段，然后进行赋值。\\n\\n### 使用类型断言代替反射\\n\\n在实际使用中，如果只是需要进行一些简单的类型判断的话，比如判断是否实现某一个接口，那么可以使用类型断言来实现：\\n\\n```go\\ntype Talk interface {\\n   Say()\\n}\\n\\ntype person struct {\\n}\\n\\nfunc (p person) Say() {\\n}\\n\\nfunc BenchmarkReflectCall(b *testing.B) {\\n   p := person{}\\n   v := reflect.ValueOf(p)\\n\\n   for i := 0; i < b.N; i++ {\\n      idx := methodIndex(&p, \\\"Say\\\")\\n      v.Method(idx).Call(nil)\\n   }\\n}\\n\\nfunc BenchmarkAssert(b *testing.B) {\\n   p := person{}\\n\\n   for i := 0; i < b.N; i++ {\\n      var inter interface{} = p\\n      if v, ok := inter.(Talk); ok {\\n         v.Say()\\n      }\\n   }\\n}\\n```\\n\\n结果：\\n\\n```\\ngoos: darwin\\ngoarch: amd64\\ncpu: Intel(R) Core(TM) i7-8700 CPU @ 3.20GHz\\nBenchmarkReflectCall-12          6906339               173.1 ns/op\\nBenchmarkAssert-12              171741784                6.922 ns/op\\n```\\n\\n在这个例子中，我们就算使用了缓存版本的反射，性能也跟类型断言差了将近 25 倍。\\n\\n> 因此，在我们使用反射之前，我们需要先考虑一下是否可以通过类型断言来实现，如果可以的话，那么就不需要使用反射了。\\n\\n## 总结\\n\\n* go 提供了性能测试的工具，我们可以通过 `go test -bench=.` 这种命令来进行性能测试，运行命令之后，文件夹下的测试文件中的 `Benchmark*` 函数会被执行。\\n* 性能测试的结果中，除了平均执行耗时之外，还有内存分配的次数和内存分配的字节数，这些都是我们需要关注的指标。其中内存分配的次数和内存分配的字节数是可以通过 `b.ReportAllocs()` 来进行统计的。内存分配的次数和内存分配的字节数越少，性能越好。\\n* 反射虽然慢，但是也带来了一定的灵活性，它的慢主要由以下几个方面的原因造成的：\\n  * 运行时需要进行类型判断，相比确定的类型，运行时可能需要在 20 多种类型中进行判断。\\n  * 类型判断之后，往往需要将 `interface{}` 转换为具体的类型，这个转换也是需要消耗一定时间的。\\n  * 方法、字段的查找也是需要消耗一定时间的。尤其是 `FieldByName`, `MethodByName` 这种方法，它们需要遍历所有的字段和方法，然后进行比较，这个比较的过程也是需要消耗一定时间的。而且这个过程还需要分配内存，这会进一步降低性能。\\n* 慢不慢是一个相对的概念，如果我们的应用大部分时间是在 IO 等待，那么反射的性能大概率不会成为瓶颈。优化其他地方可能会带来更大的收益，同时也可以在不影响代码可维护性的前提下，使用一些时空复杂度更低的反射方法，比如使用 `Field` 代替 `FieldByName` 等。\\n* 如果可以的话，尽量不使用反射就是最好的优化。\\n* 反射的一些性能优化方式有如下几种（不完全，需要根据实际情况做优化）：\\n  * 使用生成代码的方式，生成特定的序列化和反序列化方法，这样就可以避免反射的开销。\\n  * 将第一次反射拿到的结果缓存起来，这样如果后续需要反射的话，就可以直接使用缓存的结果，避免反射的开销。（**空间换时间**）\\n  * 如果只是需要进行简单的类型判断，可以先考虑一下类型断言能不能实现我们想要的效果，它相比反射的开销要小很多。\\n\\n反射是一个很庞大的话题，这里只是简单的介绍了一小部分反射的性能问题，讨论了一些可行的优化方案，但是每个人使用反射的场景都不一样，所以需要根据实际情况来做优化。"
    },
    {
        "article_id": "7167355169934409758",
        "cover_image": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bac9edafeda14bebb321689957757f31~tplv-k3u1fbpfcp-watermark.image?",
        "title": "CSS 的快乐：画一个可爱的三只小鸟 Button",
        "brief": "做为前端工程师，最大的快乐之一就是可以用 CSS 画出各种有趣的效果。 比如我最近画的一个 Button： 画的过程中确实很开心，这也是我当时选择做前端的很大一部分原因。 今天我们就一起来画下这个可爱",
        "user_name": "zxg_神说要有光",
        "view_count": 11248,
        "collect_count": 392,
        "comment_count": 57,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/4e9e751e2b32fb8afbbf559a296ccbf2~300x300.image",
        "category": "前端",
        "content": "做为前端工程师，最大的快乐之一就是可以用 CSS 画出各种有趣的效果。\\n\\n比如我最近画的一个 Button：\\n\\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8cfe464929c448648c2dae4a5d6eb788~tplv-k3u1fbpfcp-watermark.image?)\\n\\n画的过程中确实很开心，这也是我当时选择做前端的很大一部分原因。\\n\\n今天我们就一起来画下这个可爱的 Button 吧！纯 CSS，没用到图片和 JS 呦～\\n\\n首先我们需要一些前置知识：\\n\\n## border-radius\\n\\nborder-radius 大家用的比较多了。\\n\\n比如一个这样的 div：\\n\\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b1c43a346104433aa07275e939fe5bd~tplv-k3u1fbpfcp-watermark.image?)\\n\\n```css\\n#box {\\n    width: 100px;\\n    height: 100px;\\n    background: #f4cf47;\\n    border: solid 3px #000;\\n}\\n```\\n可以分别设置四个圆角的半径：\\n\\n```css\\n#box {\\n    border-radius: 20px 30px 40px 50px;\\n}\\n```\\n\\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3866bc394b11482dbb36b83ccc70d912~tplv-k3u1fbpfcp-watermark.image?)\\n\\n从效果上也可以看出来分别是左上、右上、左下、右下的圆角。\\n\\n其实还可以设置椭圆角，椭圆和圆的区别是圆的半径都是一样的，而椭圆则是有长轴和短轴，可以不一样。\\n\\n可以分别设置长半轴和短半轴的长度，用 / 隔开：\\n\\n```css\\n#box {\\n    border-radius: 20px 30px 40px 50px / 20px 30px 40px 50px;\\n}\\n```\\n\\n当然，上面这个长短半轴相等了，也就是圆角了。\\n\\n比如这样设置：\\n\\n```css\\n#box {\\n    border-radius: 20px 30px 40px 50px / 50px 40px 30px 20px;\\n}\\n```\\n\\n效果是这样的：\\n\\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30a3d98830bd4bec971f8dcf49d0c7ab~tplv-k3u1fbpfcp-watermark.image?)\\n\\n分开看每个角：\\n\\n左上角的横半轴是 20px，竖半轴是 50px，所以是这样的：\\n\\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/168af858fe96430792ed765e6b57ef3e~tplv-k3u1fbpfcp-watermark.image?)\\n\\n左下角横半轴是 40px，竖半轴是 30px，所以是这样的：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/28d73a9894b644b787930fc8bf2b27f2~tplv-k3u1fbpfcp-watermark.image?)\\n\\n通过调整四个角的横竖半轴长度，就可以实现很多形状。\\n\\n比如三只小鸟的睡觉时的形状：\\n\\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9395e1a20e304ecfb9031521cce643a7~tplv-k3u1fbpfcp-watermark.image?)\\n\\n或者醒的时候的形状：\\n\\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c4070243a20a4abcb0d3d93c496adab6~tplv-k3u1fbpfcp-watermark.image?)\\n\\n还有鸟嘴和眼睛的形状：\\n\\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/775891a0d326492e9b169bf0a8f0868c~tplv-k3u1fbpfcp-watermark.image?)\\n\\n当然，圆角能画的形状终究还是受限制的，更复杂的形状需要用别的方式来画，比如 clip-path：\\n\\n## clip-path\\n\\n前面说过，整个按钮都没有用到图片，那按钮的这个背景：\\n\\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be2394defe4d4a588c5aa6616d169a74~tplv-k3u1fbpfcp-watermark.image?)\\n\\n还有这几根鸟毛：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/463da5bf33ff415ea86a796b86a16e4a~tplv-k3u1fbpfcp-watermark.image?)\\n\\n怎么画呢？\\n\\nborder-radius？\\n\\nborder-radius 再怎么调也只是各种椭圆，没法画这种复杂形状。\\n\\n想实现这些没有规律的复杂形状就要用到 cli-path 了。\\n\\n比如这样一个 div：\\n\\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd71d80660bb49f8a88a6698cc1091a2~tplv-k3u1fbpfcp-watermark.image?)\\n\\n```css\\n #box {\\n    width: 130px;\\n    height: 38px;\\n    background: blue;\\n}\\n```\\n加上这样一个 clip-path:\\n\\n```\\n#box {\\n    clip-path : path('M13.77,37.35L.25,16.6c-.87-1.33,.69-2.91,2-2.02l12.67,8.59c.81,.55,1.91,.14,2.18-.81l2.62-9.33c.39-1.4,2.34-1.42,2.76-.02l3.6,11.99c.33,1.11,1.74,1.4,2.47,.52L49.38,.52c.87-1.04,2.53-.42,2.53,.95V23.7c0,1.13,1.2,1.83,2.16,1.26l12.75-7.51c.85-.5,1.94,0,2.13,.98l1.5,7.6c.2,1.03,1.37,1.51,2.22,.92l17.74-12.3c1.09-.75,2.52,.25,2.21,1.55l-2.44,10.2c-.26,1.09,.74,2.06,1.8,1.75l30.8-9.04c1.37-.4,2.42,1.26,1.49,2.36l-9.07,10.66c-.83,.98-.1,2.49,1.17,2.42l12.12-.68c1.6-.09,2.12,2.15,.65,2.8l-2.73,1.21c-.18,.08-.38,.12-.58,.12H14.97c-.48,0-.93-.25-1.2-.65Z') ;\\n}\\n```\\n就会变成这种形状：\\n\\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c3035dacccb414197c4fc321fd93d1b~tplv-k3u1fbpfcp-watermark.image?)\\n\\n或者这样一个 div：\\n\\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c8799c39f8e4489e9f4c9b680753821d~tplv-k3u1fbpfcp-watermark.image?)\\n\\n```css\\n#box {\\n    width: 12px;\\n    height: 12px;\\n    background: #000;\\n}\\n```\\n加上这样的 clip-path：\\n\\n```css\\n#box {\\n    clip-path : path('M10.23,3.32c-3.54,.63-5.72,2.51-7.02,4.23-.33-1.58-.34-3.54,.93-5.12,.52-.65,.41-1.59-.24-2.11C3.24-.19,2.29-.08,1.77,.57c-3.82,4.77-.31,11.11-.13,11.42,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0-.01-.02,2.49,.04,2.52,0,.1-.14,1.54-4.82,6.59-5.71,.82-.14,1.37-.92,1.22-1.74s-.94-1.36-1.75-1.21Z') ;\\n\\n}\\n```\\n就会变成这种形状：\\n\\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/60172d34bec5451fa922c6b04a906a68~tplv-k3u1fbpfcp-watermark.image?)\\n\\n背景和鸟毛不就出来了么～\\n\\n这个样式还是很容易理解的，就像剪纸一样，把一块区域按照某个路径进行裁剪（svg 中也有这个）。\\n\\n当然，不只可以写 path，还支持别的形状：\\n\\n```css\\nclip-path: circle(40%);\\nclip-path: ellipse(130px 140px at 10% 20%);\\nclip-path: polygon(50% 0, 100% 50%, 50% 100%, 0 50%);\\nclip-path: path('M 0 200 L 0,75 A 5,5 0,0,1 150,75 L 200 200 z');\\n```\\n但是，这个形状怎么来呢？\\n\\n手写么？\\n\\n这肯定不靠谱。\\n\\n其实是可以用 illustrator 等矢量图设计软件来画，导出为 svg 的。\\n\\n比如 illustrator，用钢笔在左上角画一个形状：\\n\\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d0d6c3d81bf24bd7baa0dce30ea92a52~tplv-k3u1fbpfcp-watermark.image?)\\n\\n选中它，然后点击“对象 > 复合路径 > 建立”：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e86d258e7b0045afbfd7d79702fb69d1~tplv-k3u1fbpfcp-watermark.image?)\\n\\n再点击导出，这时候导出的就是带 path 的 svg。\\n\\n有两点需要注意：\\n- 要从左上角开始画，因为 svg 会把位移保存下来。\\n- 没有复合路径那一步，导出的可能是 polygon、circle 这种形状，而不是 path\\n\\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f2d5006f0849465791583aa73915dee5~tplv-k3u1fbpfcp-watermark.image?)\\n\\n把路径复制到 cli-path 的样式处，就可以看到裁切后的效果了：\\n\\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de5a0e22da2b4dfd934a88d7196f01d5~tplv-k3u1fbpfcp-watermark.image?)\\n\\n这样，涉及到的各种形状我们就都能画了。\\n\\n再看一眼这个 Button：\\n\\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8cfe464929c448648c2dae4a5d6eb788~tplv-k3u1fbpfcp-watermark.image?)\\n\\n是不是就有思路了呢～\\n\\n接下来我们动手画一下吧。\\n\\n## 画 Button\\n\\n先写出 html 的结构：\\n\\n```javascript\\n<a href=\\\"#\\\" class=\\\"button button--bird\\\">\\n    <div class=\\\"button__wrapper\\\">\\n        <span class=\\\"button__text\\\">ENTRY</span>\\n    </div>\\n</a>\\n```\\n比一般的 button 多了一级，这是因为我们要通过每一级的 ::before 和 ::after 加一些伪元素。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3fae0c86cd8a4e08b6ae9c706e37b815~tplv-k3u1fbpfcp-watermark.image?)\\n\\n设置 .button 的样式：\\n```css\\n.button {\\n    display: flex;\\n    justify-content: center;\\n    align-items: center;\\n\\n    box-sizing: border-box;\\n    width: 280px;\\n    height: 80px;\\n\\n    text-decoration: none;\\n    border: solid 3px #000;\\n    border-radius: 40px;\\n    background: #f4cf47;\\n}\\n```\\n\\n通过 flex 布局，让子元素居中。设置 width、height，背景颜色、圆角等。\\n\\n现在效果是这样的：\\n\\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e983f169b1da45c18e18a187ed4fe671~tplv-k3u1fbpfcp-watermark.image?)\\n\\n其中的背景颜色可能会变，更好的方式是抽出一个变量来维护：\\n\\n```css\\n.button--bird {\\n    --main_color: #f4cf47;\\n}\\n.button {\\n    background : var(--main_color);\\n}\\n```\\n\\n然后设置子元素的样式，也就是 .button__warpper：\\n```css\\n.button__wrapper{\\n    display: flex;\\n    justify-content: center;\\n    align-items: center;\\n\\n    width: 100%;\\n    height: 100%;\\n}\\n```\\n\\n它同样要设置子元素居中，然后宽高都是 100%。\\n\\n它的子元素就是 span 文本标签了，也就是 .button__text：\\n\\n```css\\n.button--bird {\\n    --base_color: #000;\\n}\\n.button__text{\\n    font-size: 32px;\\n    letter-spacing: 4px;\\n    color: var(--base_color);\\n}\\n```\\n指定字体大小、文字间距和颜色。颜色是可能会变的，所以也抽成变量。\\n\\n现在的效果是这样的：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/57288e0c518745e7ba90582c11b03f20~tplv-k3u1fbpfcp-watermark.image?)\\n\\n然后我们加上一些伪元素做装饰：\\n\\n先给最外层元素加：\\n\\n```css\\n.button::before{\\n    content: '';\\n   \\n    position: absolute;\\n    right: 20px;\\n\\n    margin: auto 0;\\n    width: 24px;\\n    height: 24px;\\n  \\n    background: var(--base_color);\\n    clip-path: path('M24,12.02c0-1.09-.75-1.71-.81-1.77L11.17,.45c-.91-.74-2.21-.56-2.91,.42-.69,.97-.52,2.37,.39,3.11l7.12,5.81-13.7-.02h0C.93,9.77,0,10.76,0,11.99c0,1.23,.93,2.22,2.07,2.22l13.7,.02-7.13,5.78c-.91,.74-1.09,2.13-.4,3.11,.41,.58,1.03,.88,1.65,.88,.44,0,.88-.15,1.25-.45l12.04-9.76c.07-.06,.82-.67,.82-1.77Z');\\n}\\n```\\n指定宽高和位置，还有背景颜色，再就是裁切的形状（这里用 clip-path 裁剪的是一个箭头的形状）\\n\\n伪元素用了绝对定位，那元素就要相对定位：\\n\\n```css\\n.button {\\n    position: relative;\\n}\\n```\\n也就是让伪元素相对它来偏移。\\n\\n效果就是这样的：\\n\\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f17fcdf91a704265a8bcf35bde92b74f~tplv-k3u1fbpfcp-watermark.image?)\\n\\n然后再往里一层，给 .button__wrapper 加 ::before 和 ::after 伪元素：\\n\\n```css\\n.button--bird {\\n    --sub_color1: #f4e19c;\\n}\\n.button--bird .button__wrapper::before,\\n.button--bird .button__wrapper::after{\\n    content: '';\\n\\n    position: absolute;\\n    bottom: 0;\\n\\n    width: 130px;\\n    height: 38px;\\n\\n    background: var(--sub_color1);\\n\\n    clip-path: path('M13.77,37.35L.25,16.6c-.87-1.33,.69-2.91,2-2.02l12.67,8.59c.81,.55,1.91,.14,2.18-.81l2.62-9.33c.39-1.4,2.34-1.42,2.76-.02l3.6,11.99c.33,1.11,1.74,1.4,2.47,.52L49.38,.52c.87-1.04,2.53-.42,2.53,.95V23.7c0,1.13,1.2,1.83,2.16,1.26l12.75-7.51c.85-.5,1.94,0,2.13,.98l1.5,7.6c.2,1.03,1.37,1.51,2.22,.92l17.74-12.3c1.09-.75,2.52,.25,2.21,1.55l-2.44,10.2c-.26,1.09,.74,2.06,1.8,1.75l30.8-9.04c1.37-.4,2.42,1.26,1.49,2.36l-9.07,10.66c-.83,.98-.1,2.49,1.17,2.42l12.12-.68c1.6-.09,2.12,2.15,.65,2.8l-2.73,1.21c-.18,.08-.38,.12-.58,.12H14.97c-.48,0-.93-.25-1.2-.65Z');\\n}\\n\\n.button--bird .button__wrapper::before{\\n    left: 0;\\n}\\n.button--bird .button__wrapper::after{\\n    right: 0;\\n    transform : rotateY(180deg) ;\\n}\\n```\\n\\n分别在前后加上一个伪元素，设置宽高和背景色，裁切的形状。然后分别设置不同的位移，右边要反过来，所以是 rotateY(180deg)。\\n\\n背景色也可能变，所以抽出一个变量。\\n\\n这里伪元素用到了 position：absolute，同样要在元素上加上 position: relative;\\n\\n```css\\n.button__wrapper {\\n    position: relative;\\n}\\n```\\n\\n效果就是这样的：\\n\\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a9359ab2903647c384af41287694ad63~tplv-k3u1fbpfcp-watermark.image?)\\n\\n然后我们先加一些 hover 的效果吧，毕竟也算一个完整的 Button 了。\\n\\nhover 的时候，让字体间距变大，两个草丛背景分别左右移动，箭头往右移动：\\n\\n```css\\n.button:hover .button__text{\\n    letter-spacing : 6px ;\\n}\\n.button:hover .button__wrapper::before{\\n    transform : translateX(-12px) ;\\n}\\n.button:hover .button__wrapper::after{\\n    transform : rotateY(180deg) translateX(-12px) ;\\n}\\n.button:hover::before{\\n    right : 14px ;\\n}\\n```\\n\\n效果是这样的：\\n\\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/91e3d84e28df484fa2fb9b10a7eee2aa~tplv-k3u1fbpfcp-watermark.image?)\\n\\n过渡有点太生硬了，设置下 transition：\\n\\n```css\\n.button__text {\\n    transition: all .3s ease;\\n}\\n.button::before {\\n    transition: all .2s ease;\\n}\\n.button__wrapper::before, .button__wrapper::after {\\n    transition: all .5s ease;\\n}\\n```\\n文字 3s，箭头 2s，草丛 5s，都是匀速的过渡。\\n\\n\\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4752283be0949be8c354144aba36f44~tplv-k3u1fbpfcp-watermark.image?)\\n\\n这样就自然多了。\\n\\n接下来就是最有意思的部分了：画三只小鸟。\\n\\n在按钮的 div 的下方，再加一点 div：\\n\\n```html\\n<a href=\\\"#\\\" class=\\\"button button--bird\\\">\\n    <div class=\\\"button__wrapper\\\">\\n        <span class=\\\"button__text\\\">ENTRY</span>\\n    </div>\\n\\n    <div class=\\\"birdBox\\\">\\n        <div class=\\\"bird\\\">\\n            <div class=\\\"bird__face\\\"></div>\\n        </div>\\n        <div class=\\\"bird\\\">\\n            <div class=\\\"bird__face\\\"></div>\\n        </div>\\n        <div class=\\\"bird\\\">\\n            <div class=\\\"bird__face\\\"></div>\\n        </div>\\n    </div>\\n</a>\\n```\\n\\n一个 birdBox 元素包含着 3 个 bird 的子元素，它还有一层子元素。\\n\\n设置这些层当然也是为了利用每一层的 ::before、::after 来画一些东西：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2254a7b829724838a152f9169836028a~tplv-k3u1fbpfcp-watermark.image?)\\n\\n先设置 .birdBox 的样式：\\n\\n```css\\n.birdBox {\\n    position: absolute ;\\n    top: -54px ;\\n\\n    display: flex ;\\n    justify-content: space-between ;\\n    align-items: flex-end ;\\n\\n    width: 180px ;\\n    height: 56px ;\\n}\\n```\\n\\n设置宽高和绝对定位的位置，大概是在这里：\\n\\n\\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20957d7ef7514f29ae3aa8c75c1e5ac8~tplv-k3u1fbpfcp-watermark.image?)\\n\\n并且设置内容水平平分剩余空间，竖直居中。\\n\\n然后设置子元素也就是每只小鸟的样式：\\n\\n```css\\n.bird{\\n    width: 56px ;\\n    height: 36px ;\\n    box-sizing: border-box ;\\n    border: solid 3px #000 ;\\n    background: var(--main_color) ;\\n}\\n```\\n\\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/330fb8f29b65444fbd8191d16c515ff9~tplv-k3u1fbpfcp-watermark.image?)\\n\\n设置圆角：\\n\\n```css\\n.button__bird {\\n    --border_radius1: 60px 60px 40px 40px / 48px 48px 30px 30px ;\\n}\\n.bird {\\n   border-radius: var(--border_radius1) ;\\n}\\n```\\n这里也作为变量抽出来。\\n\\n分别设置 4 个角的横竖半轴长度，调整得到这样的形状：\\n\\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce65e9860c7848ee8c3cad28d3289d5d~tplv-k3u1fbpfcp-watermark.image?)\\n\\n然后通过 ::before 伪元素画上鸟毛：\\n\\n```css\\n.bird {\\n    position: relative;\\n}\\n.bird::before{\\n    content: '' ;\\n   \\n    position: absolute ;\\n    top: -12px ;\\n    left: 22px ;\\n\\n    width: 12px ;\\n    height: 12px ;\\n\\n    background : #000 ;\\n    clip-path : path('M10.23,3.32c-3.54,.63-5.72,2.51-7.02,4.23-.33-1.58-.34-3.54,.93-5.12,.52-.65,.41-1.59-.24-2.11C3.24-.19,2.29-.08,1.77,.57c-3.82,4.77-.31,11.11-.13,11.42,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0-.01-.02,2.49,.04,2.52,0,.1-.14,1.54-4.82,6.59-5.71,.82-.14,1.37-.92,1.22-1.74s-.94-1.36-1.75-1.21Z') ;\\n}\\n```\\n\\n这种不规则形状当然也是通过 clip-path 裁剪出来的。\\n\\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dfb4baec03794d8eb109c5be9cb6838e~tplv-k3u1fbpfcp-watermark.image?)\\n\\n然后再画上嘴：\\n\\n在子元素 .bird__face 上画：\\n\\n```css\\n.button--bird{\\n    --sub_color2: #ff8108 ;\\n}\\n.bird__face{\\n    position: absolute ;\\n    top: 15px ;\\n    \\n    width: 12px ;\\n    height: 6px ;\\n    \\n    background: var(--sub_color2) ;\\n    border-radius: 50% 50% 50% 50% / 78% 78% 22% 22% ;\\n}\\n```\\n\\n设置宽高和定位，背景颜色和圆角，就可以得到鸟嘴：\\n\\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d7d406c15a7142348e7b58ec1767a537~tplv-k3u1fbpfcp-watermark.image?)\\n\\n要居中的话可以在它的父元素设置 display: flex：\\n\\n```css\\n.bird {\\n    display: flex;\\n    justify-content: center;\\n}\\n```\\n\\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/04276c3e795a49d9b128d880c890f256~tplv-k3u1fbpfcp-watermark.image?)\\n\\n然后再通过 ::before 和 ::after 伪元素来画两只眼睛：\\n\\n```css\\n.bird__face::before,\\n.bird__face::after{\\n    content: '' ;\\n    position: absolute ;\\n    top: -4px ;\\n    width: 8px ;\\n\\n    height: 2px ;\\n    border-radius: 4px ;\\n    background: #000 ;\\n}\\n.bird__face::before{\\n    left: -5px ;\\n}\\n.bird__face::after{\\n    right: -5px ;\\n}\\n```\\n设置定位、宽高、位置、圆角、背景颜色即可：\\n\\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d09abd505c04af8ad94218ec54c425a~tplv-k3u1fbpfcp-watermark.image?)\\n\\n至此，睡着的小鸡就画完了！\\n\\n核心就是就是元素和伪元素通过定位 + flex 来布局，然后通过 border-radius 和 clip-path 设置形状。\\n\\n接下来画睡醒以后的小鸡：\\n\\n只有前两只会醒，所以给它俩单独加个 wakeup 的 class：\\n\\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6308b288d6014a57831f8d6fd43976a1~tplv-k3u1fbpfcp-watermark.image?)\\n\\n```html\\n<div class=\\\"birdBox\\\">\\n    <div class=\\\"bird wakeup\\\">\\n        <div class=\\\"bird__face\\\"></div>\\n    </div>\\n    <div class=\\\"bird wakeup\\\">\\n        <div class=\\\"bird__face\\\"></div>\\n    </div>\\n    <div class=\\\"bird\\\">\\n        <div class=\\\"bird__face\\\"></div>\\n    </div>\\n</div>\\n```\\n当 hover 的时候，wakeup 的小鸡会执行伸展身体的动画：\\n\\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/41bc42449a8349e181ef788ad20cc9ec~tplv-k3u1fbpfcp-watermark.image?)\\n\\n这个动画里变的是什么呢？\\n\\n明显是 height 变了，我们设置下：\\n\\n```css\\n.button:hover .wakeup{\\n    animation: wakeup .2s ease ;\\n}\\n\\n@keyframes wakeup{\\n    0%  {\\n        height : 32px;\\n    }\\n    100%{\\n        height : 56px ;\\n    }\\n}\\n```\\n\\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cd9f38acf324642aa7a886648823ddf~tplv-k3u1fbpfcp-watermark.image?)\\n\\n这样有两个问题，一个是动画没有停住，一执行完就回去了，这个可以设置 animation-fill-mode 来解决：\\n\\n```css\\n.button:hover .wakeup{\\n    animation : wakeup .2s ease ;\\n    animation-fill-mode : forwards ;\\n}\\n```\\n设置 animation-fill-mode 为 forwards 就是停留在最后一帧的意思：\\n\\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/029e031449eb49958d96cc422ea1eeac~tplv-k3u1fbpfcp-watermark.image?)\\n\\n还有一个问题就是鸟高度变大后，圆角也得重新设置下，不然形状很奇怪：\\n\\n```css\\n.button--bird {\\n    --border_radius2: 70px 70px 40px 40px / 48px 48px 30px 30px ;\\n    --border_radius3: 40px 40px 40px 40px / 48px 48px 30px 30px ;\\n}\\n@keyframes wakeup{\\n    0%  {\\n        height: 32px;\\n        border-radius: var(--border_radius2) ;\\n    }\\n    100%{\\n        height: 56px ;\\n        border-radius: var(--border_radius3) ;\\n    }\\n}\\n```\\n这样就好多了：\\n\\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a37c72ab6fa49e6ab0115eb205d38c7~tplv-k3u1fbpfcp-watermark.image?)\\n\\n再就是醒来以后眼睛也得睁开，还要眨眼，这个怎么做呢？\\n\\n看下分解动作就明白了：\\n\\n```css\\n.button:hover .wakeup .bird__face::before,\\n.button:hover .wakeup .bird__face::after{\\n    width: 6px;\\n    height: 6px;\\n}\\n```\\n设置宽高都为 6px，这样就是睁开眼睛的效果：\\n\\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/131b619bca964f6abd91ccd7d9133e60~tplv-k3u1fbpfcp-watermark.image?)\\n\\n瞬间变精神小伙。\\n\\n这样是之前闭着眼睛的效果：\\n```css\\n.button:hover .wakeup .bird__face::before,\\n.button:hover .wakeup .bird__face::after{\\n    width: 8px;\\n    height: 2px;\\n}\\n```\\n\\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5782d48df8d4cd48bb89612546a5aec~tplv-k3u1fbpfcp-watermark.image?)\\n\\n连起来设置几个关键帧，那就是眨眼动画了：\\n\\n```css\\n @keyframes eye {\\n    0%{\\n        top : -6px ;\\n        width : 6px ;\\n        height : 6px ;\\n    }\\n    30%{\\n        top : -6px ;\\n        width : 6px ;\\n        height : 6px ;\\n    }\\n    32%{\\n        top : -4px ;\\n        width : 8px ;\\n        height : 2px ;\\n    }\\n    34%{\\n        top : -6px ;\\n        width : 6px ;\\n        height : 6px ;\\n    }\\n    70%{\\n        top : -6px ;\\n        width : 6px ;\\n        height : 6px ;\\n    }\\n    72%{\\n        top : -4px ;\\n        width : 8px ;\\n        height : 2px ;\\n    }\\n    74%{\\n        top : -6px ;\\n        width : 6px ;\\n        height : 6px ;\\n    }\\n    76%{\\n        top : -4px ;\\n        width : 8px ;\\n        height : 2px ;\\n    }\\n    78%{\\n        top : -6px ;\\n        width : 6px ;\\n        height : 6px ;\\n    }\\n    100%{\\n        top : -6px ;\\n        width : 6px ;\\n        height : 6px ;\\n    }\\n}\\n```\\n当然睁眼以后高度变高，top 也得调整下。\\n\\n然后应用这个动画：\\n\\n```css\\n.button:hover .wakeup .bird__face::before,\\n.button:hover .wakeup .bird__face::after{\\n    animation : eye 5s linear infinite ;\\n}\\n```\\n\\n5s 内匀速执行动画，无限次执行。\\n\\n试一下：\\n\\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/18d573e9eb834d11a97f56d7b790ac58~tplv-k3u1fbpfcp-watermark.image?)\\n\\n瞬间就有灵气了。\\n\\n都一样的动作显得有点呆，我们让第二只鸟往右边看一下。\\n\\n也就是这样的动画：\\n\\n```css\\n@keyframes eye_2 {\\n    0%{\\n        top : -6px ;\\n        width : 6px ;\\n        height : 6px ;\\n    }\\n    10%{\\n        transform : translateX(0);\\n    }\\n    12%{\\n        transform : translateX(3px);\\n    }\\n    20%{\\n        top : -6px ;\\n        width : 6px ;\\n        height : 6px ;\\n    }\\n    22%{\\n        top : -4px ;\\n        width : 8px ;\\n        height : 2px ;\\n    }\\n    24%{\\n        top : -6px ;\\n        width : 6px ;\\n        height : 6px ;\\n    }\\n    25%{\\n        transform : translateX(3px);\\n    }\\n    27%{\\n        transform : translateX(0);\\n    }\\n    74%{\\n        top : -6px ;\\n        width : 6px ;\\n        height : 6px ;\\n        transform : translateX(0);\\n    }\\n    76%{\\n        top : -4px ;\\n        width : 8px ;\\n        height : 2px ;\\n        transform : translateX(3px);\\n    }\\n    78%{\\n        top : -6px ;\\n        width : 6px ;\\n        height : 6px ;\\n    }\\n    80%{\\n        top : -4px ;\\n        width : 8px ;\\n        height : 2px ;\\n    }\\n    82%{\\n        top : -6px ;\\n        width : 6px ;\\n        height : 6px ;\\n    }\\n    85%{\\n        transform : translateX(3px);\\n    }\\n    87%{\\n        transform : translateX(0);\\n    }\\n    100%{\\n        top : -6px ;\\n        width : 6px ;\\n        height : 6px ;\\n        transform : translateX(0);\\n    }\\n    \\n}\\n```\\n\\n就是多了一个 translateX 的位移。\\n\\n给第二支鸟应用这个动画：\\n\\n```css\\n.button:hover .wakeup:nth-child(2) .bird__face::before,\\n.button:hover .wakeup:nth-child(2) .bird__face::after{\\n    animation : eye_2 5s linear infinite ;\\n}\\n```\\n\\n再来试下：\\n\\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/095723bad4cf489785d684b89a56bf6e~tplv-k3u1fbpfcp-watermark.image?)\\n\\n更可爱了一点！\\n\\n最后，还要做一个睡着的动画，睡着的时候随着呼吸，身体也是有起伏的，这个动画也是改 height 和 border-radius：\\n\\n```css\\n.button__bird {\\n    --border_radius1 : 60px 60px 40px 40px / 48px 48px 30px 30px ;\\n    --border_radius2 : 70px 70px 40px 40px / 48px 48px 30px 30px ;\\n}\\n@keyframes sleep{\\n    0%  {\\n        height: 36px ;\\n        border-radius: var(--border_radius1) ;\\n    }\\n    100%{\\n        height: 32px ;\\n        border-radius: var(--border_radius2) ;\\n    }\\n}\\n.bird {\\n    animation: sleep 1s ease infinite alternate;\\n}\\n```\\n\\n先试一下：\\n\\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d6d0233a7094a0bbc8177cb2338582e~tplv-k3u1fbpfcp-watermark.image?)\\n\\n确实有随着呼吸身体起伏的感觉了！\\n\\n但不知道同学们有没有发现这个动画的不同之处？\\n\\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/891741cc32ba48428300463fab9d32c9~tplv-k3u1fbpfcp-watermark.image?)\\n\\n我们多设置了个 alternate，这个是 animation-direction，动画方向的意思。\\n\\n如果不设置是这样的效果：\\n\\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c8b2349781db44df91918a91725d4c0d~tplv-k3u1fbpfcp-watermark.image?)\\n\\n每次都从低到高来运动。\\n\\n但应该是低到高、高到低、低到高这样的循环往复的运动。\\n\\nanimation-direction: alternate 的效果就是正向、反向、正向、反向这样循环。\\n\\n当然它也有别的取值：\\n\\n- normal：正向：\\n- reverse：反向\\n- alternate：正向、反向、正向、反向...\\n- alternate-reverse：反向、正向、反向、正向...\\n\\n至此，这个可爱的 Button 就完成了，我们整体感受一下：\\n\\n\\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/75b8c51b8f34492a9036d72f49977637~tplv-k3u1fbpfcp-watermark.image?)\\n\\n确实很可爱！\\n\\n全部代码如下：\\n\\n```html\\n<!DOCTYPE html>\\n<html lang=\\\"en\\\">\\n<head>\\n    <title></title>\\n</head>\\n<body>\\n    <a href=\\\"#\\\" class=\\\"button button--bird\\\">\\n        <div class=\\\"button__wrapper\\\">\\n            <span class=\\\"button__text\\\">ENTRY</span>\\n        </div>\\n\\n        <div class=\\\"birdBox\\\">\\n            <div class=\\\"bird wakeup\\\">\\n                <div class=\\\"bird__face\\\"></div>\\n            </div>\\n            <div class=\\\"bird wakeup\\\">\\n                <div class=\\\"bird__face\\\"></div>\\n            </div>\\n            <div class=\\\"bird\\\">\\n                <div class=\\\"bird__face\\\"></div>\\n            </div>\\n        </div>\\n    </a>\\n    <style>\\n        body {\\n            padding: 100px;\\n        }\\n        .button--bird{\\n            --main_color: #f4cf47;\\n            --sub_color1: #f4e19c;\\n            --sub_color2: #ff8108;\\n            --base_color: #000;\\n            --border_radius1: 60px 60px 40px 40px / 48px 48px 30px 30px;\\n            --border_radius2: 70px 70px 40px 40px / 48px 48px 30px 30px;\\n            --border_radius3: 40px 40px 40px 40px / 48px 48px 30px 30px;\\n        }\\n        .button {\\n            display: flex;\\n            justify-content: center;\\n            align-items: center;\\n\\n            box-sizing: border-box;\\n            width: 280px;\\n            height: 80px;\\n\\n            text-decoration: none;\\n            border: solid 3px #000;\\n            border-radius: 40px;\\n            background: var(--main_color);\\n            position: relative;\\n        }\\n\\n        .button__wrapper{\\n            display: flex;\\n            justify-content: center;\\n            align-items: center;\\n\\n            width: 100%;\\n            height: 100%;\\n\\n            border-radius: 40px;\\n\\n            overflow: hidden;\\n            position: relative;\\n\\n        }\\n        .button__text{\\n            position: relative;\\n            font-size: 32px;\\n            letter-spacing: 4px;\\n            color: var(--base_color);\\n            transition: all .3s ease;\\n        }\\n\\n        .button::before{\\n            content: '';\\n            position: absolute;\\n\\n            right: 20px;\\n            margin: auto 0;\\n            width: 24px;\\n            height: 24px;\\n            background: var(--base_color); \\n            clip-path: path('M24,12.02c0-1.09-.75-1.71-.81-1.77L11.17,.45c-.91-.74-2.21-.56-2.91,.42-.69,.97-.52,2.37,.39,3.11l7.12,5.81-13.7-.02h0C.93,9.77,0,10.76,0,11.99c0,1.23,.93,2.22,2.07,2.22l13.7,.02-7.13,5.78c-.91,.74-1.09,2.13-.4,3.11,.41,.58,1.03,.88,1.65,.88,.44,0,.88-.15,1.25-.45l12.04-9.76c.07-.06,.82-.67,.82-1.77Z');\\n            transition: all ease .2s;\\n        }\\n        .button--bird .button__wrapper::before,\\n        .button--bird .button__wrapper::after{\\n            content: '';\\n            position: absolute;\\n            bottom: 0;\\n            width: 130px;\\n            height: 38px;\\n            background: var(--sub_color1);\\n            transition: all .5s ease;\\n            clip-path: path('M13.77,37.35L.25,16.6c-.87-1.33,.69-2.91,2-2.02l12.67,8.59c.81,.55,1.91,.14,2.18-.81l2.62-9.33c.39-1.4,2.34-1.42,2.76-.02l3.6,11.99c.33,1.11,1.74,1.4,2.47,.52L49.38,.52c.87-1.04,2.53-.42,2.53,.95V23.7c0,1.13,1.2,1.83,2.16,1.26l12.75-7.51c.85-.5,1.94,0,2.13,.98l1.5,7.6c.2,1.03,1.37,1.51,2.22,.92l17.74-12.3c1.09-.75,2.52,.25,2.21,1.55l-2.44,10.2c-.26,1.09,.74,2.06,1.8,1.75l30.8-9.04c1.37-.4,2.42,1.26,1.49,2.36l-9.07,10.66c-.83,.98-.1,2.49,1.17,2.42l12.12-.68c1.6-.09,2.12,2.15,.65,2.8l-2.73,1.21c-.18,.08-.38,.12-.58,.12H14.97c-.48,0-.93-.25-1.2-.65Z');\\n        }\\n        .button--bird .button__wrapper::before{\\n            left: 0;\\n        }\\n        .button--bird .button__wrapper::after{\\n            right: 0;\\n            transform: rotateY(180deg);\\n        }\\n\\n        .button:hover .button__wrapper::before{\\n            transform: translateX(-12px);\\n        }\\n        .button:hover .button__wrapper::after{\\n            transform: rotateY(180deg) translateX(-12px);\\n        }\\n        .button:hover .button__text{\\n            letter-spacing: 6px;\\n        }\\n        .button:hover::before{\\n            right: 14px;\\n        }\\n        \\n        .birdBox{\\n            position: absolute;\\n            top: -54px;\\n            display: flex;\\n            justify-content:space-between;\\n            align-items: flex-end;\\n            width: 180px;\\n            height: 56px;\\n        }\\n\\n        .bird{\\n            position: relative;\\n            width: 56px;\\n            height: 36px;\\n            box-sizing: border-box;\\n            border: solid 3px #000;\\n            background: var(--main_color);\\n            border-radius: var(--border_radius1);\\n            animation: sleep 1s ease infinite alternate;\\n            display: flex;\\n            justify-content: center;\\n        }\\n        .bird__face{\\n            position: absolute;\\n            top: 15px;\\n            width: 12px;\\n            height: 6px;\\n            background: var(--sub_color2);\\n            border-radius: 50% 50% 50% 50% / 78% 78% 22% 22%;\\n            transition: .2s;\\n        }\\n        .bird__face::before,\\n        .bird__face::after{\\n            content: '';\\n            position: absolute;\\n            top: -4px;\\n            width: 8px;\\n            height: 2px;\\n            border-radius: 4px;\\n            background: #000;\\n        }\\n        .bird__face::before{\\n            left: -5px;\\n        }\\n        .bird__face::after{\\n            right: -5px;\\n        }\\n        .bird::before{\\n            content: '';\\n            position: absolute;\\n            top: -12px;\\n            left: 22px;\\n            width: 12px;\\n            height: 12px;\\n            background: #000;\\n            clip-path: path('M10.23,3.32c-3.54,.63-5.72,2.51-7.02,4.23-.33-1.58-.34-3.54,.93-5.12,.52-.65,.41-1.59-.24-2.11C3.24-.19,2.29-.08,1.77,.57c-3.82,4.77-.31,11.11-.13,11.42,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0-.01-.02,2.49,.04,2.52,0,.1-.14,1.54-4.82,6.59-5.71,.82-.14,1.37-.92,1.22-1.74s-.94-1.36-1.75-1.21Z');\\n        }\\n        .button:hover .wakeup{\\n            animation: wakeup .2s ease;\\n            animation-fill-mode: forwards;\\n        }\\n        .button:hover .wakeup .bird__face{\\n            top: 20px;\\n        }\\n        .button:hover .wakeup .bird__face::before,\\n        .button:hover .wakeup .bird__face::after{\\n            animation: eye 5s linear infinite;\\n        }\\n\\n        .button:hover .wakeup:nth-child(2) .bird__face::before,\\n        .button:hover .wakeup:nth-child(2) .bird__face::after{\\n            animation: eye_2 5s linear infinite;\\n        }\\n        \\n        @keyframes wakeup{\\n            0%  {\\n                height: 32px;\\n                border-radius: var(--border_radius2);\\n            }\\n            100%{\\n                height: 56px;\\n                border-radius: var(--border_radius3);\\n            }\\n        }\\n\\n        @keyframes eye {\\n            0%{\\n                top: -6px;\\n                width: 6px;\\n                height: 6px;\\n            }\\n            30%{\\n                top: -6px;\\n                width: 6px;\\n                height: 6px;\\n            }\\n            32%{\\n                top: -4px;\\n                width: 8px;\\n                height: 2px;\\n            }\\n            34%{\\n                top: -6px;\\n                width: 6px;\\n                height: 6px;\\n            }\\n            70%{\\n                top: -6px;\\n                width: 6px;\\n                height: 6px;\\n            }\\n            72%{\\n                top: -4px;\\n                width: 8px;\\n                height: 2px;\\n            }\\n            74%{\\n                top: -6px;\\n                width: 6px;\\n                height: 6px;\\n            }\\n            76%{\\n                top: -4px;\\n                width: 8px;\\n                height: 2px;\\n            }\\n            78%{\\n                top: -6px;\\n                width: 6px;\\n                height: 6px;\\n            }\\n            100%{\\n                top: -6px;\\n                width: 6px;\\n                height: 6px;\\n            }\\n        }\\n\\n        @keyframes eye_2 {\\n            0%{\\n                top: -6px;\\n                width: 6px;\\n                height: 6px;\\n            }\\n            10%{\\n                transform: translateX(0);\\n            }\\n            12%{\\n                transform: translateX(3px);\\n            }\\n            20%{\\n                top: -6px;\\n                width: 6px;\\n                height: 6px;\\n            }\\n            22%{\\n                top: -4px;\\n                width: 8px;\\n                height: 2px;\\n            }\\n            24%{\\n                top: -6px;\\n                width: 6px;\\n                height: 6px;\\n            }\\n            25%{\\n                transform: translateX(3px);\\n            }\\n            27%{\\n                transform: translateX(0);\\n            }\\n            74%{\\n                top: -6px;\\n                width: 6px;\\n                height: 6px;\\n                transform: translateX(0);\\n            }\\n            76%{\\n                top: -4px;\\n                width: 8px;\\n                height: 2px;\\n                transform: translateX(3px);\\n            }\\n            78%{\\n                top: -6px;\\n                width: 6px;\\n                height: 6px;\\n            }\\n            80%{\\n                top: -4px;\\n                width: 8px;\\n                height: 2px;\\n            }\\n            82%{\\n                top: -6px;\\n                width: 6px;\\n                height: 6px;\\n            }\\n            85%{\\n                transform: translateX(3px);\\n            }\\n            87%{\\n                transform: translateX(0);\\n            }\\n            100%{\\n                top: -6px;\\n                width: 6px;\\n                height: 6px;\\n                transform: translateX(0);\\n            }\\n            \\n        }\\n        @keyframes sleep{\\n            0%  {\\n                height: 36px;\\n                border-radius: var(--border_radius1);\\n            }\\n            100%{\\n                height: 32px;\\n                border-radius: var(--border_radius2);\\n            }\\n        }\\n    </style>\\n</body>\\n</html>\\n```\\n## 总结\\n\\n我们通过纯 CSS 实现了一个可爱的 Button，核心就是用元素 + 伪元素通过 flex + 定位来布局，然后通过 border-radius + clip-path 设置形状，通过 animation + @keyframes 来做复杂的动画，通过 transition 设置过渡效果。\\n\\nborder-radius 可以设置 4 个角的横竖半轴的长度，从而做出很多形状，更复杂的不规则形状可以通过 clip-path 来裁剪出来。\\n\\n其中要注意的是可以通过设置 animnation-fill-mode: forwards 让动画停在最后一帧，设置 animation-direction: alternate 可以正反交替执行动画。再就是最好通过变量把会变化的样式值提取出来，这样方便配置。\\n\\n用 CSS 实现一些有趣的效果确实感觉很好，这也是前端工程师专属的快乐。\\n"
    },
    {
        "article_id": "7189812753366777915",
        "cover_image": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4798b66da19b4247ae5cb20f50b748b5~tplv-k3u1fbpfcp-watermark.image?",
        "title": "unplugin-vue-components 不能识别组件的自动导入的类型 (pnpm)",
        "brief": "引言 等同于以下效果 效果 这里需要实现的效果如下： 发现问题 但是问题来了，使用pnpm的用户，我相信许多人是实现不了这上效果的😀😀😀。当所有的配置文件配好，然后就出现下面的效果啦！！！ 问题效果 ",
        "user_name": "twinkle",
        "view_count": 1533,
        "collect_count": 2,
        "comment_count": 1,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/ac2b55d239918c400367ae7cbbbf76a8~300x300.image",
        "category": "前端",
        "content": "# 引言\\n> `unplugin-vue-components` 是一款能帮助组件自动导入的库，简单点的说，你不需要使用`import xx  from 'xxx.vue'` 这行语句也能实现导入的效果。\\n```ts\\n<script setup lang=\\\"ts\\\">\\nimport ScreenAdpter from '@compontents/ScreenAdpter/index.vue'\\nimport Play from '@components/Play/index.vue'\\n\\n</script>\\n\\n<template>\\n    <ScreenAdpter>\\n        <Play></Play>\\n    </ScreenAdpter>\\n</template>\\n\\n<style scoped></style>\\n```\\n等同于以下效果\\n```ts\\n<script setup lang=\\\"ts\\\">\\n</script>\\n\\n<template>\\n    <ScreenAdpter>\\n        <Play></Play>\\n    </ScreenAdpter>\\n</template>\\n\\n<style scoped></style>\\n```\\n# 效果\\n这里需要实现的效果如下：![请添加图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e096ea3dac3a429c8101fdb3ec5049bc~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n# 发现问题\\n\\n但是问题来了，**使用pnpm的用户**，我相信许多人是实现不了这上效果的😀😀😀。当所有的配置文件配好，然后就出现下面的效果啦！！！\\n\\n## 问题效果\\n![请添加图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d084cdbd8fc14d338d424928bd9e5217~tplv-k3u1fbpfcp-zoom-1.image)\\n你会发现，在组件使用的地方的类型是`any`, 当你去`unplugin-vue-components` 这里面点击组件是可以进去的，那么怎么来解决这个引用问题呢？\\n\\n# 解决问题\\n\\n## 刨根问底\\n既然组件显示的类型是`any`,那么咱们先看下生产的类型声明文件。\\n```ts\\n// generated by unplugin-vue-components\\n// We suggest you to commit this file into source control\\n// Read more: https://github.com/vuejs/core/pull/3399\\nimport '@vue/runtime-core'\\n\\nexport {}\\n\\ndeclare module '@vue/runtime-core' {\\n  export interface GlobalComponents {\\n    Play: typeof import('./components/Play/index.vue')['default']\\n    RouterLink: typeof import('vue-router')['RouterLink']\\n    RouterView: typeof import('vue-router')['RouterView']\\n    ScreenAdpter: typeof import('./components/ScreenAdpter/index.vue')['default']\\n  }\\n}\\n\\n```\\n\\n\\n在自动生成的` components.d.ts `文件中的 `declare module '@vue/runtime-core' `声明，在` pnpm` 中只能访问项目的顶级依赖，而 `@vue/runtime-core` 是 `vue` 模块下的依赖，不是顶级依赖，导致声明语句失效。（`yarn` 和 `npm` 的 `node_modules` 平铺目录结构允许访问所有依赖）\\n\\n\\n## 解决方案\\n1. 🌟 （首选）在目录的根目录中创建或编辑`.npmrc`文件，并在其中添加以下行：`public hoist pattern[]=@vue/runtime core`\\n\\n2. （不推荐）在目录的根目录中创建或编辑`.npmrc文`件，并在其中添加以下行：`shamefully-hoist=true`（这样做将使所有嵌套依赖项都可用作顶级依赖项）\\n\\n3. （不推荐）运行`pnpm add@vue/runtime core -D`将嵌套模块添加为顶级依赖项。（您必须确保`@vue/runtime`内核的版本与项目中安装的`vue`版本相匹配。）\\n\\n4. （不推荐）使用`0.18.5`版本的`unplugin-vue-components`组件，而不是最新版本。（之所以有效，是因为在此版本之前，`unplugin-vue-components` 组件将`components.d.ts`中的模块声明为`“vue”`。缺点是，您将错过插件的最新更新和改进。）\\n\\n5. （不建议）手动更新`components.d.ts`中的模块声明名称，以声明模块`“vue”`，而不是声明模块`“@vue/runtime core”`（这很不方便，因为每当取消插入`vue`组件自动生成新的`components.d.ts`文件并覆盖您的更改时，您都必须更新模块名称。）\\n\\n>注意：\\n> 如果您选择了选项1或2并创建了.npmrc文件，请在之后运行`pnpm i`以使用最新的配置更新`node_modules`。然后，重新加载工作区。自动导入组件的`Intellisense`应再次工作。\\n\\n如果这么操作还是不行，就重启下`vscode`就`ok`啦\\n\\n# 祝福\\n即将接近2022年除夕啦，小编在这里祝福大家在新的一年里，**新年快乐，心想事成，万事如意，代码永无bugger**🎉🎉🎉🎉\\n\\n"
    },
    {
        "article_id": "7189806705234935869",
        "cover_image": "https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b7a38911ada24db4b763c856be2875ab~tplv-k3u1fbpfcp-watermark.image?",
        "title": "【提升团队运营效率】交易履约之订单中心实践",
        "brief": "交易履约订单中心为履约行为提供必要的系统能力支撑，交易履约订单中心记录了交易流通的过程和状态，包括交易主体、产品信息、成交金额、计费、支付、业务信息等全流程信息，为上下游提供数据标准化、全集数据查询和",
        "user_name": "京东云开发者",
        "view_count": 1494,
        "collect_count": 2,
        "comment_count": 0,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/b9a366997037d998063135bd56302b85~300x300.image",
        "category": "开发工具",
        "content": "本文作者：京东科技-市场与平台运营中心-平台研发部，晏银喜、张学君、袁宝龙、高传江、杨迎心、游斌平、付达。\\n\\n特别感谢：杨广兴、张然、姬英泽、赵宁、张彤，在系统建设过程中的贡献。\\n\\n# 1、概述\\n\\n## 1.1 交易履约是什么？\\n\\n首先定义下什么是交易履约，交易履约是在甲乙双方达成交易产生订单后，乙方按照订单条款为甲方提供服务或交付约定物的行为。\\n\\n## 1.2 交易履约订单中心是个什么系统？\\n\\n交易履约订单中心为履约行为提供必要的系统能力支撑，交易履约订单中心记录了交易流通的过程和状态，包括交易主体、产品信息、成交金额、计费、支付、业务信息等全流程信息，为上下游提供数据标准化、全集数据查询和串联流程的功能。目前已接入的场景有：京音业绩匹配、交易数据看板、京音线上化结算、 交易流程串联等。目前交易履约订单中心年订单量 1.5 亿+，在电销、企微、金店、开放平台、用户增长等场景下，有效支持了消金、财富、保险、支付、分期商城等各大业务线的线上、线下的业务发展。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/32b7b05850444498b8c915c84b607499~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n# 2、名词解释\\n\\n**数据来源**：交易数据的来源，包含业务信息、联系人、数据接入协议等。\\n\\n**订单模版**：交易履约订单中心采用泛化的格式存储交易数据，针对每个交易场景配置一个订单模版，模版上配置映射规则来解析数据。\\n\\n**跟单**：履约订单中心接收满足某些条件的交易数据。\\n\\n**补单**：当数据源的数据不完整或不满足业务场景需求，履约订单中心请求外部接口来补充交易数据。\\n\\n**推送模版**：履约订单中心将交易数据推送到下游系统。\\n\\n# 3、设计实现\\n\\n## 3.1 整体架构\\n\\n整体架构主要分成四个部分（如下图的蓝色部分），依据高内聚、低耦合的设计原则，每个分层只专注处理自己的业务逻辑，分层之间通过 MQ 消息驱动数据流转。\\n\\n**接收层**：负责接收上游产品层的交易数据，目前支持 MQ 消息和杰夫接口两种协议。\\n\\n**数据处理层**：负责对数据进行解析、幂等判断、交易时序判断、补充数据完整性、映射订单模型等。\\n\\n**数据推送层**：负责对数据按照指定的规则格式化、推送到下游系统，目前支持 MQ 和杰夫两种协议。\\n\\n**查询服务**：负责数据的查询和导出。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af5fe5b447a64aff95799934d9a720d9~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n## 3.2 业务接入配置化\\n\\n经过对整体架构的设计和抽象以后，我们发现各个业务线的数据处理流程具有高度的一致性：数据接收、数据处理、数据推送，而在不同的业务线产品的交易场景下会存在一些特定的差异，比如，只接收满足某些条件的交易数据、金条借款的订单与基金购买的订单模型不同、只有满足某些条件的数据才推送给结算系统等。为了提高业务的接入效率、降低接入成本，我们抽象了一套通用的数据处理流程，流程中的分支通过条件表达式来识别，同时提供一套完整的配置化页面供产品和运营同学使用，最终实现了业务接入配置化、自助化，如下图：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6704b4f10bd45b1b1895facdeb92eb8~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n### 3.2.1 配置数据来源和订单模版\\n\\n数据接收层通过配置的数据来源协议编码路由到订单模版，不同的业务产品交易场景会配置不同的订单模版。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/acd568f3527349c6a04bc31a02c4a87e~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n### 3.2.2 配置模版内容\\n\\n在数据的处理环节，我们要解决不同数据来源的数据解析、模型映射、幂等判断、时序判断等问题，不同来源的差异化我们通过配置化来支持，如下图所示的配置内容，将要解析的数据配置成 `JsonPath`，数据处理程序通过读取字段类型是“交易单号”的配置，来解析交易单号并完成幂等判断；通过读取“交易时间”的配置，来解析并完成数据时序的判断。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dced27efdf1546f9b0d7ee98abc61940~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n> `Fastjson` 1.2.0 之后的版本支持 `JSONPath，`可以在 `java` 框架中当作对象查询语言（OQL）来使用。\\n\\n```\\n// 解析贷款单号\\nObject loanId = JSONPath.extract(jsonStr, \\\"$.jt_df_success.loanId\\\");\\n// 解析还款单号\\nObject loanNo = JSONPath.extract(jsonStr, \\\"$.jt_repayment.taskData.loanNo\\\");\\n\\n\\n```\\n\\n### 3.2.3 配置表达式\\n\\n前面提到过，在通用的数据流程中存在这样的分支流程：当满足一定条件时做某些事情，具体的条件根据业务场景的诉求确定，要做的事情是可以枚举和抽象的，比如过滤订单消息或者调用某个服务等。这种场景类似于一个轻量级的规则引擎，我们通过开源的 `MVEL` 类库来实现这个表达式引擎（特点：灵活、性能高、无类型限制）。下图所示为一个过滤消息的配置示例：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a18cbed39bd24bd19aae392d2432f991~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n`MVEL` 类库在订单中心主要的应用场景是对预配置的表达式进行逻辑运算。\\n\\n```\\n Object result = MVEL.executeExpression(\\\"$actExt3$=='SECOBT_JD'&&$accountType$==21\\\", context);\\n\\n\\n```\\n\\n## 3.3 业务交易明细看板配置化\\n\\n我们提供了通用的数据查询接口和通用的查询页面，来满足数据检索的诉求。针对不同业务产品的交易场景，下游系统都有个性化的查询诉求，比如那些字段需要作为查询条件、哪些字段要在列表页展示、哪些字段需要导出等，类似这样的个性化诉求我们一样是通过配置化来支持的，如下图的配置示例所示：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a5e0290ac8642d49aeafca0921a3ca4~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n通用的查询页面通过切换业务线来联动更新查询条件和列表字段：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e9ad04744dc4e8ca2a4dfbdb0c94fa9~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n## 3.4 业务数据推送配置化\\n\\n我们也具备将上游产品层的数据转发给下游系统的能力，目前支持杰夫接口和 MQ 消息两种协议，针对下游接口标准不统一的情况，我们同样通过配置化的方式来支持：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b920dc7de2340b9b100bfd64e5263ff~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n下游接口的字段可以灵活配置，推送程序运行时解析推送配置，以交易数据为上下文组装推送参数，泛化调用下游接口。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef79f4ace4924d91a8070cca680fd730~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n# 4、规划\\n\\n交易履约订单中心经过 2 年的建设与推广使用，已经完成了系统的基本能力建设，通过配置化能满足多数交易场景的数据接入需求。但是对于运营效率提升、数据核对与告警等需求支持的还不完善，为了更好的发挥系统价值，进一步提升运营效率，交易履约订单中心有以下几个方面的规划：\\n\\n**完善配置化功能**：优化配置页面交互方式，降低使用门槛、提高运营效率。\\n\\n**提升稳定性**：建立熔断机制、应急响应机制等。\\n\\n**提升数字化能力**：建设支持更多维度的数据看板、建立数据核对与告警机制。"
    },
    {
        "article_id": "7189630062692401212",
        "cover_image": "",
        "title": "被面试官问住了，MySQL两阶段提交是什么鬼？",
        "brief": "MySQL通过两阶段提交的机制，保证了redo log和bin log的逻辑一致性，进而保证了数据的不丢失以及主从库的数据一致。",
        "user_name": "程序员拾山",
        "view_count": 1006,
        "collect_count": 4,
        "comment_count": 0,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/15e6bc5226c812b9ef9a6b17f151f046~300x300.image",
        "category": "后端",
        "content": "# 前言\\n\\nMySQL通过两阶段提交的机制，保证了redo log和bin log的逻辑一致性，进而保证了数据的不丢失以及主从库的数据一致。\\n\\n而说起两阶段提交，就不得不先介绍一下redo log和bin log。\\n\\n# redo log\\n\\n**redo log即重做日志，是InnoDB引擎特有的一种日志（有的面试官经常问到这一点）。**\\n\\nredo log主要做什么呢？\\n\\n以更新数据为例，我们知道，MySQL的数据是存储在磁盘上的，如果每一次更新数据，都去磁盘寻址找到要更新的数据，进行更新操作的话，这个IO成本是非常高的。\\n\\n如果是固态硬盘还好，如果是机械硬盘，那么MySQL的更新性能根本无法满足我们的业务需要。\\n\\n所以，MySQL采用了一种叫做WAL的技术，Write-Ahead Logging。\\n\\n当更新数据时，将更新操作（即某个数据页上做了什么修改）先写到redo log里面，然后更新内存，这个更新操作就算完成了。MySQL会在服务器空闲的时候，把redo log的操作记录刷新到磁盘里，以保持数据的一致性。\\n\\n**需要注意的是，redo log虽然也是磁盘上的一个文件，但是由于操作是顺序写，所以性能是非常高的。**\\n\\n当然了，redo log也是有大小上限的，不可能无限制的写入。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a1f28c17e9974f5c97d9b8bd9244a3d6~tplv-k3u1fbpfcp-zoom-1.image)[]()\\n\\n以上图为例，配置了4个redo log，write pos就是代表当前记录写到什么位置了，而check point表示一个推进点，它会不断的前移，做擦除数据的操作，以保证redo log可以不断的写入。\\n\\n当然，擦除数据之前，会把redo log的记录刷新到磁盘。\\n\\n通过redo log，可以保证即使MySQL发生异常重启，数据也不会丢失（因为redo log是物理日志，可以进行重放），这个特性就叫做crash-safe。\\n\\n# bin log\\n\\nbin log是MySQL Server提供的一种日志，叫做归档日志，**所有引擎都可以使用bin log。**\\n\\n那bin log和redo log的区别是什么呢？\\n\\n1，这两种日志的提供者不同：bin log是由MySQL Server提供的，redo log是InnoDB引擎特有的。\\n\\n2，redo log主要记录的是某个数据页做了什么修改，bin log记录的是语句的原始逻辑，比如更新了某一行的某个字段。\\n\\n3，redo log是循环写的，数据会被覆盖。bin log是追加写，一个文件写满，就写下一个文件。\\n\\n# 两阶段提交\\n\\n介绍完了redo log和bin log，我们再看一下他们两者是如何配合完成两阶段提交的。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a3555308711547a2a06299e8ba83d881~tplv-k3u1fbpfcp-zoom-1.image)[]()\\n\\n上图就是一个更新数据的流程，可以看到，在更新一条数据之前，MySQL会先将数据加载到内存，然后更新内存，开始写redo log。\\n\\n此时，redo log处于prepare状态，等到bin log写完之后，再提交事务，这一条记录的更新操作就算完成了。\\n\\nredo log prepare -> 写bin log -> redo log commit，这个流程就叫做两阶段提交。\\n\\n下面我们分析一下，采用两阶段提交的好处。\\n\\n情景一，redo log处于prepare状态时，如果写bin log失败了，那么更新失败，此时redo log没有commit，bin log也没有记录，两者的状态是一致的，没有问题。\\n\\n情景二，redo log处于prepare状态时，写bin log成功，但是宕机导致commit失败了。此时bin log产生了记录，redo log没有写入成功，数据暂时不一致。\\n\\n但是不用担心，当MySQL重启时，会检查redo log中处于prepare状态的记录。在redo log中，记录了一个叫做XID的字段，这个字段在bin log中也有记录，MySQL会通过这个XID，如果在bin log中找到了，那么就commit这个redo log，如果没有找到，说明bin log其实没有写成功，就放弃提交。\\n\\n通过这样的机制，保证了redo log和bin log的一致性。\\n\\n# 总结\\n\\n之所以MySQL中既存在redo log，又存在bin log，这是因为bin log是MySQL Server提供的一种归档日志，其本身并不具备crash-safe能力。而redo log本身不具备归档能力，他是一种循环写的日志。\\n\\nMySQL通过将这两种日志整合起来，并通过两阶段提交的机制，保证了数据的一致性。\\n\\n写文不易，感谢您的点赞和关注。"
    },
    {
        "article_id": "7189795041765195834",
        "cover_image": "",
        "title": "Babel 介绍和 AST 入门",
        "brief": "Babel 是什么 babel 是一个 js 转译器。主要用于在当前和旧的浏览器或环境中，将 ECMAScript 2015+ 代码转换为 JavaScript 向后兼容版本的代码，最开始叫 6to5",
        "user_name": "WhaleFE",
        "view_count": 690,
        "collect_count": 2,
        "comment_count": 0,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/7ba4cfbe328e8f6e5248947fc6b1a2c7~300x300.image",
        "category": "前端",
        "content": "> 本篇文章分享来自小伙伴「huanxing」的一次学习总结分享，希望跟社区的同学一起探讨。\\n\\n## Babel 是什么\\n[babel](https://babel.docschina.org/docs/en/) 是一个 js 转译器。主要用于在当前和旧的浏览器或环境中，将 ECMAScript 2015+ 代码转换为 JavaScript 向后兼容版本的代码，最开始叫 6to5，顾名思义是 es6 转 es5，但是随着ECMAScript 标准规范发展越来越快，新语法层出不穷，有了 es7、es8 等， 6to5 的名字已经不合适了，所以改名为了 babel。\\n\\n一般可以用于 es next、typescript等代码的转换，同时还暴露出了 api 让开发者可以进行特定用途的转换。除此以外，还可以做各种静态分析，如：语法检查，编译，代码高亮，代码转换，优化，压缩等等。\\n## Babel 编译流程\\nBabel 的编译流程主要分为三步：解析 -> 转换 -> 生成\\n\\n- parse：通过 parser 把源码转成抽象语法树（AST）。\\n- transform：遍历 AST，调用各种 transform 插件对 AST 进行增删改。\\n- generate：把转换后的 AST 打印成目标代码，并生成 sourcemap。\\n### parse(解析)\\n这个阶段的主要任务就是将code转为AST，其中会经过两个阶段，分别是词法分析和语法分析。\\n\\n比如 const CHANNEL_ID = 'zyzq'; 这样一段源码，我们要先把它分成一个个不能细分的单词（token），也就是 const， CHANNEL_ID， =， 'zyzq'，这个过程是词法分析，按照单词的构成规则来拆分字符串成单词。\\n\\n之后要把 token 进行递归的组装，生成 AST，这个过程是语法分析，按照不同的语法结构，来把一组单词组合成对象，比如声明语句、赋值表达式等都有对应的 AST 节点。\\n### transform(转换)\\ntransform 阶段是对 parse 生成的 AST 的处理，会进行 AST 的遍历，遍历的过程中处理到不同的 AST 节点会调用注册的相应的 visitor 函数，visitor 函数里可以对 AST 节点进行增删改，返回新的 AST（可以指定是否继续遍历新生成的 AST）。这样遍历完一遍 AST 之后就完成了对代码的修改\\n### generate(生成)\\n该阶段的任务就是将 AST 转换回 code, 在此期间会对 AST 进行深度优先遍历，根据节点所包含的信息生成对应的代码，并且会生成对应的sourcemap。\\n\\nsourcemap 记录了源码到目标代码的转换关系，通过它我们可以找到目标代码中每一个节点对应的源码位置，用于调试的时候把编译后的代码映射回源码，或者线上报错的时候把报错位置映射到源码\\n## 什么是 AST\\n从上面的介绍可以知道，babel 的整个编译流程都是围绕 AST 来的，那么什么是 AST 呢？\\n\\n在计算机科学中，抽象语法树（Abstract Syntax Tree，AST），或简称语法树（Syntax tree），是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。\\n\\n简单来说就是按照某种约定好的规范，以树形的数据结构把我们的代码描述出来，让 js 引擎和转译器能够理解。\\n\\n当然 AST 不是 JS 特有的，每个语言的代码都能转换成对应的 AST，并且 AST 结构的规范也有很多，Babel 使用一个基于 [ESTree](https://github.com/estree/estree) 修改过的 AST，我们可以通过 [AST explorer](http://astexplorer.net/) 这个网站在线生成AST，用来学习一下结构。\\n\\n如下图，可以看到 const CHANNEL_ID = 'zyzq' 的 AST 结构，我们找到了几个重要信息，最外层是一个VariableDeclaration 意思是变量声明，所使用的类型是 const，字段 declarations 内还有一个 VariableDeclarator[变量声明符] 对象，有一个命名为 CHANNEL_ID 的 Identifer[标识符] ，值为 zyzq 的 Literal[字面量]。\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9041fdff1a894e40ac249b84a5190df3~tplv-k3u1fbpfcp-zoom-1.image)\\n## 常用的 AST 节点\\n如果想要了解或者进行 babel 插件开发，了解一些常用的 AST 节点是必不可少的，如：\\n\\n1. Literal \\n\\nLiteral 是字面量的意思，比如 const CHANNEL_ID = 'zyzq'中，'zyzq'就是一个字符串字面量 StringLiteral，相应的还有数字字面量 NumericLiteral，布尔字面量 BooleanLiteral，模板字面量 TemplateLiteral，正则表达式字面量 RegExpLiteral 等。代码中的字面量很多，babel 就是通过 xxLiteral 来抽象这部分内容的。\\n\\n2. Identifer \\n\\nIdentifer 是标识符的意思，变量名、属性名、参数名等各种声明和引用的名字，都是Identifer。我们知道，JS 中的标识符只能包含字母或数字或下划线（“_”）或美元符号（“$”），且不能以数字开头。这是 Identifier 的词法特点。\\n\\n3. Statement \\n\\n语句是代码执行的最小单位。我们常见的有 if 语句、while 语句、return 语句等等。下面代码中每一行都是一个 Statement\\n```javascript\\nbreak;\\ncontinue; \\nreturn; \\ndebugger; \\nthrow Error(); \\n{} \\ntry {} catch(e) {} finally{} \\nfor (let key in obj) {} \\nfor (let i = 0;i < 10;i ++) {} \\nwhile (true) {} \\ndo {} while (true) \\nswitch (v){case 1: break;default:;} \\nlabel: console.log(); \\nwith (a){}\\n```\\n\\n4. Declaration\\n\\n声明语句是一种特殊的语句，它执行的逻辑是在作用域内声明一个变量、函数、class、import、export 等\\n```javascript\\nconst a = 1;   //VariableDeclaration\\nfunction b(){} //FunctionDeclaration\\nclass C {}     //ClassDeclaration\\nimport d from 'e';  // ImportDeclaration\\nexport default e = 1; //ExportDefaultDeclaration\\nexport {e};    //ExportNamedDeclaration\\nexport * from 'e'; //ExportAllDeclaration\\n```\\n\\n5. Expression\\n\\nexpression 表达式的特点是执行完成后会有返回值，这也是它和语句的区别。 有的表达式可以独立作为语句执行，所以在解析时会在最外层加一个 ExpressionStatement 节点。 常见的表达式有以下几种：\\n```javascript\\n[1,2,3]       //ArrayExpression 数组表达式\\na = 1         //AssignmentExpression 赋值表达式\\n1 + 2;        //二元表达式\\n-1;           //一元表达式\\nfunction(){}; //函数表达式\\n() => {};     //箭头函数表达式\\nclass{};      //class表达式\\na;            //标识符\\nthis;         //this表达式\\nsuper;        //super\\na::b;         //绑定表达式\\n```\\n\\n6. Class\\n\\nclass 的语法比较特殊，有专门的 AST 节点来表示。整个 class 的内容是 ClassBody，属性是 ClassProperty，方法是ClassMethod（通过 kind 属性来区分是 constructor 还是 method）。如：\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e98f8701d8ca4bd2a396216f6dcde52e~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n7. Import\\n\\nimport 有 3 种语法\\n\\nnamed import：\\n```javascript\\nimport {c, d} from'c';\\n```\\ndefault import：\\n```javascript\\nimport a from 'a';\\n```\\nnamespaced import:\\n```javascript\\nimport * as b from 'b';\\n```\\n这 3 种语法都对应 ImportDeclaration 节点，但是 specifiers 属性不同，分别对应 ImportSpicifier、ImportDefaultSpecifier、ImportNamespaceSpcifier。\\n\\n8. export\\n\\nexport 也有3种语法\\n\\nnamed export：\\n```javascript\\nexport { b, d};\\n```\\ndefault export：\\n```javascript\\nexport default a;\\n```\\nall export：\\n```javascript\\nexport * from 'c';\\n```\\n分别对应 ExportNamedDeclaration、ExportDefaultDeclaration、ExportAllDeclaration。\\n\\n9. AST 的公共属性\\n- type： AST 节点的类型\\n- start、end、loc：start 和 end 代表该节点在源码中的开始和结束下标。而 loc 属性是一个对象，有 line 和 column 属性分别记录开始和结束的行列号。\\n- leadingComments、innerComments、trailingComments： 表示开始的注释、中间的注释、结尾的注释，每个 AST 节点中都可能存在注释，而且可能在开始、中间、结束这三种位置，想拿到某个 AST 的注释就通过这三个属性。\\n- extra:：记录一些额外的信息，用于处理一些特殊情况。比如 StringLiteral 的 value 只是值的修改，而修改 extra.raw 则可以连同单双引号一起修改。\\n\\n以上就是 AST 的常用节点介绍，了解了 AST 就可以把对代码的操作转为对 AST 的操作了，这是编译、静态分析的第一步。\\n\\n## 参考文档\\n\\n- [https://blog.csdn.net/weixin_33826609/article/details/93164633?spm=1001.2101.3001.6650.4&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-4-93164633-blog-121798316.pc_relevant_aa_2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-4-93164633-blog-121798316.pc_relevant_aa_2&utm_relevant_index=9](https://blog.csdn.net/weixin_33826609/article/details/93164633?spm=1001.2101.3001.6650.4&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-4-93164633-blog-121798316.pc_relevant_aa_2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-4-93164633-blog-121798316.pc_relevant_aa_2&utm_relevant_index=9)\\n- [https://juejin.cn/post/7025193043460358151](https://juejin.cn/post/7025193043460358151)\\n\\n"
    },
    {
        "article_id": "7189526259720781884",
        "cover_image": "",
        "title": "Webpack 源码调试过程记录 - 主要流程、最简情况（单入口，无其它引入）",
        "brief": "没有华丽的标题，也没有插图，主要是早前记录笔记（所谓“文字直播”）。 笔者也是第一次调试Webpack源码。如有错误的地方欢迎指正。 本文或许可以给需要调试Webpack源码的读者提供一些参考。",
        "user_name": "gogoend",
        "view_count": 483,
        "collect_count": 1,
        "comment_count": 1,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/355e1853f020bb477c79f2a95a48f78c~300x300.image",
        "category": "前端",
        "content": "本文没有华丽的标题，也没有插图，主要是早前记录的一些笔记（所谓“文字直播”）。\\n\\n相关步骤可能不准确，因为笔者也是第一次调试Webpack源码。如有错误的地方欢迎指正。\\n\\n文章中有一些 TODO项，是当时、在程序执行到相关步骤时突然想到的一些问题。\\n\\n本文或许可以给需要调试Webpack源码的读者提供一些参考。请对照源码、打好断点，阅读本文。\\n\\n如果没有用过Webpack，或者是Webpack的初学者，本文可能不适合你。\\n\\n# 调试版本\\n`webpack@5.75.0`\\n\\n# 本次上下文\\n1. 单入口打包，入口仅仅引用了Js脚本文件，没有其它文件。\\n\\n2. 初始化阶段已结束，进入构建阶段\\n\\n# 当前断点位置\\n准备调用compilation.addEntry方法。\\n\\n# 调试过程\\n进入_addEntryItem；此处进行一个entryData的判断（TODO1 这个判断是干什么的？与缓存有关吗？）然后调用addModuleTree\\n\\naddModuleTree中调用handleModuleCreation，生成、创建模块\\n\\n如果handleModuleCreation中通过毁掉抛出任何错误，且bail为真值（TODO2 那么bail是什么？），那么看起来\\nbuildQueue、rebuildQueue、processDependenciesQueue、factoriesQueue这几个队列会被停掉？（TODO3 这几个队列是做什么的？）\\n\\n进入handleModuleCreation，其中调用factorizeModule方法，用于……分解模块？（TODO3 到底是什么……）\\n\\n看起来factorizeModule这个过程是一个异步过程，通过一个队列来进行调度，这里仅仅是一个函数的入口🤔\\n最终给到异步队列进行调用的，实际上是_factorizeModule方法 —— 里面包含了一些真实的操作\\n\\n到这里，所有同步操作结束，此时调用栈会被依次清空。异步操作的回调将在后续可以执行的时候执行。\\n\\n此时complier已经建立完成。\\n\\n接下来开始处理队列。现在执行的是上面提到的_factorizeModule。其中会执行factory.create。factory由外部动态传入，类型不定，但均包含一个create方法。当前上下文中，factory是NormalModuleFactory（的实例？）。因此下一步将进入NormalModuleFactory.prototype.create方法\\n\\nNormalModuleFactory.prototype.create方法，没细看……看起来就收集了一些模块相关信息，然后依次调用了beforeResolve、factorize钩子。factorize钩子调用过程中，将会通过回调，把当前factorize（创建？分析？）出来的模块，给传到某个地方（？？？）\\n\\n跟丢了……我想想\\n\\n看起来这里factorize钩子的调用（factorize.callAsync）不简单。\\n调用钩子时，传入了一些解析出来的数据。根据这些数据，可以生成module（TODO4 暂时不是很想看此处的过程……）生成module后传给factorize.callAsync的回调函数，加入到要返回的对象中。然后执行回调，依次往上调用回调，就回到了factorizeModule的回调中。此时就可以继续其它操作。\\n\\n在factorizeModule回调中，将会调用addModule。addModule也只是一个把任务放进队列里的函数，具体操作是在_addModule中执行。\\n\\naddModule后，执行一对乱七八糟的同步操作（TODO5 暂时没注意这些操作是什么……），然后才进入_addModule函数\\n\\n_addModule中会判断一下当前模块是不是已有模块，即根据模块id，判断_modules中有没有这个模块，如有，直接调用回调函数并返回；没有的话，好像会进行一些操作，然后把模块加到_modules中。（TODO6 这些操作什么？看起来附近代码有一些cache相关的东西？）\\n后续将进入addModule的回调\\n\\n在addModule回调函数中，将会调用applyFactoryResultDependencies这个函数。看了看这个函数，大致作用是将factoryResult中的fileDependencies、contextDependencies、missingDependencies设置到当前compilation的对应变量中。\\n\\n之后对每个dependency调用moduleGraph.setResolveModule，大意应该是把当前依赖放到模块图上？\\n\\n之后调用的是_handleModuleBuildAndDependencies。其中将会调用buildModule函数 —— 看起来终于要进入buildModule阶段了\\n此处buildModule函数，同样也仅仅是把buildModule这个操作放入了buildQueue这个异步队列。具体操作定义在_buildModule函数上。\\n\\n在从buildModule进入_buildModules之前，也会进行一些乱七八糟的工作（看起来和Cache有关）；这些工作执行完后，将开始依次处理异步队列中的任务。这样后续将会执行到_buildModules。\\n\\n现在，进入_buildModule看看里面有什么……\\n\\n_buildModule中首先会执行一个needModule函数，其回调结果needBuild将指明它要不要被build（我猜的，因为如果它是false后面流程就走不下去了），然后触发buildModule钩子、将当前模块插入已构建模块集合，然后执行module.build函数 —— 这里将进入NormalModule.prototype.build函数中\\n\\n在build中进行一些信息收集后，将会进入_doBuild。首先执行_createLoaderContext获取loader上下文。接下来执行runLoaders（❗️TODO7 Webpack中的loader是在这里被调用的吗？看起来好像是的！！具体实现后续再看）。直接进入回调函数，再进入processResult中。目前，source是一个Buffer对象，其中包含了文件内容（这里目前只有一个Js文件，且未引入或导出任何内容）。这里通过createSource拿到文本内容，赋值给_source。接下来可以看到一个为_ast赋值的操作，看起来这里暂时为null。以上操作完成后，执行回调，进入_doBuild的回调函数。\\n\\n_doBuild回调首先定义了一些函数，用于处理：\\nparse 错误、成功\\nbuild 完成\\n\\n之后通过调用parser.parse，来把代码文本转换为ast。在NormalModule中不能直接看到转换出来的ast结构，但在parse函数中可以看到。\\n\\nparser.parse的定义在JavascriptParser.prototype.parse下。这里获得ast后，也会遍历ast。遍历到不同语句时，将执行各种不同的钩子（Webpack文档-API-JavascriptParser章节可以看到）\\n\\n太困，跟丢了……但后续要跟的部分大致包括\\n1. 模块之间的依赖关系是怎样确立的？（猜想应该是遍历ast过程中，拿到了import/require语句，这样的话模块之间可以产生一个图，最终遍历这个图，得到依赖关系）\\n2. 编译好的模块是在哪里被写入硬盘的？\\n3. Webpack是怎样对不同类型的导入导出语句做转换的？\\n\\n继续文字直播。\\n（TODO8 parse.parser中为何会有形如oldScope = this.scope 这样的语句？这个语句的作用是什么？）\\n\\nparser.parse调用的结束后，进入了handleParseResult函数中即前文说的再_doBuild中定义的处理parse成功的函数。这里看起来会对dependencies进行一次排序。我猜是会对模块进行排序。不过我怀疑，因为本次上下文中仅有一个Javascript文件（即入口文件），因此这个数组是空的。\\n接下来执行_initBuildHash，其中看起来会根据当前模块的代码进行计算，获得hash，并赋值给this.buildInfo.hash。\\n\\nhandleParseResult在函数末尾将会调用handleBuildDone函数。看起来这里会检查一下dependencies中包不包含非绝对路径的dep？没懂\\n之后会调用compilation.fileSystemInfo.createSnapshot来建立一个……文件系统的快照……？建立结束后，将给当前NormalModule的buildInfo.snapshot赋值为snapshot，buildInfo.fileDependencies、buildInfo.contextDependencies、buildInfo.missingDependencies将置为undefined；接下来将调用build中传入的回调函数，这将回到Compilation的module.build的回调函数中。\\n\\n在module.build中，看起来将会在_modulesCache.store中缓存一下当前模块。缓存完后，将调用_modulesCache.store的回调函数。其中将会触发successModule钩子。接下来将调用_buildModule的回调函数。\\n\\n_buildModule的回调函数即buildModule的回调函数。其中会调用processModuleDependencies。同样该函数也仅仅是将处理模块依赖这个地址放到异步队列中。真正的操作位于_processModuleDependencies。后续在处理队列时将会调用_processModuleDependencies。\\n\\n断点来到_processModuleDependencies，这里可能是对模块进行排序的地方？\\n这里定义了：\\nonDependenciesSorted\\nonTransitiveTaskFinished\\nprocessDependency\\nprocessDependencyForResolving\\n函数。\\n\\n首先看到这里有个队列，遍历时把元素弹出，然后对元素下方dependencies中的元素执行processDependency函数。如果当前元素下方blocks属性中有元素，则把执行元素放到队列中，继续迭代队列。\\n\\n感觉这里涉及到的都是图的排序了吧？似乎是拓扑排序？\\n\\n由于这里上下文中一直都只有一个Javascript文件，无其它导入导出，因此无需进行队列中的一些操作，直接来到函数末尾，进入onDependenciesSorted函数。\\n\\n断点来到onDependenciesSorted函数，同样由于上下文中一直只有一个Javascript文件且其中没有导入或导出任何内容的关系，sortedDependencies将是一个空数组。\\n\\n之后调用到processModuleDependencies的回调函数，然后再进入handleModuleCreation的回调函数，再进入handleModuleTree的回调函数并触发compilation的succeedEntry钩子，然后进入EntryPlugin中compilation.addEntry的回调函数，然后进入了compiler的make钩子的回调函数\\n\\n接下来将会触发finishMake钩子（TODO9 此时触发它有什么具体作用吗？）nextTick后，将执行compilation.finish方法，在finish方法的回调函数中再调用compilation.seal方法，再在seal方法的回调函数中再触发complier的afterComplie钩子。最后，再调用compiler.complie中的回调函数，即onCompiled。\\n\\n在compilation.seal中，第一次出现了chunk这个概念🤔\\n\\n继续文字直播。\\n今天预计再看从compilation.finish调用compilation.seal，以及之后的一些过程。\\n\\n进入compilation.finish方法后，首先会清空compilation.factorizeQueue队列，然后……计算受影响的模块（_computeAffectedModules）（TODO10 这是要做什么？没进入该函数细看，后续可以看看），接下来将触发compilation的finishModules钩子。然后获取这些模块中存在的警告或错误，分别放入当前compilation的error、warn数组中（TODO11 这是要做什么？莫非要在某个地方输出这些错误？后续可以关注一下）。\\n在获取模块警告或错误前后，分别调用了当前compilation的moduleGraph.freeze及moduleGraph.unfreeze（TODO12 为何要调用这两个方法？）。\\n接下来进入compilation.finish的回调函数中，在这里，将会调用compilation.seal方法。\\n\\n断点现在来到了compilation对象上的seal函数。看起来，首先会根据moduleGraph创建一个chunkGraph（TODO13 后续看看相关过程），之后触发compilation的seal钩子，然后触发compilation的optimizeDependencies、afterOptimizeDependencies钩子（TODO14 这里面的优化操作是什么？压缩代码吗？），接下来触发compilation的是beforeChunks钩子\\n\\n……接下来有300行代码堆在这里……🫠\\n\\n首先将开始一个for循环。这个循环将循环webpack打包配置中的所有入口。由于本次上下文仅有一个入口，因此for循环只执行一次。\\n首先执行addChunk函数，来创建一个新chunk/复用已有chunk并且加入到chunks中。\\n然后建立一个entrypoint对象（TODO15 这个entrypoint对象是干什么的？），并以当前chunk来setRuntimeChunk、setEntrypointChunk；接下来在namedChunkGroups、entrypoints、chunkGroups中加入当前entrypoint的相关信息，然后执行connectChunkGroupAndChunk方法。\\n\\n下面再进入一层for循环，这次遍历的是全局入口的依赖以及当前入口的依赖拼成的数组。在entrypoint中加入当前依赖的相关信息。然后根据当前依赖，从moduleGraph中获取对应模块。下面执行chunkGraph.connectChunkAndEntryModule，参数为当前chunk、module与entrypoint，然后在entryModule中加入当前module。接着根据entrypoint来从chunkGraphInit中获取此entrypoint对应的模块列表，并将当前module插入到模块列表中。\\n此时本层级for循环结束，继续外层for循环。\\n\\n接下来调用assignDepths方法，(看起来好像是设置某个深度的值？）然后对所有依赖进行排序（mapAndSort方法：根据dep从moduleGraph中获取模块，并按照模块Id（看起来是文件路径）进行排序）。下面根据entrypoint从chunkGraphInit中获取模块列表，获取后，为includedModules中的module进行一次for循环，为每个module调用一次assignDepth方法，然后在模块列表中压入当前for循环遍历到的项目。然后此时本层级for循环结束，回到上一层级。\\n\\n回到上一层级后，上一层级的for循环也结束。\\n\\n上一个for循环结束后，下面来到的是另一个for循环。这里的for循环以outer为标记，循环的内容也是所有compilation的入口。好像里面是在处理dependOn、runtime两个配置的一些关系？这里后续再看吧，暂时不看了……\\n\\n之后进入buildChunkGraph函数，大意是，根据ModuleGraph来建立ChunkGraph。函数入参是compilation及chunkGraphInit（TODO16 chubkGraphInit到底是什么？）\\n\\n之后会触发一个compilation的optimize钩子（TODO17 所以上面的过程是在优化一些东西吗？还是其它一些操作？）\\n\\n接下来主要都是compilation上各个钩子的一些调用，暂时不看了\\n\\n不过根据网上的一些文章，如果配置了SplitChunksPlugin插件，那么在optimizeChunk钩子时，将会进行一些操作（TODO18 SplitChunksPlugin具体操作是指什么？待分析此插件）\\n\\n下面就该进入codeGeneration函数了\\n\\n继续开始文字直播～现在断点进入codeGeneration函数。\\n\\ncodeGeneration函数是compilation对象上的一个方法。首先创建一个map用以存储codeGenerationResults，接下来遍历compilation上modules中的每一个module，依次作为chunkGraph.getModuleRuntimes的参数进行调用，来获得runtimes。根据这些runtimes，生成一个job。接下来调用compilation上的_runCodeGenerationJobs，来……执行这些job（？）\\n\\n下面断点来到_runCodeGenerationJobs函数中。这里可以看到一个runIteration函数的定义。看起来job将会在这个函数中被调度、执行；该函数中有一个asyncLib.eachLimit的函数调用，共传入了4个参数，分别是\\njobs列表、\\nparallelism（并行任务数？）、\\n迭代函数（类似Array.prototype.filter的参数）、\\n任务处理结束/出错时的回调函数。\\n迭代函数中将会调用到compilation上的_codeGenerationModule方法，断点进入这一方法。暂时跳过缓存部分，来到module.codeGeneration的调用。这里来到的是NormalModule的codeGeneration方法。里面可以看到一个for循环，循环的是模块的类型。目前仅有一种类型，即javascript。来到此处for循环下的this.generator.generate调用。这里将来到JavascriptGenerator中的generate方法下。……不过这里不是重点，因此回到上面的for循环中（TODO19 JavascriptGenerator中的generate方法做了什么？）。接下来for循环结束，将{sources, runtimeRequirements, data}作为resultEntry返回到compilation中相关变量（_codeGenerationModule下result），同时断点回到对应函数（_codeGenerationModule）。之后为result进行缓存，再调用回调函数，回到compilation下codeGeneration方法的回调函数中。\\n\\n在codeGeneration的回调函数中似乎还会再执行一次_runCodeGenerationJobs函数，第一个参数是刚刚新创建的codeGenerationJobs，第二个参数操作完了以后的回调函数。不过本次上下文中，这一数组为空，因此并不会做其它操作，将进入回调函数。\\n\\n接下来将调用this.createChunkAssets函数。在此之前将触发shouldGenerateChunkAssets同步钩子来决定要不要执行这个函数。此上下文中该函数将会执行。断点进入this.createChunkAssets。\\n这里可以看到输出配置，然后异步地遍历this.chunks。其中将根据当前compilation的一些信息，产生一些manifest，然后再进入一层异步遍历，对每一个manifest（fileManifest）进行遍历。下面将进入一个try...catch块，首先确定要产生的文件文件名是什么，确定source应当从何处取值（已缓存的source、已被写入的chunk文件或通过fileManifest.render生成一个并将新的source缓存到cachedMap中）。\\n\\n下一步执行的是当前compilation的emitAsset方法。（这是要开始写文件了吗？！不过进去看了好像还不到，因此先跳过）然后是触发compilation的chunkAsset钩子。然后在已被写入的chunk文件数组中加入当前项{hash, source, chunk}（实际上此时好像还没产生文件？）然后在已缓存的source中也缓存一下当前source。\\n之后一路执行回调函数，进入createChunkAssets的回调中。在这里，将执行cont函数。其中将会触发compilation的afterSeal的异步钩子。之后将调用finalCallback。finalCallback中将会清空掉\\nfactorizeQueue、buildQueue、rebuildQueue、processDependenciesQueue、addModuleQueue，然后执行seal中传入的回调。\\n以上，compilation的seal过程结束\\n\\n现在，断点回到了compiler.js调用compilation.seal时传入的回调函数中。下面将会触发compiler的afterCompile钩子。然后在这里将会执行到compiler的回调函数，即onCompiled中。\\n\\n现在断点来到了onCompiled；\\n从这里开始，应该就有一些往文件系统写文件的操作了吧。\\n首先执行shouldEmit同步钩子，来确定compilation对应的文件该不该被输出，这里暂时认为文件都应该被输出。nextTick后，执行compiler的emitAssets。\\n现在断点进入emitAssets，触发compiler的emit钩子，在钩子中调用mkdirp(this.outputFileSystem, outputPath, emit)，来输出最终文件。\\n\\n现在继续文字直播……真困了\\n\\n目前断点进入emitAssets下emitFiles方法，这个方法中将执行一个asyncLib.forEachLimit这样一个队列。\\n\\n呃，好吧，凌晨一点，瞌睡来了，我也不知道我在写什么东西；晚安\\n\\n首先还是来到mkdirp，这个函数看起来用于确保文件输出目录，即outputPath的存在。接下来将会进入mkdirp的回调，即emitFiles方法。\\n\\n断点来到emitFiles方法中；首先会获取到compilation中的所有assets；通过asyncLib.forEachLimit，来遍历处理这些assets（TODO20 这里可能是异步处理？好像这里可以限制一次处理的次数？这里是15个）。\\n接下来进入第三个参数，即对于每个asset项都将会执行一次的函数。这里结构出了asset的name，source，info。然后执行writeOut函数。（TODO21 writeOut函数的具体内部实现后续再看）writeOut函数中存在一个doWrite函数，其中将会执行this.outputFileSystem.writeFile。在这里加断点，并执行到这里。不过，这个函数具体实现暂时也不看。直接进入回调函数中。在回调函数中第一行处加断点，断在这里，此时可以看到文件系统中已经出现了打包出来的文件（🤩），后面在这里进行一些操作，例如缓存（我猜是为了避免重复输出），然后触发compiler的assetEmitted钩子。触发的时候，会把用于标识当前队列项处理完成的callback作为参数。因此或许它就是这个钩子的处理函数？\\n\\n由于本次上下文里仅包含一个js文件，因此队列处理函数仅执行一次，因此改项处理后，队列即处理完成；下面将进入队列处理完成的回调函数。这里会触发compiler的afterEmit钩子，在处理函数中，执行整个emitAssets钩子的回调函数，标识emitAssets完成。因此下面断点回到了onCompiled中定义的this.emitAssets的回调函数中。\\n\\n现在继续文字直播\\n断点进入onCompiled中定义的this.emitAssets的回调函数中\\n\\n在这里接下来会执行到emitRecords函数，好像是写一下构建记录？不过这里没有指定，因此直接进入回调。回调中会收集一下当前compilation的一些构建统计（开始时间、结束时间、Hash之类的）来赋值给stats变量，然后将触发compiler上的done钩子；在done钩子处理函数中，似乎会对缓存进行一些处理（this.cache.storeBuildDependencies调用），然后在缓存处理的回调函数中，将执行finalCallback，执行时将带着stats参数。\\n\\n断点来到finalCallback函数，此处没有很多特别的逻辑。\\n其中将会调用：在执行compiler.run时，传入的回调函数，参数即是stats。断点进入这一回调函数，将执行compiler.close方法。该方法将关闭watching，并触发compiler的shutdown钩子，然后执行this.cache.shutdown方法 — 在这里将执行从compiler.close传入的回调，因此断点进入到compiler.close的回调中。\\n这里仅有一行调用回调的方法，参数是stats，这里的回调是webpack-cli在runWebpack中调用createCompiler（compiler = this.webpack 附近）时传入的。因此现在断点来到了这里。\\n进入这个回调，首先看看有没有错，有的话程序将可能会推出且exitCode不为0；接下来跳过一些步骤，来到this.logger.raw(printedStats)，这里会在终端里打印经过格式化处理的stats信息（也就是我们平常看到的输出哪些文件、构建了多久一类的信息）\\n\\n接下来一路单步调试（Step Over），回到finalCallback中，触发一下compiler的afterDone钩子，参数为stats。\\n\\n接下来就没有过多实质性的内容了，可以看到调用栈里的调用（或者说应该是异步函数产生的调用？）一直在不断地变少，直到调用栈被清空。\\n\\n此时进程退出。\\n\\n# 读后\\n\\n好了，马马虎虎走过了一遍，终于执行完了……8号到16号，看了差不多一个星期；而且中间一些重要步骤暂未覆盖，因为本次调试上下文真的很简单🫠\\n\\n调试难点感觉主要是一大堆：\\n1. 回调地狱\\n2. asyncLib.forEach / asyncLib.forEachLimit\\n3. 钩子的执行\\n4. 任务调度\\n真心头大，这些让调试之路变得十分崎岖。🤯\\n\\n# 参考资料\\n1. [[万字总结] 一文吃透 Webpack 核心原理 由范文杰撰写](https://juejin.cn/post/6949040393165996040)\\n这篇文章帮我厘清了Webpack的基本逻辑，我在调试无助的时候总能在这篇文章里找到一些答案\\n2. [Webpack 官方网站 Plugins相关章节](https://webpack.js.org/api/compiler-hooks/)\\n主要大致了解了一下各个钩子的作用\\n\\n# 后续总结（TL;DR）\\n根据上文，再次跟踪相关断点，对Webpack执行过程进行大体总结。\\n\\n## 1. 初始化阶段\\n这一阶段要做的事情是，得到编译过程中将要使用的compiler。将webpack.config.js中的配置与Webpack的默认配置进行合并，同时执行所有插件的apply函数，然后将返回本次编译使用的compiler。\\n\\n## 2. 构建阶段\\ncompiler.compile的执行标志着构建阶段的开始。这一阶段要做的事情是，创建module。进入compiler.compile后将触发compiler的beforeCompile、compile钩子；接下来将创建本次编译对应的compilation对象，并将其作为参数依次触发此阶段compiler的make、finishMake钩子。make钩子触发后，finishMake钩子触发前，将执行已注册的EntryPlugin中对应钩子的一些逻辑。其中将调用compilation.addEntry；经过一些调用后，将进入compilation.handleModuleCreation后的逻辑，其中将会\\n① 运行loader，将任意导入的文件转换为Js代码\\n② 遍历Js ast的导出、导入语句，确定各module之间的的依赖关系\\n在compilation.handleModuleCreation执行完成，进入其回调函数后，将可以看到已经得到的Js源码。之后再回调，将会进入make钩子的回调函数，并接着触发finishMake钩子。其中将会执行到compilation.finish函数。此时，构建阶段便已结束。\\n\\n## 3. 生成阶段\\ncompilation.finish的回调函数中的compilation.seal是这一阶段的开始。这一阶段要做的事情是，将module转换（整理？）为用于进行输出的chunk。其中的this.createChunkAssets函数调用，会执行fileManifest.render函数，从而获取到当前chunk对应文件的内容，相关信息会附加到当前chunk上。后续将触发到compilation的afterSeal钩子，并进入compilation.seal的回调函数中。在这里将会触发compiler的afterCompile钩子。此时就认为生成阶段结束了。\\n\\n## 4. 文件输出阶段\\ncompiler.run中onCompiled的调用标志着这一阶段的开始。这一阶段要做的事情是，将chunk作为文件，输出到文件系统。其中首先会触发compiler的shouldEmit钩子，来确定要不要输出文件到文件系统，然后在this.emitAssets中，触发emit钩子；接下来调用到emitFiles函数，来从compilation中获取到所有asset，再通过writeOut->doWrite这样一些调用，把文件写入文件系统，每写入一个文件，会调用触发一次assetEmitted钩子。后续将继续触发compiler的afterEmit、done钩子，然后在控制台打印一些已输出到文件的信息，然后触发compiler的afterDone钩子。\\n\\n到此，所有过程全部结束。"
    },
    {
        "article_id": "7189805638745063483",
        "cover_image": "",
        "title": "顶刊TIP 2022｜武汉大学遥感国重团队提出二元变化引导的高光谱遥感多类变化检测网络BCG-Net",
        "brief": "来自武汉大学测绘遥感信息工程国家重点实验室的研究团队提出了一种用于 HMCD 的无监督二元变化引导的高光谱多类变化检测网络 (Binary Change Guided hyperspectral",
        "user_name": "CV顶刊顶会",
        "view_count": 553,
        "collect_count": 1,
        "comment_count": 0,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/8a2627eb8604780a9ace5d5b2bc28331~300x300.image",
        "category": "人工智能",
        "content": "![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f32067755e1a412f9f6d403a5b8496a7~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n> 论文标题：Binary Change Guided Hyperspectral Multiclass Change Detection      \\n> 论文链接：https://ieeexplore.ieee.org/document/10011164        \\n> 作者单位：武汉大学（Liangpei Zhang，IEEE Fellow）     \\n\\n**欢迎关注公众号 CV顶刊顶会，认真且严肃的计算机视觉论文前沿报道~** \\n\\n*期刊介绍：IEEE Transactions on Image Processing（IEEE TIP）是图像处理领域公认的顶级国际期刊，是中国计算机学会（CCF）推荐的A类期刊，代表了图像处理领域先进的重大进展，要求论文在理论和工程效果上对图像处理及相关领域具有重要推动作用，其最新的影响因子为[15.8](https://academic-accelerator.com/Real-Time-Impact-of-Journal/IEEE-Transactions-on-Image-Processing)。*     \\n\\n**遥感图像变化检测任务常会利用高光谱图像，高光谱图像具有较为丰富的光谱信息，能够检测到地理目标的细微的变化**，以便于区分各种变化类别。目前大多数解决高光谱多类地物变换检测任务（hyperspectral multiclass change detection，HMCD）的方法都**基于光谱分离机制，这类方法往往会受到时间相关性和误差累积的干扰**。 来自**武汉大学测绘遥感信息工程国家重点实验室的研究团队提出了一种用于 HMCD 的无监督二元变化引导的高光谱多类变化检测网络 (Binary Change Guided hyperspectral multiclass change detection Network，BCG-Net)成功发表在图像处理领域顶级期刊IEEE TIP上**。BCG-Net旨在利用目前较为**成熟的二元变化检测方法来提高多类变化检测的精度和性能**。 在 BCG-Net 中，作者为多时相光谱解混设计了一种**局部孪生解混（partial-siamese united-unmixing）模块**，此外，还设计了一种由二进制变化检测结果的伪标签引导的时序性相关约束，来指导多类变化检测的过程，鼓励未变化像素的匀质区域更连贯，变化像素的区域更准确。此外，针对传统变换检测规则易受数值影响的问题，作者还**提出了一种创新的二进制变化检测规则**。作者在多个数据集上进行的实验结果表明，提出的 BCG-Net 可以在多类变化检测任务中实现非常出色的性能，同时获得更好的光谱分离结果。   \\n## 1.引言  \\n\\n一般来说，**高光谱变化检测分为高光谱二元变化检测（HBCD）和高光谱多类变化检测（HMCD）两种**。HMCD长期以来一直是一项具有挑战性的研究课题，与 HBCD 相比，HMCD 不仅需要检测变化区域和未变化区域，还需要识别变化的数量并区分与不同土地覆盖转变相关的不同类型，相比之下，**HMCD的结果可以为遥感测绘人员提供更详细的地物变更信息**。对于 HMCD 最直接的解决方案是分类后比较方法 (post classification comparison，PCC) [33]，即先分别对两个不同时段的高光谱图像进行分类，然后比较多时态分类图以获得多类变化检测结果。但是这种方法需要大量详细标注的训练样本。**后来的一些方法提出将光谱分离机制（spectral unmixing，SU）融入到变换检测框架中**，SU是一种将混合像素的**光谱特征分解为端元及其相应比例（称为丰度）的过程**，是解决混合像素问题的有力工具。如下图所示，可以直接使用丰度图来计算二元和多类变换检测结果，但是这类方法也面临着在没有误差累积的情况下进行检测的问题，**对丰度进行直接比较可能会放大多时相的丰度方差和分离误差**。因而对结果产生噪声和以及错误移位的检测结果。   \\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ad696459384494d9dfafaff91bf7fc4~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n但是作者也观察到，通过SU计算得到的二进制变化检测结果具有一定的可信度，**并且其包含了分离和变化检测之间的误差累积和偏差**。作者想到是否可以从改进二元变化检测结果入手，进一步**完成光谱分离和变化检测的协同优化**呢？因此在本文中，作者提出了BCG-Net来解决错误累积的问题，如下图所示，即通过二元变化检测（BCD）结果构成的伪标签来引导多类的检测，实际上，多时相图像的BCD结果是时间相关性的标志，**也就是说，如果两个相位相同位置的像素点没有发生变化，那么这两个像素点的丰度很可能是相似的**；具体来说，给定来自 BCD 结果的可靠伪标签，根据 SU 结果计算的 BCD 结果与伪标签之间的误差图可以看做是光谱分解到变化检测过程之间的累积误差和偏差，**我们可以通过反向传播对误差图进行优化，以此过程达到对SU和BCD的协同优化**，来达到高精度的二元和多类变化检测结果。   \\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/816b260495ee45638c391f1a0cabfb05~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n\\n\\n## 2.方法介绍    \\n\\n下图展示了BCG-Net的整体框架，其由两部分构成，即**联合分离模块（United Unmixing Module，UU-Module）和时序相关模块（Temporal Correlation Module，TC-Module）**。BCG-Net的具体操作过程如下：首先将一组双时相图像块送入到UU-Module来获得相应的丰度向量。UU-Module 的输出然后被送入到 TC-Module，TC-Module 旨在获取像素的二进制变化信息，然后将结果与给定的二进制伪标签进行比较，**如果二进制变化结果与给定的二进制标签一致，则联合分解结果是合格的。否则，将进一步优化解混结果**，并将二进制变化结果与给定标签进一步比较。在反向传播过程中，TC-Module 从变化检测的角度对 UU-Module 起到时序相关性约束作用。   \\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea62def0058546739d04abb9d76ade9a~tplv-k3u1fbpfcp-zoom-1.image)  \\n\\n### 2.1 联合分离模块（United Unmixing Module，UU-Module）  \\n\\n**UU-Module旨在通过联合光谱分离从双时相高光谱图像中提取相应的丰度**。UU-Module 由两个子模块组成，其中 Scaled Spectral Attention Block (SSAB) 旨在从输入中提取空间和多尺度光谱特征，Transform into Abundance Block (TAB) 将提取的特征转换为丰度。UU-Module的设计细节如下图所示。   \\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ab9a8ab79b148c682df908a72e1ac29~tplv-k3u1fbpfcp-zoom-1.image)  \\n\\nSSAB模块由 3×3×1 的3D卷积层（3Dconv）和 3×3×3 的 3Dconv 构成，**3Dconv 能够同时提取空间和光谱特征。引入较小的光谱核尺寸来提取逐波段的光谱特征，而较大的光谱核尺寸有利于挖掘连续光谱通道的光谱特征**。此外，为了提高光谱特征提取能力，作者在3D卷积之后引入了efficient channel attention (ECA)模块，如下图所示。    \\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0eb85878742349a683eb8fa81970a254~tplv-k3u1fbpfcp-zoom-1.image)\\n\\nECA模块旨在捕获光谱图像跨通道的交互注意力并强调区分的光谱特征。随后TAB模块使用一系列的 1×1 二维卷积层 (2Dconv) 将空间和光谱特征转换为中心像素的丰度向量，输出丰度向量的长度等于多时相高光谱图像的端元数。并且在ReLU激活之后使用求和函数 $F$ 进行计算，旨在满足丰度向量求和的约束，例如给定向量 $S=\\\\left[s_{1}, s_{2}, \\\\ldots, s_{K}\\\\right]^{\\\\mathrm{T}} \\\\in \\\\mathbb{R}^{K \\\\times 1}$，$F(s_{i})$ 可以定义为：   \\n\\n$$\\nF\\\\left(s_{i}\\\\right)=\\\\frac{s_{i}}{\\\\sum_{i=1}^{K} s_{i}+\\\\varepsilon}, i=1,2, \\\\ldots, K\\n$$  \\n\\n其中 $\\\\varepsilon$ 是一个非常小的值，以避免计算混乱，随后根据输出的丰度向量根据线性混合模型来计算得到中心像素 $\\\\hat{x} \\\\in \\\\mathbb{R}^{C \\\\times 1}$ 的预测谱，$\\\\hat{x}=E\\\\cdot S_1$，其中 $E$ 为多时相端元矩阵。随后**通过最小误差高光谱新号识别方法[2]来计算两个时相的高光谱图像的所有端元的总数**，并选择余弦相似度函数（命名为 COS_SIM ）来衡量预测光谱与输入中心像素光谱之间的差异，COS_SIM 更强调两个向量之间的方向差异，**余弦相似度越接近1，说明两个向量在方向上越平行，反之亦然**，基于此设计的损失函数可以描述如下：  \\n\\n$$\\nL_{\\\\text {cos }}(x, \\\\hat{x})=1-\\\\operatorname{COS} \\\\operatorname{SIM}(x, \\\\hat{x})=1-\\\\frac{\\\\sum_{i=1}^{C} x_{i} \\\\cdot \\\\hat{x}_{i}}{\\\\sqrt{\\\\sum_{i=1}^{C} x_{i}^{2}} \\\\cdot \\\\sqrt{\\\\sum_{i=1}^{C} \\\\hat{x}_{i}^{2}}}\\n$$  \\n\\n### 2.2 时序相关模块（Temporal Correlation Module，TC-Module）   \\n\\nTC-Module 代表了一种新型的基于双时相丰度向量的二元变化分析规则。**目前大多数无监督 SU 网络都是通过最小化重建光谱和原始光谱之间的距离来训练的**。然而，当原始图像中**存在噪声或成像条件的光谱干扰时，更短的距离并不意味着更好的丰度**。此外 TC-Module 还从变化检测的角度对 UU-Module 进行了时序相关性约束。下图展示了TC-Module的构成细节。 \\n\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a0d55f75a9d646c4a886d0c932a020f5~tplv-k3u1fbpfcp-zoom-1.image)\\n\\nTC-Module 包含四个全连接层，将一对丰度向量 $S_1$ 和 $S_2$ 送入TC-Module，分别从丰度向量中提取特征，然后拼接提取跨期变化特征，最后转化为二进制变化信息。**考虑到变化和未变化样本之间的不平衡现象，作者加入了focal loss来缓解这一问题**。  \\n\\n\\n## 3.实验效果    \\n\\n本文的实验在三个数据集上进行，分别为**simulative Urban、USA和China**。下图展示了三种数据集的示例高光谱图像。其中simulative Urban数据集采集自美国，有162个光谱波段。场景中有大量的树木、草地和人工建筑。 USA 数据集具有 154 个光谱波段，土地覆盖类型包括水田、土壤、草地、河流、耕地和建筑物。China数据集含有 155 个光谱波段，有三个变化类。   \\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d720b1e2b4ff4e4e9a6beffe7a62b333~tplv-k3u1fbpfcp-zoom-1.image)  \\n\\n下表展示了本文方法与其他baseline方法在USA数据集上的定量评估结果。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b613bd03c2da4fe5a267a10e7281f3db~tplv-k3u1fbpfcp-zoom-1.image)  \\n\\n下图展示了本文方法与其他baseline方法在China数据集上的可视化对比，其中（a）为一种传统方法的二元变换检测结果，（b）为本文BCG-Net的二元检测结果。（c）为传统方法的多类检测结果，（d）为BCG-Net的多类检测结果，（e）为多类变换检测Ground-Truth。 \\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c774c9e71a741b0a575ce8e4ccfffce~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n## 4.总结    \\n\\n在本文中，作者提出了一种名为 BCG-Net 的无监督高光谱多类变化检测方法，以解决传统方法遇到的误差累积和忽略时间相关性的问题。**与之前大多数直接从光谱分离结果中获得二元和多类变化的方法不同，BCG-Net设计了一种由伪二元标签指导的新型时序相关约束**，以从变化检测的角度提升 SU 过程。此外，BCG-Net内嵌了一种基于神经网络的新规则，**以在丰度向量对与变化信息之间建立有效的关系**，从而绕过传统规则所遭受的大量误报情况。本文实验部分对三个高光谱数据集进行了广泛的定性和定量评估，证实了本文方法的有效性。    \\n\\n\\n## 参考   \\n\\n[1] S. Ashbindu, “Review Article Digital change detection techniques using remotely-sensed data,” Int. J. Remote Sens., vol. 10, no. 6, 1989.  \\n\\n[2] M. B.-D. J. and M. P. N. J., “Hyperspectral Subspace Identification,” IEEE Trans. Geosci. Remote Sens., vol. 46, no. 8, pp. 2435–2445, 2008.\\n\\n\\n\\n\\n\\n\\n\\n"
    },
    {
        "article_id": "7181761563336900669",
        "cover_image": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13dc2f403b4245e5a9be3a77302988db~tplv-k3u1fbpfcp-watermark.image?",
        "title": "2023年如何成为Web3开发者？详细聊聊Web3开发者的那些事",
        "brief": "最近和一些朋友闲聊，发现都对 Web3 很感兴趣，都想加入进来。但又找不到切入点。 这篇文章主要是和大家聊聊如何成为一名 Web3 开发者，以及 Web3 开发者的职业前景。",
        "user_name": "代码与野兽",
        "view_count": 2215,
        "collect_count": 41,
        "comment_count": 3,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/dac9f5ba3e7b6d8015a9b37536d4ef59~300x300.image",
        "category": "前端",
        "content": "# 难题\\n\\n最近和一些朋友闲聊，发现都对 Web3 很感兴趣，都想加入进来。但又找不到切入点。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4436f43014764cbb9a56421602f4d51a~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e047fcb813bd46b4b68636dae8ba6911~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n这篇文章主要是和大家聊聊如何成为一名 Web3 开发者。\\n\\n# 前景\\n\\n至于 Web3 开发者的职业前景，我就不多赘述了。可以看我之前的一些文章。\\n\\n这里可以简单看下目前 Web3 开发者的招聘市场和薪资情况。截图均来自我的朋友圈及我所接触的一些社区和平台。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/90de92640cff4ef8a6f83f51222ff0ba~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb883684a8d243739f79485dd8df4bd8~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/426139b46c2d4e2796e16c401d596485~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n可以看到，Web3 的要求并没有那么高，通常只需要 2 年以上的工作经验就可以拿到 Web2 中 5 年以上经验才拥有的待遇。\\n\\n为什么会这样？\\n\\nWeb3 目前仍然是蓝海，刚起步不久，开发者少，人才难招。\\n\\n就像 00 年前后，你即使只会用 html、css 和 js 简单画一个页面也仍然是难得的人才。\\n\\n而反观 Java、前端这些已经非常成熟的领域，人才泛滥，市场竞争激烈。你需要付出非常多的时间和精力才能在一众人群中脱颖而出。拿最成熟的 Java 招聘市场举例，这个领域有数不清的十几年架构经验的老程序员，他们具有先发优势，作为后起之秀的你很难在技术和经验上卷得过他们。\\n\\n但在如今的 Web3 开发者里面，竞争没有这么激烈。你现在加入进来，三年以后你就是大佬，五年以后你就是专家。\\n\\n# Web3 适合什么人？\\n\\n适合零基础小白，也适合具有前端、后端、数据库等经验的开发者。可以说，Web3 适合所有人。\\n\\n为什么这么说？我先分析一下 Web3 的技术架构。\\n\\n本质上 Web3 和 Web2 的架构没有太大区别，但是引入了一些概念。\\n\\n传统 Web2 架构是前端、后端、数据库。\\n\\n通常 Web3 架构是前端、后端、智能合约、区块链、去中心化存储。\\n\\nWeb2 的前端是和 API 交互，Web3 的前端不仅仅是和 API 交互，还要和 ABI 交互、和合约、区块链交互。\\n\\nWeb2 的后端是操作 DB，Web3 的前端是操作合约、区块链和去中心化存储。\\n\\nWeb2 的接口风格是 RESTFul，Web3 是 JSON-RPC。\\n\\n总而言之，Web3 不是一种新技术，而是将一堆技术进行框选，组合，形成的技术体系，在技术上，它并没有完全脱离 Web2。原来在 Web2 中的各种技术及经验，一样可以沿用到 Web3 的开发中。\\n\\n# 学习 Web3 技术有哪些难点？\\n\\n四个字：不成体系。\\n\\n说到底，Web3 毕竟是一个新事物，虽然它是建立在一堆旧事物上的。\\n\\n新事物在诞生之初都会伴随着非常多的变化。\\n\\n在这个过程中产生的一系列内容都只有很短的时效性。而且网络上的大部分内容只适合作为了解信息的一种渠道，很难成体系。\\n\\n体系是很重要的，在任何一种知识或者技术中都是非常重要的。所有高手都有自己的体系。\\n\\nWeb3 的中文资料很少，而且很多都很片面，而目前中国对待 Web3 这类技术的政策保持着冷眼旁观的态度，这导致无论是权威机构还是网络上的中文资料都很稀缺，而成体系的 Web3 资料更是少之又少。\\n\\n所以一个 Web3 成体系的学习资源对很多人是很有价值的。而我也在想办法整理一套这样的知识体系，帮助到更多需要的人。让 Web3 成为一种普惠的技术，不要再和下一个技术机遇擦肩而过。\\n\\n# 知识体系与学习路径\\n\\n目前我还在设计这套 Web3 的体系，不过在这之前我可以给大家推荐一下我目前设计的半成品。由于我设计的知识体系是对标全栈开发者，所以会涵盖 Web3 技术相关的方方面面。\\n\\n话不多说，下面是学习路径。\\n\\n## 1. 基本概念\\n\\n无论你是做前端、后端、智能合约还是全栈，都需要了解 Web3 中的基本概念。\\n\\n其中包括：Web3 原理、加密货币、区块链、钱包、交易所、区块链浏览器、智能合约、NFT、DApp、DAO、比特币底层原理及核心技术、以太坊底层原理及核心技术。\\n\\n当然不是所有内容都需要了解，有一些是根据你的具体情况选学的。\\n\\n但是有一些是你必须懂并且要操作的。\\n\\n比如如何注册一个钱包，MetaMask、rainbow、coinbase 这些主流钱包的基本使用。\\n\\n然后你要知道怎么样获取货币，交易所你要会用，区块链浏览器你要会看。\\n\\n你要懂什么是智能合约，以及智能合约基本的功能。\\n\\n## 2. 前端基础知识\\n\\n因为 DApp 也要有前端页面，所以你必须懂前端基础知识。这部分内容并不多。\\n\\n一款编辑器：VSCode。\\n\\n三门语言：HTML、CSS、JavaScript。\\n\\n一门非必选语言：TypeScript。\\n\\n## 3. 前端框架\\n\\n只学习前端基础知识确实能够开发一个 DApp 的前端，但要想 hold 住一个稍有规模的项目还是比较吃力的。这时需要学习一门框架。\\n\\n目前大多数 Web3 项目都会采用 Nextjs 框架，并使用 vercel 部署。\\n\\n而 Nextjs 框架又基于 React 库。\\n\\n所以这里你需要学习 React 和 Nextjs。\\n\\n当然你也可以学习 Angular、jQuery 这些库或者框架，但使用率没那么高，机会会少很多。\\n\\n## 4. 后端基础知识\\n\\n任何一门编程语言都可以充当 Web3 的后端，可以学习 Nodejs、Go、Java。\\n\\n这里推荐 Nodejs，因为是全栈，使用 Nodejs 的话可以前后端都只使用一门语言就可以了。\\n\\n## 5. 后端框架\\n\\nNextjs 可以写一些 API，使用 Nextjs 作为后端框架完全可以。\\n\\n当然也可以选择其他语言的框架，比如 Nodejs 的 express、koa；Java 的 Spring；Go 的 gin、Iris 等。\\n\\n## 6. 智能合约\\n\\n相对前面的内容，智能合约是一个全新的概念。\\n\\n你需要掌握 Remix 编辑器的使用，Solidity 语言的使用。还要学会一些工具，比如 Hardhat、Waffle、Ganache 和 Truffle，它们可以帮我们更好的完成智能合约编译、测试和部署工作。你还需要学习 OpenZeppelin，它是一个很棒的 Solidity 库。\\n\\n然后还需要学习各种协议标准以及它们的区别，比如 ERC20、ERC721 和 ERC1155 等。这是必不可少的基础。同时你还需要知道代理合约。\\n\\n同时你还需要了解一些 NaaS，比如 Alchemy、Infura、Tenderly 等。这些 NaaS 都提供了很多功能让你更好地完成你的 DApp 开发。\\n\\n## 7. 智能合约交互\\n\\n智能合约交互需要学习 Web3.js、Ethers.js 和 Wagmi 这三个主流的库。如果你使用 TypeScript，还需要学会使用 typechain 这个库。\\n\\nEthers.js 是我认为目前最好的智能合约交互库。\\n\\n如果你使用 nextjs 或 React 进行开发，那么 Wagmi 是更好的选择。\\n\\n## 8. 基础设施\\n\\n这部分内容比较杂，包括公链、域名系统、EVM、跨链桥、去中心化存储、IPFS、预言机等。\\n\\n但很多都是存在于概念上的，在技术上可能很少会接触到。\\n\\n但是像 IPFS 和预言机这种技术还是会用得到的。如果使用 IPFS 还要使用 Pinata 这类 Pin 服务。\\n\\n总结来说，基础设施除了一些原理性知识和概念外，主要是去中心化存储这项技术，它取代了传统数据库，用来存储体积大难以上链的数据。\\n\\n## 9. 应用生态\\n\\n这部分就是 Web3 真正发挥价值的地方了。\\n\\n你不能仅仅知道 Web3 的技术，还需要知道一些业务。\\n\\n包括了 DEX、稳定币、借贷平台、流动性质押、预测市场、NFT、DeFi、GameFi 等。\\n\\n当然作为开发者的话，这部分并非必学，以了解为主，如果你完全不了解，很难进行业务的开发。如果作为产品或者运营，就需要非常精通这些生态。\\n\\n以上就是我总结的知识体系，目前仍在不断丰富和完善中。\\n\\n我希望将我的经验分享给更多人，帮助一些人，成就一些人，改变一下这个行业，推动一下世界的进步。\\n\\n我正在参加掘金的年度人气创作者投票，如果方便希望可以帮我投票，非常感谢。\\n\\n网页和 App 都可以分别投很多票哦。\\n\\n可以点击我的头像后面的按钮进入投票，也可以点击下面的链接。你的投票对我非常重要！\\n\\n<https://rank.juejin.cn/rank/2022/writer/571401777717031?utm_campaign=annual_2022&utm_medium=self_web_share&utm_source=%E4%BB%A3%E7%A0%81%E4%B8%8E%E9%87%8E%E5%85%BD>\\n\\n我们是一群立志改变世界的人。而 Web3 是未来世界一大变数，我们想帮助更多人了解 Web3，如果你对 Web3 感兴趣，可以添加我的微信：LZQ20130415，邀你入群，一起沉淀、一起成长、一起拥抱未来。"
    },
    {
        "article_id": "7187793514766270519",
        "cover_image": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db42af1685544c0eafda7fb4c26b935b~tplv-k3u1fbpfcp-watermark.image?",
        "title": "读 2022 年 JavaScript 趋势报告",
        "brief": "2023年1月12日，《JavaScript 2022趋势调查报告》发布了。收集了 39,472 份调查报告，几乎是去年的两倍，涵盖了浏览器、开发者对 JavaScript 特性、代码库、技术、工具、",
        "user_name": "天行无忌",
        "view_count": 4162,
        "collect_count": 61,
        "comment_count": 1,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/ee5b3d33c959244bf7b70b28bb3a4d07~300x300.image",
        "category": "前端",
        "content": "2022年新冠疫情防控出现了很大的调整，见证了很多，经历了很多，也感受了很多，但这都已经过去，总结过去，展望未来！\\n\\n2023年1月12日，《[JavaScript 2022趋势调查报告](https://2022.stateofjs.com/en-US/)》发布了。收集了 **39,472** 份调查报告，几乎是去年的两倍，涵盖了浏览器、开发者对 JavaScript 特性、代码库、技术、工具、资源等的内容。下面来一起看看这份报告，并加深对 JavaScript 的认识，在新的一年里提升一个档次。\\n\\n* 《[读 2020 年 Javascript 趋势报告展望 ES2020](https://juejin.cn/post/6960494605288603656)》\\n\\n### 2022 年 JavaScript 工具\\n\\n每行从最早的可用数据年份到最新的可用数据年份。点数越高代表一项技术被更多人使用，点数越靠右代表越多人想学习；或者已经使用过并且会再次使用它。\\n\\n![2.jpeg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c21d123c5bc4a948fe02bf734772cd7~tplv-k3u1fbpfcp-watermark.image?)\\n\\n#### 前端框架 Solid\\n\\n![4.jpeg](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc02e517aad64faaa6e3015978c4c7b5~tplv-k3u1fbpfcp-watermark.image?)\\n\\n和 2021 年一样，[Solid](https://www.solidjs.com/) 仍然是最受欢迎的前端库，一个用于构建用户界面，简单高效、性能卓越的JavaScript库。以性能为主导的创新的延续。Svelte 在开发人员工效学方面采用了简单性并倾向于编译器。Solid 探索了反应性的新方法，\\n\\n#### 渲染框架 Astro\\n\\n专注于呈现和服务您的应用程序的框架。[Astro](https://github.com/withastro/astro) 取代2021年的 [SvelteKit](https://kit.svelte.dev/) ，成为最流行的框架。\\n\\n![5.jpeg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5589fb7f455e40cab58840d76da88da8~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n* [Astro](https://github.com/withastro/astro) 是一个多合一的 Web 框架，主要用于构建快速、聚焦内容为中心的系统。\\n* [SvelteKit](https://kit.svelte.dev/) 是一个官方支持的框架，围绕 Svelte 构建，为 Svelte 应用添加了一些关键功能：如路由、布局和服务器端渲染，并使前端开发变得异常简单。\\n\\n#### 测试框架 Vitest\\n\\n\\n![6.jpeg](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/491f3482f8a7478292d3c870aa8f1c0c~tplv-k3u1fbpfcp-watermark.image?)\\n\\n[Vitest](https://cn.vitest.dev/) 由 Vite 提供支持的极速单元测试框架，一个 Vite-native 单元测试框架，它很快！\\n\\n#### 移动和桌面 Tauri\\n\\n![7.jpeg](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/04fa02a614a64b0fa353dd44a58c789d~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n[Tauri](https://tauri.app/) 为多平台部署构建优化、安全且独立于前端的应用程序。在 Tauri、Ionic 和 Flutter 等多平台解决方案中看到创新，为跨平台开发提供了更多的选择。\\n\\n#### 构建工具 Vite\\n\\n![8.jpeg](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ecae49a4891443f9be3cd9288e9170ae~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n[Vite](https://cn.vitejs.dev/) 号称下一代前端开发与构建工具，是2021年新出的构建工具。而紧随其后的 [esbuild](https://esbuild.github.io/) 的趋势比较稳定。\\n\\n#### 其他库\\n\\n\\n![9.jpeg](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/55efe5a47e5d413b9e22bf5ec19ad7dc~tplv-k3u1fbpfcp-watermark.image?)\\n\\n[lodash](https://lodash.com/) 一个提供模块化、性能和附加功能的现代 JavaScript 实用程序库。\\n\\n### 2022 年 JavaScript 使用场景\\n\\n2022 年都用 JavaScript 来做什么？\\n\\n![10.jpeg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d3a2749fd2da4661a44af54ba29a2f14~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n> 前端开发、后端开发、手机应用、桌面应用、数据可视化等\\n\\n#### 应用模式\\n\\n2022 年构建的应用模式。\\n\\n![11.jpeg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/269a3a96351f42a499fd46d197ae19bb~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n单页面应用占据主要地位，这主要还是因为前端开发框架带来的结果。\\n\\n### 学习资源\\n\\n优秀的博客、播客和网站是一个好的开始，今年更进一步，真正突出 JavaScript 社区的组成人员，下面这些学习资源不容错过。\\n\\n#### 网站和杂志\\n\\n\\n![12.jpeg](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4996583608b14b1eabf00b73460295a8~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n#### 网站和课程\\n\\n\\n![13.jpeg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b71705e776064346b1274db142653642~tplv-k3u1fbpfcp-watermark.image?)\\n\\n### 总结\\n\\n从整体报告来看 JavaScript 和 TypeScript 比以往任何时候都更有活力。全球人才的分布，如尼日利亚和现在的印度，在 GitHub 上的开发人员增长最快。"
    },
    {
        "article_id": "7187211016110309431",
        "cover_image": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/01235a5cdbaa4ed0828ef7629f73f336~tplv-k3u1fbpfcp-watermark.image?",
        "title": "H5直播技术起航",
        "brief": "视频格式就是通常所说的.mp4,.flv,.ogv,.webm等。简单来说，它其实就是一个盒子，用来将实际的视频流以一定的顺序放入，确保播放的有序和完整性。",
        "user_name": "京东云开发者",
        "view_count": 5852,
        "collect_count": 8,
        "comment_count": 0,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/b9a366997037d998063135bd56302b85~300x300.image",
        "category": "开发工具",
        "content": "##### 作者：京东科技 吴磊\\n\\n# 音视频基本概念\\n\\n视频格式就是通常所说的`.mp4`,`.flv`,`.ogv`,`.webm`等。简单来说，它其实就是一个盒子，用来将实际的视频流以一定的顺序放入，确保播放的有序和完整性。\\n\\n视频压缩格式和视频格式具体的区别就是，它是将原始的视频码流变为可用的数字编码。因为，原始的视频流非常大，打个比方就是，你直接使用手机录音，你会发现你几分钟的音频会比市面上出现的 MP3 音频大小大很多，这就是压缩格式起的主要作用。\\n\\n首先，由原始数码设备提供相关的数字信号流，然后经由视频压缩算法，大幅度的减少流的大小，然后交给视频盒子，打上相应的dts，pts字段，最终生成可用的视频文件。\\n\\n> DTS（Decoding Time Stamp）：即解码时间戳，这个时间戳的意义在于告诉播放器该在什么时候解码这一帧的数据。\\n\\n> PTS（Presentation Time Stamp）：即显示时间戳，这个时间戳用来告诉播放器该在什么时候显示这一帧的数据。\\n\\n# 视频编码\\n\\n视频实际上就是一帧一帧的图片，拼接起来进行播放而已。而图片本身也可以进行相关的压缩，比如去除重复像素，合并像素块等等。不过，还有另外一种压缩方法就是，运动估计和运动补偿压缩，因为相邻图片一定会有一大块是相似的，所以，为了解决这个问题，可以在不同图片之间进行去重。\\n\\n所以，总的来说，常用的编码方式分为三种：\\n\\n-   变换编码：消除图像的帧内冗余\\n\\n<!---->\\n\\n-   运动估计和运动补偿：消除帧间冗余\\n\\n<!---->\\n\\n-   熵编码：提高压缩效率\\n\\n> 熵编码即编码过程中按熵原理不丢失任何信息的编码。信息熵为信源的平均信息量（不确定性的度量）。常见的熵编码有：香农(Shannon)编码、哈夫曼(Huffman)编码和算术编码(arithmetic coding)。\\n\\n# 直播\\n\\n现在，常用的直播协议有 RTMP，HLS，HTTP-FLV。最常用的还是 HLS 协议，因为支持度高，技术简单，但是延迟非常严重。这对一些对实时性比较高的场景，比如运动赛事直播来说非常的不友好。这里来细分的看一下每个协议。\\n\\n# 协议对比\\n\\n| 协议       | 优势          | 劣势           | 延时     |\\n| -------- | ----------- | ------------ | ------ |\\n| HLS      | 支持性广        | 延时巨高         | 10s 以上 |\\n| RTMP     | 延时性好，灵活     | 量大的话，负载较高    | 1s 以上  |\\n| HTTP-FLV | 延时性好，游戏直播常用 | 只能在手机 APP 播放 | 2s 以上  |\\n\\n# HLS\\n\\nHLS 全称是 HTTP Live Streaming。这是Apple提出的直播流协议。\\n\\nHLS 由两部分构成，一个是`.m3u8`文件，一个是`.ts`视频文件（TS 是视频文件格式的一种）。整个过程是，浏览器会首先去请求`.m3u8`的索引文件，然后解析`m3u8`，找出对应的`.ts`文件链接，并开始下载。\\n\\n\\n![1.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e4a9a645224414bab1bbe5f1d14a32f~tplv-k3u1fbpfcp-watermark.image?)\\n他的使用方式为：\\n\\n```\\n<video>  \\n    <source src=\\\"http://..../xxxx.m3u8\\\" type=\\\"application/x-mpegURL\\\" /> \\n</video>\\n```\\n\\n直接可以将`m3u8`写进`src`中，然后交由浏览器自己去解析。当然也可以采取`fetch`来手动解析并获取相关文件。HLS 详细版的内容比上面的简版多了一个`playlist`，也可以叫做`master`。在`master`中，会根据网络段实现设置好不同的 m3u8 文件，比如，3G/4G/wifi 网速等。比如，一个 master 文件中为：\\n\\n```\\n#EXTM3U\\n#EXT-X-VERSION:6\\n#EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=2855600,CODECS=\\\"avc1.4d001f,mp4a.40.2\\\",RESOLUTION=960x540\\nlive/medium.m3u8\\n#EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=5605600,CODECS=\\\"avc1.640028,mp4a.40.2\\\",RESOLUTION=1280x720\\nlive/high.m3u8\\n#EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=1755600,CODECS=\\\"avc1.42001f,mp4a.40.2\\\",RESOLUTION=640x360\\nlive/low.m3u8\\n#EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=545600,CODECS=\\\"avc1.42001e,mp4a.40.2\\\",RESOLUTION=416x234\\nlive/cellular.m3u8\\n```\\n\\n大家只要关注`BANDWIDTH`（带宽）字段，其他的看一下字段内容大致就清楚了。假如这里选择`high.m3u8`文件，那么，里面内容为：\\n\\n```\\n#EXTM3U\\n#EXT-X-VERSION:6\\n#EXT-X-TARGETDURATION:10\\n#EXT-X-MEDIA-SEQUENCE:26\\n#EXTINF:9.901,\\nhttp://media.example.com/wifi/segment26.ts\\n#EXTINF:9.901,\\nhttp://media.example.com/wifi/segment27.ts\\n#EXTINF:9.501,\\nhttp://media.example.com/wifi/segment28.ts\\n```\\n\\n注意，其中以`ts`结尾的链接就是在直播中真正需要播放的视频文件。该第二级的`m3u8`文件也可以叫做`media`文件。该文件，其实有三种类型：\\n\\n1.  live playlist: 动态列表。顾名思义，该列表是动态变化的，里面的 ts 文件会实时更新，并且过期的 ts 索引会被删除。默认，情况下都是使用动态列表。\\n\\n<!---->\\n\\n1.  event playlist: 静态列表。它和动态列表主要区别就是，原来的 ts 文件索引不会被删除，该列表是不断更新，而且文件大小会逐渐增大。它会在文件中，直接添加 #EXT-X-PLAYLIST-TYPE:EVENT 作为标识。\\n\\n<!---->\\n\\n1.  VOD playlist: 全量列表。它就是将所有的 ts 文件都列在 list 当中。如果，使用该列表，就和播放一整个视频没有啥区别了。它是使用 #EXT-X-ENDLIST 表示文件结尾。\\n\\n> <https://developer.apple.com/library/archive/referencelibrary/GettingStarted/AboutHTTPLiveStreaming/about/about.html>\\n\\n# HLS 缺陷\\n\\nHLS 缺陷就是延迟性太大了。HLS 中的延时包括：\\n\\n-   TCP 握手\\n\\n<!---->\\n\\n-   m3u8 文件下载\\n\\n<!---->\\n\\n-   m3u8 文件下所有 ts 文件下载\\n\\n这里先假设每个 ts 文件播放时长为 5s，每个 m3u8 最多可携带的 ts 文件数为 3~8。那么最大的延迟则为 40s。注意，只有当一个`m3u8`文件下所有的 ts 文件下载完后，才能开始播放。这里还不包括 TCP 握手，DNS 解析，m3u8 文件下载。所以，HLS 总的延时是非常令人绝望的。\\n\\n那解决办法有吗？ 有，很简单，要么减少每个 ts 文件播放时长，要么减少`m3u8`的中包含 ts 的数量。如果超过平衡点，那么每次请求新的 m3u8 文件时，都会加上一定的延时，所以，这里需要根据业务指定合适的策略。\\n\\n# RTMP\\n\\nRTMP 全称为：`Real-Time Messaging Protocol`。它是基于`FLV`格式进行开发的，所以，第一反应就是，又不能用了！！！\\n\\n\\n![2.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce21e1d52ce3450dad5962ae4fbd017d~tplv-k3u1fbpfcp-watermark.image?)\\n\\n是的，在现在设备中，由于 FLV 的不支持，基本上 RTMP 协议在 Web 中，根本用不到。不过，由于`MSE`（MediaSource Extensions）的出现，在 Web 上直接接入 RTMP 也不是不可能的。基本思路是根据 WebSocket 直接建立长连接进行数据的交流和监听。RTMP 协议根据不同的套层，也可以分为：\\n\\n-   纯 RTMP: 直接通过 TCP 连接，端口为 1935\\n\\n<!---->\\n\\n-   RTMPS: RTMP + TLS/SSL，用于安全性的交流。\\n\\n<!---->\\n\\n-   RTMPE: RTMP + encryption。在 RTMP 原始协议上使用，Adobe 自身的加密方法\\n\\n<!---->\\n\\n-   RTMPT: RTMP + HTTP。使用 HTTP 的方式来包裹 RTMP 流，延迟性比较大。\\n\\n<!---->\\n\\n-   RTMFP: RMPT + UDP。该协议常常用于 P2P 的场景中，针对延时有变态的要求。\\n\\nRTMP 内部是借由 TCP 长连接协议传输相关数据，所以，它的延时性非常低。并且，该协议灵活性非常好（所以，也很复杂），它可以根据 message stream ID 传输数据，也可以根据 chunk stream ID 传递数据。两者都可以起到流的划分作用。流的内容也主要分为：视频，音频，相关协议包等。\\n\\n# HTTP-FLV\\n\\n该协议和 RTMP 比起来其实差别不大，只是落地部分有些不同：\\n\\nRTMP 是直接将流的传输架在 RTMP 协议之上，而 HTTP-FLV 是在 RTMP 和客户端之间套了一层转码的过程，由于，每个 FLV 文件是通过 HTTP 的方式获取的，所以，它通过抓包得出的协议头需要使用chunked编码。\\n\\n```\\nContent-Type:video/x-flv\\nExpires:Fri, 10 Feb 2017 05:24:03 GMT\\nPragma:no-cache\\nTransfer-Encoding:chunked\\n```\\n\\n它用起来比较方便，不过后端实现的难度和直接使用 RTMP 来说还是比较大的。\\n\\n# 前端音视频流\\n\\n由于各大浏览器的对 FLV 的围追堵截，导致 FLV 在浏览器的生存状况堪忧，但是，FLV 凭借其格式简单，处理效率高的特点，使各大视频后台的开发者都舍不得弃用，如果一旦更改的话，就需要对现有视频进行转码，比如变为 MP4，这样不仅在播放，而且在流处理来说都有点重的让人无法接受。而 MSE 的出现，彻底解决了这个尴尬点，能够让前端能够自定义来实现一个 Web 播放器，确实完美。（不过，苹果觉得没这必要，所以，在 IOS 上无法实现。）\\n\\n# MSE\\n\\nMSE 全称就是`Media Source Extensions`。它是一套处理视频流技术的简称，里面包括了一系列 API：`Media Source`，`Source Buffer`等。在没有 MSE 出现之前，前端对 video 的操作，仅仅局限在对视频文件的操作，而并不能对视频流做任何相关的操作。现在 MSE 提供了一系列的接口，使开发者可以直接提供 media stream。\\n\\n来看一下 MSE 是如何完成基本流的处理的。\\n\\n```\\nvar vidElement = document.querySelector('video');\\n\\nif (window.MediaSource) {\\n  var mediaSource = new MediaSource();\\n  vidElement.src = URL.createObjectURL(mediaSource);\\n  mediaSource.addEventListener('sourceopen', sourceOpen);\\n} else {\\n  console.log(\\\"The Media Source Extensions API is not supported.\\\")\\n}\\n\\nfunction sourceOpen(e) {\\n  URL.revokeObjectURL(vidElement.src);\\n  var mime = 'video/webm; codecs=\\\"opus, vp9\\\"';\\n  var mediaSource = e.target;\\n  var sourceBuffer = mediaSource.addSourceBuffer(mime);\\n  var videoUrl = 'droid.webm';\\n  fetch(videoUrl)\\n    .then(function(response) {\\n      return response.arrayBuffer();\\n    })\\n    .then(function(arrayBuffer) {\\n      sourceBuffer.addEventListener('updateend', function(e) {\\n        if (!sourceBuffer.updating && mediaSource.readyState === 'open') {\\n          mediaSource.endOfStream();\\n        }\\n      });\\n      sourceBuffer.appendBuffer(arrayBuffer);\\n    });\\n}\\n```\\n\\n上面这个例子可以简单理解为：\\n\\n\\n![3.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f2ff6a83dff484aa6aab59ce22e4ffd~tplv-k3u1fbpfcp-watermark.image?)\\n\\n-   第一步，通过异步拉取数据。\\n\\n<!---->\\n\\n-   第二步，通过 MediaSource 处理数据。\\n\\n<!---->\\n\\n-   第三步，将数据流交给 audio/video 标签进行播放。\\n\\n而中间传递的数据都是通过`Buffer`的形式来进行传递的。\\n\\n\\n![4.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/27da5b0737284b1fb2b908be3428338d~tplv-k3u1fbpfcp-watermark.image?)\\n\\n中间有个需要注意的点，MS 的实例通过`URL.createObjectURL()`创建的 url 并不会同步连接到 video.src。换句话说，`URL.createObjectURL()`只是将底层的流（MS）和 video.src 连接中间者，一旦两者连接到一起之后，该对象就没用了。\\n\\n# MediaSource\\n\\n> MediaSource 是 Media Source Extensions API 表示媒体资源 HTMLMediaElement 对象的接口。MediaSource 对象可以附着在 HTMLMediaElement 在客户端进行播放。\\n\\nMS(MediaSource) 只是一系列视频流的管理工具，它可以将音视频流完整的暴露给 Web 开发者来进行相关的操作和处理。所以，它本身不会造成过度的复杂性。\\n\\nMS 整个只挂载了 4 个属性，3 个方法和 1 个静态测试方法。\\n\\n4 个属性：\\n\\n-   sourceBuffers: 获得当前创建出来的 SourceBuffer\\n\\n<!---->\\n\\n-   activeSourceBuffers: 获得当前正处于激活状态的 SourceBuffer\\n\\n<!---->\\n\\n-   readyState: 返回当前 MS 的状态，比如:`closed`,`open`,`ended`.\\n\\n<!---->\\n\\n-   duration: 设置当前 MS 的播放时长。\\n\\n3 个方法：\\n\\n-   addSourceBuffer(): 根据给定的 MIME 创建指定类型的 SourceBuffer\\n\\n<!---->\\n\\n-   removeSourceBuffer(): 将 MS 上指定的 SourceBuffer 移除。\\n\\n<!---->\\n\\n-   endOfStream(): 直接终止该流\\n\\n1 个静态测试方法：\\n\\n-   isTypeSupported(): 主要用来判断指定的音频的 MIME 是否支持。\\n\\n最基本的就是使用`addSourceBuffer`该方法来获得指定的 SourceBuffer。\\n\\n```\\nvar sourceBuffer = mediaSource.addSourceBuffer('video/mp4; codecs=\\\"avc1.42E01E, mp4a.40.2\\\"');\\n```\\n\\n资料：<https://developer.mozilla.org/zh-CN/docs/Web/API/MediaSource>\\n\\n# SourceBuffer\\n\\n> SourceBuffer 接口表示通过 MediaSource 对象传递到 HTMLMediaElement 并播放的媒体分块。它可以由一个或者多个媒体片段组成。\\n\\n一旦利用 MS 创建好 SourceBuffer 之后，后续的工作就是将额外获得的流放进 Buffer 里面进行播放即可。所以，SourceBuffer 提供两个最基本的操作`appendBuffer`，`remove`。之后，就可以通过`appendBuffer`直接将 ArrayBuffer 放进去即可。\\n\\n其中，SourceBuffer 还提供了一个应急的方法`abort()`如果该流发生问题的话可以直接将指定的流给废弃掉。\\n\\n音视频的 ArrayBuffer 通过 MediaSource 和 SourceBuffer 的处理直接将`<audio>`&&`<video>`接入。然后，就可以实现正常播放的效果。\\n\\n资料：<https://developer.mozilla.org/zh-CN/docs/Web/API/SourceBuffer>\\n\\n# 基于flv.js实现H5直播\\n\\n## flv.js 简介\\n\\nflv.js是来自Bilibli的开源项目。它解析FLV文件传给原生HTML5 Video标签播放音视频数据，使浏览器在不借助Flash的情况下播放FLV成为可能。\\n\\n## flv.js 优势\\n\\n-   由于浏览器对原生Video标签采用了硬件加速，性能很好，支持高清。\\n\\n<!---->\\n\\n-   同时支持录播和直播\\n\\n<!---->\\n\\n-   去掉对Flash的依赖\\n\\n## flv.js 限制\\n\\n-   FLV里所包含的视频编码必须是H.264，音频编码必须是AAC或MP3， IE11和Edge浏览器不支持MP3音频编码，所以FLV里采用的编码最好是H.264+AAC，这个让音视频服务兼容不是问题。\\n\\n<!---->\\n\\n-   对于录播，依赖 原生HTML5 Video标签 和 Media Source Extensions API\\n\\n<!---->\\n\\n-   对于直播，依赖录播所需要的播放技术，同时依赖 HTTP FLV 或者 WebSocket 中的一种协议来传输FLV。其中HTTP FLV需通过流式IO去拉取数据，支持流式IO的有fetch或者stream\\n\\n<!---->\\n\\n-   由于依赖Media Source Extensions，目前所有iOS和Android4.4.4以下里的浏览器都不支持，也就是说目前对于移动端flv.js是有局限性的。\\n\\n## flv.js 原理\\n\\nflv.js只做了一件事，在获取到FLV格式的音视频数据后通过原生的JS去解码FLV数据，再通过Media Source Extensions API 传递给原生HTML5 Video标签。(HTML5 原生仅支持播放 mp4/webm 格式，不支持 FLV)\\n\\n## vue + flv.js\\n\\n```\\n//下载flv.js包\\nnpm i flv.js -S\\n//引入flv.js包\\nimport flv from 'flv.js'\\n//HTML部分\\n<video ref=\\\"myVideo\\\" autoplay muted controls/>\\n//script部分\\n//创建一个Player实例，它接收一个MediaDataSource(必选), 一个Config(可选) flvjs.createPlayer(mediaDataSource: MediaDataSource, config?: Config)\\nexport default {\\n    data() {\\n        return {\\n            player: null,\\n        }\\n    },\\n    created() {\\n        if (flv.isSupported()) {\\n            this.player = flv.createPlayer({\\n                    type: 'flv',\\n                    isLive: true,\\n                    url: 'https://api.tjdataspace.com/flv.flv'\\n                }, {\\n                    enableWorker: true,\\n                    enableStashBuffer: false,\\n                    stashInitialSize: 128,\\n                }\\n            );\\n        }\\n    },\\n    mounted() {\\n        this.player.attachMediaElement(this.$refs.myVideo);\\n        this.player.load();\\n        this.player.play();\\n\\t\\t\\n        setInterval(() => {\\n            if (!this.player.buffered.length) {return;}\\n            let end = this.player.buffered.end(0);\\n            let diff = end - this.player.currentTime;\\n            if (diff >= 1.5) { //延时如果大于1.5秒，就让直播跳到当前时间位置播放\\n                this.player.currentTime = end - 0.5;\\n            }\\n        }, 3 * 60 * 1000);\\n    },\\n}\\n```\\n\\n> flv.js资料：<https://www.npmjs.com/package/flv.js>\\n\\n参考资料：\\n\\n<https://segmentfault.com/a/1190000008916399>\\n\\n<https://segmentfault.com/a/1190000010440054>\\n\\n<https://blog.csdn.net/An1090239782/article/details/108972491>\\n\\n<https://zhuanlan.zhihu.com/p/47773064>\\n\\n<https://juejin.cn/post/6900540290432499725>"
    },
    {
        "article_id": "7189794905219137595",
        "cover_image": "",
        "title": "chrome禁止混合内容（Mixed Content）三种解决办法",
        "brief": "chrome禁止混合内容（Mixed Content）三种解决办法。在Chrome浏览器内，https协议的网站内加载http协议的图片，会报以下错误，图片、CSS也会加载不出来。",
        "user_name": "非优秀程序员",
        "view_count": 470,
        "collect_count": 2,
        "comment_count": 0,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/c7168b49aafa388a31948dc24a3ad0eb~300x300.image",
        "category": "前端",
        "content": "## 问题描述\\n\\n在Chrome浏览器内，`https`协议的网站内加载`http`协议的图片，会报以下错误，图片也会加载不出来。\\n```\\nMixed Content: The page at 'https://beef.zz.com/front/#/biz/cultivationList/cultivationDetails/5dbf836751ba4b5d9e246ad44f013200' was loaded over HTTPS, but requested an insecure element 'http://www.aa.com/files/financialAppUpload/20201230/0403e240-95dc-4c91-a032-2262e396c411-20201230.jpg'. This request was automatically upgraded to HTTPS, For more information see https://blog.chromium.org/2019/10/no-more-mixed-messages-about-https.html \\n``` \\n\\n## 原因\\n\\nchrome阻止了混合内容，会自动将`http`升级到`https`，即使`https`下没有该资源，也不回退，可能会导致网站损坏（即加载不出来图片）。\\n\\n## 解决办法（一）\\n\\n点击地址栏小锁图标，选择网站设置\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c90c3d85411431dbfe7a112e1bba8cb~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n拉到最下边，找到不安全内容 选择允许\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0585629760df43c097f11db0d1e9041e~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n刷新页面就可以展示图片了。\\n\\n## 解决办法（二）\\n1.首先确定引入的资源可以在http和https下都能访问  \\n比如：\\n\\n[http://res.wx.qq.com/open/js/jweixin-1.6.0.js](https://links.jianshu.com/go?to=http%3A%2F%2Fres.wx.qq.com%2Fopen%2Fjs%2Fjweixin-1.6.0.js)\\n\\n[https://res.wx.qq.com/open/js/jweixin-1.6.0.js](https://links.jianshu.com/go?to=https%3A%2F%2Fres.wx.qq.com%2Fopen%2Fjs%2Fjweixin-1.6.0.js)  \\n2.在head里面写类似相对路径的形式\\n  \\n```\\n<script src=\\\"//res.wx.qq.com/open/js/jweixin-1.6.0.js\\\" type=\\\"text/javascript\\\"></script> \\n```\\n## 解决办法（三）\\n\\n1.在页面中加入（meta）头中添加upgrade-insecure-requests\\n\\n```\\n<meta http-equiv=\\\"Content-Security-Policy\\\" content=\\\"upgrade-insecure-requests\\\">\\n```\\n2.这将会把http请求转化为https请求。这样就不会再出现Mixed Content的错误了。\\n\\n\\n\\n\\n"
    },
    {
        "article_id": "7189579653144084536",
        "cover_image": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ba8413fc9284541ac2d36409bfcf2a2~tplv-k3u1fbpfcp-watermark.image?",
        "title": "vue2渲染更新原理 - diff算法",
        "brief": "vue2渲染更新原理 上一章我们介绍了vue2首次渲染的基本流程，这次主要介绍vue2更新渲染的原理。 流程 先讲更新渲染基本流程，接上一章，vue在首次渲染时，在mountCompent 创建了 渲",
        "user_name": "三飘",
        "view_count": 474,
        "collect_count": 2,
        "comment_count": 0,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/41a6fbc5ca78f4c2d85c23c4b67b3c3f~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: smartblue\\n---\\n# vue2渲染更新原理\\n\\n[上一章](https://juejin.cn/post/7189214798066745404)我们介绍了vue2首次渲染的基本流程，这次主要介绍vue2更新渲染的原理。\\n\\n## 流程\\n\\n先讲更新渲染基本流程，接上一章，vue在首次渲染时，在`mountCompent` 创建了 `渲染watcher` 。那么根据之前讲的响应式原理，`data`的响应式数据发生变动 -> 触发`渲染watcher`更新 ->调用 `updateComponent` -> 调用`_render` 生成 `VNode` -> 调用 `_update`\\n\\n```js\\n // core/instance/lifecycle.js\\n // 省略部分其他代码\\n Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) {\\n     const vm: Component = this\\n     // 缓存旧节点\\n     const prevVnode = vm._vnode\\n     vm._vnode = vnode\\n ​\\n     if (!prevVnode) {\\n         // 首次渲染\\n         vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */)\\n     } else {\\n         // 更新\\n         vm.$el = vm.__patch__(prevVnode, vnode)\\n     }\\n }\\n```\\n\\n## patch\\n\\n调用 `patch` 方法 传入新旧节点对比\\n\\n```js\\n // core/vdom/patch.js\\n // 省略部分代码 \\n function patch (oldVnode, vnode, hydrating, removeOnly) {\\n     // 只有旧节点，没有新节点，则毁旧节点\\n     if (isUndef(vnode)) {\\n       if (isDef(oldVnode)) invokeDestroyHook(oldVnode)\\n       return\\n     }\\n ​\\n     // 没有旧节点， 直接渲染新节点\\n     if (isUndef(oldVnode)) {\\n       createElm(vnode)\\n     } else {\\n       // oldVnode是否是真实节点，存在即上面首次渲染时直接传$el的情况\\n       const isRealElement = isDef(oldVnode.nodeType)\\n       \\n       // oldVnode是虚拟节点，且和新建节点是同一节点\\n       if (!isRealElement && sameVnode(oldVnode, vnode)) {\\n         // 对比新旧节点\\n         patchVnode(oldVnode, vnode)\\n       } else {\\n         \\n         // oldVnode是真实节点，即根节点首次渲染\\n         if (isRealElement) {\\n           // 根据oldVnode的真实dom,生成一个无子节点的空节点赋给oldVnode\\n           oldVnode = emptyNodeAt(oldVnode)\\n         }\\n ​\\n         // 获取旧真实dom,和其父dom\\n         const oldElm = oldVnode.elm\\n         const parentElm = nodeOps.parentNode(oldElm)\\n ​\\n         // 无论是首次渲染还是，新旧节点不一致的情况，都会根据新vnode创建新的dom\\n         createElm(\\n           vnode,\\n           parentElm,\\n           nodeOps.nextSibling(oldElm)\\n         )\\n ​\\n         // 最后销毁旧节点\\n         if (isDef(parentElm)) {\\n           removeVnodes([oldVnode], 0, 0)\\n         } else if (isDef(oldVnode.tag)) {\\n           invokeDestroyHook(oldVnode)\\n         }\\n       }\\n     }\\n     // 返回生成好的新真实dom\\n     return vnode.elm\\n   }\\n```\\n\\n更新渲染时，分两种情况，\\n\\n第一种是新旧节点不一致了，那么就直接根据新的`VNode`生成真实dom，然后销毁旧节点。\\n\\n第二种是新旧节点是同一类型的，那么就不销毁旧节点，而是调`patchVnode`做进一步对比。\\n\\n## sameVnode\\n\\n先看 `sameVnode` 怎么判断节点是否是一致的：\\n\\n```js\\n // core/vdom/patch.js\\n function sameVnode (a, b) {\\n   return (\\n     a.key === b.key && // key相同， 未设置就都是 undefined\\n     a.asyncFactory === b.asyncFactory && (  // 是否都是异步组件或都不是\\n       (\\n         a.tag === b.tag && // tag相同\\n         a.isComment === b.isComment && // 是否都是注释节点或都不是\\n         isDef(a.data) === isDef(b.data) && // 是否都定义了data\\n         sameInputType(a, b) // 如果都是input标签，则input的type也要相同，这是个特殊处理\\n       ) || (\\n         isTrue(a.isAsyncPlaceholder) && \\n         isUndef(b.asyncFactory.error) // 也是异步组件相关的，代表 旧节点是异步组件的占位节点， 新节点是异步组件加载完成且未出错的情况\\n       )\\n     )\\n   )\\n }\\n```\\n\\n其实简单点就是 新旧节点 key和tag要相同，就判定为 是同一类型的节点，旧节点不用销毁，其他的就是各种特殊情况处理。**这里就是要求我们节点要写key的原因了**\\n\\n上面说的第一种情况就是创建新节点，那就和首次渲染没区别了，这里就不在讲了，\\n\\n看第二种情况，新旧节点类型一致，调用 `patchVnode` 更仔细的处理\\n\\n## patchVnode\\n\\n```js\\n // core/vdom/patch.js\\n // 省略部分其他逻辑代码\\n ​\\n function patchVnode (oldVnode,vnode) {\\n     if (oldVnode === vnode) {\\n         return\\n     }\\n     // 新节点复用旧节点的dom, 就是说sameVnode一致后，当前dom节点就会复用，然后只会去更新\\n     const elm = vnode.elm = oldVnode.elm\\n      \\n     let i\\n     const data = vnode.data\\n     \\n     // 组件类型节点对比前的操作，主要逻辑是复用旧组件的实例，同时更新 props,attrs,listeners,slot等相关属性\\n     if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {\\n         i(oldVnode, vnode)\\n     }\\n ​\\n     // 获取新旧节点的子项\\n     const oldCh = oldVnode.children\\n     const ch = vnode.children\\n     \\n     if (isDef(data) && isPatchable(vnode)) {\\n         // 更新dom节点的各种属性\\n         for (i = 0; i < cbs.update.length; ++i) cbs.update[i](oldVnode, vnode)\\n         // 调组件更新钩子 \\n         if (isDef(i = data.hook) && isDef(i = i.update)) i(oldVnode, vnode)\\n     }\\n     // 新节点是非文本节点\\n     if (isUndef(vnode.text)) {\\n         // 新旧节点均存在子节点时\\n         if (isDef(oldCh) && isDef(ch)) {\\n             // 对比新旧节点的子节点， 大名鼎鼎的diff算法就在这里，就是新旧节点的子节点处理\\n             if (oldCh !== ch) updateChildren(elm, oldCh, ch)\\n         // 只有新节点存在子节点时\\n         } else if (isDef(ch)) {\\n             // 旧节点没有子节点，但它可能是文本节点，所以这里要删除文本\\n             if (isDef(oldVnode.text)) nodeOps.setTextContent(elm, '')\\n             // 旧节点没有子节点，新节点有，就直接新建子节点dom并插入到当前dom下\\n             addVnodes(elm, null, ch, 0, ch.length - 1)\\n         // 只有旧节点存在子节点时\\n         } else if (isDef(oldCh)) {\\n             // 删除所以子节点\\n             removeVnodes(oldCh, 0, oldCh.length - 1)\\n         // 都没有子节点且旧节点是文本节点\\n         } else if (isDef(oldVnode.text)) {\\n             // 删除旧节点的文本，即清空旧节点\\n             nodeOps.setTextContent(elm, '')\\n         }\\n     // 新节点是文本节点，则直接给dom设置文本内容\\n     } else if (oldVnode.text !== vnode.text) {\\n         nodeOps.setTextContent(elm, vnode.text)\\n     }\\n     // 组件节点，调用更新完成后的钩子\\n     if (isDef(data)) {\\n         if (isDef(i = data.hook) && isDef(i = i.postpatch)) i(oldVnode, vnode)\\n     }\\n }\\n```\\n\\n可以看到调`patchVnode` 精细对比两节点时，会直接复用旧节点的dom，然后分各种情况对比操作dom更新，如果是组件节点，还会复用组件实例，调用对应的钩子。然后就是处理子节点的更新。只有在都存在子节点则会调用`updateChildren` 对比子节点，否则就根据情况直接删除旧节点的子节点或者新建新节点的子节点。\\n\\n## updateChildren\\n\\n`updateChildren` 就是diff算法所在的地方了\\n\\n> 为啥需要diff算法？\\n>\\n> 因为直接操作dom是一件很费性能的事，而虚拟dom(VNode)就是个简单的js对象，直接操作js对象运算一件很轻松的事，所以尽可能的减少dom操作就能有效的提升性能，所以diff算法主要就是为了用更少的dom操作去完成子节点的复用以及删除或新建，以节约性能。\\n\\nvue2采用的**双端对比**的算法来实现子节点diff\\n\\n```js\\n // core/vdom/patch.js\\n // 省略部分其他逻辑代码\\n ​\\n function updateChildren (parentElm, oldCh, newCh ) {\\n     let oldStartIdx = 0 // 旧子节点起始下标\\n     let newStartIdx = 0 // 新子节点起始小白\\n     let oldEndIdx = oldCh.length - 1 // 旧子节点结尾下标\\n     let newEndIdx = newCh.length - 1 // 新子节点结尾下标\\n     let oldStartVnode = oldCh[0] // 第一个旧子节点\\n     let oldEndVnode = oldCh[oldEndIdx] // 最后一个旧子节点\\n     let newStartVnode = newCh[0] // 第一个新子节点\\n     let newEndVnode = newCh[newEndIdx] // 最后一个新子节点\\n     \\n     let oldKeyToIdx, idxInOld // 下面会讲\\n ​\\n     // 只有当新旧子节点的指标的起始位置都不大于其结束位置的时候，才能循环；\\n     // 一方的开始位置大于结束位置，说明该方循环完毕，需要结束循环\\n     while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\\n         // 如果旧子节点被置空了，dom被移走了，直接跳过\\n         if (isUndef(oldStartVnode)) {\\n             oldStartVnode = oldCh[++oldStartIdx] // Vnode has been moved left\\n         } else if (isUndef(oldEndVnode)) {\\n             oldEndVnode = oldCh[--oldEndIdx]\\n         // 新旧子节点首首对比，相同则新旧子节点首部指针向右进一，接着对比\\n         } else if (sameVnode(oldStartVnode, newStartVnode)) {\\n             patchVnode(oldStartVnode, newStartVnode) // 复用子节点并递归对比子节的节点\\n             oldStartVnode = oldCh[++oldStartIdx]\\n             newStartVnode = newCh[++newStartIdx]\\n         //首首对比完成后，开始新旧子节点尾尾对比，相同则新旧子节点尾部指针向左进一，接着对比\\n         } else if (sameVnode(oldEndVnode, newEndVnode)) {\\n             patchVnode(oldEndVnode, newEndVnode) // 复用子节点并递归对比子节的节点\\n             oldEndVnode = oldCh[--oldEndIdx]\\n             newEndVnode = newCh[--newEndIdx]\\n         // 首首尾尾对比完成后，\\n         // 再开始首尾对比，\\n         // 相同则新子节点复用旧子节点并更新好属性，递归完孙节点后\\n         // 将复用后的真实dom,移动到dom节点的对尾，也不是真实的队尾就是去除调前面首首尾尾对比后剩下节点的队尾， 细品\\n         // 旧子节点向右进一， 新子节点向左进一\\n         } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\\n             patchVnode(oldStartVnode, newEndVnode) // 复用子节点并递归对比子节的节点\\n             parentElm.insertBefore(oldStartVnode.elm, oldEndVnode.elm.nextSibling); \\n             oldStartVnode = oldCh[++oldStartIdx]\\n             newEndVnode = newCh[--newEndIdx]\\n         // 对比完首尾后再进行尾首对比\\n         // 相同则新子节点复用旧子节点并更新好属性，递归完孙节点后\\n         // 将复用后的真实dom,移动到dom节点的对首，同样不是真实的队首就是去除调前面对比后剩下节点的队首\\n         // 旧子节点向左进一， 新子节点向右进一\\n         } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\\n             patchVnode(oldEndVnode, newStartVnode)\\n             parentElm.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)\\n             oldEndVnode = oldCh[--oldEndIdx]\\n             newStartVnode = newCh[++newStartIdx]\\n         // 最后都没对比上，就手动根据key找节点复用\\n         } else {\\n             // 创建一个剩余旧子节点的，key 和 index 的 映射, 方便新子节点直接根据key找到其在旧子节点中的位置\\n             if (isUndef(oldKeyToIdx)) {\\n                 oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)\\n             }\\n             \\n             // 新子节点在旧子节点中的位置\\n             idxInOld = isDef(newStartVnode.key)\\n                 // 新子节点有key,则直接到刚刚建的key到index的映射中拿\\n                 ? oldKeyToIdx[newStartVnode.key] \\n             // 新子节点要是没有key, 则拿新子节点到剩余的旧子节点中去循环调sameVnode对比找\\n             : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)\\n             \\n             // 新子节点在旧子节点中找不到,则直接新建新子节点的dom并插入剩下节点的队首\\n             if (isUndef(idxInOld)) { \\n                 parent.insertBefore(createElm(newStartVnode), oldStartVnode.elm);\\n             } else {\\n                 vnodeToMove = oldCh[idxInOld]\\n                 // 对于刚刚找到的新旧子节点，之前只是用key去找的，sameVnode判定里还有tag之类的条件\\n                 // 如果相同，则复用旧子节点\\n                 // 将旧子节点dom移动到剩余节点对首\\n                 if (sameVnode(vnodeToMove, newStartVnode)) {\\n                     patchVnode(vnodeToMove, newStartVnode)\\n                     oldCh[idxInOld] = undefined // 老节点对应位置置空\\n                     parentElm.insertBefore(vnodeToMove.elm, oldStartVnode.elm)\\n                 } else {\\n                     // 相同 key 但是 tag 之类不同的话也不能复用\\n                     parent.insertBefore(createElm(newStartVnode), oldStartVnode.elm);\\n                 }\\n             }\\n             // 将新子节点像右移一步， 再回去 首首、尾尾。。。。循环的对比\\n             newStartVnode = newCh[++newStartIdx]\\n         }\\n     }\\n     // 如果旧子节点循环完毕了，但是新子节点还有\\n     if (newStartIdx <= newEndIdx) {\\n         // 此时newStartIdx并非为0，而是等于oldCh比对完时，newCh所处的位置\\n         // 遍历newCh剩余的节点，生成真实dom，插入到parent中\\n         for (let i = newStartIdx; i <= newEndIdx; i++) {\\n             // 这是一个优化写法 insertBefore的第二个参数是null等同于appendChild作用\\n             const anchor =\\n                   !!newCh[newEndIdx + 1] ? null : newCh[newEndIdx + 1].el;\\n             parent.insertBefore(createElm(newCh[i]), anchor);\\n         }\\n     }\\n ​\\n     // 如果新子节点循环完毕，旧子节点还有\\n     if (oldStartIndex <= oldEndIndex) {\\n         // 遍历oldCh剩余的节点，将他们从parent中删除\\n         for (let i = oldStartIndex; i <= oldEndIndex; i++) {\\n             let child = oldCh[i];\\n             // 老节点的dom可能被移走，自身被置空了,所以要判断下\\n             if (child) { \\n               parent.removeChild(child.el);   \\n             }\\n         }\\n     }\\n }\\n ​\\n // 创建key到index的映射\\n function createKeyToOldIdx (children, beginIdx, endIdx) {\\n   let i, key\\n   const map = {}\\n   for (i = beginIdx; i <= endIdx; ++i) {\\n     key = children[i].key\\n     if (isDef(key)) map[key] = i\\n   }\\n   return map\\n }\\n ​\\n // 去剩余的老子节点里，循环查找 sameVnode 一致的节点\\n function findIdxInOld (node, oldCh, start, end) {\\n     for (let i = start; i < end; i++) {\\n         const c = oldCh[i]\\n         if (isDef(c) && sameVnode(node, c)) return i\\n     }\\n }\\n```\\n\\n## diff算法流程分析\\n\\n1.  采用了四个指针，进行向中间逼近对比\\n\\n    ![双指针](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/465180272cdd42fdb9d62c4c922ea88b~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n1.  首首对比成功则，复用节点且节点的dom不用移动，首部新旧指针均向右移一位，继续直到首首不一致\\n\\n1.  然后开始尾尾对比，尾尾对比成功则，复用节点且节点的dom不用移动，尾部新旧指针均向左移一位，继续直到尾尾也不一致\\n\\n1.  然后开始旧首新尾对比，对比成功则，复用节点但节点的dom要移动到剩余节点的对尾，然后首部旧指针右移一位，尾部新指针左移一位，此旧节点的首部变了新节点的尾部变了但首部没变，就又可以来一波首首、尾尾的对比了。\\n\\n1.  继续以上3种都没对比上，则开始旧尾新首对比，对比成功则，复用节点但节点的dom需移动到剩余节点的对首，然后尾部旧指针左移一位，首部新指针右移一位，同样首部节点变化了，就又可以来一波首首、尾尾的对比了。\\n\\n1.  上面比对全部没对比上，那么就用剩下的新首节点去剩下的旧节点中找sameVnode一致的节点，找到则，复用节点且将节点dom移动到剩余节点对首，并置空节点，找不到则直接拿新首节点去创建一个dom插入到剩余节点对首。最后首部新指针想右移一位，同样首部节点变化了，就又可以来一波首首、尾尾的对比了，直至一方循环完毕\\n\\n1.  如果旧节点循环完毕，新节点还有则剩余新节点创建dom并插入到之前剩余的队尾\\n\\n1.  如果新节点循环完毕，旧节点还有则移除剩余的旧节点\\n\\n至此vue2的渲染流程完毕；\\n\\n总结下就是：\\n\\n**响应式数据变动 -> `渲染wather` 触发更新 -> `patch` 组件根节点 -> 不同直接销毁重建 -> 相同则 调用 `patchVnode`复用节点并更新属性 -> 如果都有子节点则调用 `updateChildern` 使用双端对比算法确定子节点的复用情况**\\n"
    },
    {
        "article_id": "7189536752062136357",
        "cover_image": "",
        "title": "解决用ESLint检查TypeScript编写的Vue单文件组件的代码时出现的性能差、速度慢的问题",
        "brief": "当我们用ESLint检查TypeScript编写的Vue单文件组件的代码时，有时会出现性能很差，速度很慢的问题，而我找到了解决方案",
        "user_name": "础砜",
        "view_count": 462,
        "collect_count": 1,
        "comment_count": 1,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/1531177f5538f0118eafbf9918d298d4~300x300.image",
        "category": "前端",
        "content": "---\\nhighlight: atom-one-dark\\n---\\n# 问题描述\\n当我们在使用TypeScript编写的Vue单文件组件时，如果用ESLint进行代码检查，有时会出现性能很差，速度很慢的问题，在同一个项目里，`.ts`文件的ESLint自动修复可以瞬间完成，而Vue单文件组件光检查就要花费几秒时间甚至很久，好在我找到了原因和解决方案：\\n\\n具体原因可以查看Github上的相关讨论：[vue-eslint-parser and typescript-eslint problems · Issue #104 · vuejs/vue-eslint-parser (github.com)](https://github.com/vuejs/vue-eslint-parser/issues/104)\\n\\n以上的Github页面中的内容比较多，如果你只想快速解决问题，那你就直接先往下看：\\n\\n# 解决方案\\n\\n我总结了如下两个解决方案，都是亲测有效的：\\n\\n## 方案一：删除`eslintrc`文件里的`project`字段\\n\\n就像这样：\\n\\n```json\\n{\\n    \\\"parser\\\": \\\"vue-eslint-parser\\\",\\n    \\\"parserOptions\\\": {\\n        \\\"project\\\": [\\\"./tsconfig.json\\\"] // 删除这行\\n    }\\n}\\n```\\n\\n在`typescript-eslint`插件的[官网介绍](https://typescript-eslint.io/linting/typed-linting)中，他会建议你使用`\\\"project\\\": [\\\"./tsconfig.json\\\"]`。\\n\\n但是经过我的测试，似乎至少有三种可以被解析器接受的写法：\\n1. `\\\"project\\\": [\\\"./tsconfig.json\\\"]`。这是官网中介绍的写法，性能最差，Vue单文件组件检查需要大约8秒；\\n2. `\\\"project\\\": \\\"./tsconfig.json\\\"`。这是我以前的配置文件里的写法，性能也很差，但是比第一种强一点，Vue单文件组件检查需要大约5秒。我以前之所以这么写，可能是旧版官网推荐的写法；\\n3. 不写这一项。当我删除这一项后，我本以为会报错，然而并没有，重启编辑器也没有任何报错，同时Vue单文件组件的检查时间也从5秒降到了瞬间完成，非常神奇。\\n\\n如果你必须要用到它，或者你删除后出错了，那么就使用方案二：\\n\\n## 方案二：自定义解析器\\n\\n就像这样：\\n\\n```json\\n{\\n    \\\"parser\\\": \\\"vue-eslint-parser\\\",\\n    \\\"parserOptions\\\": {\\n        \\\"project\\\": [\\\"./tsconfig.json\\\"],\\n        \\\"parser\\\": {\\n            \\\"ts\\\": \\\"@typescript-eslint/parser\\\",\\n            \\\"<template>\\\": \\\"espree\\\"\\n        }\\n    }\\n}\\n```\\n\\n经过我的测试，修改之后Vue单文件组件的检查时间从5秒降到了瞬间完成。更复杂的测试结果参考文章开头的Github链接。\\n\\n这个方法是我从文章开头的Github链接学到的，新增这段代码的意思是：如果是`.ts`文件和Vue单文件组件的`<script lang=\\\"ts\\\">`部分，就用`@typescript-eslint/parser`解析；如果是Vue单文件组件的`<template>`部分，就用ESLint原版的`espree`解析。\\n\\n需要注意的是`\\\"<template>\\\": \\\"espree\\\"`这个字段它就是这么写的，无需任何改动，别想多了，`<>`不是让你往里填空的。\\n\\n这么改当然也是有缺点的，而且其实一眼就能看到缺点：Vue单文件组件的`<template>`使用`espree`解析，而`espree`只支持JavaScript，这就意味着你不能在`<template>`中使用TypeScript语法的表达式，用了就会报错，只能用JavaScript表达式，而且失去了一部分类型检查，这种情况下我们只能尽量将脚本写在`<script lang=\\\"ts\\\">`部分。\\n\\n但是这只会影响到编辑器的开发环境，运行时`<template>`还是支持TypeScript的。\\n\\n# 总结\\n\\n如果你的项目中只有一个`tsconfig.json`，那么我觉得只要不报错，用方案一最方便，而且不会失去在`<template>`中写TypeScript表达式的编辑器支持。\\n\\n如果你必须使用`project`字段，那么就使用方案二，只是会失去在`<template>`中写TypeScript表达式的编辑器支持。"
    },
    {
        "article_id": "7184986079437520933",
        "cover_image": "",
        "title": "有意思，小程序还可以一键生成App！",
        "brief": "小程序≠微信小程序 说到小程序，大部分同学的第一反应，可能是微信小程序、支付宝小程序，确实，小程序的概念深入人心，并且已经被约定俗成的绑定到某些互联网公司的 APP 上。 但是，“小程序”并不是一个注",
        "user_name": "chokcoco",
        "view_count": 6579,
        "collect_count": 16,
        "comment_count": 7,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/d5909b97177d58b77d02a83a620abd18~300x300.image",
        "category": "前端",
        "content": "## 小程序≠微信小程序\\n\\n说到小程序，大部分同学的第一反应，可能是微信小程序、支付宝小程序，确实，小程序的概念深入人心，并且已经被约定俗成的绑定到某些互联网公司的 APP 上。\\n\\n**但是，“小程序”并不是一个注册商标，也不是哪一家的专利。**\\n\\n小程序作为一种人机交互的软件载体、一种数字内容格式、一种代码分发传播机制，也到了被商业机构“借鉴”采用的时刻。\\n\\n企业们不是已经一直在用小程序吗？不算。因为他们不过是作为某个互联网大平台的内容贡献者、参与者，“免费”向互联网平台提供了自己的内容与服务，成为了别人的“生态一员”，换取流量的转化，以触达更多的互联网消费者。\\n\\n小程序类技术的企业商用，**意味着：企业拥有了和互联网平台们类似的技术，能够以小程序这种技术载体、内容格式来开发自己的商业软件，从而享受这种技术带来的敏捷、轻量、极度松散耦合的好处。**\\n\\n进一步，企业还能自主运营自己的平台，对其中小程序内容的上下架、审核发布完全掌握，让自己的业务功能灵活发表和投放；更进一步的，一些企业还可以开放自己的这种平台能力，让合作伙伴的小程序内容上架到平台上，以更好的服务自己的存量客户，建立行业数字生态，极大程度提升自己的数字化连接能力。\\n\\n## 以小程序为载体的企业轻应用方案\\n\\n虽然互联网大厂并未将这部分小程序运行能力技术开放出来，但是我们也不必望而生羡，市面上早就推出了类似的技术能力，我们一般称之为**小程序容器技术**。\\n\\n今天要给大家分享的也正是目前在 GitHub 很热门的前端容器技术 ——  [FinClip](https://github.com/finogeeks) 。\\n\\n一句话介绍 FinClip ：可以让小程序脱离微信环境最快运行在自有APP中\\n\\n只需简单集成  FinClip SDK  , 即可在 iPhone、Android、Windows、Linux、macOS、统信等平台下的应用中运行你的小程序。\\n\\n未来小程序战火还要烧其他终端设备之上，这意味着，移动端、PC 端、车载设备、智能电视、智能手表、智能家居都能运行小程序了。\\n\\n此外 FinClip 支持小程序小游戏，，用户可以在集成了 FinClip SDK 的 App 内对小游戏**点开即玩，用完即走**。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/604a0bfc1f8543ada268418911bf3216~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n而且 `FinClip SDK` 极其轻量，应用在集成后安装包的体积仅仅增大了不到 3MB。\\n\\n我们率先来看看 FinClip 小程序 SDK 是如何工作的\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/23194ec5e94140acbb7acc7c459ec872~tplv-k3u1fbpfcp-zoom-1.image)\\n\\nFinClip 小程序 SDK 提供了一套可运行小程序业务代码的**安全沙箱与宿主环境**：\\n\\n+ **安全沙箱**负责保护小程序中的业务应用，在安全可信的环境中传输数据，避免第三方的干扰与窃听；\\n\\n+ **宿主环境**负责执行小程序 JS 业务逻辑代码，并使用 WebView 渲染展示小程序页面。\\n\\n其次，FinClip 则主要由 3 个模块构成  \\n\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5cebd85ba16c4833968f849ff2546562~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n1. **云侧**代表 FinClip 小程序管理后台，可管理小程序的开发、上架等全生命周期进行；\\n\\n2. **端侧**代表FinClip 小程序 SDK，代表集成了 FinClip 小程序 SDK 的移动 App 或各类智能设备，用于向其提供能够运行小程序的能力；\\n\\n3. **开发者工具**则主要用于编写，调试，上传，预览小程序代码。\\n\\n此外，下面这个功能特性需要重点强调一下， `FinClip` 支持微信小程序语法 WXML，也就是说微信小程序代码可以直接在 FinClip 复用，无需再二次开发，体验与微信端保持一致。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/29527200d2714f6880e4be7f2aebaabb~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n`FinClip` 还自研了一个 小程序 IDE 开发工具，界面与微信小程序的开发工具类似，自带调试和真机预览，简单易上手。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97282ae2dfd74a63b1a8182f9847fe99~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n你可以在这个 `FinClip IDE` 里面，对现有项目进行二次开发，扩展功能和接口。\\n\\n同时，它还支持 小程序一键转换成 App，可以将已有小程序代码导出为 IOS 与 Android 中可用的工程文件,并上架至各应用市场 。由于导出的工程文件自动集成了  FinClip  SDK ，所以直接拥有小程序的运行能力，后续可在这个 APP 上继续上架更多小程序，自建自己的小程序生态。\\n\\n![Image](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eee09debf73f469eb37a8379dc28b943~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n并且 FIDE 中还包含各类扩展插件和接口（支付、人脸识别、音视频、OCR 等），开发者可自主勾选所需的支持插件，从而增强所生成 App 原生能力。\\n\\n最后简单总结一下 `FinClip` 可以帮助企业/开发者实现什么：\\n\\n+ **促进连接**：只要把FinClip SDK嵌入到自己的App中，马上获得小程序运行能力。小程序已经在互联网上被充分证明是一个非常有效的促进连接的技术形态。\\n\\n+ **动态更新**：借助 FinClip 将应用中业务功能均以小程序形式替代，功能模块互相解耦，实现模块化开发，极大的提升开发效率，降低开发成本。\\n\\n+ **多端支持**：同一个业务场景，小程序化之后，可以展现在手机端、也可以运行在PC端、更可以出现在智能电视和车载大屏上，多端同步、转发分享、一致体验，甚至可以无缝对接至互联网公共平台，代码只写一次，多处运行。\\n\\n+ **生态共建**：让开发者、企业拥有自己的小程序应用商店，在这里可以实现与合作伙伴的资源整合 - 例如让合作伙伴把数字服务以小程序方式上架、投放到自己的App中。\\n\\n## 总结一下\\n\\n`FinClip` 的技术方案，目的就是要让任何行业的任何企业，均可以拥有自主打造小程序生态、发布管理小程序内容、在自己的各终端App中运行小程序的能力。\\n\\n那 `FinClip` 是不是可以免费使用？是的，目前 FinClip SaaS 版开箱即用，欢迎各位开发者体验反馈。\\n\\n可以猛戳这里：[Link - FinClip](https://www.finclip.com/)\\n\\n好了，本文到此结束，希望本文对你有所帮助 :)\\n\\n如果还有什么疑问或者建议，可以多多交流文笔有限，文中若有不正之处，万望告知。"
    },
    {
        "article_id": "7189818971443429433",
        "cover_image": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8001b3992744d1bbb511676ef949211~tplv-k3u1fbpfcp-watermark.image?",
        "title": "iOS schem 和 Universal Link 在调试时的踩坑记录",
        "brief": "简介 scheme和Universal Link是在iOS中两种可以在网页中点击回跳到自己预定的APP的两种方式。至于这两种方式需要怎么配置，这里就不做详细的介绍了。网上的文章一搜一大堆。今天主要是说",
        "user_name": "馋嘴的张先生",
        "view_count": 885,
        "collect_count": 1,
        "comment_count": 0,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/bf0f3243561603039c016a8ec7c66def~300x300.image",
        "category": "iOS",
        "content": "# 简介\\n![截屏2023-01-18 10.16.53.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/62dddab4203547868b41e8946c0b66a0~tplv-k3u1fbpfcp-watermark.image?)\\nscheme和Universal Link是在iOS中两种可以在网页中点击回跳到自己预定的APP的两种方式。至于这两种方式需要怎么配置，这里就不做详细的介绍了。网上的文章一搜一大堆。今天主要是说一下这次的配置过程中遇到的问题。  \\n# AppDelegate和SceneDelegate  \\nSceneDelegate是在iOS13的时候新增的，之前做老项目的迭代更新的时候很少接触这个文件。这回就简单的和它交流一下。  \\n对于这次的交流结论是：当AppDelegate和SceneDelegate两个文件共存的时候，我们不仅仅要关注AppDelegate中的回调函数，还要关注SceneDelegate代理的回调函数，因为在不同的iOS系统下走的文件回调是不一样的。在iOS13之前通通走AppDelegate，iOS13之后就会走SceneDelegate。\\n\\n# 问题：在iOS13以上冷启动的时候不会走代理函数！\\n上面已经说过在iOS13之前通通走AppDelegate，iOS13之后就会走SceneDelegate。  \\n##### 如果你用了Scheme方式：\\n###### iOS13之前会走这个代理函数\\n```objc\\n- (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary<UIApplicationOpenURLOptionsKey,id> *)options{\\n\\n}\\n```  \\n我们只需要在里面多自己相应的逻辑处理就可以了，并且不用关注是冷启动还是APP已经在后台挂起。都能在这里获取到你想要的参数。\\n###### iOS13之后会走\\n```objc\\n- (void)scene:(UIScene *)scene openURLContexts:(NSSet<UIOpenURLContext *> *)URLContexts{\\n    UIOpenURLContext *urlContext = URLContexts.anyObject\\n}\\n```\\n这时就会出现问题了，这个函数只有在APP在后台挂起的时候才会走。如果是冷启动的时候，压根不会走这个函数，从而导致我们拿不到那个想要跳转的链接地址。\\n##### 如果你用了Universal Link方式：\\n###### iOS13之前会走这个代理函数\\n```objc\\n- (BOOL)application:(UIApplication *)application continueUserActivity:(NSUserActivity *)userActivity restorationHandler:(void(^)(NSArray<id<UIUserActivityRestoring>> * __nullable restorableObjects))restorationHandler{\\n}\\n```\\n我们只需要在里面多自己相应的逻辑处理就可以了，并且不用关注是冷启动还是APP已经在后台挂起。都能在这里获取到你想要的参数。\\n###### iOS13之后会走\\n```objc\\n- (void)scene:(UIScene *)scene continueUserActivity:(NSUserActivity *)userActivity{\\n}\\n```\\n这时就会出现问题了，这个函数只有在APP在后台挂起的时候才会走。如果是冷启动的时候，压根不会走这个函数，从而导致我们拿不到那个想要跳转的链接地址。  \\n\\n# 总结\\n在你使用SceneDelegate的时候不管你是scheme还是Universal Link 都会在冷启动的时候不走代理函数。解决办法有两种：  \\n1.你可以不用SceneDelegate这个文件。这样就可以避免问题的出现。毕竟现在的APP好像并没有强制开发者只用SceneDelegate；  \\n2.在无数次的测试的时候我们会发现在APP冷启动的时候都会走SceneDelegate的\\n```objc\\n- (void)scene:(UIScene *)scene willConnectToSession:(UISceneSession *)session options:(UISceneConnectionOptions *)connectionOptions\\n```\\n我们可以对这个函数做做文章。\\n在`connectionOptions`中有两个属性，一个是`URLContexts`另一个是`userActivities`，你再看看对应在SceneDelegate的函数都有对应的形参，所以我们可以在冷启动的时候获取一下相应的参数然后从而达到获取链接参数的目的；\\n```objc\\nscheme：\\nUIOpenURLContext *urlContext = connectionOptions.URLContexts.anyObject;\\nUniversal Link：\\nNSUserActivity *userActivity =connectionOptions.userActivities.anyObject;\\n```"
    },
    {
        "article_id": "7189891425520549925",
        "cover_image": "",
        "title": "别忘记我：通过局部-全局内容建模进行文本擦除方法",
        "brief": "本文简要介绍了发表于ECCV 2022的论文“Don’t Forget Me: Accurate Background Recovery for Text Removal via Modeling",
        "user_name": "合合技术团队",
        "view_count": 529,
        "collect_count": 1,
        "comment_count": 0,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/f16cd67b5a69dcba15ff6f6b4512a7ac~300x300.image",
        "category": "人工智能",
        "content": "![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/efcc5bc81cd44c58b67799e3b37e6966~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n本文简要介绍了发表于ECCV 2022的论文“Don’t Forget Me: Accurate Background Recovery for Text Removal via Modeling Local-Global Context”的相关工作。该论文针对文本擦除中存在的复杂背景修复的问题，提出了CTRNet，它利用局部和全局的语义建模提升模型的背景还原能力，它设计了Low-level Contextual Guidance（LCG）和High-level Contextual Guidance（HCG）去挖掘不同的语义表征，然后通过Local-Global Content Modeling（LGCM）进行局部与全局的特征建模，从而提升文本擦除的能力。\\n\\n# 一、研究背景\\n\\n文本擦除在近几年得到了越来越多的关注，这项技术在隐私保护、视觉信息翻译和图片内容编辑等方面都有着很重要的作用；而且在教育、办公领域，文本擦除可以用于文档还原。因此，文字擦除不仅仅是给自然场景中的文字打上马赛克这样简单，而是要考虑在擦掉文字的同时保持文本区域背景的原特征，这就为这个任务带来了挑战。目前已有的工作如EraseNet[1]，PERT[2]， MTRNet++[3]等都是直接通过image-to-image的方式，它们对复杂文本背景的恢复效果并不是非常好，前景与背景经常存在明显的差异。本文受到Image Inainting领域相关工作[4][5]的启发，提出了一个通过挖掘不同语义表征去指引文本擦除的模型CTRNet，它设计了两种不同的语义表征，并通过局部-全局的特征建模提升了模型的性能。\\n\\n# 二、方法介绍\\n\\n本文提出了一个全新的两阶段文本擦除网络CTRNet，它设计了两种不同的语义表征作为擦除指引，其中文本图像的Structure作为Low-level Contextual Guidance，而深层语义特征作为High-level Contextual Guidance；得到两种表征后，再通过Local- Global Content Modeling（LGCM）进行局部与全局的特征建模，最终再通过解码器得到最终的擦除结果。CTRNet的流程图如图1所示。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c23c3212c324aa3b8d8855c4bc2e0bc~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n图1 CTRNet整体结构流程图\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd3a7ee85a024f4e84fee5d441660e19~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n图2 数据示意图\\n\\n## 2.1 文本感知分支与Soft Mask\\n\\nCTRNet是一个两阶段的模型，即先进行文本检测得到文本位置，然后再根据检测结果对图片中各个文本进行擦除。该模型使用的是PAN [6]进行文本检测，在实现过程中，PAN会和整个擦除网络一起进行优化。此外，考虑到常规的0-1 Mask（Hard Mask）会在前景与背景的边界有明显的不连续问题，我们提出在训练和前向的过程中用Soft Mask代替原本的Hard Mask。示意图如图2（b），（c）所示。\\n\\n## 2.2 Low-level Contextual Guidance（LCG）\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2bf2f2e68d534ce39c5cc29b8be28531~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/34210180393e4a529e5b66505636cd3d~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n图3\\n\\n## 2.3 High-level Contextual Guidance\\n\\n除了Low-level的结构语义先验外，我们还加入了HCG。在图像翻译以及图像修复的任务中，Perceptual/Style Loss验证了高层语义监督的有效性，因此我们认为这些语义可以作为额外的先验直接用于特征的解码与最终结果的生成，于是便在CTRNet中结合了一个HCG模块去学习并利用高层的语义特征。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93e0e44cc7194da3ae187c57bb64c5b9~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n## 2.4 Local-global Content Modeling (LGCM)\\n\\n当模型进行文本擦除并合成相应背景的时候，除了参考本身的文本区域内容外，还需要利用区域周围以及整图各部分的信息作为参考。结合CNN提取局部特征的能力以及Transformer的全局建模能力，本文设计了LGCM模块，结构如图3（b）所示。其中CNN block进行下采样，而后Transformer-Encoder则是捕获全局像素之间的长距离关联，最后再通过上采样得到最终建模后的特征。此外LGCM模块还通过SPADE操作（图1中的Incor）结合了HCG得到的高层语义特征作为先验。\\n\\n如图1所示，LGCM是一个迭代式的结构，CTRNet一共级联了8个LGCM模块。最终得到的特征用于解码得到最后的文本擦除结果。\\n\\n## 2.5 损失函数\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb8f7d80e06e4bb4b752e3f36d388dc6~tplv-k3u1fbpfcp-zoom-1.image)\\n\\nPerceptual/Style Loss\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb7ee0c94619496fb0647c36b3d3f514~tplv-k3u1fbpfcp-zoom-1.image)\\n\\nAdversarial Loss\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/acf7b8e819a8492eb6521a4f19052a09~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n# 三、实验\\n\\n实验主要是在SCUT-EnsText以及SCUT-Syn两个公开数据集上进行。此外本文还采集了一个In-house的试卷数据集进行实验验证CTRNet的泛化性。\\n\\nA． 对于各模块的消融实验结果如表1所示，可视化对比如图4所示\\n\\n表1\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd9bae90cb9d469a8cf5f04ba196877d~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b6f3297713e049e28f67a64a3f8f1fdb~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n图4\\n\\nB． 与之前SOTA方法的对比实验结果如表2与图5所示—SCUT-EnsText\\n\\n表2\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0de457463d1744b6a3dd8c4d6bf39e7c~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba576e53ea8344d1a17737694deaa3f4~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n图5\\n\\nC. 与之前SOTA方法的对比实验结果如表3与图6所示—SCUT-Syn\\n\\n表3\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7037cbb784cf4408870d29d1cc69ad57~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b718a10adb534634a5ebd77b75ad57f8~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n图6\\n\\nD. 此外，还进行了与一些Image Inpainting方法的对比，结果如表4和图7所示\\n\\n表4\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/29572f3fe0f441f0afb85b9fcb290ac6~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae14826df0de4b919d7ea7d9f919cf2a~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n图7\\n\\nE．还在in-house手写试卷数据集上验证了CTRNet的有效性，如图8所示。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c93440bd8c1542378d78a1d9c4147194~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n图8\\n\\n# 四、总结与讨论\\n\\n本文针对文本擦除中复杂背景的恢复问题提出了CTRNet，通过设计了两种不同形式的监督使得模型能学习到不同的语义表征，然后通过一个LGCM模块进行局部全局的特征建模并有效结合学习到的语义表征，以此在解码的时候能同时利用文本区域和整图其他区域的信息并恢复更加自然、合理的文本背景。在各个数据集上的实验也验证了该模型的有效性。\\n\\n# 五、相关资源\\n\\n论文地址：<https://link.springer.com/chapter/10.1007/978-3-031-19815-1_24>\\n\\n代码地址：<https://github.com/lcy0604/CTRNet>\\n\\n# 六、参考文献\\n\\n[1] Liu, Chongyu, et al. \\\"EraseNet: End-to-end text removal in the wild.\\\" IEEE Transactions on Image Processing 29 (2020): 8760-8775.\\n\\n[2] Wang, Yuxin, et al. \\\"PERT: A Progressively Region-based Network for Scene Text Removal.\\\"arXiv preprint arXiv:2106.13029 (2021).\\n\\n[3] Tursun, Osman, et al. \\\"MTRNet++: One-stage mask-based scene text eraser.\\\"Computer Vision and Image Understanding 201 (2020): 103066.\\n\\n[4] Liu, Hongyu, et al. \\\"Rethinking image inpainting via a mutual encoder-decoder with feature equalizations.\\\"European Conference on Computer Vision. Springer, Cham, 2020.\\n\\n[5] Ren, Yurui, et al. \\\"Structureflow: Image inpainting via structure-aware appearance flow.\\\"Proceedings of the IEEE/CVF International Conference on Computer Vision. 2019.\\n\\n[6] Wang, Wenhai, et al. \\\"Efficient and accurate arbitrary-shaped text detection with pixel aggregation network.\\\" Proceedings of the IEEE/CVF International Conference on Computer Vision. 2019.\\n\\n[7] Xu, Li, et al. \\\"Structure extraction from texture via relative total variation.\\\"ACM transactions on graphics (TOG) 31.6 (2012): 1-10.\\n\\n[8] Zhang, Wendong, et al. \\\"Context-aware image inpainting with learned semantic priors.\\\"Proceedings of the International Joint Conference on Artificial Intelligence, 2021.\\n\\n* * *\\n\\n**原文作者**: Chongyu Liu, Lianwen Jin, Yuliang Liu, Canjie Luo, Bangdong Chen, Fengjun Guo, and Kai Ding"
    },
    {
        "article_id": "7185736156573597756",
        "cover_image": "",
        "title": "字节三面：如何设计一个高并发系统",
        "brief": "大家好，我是田螺。 记得很久之前，去面试过字节跳动。被三面的面试官问了一道场景设计题目：如何设计一个高并发系统。当时我回答得比较粗糙，最近回想起来，所以整理了设计高并发系统的15个锦囊",
        "user_name": "捡田螺的小男孩",
        "view_count": 8216,
        "collect_count": 284,
        "comment_count": 11,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/84f7320d757a1a90652f1c80b639fcd5~300x300.image",
        "category": "后端",
        "content": "## 前言\\n\\n大家好，我是**田螺**。\\n\\n记得很久之前，去面试过**字节跳动**。被三面的面试官问了一道场景设计题目：**如何设计一个高并发系统**。当时我回答得比较粗糙，最近回想起来，所以整理了设计高并发系统的15个锦囊，相信大家看完会有帮助的。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6393addac07c442fa479a9bacc877361~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n- **公众号**：捡田螺的小男孩\\n- github地址，感谢每颗star：[github](https://github.com/whx123/JavaHome)\\n\\n\\n\\n## 如何理解高并发系统\\n\\n所谓设计**高并发**系统，就是设计一个系统，保证它**整体可用**的同时，能够**处理很高的并发用户请求**，能够承受**很大的流量冲击**。\\n\\n我们要设计高并发的系统，那就需要处理好一些常见的系统瓶颈问题，如**内存不足、磁盘空间不足，连接数不够，网络宽带不够**等等，以应对突发的流量洪峰。\\n\\n## 1. 分而治之，横向扩展\\n\\n如果你**只部署一个应用，只部署一台服务器**，那抗住的流量请求是非常有限的。并且，单体的应用，有单点的风险，如果它挂了，那服务就不可用了。\\n\\n因此，设计一个高并发系统，我们可以**分而治之，横向扩展**。也就是说，采用分布式部署的方式，部署多台服务器，把流量分流开，让每个服务器都承担一部分的并发和流量，提升**整体系统的并发能力**。\\n\\n\\n## 2. 微服务拆分（系统拆分）\\n\\n要提高系统的吞吐，提高系统的处理并发请求的能力。除了采用**分布式部署的方式**外，还可以做**微服务拆分**，这样就可以达到分摊请求流量的目的，提高了并发能力。\\n\\n所谓的**微服务拆分**，其实就是把一个单体的应用，按功能单一性，拆分为多个服务模块。**比如一个电商系统，拆分为用户系统、订单系统、商品系统等等**。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6527c4175e1147ca81ec79496da82061~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n## 3. 分库分表\\n\\n当业务量暴增的话，MySQL单机**磁盘容量会撑爆**。并且，我们知道数据库连接数是有限的。**在高并发的场景下**，大量请求访问数据库，```MySQL```单机是扛不住的！高并发场景下，会出现```too many connections```报错。\\n\\n所以高并发的系统，**需要考虑拆分为多个数据库，来抗住高并发的毒打**。而假如你的单表数据量非常大，存储和查询的性能就会遇到瓶颈了，如果你做了很多优化之后还是无法提升效率的时候，就需要考虑做**分表**了。一般千万级别数据量，就需要**分表**，每个表的数据量少一点，提升SQL查询性能。\\n\\n当面试官问要求你设计一个高并发系统的时候，一般都要说到**分库分表**这个点。\\n\\n之前写了分库分表15连问，为了应对面试官追问到底，大家可以顺便复习一下分库分表的相关经典面试题哈，可以看我这篇文章：[分库分表经典15连问](https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&amp;mid=2247502983&amp;idx=1&amp;sn=47cc9079b01940cbb83d4f71972e5d20&amp;chksm=cf2213aef8559ab845c5740abc98c335f0b040976bc39781ade95ea085cf32a183021a54ff36&token=1274856030&lang=zh_CN#rd)\\n\\n## 4. 池化技术\\n\\n在高并发的场景下，**数据库连接数**可能成为瓶颈，因为连接数是有限的。\\n\\n我们的请求调用数据库时，都会先获取数据库的连接，然后依靠这个连接来查询数据，搞完收工，最后关闭连接，释放资源。如果我们不用数据库连接池的话，每次执行```SQL```，都要创建连接和销毁连接，这就会导致每个查询请求都变得更慢了，相应的，系统处理用户请求的能力就降低了。\\n\\n因此，需要使用池化技术，即**数据库连接池、HTTP 连接池、Redis 连接池**等等。使用数据库连接池，可以避免每次查询都新建连接，减少不必要的资源开销，通过复用连接池，**提高系统处理高并发请求的能力**。\\n\\n同理，我们使用线程池，也能**让任务并行处理，更高效地完成任务**。大家可以看下我之前线程池的这篇文章，到时候面试官问到这块时，刚好可以扩展开来讲\\n\\n- [面试必备：Java线程池解析](https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&mid=2247487945&idx=1&sn=447d2da258797de08eca329a2500d457&chksm=cf21cee0f85647f676dced72811b90bf7db7c898d2a90b7dc2195c5d6279c05d1b125d4b82a1&token=1976733249&lang=zh_CN&scene=21#wechat_redirect)\\n- [细数线程池的10个坑](https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&mid=2247501030&idx=1&sn=0c0c8523d73d65ba7358856ea02fb5fc&chksm=cf221bcff85592d9556cb3735357b96baad9544c1b9c3149d0bffc290dedab32bb86d40e1075&token=1976733249&lang=zh_CN&scene=21#wechat_redirect)\\n\\n## 5. 主从分离\\n\\n通常来说，一台单机的MySQL服务器，可以支持```500```左右的```TPS```和```10000```左右的```QPS```，即单机支撑的**请求访问是有限**的。因此你做了分布式部署，部署了多台机器，部署了主数据库、从数据库。\\n\\n但是，如果双十一搞活动，流量肯定会猛增的。如果所有的查询请求，都走主库的话，主库肯定扛不住，因为查询请求量是非常非常大的。因此一般都要求做**主从分离**，然后实时性要求不高的读请求，都去读从库，**写的请求或者实时性要求高的请求，才走主库**。这样就很好保护了主库，也提高了系统的吞吐。\\n\\n当然，如果回答了主从分离，面试官可能扩展开问你**主从复制原理，问你主从延迟问题**等等，这块大家需要**全方位复习好**哈。可以去看看我之前的这篇文章\\n\\n[面试必备：聊聊MySQL的主从](https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&amp;mid=2247497982&amp;idx=1&amp;sn=bb589329cceb5462fc41f66ec63dbf56&amp;chksm=cf2227d7f855aec16dd4d3b3425c0401850eeaf2c9cdc82e82722d38a00c24ee9ccfa3353774&token=1274856030&lang=zh_CN#rd)\\n\\n\\n## 6. 使用缓存\\n\\n无论是操作系统，浏览器，还是一些复杂的中间件，你都可以看到缓存的影子。我们使用缓存，主要是提升系统接口的性能，这样高并发场景，你的系统就可以支持更多的用户同时访问。\\n\\n常用的缓存包括：```Redis```缓存，```JVM```本地缓存，```memcached```等等。就拿```Redis```来说，它单机就能轻轻松松应对几万的并发，你读场景的业务，可以用缓存来抗高并发。\\n\\n\\n缓存虽然用得爽，但是要**注意缓存使用的一些问题**：\\n\\n- 缓存与数据库的一致性问题\\n- 缓存雪崩\\n- 缓存穿透\\n- 缓存击穿\\n\\n如果大家打算使用```Redis```的话，需要知道一些注意点，可以看下我之前的这篇文章哈，挺好的。[使用Redis，你必须知道的21个注意要点](https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&amp;mid=2247488325&amp;idx=1&amp;sn=6d9bbe5bf2f2f2904755de5c786fb21b&amp;chksm=cf21cc6cf856457a9d23b3e25ec48107a582e709f05964dfdb5ba77e9a239d8307334c485fdf&token=1371687559&lang=zh_CN#rd)\\n\\n## 7. CDN，加速静态资源访问\\n\\n\\n商品图片，```icon```等等静态资源，可以对页面做**静态化处理，减少访问服务端的请求**。如果用户分布在全国各地，有的在上海，有的在深圳，地域相差很远，网速也各不相同。为了让用户最快访问到页面，可以使用```CDN```。```CDN```可以让用户就近获取所需内容。\\n\\n什么是CDN？\\n> Content Delivery Network/Content Distribution Network,翻译过来就是内容分发网络，它表示将静态资源分发到位于多个地理位置机房的服务器，可以做到数据就近访问，加速了静态资源的访问速度，因此让系统更好处理正常别的动态请求。\\n\\n\\n## 8. 消息队列，削锋\\n\\n我们搞一些双十一、双十二等运营活动时，需要**避免流量暴涨，打垮应用系统的风险**。因此一般会引入消息队列，来应对**高并发的场景**。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/01f2c25360974e9c833a9e2745e5e41a~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n假设你的应用系统每秒最多可以处理```2k```个请求，每秒却有```5k```的请求过来，可以引入消息队列，应用系统每秒从消息队列拉```2k```请求处理得了。\\n\\n有些伙伴担心这样可能会出现**消息积压**的问题：\\n\\n- 首先，搞一些运营活动，不会每时每刻都那么多请求过来你的系统（**除非有人恶意攻击**），高峰期过去后，积压的请求可以慢慢处理；\\n- 其次，如果消息队列长度超过最大数量，可以直接抛弃用户请求或跳转到错误页面；\\n\\n\\n## 9. ElasticSearch\\n\\n```Elasticsearch```，大家都使用得比较多了吧，**一般搜索功能都会用到它**。它是一个分布式、高扩展、高实时的搜索与数据分析引擎，简称为```ES```。\\n\\n我们在聊高并发，为啥聊到```ES```呢？ 因为```ES```可以扩容方便，天然支撑高并发。**当数据量大的时候，不用动不动就加机器扩容，分库等等**，可以考虑用```ES```来支持简单的查询搜索、统计类的操作。\\n\\n\\n## 10. 降级熔断\\n\\n**熔断降级**是保护系统的一种手段。当前互联网系统一般都是分布式部署的。而分布式系统中偶尔会出现某个基础服务不可用，最终导致整个系统不可用的情况, 这种现象被称为**服务雪崩效应**。\\n\\n比如分布式调用链路```A->B->C....```，下图所示：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e4ce0feb22bd477489549bda261dc487~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n> 如果服务```C```出现问题，比如是因为慢```SQL```导致调用缓慢，那将导致```B```也会延迟，从而```A```也会延迟。堵住的```A```请求会消耗占用系统的线程、IO、CPU等资源。当请求```A```的服务越来越多，占用计算机的资源也越来越多，最终会导致系统瓶颈出现，造成其他的请求同样不可用，最后导致业务系统崩溃。\\n\\n为了应对服务雪崩, 常见的做法是**熔断和降级**。最简单是加开关控制，当下游系统出问题时，开关打开降级，不再调用下游系统。还可以选用开源组件```Hystrix```来支持。\\n\\n你要保证设计的系统能应对**高并发场景**，那肯定要考虑**熔断降级**逻辑进来。\\n\\n## 11. 限流\\n\\n限流也是我们应对高并发的一种方案。我们当然希望，在高并发大流量过来时，系统能全部请求都正常处理。但是有时候没办法，系统的CPU、网络带宽、内存、线程等资源都是有限的。因此，我们要考虑限流。\\n\\n如果你的系统每秒扛住的请求是一千，**如果一秒钟来了十万请求呢**？换个角度就是说，高并发的时候，流量洪峰来了，超过系统的承载能力，怎么办呢？\\n\\n这时候，我们可以采取限流方案。就是为了保护系统，多余的请求，直接丢弃。\\n\\n> **什么是限流**：在计算机网络中，限流就是控制网络接口发送或接收请求的速率，它可防止DoS攻击和限制Web爬虫。限流，也称流量控制。是指系统在面临高并发，或者大流量请求的情况下，限制新的请求对系统的访问，从而保证系统的稳定性。\\n\\n可以使用```Guava```的```RateLimiter```单机版限流，也可以使用```Redis```分布式限流，还可以使用阿里开源组件```sentinel```限流。\\n\\n面试的时候，你说到限流这块的话？面试官很大概率会问你限流的算法，因此，大家在准备面试的时候，需要复习一下这几种经典的限流算法哈，可以看下我之前的这篇文章，[面试必备：4种经典限流算法讲解](https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&mid=2247490393&idx=1&sn=98189caa486406f8fa94d84ba0667604&chksm=cf21c470f8564d665ce04ccb9dc7502633246da87a0541b07ba4ac99423b28ce544cdd6c036b&token=162724582&lang=zh_CN&scene=21#wechat_redirect)\\n\\n## 12. 异步\\n\\n> 回忆一下什么是同步，什么是异步呢？以**方法调用**为例，它代表**调用方要阻塞等待被调用方法中的逻辑执行完成**。这种方式下，当被调用方法响应时间较长时，会造成调用方长久的阻塞，在高并发下会造成整体系统性能下降甚至发生雪崩。异步调用恰恰相反，调用方不需要等待方法逻辑执行完成就可以返回执行其他的逻辑，在被调用方法执行完毕后再通过回调、事件通知等方式将结果反馈给调用方。\\n\\n因此，设计一个高并发的系统，**需要在恰当的场景使用异步**。如何使用异步呢？后端可以借用消息队列实现。比如在海量秒杀请求过来时，先放到消息队列中，快速相应用户，告诉用户请求正在处理中，这样就可以释放资源来处理更多的请求。秒杀请求处理完后，通知用户秒杀抢购成功或者失败。\\n\\n## 13. 常规的优化\\n\\n设计一个高并发的系统，需要设计接口的性能足够好，这样系统在相同时间，就可以处理更多的请求。当说到这里的话，大家就可以跟面试官说说接口优化的一些方案了。大家可以看下我的这篇文章哈:[实战总结！18种接口优化方案的总结](https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&amp;mid=2247502660&amp;idx=1&amp;sn=17166646f82412cd81955930f799ab4e&amp;chksm=cf22146df8559d7bcf9becd82e1d8006c35a781e5dbd0a79e0a9e121803ee40d6eae7ebd7ccb&token=1371687559&lang=zh_CN#rd)\\n\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/31e6b1a61abd4374a7cd0cd37e4f0d42~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n\\n\\n## 14. 压力测试确定系统瓶颈\\n\\n设计高并发系统，离不开最重要的一环，**就是压力测试**。就是在系统上线前，需要对系统进行压力测试，测清楚你的系统支撑的最大并发是多少，确定系统的瓶颈点，让自己心里有底，最好预防措施。\\n\\n压测完要分析整个调用链路，性能可能出现问题是网络层（如带宽）、Nginx层、服务层、还是数据路缓存等中间件等等。\\n\\n```loadrunner```是一款不错的压力测试工具，```jmeter```则是接口性能测试工具，都可以来做下压测。\\n\\n## 15. 应对突发流量峰值：扩容+切流量\\n\\n如果是突发的流量高峰，除了降级、限流保证系统不跨，我们可以采用这两种方案，保证系统尽可能服务用户：\\n\\n- 扩容：**比如增加从库、提升配置的方式**，提升系统/组件的流量承载能力。比如增加```MySQL、Redis```从库来处理查询请求。\\n- 切流量：**服务多机房部署**，如果高并发流量来了，把流量从一个机房切换到另一个机房。\\n\\n\\n## 参考与感谢\\n\\n- [极客时间高并发系统设计 40 问](https://time.geekbang.org/column/article/192203)\\n\\n"
    },
    {
        "article_id": "7187433862765477947",
        "cover_image": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52af12e8fec646bc9dd5cdad9113d7f5~tplv-k3u1fbpfcp-watermark.image?",
        "title": "低头做事，抬头看路",
        "brief": "前言 博主出来搬砖快4年了，在职场摸爬滚打，经历挺多比较难熬的经历，在这些磨练下不断的成长，平时有空的时候我习惯去思考，当然这个跟我的习惯有关系，以前喜欢幻想各种变身机甲战斗，每个男孩子小时候的梦想。",
        "user_name": "大鸡腿同学",
        "view_count": 4541,
        "collect_count": 10,
        "comment_count": 5,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/b8b82e41a702943a5442964c471f02e5~300x300.image",
        "category": "代码人生",
        "content": "# 前言\\n---\\n\\n博主出来搬砖快4年了，在职场摸爬滚打，经历挺多比较难熬的经历，在这些磨练下不断的成长，平时有空的时候我习惯去思考，当然这个跟我的习惯有关系，以前喜欢幻想各种变身机甲战斗，每个男孩子小时候的梦想。\\n\\n> 低头做事，抬头看路\\n\\n这个应该是我感受比较深的一句话，当然也是属于我自己的东西，比如说某个名人说了一句名言，但是你没有去经历过，没有去深入思考，它对你来说就是一句话，只是被名人光环笼罩着，感觉高大无比，其实对你没有什么帮助的。\\n\\n接下来，找个凳子坐下，听我慢慢讲述～\\n\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b3e6903987d241fb9115e922cfb77d67~tplv-k3u1fbpfcp-watermark.image?)\\n\\n# 低头做事\\n---\\n\\n- 干好活\\n\\n我认为这是普通人最实在的一件事，也是最应该去做的，比如说在社会中有很多收入比较低的人群，他们起早贪黑，很辛苦，但是如果他们不这么做的话，可能连生活都成问题，所以努力做事是一个基础。\\n\\n- 运气差的时候\\n\\n如果你读过《易经》里面会谈到人的运气类似周期变化，潜龙勿用，这里我们不讲玄学的东西，当运气差的时候，没有背景，没有靠山的时候，你再怎么吹多厉害多能干，其实是没有多大用处的，这时适合把嘴闭上，把事干好。\\n\\n- 建立信任\\n\\n当你刚刚进入新的团队的时候，leader怎么会把重任给一个新人接手对吧，其实多做事，做好事，这个是建立信任的基础。如果你上来就喊要造飞机搞火箭，可能别人会觉得你是传销毕业的，不太靠谱。\\n\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/548d6aa644fe486b83f6a83ee9e03c47~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n我认为它是一种比较实在的做法，也是普通人最基本的生存法则，它叫低头做事。\\n\\n# 抬头看路\\n\\n---\\n\\n低头做事作为一个基础，那么抬头看路是一个进阶版，快跑者未必先到，力战者未必能克，如果方向错了，努力事倍功半。这部分讲更多的是方法论，一种思想。\\n\\n- 方向\\n\\n作为程序猿，在业界对他是有标准要求的，之前写过一篇文章是阿里工程师修炼素养里面讲到的，就是技术思维、工程思维、产品思维，但是这不是唯一标准，你可以就某一项特别突出，那一定是个人才。但很多人对自己的职业规划还是模糊的，有几方面：\\n\\n一个是接触的人、事情比较少，如果跟你打交道的都是小喽喽，那你没有机会从大佬身上去学习东西。即使你没有机会接触公司这些中高层，你可以网上认识各大厂大佬，我之前在一个技术群认识很多技术大牛，至少他们可以为你的问题、你的职业抉择提出他们的想法。\\n\\n> 毕竟你走的路，他们已经走过了。\\n\\n\\n一方面是自己没有意识去归纳，你当前这个阶段要求的能力是什么，下一阶段需要的能力、素质是什么，那下一段的要求从哪里去找呢？从你身边的大佬、业界优秀的人身上去找，甚至招聘的jd里面的要求去找。\\n\\n> 有时迷茫是正常的，保持前进的心态，积极向上的精神\\n\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/776e219ddf2740f7a32edc4d04e6e785~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n- 参考、借鉴\\n\\n在实际工作中，有很多需求其实在业界早已有解决方案了，互联网发展了几十年，你碰到的问题其实很多人都帮你踩了好几遍了，在处理这些需求的时候，需要前期的调研，比如业界有哪些优秀的设计或者思想，为什么要采用这种方式解决，跟你心里想的方案有什么差异。\\n\\n就拿ddd领域来讲吧，其实这个就是换个皮又出来，高内聚、低耦合这个思想一直都是存在的，比如说各种设计模式，还有各种优化，对那些重复的代码进行抽象、聚拢，这个一直在我们身边只是没有给它定义一套方法论出来，ddd就将它讲清楚，并给了对应demo。\\n\\n甚至是跨界的思维也可以帮你解决问题，这个需要你的抽象能力，就像今天有个同学在我博客下面评论他对ddd那篇文章看法，因为我项目里面应用的比较少，违背各种它的设计理念，我觉得这是大部分人的思维被技术控死了。\\n\\n我举了个栗子，一棵苹果树砍成树冠，那它还是不是苹果树？大部人会觉得是的，我也是这个观点。就是你目前有结苹果的能力，或者未来有这个能力，也算苹果树。苹果树苗，人家小时候也是一点一点长起来的，又不是一下子就结果对吧。\\n\\nDDD领域改造一个道理，它是一个过程，它具备往这个方向发展的能力，但是目前没有必要去做这层优化，你说我项目是不是ddd呢？我觉得算是，只是应用程度没有覆盖那么广，但是理论我们需要去了解的。\\n\\n- 机会\\n\\n前面讲过，低头做事为了建立信任，那么抬头看路可以更多为你创造机会，有段时间我的飞书签名：抓住机会，创造机会。\\n\\n> 抓住机会，创造机会\\n\\n我在上家公司的时候，感受比较深，就是即使你做了很多事，其实成就不高的，原因是你干的活不被上面的人重视，或者不是很重要的活。这时你要去发现机会，抓住它，甚至主动请缨，劳资就能把事情干好，干漂亮了。即使是难度很大，要把首战必胜的信心，认真做事态度表现出来。\\n\\n还有个栗子，很多高收益的项目，就是你做完之后收获很多，可能是荣誉、奖金、信任、赞赏，其实换个人去做很大几率可以干成，所以并不是你埋头苦干就能出成绩，往往属于你的机会就是那么关键几个，把它做好，做漂亮了就可以了。就像我们以前高考，把会答的题写了就已经超过60%的人了。\\n\\n> 现在太多的人想着拿90分，但连5分的题都不屑于去做\\n\\n查理芒格他们有个投资理念：棒球理论，就是有个研究，棒球在某几个格子的时候是最容易击中的，只要把那几个打好就ok了，现在的社会鼓吹一股浮躁的风气，大家都想赚大钱，拿很多荣誉，这是人性的贪在肆虐。\\n\\n> 寻找属于自己的机会\\n\\n\\n# 感知能力\\n---\\n\\n这个话题偏玄学一点的，当然里面的内容尽可能往实际的场景去靠，不过于虚，对读者也没有太大的帮助。上面我们讲了低头做事，抬头看路这还不够的，因为这局限于个人，人在一个场里面，或者不同场的嵌套，是会被影响的，大趋势一定比你个人的努力还重要的。（这个我觉得是前面两者做好的基础上去提高，而不是还没学会走，开始学飞）\\n\\n- 势能\\n\\n有句话我听过很多次，“一命二运三风水...”，它对个人来讲有木有用呢？这个需要个人去理解、思考的，前面好几个讲的是机会问题，这个是我们决定不了的，闽南语里面“七分靠打拼，三分天注定”是这个道理。另外有个东西是我们可以去感知的，就是势能。\\n\\n比如说一家技术公司，它是产品强势还是研发，还是测试，他们之间的势能不一样，会影响职场工作、项目推进，因为这是一个比较大的场。\\n\\n市场也有势能，这东西就像做菜一样，买菜备料，炖的话可能要炖很久，食物才能入味，最后才能发挥它的威力。市场我们也能找到对应的事件，忽然某个社交app一直讲某件事造势，然后其他人跟着喊，然后就扩大了，最终朝着它想要去的地方发展。\\n\\n> 个人能力、努力太单薄了，多关注势\\n\\n\\n- 推演\\n\\n这个跟上面还是有些耦合的内容，推演是依据现有的东西，然后根据自己的经验或者过往的经验进行预判。这个在五子棋的时候，ai机器人进行机器学习训练，打败了很多高手，这就是推演的魅力。\\n\\n这个能力也会被决策者应用，比如说决策树，主要是列出会出现的场景，以及对应的应对措施，预防一些风险。\\n\\n推演对于普通人来讲也是一项能力，比如说你能否预测下这个月的成长，今年所达到的水平，或者更长时间5年后你成长的模样，你的能力圈层能到哪里。\\n\\n# 总结\\n\\n---\\n\\n\\n低头做事，抬头看路，可能几年后荣誉满满、成就满满，也可能平淡无奇，人生也就那样。人生的意义不是得来衡量的，就像很多有钱人不一定就很幸福，因为他们消费水平也上去了，欲望更大了。\\n\\n人生是一场体验，你在中间经历了什么，成长了什么，收获了什么，酸甜苦辣咸何尝不就是人生的味道。\\n\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8d6276812034850a88c7fba5bbf5736~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n"
    },
    {
        "article_id": "7164694758588153863",
        "cover_image": "",
        "title": "推荐20个开源的前端低代码项目",
        "brief": "近几年，在技术领域低代码是比较热门的话题，比如阿里云推出了易搭，通过简单的拖拽、配置，即可完成业务应用的搭建，腾讯云则是推出了微搭，通过行业化模板、拖放式组件和可视化配置快速构建多端应用。 低代码是基",
        "user_name": "xiangzhihong",
        "view_count": 16813,
        "collect_count": 632,
        "comment_count": 15,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/ae3b5ed78812b766bd8f5f82a5ee8128~300x300.image",
        "category": "前端",
        "content": "近几年，在技术领域低代码是比较热门的话题，比如阿里云推出了易搭，通过简单的拖拽、配置，即可完成业务应用的搭建，腾讯云则是推出了微搭，通过行业化模板、拖放式组件和可视化配置快速构建多端应用。\\n\\n\\n低代码是基于可视化和模型驱动理念，结合云原生与多端体验技术，它能够在多数业务场景下实现大幅度的提效降本，为专业开发者提供了一种全新的高生产力开发范式。下面就来分享几个值得学习和使用的低代码开源项目，更深入地了解什么是低代码。\\n\\n# 1，Appsmith\\n\\nAppsmith 是一款开源低代码框架，主要用于构建管理面板、内部工具和仪表板等，允许拖放 UI 组件来构建页面，通过连接到任何 API、数据库或 GraphQL 源，并使用 JavaScript 语言编写逻辑，可以在短时间内创建内部应用程序。\\n\\n \\n![Build-UI.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aae446899d494ea29b2f88ad021723ee~tplv-k3u1fbpfcp-watermark.image?)\\n\\n项目链接：<https://github.com/appsmithorg/appsmith>\\n\\n# 2，LowCodeEngine\\n\\nLowCodeEngine 由阿里巴巴钉钉宜搭团队开发的低代码框架，基于阿里云的云基础设施和钉钉的企业数字化操作系统。使用者只需要基于低代码引擎便可以快速定制符合自己业务需求的低代码平台。同时LowCodeEngine还提供了很多的基础组件，可以帮助开发者快速的构建业务页面。\\n\\n \\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2504e31a51534fdebb3bb19544672cb9~tplv-k3u1fbpfcp-watermark.image?)\\n\\n \\n\\n项目链接：<https://github.com/alibaba/lowcode-demo>\\n\\n# 3，Amis\\n\\nAmis 是百度开源的一款前端低代码框架，通过 JSON 配置就能生成各种后台页面，包括数据获取、表单提交及验证等功能，同时，Amis内置 100+ 种 UI 组件，能够满足各种页面组件展现的需求，极大减少开发成本，甚至可以不需要了解前端。\\n\\n \\n\\namis 在百度内部得到了广泛使用，在 4 年多的时间里创建了 3w 多页面，从内容审核到机器管理，从数据分析到模型训练，amis 满足了各种各样的页面需求。我们可以[下载源码](https://github.com/baidu/amis)，然后使用如下的命令来体验。\\n\\n```\\n# 安装项目 npm 依赖，在 node 12 下会有报错但不影响正常使用。\\nnpm i --legacy-peer-deps\\n# 启动项目，等编译结束后通过 http://127.0.0.1:8888/examples/pages/simple 访问。\\nnpm start\\n```\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eaf6226b03f24bb4b4028c2bc7c7186f~tplv-k3u1fbpfcp-watermark.image?)\\n \\n\\n项目链接：<https://github.com/baidu/amis>\\n\\n# 4，tmagic-editor\\n\\ntmagic-editor是一款由腾讯技术中心出品的一款开源低代码框架，能够实现零代码/低代码生成页面 ， 可以快速搭建可视化页面生产平台，让非技术人员可以通过拖拽和配置，自助生成H5页面、PC页面、TV页面，大大降低页面生产成本 。\\n\\n\\n \\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/29e75c1df2554085890121a41785458b~tplv-k3u1fbpfcp-watermark.image?)\\n\\n项目链接：<https://gitee.com/webapp_qsr/tmagic-editor>\\n\\n# 5，dooring-electron-lowcode\\n\\ndooring-electron-lowcode是一款功能强大，专业可靠的可视化页面配置解决方案，致力于提供一套简单方便、专业可靠、无限可能的H5落地页最佳实践。技术栈以react和typescript为主， 后台采用nodejs开发, electron作为桌面端基础方案。\\n\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4050a78d509e4cf5b4c799476f0db94c~tplv-k3u1fbpfcp-watermark.image?)\\n\\n和它一样的还有H5-Dooring，H5-Dooring是一款功能强大、专业可靠的H5可视化页面配置解决方案，致力于提供一套简单方便、专业可靠、无限可能的H5落地页最佳实践。技术栈以 React 和 TypeScript 为主，后台采用nodejs开发。除了 H5 版，还提供了 PC 版。\\n\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ffcb11c2a7c14658a239c6f7a859975b~tplv-k3u1fbpfcp-watermark.image?)\\n\\n# 6，vite-vue3-lowcode\\n\\nvite-vue3-lowcode 是一款基于Vite2.x + Vue3.x + TypeScript技术框架的的H5 低代码平台。目前只是一个简单的模板，支持数据配置的导入和导出，配置的修改和删除操作，用到的技术有sandbox 中执行自定义逻辑、monaco-editor 自定义代码补全、vue3 createRenderer 自定义渲染器等。\\n \\n![68747470733a2f2f7a332e617831782e636f6d2f323032312f30372f30372f52486642626e2e676966.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a3b933896a3544f9a73ba43bd914dbbe~tplv-k3u1fbpfcp-watermark.image?)\\n\\n# 7，shida\\n\\nshida是一个视频可视化搭建项目，开发者可以通过拖拽就可以快速地生产一个短视频，使用方式就像易企秀或百度 H5 等 h5 低代码平台一样。shida的后端视频合成部分是基于[FFCreator](https://github.com/tnfe/FFCreator)进行开发的，FFCreator 是一个基于 node.js 的轻量、灵活的短视频加工库，只需要添加几张图片或视频片段再加一段背景音乐，就可以快速生成一个很酷的视频短片。\\n\\n\\n![demo.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70be0b909a6747dc9295baced5520e7b~tplv-k3u1fbpfcp-watermark.image?)\\n项目链接：<https://github.com/tnfe/shida>\\n\\n# 8，quark-h5\\n\\nquark-h5是一个使用Vue + Koa的前端低代码框架，和大多数的前端低代码框架一样，采用的是编辑器生成页面JSON数据，服务端负责存取JSON数据，渲染时从服务端取数据JSON交给前端模板处理。\\n\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/100ce51347e249699a367759c99c91ad~tplv-k3u1fbpfcp-watermark.image?)\\n\\n项目链接：<https://github.com/huangwei9527/quark-h5>\\n\\n\\n# 9，gods-pen\\n\\n码良是一个在线生成 H5 页面并提供页面管理和页面编辑的平台，用于快速制作 H5 页面。用户无需掌握复杂的编程技术，通过简单拖拽、少量配置即可制作精美的页面，可用于营销场景下的页面制作。同时，也为开发者提供了完备的编程接入能力，通过脚本和组件的形式获得强大的组件行为和交互控制能力。\\n\\n \\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3bcff975dc104d29b1551bbd34d091ff~tplv-k3u1fbpfcp-watermark.image?)\\n\\n项目链接：<https://github.com/ymm-tech/gods-pen>\\n\\n# 10，luban-h5\\n\\n鲁班H5是基于Vue2.0开发的支持拖拽方式来快速生成页面的低代码平台，功能基本类似于易企秀、Maka、百度等H5平台。\\n\\n \\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be285e7616b242bd9ab3ade00da156c5~tplv-k3u1fbpfcp-watermark.image?)\\n\\n项目链接：<https://github.com/ly525/luban-h5>\\n\\n# 11，mometa\\n\\nmometa 并不是传统主流的低代码平台（如 amis），mometa 是面向研发、代码可视设计编辑平台，更像是 dreamweaver、gui的可视编辑 工具。借助它，我们可以获得所见即所得的可视编辑开发体验。\\n\\n \\n![mometa-insert-material.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d7bfffe6cd74c2e83f350ec667c0182~tplv-k3u1fbpfcp-watermark.image?)\\n 项目链接：<https://github.com/imcuttle/mometa>\\n\\n\\n# 12，h5-factory\\n\\nh5-factory是专题页面可视化编辑工具，可以通过拖拽来设计页面，并且指出一键生成html文件。\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc04c5e99c5741dda77d55f9556efed7~tplv-k3u1fbpfcp-watermark.image?)\\n\\n项目链接：<https://github.com/xuhaiqing/h5-factory>\\n\\n\\n# 13，steedos-platform\\n\\nsteedos-platform是 Salesforce 低代码平台的开源替代方案，使用可视化工具进行模型设计, 页面设计, 流程设计, 报表设计，只需点击鼠标，就能快速创建应用程序，实现敏捷开发的新高度。在技术实现细节上，steedos-platform使用元数据定义对象，字段，配置，代码，逻辑和页面布局，并基于这些元数据自动生成系统的数据结构以及Steedos应用程序的用户界面和自动化逻辑。\\n\\n \\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ec50cc536994381ba4be80f296e0842~tplv-k3u1fbpfcp-watermark.image?)\\n\\n不过，steedos-platform是一整套的低代码解决方案，如果需要单独开发或者部署需要同时具备前后端架构的能力。\\n\\n项目链接：<https://github.com/steedos/steedos-platform/>\\n\\n# 14，lz-h5-edit\\n\\nlz-h5-edit是一个H5低代码编辑平台，支持拖拽、缩放、旋转、动画、撤销、重做、组合元素等方式来创建H5页面。\\n\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7315e0ccecd1408e86de0c715fcddb51~tplv-k3u1fbpfcp-watermark.image?)\\n\\n项目链接：<https://github.com/lzuntalented/lz-h5-edit>\\n\\n# 15，tefact\\n\\n星搭开源无代码编辑器，使用图形化界面生成 网站、H5和表单，无需任何代码即可生成应用程序。\\n\\n![show.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d02014c1f4f44ee9e9146ea44c144b3~tplv-k3u1fbpfcp-watermark.image?)\\n\\n项目链接：<https://github.com/staringos/tefact/>\\n\\n# 16，fast-poster\\n\\nfast-poster是一款使用Python+Vue开发的通用海报生成器，可以用来快速的生成海报。使用时知需要经过三步即可生成所需要的海报：启动服务 > 编辑海报 > 生成代码。\\n\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e8c5fd232794f848e71e07f88b449b9~tplv-k3u1fbpfcp-watermark.image?)\\n\\n项目链接：<https://gitee.com/vitojc/fast-poster>\\n\\n# 17，openDataV\\n\\nOpenDataV 是一款基于Vue3 + vite + TypeScript开发前端可视化低代码平台。支持拖拽式、可视化、低代码数据可视化开发，你可以用它自由的拼接成各种炫酷的大屏，同时支持接入开发者自己开发的组件接入平台。\\n\\n\\n![2.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f35c3961fc3e437ca475151be1022f1e~tplv-k3u1fbpfcp-watermark.image?)\\n\\n项目链接：<https://github.com/AnsGoo/openDataV>\\n\\n# 18，mall-cook\\n\\nMall-Cook 是一个基于 vue 开发的可视化商城搭建平台，包括多页面可视化构建、Json Schema 生成器（可视化搭建物料控制面板），实现组件流水线式标准接入平台。最新版本使用 uni-app 重构物料、模板项目，支持生成 H5、小程序多端商城。\\n\\n \\n![MallCook-Build.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42d02127221a4bd0a735bf605fbd7609~tplv-k3u1fbpfcp-watermark.image?)\\n\\n![]()项目链接：<https://github.com/wangyuan389/mall-cook>\\n\\n# 19，form-generator\\n\\nform-generator是一个基于Element UI表单设计及代码生成器，可将生成的代码直接运行在基于Element的vue项目中，也可导出JSON表单，使用配套的解析器将JSON解析成真实的表单。\\n\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bea2d129b26b4494b1c4fb1338c090ca~tplv-k3u1fbpfcp-watermark.image?)\\n\\n项目链接：<https://github.com/JakHuang/form-generator>\\n\\n# 20，vjdesign\\n\\nvjdesign是一款支持任何 vue 项目中的组件，不需要二次开发就可以定义支持的组件以及组件的属性，并且对组件的属性和数据的关系以及表单的交互行为也可以通过设计器配置实现。\\n\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/12a5a46028504e79b4d880e6cdc7dcdb~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n项目链接：<https://github.com/fyl080801/vjdesign>\\n\\n除了上面部分开源的低代码平台外，还有很多是不开源的，具体参考下面的链接：<https://github.com/taowen/awesome-lowcode>。\\n\\n***本文正在参加[「金石计划 . 瓜分6万现金大奖」](https://juejin.cn/post/7162096952883019783 \\\"https://juejin.cn/post/7162096952883019783\\\")***"
    },
    {
        "article_id": "7155040639497797645",
        "cover_image": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e71329fd176549cdaf9a7fc43c90b924~tplv-k3u1fbpfcp-watermark.image?",
        "title": "使用fabric.js 快速开发一个图片编辑器",
        "brief": "源码在GitHub上，总结下使用fabric.js开发一个编辑器需要用到哪些知识点。 预览地址：https://nihaojob.github.io/vue",
        "user_name": "愚坤",
        "view_count": 31206,
        "collect_count": 580,
        "comment_count": 78,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/06f5332b06d5614f382bc8c8f573ae6f~300x300.image",
        "category": "前端",
        "content": "\\n最近自己开发了一个图片编辑器，把源码也放在了GitHub上，顺便也总结下使用fabric.js开发一个编辑器需要用到哪些知识点。\\n\\n- 预览地址：https://nihaojob.github.io/vue-fabric-editor/\\n- GitHub地址：https://github.com/nihaojob/vue-fabric-editor\\n\\n![Foxmail20220904011310.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88ca4329b4c24dcea91e624ccadf4127~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n### 架构设计\\n**选型：** fabric.js 和 konva.js都是强大的canvas库，功能上类似，konva.js比较新中文文档也多一些，因为比较熟悉fabric就没有采用konva。\\n\\n**要点：** 因为框架用的vue，主要解决如何把fabric的实例对象共享给各个功能组件，区分出是未选中、单选、多选状态，然后将选中、取消选中事件暴露给各个功能组件，子组件根据状态进行独立的功能开发。\\n\\n我的方法是在入口文件中初始化实例，然后与mixins结合，在mixins中定义了选择类型（多选、单选、未选中）、选中元素类型、选中id等属性，以及选中、取消选中的事件，子组件通过引入mixins来开发对应功能；如子组件需要对fabric对象进行操作，则可以通过inject获得原始对象。\\n\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97d79b361a2549eea30d199e59b36344~tplv-k3u1fbpfcp-watermark.image?)\\n\\n入口文件：\\nhttps://github.com/nihaojob/vue-fabric-editor/blob/161faae7b0adcf6f55d9efaa38cb6d7c6d2c01b5/src/views/HomeView.vue#L113\\n\\nmixins文件：\\nhttps://github.com/nihaojob/vue-fabric-editor/blob/main/src/mixins/select.js\\n\\n\\n\\n\\n### 初始化\\n初始化比较简单，fabric.js创建对象，用EventEmitter创建事件发射器，可订阅单选、多选、取消选择事件。\\n通过vue的provide语法把fabric对象、EventEmitter对象向下传递，在mixins中保存选中的元素和选中状态。\\n\\n**初始化：**\\nhttps://github.com/nihaojob/vue-fabric-editor/blob/161faae7b0adcf6f55d9efaa38cb6d7c6d2c01b5/src/views/HomeView.vue#L111\\n\\n\\n**事件发射器：**\\n\\n```\\nimport EventEmitter from 'events'\\n\\nclass EventHandle extends EventEmitter {\\n\\n    init(handler){\\n        this.handler = handler\\n        this.handler.on(\\\"selection:created\\\", (e) => this._selected(e));\\n        this.handler.on(\\\"selection:updated\\\",  (e) => this._selected(e));\\n        this.handler.on(\\\"selection:cleared\\\", (e) => this._selected(e));\\n    }\\n\\n    // 暴露单选多选事件\\n    _selected(e) {\\n        const actives = this.handler.getActiveObjects()\\n        if(actives && actives.length === 1) {\\n            this.emit('selectOne', actives)\\n        }else if(actives && actives.length > 1){\\n            this.mSelectMode = 'multiple'\\n            this.emit('selectMultiple', actives)\\n        }else{\\n            this.emit('selectCancel')\\n        }\\n    }\\n}\\n\\nexport default EventHandle\\n```\\n**mixins:**\\n```\\nexport default {\\n  inject: ['canvas', 'fabric', 'event'],\\n  data() {\\n    return {\\n      mSelectMode: '', // one | multiple\\n      mSelectOneType: '', // i-text | group ...\\n      mSelectId: '', // 选择id\\n      mSelectIds: [], // 选择id\\n    }\\n  },\\n  created(){\\n    this.event.on('selectOne', (e) => {\\n      this.mSelectMode = 'one'\\n      this.mSelectId = e[0].id\\n      this.mSelectOneType = e[0].type\\n      this.mSelectIds = e.map(item => item.id)\\n    })\\n\\n    this.event.on('selectMultiple', (e) => {\\n      this.mSelectMode = 'multiple'\\n      this.mSelectId = ''\\n      this.mSelectIds = e.map(item => item.id)\\n    })\\n\\n    this.event.on('selectCancel', () => {\\n      this.mSelectId = ''\\n      this.mSelectIds = []\\n      this.mSelectMode = ''\\n      this.mSelectOneType = ''\\n    })\\n  },\\n  methods: {\\n    /**\\n     * @description: 保存data数据\\n     * @param {Object} data 房间详情数据\\n     */\\n    _mixinSelected({ event, selected }) {\\n      if(selected.length === 1) {\\n        const selectItem = selected[0]\\n        this.mSelectMode = 'one'\\n        this.mSelectOneType = selectItem.type\\n        this.mSelectId = [selectItem.id]\\n        this.mSelectActive = [selectItem]\\n      }else if(selected.length > 1){\\n        this.mSelectMode = 'multiple'\\n        this.mSelectActive = selected\\n        this.mSelectId = selected.map(item => item.id)\\n      }else{\\n        this._mixinCancel()\\n      }\\n    },\\n    /**\\n     * @description: 保存data数据\\n     * @param {Object} data 房间详情数据\\n     */\\n     _mixinCancel(data) {\\n      this.mSelectMode =''\\n      this.mSelectId= []\\n      this.mSelectActive =[]\\n      this.mSelectOneType = ''\\n    },\\n  }\\n}\\n\\n```\\n\\n\\n### 背景设置\\n![背景.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2286f31ad81545579f8a0a4caf060d60~tplv-k3u1fbpfcp-watermark.image?)\\n主要包括设置画布大小、设置背景颜色、设置背景图片，也可以设置背景重复方向。\\n[代码：](https://github.com/nihaojob/vue-fabric-editor/blob/main/src/components/bgBar.vue)\\n``` \\n// 设置大小\\nsetSize() {\\n      this.canvas.c.setWidth(this.width);\\n      this.canvas.c.setHeight(this.height);\\n      this.canvas.c.renderAll()\\n},\\n// 设置背景图片\\nsetBgImg(target) {\\n      const imgEl = target.cloneNode(true);\\n      imgEl.onload = () => {\\n        // 可跨域设置\\n        const imgInstance = new this.fabric.Image(imgEl, { crossOrigin: 'anonymous' });\\n        // 渲染背景\\n        this.canvas.c.setBackgroundImage(imgInstance, this.canvas.c.renderAll.bind(this.canvas.c), {\\n          scaleX: this.canvas.c.width / imgInstance.width,\\n          scaleY: this.canvas.c.width / imgInstance.width,\\n        });\\n        this.canvas.c.renderAll()\\n        this.canvas.c.requestRenderAll();\\n      }\\n},\\n// 背景颜色设置\\nsetColor(color) {\\n      this.canvas.c.setBackgroundColor(color, this.canvas.c.renderAll.bind(this.canvas.c))\\n      this.canvas.c.backgroundImage = ''\\n      this.canvas.c.renderAll()\\n}\\n```\\n\\n### 插入元素\\n![插入元素.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43d110915d044f91818a238df07bf767~tplv-k3u1fbpfcp-watermark.image?)\\n主要包括插入基础元素文字、正方形、圆形、三角形、SVG元素，详见[代码](https://github.com/nihaojob/vue-fabric-editor/blob/main/src/components/tools.vue#L122)：\\n```\\naddText() {\\n      const text = new this.fabric.IText('万事大吉', {\\n        ...defaultPosition,\\n        fontSize: 40, id: uuid(),\\n      });\\n      this.canvas.c.add(text)\\n      this.canvas.c.setActiveObject(text);\\n},\\naddTriangle() {\\n      const triangle = new this.fabric.Triangle({\\n        top: 100,\\n        left: 100,\\n        width: 100,\\n        height: 100,\\n        fill: '#92706B'\\n      })\\n      this.canvas.c.add(triangle)\\n      this.canvas.c.setActiveObject(triangle);\\n},\\n```\\n导入SVG元素时，可以导入SVG文件或者字符串进行导入，调用fabric的loadSVGFromURL、loadSVGFromString方法进行导入，[详见代码](https://github.com/nihaojob/vue-fabric-editor/blob/main/src/components/importSvg.vue)。\\n\\n\\n### 属性调整\\n![属性调整.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e780a1c7c0414f0896bf80ca69b4a35c~tplv-k3u1fbpfcp-watermark.image?)\\n不同元素的属性会有差异，但通用属性是一致的，如填充颜色、坐标、旋转角度、透明度等，也有很多特定元素的特定属性，如文字的字体属性、图片的滤镜属性等，[详见代码](https://github.com/nihaojob/vue-fabric-editor/blob/main/src/components/attribute.vue)。\\n字体属性可以自定义字体，需要先下载字体后再进行设置，可以通过fontfaceobserver工具库下载指定字体，成功后在设置字体名称。\\n```\\n// 字体加载\\nvar font = new FontFaceObserver(fontName);\\nfont.load(null, 150000).then(() => {\\n    const activeObject = this.canvas.c.getActiveObjects()[0]\\n    activeObject && activeObject.set('fontFamily', fontName);\\n    this.canvas.c.renderAll()\\n    this.$Spin.hide();\\n}).catch((err) => {\\n    this.$Spin.hide();\\n})\\n```\\n\\n\\n\\n### 元素对齐\\n![对齐.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9dd4ffa48d104810b895c82c705701d2~tplv-k3u1fbpfcp-watermark.image?)\\n元素对齐区分单选元素与多选元素，单选元素时只支持相对于画布水平、垂直、水平垂直对齐。\\n```\\n// name为 centerH | centerV | center\\nposition(name){\\n  const activeObject = this.canvas.c.getActiveObject()\\n  if(activeObject){\\n    activeObject[name]()\\n    this.canvas.c.renderAll()\\n  }\\n}\\n```\\n多元素对齐有上下左右对齐、水平、垂直对齐，主要是通过获得最边缘元素的坐标，然后进行计算排序，如顶部对齐代码：\\n```\\nconst activeObject = this.canvas.c.getActiveObject();\\n  if (activeObject && activeObject.type === 'activeSelection') {\\n        const activeSelection = activeObject;\\n        console.log(activeSelection)\\n        const activeObjectTop = -(activeObject.height / 2);\\n        activeSelection.forEachObject(item => {\\n          item.set({\\n                top: activeObjectTop,\\n            });\\n            item.setCoords();\\n            this.canvas.c.renderAll();\\n        });\\n    }\\n}\\n```\\n平均分配会复杂一些，需要计算出边缘与元素间距，再进行设置，[详见代码](https://github.com/nihaojob/vue-fabric-editor/blob/main/src/components/align.vue)。\\n\\n### 其他用法\\n编辑器经常需要给元素进行分组/拆分组合、调整层级、回退、快捷键、画布放大/缩小、导入/导出文件等功能，不再一一罗列，这个小编辑器都已经支持，大家感兴趣的可以看源码。\\n\\n- [组合](https://github.com/nihaojob/vue-fabric-editor/blob/main/src/components/group.vue)\\n- [层级调整](https://github.com/nihaojob/vue-fabric-editor/blob/main/src/components/layer.vue)\\n- [快捷键实现](https://github.com/nihaojob/vue-fabric-editor/blob/main/src/plugin/hotkeys.js)\\n- [画布放大缩小](https://github.com/nihaojob/vue-fabric-editor/blob/main/src/components/zoom.vue)\\n- [导入/导出](https://github.com/nihaojob/vue-fabric-editor/blob/main/src/components/save.vue)\\n\\n\\n### 总结\\n\\nfabric.js的功能很强大，可以很轻松的开发出一个简版的图片编辑器，自定义素材、模板、字体文件；还可以结合数据接口拼接模板生成图片，很轻松的实现定制模板 + 生成图片的功能，比如我的朋友借助我的功能 + 成语接口生成成语图片，在小红书上斩获了八千多的粉丝。\\n\\n最后希望大家能够通过这个项目学习到fabric.js的基础用法，感兴趣的话可以一起维护这款小编辑器，欢迎star。\\n\\nhttps://github.com/nihaojob/vue-fabric-editor\\n\\n\\n"
    }
]