[
    {
        "article_id": "7182171033116344381",
        "cover_image": "",
        "title": "应届生学习Java八个月，offer年薪28W，这一年我经历了什么？",
        "brief": "我叫阿杆，19级本科在读，双非院校，希望和大家交个朋友😋。主修软件工程，学习方向是后端开发，主要语言Java，今年秋招拿到了一份18*16的offer。",
        "user_name": "阿杆",
        "view_count": 9498,
        "collect_count": 72,
        "comment_count": 50,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/de3dfdc0012f9090816782278813f241~300x300.image",
        "category": "代码人生",
        "content": "---\\ntheme: devui-blue\\n---\\n\\n\\n# 自我介绍\\n\\n首页和大家介绍一下我，我叫阿杆（笔名及游戏名🤣），19级本科在读，双非院校，专业是数字媒体技术，但我主修软件工程，学习方向是后端开发，主要语言Java、Python，今年秋招拿到了一份18*16的offer，目前主要活跃于掘金和Github，也在建设自己的微信公众号。\\n\\n和大家分享一下我这一年的经历，也希望在掘金社区和大家交个朋友。\\n\\n# 学习历程\\n\\n## 背景\\n\\n怎么说呢，我自认为大学的前三年还算是学了挺多东西的，主要是：\\n\\n- 用C++写算法题，参加一下蓝桥杯；\\n\\n- 用C# WPF写桌面应用程序，参加省里的物联网技能赛；\\n\\n- 用Python写Nao机器人程序参加省里的机器人高尔夫赛；\\n\\n- 用Python写了个后端程序 “打卡提醒小助手” ，这个程序是给学校催打卡用的，算是小有名气😎；\\n\\n- 也参加过数学建模和数据挖掘分析的比赛。\\n\\n当然，上面参加的比赛基本都拿奖了，这让我骄傲，也让我膨胀。\\n\\n![image-20221228155803779](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/81566fcfdb9142a181443968d456f8ee~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n今年三月份之前，我一直觉得以我的能力，要找个好工作应该是不成问题的，于是我就去看了一些招聘信息，并且投递了简历。那时候我Python是用的最熟的，平时做的也基本都是后端相关的东西，所以找的岗位主要就是Python后端开发。\\n\\n## 现实给了我一记重拳\\n\\n但现实是，我能找到的合适岗位非常少，首先是很少有公司用Python做后端开发，而我的能力符合他们的岗位要求的就更少了😅。\\n\\n后来我把简历发给了一位在阿里的学长，他们当时刚好在招实习生，下面是他给我的邮件回复全文：\\n\\n![image-20221225115718529](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d08dab85e56f45d0bae53d4fc82366a1~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n其中，下面这段话是最让我吃惊的，也算是给了我一记重拳，把我从学校思维的深渊里拉了出来：\\n\\n> 如果你想进入国内一线互联网大厂的开发岗的话，可以直接告诉你，找Python开发实习是基本没有太大希望的，建议多关注看看市场行情、招聘动态，没有哪家公司会用Python作为主要语言搞研发。语言其实也只是小问题，在校生更加看基础是否足够扎实，比如算法、计网、操作系统、数据库等，如果这些能力缺少，建议赶紧恶补起来。\\n\\n\\n## 确定方向\\n\\n我知道这主要是由于我对社会的就业需求不了解所导致的，于是我开始去了解就业市场，去boss直聘上分析岗位需求，大概的看了一下，我发现Java的岗位是真的多👴，跟Python完全不是一个数量级的！\\n\\n我当时就大为震撼，Java这么牛吗？那我大学这几年都没学Java，岂不是血亏😭！再结合当时某个学Java的同学已经拿到实习offer，就搞的我也很想转Java。犹豫了几天后，我最终也确定了要去走Java的路。\\n\\n（*当然，在现在看来，Java不仅是岗位多，求职者也是非常多的，竞争也是很大的，当初做的决定仍然是很草率的*）😅\\n\\n## 学习Java\\n\\n自此，我正式开始学习Java，这时差不多是2022年3月中旬。\\n\\n为了方便回顾我以前做的事情，我会把这些东西都记录在一个Excel表格上，*就像下面截图的这样*，每次开始学习一个新的知识点，我就会记录在这上面，比如 3/8 Linux学习 ，意思是3月8号开始学习Linux，但这个状态不是指这一天，而是持续的，至于持续多久，这我倒是没有记录。\\n\\n![image-20221225151710140](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dab23b22b9b6422d87154c2632b5a477~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n由于学习历程耗时比较长，所以我就不贴截图了，直接整理成表格放在这里：\\n\\n| 日期  |                        工作安排                        | 日期  |         工作安排         |\\n| :---: | :----------------------------------------------------: | :---: | :----------------------: |\\n| 3/18  |                         Maven                          | 3/19  |         JavaWeb          |\\n| 3/22  | 创建[校园博客](https://github.com/stick-i/scblogs)项目 | 3/26  | Spring+SpringMVC+Mybatis |\\n| 3/31  |                       SpringBoot                       |  4/9  |        蓝桥杯省赛        |\\n| 4/12  |                         Minio                          | 4/17  |    spring-boot-admin     |\\n|  5/6  |                    项目部署到Linux                     |  5/9  |     SpringCloud开始      |\\n| 5/10  |                         Nginx                          | 5/16  |          Nacos           |\\n| 5/17  |                     gateway、feign                     | 5/22  |  微服务架构拆分基本成型  |\\n|  6/2  |            微服务架构基本搭建完毕，分库完毕            |  6/3  |        docker学习        |\\n|  6/5  |                        复习四级                        | 6/11  |       英语四级考试       |\\n| 6/14  |                     开始学习Redis                      | 6/18  |        蓝桥杯国赛        |\\n| 6/22  |                        RabbitMQ                        | 6/27  |  自动化部署Jenkins学习   |\\n| 6/30  |                    Docker复习+实操                     |  7/4  |  elasticsearch学习开始   |\\n| 7/10  |               elasticsearch学习基本结束                | 7/14  |       JVM基础知识        |\\n| 7/17  |                  MySQL优化和底层原理                   | 7/18  |  看面经、投简历、刷题等  |\\n| 8/29  |                  入职XXXX公司（实习）                  | 11/14 |      拿到秋招offer       |\\n| 11/30 |               离职XXXX公司、准备四级考试               | 12/10 |       再次四级考试       |\\n\\n所以这差不多就是我今年的学习内容，我的学习资料基本是B站视频，学习路线基本是跟着黑马的走的，课程的话我会多比较几个机构的视频，挑一个自己听的舒服一些的去学。\\n\\n至于为什么我一上来就是学Maven，而不是Java基础？你要相信一个学过C++、C#、Python的人，是没有必要再去学一遍Java基础的🤣。其实我一开始是想直接学Spring的，结果呢？tnnd，IDEA打开之后不晓得咋建项目，而视频里的老师是直接跳过项目创建的😅😅。\\n\\n## 做项目：校园博客\\n\\n我深知，要想学好编程，写代码是必不可少的。\\n\\n**写个大一点的程序，可以让你把所学知识融会贯通，并且在其中遇到的问题，会让你查漏补缺。而这个大一点的程序，也叫项目，我从一开始学Java，就拟好了一个项目，项目名称就叫：校园博客。**\\n\\n项目现在的样子🤣：\\n\\n![image-20221225161844111](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa27dad6a41d45e7960af13a958d825a~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n在我学习的过程中，我是边学东西边写项目的，把所学的知识点转化到自己的项目中，看自己是否已经能够基本的去使用这些知识。\\n\\n一开始做的东西大概率是很烂的，所以我后面也把项目推翻重构过几次，保持对代码的追求，因为项目是自己的，写的好写的坏都是自己技术的体现。所以不要赶进度式的去写，要把自己当做一名艺术家，在打造一件艺术品。\\n\\n> PS：上面这段话纯粹是个人感慨，不一定对哈哈哈哈。\\n\\n对我来说最大的痛点就是没有找到一个靠谱的前端😅，目前项目前端已经停滞很久了，后端倒是一直在更新。而且由于前端代码也需要重构，所以目前甚至没有贡献者愿意加入😅。\\n\\n校园博客GitHub地址：https://github.com/stick-i/scblogs\\n\\n这是我最近一年在github上的贡献，说多不多，说少也不少🤣。\\n\\n![image-20221225162856010](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c499878fb0840528ea0e7980d641812~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n\\n\\n# 求职历程\\n\\n## 海投\\n\\n七月中旬我就开始找工作了，当时找的是实习岗位，但是谁知道呢，暑期实习三四月份就开始招人了，七月都招聘结束了，我直接懵逼😅。\\n\\n当然也偶有几家公司是仍然在招实习生的，我参加了其中一家公司的面试，但由于我轻视了背八股的重要性，于是不出意外的挂了，哈哈哈🤣🤣。\\n\\n求职的过程中我也会用一个Excel表格来记录，包括时间、状态、公司、岗位，以及个人认为的重要程度等等，大概长这样：\\n\\n![image-20221228162411233](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/023d52c44645498fbec43440513baa7b~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n今年是不是互联网寒冬我不知道，但就我找工作来说，确实非常困难。下面的表格是我的秋招统计：\\n\\n|         状态         | 数量 |\\n| :------------------: | :--: |\\n|         投递         | 125  |\\n|         笔试         |  33  |\\n|         一面         |  10  |\\n|         二面         |  6   |\\n| 三面（不是每家都有） |  1   |\\n|         HR面         |  3   |\\n|        offer         |  1   |\\n\\n我刚开始投的时候还会看看公司是不是自己有意向的，后来发现压根没有公司理人，就直接海投了😅。\\n\\n投递简历的过程真的是非常痛苦的，填了无数遍个人信息、项目经历、工作经历等，只有少数公司的招聘网站对在线简历的填写比较友好。\\n\\n**我也更推荐应届生在公司的官网上进行投递，大多数公司都是支持官网投递的。**\\n\\n## 实习\\n\\n八月底，同学引荐我去面试一家本地的金融公司，他说公司现在刚好在招后端实习生，要我去试试。\\n\\n我想着反正现在还没找到工作，而且我也没有实习经验，倒不如去这里工作几个月增加一下我的实习经历。\\n\\n于是经过了一下午的面试后，我成功入职了这家公司，是那种比较普通的实习，一个月三千，以Java后端开发实习生的身份进去的。\\n\\n实习期间，我一边在公司工作，同时也仍然在投简历，笔试、面试。\\n\\n刚进公司确实可以接触到很多新东西，但我感觉对于我技术上的帮助并不是特别大，并不如自学来得快。只能说公司毕竟是招我进去干活的，而不是专门学技术的🤣。\\n\\n不出意外的，实习满三个月，我便离职了。这下我也算是有实习经验了，之后再找工作也能轻松些了吧👴。\\n\\n> 有些同学进不去或者找不到大厂实习，但是又看不上这种工资低并且工作内容杂的实习。\\n> \\n> 对此，我的建议是：如果你还没有一段两三个月以上的实习经历，并且暂时没有进大厂实习的希望，那最好还是抓紧时间找个小公司先实习着。\\n> \\n> 虽然不一定能让你收获到很多东西，但可以让你在简历上多一段有用的实习经历，*很多公司看我是双非本科，又没有实习经历，就直接把我的简历给刷掉了，大家懂吧*😅。\\n> \\n> 如果你已经有一段三个月以上的实习经历了，那我觉得你没有必要再去小公司实习了，如果时间充裕的话，就去冲大厂实习吧！如果马上就要秋招或者春招了，那就好好准备，别去浪费自己的时间了！\\n> \\n> PS：这是给非大四同学的一点建议，最好结合文章末尾的【给大一二三同学的一些建议】一起了解。\\n\\n## 收获offer\\n\\n十一月初，在经历了几轮面试后，我通过了面试官们的考核，拿到了我的秋招offer，还是比较满意的🤣（除了工作地点）。\\n\\n![image-20221228190627833](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/49f54c5406fe4194be5b66ab7c88222b~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n怎么说呢，我从七月中旬就开始找工作，收到offer已经是十一月了，这么长的一段时间，真的很难不让人想放弃，但还好我坚持下来了，很庆幸🤧。希望大家也能够坚持！\\n\\n# 创作历程\\n\\n2022年8月24日，我加入了掘金，这是我的个人主页 -> [阿杆 的个人主页 - 掘金 (juejin.cn)](https://juejin.cn/user/4182956056773160/posts)。\\n\\n到目前为止，我总文章数为34篇，下面是我的后台数据，感谢各位JY们的支持和肯定🥰🥰。\\n\\n![image-20221228154002271](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df6b5c7c973f4859ac090e47d3b6ced0~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n## 日新计划\\n\\n十月份我参加了日新计划，然后把我以前写的文章搬了过来🤣，获得了一箱子的奖品，里面还包括罗技G910键盘，非常nice。\\n\\n![1672209653733](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36cd47c46db844979b6b32586c9968f7~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n## 数据库征文TOP1\\n\\n十一月份我参加了数据库技术征文，花了大概两周时间，研究并且写下了《[🔥我说MySQL每张表最好不超过2000万数据，面试官让我回去等通知？](https://juejin.cn/post/7165689453124517896)》一文，很荣幸，获得了本场技术征文TOP1😎 [开奖公示](https://juejin.cn/post/7175026553842040893/)。\\n\\n![image-20221228143551601](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5ad29fc299a4c93bc381b88b13bc1ba~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n奖品是一台VR和一张证书👴，还是很香的。\\n\\n![1672209653738](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/15b9737c55b04a18aea1022e51b642de~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n## 年度人气创作者\\n\\n我也参加了年度人气创作者的打榜，感谢各位朋友连续九天帮我投票，让我获得了2022年度人气作者第62名，排名链接：https://rank.juejin.cn/rank/2022\\n\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13ff24347e9a410c8c1df5bee740a25f~tplv-k3u1fbpfcp-watermark.image?)\\n\\n![鞠躬](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/44b892bef5f649d8a6240eb6c75ed45f~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n# 给大一二三同学的一些建议\\n\\n我认为我前期最大的错误，就是学的杂，而不精。\\n\\n其次就是没有经验，不知道要去准备什么暑期实习，对工作就业没有了解，不知道什么时候该去找工作。\\n\\n所以我根据个人所了解的，给准备就业的大一大二大三同学提出一些建议：\\n\\n1. 尽早确定方向。如果你确定要就业的话，你将来想做什么工作、去什么行业？早点确定，然后朝着这个方向，去网上找个学习路线，照着路线学个大概。\\n\\n2. 大三的那个寒假，给自己准备一份像样的简历，然后看看八股，刷刷算法。看八股不是一件无意义的事情，你看在八股的时候，也会学到很多东西的。\\n\\n   如果你找不到喜欢的简历模板，可以看看我的这篇文章，可能对你有帮助👉[关于如何使用 Markdown 写出一份漂亮的简历！](https://juejin.cn/post/7152386844984868878)👈\\n\\n3. 大三下学期大概三四月份就可以去找暑期实习的招聘了。各公司的官网都会发布招聘信息，寻找并选择自己的岗位进行投递，尽量多投一些，海投，这样可以让自己多一些面试经验。\\n\\n4. 实习期间多做记录，尤其是对一些有技术亮点的部分，可以写篇博客进行总结。将来把他们写到自己的简历里，面试官很有可能会对你进行提问。\\n\\n5. 大四上学期，大概八九月份就该开始准备秋招了，如果此时你有三个月及以上的工作经验，那会对你有很大的帮助。\\n\\n6. 学习的过程中可以尝试着去写一些博客，把你项目中的技术亮点，或者是你的学习总结，写成博客。这样可以加深你对知识的记忆和理解，且当你有了一定数量的文章后，你可以把自己的博客主页链接贴到简历里。\\n\\n7. 永远不要等准备好了才去开始，时间不会等你，工作也不会自己找上门来。\\n\\n8. 求职的过程是辛苦的，但不要轻易放弃，你的未来值得你去奋斗。\\n\\n# 最后\\n\\n祝愿大家都能找到自己心仪的工作，早日上岸🧐。\\n\\n如果你有问题想问我，或者想和我进行交流的话，可以在掘金私聊我，我会拉你进交流群噢👨‍💻。\\n\\n「回顾2022，展望2023，我正在参与[2022年终总结征文大赛活动](https://juejin.cn/post/7172462429929111559 \\\"https://juejin.cn/post/7172462429929111559\\\")」",
        "tags": [
            "面试",
            "程序员",
            "后端"
        ]
    },
    {
        "article_id": "7155284391596392461",
        "cover_image": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d63954caca84d8c90b7c351463e6b44~tplv-k3u1fbpfcp-watermark.image?",
        "title": "我用canvas带你看一场流星雨",
        "brief": "今天，我决定用canvas为大家带来一场流星雨视觉盛宴。昙花和流星瞬间之美令我无法忘怀，大自然神奇的造物者给了我们许多的美，不论瞬间的还是永恒的，我们都要用真心去欣赏去品味。",
        "user_name": "前端南玖",
        "view_count": 6665,
        "collect_count": 116,
        "comment_count": 19,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/3afd4a350eac1690e6e0165f081456d8~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: fancy\\nhighlight: atelier-dune-dark\\n---\\n## 前言\\n\\n最近总是梦见一些小时候的故事，印象最深刻的就是夏天坐在屋顶上，看着满天的繁星，一颗，两颗，三颗...不由自主地开始了数星星的过程。不经意间，一颗流星划过夜间，虽然只是转瞬即逝，但它似乎比夜空中的其它繁星更吸引着我。听老人说，看见流星的时候许愿，愿望是可以实现的，此时早已把数星星抛之脑后，开始期待着下一颗流星的出现。但是那天晚上，流星再也没有出现，这也成了自己小时候的一个遗憾。\\n\\n今天，我决定用canvas为大家带来一场流星雨视觉盛宴。\\n\\n\\n![meteor.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db71b012664448989271e64d8d72dcd4~tplv-k3u1fbpfcp-watermark.image?)\\n\\n**如果这篇文章有帮助到你，❤️关注+点赞❤️鼓励一下作者，文章公众号首发，关注 `前端南玖` 第一时间获取最新文章～**\\n\\n## 需求分析\\n\\n首先我们需要的元素有：夜空、满天繁星、流星雨。\\n\\n**满天繁星：** 这个其实就是画上一个个点，然后不断的通过颜色交替，营造出一种星星闪烁的意境。\\n\\n**流星雨：** 流星处于他自己的运动轨迹之中，当前的位置最亮，轮廓最清晰，而之前划过的地方离当前位置轨迹距离越远就越暗淡越模糊，其实它就是一个渐变的过程，恰巧canvas有方法可以创建一个沿参数坐标指定的直线的渐变。然后**让它从右上向左下移动**，这样就能营造一种流星雨的效果，同时实现动画的循环。\\n\\nOK，需求分析结束，准备动手开干～\\n\\n![ceeb653ely1g2ipggyei2g205k05k4kl.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e9bc1b588bd04cc9abc6d00b7c5057ca~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## 实现过程\\n\\n### 1.绘制满天繁星\\n\\n```js\\n//创建一个星星对象\\nclass Star {\\n  constructor() {\\n    this.x = windowWidth * Math.random(); //横坐标\\n    this.y = 5000 * Math.random(); //纵坐标\\n    this.text = \\\".\\\"; //文本\\n    this.color = \\\"white\\\"; //颜色\\n  }\\n  //初始化\\n  init() {\\n    this.getColor();\\n  }\\n  //绘制\\n  draw() {\\n    context.fillStyle = this.color;\\n    context.fillText(this.text, this.x, this.y);\\n  }\\n}\\n\\n//画星星\\nfor (let i = 0; i < starCount; i++) {\\n  let star = new Star();\\n  star.init();\\n  star.draw();\\n  arr.push(star);\\n}\\n```\\n\\n来看下此时的效果：\\n\\n![stars.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c8f8666ca994835a5efd0f31267a3e9~tplv-k3u1fbpfcp-watermark.image?)\\n\\n夜空中的满天繁星现在是有了，但是缺乏一点意境，我们得想办法让这些繁星都闪烁起来。\\n\\n### 2.满天繁星闪起来\\n\\n```js\\n//创建一个星星对象\\nclass Star {\\n  constructor() {\\n    this.x = windowWidth * Math.random(); //横坐标\\n    this.y = 5000 * Math.random(); //纵坐标\\n    this.text = \\\".\\\"; //文本\\n    this.color = \\\"white\\\"; //颜色\\n  }\\n\\t// 获取随机颜色\\n  getColor() {\\n    let _r = Math.random();\\n    if (_r < 0.5) {\\n      this.color = \\\"#333\\\";\\n    } else {\\n      this.color = \\\"white\\\";\\n    }\\n  }\\n\\n  //初始化\\n  init() {\\n    this.getColor();\\n  }\\n  //绘制\\n  draw() {\\n    context.fillStyle = this.color;\\n    context.fillText(this.text, this.x, this.y);\\n  }\\n}\\n\\n//画星星\\nfor (let i = 0; i < starCount; i++) {\\n  let star = new Star();\\n  star.init();\\n  star.draw();\\n  arr.push(star);\\n}\\n\\n//繁星闪起来\\nlet t1\\nfunction playStars() {\\n  for (let n = 0; n < starCount; n++) {\\n    arr[n].getColor();\\n    arr[n].draw();\\n  }\\n  t1 = requestAnimationFrame(playStars);\\n}\\n```\\n\\n繁星闪烁的元素就在于这个`getColor`方法，通过不断地切换星星的颜色，来达到星星闪烁的效果。\\n\\n再来看看这时的效果：\\n\\n\\n![星星闪烁.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b7db4fa60ce04ef59f54bb2205e1c0d4~tplv-k3u1fbpfcp-watermark.image?)\\n\\n此刻的自己就可以开始数星星了，一颗，两颗，三颗...\\n\\n### 3.绘制流星\\n\\n> 简单点理解，流星其实就是一条渐变的线段，当前的位置最亮，轮廓最清晰，而之前划过的地方离当前位置轨迹距离越远就越暗淡越模糊。\\n\\n这里的关键API是`createLinearGradient`，用于创建一个沿参数坐标指定的直线的渐变。\\n\\n\\n![mdn-canvas-lineargradient.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aeaf9c8565e54953b61f4c3e2a01fba7~tplv-k3u1fbpfcp-watermark.image?)\\n\\n**语法：**\\n\\n> CanvasGradient ctx.createLinearGradient(x0, y0, x1, y1);\\n\\n- x0：起点的 x 轴坐标。\\n- y0：起点的 y 轴坐标。\\n- x1：终点的 x 轴坐标。\\n- y1：终点的 y 轴坐标。\\n\\n使用`createLinearGradient()` 方法初始化一个线性渐变。在这个线性渐变中添加三种颜色，达到一种渐变的效果来模拟出流星划过夜空的状态。\\n\\n```js\\n/**绘制流星**/\\n  draw() {\\n    //绘制一个流星的函数\\n    context.save();\\n    context.beginPath();\\n    context.lineWidth = 1; //宽度\\n    context.globalAlpha = this.alpha; //设置透明度\\n    //创建横向渐变颜色,起点坐标至终点坐标\\n    let line = context.createLinearGradient(\\n      this.x,\\n      this.y,\\n      this.x + this.width,\\n      this.y - this.height\\n    );\\n    //分段设置颜色\\n    line.addColorStop(0, \\\"white\\\");\\n    line.addColorStop(0.3, this.color1);\\n    line.addColorStop(0.6, this.color2);\\n    context.strokeStyle = line;\\n    //起点\\n    context.moveTo(this.x, this.y);\\n    //终点\\n    context.lineTo(this.x + this.width, this.y - this.height);\\n    context.closePath();\\n    context.stroke();\\n    context.restore();\\n  }\\n```\\n\\n现在我们来看一看当年的那个流星：\\n\\n\\n![流星.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f7297b9241b44fca0b44c088eb51a96~tplv-k3u1fbpfcp-watermark.image?)\\n\\n### 4.流星划过夜空\\n\\n流星有了，现在我们得想办法让它动起来。这里其实就是通过不断地计算位置来达到流星动起来的效果。\\n\\n```js\\nmove() {\\n    //清空流星像素\\n    let x = this.x + this.width - this.offset_x;\\n    let y = this.y - this.height;\\n    context.clearRect(x - 3, y - 3, this.offset_x + 5, this.offset_y + 5);\\n    //重新计算位置，往左下移动\\n    this.countPos();\\n    //透明度增加\\n    this.alpha -= 0.002;\\n    //重绘\\n    this.draw();\\n  }\\n```\\n\\n![流星.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d4dcbb0e7cc494aa267d77de800c986~tplv-k3u1fbpfcp-watermark.image?)\\n\\n现在，我们就可以看到当年的那颗流星了，是不是很激动。稍安勿躁，为了弥补当年的遗憾，这里决定来一场从未真实见过的流星雨。\\n\\n### 5.流星雨\\n\\n写到这里，实现流星雨其实就很简单了，我们只需要再多生成一些流星，为它们各自分配不同的坐标即可。\\n\\n```js\\nlet t2\\n// 创建流星雨对象\\nclass MeteorRain {\\n  constructor() {\\n    this.x = -1;\\n    this.y = -1;\\n    this.length = -1; //长度\\n    this.angle = 30; //倾斜角度\\n    this.width = -1; //宽度\\n    this.height = -1; //高度\\n    this.speed = 1; //速度\\n    this.offset_x = -1; //横轴移动偏移量\\n    this.offset_y = -1; //纵轴移动偏移量\\n    this.alpha = 1; //透明度\\n    this.color1 = \\\"\\\"; //流星的色彩\\n    this.color2 = \\\"\\\"; //流星的色彩\\n  }\\n  init() {\\n    //初始化\\n    this.getPos();\\n    this.alpha = 1; //透明度\\n    this.getRandomColor();\\n    //最小长度，最大长度\\n    let x = Math.random() * 80 + 150;\\n    this.length = Math.ceil(x);\\n    x = Math.random() + 0.5;\\n    this.speed = Math.ceil(x); //流星的速度\\n    let cos = Math.cos((this.angle * 3.14) / 180);\\n    let sin = Math.sin((this.angle * 3.14) / 180);\\n    this.width = this.length * cos;\\n    this.height = this.length * sin;\\n    this.offset_x = this.speed * cos;\\n    this.offset_y = this.speed * sin;\\n  }\\n  /**获取随机颜色函数**/\\n  getRandomColor() {\\n    let a = Math.ceil(255 - 240 * Math.random());\\n    //中段颜色\\n    this.color1 = \\\"rgba(\\\" + a + \\\",\\\" + a + \\\",\\\" + a + \\\",1)\\\";\\n    //结束颜色\\n    this.color2 = \\\"black\\\";\\n  }\\n  /**重新计算流星坐标的函数**/\\n  countPos() {\\n    //\\n    //往左下移动,x减少，y增加\\n    this.x = this.x - this.offset_x;\\n    this.y = this.y + this.offset_y;\\n  }\\n  /**获取随机坐标的函数**/\\n  getPos() {\\n    //\\n    //横坐标\\n    this.x = Math.random() * window.innerWidth; //窗口高度\\n    //纵坐标\\n    this.y = Math.random() * window.innerHeight; //窗口宽度\\n  }\\n  /**绘制流星**/\\n  draw() {\\n    //绘制一个流星的函数\\n    context.save();\\n    context.beginPath();\\n    context.lineWidth = 1; //宽度\\n    context.globalAlpha = this.alpha; //设置透明度\\n    //创建横向渐变颜色,起点坐标至终点坐标\\n    let line = context.createLinearGradient(\\n      this.x,\\n      this.y,\\n      this.x + this.width,\\n      this.y - this.height\\n    );\\n    //分段设置颜色\\n    line.addColorStop(0, \\\"white\\\");\\n    line.addColorStop(0.3, this.color1);\\n    line.addColorStop(0.6, this.color2);\\n    context.strokeStyle = line;\\n    //起点\\n    context.moveTo(this.x, this.y);\\n    //终点\\n    context.lineTo(this.x + this.width, this.y - this.height);\\n    context.closePath();\\n    context.stroke();\\n    context.restore();\\n  }\\n  move() {\\n    //清空流星像素\\n    let x = this.x + this.width - this.offset_x;\\n    let y = this.y - this.height;\\n    context.clearRect(x - 3, y - 3, this.offset_x + 5, this.offset_y + 5);\\n    //重新计算位置，往左下移动\\n    this.countPos();\\n    //透明度增加\\n    this.alpha -= 0.002;\\n    //重绘\\n    this.draw();\\n  }\\n}\\n\\n//绘制流星\\nfunction playRains() {\\n  for (let n = 0; n < rainCount; n++) {\\n    // console.log(rains, \\\"--\\\");\\n    let rain = rains[n];\\n    rain.move(); //移动\\n    if (rain.y > window.innerHeight) {\\n      //超出界限后重来\\n      context.clearRect(rain.x, rain.y - rain.height, rain.width, rain.height);\\n      rains[n] = new MeteorRain();\\n      rains[n].init();\\n    }\\n  }\\n  t2 = requestAnimationFrame(playRains);\\n}\\n```\\n![流星雨.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f49b281ed173471f98361feeb5e1ab18~tplv-k3u1fbpfcp-watermark.image?)\\n\\n### 6.merge视觉盛宴\\n\\n流星极短暂的星星是也，它不像恒星和行星那般耀眼，却用短暂的生命，划破夜空，用瞬间潇洒的弧线留住美丽的光辉。昙花和流星瞬间之美令我无法忘怀，大自然神奇的造物者给了我们许多的美，不论瞬间的还是永恒的，我们都要用真心去欣赏去品味。\\n\\n通过合并前面五个步骤，我们就能够一睹这流星刹那间的交错，而后瞬间就穿透为永恒，只是一刻用生命幻化的美。\\n\\n\\n![meteor.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5d652044b4874d4181bfea9549a4ec72~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## 最后\\n\\n今天的视觉盛宴就到这里了，想要查看源码的同学公众号回复**流星雨**～\\n> 原文首发地址[点这里](https://mp.weixin.qq.com/s/watoGsF-_TkX4-buASJwDg)，欢迎大家关注公众号 **「前端南玖」**，如果你想进前端交流群一起学习，[请点这里](https://juejin.cn/pin/7072217320155775007)\\n\\n**我是南玖，我们下期见！！！**\\n",
        "tags": [
            "前端",
            "JavaScript",
            "Canvas"
        ]
    },
    {
        "article_id": "7156964464294002718",
        "cover_image": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/04b1de7de1844558b5be8a7f78fd165f~tplv-k3u1fbpfcp-watermark.image?",
        "title": "vue 日历 组件",
        "brief": "那位大佬来批评一下我的不足，不甚感激。不用任何第三方库，只基于vue2实现一个日历组件。已拆分代码。2022-12-27，效果图",
        "user_name": "华菱下水道二组_历飞宇",
        "view_count": 9454,
        "collect_count": 94,
        "comment_count": 40,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/bd1c7caabe140167819b50b7914e8b1e~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: nico\\nhighlight: lioshi\\n---\\n>  不用任何第三方库，只基于vue2实现一个日历组件，末尾附上我的代码，单文件，代码没有抽取，有点长。哪位大佬批评指正一下，末尾有效果图\\n\\n-   样式是类似于window10日历\\n-   支持控制周一还是周日在第一列\\n-   支持鼠标滑动切换\\n-   支持单选，拖动鼠标多选，范围选择\\n-   支持年月日选择切换\\n-   支持传入选中数据\\n-   支持隐藏非本月日期\\n##  QCalendar.scss\\n\\n```css\\n.Q-calendar-change-enter-active,\\n.Q-calendar-change-leave-active {\\n  transition: opacity 0.5s;\\n}\\n\\n.Q-calendar-change-enter,\\n.Q-calendar-change-leave-to\\n  {\\n  opacity: 0;\\n}\\n\\n.Q-calendar {\\n  width: 100%;\\n  height: 100%;\\n  margin: 0 auto;\\n  overflow: hidden;\\n  background-color: #ffffff;\\n  color: #000;\\n  user-select: none;\\n  border: 1px solid #4152b3;\\n\\n  .Q-calendar-title {\\n    height: 50px;\\n    width: 100%;\\n    box-sizing: border-box;\\n    display: flex;\\n    justify-content: space-between;\\n\\n    div {\\n      align-self: center;\\n    }\\n\\n    .Q-calendar-button,\\n    .top {\\n      align-self: center;\\n    }\\n\\n    .Q-calendar-title-box {\\n      width: calc((100% / 7) * 2);\\n      display: flex;\\n      justify-content: space-around;\\n      cursor: default;\\n\\n      .Q-calendar-title-box-text {\\n        width: 50%;\\n        text-align: center;\\n        align-self: center;\\n      }\\n      .Q-calendar-title-box-text:hover {\\n        color: #4152b3;\\n        font-weight: 700;\\n      }\\n    }\\n    .Q-calendar-title-box-padding{\\n      padding-left: 18px;\\n    }\\n    .Q-calendar-title-box-center{\\n      margin: 0 auto;\\n      font-weight: 700\\n    }\\n  }\\n  .Q-calendar-day {\\n    height: calc(100% - 50px);\\n    /* 周末 */\\n    .Q-calendar-week {\\n      display: flex;\\n      justify-content: inherit;\\n      cursor: default;\\n\\n      p {\\n        display: flex;\\n        justify-content: center;\\n        width: calc(100% / 7);\\n        box-sizing: border-box;\\n      }\\n    }\\n    /* 日历内容 */\\n    .Q-calendar-box {\\n      display: flex;\\n      justify-content: inherit;\\n      flex-wrap: wrap;\\n      width: 100%;\\n      height: 80%;\\n\\n      div:hover {\\n        color: yellowgreen;\\n        font-weight: 700;\\n      }\\n\\n      .Q-calendar-current-month {\\n        box-sizing: border-box;\\n        cursor: default;\\n\\n      }\\n\\n      .Q-calendar-current-month:hover {\\n        color: #4152b3;\\n        font-weight: 700;\\n        font-size: 20px;\\n      }\\n\\n      div {\\n        display: flex;\\n        justify-content: center;\\n        width: calc(100% / 7);\\n        height: calc(100% / 7);\\n\\n        span {\\n          margin: auto;\\n        }\\n      }\\n\\n      p {\\n        display: flex;\\n        justify-content: center;\\n        width: calc(100% / 7);\\n      }\\n    }\\n  }\\n\\n  .Q-calendar-years {\\n    height: calc(100% - 50px);\\n\\n    .Q-calendar-years-box {\\n      // border: 1px solid pink;\\n      display: flex;\\n      justify-content: inherit;\\n      flex-wrap: wrap;\\n      height: 98%;\\n\\n      div {\\n        display: flex;\\n        box-sizing: border-box;\\n        justify-content: center;\\n        width: calc(100% / 4);\\n        height: calc(100% / 4);\\n\\n        span {\\n          margin: auto;\\n        }\\n      }\\n\\n      div:hover {\\n        font-weight: 700;\\n        color: yellowgreen;\\n      }\\n    }\\n  }\\n}\\n\\n/* //非本月时间内，或非本年内 */\\n.Q-calendar-surplus {\\n  color: #898989;\\n}\\n\\n.nowCss {\\n  // border:1px solid pink;\\n  background: #f1f3f4;\\n  color: #40b8ff;\\n}\\n\\n.Q-calendar-checked {\\n  span {\\n    color: var(--Q-calendar-color);\\n    background-color: var(--Q-calendar-background-color);\\n    border-radius: 10px;\\n    width: 50%;\\n    height: 50%;\\n    text-align: center;\\n    line-height: 24px;\\n  }\\n}\\n\\n```\\n## getRangeDay.js\\n\\n```js\\nimport { parseTime } from './formatTime'\\n\\nexport function getRangeDay(startDate, endDate) {\\n    const result = [];\\n    const db = new Date();\\n    db.setUTCFullYear(startDate.year, startDate.month - 1, startDate.day);\\n    const de = new Date();\\n    de.setUTCFullYear(endDate.year, endDate.month - 1, endDate.day);\\n    let smallDate\\n    let bigDate\\n    if (db.getTime() > de.getTime()) {\\n      smallDate = de.getTime()\\n      bigDate = db.getTime()\\n    } else {\\n      smallDate = db.getTime()\\n      bigDate = de.getTime()\\n    }\\n    for (let k = smallDate; k <= bigDate;) {\\n      result.push({\\n        year: parseTime(k, \\\"{y}\\\"),\\n        month: parseTime(k, \\\"{m}\\\").length===1?('0'+parseTime(k, \\\"{m}\\\")):parseTime(k, \\\"{m}\\\"),\\n        day: parseTime(k, \\\"{d}\\\").length===1?('0'+parseTime(k, \\\"{d}\\\")):parseTime(k, \\\"{d}\\\"),\\n        checked: true\\n      });\\n      k = k + 24 * 60 * 60 * 1000;\\n    }\\n    return result;\\n  }\\n```\\n\\n## formatTime.js\\n\\n\\n```js\\nexport function parseTime(time, pattern) {\\n    if (arguments.length === 0 || !time) return null;\\n    const format = pattern || '{y}-{m}-{d} {h}:{i}:{s}';\\n    let date;\\n    if (typeof time === 'object') {\\n      date = time;\\n    } else {\\n      if ((typeof time === 'string') && (/^[0-9]+$/.test(time))) {\\n        time = parseInt(time);\\n      } else if (typeof time === 'string') {\\n        time = time.replace(new RegExp(/-/gm), '/');\\n      }\\n      if ((typeof time === 'number') && (time.toString().length === 10)) {\\n        time = time * 1000;\\n      }\\n      date = new Date(time);\\n    }\\n    const formatObj = {\\n      y: date.getFullYear(),\\n      m: date.getMonth() + 1,\\n      d: date.getDate(),\\n      h: date.getHours(),\\n      i: date.getMinutes(),\\n      s: date.getSeconds(),\\n      a: date.getDay(),\\n    };\\n    return format.replace(/{(y|m|d|h|i|s|a)+}/g, (result, key) => {\\n      // @ts-ignore\\n      let value = formatObj[key];\\n      // Note: getDay() returns 0 on Sundayday\\n      if (key === 'a') {\\n        return ['日', '一', '二', '三', '四', '五', '六'][value];\\n      }\\n      if (result.length > 0 && value < 10) {\\n        value = '0' + value;\\n      }\\n      return value || 0;\\n    });\\n  }\\n```\\n\\n##  QCalendar.vue\\n\\n```js\\n<template>\\n  <!-- 外部 -->\\n  <div class=\\\"Q-calendar\\\" @mouseup.stop=\\\"onMouseUp\\\" @mouseleave.stop=\\\"onMouseleave\\\">\\n    <!-- 头部 -->\\n    <div class=\\\"Q-calendar-title\\\" v-if=\\\"hideTitle\\\">\\n      <div class=\\\"Q-calendar-title-box Q-calendar-title-box-padding\\\">\\n        <div @click=\\\"onClickYears\\\" class=\\\"Q-calendar-title-box-text\\\">\\n          {{ this.currentYear }}年\\n        </div>\\n        <div @click=\\\"onClickMonth\\\" class=\\\"Q-calendar-title-box-text\\\">\\n          {{ this.currentMonth }}月\\n        </div>\\n        <!-- <div>{{this.currentDay}}号</div> -->\\n      </div>\\n      <slot name=\\\"mkCalendarHeaderSlot\\\"></slot>\\n      <div class=\\\"Q-calendar-title-box\\\" v-if=\\\"isSwitch\\\">\\n        <div class=\\\"Q-calendar-title-box-text\\\" @click=\\\"onClickUp\\\">上</div>\\n        <div class=\\\"Q-calendar-title-box-text\\\" @click=\\\"onClickDown\\\">下</div>\\n      </div>\\n    </div>\\n    <div v-else class=\\\"Q-calendar-title\\\">\\n      <div class=\\\"Q-calendar-title-box Q-calendar-title-box-center\\\">\\n        <div class=\\\"Q-calendar-title-box-text\\\">{{ this.currentYear }}年</div>\\n        <div class=\\\"Q-calendar-title-box-text\\\">{{ this.currentMonth }}月</div>\\n      </div>\\n    </div>\\n    <!-- 日历 -->\\n    <transition name=\\\"Q-calendar-change\\\">\\n      <div class=\\\"Q-calendar-day\\\" v-if=\\\"hide === 1\\\" @mousewheel=\\\"onMousewheel\\\">\\n        <!-- 周一到周日 -->\\n        <div class=\\\"Q-calendar-week\\\">\\n          <p v-for=\\\"item in isMonday ? weekSort.Monday : weekSort.Sunday\\\" :key=\\\"item\\\">{{ item }}</p>\\n        </div>\\n        <div class=\\\"Q-calendar-box\\\">\\n          <!-- 上个月剩余天数 -->\\n          <div class=\\\"Q-calendar-surplus\\\" v-for=\\\"item in lastMonthDays\\\" :key=\\\"'dayLast' + item\\\">\\n            <span v-show=\\\"isOtherDate\\\"> {{ item }}</span>\\n          </div>\\n          <!-- 当前月份天数 -->\\n          <div v-for=\\\"item in currentMonthDays\\\" :key=\\\"'dayCur' + item.day\\\" class=\\\"Q-calendar-current-month\\\"\\n            :style=\\\"cssProps\\\" @click=\\\"onChangeDay(item)\\\" :class=\\\"{\\n              'Q-calendar-checked': item.checked,\\n              nowCss:\\n              new Date().getFullYear()+'' === item.year &&\\n              (new Date().getMonth() + 1)+'' === item.month &&\\n              new Date().getDate()+'' === item.day,\\n            }\\\" @mouseover=\\\"dragDay(item)\\\" @mousedown=\\\"onMouseDown(item)\\\">\\n            <span> {{ item.day}}</span>\\n          </div>\\n          <!-- 下月余出 -->\\n          <div class=\\\"Q-calendar-surplus\\\" v-for=\\\"item in this.nextMonth()\\\" :key=\\\"'dayNext' + item\\\">\\n            <span v-show=\\\"isOtherDate\\\">{{ item }}</span>\\n          </div>\\n        </div>\\n      </div>\\n    </transition>\\n    <!-- 月 -->\\n    <transition name=\\\"Q-calendar-change\\\">\\n      <div class=\\\"Q-calendar-years\\\" v-if=\\\"hide === 2\\\" @mousewheel=\\\"onMousewheel\\\">\\n        <div class=\\\"Q-calendar-years-box\\\">\\n          <div v-for=\\\"item in clickMonth\\\" :key=\\\"'monthCur' + item.value\\\" @click=\\\"onChangeMonth(item)\\\" :class=\\\"{\\n            nowCss: isNowYear && new Date().getMonth() + 1 === item.value,\\n          }\\\">\\n            <span>{{ item.key }}</span>\\n          </div>\\n          <div class=\\\"Q-calendar-surplus\\\" v-for=\\\"item in lastMonth\\\" :key=\\\"'monthNext' + item\\\">\\n            <span>{{ item }}</span>\\n          </div>\\n        </div>\\n      </div>\\n    </transition>\\n    <!-- 年 -->\\n    <transition name=\\\"Q-calendar-change\\\">\\n      <div class=\\\"Q-calendar-years Q-calendar-year\\\" v-if=\\\"hide === 3\\\" @mousewheel=\\\"onMousewheel\\\">\\n        <div class=\\\"Q-calendar-years-box\\\">\\n          <div class=\\\"Q-calendar-surplus\\\" v-for=\\\"item in lastYear\\\" :key=\\\"'yearLast' + item\\\">\\n            <span>{{ item }}</span>\\n          </div>\\n          <div v-for=\\\"item in thisYear\\\" :key=\\\"'yearCur' + item\\\" @click=\\\"onChangeYear\\\"\\n            :class=\\\"{ nowCss: new Date().getFullYear() === item }\\\">\\n            <span>{{ item }}</span>\\n          </div>\\n        </div>\\n      </div>\\n    </transition>\\n  </div>\\n</template>\\n<script>\\n/**\\n * 日历组件\\n * @description\\n * @property {Boolean}        isOtherDate                    false              是否展示非本月份的日期\\n * @property {Boolean}        hideTitle                      true               是否展示title\\n * @property {Boolean}        multiSelect                    false              是否开启摁下鼠标进行多选\\n * @property {String}         SelectedBackgroundColor        \\\"#4152b3\\\"          选中的背景色\\n * @property {String}         SelectedTextColor              \\\"#ffffff\\\"          选中的文字色\\n * @property {Boolean}        isMonday                       true               是否从周一在开头\\n * @property {Number}         selectType                     1                  单选1，多选2，范围选3\\n * @property {Array}          selectList                     []                 选中数据的数组\\n * @property {Boolean}        isSwitch                       true               需要切换按钮传入true \\n *\\n */\\n//  import { parseTime } from \\\"./utils/formatTime\\\";\\nimport { getRangeDay } from \\\"./utils/getRangeDay\\\";\\nexport default {\\n  name: \\\"QCalendar\\\",\\n  props: {\\n    isOtherDate: {\\n      type: Boolean,\\n      default: false,\\n    },\\n    hideTitle: {\\n      type: Boolean,\\n      default: true,\\n    },\\n    multiSelect: {\\n      type: Boolean,\\n      default: false,\\n    },\\n    SelectedBackgroundColor: {\\n      type: String,\\n      default: \\\"#4152b3\\\",\\n    },\\n    SelectedTextColor: {\\n      type: String,\\n      default: \\\"#ffffff\\\",\\n    },\\n    isMonday: {\\n      type: Boolean,\\n      default: true,\\n    },\\n    selectType: {\\n      type: Number,\\n      default: 1,\\n    },\\n    selectList: {\\n      type: Array,\\n      default: () => []\\n    },\\n    isSwitch: {\\n      type: Boolean,\\n      default: true,\\n    }\\n  },\\n  data() {\\n    return {\\n      isMouseDown: false,\\n      arr: this.selectList,\\n      isNowYear: true,\\n      isNowMOnth: true,\\n      hide: 1,\\n      weekSort:{\\n        Sunday: [\\\"日\\\", \\\"一\\\", \\\"二\\\", \\\"三\\\", \\\"四\\\", \\\"五\\\", \\\"六\\\"],\\n        Monday: [\\\"一\\\", \\\"二\\\", \\\"三\\\", \\\"四\\\", \\\"五\\\", \\\"六\\\", \\\"日\\\"],\\n      },\\n      clickMonth: [\\n        { key: \\\"一月\\\", value: 1 },\\n        { key: \\\"二月\\\", value: 2 },\\n        { key: \\\"三月\\\", value: 3 },\\n        { key: \\\"四月\\\", value: 4 },\\n        { key: \\\"五月\\\", value: 5 },\\n        { key: \\\"六月\\\", value: 6 },\\n        { key: \\\"七月\\\", value: 7 },\\n        { key: \\\"八月\\\", value: 8 },\\n        { key: \\\"九月\\\", value: 9 },\\n        { key: \\\"十月\\\", value: 10 },\\n        { key: \\\"十一月\\\", value: 11 },\\n        { key: \\\"十二月\\\", value: 12 },\\n      ],\\n      lastMonth: [\\\"一月\\\", \\\"二月\\\", \\\"三月\\\", \\\"四月\\\"],\\n      lastYear: [],\\n      thisYear: [],\\n      // 当前日\\n      currentDay: new Date().getDate(),\\n      // 当前月\\n      currentMonth: new Date().getMonth() + 1,\\n      // 当前年\\n      currentYear: new Date().getFullYear(),\\n    };\\n  },\\n  created() {\\n    this.initParameter();\\n  },\\n  computed: {\\n    cssProps() {\\n      return {\\n        \\\"--Q-calendar-background-color\\\": this.SelectedBackgroundColor,\\n        \\\"--Q-calendar-color\\\": this.SelectedTextColor,\\n      };\\n    },\\n    // 当前月的天数\\n    currentMonthDays() {\\n      let dayLength = new Date(\\n        this.currentYear,\\n        this.currentMonth,\\n        0\\n      ).getDate();\\n      let arr = [];\\n      for (let h = 0; h < dayLength; h++) {\\n        let dataObj = {\\n          year: this.currentYear + \\\"\\\",\\n          month: (this.currentMonth>0&&this.currentMonth<10)?'0'+ this.currentMonth :this.currentMonth+'',\\n          day: (h+1>0&&h+1<10)? '0'+ (h+1) : (h+1) + '',\\n          checked: false,\\n        };\\n        arr[h] = dataObj;\\n      }\\n      for (let p = 0; p < this.arr.length; p++) {\\n        for (let k = 0; k < arr.length; k++) {\\n          if ((this.arr[p].year === arr[k].year + \\\"\\\") && (this.arr[p].month === arr[k].month + \\\"\\\") && (this.arr[p].day === arr[k].day + \\\"\\\") && this.arr[p].checked) {\\n            arr[k].checked = true\\n          }\\n        }\\n      }\\n      return arr;\\n    },\\n    // 获取上个月的剩余多少天\\n    lastMonthDays() {\\n      const lastLength = new Date(\\n        this.currentYear,\\n        this.currentMonth - 1,\\n        0\\n      ).getDate();\\n      let cutLength;\\n      if (this.isMonday) {\\n        cutLength = new Date(\\n          this.currentYear,\\n          this.currentMonth - 1,\\n          0\\n        ).getDay();\\n      } else {\\n        cutLength = new Date(\\n          this.currentYear,\\n          this.currentMonth - 1,\\n          1\\n        ).getDay();\\n      }\\n      let arr = [];\\n      for (let h = lastLength - cutLength + 1; h <= lastLength; h++) {\\n        arr.push(h);\\n      }\\n      return arr;\\n    },\\n  },\\n  methods: {\\n    onMousewheel(e) {\\n      let evt = e || window.event; //考虑兼容性\\n      evt.preventDefault();\\n      if (evt.deltaY > 0) {\\n        this.onClickDown();\\n      } else {\\n        this.onClickUp();\\n      }\\n      //检查事件\\n      // console.log(evt.type, evt.deltaX, evt.deltaY, evt.deltaZ);\\n    },\\n    dragDay(dayObj) {\\n      if (!this.multiSelect) {\\n        return;\\n      } else {\\n        if (!this.isMouseDown) {\\n          return;\\n        } else {\\n          this.onChangeDay(dayObj);\\n        }\\n      }\\n    },\\n    onMouseDown(dayObj) {\\n      if (!this.multiSelect) {\\n        return;\\n      } else {\\n        if (this.isMouseDown) this.onChangeDay(dayObj);\\n        this.isMouseDown = true;\\n      }\\n    },\\n    onMouseUp() {\\n      this.isMouseDown = false;\\n    },\\n    onMouseleave() {\\n      if (this.isMouseDown) {\\n        this.isMouseDown = false;\\n      }\\n    },\\n    // 点击多选\\n    onChangeDay(val) {\\n      // 判断单选，多选，还是范围选，对应值1.2.3.\\n      if (this.selectType === 1) {\\n        if (this.arr.length === 0) {\\n          val.checked = true;\\n          this.arr=[val]\\n        } else if (this.arr.length === 1) {\\n          if ((this.arr[0].year === val.year) && (this.arr[0].month === val.month) && (this.arr[0].day === val.day)) {\\n            this.arr = []\\n          } else {\\n            this.arr = []\\n            val.checked = true;\\n            this.arr.push(val);\\n          }\\n        } else {\\n          return\\n        }\\n      } else if (this.selectType === 2) {\\n        if (val.checked) {\\n          // 剔除\\n          val.checked = false;\\n          this.arr = this.arr.filter((ele) => {\\n            return !(\\n              ele.year === val.year &&\\n              ele.month === val.month &&\\n              ele.day === val.day\\n            );\\n          });\\n        } else {\\n          // 添加\\n          val.checked = true;\\n          this.arr.push(val);\\n        }\\n      } else if (this.selectType === 3) {\\n        // 范围选择，\\n        if (this.arr.length === 0) {\\n          val.checked = true;\\n          this.arr.push(val);\\n        } else if (this.arr.length === 1) {\\n          val.checked = true;\\n          this.arr.push(val);\\n          const arrS = getRangeDay(this.arr[0],this.arr[1])\\n          this.arr = []\\n          this.arr = arrS\\n        } else {\\n          this.arr = []\\n          val.checked = true;\\n          this.arr.push(val);\\n        }\\n      }\\n      this.$emit(\\\"selectedData\\\", this.arr);\\n    },\\n    initParameter() {\\n      let currentYear = this.currentYear - 1;\\n      for (let p = 3; p >= 0; p--) {\\n        this.lastYear[p] = currentYear--;\\n      }\\n      currentYear = this.currentYear;\\n      for (let l = 0; l < 12; l++) {\\n        this.thisYear[l] = currentYear++;\\n      }\\n    },\\n    onChangeYear(val) {\\n      this.hide = 2;\\n      let currentYear = new Date().getFullYear();\\n      this.currentYear = val.srcElement.innerText;\\n      this.isNowYear = val.srcElement.innerText + \\\"\\\" === currentYear+''\\n    },\\n    onChangeMonth(val, ) {\\n      this.hide = 1;\\n      let currentMonth = new Date().getMonth() + 1;\\n      this.currentMonth = val.value;\\n      this.isNowMOnth=val.value + \\\"\\\" === currentMonth + \\\"\\\"\\n    },\\n    // 点击年\\n    onClickYears() {\\n      let currentYear = this.currentYear - 1;\\n      for (let p = 3; p >= 0; p--) {\\n        this.lastYear[p] = currentYear--;\\n      }\\n      this.hide = 3;\\n    },\\n    // 点击月\\n    onClickMonth() {\\n      this.hide = 2;\\n    },\\n    // 获取上个月的剩余多少天\\n    nextMonth() {\\n      const ac = 42 - this.currentMonthDays.length - this.lastMonthDays.length;\\n      return ac;\\n    },\\n    // 上\\n    onClickUp() {\\n      let currentYear = new Date().getFullYear();\\n      if (this.hide === 1) {\\n        if (this.currentMonth === 1) {\\n          this.currentYear--, (this.currentMonth = 13);\\n        }\\n        this.currentMonth--;\\n      } else if (this.hide === 2) {\\n        this.currentYear--;\\n        this.isNowYear = this.currentYear+'' === currentYear+''\\n      } else {\\n        this.switchingYear(1);\\n      }\\n    },\\n    // 下\\n    onClickDown() {\\n      let currentYear = new Date().getFullYear();\\n      if (this.hide === 1) {\\n        // 日\\n        if (this.currentMonth === 12) {\\n          this.currentYear++, (this.currentMonth = 0);\\n        }\\n        this.currentMonth++;\\n      } else if (this.hide === 2) {\\n        // 月默认切换年\\n        this.currentYear++;\\n        this.isNowYear = this.currentYear+'' === currentYear+''\\n      } else {\\n        // 切换年的选择\\n        this.switchingYear(2);\\n      }\\n    },\\n    switchingYear(type) {\\n      // 1上，2下\\n      if (type === 1) {\\n        // last最后一个为this的最后一个\\n        let thisAnchor = this.lastYear[3] - 11;\\n        let lastAnchor = this.lastYear[3] - 15;\\n        this.thisYear = [];\\n        for (let p = 0; p < 12; p++) {\\n          this.thisYear[p] = thisAnchor++;\\n        }\\n        this.lastYear = [];\\n        for (let l = 0; l < 4; l++) {\\n          this.lastYear[l] = lastAnchor++;\\n        }\\n      } else if (type === 2) {\\n        let anchor = this.thisYear[11] + 1;\\n        this.lastYear = [];\\n        for (let p = 3; p >= 0; p--) {\\n          this.lastYear[p] = this.thisYear[11]--;\\n        }\\n        this.thisYear = [];\\n        for (let l = 0; l < 12; l++) {\\n          this.thisYear[l] = anchor++;\\n        }\\n      }\\n    },\\n  },\\n};\\n</script>\\n\\n<style scoped lang=\\\"scss\\\">\\n@import './utils/QCalendar.scss';\\n</style>\\n\\n```\\n## 日历组件效果图\\n> 2022-12-27日补充\\n### 日\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/230e4c1d127d4442b96617ab0761a463~tplv-k3u1fbpfcp-watermark.image?)\\n### 月\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f30343c5e90e4e148188bdda9921152d~tplv-k3u1fbpfcp-watermark.image?)\\n### 年\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c38be3107514662b5ec0afc11e0ebee~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## tips\\n**支持滑动切换年月日，具体功能请移步组件文档**",
        "tags": [
            "前端",
            "Vue.js",
            "JavaScript"
        ]
    },
    {
        "article_id": "7193594082814656549",
        "cover_image": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9243986fc8604b479efdb325e3acddb0~tplv-k3u1fbpfcp-watermark.image?",
        "title": "开源推荐! 一款开箱即用的电子签名组件",
        "brief": "hello, 大家好, 我是徐夕, 今天又到了分享时间. 今天和大家分享一下我最近开源的轻量级电子签名组件——react-sign2. 我们可以使用它轻松的实现电子签名, 比如说常用的合同签字, 文稿",
        "user_name": "徐小夕",
        "view_count": 2292,
        "collect_count": 45,
        "comment_count": 9,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/d08df4df3fe80db668014b4b815390a5~300x300.image",
        "category": "前端",
        "content": "> 作者: 徐小夕\\n>\\n> 演示地址: http://h5.dooring.cn/react-sign\\n\\nhello, 大家好, 我是徐夕, 今天又到了分享时间. 今天和大家分享一下我最近开源的**轻量级电子签名组件——react-sign2**. \\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c7f4c3af91e46a8917c3c91d99e3f3f~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n我们可以使用它轻松的实现电子签名, 比如说常用的**合同签字**, **文稿签名**, **艺术签名**等, 并支持一键将签名保存.\\n\\n### 基本使用\\n\\n我们要想直接使用, 可以在 `npm` 上安装 `react-sign2` :\\n```\\n# 或者yarn add react-sign2\\nnpm i react-sign2\\n```\\n\\n然后一个简单的使用如下:\\n\\n```js\\nimport Sign from 'react-sign2';\\n\\nexport default () => \\n  <Sign width={400} onDrawEnd={(c) => console.log(c)} />;\\n```\\n\\n`react-sign2`还提供了很多可定制的属性, 来方便使用者灵活定制电子签名, 以下是开放性属性介绍:\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/518cf5386c6f4dd192809339733326d5~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n比如我可以调整线条的颜色:\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/375315f1724847fe873c86a2488748a1~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n调整线条宽度:\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/636f254c1b03445fab16d96a7a2737e5~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n在具体使用的时候灵活配置即可, 我还提供了业务中经常用到的监听事件, 方便使用者灵活调用:\\n\\n- **onSave** 保存时的回调\\n- **onClear** 当画布清空时的回调\\n- **onDrawEnd** 每次绘制结束时的回调\\n\\n\\n### 实现思路\\n\\n按照笔者之前的习惯, 在设计组件之前都会**先明确组件的设计需求**, 然后根据健壮组件的设计原则来落地组件, 这里给大家分享一下我总结的几条组件设计经验:\\n\\n- 对组件进行严格的属性设计, 保证业务层能低成本使用组件, 并保持一定的可配性\\n- 组件内外部类型约定(ts规范), 并提供对逻辑的兼容性\\n- 可读性(代码格式统一清晰，注释完整，代码结构层次分明，编程范式使用得当)\\n- 可用性(代码功能完整，在不同场景都能很好兼容，业务逻辑覆盖率)\\n- 复用性(代码可以很好的被其他业务模块复用)\\n- 可维护性(代码易于维护和扩展，并有一定的向下/向上兼容性)\\n- 高性能(组件具有一定的性能, 如复杂场景的渲染, 计算等)\\n\\n对于电子签名组件, 我们最小化的需求就是**能满足用户的线上签名, 并能保存签名数据**.\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/faf1616850654eaaa7367c6ca7297eb8~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n以上就是我们最小化的需求, 为了满足我总结的组件设计几大原则, 我们需要对组件进行近一步的需求分析: **签名的颜色**, **笔触的粗细**, **平滑度**, **支持自定义事件**等. \\n\\n这些都是组件第一个阶段可以想到的配置点, 也是能应对第一阶段业务需求的功能, 所以有了第一版的组件需求设计:\\n\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c07fc4a12fc488b9c0088760c26cb31~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n接下来就需要用 `typescript` 来规范组件的输入和输出了. 具体定义如下:\\n\\n```ts\\nexport interface IProp {\\n  /**\\n   * @description   画布宽度\\n   * @default       400\\n   */\\n   width?: number;\\n   /**\\n    * @description   画布高度\\n    * @default       200\\n    */\\n   height?: number;\\n   /**\\n    * @description   线宽\\n    * @default       4\\n   */\\n   lineWidth?: number;\\n   /**\\n    * @description   线段颜色\\n    * @default       'red'\\n   */\\n   strokeColor?: string;\\n   /**\\n    * @description   设置线条两端圆角\\n    * @default       'round'\\n   */\\n   lineCap?: string;\\n   /**\\n    * @description   线条交汇处圆角\\n    * @default       'round'\\n   */\\n   lineJoin?: string;\\n   /**\\n    * @description   画布背景颜色\\n    * @default       'transparent'\\n   */\\n   bgColor?: string;\\n   /**\\n    * @description   true\\n   */\\n   showBtn?: boolean;\\n   /**\\n   * @description   当保存时的回调, blob为生成的图片bob\\n   * @default       -\\n   */\\n   onSave?: (blob: Blob) => void;\\n  /**\\n   * @description   当画布清空时的回调, 参数为画布的上下文对象,可以直接使用canvas的api\\n   * @default       -\\n   */\\n   onClear?: (canvasContext: CanvasRenderingContext2D) => void;\\n   /**\\n   * @description   当画布结束时的回调\\n   * @default       -\\n   */\\n   onDrawEnd?: (canvas: HTMLCanvasElement) => void;\\n}\\n```\\n\\n接下来就到了我们具体的代码实现阶段. 由于电子签名的核心技术采用的是`canvas`(虽然用**dom**和**svg**也可以实现), 所以无论你是用的`react`还是`vue3`, 或者似乎原生态`javascript`, 都能低成本的封装. 这里笔者采用**全球程序员**最爱用的`react` 来实现. \\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2065aa22c24342238b5254c36ec63e1d~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n以上是组件的基本属性定义和代码结构, 画图部分涉及到 `canvas` 的比较细节的部分, 如果大家对图形学感兴趣可以参考我的专栏:\\n\\n[100+前端几何学应用案例\\n100+前端几何学应用案例](https://juejin.cn/column/7140106706628902948)\\n\\n具体实现的源码我已经上传到`github`, 感兴趣的朋友大家可以参考一下, 有问题随时交流反馈.\\n\\n**github: https://github.com/MrXujiang/react-sign**\\n\\n大家如果想直接使用, 可以使用如下方式安装使用:\\n\\n[react-sign2 官方演示文档](http://h5.dooring.cn/react-sign/)\\n\\n\\n### 扩展\\n\\n这里给大家聊点题外话, 也是大家比较关注的话题——如何持续维护开源项目. 就拿本文中实现的 `react-sign2` 举例,  以上分享的只是组件的第一阶段实现, 为了让我们的开源组件能被更多的人使用, 我们必须与时俱进, 随着技术的发展持续迭代优化技术底层实现, 比如跨平台, 跨终端, 跨框架, 优化或者增加新功能:\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7fd7240c52dc4be6ad7ac02c066648e4~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n这样我们的开源组件库才能覆盖更多场景, 被更多人使用.\\n\\n所以, 开源的正确打开方式, 你学会了吗? 如果对上面的迭代方向感兴趣, 欢迎在评论区交流, 一起共建v3.0.0. \\n\\n\\n\\n#### 参考资料\\n\\n1. https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API\\n2. https://juejin.cn/post/7174251833773752350\\n\\n\\n### 更多推荐\\n\\n- [2023年, 前端路上的开源总结(最新更新)](https://juejin.cn/post/7191429580790431803)\\n\\n- [Dooring低代码关于辅助设计的思考和实践](https://juejin.cn/post/7188899490810560571)\\n\\n- [低代码平台组件间通信方案复盘](https://juejin.cn/post/7184801269226143805)\\n\\n- [前端图形学实战: 从零开发一款轻量级滑动验证码组件(vue3 + vite版)](https://juejin.cn/post/7168429787835269133)\\n\\n",
        "tags": [
            "前端",
            "GitHub",
            "JavaScript"
        ]
    },
    {
        "article_id": "7171261348859346974",
        "cover_image": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c96d29cde3847788b4a23f740a15332~tplv-k3u1fbpfcp-watermark.image?",
        "title": "[前端攻坚]：Map的使用",
        "brief": "总结一些日常需要用到的一些api，也是在一些面试中会经常出现的题目，今天分享的是Set的一些用法和个人的一些理解， 同时文章也被收录到我的《JS基础》专栏中，欢迎大家点击收藏加关注。",
        "user_name": "一只大加号",
        "view_count": 3231,
        "collect_count": 32,
        "comment_count": 2,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/3b9ea633ff2678cd409278def6910ebb~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: smartblue\\nhighlight: foundation\\n---\\n\\n开启掘金成长之旅！这是我参与「掘金日新计划 · 12 月更文挑战」的第9天，[点击查看活动详情](https://juejin.cn/post/7167294154827890702 \\\"https://juejin.cn/post/7167294154827890702\\\")\\n\\n\\n> 总结一些日常需要用到的一些api，也是在一些面试中会经常出现的题目，今天分享的是Map的一些用法和个人的一些理解， 同时文章也被收录到我的《JS基础》专栏中，欢迎大家点击收藏加关注。\\n\\n> `Map`类型是键值对的有序列表，而键和值都可以是任意类型\\n\\n1. set()\\n2. get()\\n3. has()\\n4. size\\n\\n先看下简单的调用\\n\\n\\n1. set 用来设置键和值\\n2. get 通过键获取值\\n3. has 判断时候存在某个值\\n4. size 返回map中的个数\\n5. clear 清空map\\n```js\\nlet n = new Map()\\nn.set(1, 'a')\\nconsole.log(n)//Map(1) { 1 => 'a' }\\nconsole.log(n.get(1))//a\\nconsole.log(n.has(1))//true\\nn.set(2, 'a')\\nconsole.log(n.size)//2\\nn.clear()\\nn.size // 0\\n```\\n## 基本使用\\n\\n1. 可以使用set来对map设置键值，并且可以使用链式操作来进行设置\\n2. 键可以是任意数据类型\\n3. 键**只能出现一次**；它在 `Map` 的集合中是独一无二的\\n4. entries和values的使用\\n```js\\n//基本数据类型 \\nlet m = new Map()\\nm.set(1, 'a').set(2, 'b').set(3, 'c') // 链式操作\\n// console.log(m) //Map(3) { 1 => 'a', 2 => 'b', 3 => 'c' }\\n```\\n\\n#### 键**只能出现一次**\\n\\n`情况1`：在这里set设置的都是同一个值，所以在这里键会被认为是同一个值，会更改值，而不会新加一个键\\n`情况2`：这种情况下set会设置一个新键\\n\\n```js\\n//情况1\\nlet a = {a:2}\\nm.set(a, 'a').set(a, 'b')\\nconsole.log(m)//Map(1) { { a: 2 } => 'b' }\\nconsole.log(m.has(a)) //true\\nconsole.log(m.has({a:2})) //false\\n\\n//情况2\\nm.set({a:1}, 'a').set({a:1}, 'b')\\nconsole.log(m)//Map(2) { { a: 1 } => 'a', { a: 1 } => 'b' }\\nconsole.log(m.has({a:1})) //false\\nlet a = {a:1}\\nconsole.log(m.has(a))//false\\n\\n//对于情况2的解释\\nconsole.log({a:1}==={a:1}) //false 因为复杂数据类型判断是时候不相等，所以map在复杂数据类型的设置键上会有同样的效果\\nconsole.log(a==={a:1}) //false\\n```\\n4.遍历：entries的使用\\n\\n```js\\nconst map = new Map([\\n  ['F', 'no'],\\n  ['T',  'yes'],\\n]);\\nfor (let [key, value] of map.entries()) {\\n  console.log(key, value);\\n}\\n// \\\"F\\\" \\\"no\\\"\\n// \\\"T\\\" \\\"yes\\\"\\n\\n// 等同于使用map.entries()\\nfor (let [key, value] of map) {\\n  console.log(key, value);\\n}\\n// \\\"F\\\" \\\"no\\\"\\n// \\\"T\\\" \\\"yes\\\"\\n```\\n\\n上面是map的使用方法，entries可以用在map上面，object的遍历也有用到entries这个功能，只是写法不一样，写法如下，用法和map都是相同的，结果的数据也是相同的\\n\\n```js\\nconst map = {\\n    'F':'no',\\n    'T':'yes'\\n}\\nfor (let [key, value] of Object.entries(map) ){\\n    console.log(key, value);\\n    //F no\\n    //T yes\\n}\\n```\\n## 应用场景\\n从这里我们可以看出map的存储类型和object的存储非常相似，都是通过键值对的方式存储，并且可以通过遍历输出，不同的是map的键可以是任意的数据类型\\n\\n对于map的应用场景，可以放到实现深拷贝中进行使用，存储对象中的复杂数据类型",
        "tags": [
            "前端",
            "JavaScript",
            "掘金·日新计划"
        ]
    },
    {
        "article_id": "7181042065038377020",
        "cover_image": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0fdfc6e05e7d494dadfb6fed0ae1eef0~tplv-k3u1fbpfcp-watermark.image?",
        "title": "2022 年终总结｜技术飞速成长，生活颠沛流离",
        "brief": "2022 年快过去了，是时候回顾一下了。 去年年末的时候，我从北京去了上海，去了一家外企。 最开始的几个月是在上海这边的 team，平时的工作都是和国内的同事沟通，但后来组织结构调整，我被分到了一个跨",
        "user_name": "zxg_神说要有光",
        "view_count": 3803,
        "collect_count": 9,
        "comment_count": 23,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/4e9e751e2b32fb8afbbf559a296ccbf2~300x300.image",
        "category": "代码人生",
        "content": "2022 年快过去了，是时候回顾一下了。\\n\\n去年年末的时候，我从北京去了上海，去了一家外企。\\n\\n最开始的几个月是在上海这边的 team，平时的工作都是和国内的同事沟通，但后来组织结构调整，我被分到了一个跨国的 team，需要和韩国的同事沟通。\\n\\n跨国 team 的特点就是经常开会，而且没约到翻译的时候需要口语沟通。\\n\\n我英语不是很好，感觉沟通上比较困难。加上正好那段时间赶上了上海全套的疫情，被封在家里 3 个多月，心态也不是很好。\\n\\n解封之后我就离职回家了，打算自由职业一段时间。\\n\\n当时决定自由职业也不是随意的决定，也是有一些基础的。\\n\\n去年我写了 babel 插件的小册：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/789795392e4343cb9dc3b7d645c19e28~tplv-k3u1fbpfcp-watermark.image?)\\n\\n今年在外企的时候写完了 typescript 类型体操的小册：\\n\\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96a19ea11a8a4b4da5596a7ef74fdcc6~tplv-k3u1fbpfcp-watermark.image?)\\n\\n当时给 ts 体操小册写了篇软文：\\n\\n[![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b9167edc621e45bdbef34f94b6d09eb5~tplv-k3u1fbpfcp-watermark.image?)](https://mp.weixin.qq.com/s?__biz=Mzg3OTYzMDkzMg==&mid=2247488474&idx=1&sn=b69221cd7f771c72b2c316bbbcae9599&chksm=cf00dce1f87755f7dceed925fbaa45e7d04d5e3f1577d9392fa29b8cc6c996901734cfd6a737&token=1255857305&lang=zh_CN#rd)\\n\\n这篇文章被 Anthony Fu 点赞了，而且还知乎关注了我。\\n\\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/193ea43475a34333ac0d70c68f0fc002~tplv-k3u1fbpfcp-watermark.image?)\\n\\n他可是 type challenge 项目的发起者呀，真正的大佬。\\n\\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b70987e07204f4b9910bc0dc06f7ae0~tplv-k3u1fbpfcp-watermark.image?)\\n\\n当时挺开心的，而且这本小册后面评价也很好，很多人 3 刷、5 刷的：\\n\\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d7637ee2a46b4bfb98f63fc254673fc0~tplv-k3u1fbpfcp-watermark.image?)\\n\\n这让我感觉我写的东西是有价值的。\\n\\n说实话，这比工作带给我的成就感更多。\\n\\n我算了下，如果一年能写 5、6 本小册，虽然赚的不多，但也够养活自己了。\\n\\n所以我回家之后在附近租了个房子，成立了神光实验室：\\n\\n[![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a41dc2db5f5943e58b3b198250341081~tplv-k3u1fbpfcp-watermark.image?)](https://mp.weixin.qq.com/s?__biz=Mzg3OTYzMDkzMg==&mid=2247491172&idx=1&sn=5aefd625d81252befd078e61f3747309&chksm=cf00d15ff87758493e8cede7d31aad54d8b2ca2b034fa95c9e46d1c5b8d261f0ea76cf5eae62&token=1255857305&lang=zh_CN#rd)\\n\\n并且定下了第一年的目标：\\n\\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ec3be604259c4f99964eeb8a18b3b8ab~tplv-k3u1fbpfcp-watermark.image?)\\n\\n那段时间确实挺开心的，可以专心的研究技术和思考，没人打扰，饿了就骑着电动车回家吃饭。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ced53a53540c4af5802d212977034a89~tplv-k3u1fbpfcp-watermark.image?)\\n\\n也就是在那里我完成了调试小册的前期准备，一个多月后上线了调试小册：\\n\\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f0667f1924bf4b36ac3aaf78721a124b~tplv-k3u1fbpfcp-watermark.image?)\\n\\n这本小册讲了网页和 Node.js 的调试，讲了 Chrome DevTools 还有 Charles，也讲了调试工具的实现原理。\\n\\n我始终觉得调试能力是工程师最重要的能力，这本我很早就想写了，算是完成了一个小心愿。\\n\\n而且这本写了 40 多节，也破了我的小册章节数的记录了。\\n\\n那段时间，极客时间找过我，谈过出一本编译的专栏，我当时以还要更掘金小册为由推后了几个月，然后就没消息了。\\n\\n后面我应该会在掘金出这个编译小册，其实这也是我之前打算写书的内容。\\n\\n说到写书，其实每本小册都有编辑联系我出书。\\n\\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e1dbe2ef9424cd3926fef07cd94f75c~tplv-k3u1fbpfcp-watermark.image?)\\n\\n但我始终没找到可以写书的内容，小册里可以放 gif 可以复制代码，可以放链接，可以随时更新和加餐，但是书不可以。\\n\\n书更适合偏理论的东西，可能编译小册写完后我会出本书。\\n\\n在我自由职业了一段时间的时候，我妈告诉我说我爸得了淋巴癌了，可能活不了几个月了。这对我来说无疑是一个晴天霹雳。\\n\\n之后我去医院看了我爸，我爸也知道了我自由职业的事情，之前我一直没告诉他。\\n\\n他还是想让我有个正当的工作。\\n\\n我同意了。于是开始找工作。\\n\\n我的目标是尽快的定下来，只面了 3 家，一个是 tiktok，一个是猿辅导，还有一家是现在的小公司。\\n\\ntiktok 当时问了一道 ts 类型编程的题，我感觉答的还可以，后来录了个视频：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1fd99ed0847e42e39f99a47932a337d8~tplv-k3u1fbpfcp-watermark.image?)\\n\\n这个视频据说传的挺广的，我之前的同事都因为这个视频找到了我。\\n\\ntiktok 前两面高分通过，据 hr 说她第一次见这么好的评价。\\n\\n然并卵，三面挂掉了，接雨水问题没答好。\\n\\n猿辅导那边说我太贵了，其实我都降薪很多了。\\n\\n然后我就去了现在的小公司，虽然也降了不少，但是现金涨了。\\n\\n我爸那边后来出了结果是霍奇金类型的淋巴癌，按时化疗就好了，没啥大问题，治好了能活几十年。\\n\\n于是我又恢复了按时上下班的生活。\\n\\n这家公司是 965，下班挺早的。\\n\\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76ff6d18b4e04d3fa8d2df61bfe15ed9~tplv-k3u1fbpfcp-watermark.image?)\\n\\n再次回到了北京。\\n\\n在这个城市有太多的回忆了，包括和东东的故事，这也是我一直努力的底层原因。\\n\\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/15ab6bd2a29c4ad9b780e889f8c28fa4~tplv-k3u1fbpfcp-watermark.image?)\\n\\n我想成为真正的技术大佬，在那之后我会把我和东东的故事写下来。\\n\\n我之前也写过一点：\\n\\n[![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c44e07cff5c345509d1730d908ea3070~tplv-k3u1fbpfcp-watermark.image?)](https://mp.weixin.qq.com/s?__biz=Mzg3OTYzMDkzMg==&mid=2247488816&idx=1&sn=4d5147fba502c0b916560e95f8e282e6&chksm=cf00da0bf877531d8ef28a1e1fc783dca3f67f77c8d6e0979afe9f1f4c5ac7ca7a418e061f61&token=1255857305&lang=zh_CN#rd)\\n\\n有人问过我是怎么保持对技术的热情的。\\n\\n我不知道我是不是热爱技术，但至少我想成为技术大佬，希望有一天再次见到东东的时候，我可以笑着充满自信的和他说 “东东，我现在已经是技术大佬了哦，有啥问题都可以问我”。\\n\\n这是驱动我写下一篇篇技术文章的底层原因。\\n\\n当然还有一个原因 ，我最近录了个一个[播客](https://www.xiaoyuzhoufm.com/episode/6391f0b7b2cc2ab478979d13?s=eyJ1IjoiNWY3NjA4MTVlMGY1ZTcyM2JiYTcyMTg2IiwiZCI6MX0%3D)里也讲到了。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/259b04bfb0c945bd8053b761c666d9f7~tplv-k3u1fbpfcp-watermark.image?)\\n\\n吴克群采访过唐家三少的时候，问过一个问题，你觉得你 30 岁前的时间都花在哪里了？\\n\\n唐家三少比划着一堆书说，这些书就是我的时间。\\n\\n我也希望我以后可以说这些文章、这些小册就是我的时间。\\n\\n我希望我能写一辈子的技术文章。\\n\\n知识是有复利的，当你在一个领域掌握的知识足够多，足够深入，那么它们之间会发生联结，产生新的知识。\\n\\n我确实能感觉到这一点：\\n\\n[![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1376190e53c74c7c8b21403a4507ca11~tplv-k3u1fbpfcp-watermark.image?)](https://mp.weixin.qq.com/s?__biz=Mzg3OTYzMDkzMg==&mid=2247492729&idx=1&sn=48f729603a41e99abaf0004c966dce25&chksm=cf032b42f874a25428d8861e7fe5b8862711c67ef0faa4bd007ac24e77e35753baa871ad1832&token=1255857305&lang=zh_CN#rd)\\n\\n所以我希望我能深入掌握更多的技术，就像我对 babel、ts、调试这些技术的掌握一样。\\n\\n希望能通过掌握更多的技术而产生一些新的认知，从而写出更多有价值的东西。\\n\\n今年我写了 100 多篇文章，其中有一些还是挺不错的（链接可点）：\\n\\n[![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aedfacec3b4745abb631fff2e84c955d~tplv-k3u1fbpfcp-watermark.image?)](https://mp.weixin.qq.com/s?__biz=Mzg3OTYzMDkzMg==&mid=2247487368&idx=1&sn=506bdf65f18ad053fa737b7821e63406&chksm=cf00c0b3f87749a5a87ac346ac8671ee9e9ac12937958176ab4088d7f48254df0a83cd399661&token=1255857305&lang=zh_CN#rd)\\n\\n\\n[![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/91409ae46b744e8493d0761ba703b9c4~tplv-k3u1fbpfcp-watermark.image?)](https://mp.weixin.qq.com/s?__biz=Mzg3OTYzMDkzMg==&mid=2247487557&idx=1&sn=f7c295cb6d868c4a03fbef0a98aa2888&chksm=cf00df7ef8775668d604d5a54c67793e7e11f77977644e337dde6c9da5d50eee8a8673ef71f0&token=1255857305&lang=zh_CN#rd)\\n\\n\\n[![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/845d712a249f44ddb808fa9d3db85c75~tplv-k3u1fbpfcp-watermark.image?)](https://mp.weixin.qq.com/s?__biz=Mzg3OTYzMDkzMg==&mid=2247488313&idx=1&sn=b03f6912f3a44a4bb802b67e1771614c&chksm=cf00dc02f87755148746750aaca34e0b9a1c05e332bcfd56d3d34672798aa18c43f73347890b&token=1255857305&lang=zh_CN#rd)\\n\\n[![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/44ea905edbe84f569bc31f091247a2e9~tplv-k3u1fbpfcp-watermark.image?)](https://mp.weixin.qq.com/s?__biz=Mzg3OTYzMDkzMg==&mid=2247490464&idx=1&sn=189abe12e4bae409a3c68aba904ce297&chksm=cf00d49bf8775d8d9e0513376f32ad365443adc7c8f7d080865a98ef79240f94b0bc95298431&token=1255857305&lang=zh_CN#rd)\\n\\n\\n[![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c2f66ce9e6c74e0b808320f9b85f3eeb~tplv-k3u1fbpfcp-watermark.image?)](https://mp.weixin.qq.com/s?__biz=Mzg3OTYzMDkzMg==&mid=2247490336&idx=1&sn=fc9a3fcd2e0263308577127cb1820590&chksm=cf00d41bf8775d0dff3bc17cca1060a40019908646a8149ba8b16c1a91d412b815019d7179f9&token=1255857305&lang=zh_CN#rd)\\n\\n[![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45951da616764252b46a0ac1595b6acf~tplv-k3u1fbpfcp-watermark.image?)](https://mp.weixin.qq.com/s?__biz=Mzg3OTYzMDkzMg==&mid=2247490950&idx=1&sn=20deb0b336fc1b874cc03adb0e3ca746&chksm=cf00d2bdf8775bab1e034aff266080c34d7e1545354b2aa36e4a3b4b0728186694507052caae&token=1255857305&lang=zh_CN#rd)\\n\\n[![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ffd43cc07204c798f8edcdff9d2dc6b~tplv-k3u1fbpfcp-watermark.image?)](https://mp.weixin.qq.com/s?__biz=Mzg3OTYzMDkzMg==&mid=2247490704&idx=1&sn=89d6afc3242f33a841fdeaaf0b209f2b&chksm=cf00d3abf8775abd8a603b225d23ef35f894d993e5f6ca2c533979be236ed4fb4a0a92450570&token=1255857305&lang=zh_CN#rd)\\n\\n[![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/919b7fd7dddf4e9ba4304b800409d0ca~tplv-k3u1fbpfcp-watermark.image?)](https://mp.weixin.qq.com/s?__biz=Mzg3OTYzMDkzMg==&mid=2247491214&idx=1&sn=d91217e330f86acdf67ff651890fe85c&chksm=cf00d1b5f87758a39aa9f526b44e659863e805220e5e27e568b683640efc0dd9c0e7592eccd4&token=1255857305&lang=zh_CN#rd)\\n\\n[![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c2430f9d48843acb49351c7cd967e4f~tplv-k3u1fbpfcp-watermark.image?)](https://mp.weixin.qq.com/s?__biz=Mzg3OTYzMDkzMg==&mid=2247491639&idx=1&sn=181ebdd4ee1b2466a3a87d06b9e44694&chksm=cf032f0cf874a61a342e95e0bb214c8babd2092ff405a1a6060821189b4032a41db3813ffd93&token=1255857305&lang=zh_CN#rd)\\n\\n\\n[![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db86d6ddb8374d29ba2dd9ca6ae2564f~tplv-k3u1fbpfcp-watermark.image?)](https://mp.weixin.qq.com/s?__biz=Mzg3OTYzMDkzMg==&mid=2247491872&idx=1&sn=7de5ba876674f91c2b8c07460d306903&chksm=cf032e1bf874a70dd68793893996e52a5bd43f7f15563649d41db12070237aa208d67cb9db2c&token=1255857305&lang=zh_CN#rd)\\n\\n[![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/084df80d9a044855a60013a6d90c381c~tplv-k3u1fbpfcp-watermark.image?)](https://mp.weixin.qq.com/s?__biz=Mzg3OTYzMDkzMg==&mid=2247492177&idx=1&sn=91d8ed648e053ec286ceaad06f92f246&chksm=cf032d6af874a47cc63ff9bcfc3091dfcf71dcecb0e3d7914ad13a634ced3be03976af6255e2&token=1255857305&lang=zh_CN#rd)\\n\\n\\n[![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/208016354bc3427893939b2d9216e8a6~tplv-k3u1fbpfcp-watermark.image?)](https://mp.weixin.qq.com/s?__biz=Mzg3OTYzMDkzMg==&mid=2247492025&idx=1&sn=68e634ceab841b264680657665664ad8&chksm=cf032e82f874a7945b1f0dfdb8fedd3ae972f0c81157f42ea22649b94376333e0bd9d5ced682&token=1255857305&lang=zh_CN#rd)\\n\\n[![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5c7346de15e4ba09bc9128945277a9f~tplv-k3u1fbpfcp-watermark.image?)](https://mp.weixin.qq.com/s?__biz=Mzg3OTYzMDkzMg==&mid=2247491993&idx=1&sn=3c6dec129da83f8d3077c3134e9fdd12&chksm=cf032ea2f874a7b4454cdbd71936616f9e1d68e0fd46dafb3c0c4bfa1806525955040cacd16a&token=1255857305&lang=zh_CN#rd)\\n\\n[![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ae884a287b84676800c9718fdfa19b1~tplv-k3u1fbpfcp-watermark.image?)](https://mp.weixin.qq.com/s?__biz=Mzg3OTYzMDkzMg==&mid=2247492429&idx=1&sn=cbe51b221985ece58852776716d8762e&chksm=cf032c76f874a56020f5a96237f6bae2bf1d037bd8b2bb4284700356ad1ba64e6dafa7c255de&token=1255857305&lang=zh_CN#rd)\\n\\n[![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/06613cb57e6b43d380265ae787f225e5~tplv-k3u1fbpfcp-watermark.image?)](https://mp.weixin.qq.com/s?__biz=Mzg3OTYzMDkzMg==&mid=2247492344&idx=1&sn=a9187b4394b9d62d366974ed677f40fb&chksm=cf032dc3f874a4d5344b8c79057ad9e8859416c82f1b1efa9a56602b0778863667d445c27658&token=1255857305&lang=zh_CN#rd)\\n\\n[![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f44e66e82e2c43f2b83d8d84c81d481a~tplv-k3u1fbpfcp-watermark.image?)](https://mp.weixin.qq.com/s?__biz=Mzg3OTYzMDkzMg==&mid=2247493043&idx=1&sn=197aca704daa784341a8dd8a5c9d0b73&chksm=cf032a88f874a39e712f7a2f8c29af9c4c371270a50ba49d0628fb07353cd18e6a4e6702c069&token=1255857305&lang=zh_CN#rd)\\n\\n[![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3707a72a938944559933b257e4636313~tplv-k3u1fbpfcp-watermark.image?)](https://mp.weixin.qq.com/s?__biz=Mzg3OTYzMDkzMg==&mid=2247492855&idx=1&sn=eeb9a13a269ca18b1f7b2a21e5318bf8&chksm=cf032bccf874a2da5120e0240f44f569aa1df50ceaa8fdc9154ea8fe04d4f152cbfe08e33b44&token=1255857305&lang=zh_CN#rd)\\n\\n[![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df0195f0536c4ba388270361740c9dfd~tplv-k3u1fbpfcp-watermark.image?)](https://mp.weixin.qq.com/s?__biz=Mzg3OTYzMDkzMg==&mid=2247492801&idx=1&sn=adb146bfd1598e7f48bd9494c4aebab2&chksm=cf032bfaf874a2ec7897f5514f0ec2ad89e15d04170f8d6d5f1a39b65f4d79f635b3955f2a86&token=1255857305&lang=zh_CN#rd)\\n\\n[![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/62e83c35fa4441559bd8cd4ef3236530~tplv-k3u1fbpfcp-watermark.image?)](https://mp.weixin.qq.com/s?__biz=Mzg3OTYzMDkzMg==&mid=2247493185&idx=1&sn=bde167a5d3894934967f043b9f3a662f&chksm=cf03297af874a06cfc8007fbd68a71368bdafd21837538ecc9f01425e96edc44edfe4d8037b1&token=1255857305&lang=zh_CN#rd)\\n\\n整体文章的数据比去年好的多，这说明我写文章的水平以及技术都有了不小的进步，再就是也涨了不少粉。\\n\\n今年视频号的数据也很不错，不过我还是不会剪辑，依然是一次性录完那种。\\n\\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1adfb2b970ff4a5ebae6142bd16341f2~tplv-k3u1fbpfcp-watermark.image?)\\n\\n不过最近我一段时间没写文章，一个是因为不知道写什么，很多东西都写过了，另一个是工作中也有一些烦心事。\\n\\n我在公司做 D2C 相关的事情，也就是设计稿转代码，其实我觉得我们几个人的小团队做这件事情意义不大，但是 leader 想搞。\\n\\n我调研过 D2C：\\n\\n[![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/733c783cd647445fa1a9391abb11cef2~tplv-k3u1fbpfcp-watermark.image?)](https://mp.weixin.qq.com/s?__biz=Mzg3OTYzMDkzMg==&mid=2247492152&idx=1&sn=333ac759b7a97cdb6d260bca4ff41f3c&chksm=cf032d03f874a41560cf7f9fcfa1dbbb2700fe7c51834c10cc677a5ac1e7c8241622e0c2e346&token=1255857305&lang=zh_CN#rd)\\n\\n这个领域没啥资料，纯靠自己摸索，我并没有信心能做出来，而且这个是要和设计团队合作的，推进也要看那边的时间。\\n\\n其实我并不是很想搞，但工作做这个，就一直在摸索着前进。\\n\\n也许再摸索一段时间就会豁然开朗吧。\\n\\n总的来说，这一年在技术上成长还是挺大的，但是在上海经历了全套疫情，回家自由职业又被我爸的淋巴癌中断，然后再次回到北京，成了打工人，算是颠沛流离的一年。\\n\\n最后定一下明年的目标：\\n\\n我搞过一个统计，下本写啥小册，nodejs 得票最多。\\n\\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c204948d6214e79b84f3da1e2c7cd66~tplv-k3u1fbpfcp-watermark.image?)\\n\\n这个是明年必写的小册，但不一定是在下本。\\n\\n明年我应该会写《通读 React 18 源码》的视频+ 图文的小册，《webpack 插件通关秘籍》《nodejs 通关秘籍》《微前端通关秘籍》《前端编译通关秘籍》的小册。\\n\\n编译小册可能再写本书。\\n\\n离 30 岁还有两年，希望那之前能写完 10 本小册。\\n\\n这也是为我以后的自由职业做准备，虽然现在又是打工人了，但再过几年还是会自由职业。\\n\\n去年计划今年能把 nest 拿下，成为全栈工程师来着，但是换工作后接触不到 nest 了，所以就没继续了。\\n\\n总之，TODO List 还有很长，继续加油吧，希望以后我能成为真正的技术大佬。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1aa1c41cf5744bba957746d67edc634~tplv-k3u1fbpfcp-watermark.image?)\\n\\n「回顾2022，展望2023，我正在参与[2022年终总结征文大赛活动](https://juejin.cn/post/7172462429929111559 \\\"https://juejin.cn/post/7172462429929111559\\\")」\\n",
        "tags": [
            "前端",
            "JavaScript",
            "Node.js"
        ]
    },
    {
        "article_id": "7182122916505944124",
        "cover_image": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f77866f5f5404ae19cdd764cbbae70e9~tplv-k3u1fbpfcp-watermark.image?",
        "title": "前端开发者利用Strapi实现API自由 - 之微信小程序登录",
        "brief": "作为一名前端，要想自己一个人撸一个网站、APP或者小程序，如果没有后端合作还是有难度的，strapi 提供了这样的可能，本文介绍如何将 strapi 用户系统与微信小程序登录相结合。",
        "user_name": "wfz",
        "view_count": 1404,
        "collect_count": 16,
        "comment_count": 2,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/7d563547d892fd002b99ea3886ce0f62~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: juejin\\n---\\n## 背景\\n作为一名前端，要想自己一个人撸一个网站、APP或者小程序，如果没有后端合作还是有难度的。之前在微信生态可以用 [微信云开发](https://cloud.weixin.qq.com/cloudbase) CMS输出api，基本能实现自给自足，自己一个人能完成一些简单功能的项目，可这玩意积累了一定的用户量以后，几个月前开始收费啦！好吧，本着能白嫖就白嫖的原则，另寻他路吧。\\n\\n正在思前想后不断纠结中，了解到了 [Strapi - Open source Node.js Headless CMS 🚀](https://strapi.io/) ，相信不少朋友用过，他上手方便、功能丰富、部署简单，非常吸引人，果断与微信云开发决裂，投入到strapi的怀抱。不过我今天要说的不是如何使用、入门stiapi，我要说的是如何将 **strapi的用户管理系统和微信小程序的登录** 结合起来，让我们在开发小程序的时候方便使用strapi的用户系统进行权限控制。\\n\\n另，快速入门可以先看这里 [Quick Start Guide - Strapi Developer Docs](https://docs.strapi.io/developer-docs/latest/getting-started/quick-start.html)！\\n\\n\\n## strapi 的用户系统\\nstrapi 提供了基础的用户管理功能，用户可以进行注册、登录、修改密码等操作，不同版本的用户注册、登录调用方法可能有细微差别，现在以4.5.3版本为例进行演示，更为详细的文档请参考这里：[Users & Permissions - Strapi Developer Docs](https://docs.strapi.io/developer-docs/latest/plugins/users-permissions.html#authentication)。\\n\\n### 用户注册\\n当我们正确安装、启动了 strapi 后就可以通过接口进行注册操作，如下：\\n```bash\\n# post\\n{{STRAPI_BACKEND_URL}}/api/auth/local/register\\n\\n# body\\n{\\n    \\\"username\\\":\\\"tester\\\",\\n    \\\"email\\\":\\\"tester@test.com\\\",\\n    \\\"password\\\":\\\"testPassword\\\"\\n}\\n\\n# response\\n{\\n    \\\"jwt\\\": \\\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MywiaWF0IjoxNjcwNzI1NDQ3LCJleHAiOjE2NzMzMTc0NDd9.2fsTqlE2xdCwd9JVk9NQ7WK6i0V--nhpYV-r5EVmqhk\\\",\\n    \\\"user\\\": {\\n        \\\"id\\\": 3,\\n        \\\"username\\\": \\\"tester\\\",\\n        # ......\\n    }\\n}\\n```\\n注册成功以后，进入后台管理界面，就可以看到刚刚注册的用户：\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68b31c42089c492482fac380690c132a~tplv-k3u1fbpfcp-watermark.image?)\\n\\n一个用户注册的过程就结束了。\\n\\n### 用户登录\\n登录过程如下：\\n```bash\\n# post\\n{{STRAPI_BACKEND_URL}}/api/auth/local\\n\\n# body\\n{\\n    \\\"identifier\\\":\\\"tester@test.com\\\",\\n    \\\"password\\\":\\\"testPassword\\\"\\n}\\n\\n# response\\n{\\n    \\\"jwt\\\": \\\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MywiaWF0IjoxNjcwNzI2Njg1LCJleHAiOjE2NzMzMTg2ODV9.EFL9akvV65tmu9PqHp4lQHhnTvx33fXiKN_geYbJfIg\\\",\\n    \\\"user\\\": {\\n        \\\"id\\\": 3,\\n        \\\"username\\\": \\\"tester\\\",\\n        # ......\\n    }\\n}\\n```\\n拿到`token`后就可以存起来，用于后续的业务。\\n\\n这里有一点要注意的是，登录用的`identifier`可以是我们注册时的 `username`，也可以是`email`，其他无特殊之处。\\n\\n### Token 的使用\\n上文返回的 jwt token 可以用于受限资源的访问。在日常业务中，有些数据需要用户登录以后才可以访问，可以在后台的角色权限管理里对其进行配置，任何没有 token 的请求都被视为公共角色。\\n\\n现在新建一个模型 Post，并以它为例。（*新建的过程请参考 Quick Start Guide*）\\n\\n在用户权限里配置只有已授权的用户可以访问，如下：\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/309ada0139b341bc9d8235e9e07f1041~tplv-k3u1fbpfcp-watermark.image?)\\n\\n这时，对于一个 header 里未带 token 的请求，将会返回一个 `403` ForbiddenError，如下：\\n```bash\\n# get\\n{{STRAPI_BACKEND_URL}}/api/posts\\n\\n# response\\n{\\n    \\\"data\\\": null,\\n    \\\"error\\\": {\\n        \\\"status\\\": 403,\\n        \\\"name\\\": \\\"ForbiddenError\\\",\\n        \\\"message\\\": \\\"Forbidden\\\",\\n        \\\"details\\\": {}\\n    }\\n}\\n```\\n\\n如果将正确的 `token` 添加到 header 里，就可以正常取得数据：\\n```bash\\n# get\\n{{STRAPI_BACKEND_URL}}/api/posts\\n\\n# header\\nAuthorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MywiaWF0IjoxNjcyMDM3MTY3LCJleHAiOjE2NzQ2MjkxNjd9.-9aVMgPlxUNq0c1i3EEbOuFAFvEme2IrTnzU_6xTjG0\\n\\n# response\\n{\\n    \\\"data\\\": [\\n        ...\\n    ],\\n    \\\"meta\\\": {\\n        ...\\n    }\\n}\\n```\\n\\n## 微信小程序登录\\n说完了 strapi 的注册、登录过程，再看看\\n[小程序登录](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/login.html) 。根据官方文档的解释，是利用 wx.login() 获取临时登录凭证**code**，然后将code传递给开发者服务器，在开发者服务器调用微信的 auth.code2Session 接口，换取 用户唯一标识 **OpenID** 、 用户在微信开放平台帐号下的唯一标识 **UnionID**，开发者服务器拿到用户的标识以后，可以根据自己的业务需要对用户进行权限管理。\\n\\n微信小程序官网的登录流程时序图如下：\\n\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b38a67487d8437e871b5aec7e7369c6~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n通常来说，对于一个前端来说，我们能做的只有第一步：\\nwx.login() 获取 code，通过 wx.request()发送 code。\\n\\n后续的开发者服务器部分，如何通过 code 换取 OpenId 等业务操作，如果作为 *纯前端* 我们是做不了的，需要后端支持，不过既然要使用 strapi 自己开发一个完整的服务，可以利用 strapi 的插件系统，将微信登录与 strapi 用户系统结合，完成一个完整的微信小程序用户登录业务，并对其进行权限控制。\\n\\n下面介绍具体做法。\\n\\n## 将微信小程序登录与strapi用户系统结合\\n前面提到，微信小程序登录就是用 wx.login() 获取临时登录凭证 **code**，再用 wx.request()发送给后端，后端如何处理这个 code，如何处理登录逻辑，做为前端是无法控制的。\\n\\n但是现在作为前端的我们，自己开发一个完整的CMS系统，没有后端可以依靠，只能自己来！\\n\\n**以 strapi 为基础，完成微信小程序的用户登录，具体的做法主要有以下几步：**\\n1. 基于 strapi 系统，生成一个 strapi plugin\\n2. 利用这个 plugin 接收来自 wx.request() 发送过来的 code\\n3. 调用微信 auth.code2Session 接口换取用户唯一标识 OpenID 等用户信息\\n4. 将用户信息存到 strapi 用户表里，返回 jwt token 及用户信息\\n\\n微信小程序拿到后端返回的 token 及用户信息以后，就可以存起来用于以后的业务中，下面分步详细说明：\\n\\n### 1. 基于 strapi 系统，生成一个 strapi plugin\\nstrapi 提供以命令行方式初始化一个 plugin ，切换到 strapi 根目录，执行命令\\n```bash\\nnpm run strapi generate\\n\\n# 执行命令后会让你选择要生成的模板类型，选择 plugin 即可\\n\\n> strapi \\\"generate\\\"\\n\\n? Strapi Generators (Use arrow keys)\\n> api - Generate a basic API\\n  controller - Generate a controller for an API\\n  content-type - Generate a content type for an API\\n  plugin - Generate a basic plugin\\n  policy - Generate a policy for an API\\n  middleware - Generate a middleware for an API\\n  service - Generate a service for an API\\n  \\n# 然后按提示输入 plugin name: wx-login\\n# 再选择语言 javascript\\n# 回车后文件就生成完成了\\n```\\n如果是第一次开发 plugin，需要在目录下新建文件 `./config/plugins.js`，然后将以下内容写到 plugins.js 中：\\n```javascript\\nmodule.exports = {\\n    // ...\\n    'wx-login': {\\n        enabled: true,\\n        resolve: './src/plugins/wx-login'\\n    },\\n    // ...\\n}\\n```\\n再打开`src\\\\plugins\\\\wx-login\\\\server\\\\routes\\\\index.js`，在 config 里加上 `auth: false`。\\n然后启动项目（`npm run develop`）进行测试：\\n\\n```bash\\n# get\\n{{STRAPI_BACKEND_URL}}/wx-login/\\n\\n# response\\nWelcome to Strapi 🚀\\n```\\n如果能看到如上的返回，那么 wx-login 插件就初始化好了。\\n\\n### 2. 利用这个 plugin 接收来自 wx.request() 发送过来的 code\\n接下来要做的是在微信小程序端，利用 wx.login() 获取临时登录凭证 **code**，然后传递给后端。\\n\\n> 微信小程序 `index.wxml`\\n```html\\n<!--pages/account/index.wxml-->\\n\\n<button bindtap=\\\"login\\\">授权登录</button>\\n```\\n> 微信小程序 `index.js`\\n```javascript\\n// pages/account/index.js\\nPage({\\n  // 其他业务代码 ...\\n  login() {\\n    wx.login({\\n      success: res => {\\n        // 发送res.code到后台换取openId,sessionKey,unionId\\n        wx.request({\\n          url: 'http://localhost:1337/wx-login/',\\n          method: \\\"post\\\",\\n          data: {\\n            code: res.code\\n          },\\n          success(res) {\\n            console.log('wx.request res', res)\\n          }\\n        })\\n      }\\n    })\\n  },\\n  // 其他业务代码 ...\\n})\\n```\\n服务端接收 **code** \\n> strapi wx-login 插件 `src\\\\plugins\\\\wx-login\\\\server\\\\routes\\\\index.js`\\n```javascript\\n// 修改 route，接受来自前端的 post 请求\\nmodule.exports = [\\n  {\\n    method: 'POST',\\n    path: '/',\\n    handler: 'myController.index',\\n    config: {\\n      auth: false,\\n      policies: [],\\n    },\\n  },\\n];\\n```\\n\\n> `src\\\\plugins\\\\wx-login\\\\server\\\\controllers\\\\my-controller.js`\\n```javascript\\n// 接收 post 过来的 code，传递给 service 处理\\n'use strict';\\nmodule.exports = ({ strapi }) => ({\\n  async index(ctx) {\\n    ctx.body = await strapi\\n      .plugin('wx-login')\\n      .service('myService')\\n      .login(ctx.request.body.code);\\n  },\\n});\\n\\n```\\n> `src\\\\plugins\\\\wx-login\\\\server\\\\services\\\\my-service.js`\\n```javascript\\n// service 接收到 code 后，调用微信调用 auth.code2Session 接口换取用户唯一标识 OpenID等用户信息\\n'use strict';\\nconst axios = require(\\\"axios\\\")\\nmodule.exports = ({ strapi }) => ({\\n  getWelcomeMessage() {\\n    return 'Welcome to Strapi 🚀';\\n  },\\n  login(code) {\\n    return new Promise(async (resolve, reject) => {\\n      try {\\n      \\n        // 这里是主要的处理逻辑\\n        \\n      } catch (error) {\\n        return reject({ error: true, message: error });\\n      }\\n    })\\n  },\\n});\\n```\\n到目前为止，已经按着 strapi plugin 的代码格式，成功的处理了来自前端的请求，并将 **code** 传递到 service，接下来将具体看如何调用微信的服务，获取用户标识。\\n\\n### 3. 调用微信 auth.code2Session 接口换取用户唯一标识 OpenID等用户信息\\n打开微信小程序管理后台，进入：开发管理 -> 开发设置，找到 `AppID`、`AppSecret`，将其复制到代码中。再结合前端传过来的 code 进行登录凭证校验。\\n\\n> `src\\\\plugins\\\\wx-login\\\\server\\\\services\\\\my-service.js`\\n```javascript \\nlet app_id = 'Your AppID'\\nlet app_secret = 'Your AppSecret'\\n\\n// 这里的 code 是前端通过 wx.login() 获取临时登录凭证\\nlet resData = await axios.get(`https://api.weixin.qq.com/sns/jscode2session?appid=${app_id}&secret=${app_secret}&js_code=${code}&grant_type=authorization_code`)\\n```\\n返回的数据示例：\\n```bash\\n {\\n    session_key: '0PTbmNDSOmdkJJqAIaNNVw==',\\n    openid: 'oFHxc5TV5VKscIudqlmfx9JpK4d4'\\n }\\n  ```\\n如果能正确返回 `openid`，说明验证成功，认为这个用户是一个有效用户，返回登录信息。\\n\\n### 4. 将用户信息存到 strapi 用户表里，返回 jwt token 及用户信息\\n前面已经完成了微信小程序登录的整个过程，现在要把这个用户记录到 strapi 的 user 表里。\\n需要在 user 表里新建一个 openid 字段，将 auth.code2Session 接口获取的 openid 存到表里，做为用户的唯一标识。\\n\\n\\n来到后面管理界面, 切换到 User 模型管理 (PLUGINS -> Content-Type Builder -> COLLECTION TYPES -> User)，添加 openid 字段，并且保存。\\n|  NAME   | TYPE  |\\n|  ----  | ----  |\\n| openid  | Text |\\n\\n添加完成后，下面看 `my-service.js` 的完整代码。\\n\\n> `src\\\\plugins\\\\wx-login\\\\server\\\\services\\\\my-service.js`\\n```javascript\\n'use strict';\\nconst axios = require(\\\"axios\\\")\\nmodule.exports = ({ strapi }) => ({\\n  getWelcomeMessage() {\\n    return 'Welcome to Strapi 🚀';\\n  },\\n  // 生成一个随机的密码\\n  makeRandomPassword(length) {\\n    var result = '';\\n    var characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\\n    var charactersLength = characters.length;\\n    for (var i = 0; i < length; i++) {\\n      result += characters.charAt(Math.floor(Math.random() *\\n        charactersLength));\\n    }\\n    return result;\\n  },\\n  login(code) {\\n    return new Promise(async (resolve, reject) => {\\n      try {\\n        let app_id = 'Your AppID'\\n        let app_secret = 'Your AppSecret'\\n        \\n        // 调用 auth.code2Session 进行用户登录验证\\n        let resData = await axios.get(`https://api.weixin.qq.com/sns/jscode2session?appid=${app_id}&secret=${app_secret}&js_code=${code}&grant_type=authorization_code`)\\n        if (resData.status !== 200) {\\n          return reject({ error: true, message: \\\"Error occur when request to wechat api\\\" });\\n        }\\n        \\n        // 验证失败，返回错误信息\\n        if (!resData.data.openid) {\\n          return reject({ error: true, message: resData.data });\\n        }\\n        \\n        // 登录验证通过，查询 strapi 用户表中是否存在该用户\\n        const { openid } = resData.data;\\n        const user = await strapi.db.query('plugin::users-permissions.user').findOne({ where: { openid } });\\n        \\n        // 如果该用户不存在（第一次登录），将用户信息插入到用户表中\\n        if (!user) {\\n          let randomPass = this.makeRandomPassword(10);\\n          let password = await strapi.service(\\\"admin::auth\\\").hashPassword(randomPass);\\n          let newUser = await strapi.db.query('plugin::users-permissions.user').create({\\n            data: {\\n              password,\\n              openid,\\n              confirmed: true,\\n              blocked: false,\\n              role: 1,\\n              provider: \\\"local\\\"\\n            }\\n          })\\n          \\n          // 返回登录信息\\n          return resolve({\\n            token: strapi.plugin('users-permissions').service('jwt').issue({ id: newUser.id }),\\n            user: strapi.service('admin::user').sanitizeUser(newUser),\\n          })\\n        }\\n        \\n        // 如果用户已经存在于 user 表中，直接返回用户登录信息\\n        resolve({\\n          token: strapi.plugin('users-permissions').service('jwt').issue({ id: user.id }),\\n          user: strapi.service('admin::user').sanitizeUser(user),\\n        })\\n      } catch (error) {\\n        return reject({ error: true, message: error });\\n      }\\n    })\\n  },\\n});\\n\\n```\\n至此，微信小程序的整个登录过程就结束了，前端通过 wx.login() 可以直接拿到 `token`，前端通过返回的 `token` 可以访问 strapi 权限管理体系内的受限资源。\\n\\n更详细的代码看这里： [wfzong/strapi-wechat-miniprogram-auth (github.com)](https://github.com/wfzong/strapi-wechat-miniprogram-auth)\\n\\n## strapi 插件 WeChat MiniProgram Auth 的使用\\n作为单个项目来说，这么做是没问题的，可以直接在代码写任何逻辑，但其实这个登录是个通用过程，所以在前段时间做项目的时候，就把它写成了一个 strapi plugin 插件，主要有两点优化：\\n1. 可以在后台管理 appid 和 app_secret，不用把它们直接写在代码里。\\n2. 一键安装使用，几乎不用写任何代码。\\n\\n并且将它发布到了 strapi 的插件市场里，官方也收录了：[Wechat Miniprogram Auth | Strapi Market](https://market.strapi.io/plugins/strapi-wechat-miniprogram-auth)\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f1fb2489d3064d91b7b9a37342ab09e9~tplv-k3u1fbpfcp-watermark.image?)\\n\\n使用相对简单，只需要`npm install strapi-wechat-miniprogram-auth`安装一下，再配置一下 `config/plugins.js`，再给 user 表加两个字段就可以使用。\\n\\n更详细的使用说明，可以看 [strapi-wechat-miniprogram-auth - npm (npmjs.com)](https://www.npmjs.com/package/strapi-wechat-miniprogram-auth) 的 README.md。\\n\\n## 总结\\n微信小程序的登录过程相对比较简单，其核心是通过 code 拿到 openid，这个 openid 是用户在微信系统的唯一标识，将它存到 strapi 的 user 表里，也就成为了用户在 strapi 系统里的唯一标识，这样就将微信小程序的用户和strapi用户关联起来，然后再按着 strapi 的 token 生成规则，生成 token 返回给用户，用户拿到 token 后就完成了整个登录过程。\\n\\n至于是否在微信小程序端获取用户信息、获取用户手机号等业务，可以根据自己的业务需要做处理，然后决定把它存在什么位置。\\n\\n",
        "tags": [
            "CMS",
            "前端",
            "Node.js"
        ]
    },
    {
        "article_id": "7189978888934522935",
        "cover_image": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c54659f09e642ee9b19f7611b59eda0~tplv-k3u1fbpfcp-watermark.image?",
        "title": "JavaScript: 一战吃透Promise精修版",
        "brief": "爱情Promise，曾2017年大学毕业，通过校招来到了一家不错的大厂工作，若按当时的校聘，可真没有前端相关的面试笔试题呀，基本侧重方面都是java、C++、C#、Sql相关的考题。",
        "user_name": "糖墨夕",
        "view_count": 1432,
        "collect_count": 83,
        "comment_count": 15,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/f2be119aeaeb919175de9aa398141dbd~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: awesome-green\\nhighlight: atelier-seaside-light\\n---\\n\\n# 缘起\\n\\n曾2017年大学毕业，通过校招来到了一家不错的大厂工作，若按当时的校聘，可真没有前端相关的面试笔试题呀，基本侧重方面都是java、C++、C#、Sql相关的考题。因为这些在大学里是必修课，也更能反映学生的学习能力。所以后面工作之后，基本就是实战居多，没有过多了解外面公司的面试笔试要求，和甄选应聘者的条件。在公司的第一年，就开始坚定地往前端方向的走下去了，因为我觉得，与其枯燥无味地研究后端的逻辑代码，还不如能直观看到视觉效果的前端的成就感来得更加爽快（**并不是鄙视后端，只是个人的爱好，而且相对而言上手迅速，是不是也有很多前端的掘友也跟我一样的想法**）\\n\\n>有的人说，三年就能把前端学到了天花板，我想这跟个人的眼界有关；你以为的天花板，和别人以为的天花板真的是一回事吗？\\n\\n当我开始考虑晋升和挑战自我（**跳槽**）的时候，就想本着两年前端经验的实战作品，去应聘薪酬条件更高的公司，结果碰了一脸灰，本以为有了工作经验之后，笔试题可以直接跳过了。尴尬的是，摆在我面前的就有多道Promise的改编和升华的题目。当时真的一脸懵逼，虽说在项目中几乎哪里都用到。但是，我在问自己，我自己真的已经掌握它了吗。会用不等于理解，当然理解了，同样也不一定会用。我们需要通过实战中更深刻地去理解，这样，出题人，不论如何改编题目，我们都能通过理解的知识点，来解题。 题目变的是形式，而其本是同一类型的题。\\n\\n后面我就针对这个题型，做了深度总结，同时也分享给大家，不对的可以建议建议，非常感谢！\\n\\n从下面几个方面，做下精修：\\n\\n    1. Promise相关概念-白话文篇\\n    2. 微任务、宏任务与Event-Loop-长话短说篇\\n    4. 微任务、宏任务混合考题-综合篇\\n\\n# 精修\\n## Promise相关概念-白话文篇\\n> 白话文的意思就是不想通过以下图中那么官方的讲解，结果换来掘友的一字好评==“就我一个人看半天不知道说的啥吗”，结果引来一波掘友+1，哈哈哈😂，所以后面我换了一种通俗接地气的说法，给一一理解的\\n\\n\\n<p align=center><img src=\\\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b681199745740c584561f6a71613ad9~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\" width=\\\"70%\\\" /></p>\\n\\n\\n\\n\\n<p align=center><img src=\\\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ed3c20370d5433f990b4eed4f1e841c~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\" width=\\\"70%\\\" /></p>\\n\\n### **Promise对象有以下两个特点。**\\n\\n（1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称 Fulfilled）和Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。**我想，如果也能拥有一份promise的爱情，那真的是三世修来的福气啦哈哈哈**😂 \\n\\n（2）一旦状态改变，就不会再变，（想想狗的忠诚）任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就会凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的，往事不可追。\\n\\n<img src=\\\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df3b74626ef34c359bc035bec1875ef6~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\" width=\\\"100%\\\" />\\n\\n> **上面所说的两点需要你有对异步有过了解，如果没有比较清晰的认识，我这里也为入门级的前端掘友做一下补充：异步事件**\\n\\n### **异步事件的概念**\\n\\n注册一个回调函数，比如说发一个网络请求，我们告诉主程序等到接收到数据后通知我，然后我们就可以去做其他的事情了。\\n\\n然后在异步完成后，会通知到我们，但是此时可能程序正在做其他的事情，所以即使异步完成了也需要在一旁等待，等到程序空闲下来才有时间去看哪些异步已经完成了，可以去执行。\\n\\n**比方说打了个车，如果司机先到了，但是你手头还有点儿事情要处理，这时司机是不可能自己先开着车走的，一定要等到你处理完事情上了车才能走**\\n\\n<p align=center><img src=\\\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63020a3c27bf4b59b48cc60dcef89f3e~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\"  width=\\\"70%\\\"/></p>\\n\\n\\n## 微任务、宏任务与Event-Loop-长话短说篇\\n### **`event loop`它的执行顺序：**\\n\\n    1. 一开始整个脚本作为一个宏任务执行\\n    2. 执行过程中同步代码直接执行，宏任务进入宏任务队列，微任务进入微任务队列\\n    3. 当前宏任务执行完出队，检查微任务列表，有则依次执行，直到全部执行完\\n    4. 执行浏览器UI线程的渲染工作\\n    5. 检查是否有`Web Worker`任务，有则执行\\n    6. 执行完本轮的宏任务，回到2，依此循环，直到宏任务和微任务队列都为空\\n\\n### **微任务包括：**\\n\\n    `MutationObserver`\\n    `Promise.then()或catch()`\\n    `Promise为基础开发的其它技术，比如fetch API`、`V8`的垃圾回收过程\\n    `Node独有的process.nextTick`\\n\\n### **宏任务包括**：\\n\\n`script`、`setTimeout`、`setInterval` 、`setImmediate` 、`I/O` 、`UI rendering`\\n\\n**注意**⚠️：在所有任务开始的时候，由于宏任务中包括了`script`，所以浏览器会先执行一个宏任务，在这个过程中你看到的延迟任务(例如`setTimeout`)将被放到下一轮宏任务中来执行。\\n\\n### 补充说明：\\n\\n> **注：非入门级掘友请跳过以下描述**\\n\\n如果上面所说的有点晦涩难懂，这里就把抽象具体化：\\n宏任务和微任务的过程，就像去银行办业务一样，先要取号进行排号。  \\n一般上边都会印着类似：“您的号码为XX，前边还有XX人。”之类的字样。\\n\\n因为柜员同时职能处理一个来办理业务的客户，这时每一个来办理业务的人就可以认为是银行柜员的一个宏任务来存在的，当柜员处理完当前客户的问题以后，选择接待下一位，广播报号，也就是下一个宏任务的开始。  \\n所以多个宏任务合在一起就可以认为说有一个任务队列在这，里边是当前银行中所有排号的客户。  \\n**任务队列中的都是已经完成的异步操作，而不是说注册一个异步任务就会被放在这个任务队列中，就像在银行中排号，如果叫到你的时候你不在，那么你当前的号牌就作废了，柜员会选择直接跳过进行下一个客户的业务处理，等你回来以后还需要重新取号**\\n\\n而且一个宏任务在执行的过程中，是可以添加一些微任务的，就像在柜台办理业务，你前边的一位老大爷可能在存款，在存款这个业务办理完以后，柜员会问老大爷还有没有其他需要办理的业务，这时老大爷想了一下：“最近P2P爆雷有点儿多，是不是要选择稳一些的理财呢”，然后告诉柜员说，要办一些理财的业务，这时候柜员肯定不能告诉老大爷说：“您再上后边取个号去，重新排队”。  \\n所以本来快轮到你来办理业务，会因为老大爷临时添加的“**理财业务**”而往后推。  \\n也许老大爷在办完理财以后还想 **再办一个信用卡**？或者 **再买点儿纪念币**？  \\n无论是什么需求，只要是柜员能够帮她办理的，都会在处理你的业务之前来做这些事情，这些都可以认为是微任务。\\n\\n**在当前的微任务没有执行完成时，是不会执行下一个宏任务的**\\n\\n那么event-loop又是个啥东西？上边一直在讨论 宏任务、微任务，各种任务的执行。  \\n但是回到现实，`JavaScript`是一个单进程的语言，同一时间不能处理多个任务，所以何时执行宏任务，何时执行微任务？我们需要有这样的一个判断逻辑存在。\\n\\n每办理完一个业务，柜员就会问当前的客户，是否还有其他需要办理的业务。**（检查还有没有微任务需要处理）**\\n而客户明确告知说没有事情以后，柜员就去查看后边还有没有等着办理业务的人。 **（结束本次宏任务、检查还有没有宏任务需要处理）**\\n> 这个检查的过程是持续进行的，每完成一个任务都会进行一次，而这样的操作就被称为`Event Loop`。 (这是个非常简易的描述了，实际上会复杂很多)\\n\\n而且就如同上边所说的，一个柜员同一时间只能处理一件事情，即便这些事情是一个客户所提出的，所以可以认为微任务也存在一个队列。\\n\\n\\n\\n\\n\\n## 微任务、宏任务混合考题-综合篇\\n\\n>接下来我们就来验证下我们刚get到的知识，是否已经理解通透。\\n\\n### 异步题1\\n\\n  \\n\\n\\n这道题主要考察的是事件循环中函数执行顺序的问题，其中包括`async` ，`await`，`setTimeout`，`Promise`函数。下面来说一下本题中涉及到的知识点。\\n\\n```\\n//请写出输出内容\\nasync function async1() {\\n    console.log('async1 start');\\n    await async2();\\n    console.log('async1 end');\\n}\\nasync function async2() {\\n\\tconsole.log('async2');\\n}\\n\\nconsole.log('script start');\\n\\nsetTimeout(function() {\\n    console.log('setTimeout');\\n}, 0)\\n\\nasync1();\\n\\nnew Promise(function(resolve) {\\n    console.log('promise1');\\n    resolve();\\n}).then(function() {\\n    console.log('promise2');\\n});\\nconsole.log('script end');\\n\\n\\n/*\\nscript start\\nasync1 start\\nasync2\\npromise1\\nscript end\\nasync1 end\\npromise2\\nsetTimeout\\n*/\\n```\\n\\n以上的结果都可以通过下面码上掘金去验证结果；\\n[jcode](https://code.juejin.cn/pen/7189592078207156285)\\n\\n\\n### 异步题2（改编）\\n\\n```\\nasync function async1() {\\n    console.log('async1 start');\\n    await async2();\\n    console.log('async1 end');\\n}\\nasync function async2() {\\n    //async2做出如下更改：\\n    new Promise(function(resolve) {\\n    console.log('promise1');\\n    resolve();\\n}).then(function() {\\n    console.log('promise2');\\n    });\\n}\\nconsole.log('script start');\\n\\nsetTimeout(function() {\\n    console.log('setTimeout');\\n}, 0)\\nasync1();\\n\\nnew Promise(function(resolve) {\\n    console.log('promise3');\\n    resolve();\\n}).then(function() {\\n    console.log('promise4');\\n});\\n\\nconsole.log('script end');\\n```\\n\\n可以先自己看看输出顺序会是什么，下面来公布结果：\\n\\n\\n```\\nscript start\\nasync1 start\\npromise1\\npromise3\\nscript end\\npromise2\\nasync1 end\\npromise4\\nsetTimeout\\n```\\n\\n\\n在第一次macrotask执行完之后，也就是输出`script end`之后，会去清理所有microtask。所以会相继输出`promise2`，` async1 end` ，`promise4`，其余不再多说。\\n\\n\\n### 异步题3（改编）\\n\\n  \\n\\n\\n在第二个变式中，我将async1中await后面的代码和async2的代码都改为异步的，代码如下：\\n\\n\\n```\\nasync function async1() {\\n    console.log('async1 start');\\n    await async2();\\n    //更改如下：\\n    setTimeout(function() {\\n        console.log('setTimeout1')\\n    },0)\\n}\\nasync function async2() {\\n    //更改如下：\\nsetTimeout(function() {\\n \\tconsole.log('setTimeout2')\\n },0)\\n}\\nconsole.log('script start');\\nsetTimeout(function() {\\n    console.log('setTimeout3');\\n}, 0)\\nasync1();\\nnew Promise(function(resolve) {\\n    console.log('promise1');\\n    resolve();\\n}).then(function() {\\n    console.log('promise2');\\n});\\nconsole.log('script end');\\n```\\n\\n  \\n\\n\\n可以先自己看看输出顺序会是什么，下面来公布结果：\\n\\n  \\n\\n\\n  \\n\\n\\n  \\n\\n\\n```\\nscript start\\nasync1 start\\npromise1\\nscript end\\npromise2\\nsetTimeout3\\nsetTimeout2\\nsetTimeout1\\n```\\n\\n  \\n\\n\\n在输出为`promise2`之后，接下来会按照加入setTimeout队列的顺序来依次输出，通过代码我们可以看到加入顺序为`3 2 1`，所以会按3，2，1的顺序来输出。\\n\\n  \\n\\n\\n### 异步题4（改编）\\n\\n变式三是我在一篇面经中看到的原题，整体来说大同小异，代码如下：\\n\\n  \\n\\n\\n```\\nasync function a1 () {\\n    console.log('a1 start')\\n    await a2()\\n    console.log('a1 end')\\n}\\nasync function a2 () {\\n    console.log('a2')\\n}\\nconsole.log('script start')\\nsetTimeout(() => {\\n    console.log('setTimeout')\\n}, 0)\\nPromise.resolve().then(() => {\\n    console.log('promise1')\\n})\\na1()\\nlet promise2 = new Promise((resolve) => {\\n    resolve('promise2.then')\\n    console.log('promise2')\\n})\\npromise2.then((res) => {\\n    console.log(res)\\n    Promise.resolve().then(() => {\\n        console.log('promise3')\\n    })\\n})\\nconsole.log('script end')\\n```\\n\\n  \\n\\n\\n  \\n\\n\\n  \\n\\n\\n无非是在微任务那块儿做点文章，前面的内容如果你都看懂了的话这道题一定没问题的，结果如下：\\n\\n  \\n\\n\\n  \\n\\n\\n  \\n\\n\\n```\\nscript start\\na1 start\\na2\\npromise2\\nscript end\\npromise1\\na1 end\\npromise2.then\\npromise3\\nsetTimeout\\n```\\n\\n如果看到这里的掘友，我相信你已经基本掌握了上面的内容，可以去网上再挑选一些题目再小试牛刀，验证自己的成功吧，嘿嘿😁\\n\\n# 预告\\n\\n后面我会针对入门级写个总结由浅入深去一一加深我们对宏任务和微任务的理解，欢迎点赞关注+收藏谢谢！\\n敬请期待！\\n\\n\\n",
        "tags": [
            "JavaScript",
            "前端",
            "Promise"
        ]
    },
    {
        "article_id": "7143142671920398373",
        "cover_image": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/977fcaa634ca4c2b972ee0e60754510c~tplv-k3u1fbpfcp-watermark.image?",
        "title": "推荐16个前端必备的实用工具与网站✨",
        "brief": "推荐16个前端必备的实用工具与网站。一些日常工作中比较实用的软件和网站，这些网站你平时工作中大概率是会用到的，感觉不错的话可以点赞收藏🤪🤪",
        "user_name": "前端老干部",
        "view_count": 51713,
        "collect_count": 2289,
        "comment_count": 79,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/1c916e528402aee0076c46a48f2cc138~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: jzman\\n---\\n“我报名参加金石计划1期挑战——瓜分10万奖池，这是我的第3篇文章，[点击查看活动详情](https://s.juejin.cn/ds/jooSN7t \\\"https://s.juejin.cn/ds/jooSN7t\\\")”\\n\\n分享一些日常工作中比较实用的软件和网站，这些网站你平时工作中大概率是会用到的，感觉不错的话可以点赞收藏🤪🤪\\n\\n## 1. [GitHub Desktop](https://desktop.github.com/)\\n对于新手来说，要记住那么多git命令可能有点困难，建议新手用git可视化工具，会方便很多\\n\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f8efb292fd347bd9aacde7a45489438~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## 2. [图片在线压缩](https://tinypng.com/)\\n[tinypng](https://tinypng.com/) 是一个完全免费并且高压缩率的在线压缩图片网站，一般能满足日常大部分压缩图片的需求，如果你需要压缩大于5M的图片，可以考虑用 [squoosh](https://squoosh.app/) ，这个网站支持大图片压缩和图片压缩质量自定义\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8665620d2c64cb2b1cbdabc4af802f6~tplv-k3u1fbpfcp-watermark.image?)\\n大图片压缩点这里：[squoosh](https://squoosh.app/) \\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dcacdd6e50c04387b8f72ed18a51d0f5~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n\\n## 3. [在线代码编辑](https://code.juejin.cn/)\\n很多人可能用的是 [codePen](https://codepen.io/) 或者 [CodeSandbox](https://codesandbox.io/) 等，但是我觉得掘金的码上掘金也挺好用的，并且登录自己的掘金账号就能看到，挺方便的\\n\\n![code.juejin.cn_.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef55aefbbc8d4b59b72b20ae8f0eb867~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## 4. [JSON格式化](https://smalldev.tools/)\\n\\nJSON在线格式化的网站有很多，基本上都能满足我们的需要，用 [Json.cn](https://www.json.cn/) 的原因只是因为他好记，哈哈~\\n\\n![1663138491509.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c4bec77122ab4e82a0d10b8b267eef75~tplv-k3u1fbpfcp-watermark.image?)\\n\\n另外还有个前端工具类集合的网站 [smalldev](https://smalldev.tools/) 也挺好用的\\n\\n\\n## 5. [代码生成图片](https://carbon.now.sh/)\\n[carbon](https://carbon.now.sh/) 可以生成酷炫的代码片段，并且支持导出图片\\n\\n![carbon.now.sh__bg=rgba%28171%2C+184%2C+195%2C+1%29&t=seti&wt=none&l=auto&width=680&ds=true&dsyoff=20px&dsblur=68px&wc=true&wa=true&pv=56px&ph=56px&ln=false&fl=1&fm=Hack&fs=14px&lh=133%25&si=false&es=2x&wm=fals.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c460d1b3a1444d4586837f0128516bc3~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n如果你不喜欢上面的代码风格，也可以用 [ray.so](https://ray.so/) ，生成的代码图如下:\\n\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/482213224c194e3a886a2dbe8963c657~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n## 6. [表情符号](https://www.emojiall.com/zh-hans)\\n这个网站有很多颜文字，并且可以直接cv，国内外很多博客用的都是这上面的表情符号\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a282b2d664504a86a3ca3478a5a78053~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n## 7. [矢量图标-iconfont](https://www.iconfont.cn/)\\n阿里阿巴巴推出的字体图标库，可以找到大部分的图标，并且可以结合项目去自定义自己项目的字体图标库\\n\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/646be4eaae1c4dbabd5dba24d28e4d89~tplv-k3u1fbpfcp-watermark.image?)\\n## 8. [css3动画](https://www.webhek.com/post/css3-animation-sniplet-collection/#/)\\n我们在日常开发中，会遇到一些css动画的需求，可是有时候为了一两个动画引入一些库感觉得不偿失，[css3-animation](https://www.webhek.com/post/css3-animation-sniplet-collection/#/) 包含了一些常见的动画效果，并且包含片段代码，直接cv就可以了\\n\\n![www.webhek.com_post_css3-animation-sniplet-collection_.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0cadada58c034a85900fe96210f0e1db~tplv-k3u1fbpfcp-watermark.image?)\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1b4bf85fda347a4a019166a5eb96bed~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## 9. [封面模板-canva](https://www.canva.cn/)\\n\\n我们在写文章或者有时候要自己制作一些封面图片，[canva](https://www.canva.cn/)上面有很多免费的素材和模板，用起来很方便\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d96b24bb5eb34ec3bb1d78ceceea7c81~tplv-k3u1fbpfcp-watermark.image?)\\n![未命名 (1303 × 734, 像素) (1).png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea446bd22b524ab4b89076c0d56d296b~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## 10. [高清图片-UnSplash](https://unsplash.com/)\\n国外的一个高清图片下载网站，里面有很多的4k高清图片免费下载，再也不用到处找高清图片了\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a37a7f2662df4a888a0c74d7f32f070c~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## 11. [在线画图](https://boardmix.cn/)\\n日常工作中我们要画一些流程图或者思维导图等等，[boardmix](https://boardmix.cn/) 个人用起来感觉还不错，也有人喜欢用ProcessOn等，看个人喜好\\n\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0316e931b2f34ebfb450811a3e634228~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## 12. [快速部署建站](https://surge.sh/)\\n前端有时候需要自己部署一个网站，我们可以自己去买服务器，也有免费的部署网站，如 [surge](https://surge.sh/)\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2430717194a441b8a594335db19ebfff~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## 13. [在线性能评测](https://pagespeed.web.dev/)\\n[pagespeed](https://pagespeed.web.dev/) 根据各项指标可以得出我们网站的一个综合评分，让我们知道我们的网站在那些方面还可以进行优化\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d2270bcf2e541a4a4c56478ed4bfec3~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## 14. [多平台测试](https://responsively.app/)\\n我们的网站经常要在各种设备下看下效果，可是用手机和浏览器去一个个访问截图又比较麻烦，[responsively](https://responsively.app/) 这个软件支持主流手机、PAD、电脑设备访问您的网站，并可以导出\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c9c24f906fa4d289a299d259e43841c~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## 15. [Chrome扩展组件](https://chrome.zzzmh.cn/)\\n有些同学不能翻墙登录google账号去Google商店下载扩展程序，[极简插件](https://chrome.zzzmh.cn/) 可以不翻墙直接下载Google扩展程序，而且网站是中文的，感觉很不错\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c7d647ea70240e5af8e12f9178a214a~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## 16. [在线简历](https://www.500d.me/)\\n简历这个东西找工作大家都是要用到的，网上也有很多免费的简历模板网站，个人推荐这个500丁网站，上面有很多好看的简历模板，很方便  \\nps：这个网站是收费的，不过永久会员39.9还行，不用担心过期，毕竟用到不止一次（如果实在不想花39.9，可以找我要下哈~）\\n\\n![www.500d.me_.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dbe56621619a4859853aef3e31137db4~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n上面就是和大家分享的平时日常工作中比较实用的一些工具和网站，如果感觉对你有用的话可以收藏一下。\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1642fbc4b7e5454a8e145246ff802bd9~tplv-k3u1fbpfcp-watermark.image?)\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8fa7b9afd98b4e23a2e48c051c7ff6d8~tplv-k3u1fbpfcp-watermark.image?)",
        "tags": [
            "前端",
            "Vue.js",
            "JavaScript"
        ]
    },
    {
        "article_id": "7176206226903007292",
        "cover_image": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d0e3a0b3d0b64d5793177f02d921c648~tplv-k3u1fbpfcp-watermark.image?",
        "title": "前端白屏的检测方案，让你知道自己的页面白了",
        "brief": "页面白屏，绝对是让前端开发者最为胆寒的事情，特别是随着 SPA 项目的盛行，前端白屏的情况变得更为复杂且棘手起来 这里的白屏是指页面一直处于白屏状态，要是能检测到页面白屏就太棒了……",
        "user_name": "海阔_天空",
        "view_count": 14228,
        "collect_count": 362,
        "comment_count": 44,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/855a56c7c01cfae34279302336d4cf15~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: juejin\\nhighlight: androidstudio\\n---\\n\\n## 前言\\n\\n页面白屏，绝对是让前端开发者最为胆寒的事情，特别是随着 SPA 项目的盛行，前端白屏的情况变得更为复杂且棘手起来（ 这里的白屏是指页面一直处于白屏状态 ）\\n\\n要是能检测到页面白屏就太棒了，开发者谁都不想成为最后一个知道自己页面白的人😥\\n\\n[web-see](https://github.com/xy-sea/web-see) 前端监控方案，提供了 **采样对比+白屏修正机制** 的检测方案，兼容有骨架屏、无骨架屏这两种情况，来解决开发者的白屏之忧\\n\\n## 知道页面白了，然后呢？\\n\\nweb-see 前端监控，会给每次页面访问生成一个唯一的uuid，当上报页面白屏后，开发者可以根据白屏的uuid，去监控后台查询该id下对应的代码报错、资源报错等信息，定位到具体的源码，帮助开发者快速解决白屏问题\\n\\n## 白屏检测方案的实现流程\\n\\n采样对比+白屏修正机制的主要流程：\\n\\n1、页面中间取17个采样点（如下图），利用 [elementsFromPoint](https://developer.mozilla.org/zh-CN/docs/Web/API/Document/elementsFromPoint) api 获取该坐标点下的 HTML 元素\\n\\n2、定义属于容器元素的集合，如 `['html', 'body', '#app', '#root']`\\n\\n3、判断17这个采样点是否在该容器集合中。说白了，就是判断采样点有没有内容；如果没有内容，该点的 dom 元素还是容器元素，若17个采样点都没有内容则算作白屏\\n\\n4、若初次判断是白屏，开启轮询检测，来确保白屏检测结果的正确性，直到页面的正常渲染\\n\\n采样点分布图（蓝色为采样点）：\\n\\n<img src=\\\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a54a4fb89de48038b4fcc091f5f6d31~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"point.png\\\" width=\\\"50%\\\" />\\n\\n## 如何使用\\n\\n```\\nimport webSee from 'web-see';\\n\\nVue.use(webSee, {\\n  dsn: 'http://localhost:8083/reportData', // 上报的地址\\n  apikey: 'project1', // 项目唯一的id\\n  userId: '89757', // 用户id\\n  silentWhiteScreen: true, // 开启白屏检测\\n  skeletonProject: true, // 项目是否有骨架屏\\n  whiteBoxElements: ['html', 'body', '#app', '#root'] // 白屏检测的容器列表\\n});\\n```\\n下面聊一聊具体的分析与实现\\n\\n## 白屏检测的难点\\n\\n1） 白屏原因的不确定\\n\\n从问题推导现象虽然能成功，但从现象去推导问题却走不通。白屏发生时，无法和具体某个报错联系起来，也可能根本没有报错，比如关键资源还没有加载完成\\n\\n导致白屏的原因，大致分两种：资源加载错误、代码执行错误\\n\\n2） 前端渲染方式的多样性\\n\\n前端页面渲染方式有多种，比如 客户端渲染 CSR 、服务端渲染 SSR 、静态页面生成 SSG 等，每种模式各不相同，白屏发生的情况也不尽相同\\n\\n很难用一种统一的标准去判断页面是否白了\\n\\n## 技术方案调研\\n\\n如何设计出一种，在准确性、通用型、易用性等方面均表现良好的检测方案呢？\\n\\n本文主要讨论 SPA 项目的白屏检测方案，包括有无骨架屏的两种情况\\n\\n### 方案一：检测根节点是否渲染\\n\\n原理很简单，在当前主流 SPA 框架下，DOM 一般挂载在一个根节点之下（比如 `<div id=\\\"app\\\"></div>` ），发生白屏后通常是根节点下所有 DOM 被卸载，该方法通过检测根节点下是否挂载 DOM，若无则证明白屏\\n\\n这是简单明了且有效的方案，但缺点也很明显：其一切建立在 `白屏 === 根节点下 DOM 被卸载` 成立的前提下，缺点是通用性较差，对于有骨架屏的情况束手无策\\n\\n### 方案二：Mutation Observer 监听 DOM 变化\\n\\n通过此 API 监听页面 DOM 变化，并告诉我们每次变化的 DOM 是被增加还是删除\\n\\n但这个方案有几个缺陷\\n\\n1）白屏不一定是 DOM 被卸载，也有可能是压根没渲染，且正常情况也有可能大量 DOM 被卸载\\n\\n2）遇到有骨架屏的项目，若页面从始至终就没变化，一直显示骨架屏，这种情况 Mutation Observer 也束手无策\\n\\n### 方案三：页面截图检测\\n\\n这种方式是基于[原生图片对比算法处理白屏检测](https://toutiao.io/posts/1siqlk0/preview)的 web 实现\\n\\n整体流程：对页面进行截图，将截图与一张纯白的图片做对比，判断两者是否足够相似\\n\\n但这个方案有几个缺陷：\\n\\n1、方案较为复杂，性能不高；一方面需要借助 canvas 实现前端截屏，同时需要借助复杂的算法对图片进行对比\\n\\n2、通用性较差，对于有骨架屏的项目，对比的样张要由纯白的图片替换成骨架屏的截图\\n\\n### 方案四：采样对比\\n\\n该方法是对页面取关键点，进行采样对比，在准确性、易用性等方面均表现良好，也是最终采用的方案\\n\\n对于有骨架屏的项目，通过对比前后获取的 dom 元素是否一致，来判断页面是否变化（这块后面专门讲解）\\n\\n采样对比代码：\\n\\n```\\n// 监听页面白屏\\nfunction whiteScreen() {\\n  // 页面加载完毕\\n  function onload(callback) {\\n    if (document.readyState === 'complete') {\\n      callback();\\n    } else {\\n      window.addEventListener('load', callback);\\n    }\\n  }\\n  // 定义外层容器元素的集合\\n  let containerElements = ['html', 'body', '#app', '#root'];\\n  // 容器元素个数\\n  let emptyPoints = 0;\\n  // 选中dom的名称\\n  function getSelector(element) {\\n    if (element.id) {\\n      return \\\"#\\\" + element.id;\\n    } else if (element.className) {// div home => div.home\\n      return \\\".\\\" + element.className.split(' ').filter(item => !!item).join('.');\\n    } else {\\n      return element.nodeName.toLowerCase();\\n    }\\n  }\\n  // 是否为容器节点\\n  function isContainer(element) {\\n    let selector = getSelector(element);\\n    if (containerElements.indexOf(selector) != -1) {\\n      emptyPoints++;\\n    }\\n  }\\n  onload(() => {\\n    // 页面加载完毕初始化\\n    for (let i = 1; i <= 9; i++) {\\n      let xElements = document.elementsFromPoint(window.innerWidth * i / 10, window.innerHeight / 2);\\n      let yElements = document.elementsFromPoint(window.innerWidth / 2, window.innerHeight * i / 10);\\n      isContainer(xElements[0]);\\n      // 中心点只计算一次\\n      if (i != 5) {\\n        isContainer(yElements[0]);\\n      }\\n    }\\n    // 17个点都是容器节点算作白屏\\n    if (emptyPoints == 17) {\\n      // 获取白屏信息\\n      console.log({\\n        status: 'error'\\n      });\\n    }\\n  }\\n}\\n```\\n\\n## 白屏修正机制\\n\\n若首次检测页面为白屏后，任务还没有完成，特别是手机端的项目，有可能是用户网络环境不好，关键的JS资源或接口请求还没有返回，导致的页面白屏\\n\\n需要使用轮询检测，来确保白屏检测结果的正确性，直到页面的正常渲染，这就是**白屏修正机制**\\n\\n白屏修正机制图例：\\n\\n![point.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d84a39a3d42041e18e6aa1190f9493d5~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\\n\\n轮询代码：\\n\\n```\\n// 采样对比\\nfunction sampling() {\\n  let emptyPoints = 0;\\n  ……\\n  // 页面正常渲染，停止轮询\\n  if (emptyPoints != 17) {\\n    if (window.whiteLoopTimer) {\\n      clearTimeout(window.whiteLoopTimer)\\n      window.whiteLoopTimer = null\\n    }\\n  } else {\\n    // 开启轮询\\n    if (!window.whiteLoopTimer) {\\n      whiteLoop()\\n    }\\n  }\\n  // 通过轮询不断修改之前的检测结果，直到页面正常渲染\\n  console.log({\\n    status: emptyPoints == 17 ? 'error' : 'ok'\\n  });\\n}\\n// 白屏轮询\\nfunction whiteLoop() {\\n  window.whiteLoopTimer = setInterval(() => {\\n    sampling()\\n  }, 1000)\\n}\\n```\\n\\n## 骨架屏\\n\\n对于有骨架屏的页面，用户打开页面后，先看到骨架屏，然后再显示正常的页面，来提升用户体验；但如果页面从始至终都显示骨架屏，也算是白屏的一种\\n\\n骨架屏示例：\\n\\n![skeleton.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a0860ca40b94fd7a5a3b9fed658dc71~tplv-k3u1fbpfcp-watermark.image?)\\n\\n### 骨架屏的原理\\n\\n无论 vue 还是 react，页面内容都是挂载到根节点上。常见的骨架屏插件，就是基于这种原理，在项目打包时将骨架屏的内容直接放到 html 文件的根节点中\\n\\n有骨架屏的html文件：\\n\\n![html.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e7cb826b21ee40a59c30971a5551c548~tplv-k3u1fbpfcp-watermark.image?)\\n\\n### 骨架屏的白屏检测\\n\\n上面的白屏检测方案对有骨架屏的项目失灵了，虽然页面一直显示骨架屏，但判断结果页面不是白屏，不符合我们的预期\\n\\n需要通过外部传参明确的告诉 SDK，该页面是不是有骨架屏，如果有骨架屏，通过对比前后获取的 dom 元素是否一致，来实现骨架屏的白屏检测\\n\\n完整代码：\\n\\n```\\n/**\\n * 检测页面是否白屏\\n * @param {function} callback - 回到函数获取检测结果\\n * @param {boolean} skeletonProject - 页面是否有骨架屏\\n * @param {array} whiteBoxElements - 容器列表，默认值为['html', 'body', '#app', '#root']\\n */\\nexport function openWhiteScreen(callback, { skeletonProject, whiteBoxElements }) {\\n  let _whiteLoopNum = 0;\\n  let _skeletonInitList = []; // 存储初次采样点\\n  let _skeletonNowList = []; // 存储当前采样点\\n\\n  // 项目有骨架屏\\n  if (skeletonProject) {\\n    if (document.readyState != 'complete') {\\n      sampling();\\n    }\\n  } else {\\n    // 页面加载完毕\\n    if (document.readyState === 'complete') {\\n      sampling();\\n    } else {\\n      window.addEventListener('load', sampling);\\n    }\\n  }\\n  // 选中dom点的名称\\n  function getSelector(element) {\\n    if (element.id) {\\n      return '#' + element.id;\\n    } else if (element.className) {\\n      // div home => div.home\\n      return ('.' + element.className.split(' ').filter(item => !!item).join('.'));\\n    } else {\\n      return element.nodeName.toLowerCase();\\n    }\\n  }\\n  // 判断采样点是否为容器节点\\n  function isContainer(element) {\\n    let selector = getSelector(element);\\n    if (skeletonProject) {\\n      _whiteLoopNum ? _skeletonNowList.push(selector) : _skeletonInitList.push(selector);\\n    }\\n    return whiteBoxElements.indexOf(selector) != -1;\\n  }\\n  // 采样对比\\n  function sampling() {\\n    let emptyPoints = 0;\\n    for (let i = 1; i <= 9; i++) {\\n      let xElements = document.elementsFromPoint(\\n        (window.innerWidth * i) / 10,\\n        window.innerHeight / 2\\n      );\\n      let yElements = document.elementsFromPoint(\\n        window.innerWidth / 2,\\n        (window.innerHeight * i) / 10\\n      );\\n      if (isContainer(xElements[0])) emptyPoints++;\\n      // 中心点只计算一次\\n      if (i != 5) {\\n        if (isContainer(yElements[0])) emptyPoints++;\\n      }\\n    }\\n    // 页面正常渲染，停止轮训\\n    if (emptyPoints != 17) {\\n      if (skeletonProject) {\\n        // 第一次不比较\\n        if (!_whiteLoopNum) return openWhiteLoop();\\n        // 比较前后dom是否一致\\n        if (_skeletonNowList.join() == _skeletonInitList.join())\\n          return callback({\\n            status: 'error'\\n          });\\n      }\\n      if (window._loopTimer) {\\n        clearTimeout(window._loopTimer);\\n        window._loopTimer = null;\\n      }\\n    } else {\\n      // 开启轮训\\n      if (!window._loopTimer) {\\n        openWhiteLoop();\\n      }\\n    }\\n    // 17个点都是容器节点算作白屏\\n    callback({\\n      status: emptyPoints == 17 ? 'error' : 'ok',\\n    });\\n  }\\n  // 开启白屏轮训\\n  function openWhiteLoop() {\\n    if (window._loopTimer) return;\\n    window._loopTimer = setInterval(() => {\\n      if (skeletonProject) {\\n        _whiteLoopNum++;\\n        _skeletonNowList = [];\\n      }\\n      sampling();\\n    }, 1000);\\n  }\\n}\\n\\n```\\n\\n如果不通过外部传参，SDK 能否自己判断是否有骨架屏呢？ 比如在页面初始的时候，根据根节点上有没有子节点来判断\\n\\n因为这套检测方案需要兼容 SSR 服务端渲染的项目，对于 SSR 项目来说，浏览器获取 html 文件的根节点上已经有了 dom 元素，所以最终采用外部传参的方式来区分\\n\\n## 总结\\n\\n这套白屏检测方案是从现象推导本质，可以覆盖绝大多数 SPA 项目的应用场景\\n\\n小伙们若有其他检测方案，欢迎多多讨论与交流 💕\\n\\n这是前端监控的第三篇文章，前两篇没有看过的小伙伴也建议了解下\\n\\n- [从0到1搭建前端监控平台，面试必备的亮点项目](https://juejin.cn/post/7172072612430872584)\\n\\n- [前端录屏+定位源码，帮你快速定位线上bug](https://juejin.cn/post/7173596154297810957)\\n\\n**参考资料**  \\n[如何实现前端白屏监控？](https://blog.csdn.net/xgangzai/article/details/118470550)  \\n[H5的白屏检测方案实践](https://juejin.cn/post/6904246603197415437)",
        "tags": [
            "前端",
            "监控",
            "JavaScript"
        ]
    },
    {
        "article_id": "7181761563336900669",
        "cover_image": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13dc2f403b4245e5a9be3a77302988db~tplv-k3u1fbpfcp-watermark.image?",
        "title": "2023年如何成为Web3开发者？详细聊聊Web3开发者的那些事",
        "brief": "最近和一些朋友闲聊，发现都对 Web3 很感兴趣，都想加入进来。但又找不到切入点。 这篇文章主要是和大家聊聊如何成为一名 Web3 开发者，以及 Web3 开发者的职业前景。",
        "user_name": "代码与野兽",
        "view_count": 2699,
        "collect_count": 70,
        "comment_count": 3,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/dac9f5ba3e7b6d8015a9b37536d4ef59~300x300.image",
        "category": "前端",
        "content": "# 难题\\n\\n最近和一些朋友闲聊，发现都对 Web3 很感兴趣，都想加入进来。但又找不到切入点。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4436f43014764cbb9a56421602f4d51a~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e047fcb813bd46b4b68636dae8ba6911~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n这篇文章主要是和大家聊聊如何成为一名 Web3 开发者。\\n\\n# 前景\\n\\n至于 Web3 开发者的职业前景，我就不多赘述了。可以看我之前的一些文章。\\n\\n这里可以简单看下目前 Web3 开发者的招聘市场和薪资情况。截图均来自我的朋友圈及我所接触的一些社区和平台。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/90de92640cff4ef8a6f83f51222ff0ba~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb883684a8d243739f79485dd8df4bd8~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/426139b46c2d4e2796e16c401d596485~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n可以看到，Web3 的要求并没有那么高，通常只需要 2 年以上的工作经验就可以拿到 Web2 中 5 年以上经验才拥有的待遇。\\n\\n为什么会这样？\\n\\nWeb3 目前仍然是蓝海，刚起步不久，开发者少，人才难招。\\n\\n就像 00 年前后，你即使只会用 html、css 和 js 简单画一个页面也仍然是难得的人才。\\n\\n而反观 Java、前端这些已经非常成熟的领域，人才泛滥，市场竞争激烈。你需要付出非常多的时间和精力才能在一众人群中脱颖而出。拿最成熟的 Java 招聘市场举例，这个领域有数不清的十几年架构经验的老程序员，他们具有先发优势，作为后起之秀的你很难在技术和经验上卷得过他们。\\n\\n但在如今的 Web3 开发者里面，竞争没有这么激烈。你现在加入进来，三年以后你就是大佬，五年以后你就是专家。\\n\\n# Web3 适合什么人？\\n\\n适合零基础小白，也适合具有前端、后端、数据库等经验的开发者。可以说，Web3 适合所有人。\\n\\n为什么这么说？我先分析一下 Web3 的技术架构。\\n\\n本质上 Web3 和 Web2 的架构没有太大区别，但是引入了一些概念。\\n\\n传统 Web2 架构是前端、后端、数据库。\\n\\n通常 Web3 架构是前端、后端、智能合约、区块链、去中心化存储。\\n\\nWeb2 的前端是和 API 交互，Web3 的前端不仅仅是和 API 交互，还要和 ABI 交互、和合约、区块链交互。\\n\\nWeb2 的后端是操作 DB，Web3 的前端是操作合约、区块链和去中心化存储。\\n\\nWeb2 的接口风格是 RESTFul，Web3 是 JSON-RPC。\\n\\n总而言之，Web3 不是一种新技术，而是将一堆技术进行框选，组合，形成的技术体系，在技术上，它并没有完全脱离 Web2。原来在 Web2 中的各种技术及经验，一样可以沿用到 Web3 的开发中。\\n\\n# 学习 Web3 技术有哪些难点？\\n\\n四个字：不成体系。\\n\\n说到底，Web3 毕竟是一个新事物，虽然它是建立在一堆旧事物上的。\\n\\n新事物在诞生之初都会伴随着非常多的变化。\\n\\n在这个过程中产生的一系列内容都只有很短的时效性。而且网络上的大部分内容只适合作为了解信息的一种渠道，很难成体系。\\n\\n体系是很重要的，在任何一种知识或者技术中都是非常重要的。所有高手都有自己的体系。\\n\\nWeb3 的中文资料很少，而且很多都很片面，而目前中国对待 Web3 这类技术的政策保持着冷眼旁观的态度，这导致无论是权威机构还是网络上的中文资料都很稀缺，而成体系的 Web3 资料更是少之又少。\\n\\n所以一个 Web3 成体系的学习资源对很多人是很有价值的。而我也在想办法整理一套这样的知识体系，帮助到更多需要的人。让 Web3 成为一种普惠的技术，不要再和下一个技术机遇擦肩而过。\\n\\n# 知识体系与学习路径\\n\\n目前我还在设计这套 Web3 的体系，不过在这之前我可以给大家推荐一下我目前设计的半成品。由于我设计的知识体系是对标全栈开发者，所以会涵盖 Web3 技术相关的方方面面。\\n\\n话不多说，下面是学习路径。\\n\\n## 1. 基本概念\\n\\n无论你是做前端、后端、智能合约还是全栈，都需要了解 Web3 中的基本概念。\\n\\n其中包括：Web3 原理、加密货币、区块链、钱包、交易所、区块链浏览器、智能合约、NFT、DApp、DAO、比特币底层原理及核心技术、以太坊底层原理及核心技术。\\n\\n当然不是所有内容都需要了解，有一些是根据你的具体情况选学的。\\n\\n但是有一些是你必须懂并且要操作的。\\n\\n比如如何注册一个钱包，MetaMask、rainbow、coinbase 这些主流钱包的基本使用。\\n\\n然后你要知道怎么样获取货币，交易所你要会用，区块链浏览器你要会看。\\n\\n你要懂什么是智能合约，以及智能合约基本的功能。\\n\\n## 2. 前端基础知识\\n\\n因为 DApp 也要有前端页面，所以你必须懂前端基础知识。这部分内容并不多。\\n\\n一款编辑器：VSCode。\\n\\n三门语言：HTML、CSS、JavaScript。\\n\\n一门非必选语言：TypeScript。\\n\\n## 3. 前端框架\\n\\n只学习前端基础知识确实能够开发一个 DApp 的前端，但要想 hold 住一个稍有规模的项目还是比较吃力的。这时需要学习一门框架。\\n\\n目前大多数 Web3 项目都会采用 Nextjs 框架，并使用 vercel 部署。\\n\\n而 Nextjs 框架又基于 React 库。\\n\\n所以这里你需要学习 React 和 Nextjs。\\n\\n当然你也可以学习 Angular、jQuery 这些库或者框架，但使用率没那么高，机会会少很多。\\n\\n## 4. 后端基础知识\\n\\n任何一门编程语言都可以充当 Web3 的后端，可以学习 Nodejs、Go、Java。\\n\\n这里推荐 Nodejs，因为是全栈，使用 Nodejs 的话可以前后端都只使用一门语言就可以了。\\n\\n## 5. 后端框架\\n\\nNextjs 可以写一些 API，使用 Nextjs 作为后端框架完全可以。\\n\\n当然也可以选择其他语言的框架，比如 Nodejs 的 express、koa；Java 的 Spring；Go 的 gin、Iris 等。\\n\\n## 6. 智能合约\\n\\n相对前面的内容，智能合约是一个全新的概念。\\n\\n你需要掌握 Remix 编辑器的使用，Solidity 语言的使用。还要学会一些工具，比如 Hardhat、Waffle、Ganache 和 Truffle，它们可以帮我们更好的完成智能合约编译、测试和部署工作。你还需要学习 OpenZeppelin，它是一个很棒的 Solidity 库。\\n\\n然后还需要学习各种协议标准以及它们的区别，比如 ERC20、ERC721 和 ERC1155 等。这是必不可少的基础。同时你还需要知道代理合约。\\n\\n同时你还需要了解一些 NaaS，比如 Alchemy、Infura、Tenderly 等。这些 NaaS 都提供了很多功能让你更好地完成你的 DApp 开发。\\n\\n## 7. 智能合约交互\\n\\n智能合约交互需要学习 Web3.js、Ethers.js 和 Wagmi 这三个主流的库。如果你使用 TypeScript，还需要学会使用 typechain 这个库。\\n\\nEthers.js 是我认为目前最好的智能合约交互库。\\n\\n如果你使用 nextjs 或 React 进行开发，那么 Wagmi 是更好的选择。\\n\\n## 8. 基础设施\\n\\n这部分内容比较杂，包括公链、域名系统、EVM、跨链桥、去中心化存储、IPFS、预言机等。\\n\\n但很多都是存在于概念上的，在技术上可能很少会接触到。\\n\\n但是像 IPFS 和预言机这种技术还是会用得到的。如果使用 IPFS 还要使用 Pinata 这类 Pin 服务。\\n\\n总结来说，基础设施除了一些原理性知识和概念外，主要是去中心化存储这项技术，它取代了传统数据库，用来存储体积大难以上链的数据。\\n\\n## 9. 应用生态\\n\\n这部分就是 Web3 真正发挥价值的地方了。\\n\\n你不能仅仅知道 Web3 的技术，还需要知道一些业务。\\n\\n包括了 DEX、稳定币、借贷平台、流动性质押、预测市场、NFT、DeFi、GameFi 等。\\n\\n当然作为开发者的话，这部分并非必学，以了解为主，如果你完全不了解，很难进行业务的开发。如果作为产品或者运营，就需要非常精通这些生态。\\n\\n以上就是我总结的知识体系，目前仍在不断丰富和完善中。\\n\\n我希望将我的经验分享给更多人，帮助一些人，成就一些人，改变一下这个行业，推动一下世界的进步。\\n\\n我正在参加掘金的年度人气创作者投票，如果方便希望可以帮我投票，非常感谢。\\n\\n网页和 App 都可以分别投很多票哦。\\n\\n可以点击我的头像后面的按钮进入投票，也可以点击下面的链接。你的投票对我非常重要！\\n\\n<https://rank.juejin.cn/rank/2022/writer/571401777717031?utm_campaign=annual_2022&utm_medium=self_web_share&utm_source=%E4%BB%A3%E7%A0%81%E4%B8%8E%E9%87%8E%E5%85%BD>\\n\\n我们是一群立志改变世界的人。而 Web3 是未来世界一大变数，我们想帮助更多人了解 Web3，如果你对 Web3 感兴趣，可以添加我的微信：LZQ20130415，邀你入群，一起沉淀、一起成长、一起拥抱未来。",
        "tags": [
            "前端",
            "后端",
            "web3"
        ]
    },
    {
        "article_id": "7184986079437520933",
        "cover_image": "",
        "title": "有意思，小程序还可以一键生成App！",
        "brief": "小程序≠微信小程序 说到小程序，大部分同学的第一反应，可能是微信小程序、支付宝小程序，确实，小程序的概念深入人心，并且已经被约定俗成的绑定到某些互联网公司的 APP 上。 但是，“小程序”并不是一个注",
        "user_name": "chokcoco",
        "view_count": 8965,
        "collect_count": 17,
        "comment_count": 7,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/d5909b97177d58b77d02a83a620abd18~300x300.image",
        "category": "前端",
        "content": "## 小程序≠微信小程序\\n\\n说到小程序，大部分同学的第一反应，可能是微信小程序、支付宝小程序，确实，小程序的概念深入人心，并且已经被约定俗成的绑定到某些互联网公司的 APP 上。\\n\\n**但是，“小程序”并不是一个注册商标，也不是哪一家的专利。**\\n\\n小程序作为一种人机交互的软件载体、一种数字内容格式、一种代码分发传播机制，也到了被商业机构“借鉴”采用的时刻。\\n\\n企业们不是已经一直在用小程序吗？不算。因为他们不过是作为某个互联网大平台的内容贡献者、参与者，“免费”向互联网平台提供了自己的内容与服务，成为了别人的“生态一员”，换取流量的转化，以触达更多的互联网消费者。\\n\\n小程序类技术的企业商用，**意味着：企业拥有了和互联网平台们类似的技术，能够以小程序这种技术载体、内容格式来开发自己的商业软件，从而享受这种技术带来的敏捷、轻量、极度松散耦合的好处。**\\n\\n进一步，企业还能自主运营自己的平台，对其中小程序内容的上下架、审核发布完全掌握，让自己的业务功能灵活发表和投放；更进一步的，一些企业还可以开放自己的这种平台能力，让合作伙伴的小程序内容上架到平台上，以更好的服务自己的存量客户，建立行业数字生态，极大程度提升自己的数字化连接能力。\\n\\n## 以小程序为载体的企业轻应用方案\\n\\n虽然互联网大厂并未将这部分小程序运行能力技术开放出来，但是我们也不必望而生羡，市面上早就推出了类似的技术能力，我们一般称之为**小程序容器技术**。\\n\\n今天要给大家分享的也正是目前在 GitHub 很热门的前端容器技术 ——  [FinClip](https://github.com/finogeeks) 。\\n\\n一句话介绍 FinClip ：可以让小程序脱离微信环境最快运行在自有APP中\\n\\n只需简单集成  FinClip SDK  , 即可在 iPhone、Android、Windows、Linux、macOS、统信等平台下的应用中运行你的小程序。\\n\\n未来小程序战火还要烧其他终端设备之上，这意味着，移动端、PC 端、车载设备、智能电视、智能手表、智能家居都能运行小程序了。\\n\\n此外 FinClip 支持小程序小游戏，，用户可以在集成了 FinClip SDK 的 App 内对小游戏**点开即玩，用完即走**。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/604a0bfc1f8543ada268418911bf3216~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n而且 `FinClip SDK` 极其轻量，应用在集成后安装包的体积仅仅增大了不到 3MB。\\n\\n我们率先来看看 FinClip 小程序 SDK 是如何工作的\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/23194ec5e94140acbb7acc7c459ec872~tplv-k3u1fbpfcp-zoom-1.image)\\n\\nFinClip 小程序 SDK 提供了一套可运行小程序业务代码的**安全沙箱与宿主环境**：\\n\\n+ **安全沙箱**负责保护小程序中的业务应用，在安全可信的环境中传输数据，避免第三方的干扰与窃听；\\n\\n+ **宿主环境**负责执行小程序 JS 业务逻辑代码，并使用 WebView 渲染展示小程序页面。\\n\\n其次，FinClip 则主要由 3 个模块构成  \\n\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5cebd85ba16c4833968f849ff2546562~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n1. **云侧**代表 FinClip 小程序管理后台，可管理小程序的开发、上架等全生命周期进行；\\n\\n2. **端侧**代表FinClip 小程序 SDK，代表集成了 FinClip 小程序 SDK 的移动 App 或各类智能设备，用于向其提供能够运行小程序的能力；\\n\\n3. **开发者工具**则主要用于编写，调试，上传，预览小程序代码。\\n\\n此外，下面这个功能特性需要重点强调一下， `FinClip` 支持微信小程序语法 WXML，也就是说微信小程序代码可以直接在 FinClip 复用，无需再二次开发，体验与微信端保持一致。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/29527200d2714f6880e4be7f2aebaabb~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n`FinClip` 还自研了一个 小程序 IDE 开发工具，界面与微信小程序的开发工具类似，自带调试和真机预览，简单易上手。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97282ae2dfd74a63b1a8182f9847fe99~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n你可以在这个 `FinClip IDE` 里面，对现有项目进行二次开发，扩展功能和接口。\\n\\n同时，它还支持 小程序一键转换成 App，可以将已有小程序代码导出为 IOS 与 Android 中可用的工程文件,并上架至各应用市场 。由于导出的工程文件自动集成了  FinClip  SDK ，所以直接拥有小程序的运行能力，后续可在这个 APP 上继续上架更多小程序，自建自己的小程序生态。\\n\\n![Image](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eee09debf73f469eb37a8379dc28b943~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n并且 FIDE 中还包含各类扩展插件和接口（支付、人脸识别、音视频、OCR 等），开发者可自主勾选所需的支持插件，从而增强所生成 App 原生能力。\\n\\n最后简单总结一下 `FinClip` 可以帮助企业/开发者实现什么：\\n\\n+ **促进连接**：只要把FinClip SDK嵌入到自己的App中，马上获得小程序运行能力。小程序已经在互联网上被充分证明是一个非常有效的促进连接的技术形态。\\n\\n+ **动态更新**：借助 FinClip 将应用中业务功能均以小程序形式替代，功能模块互相解耦，实现模块化开发，极大的提升开发效率，降低开发成本。\\n\\n+ **多端支持**：同一个业务场景，小程序化之后，可以展现在手机端、也可以运行在PC端、更可以出现在智能电视和车载大屏上，多端同步、转发分享、一致体验，甚至可以无缝对接至互联网公共平台，代码只写一次，多处运行。\\n\\n+ **生态共建**：让开发者、企业拥有自己的小程序应用商店，在这里可以实现与合作伙伴的资源整合 - 例如让合作伙伴把数字服务以小程序方式上架、投放到自己的App中。\\n\\n## 总结一下\\n\\n`FinClip` 的技术方案，目的就是要让任何行业的任何企业，均可以拥有自主打造小程序生态、发布管理小程序内容、在自己的各终端App中运行小程序的能力。\\n\\n那 `FinClip` 是不是可以免费使用？是的，目前 FinClip SaaS 版开箱即用，欢迎各位开发者体验反馈。\\n\\n可以猛戳这里：[Link - FinClip](https://www.finclip.com/)\\n\\n好了，本文到此结束，希望本文对你有所帮助 :)\\n\\n如果还有什么疑问或者建议，可以多多交流文笔有限，文中若有不正之处，万望告知。",
        "tags": [
            "前端",
            "架构",
            "微信小程序"
        ]
    },
    {
        "article_id": "7172072612430872584",
        "cover_image": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b17a865fbda46e0ac9c4ab41fddd1cf~tplv-k3u1fbpfcp-watermark.image?",
        "title": "从0到1搭建前端监控平台，面试必备的亮点项目",
        "brief": "常常会苦恼，平常做的项目很普通，没啥亮点；面试中也经常会被问到：做过哪些亮点项目吗？ 前端监控就是一个很有亮点的项目，各个大厂都有自己的内部实现，没有监控的项目就是在裸奔",
        "user_name": "海阔_天空",
        "view_count": 14111,
        "collect_count": 963,
        "comment_count": 49,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/855a56c7c01cfae34279302336d4cf15~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: juejin\\nhighlight: androidstudio\\n---\\n\\n## 前言\\n \\n常常会苦恼，平常做的项目很普通，没啥亮点；面试中也经常会被问到：做过哪些亮点项目吗？\\n\\n前端监控就是一个很有亮点的项目，各个大厂都有自己的内部实现，没有监控的项目好比是在裸奔\\n\\n文章分成以下六部分来介绍：\\n\\n- 自研监控平台解决了哪些痛点，实现了什么亮点功能？\\n \\n- 相比sentry等监控方案，自研监控的优势有哪些？\\n\\n- 前端监控的设计方案、监控的目的\\n\\n- 数据的采集方式：错误信息、性能数据、用户行为、加载资源、个性化指标等\\n  \\n- 设计开发一个完整的监控SDK\\n\\n- 监控后台错误还原演示示例\\n\\n## 痛点\\n\\n某⼀天用户：xx商品无法下单！  \\n⼜⼀天运营：xx广告在手机端打开不了！  \\n\\n大家反馈的bug，怎么都复现不出来，尴尬的要死！😢\\n\\n如何记录项目的错误，并将错误还原出来，这是监控平台要解决的痛点之一\\n\\n## 错误还原\\n\\n[web-see](https://github.com/xy-sea/web-see) 监控提供三种错误还原方式：定位源码、播放录屏、记录用户行为\\n\\n### 定位源码\\n\\n项目出错，要是能定位到源码就好了，可线上的项目都是打包后的代码，也不能把 .map 文件放到线上\\n\\n监控平台通过 [source-map](https://github.com/mozilla/source-map) 可以实现该功能\\n\\n最终效果：\\n\\n![errorCode.jpg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/026bbc81cf4843b6a0671c89a52e8513~tplv-k3u1fbpfcp-watermark.image?)\\n\\n### 播放录屏\\n\\n多数场景下，定位到具体的源码，就可以定位bug，但如果是用户做了异常操作，或者是在某些复杂操作下才出现的bug，仅仅通过定位源码，还是不能还原错误\\n\\n要是能把用户的操作都录制下来，然后通过回放来还原错误就好了\\n\\n监控平台通过 [rrweb](https://github.com/rrweb-io/rrweb) 可以实现该功能\\n\\n最终效果：\\n![record.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0eb30a82a89e457182b9fde875757e80~tplv-k3u1fbpfcp-watermark.image?)\\n\\n回放的录屏中，记录了用户的所有操作，红色的线代表了鼠标的移动轨迹\\n\\n前端录屏确实是件很酷的事情，但是不能走极端，如果把用户的所有操作都录制下来，是没有意义的\\n\\n我们更关注的是，页面报错的时候用户做了哪些操作，所以监控平台只把报错前10s的视频保存下来（单次录屏时长也可以自定义）\\n\\n### 记录用户行为\\n\\n通过 定位源码 + 播放录屏 这套组合，还原错误应该够用了，同时监控平台也提供了 记录用户行为 这种方式\\n\\n假如用户做了很多操作，操作的间隔超过了单次录屏时长，录制的视频可能是不完整的，此时可以借助用户行为来分析用户的操作，帮助复现bug\\n\\n最终效果：\\n![userlist.jpg](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30f7c0f6e99d4f1d81def0c37a86e1ca~tplv-k3u1fbpfcp-watermark.image?)\\n\\n用户行为列表记录了：鼠标点击、接口调用、资源加载、页面路由变化、代码报错等信息\\n\\n通过 `定位源码、播放录屏、记录用户行为` 这三板斧，解决了复现bug的痛点\\n\\n## 自研监控的优势\\n\\n为什么不直接用sentry私有化部署，而选择自研前端监控？\\n\\n这是优先要思考的问题，sentry作为前端监控的行业标杆，有很多可以借鉴的地方\\n\\n相比sentry，自研监控平台的优势在于：\\n\\n1、可以将公司的SDK统一成一个，包括但不限于：监控SDK、埋点SDK、录屏SDK、广告SDK等\\n\\n2、提供了更多的错误还原方式，同时错误信息可以和埋点信息联动，便可拿到更细致的用户行为栈，更快的排查线上错误\\n\\n3、监控自定义的个性化指标：如 long task、memory页面内存、首屏加载时间等。过多的长任务会造成页面丢帧、卡顿；过大的内存可能会造成低端机器的卡死、崩溃\\n\\n4、统计资源缓存率，来判断项目的缓存策略是否合理，提升缓存率可以减少服务器压力，也可以提升页面的打开速度\\n\\n5、提供了 **采样对比+ 轮询修正机制** 的白屏检测方案，用于检测页面是否一直处于白屏状态，让开发者知道页面什么时候白了，具体实现见 [前端白屏的检测方案，解决你的线上之忧](https://juejin.cn/post/7176206226903007292)\\n\\n## 设计思路\\n\\n一个完整的前端监控平台包括三个部分：数据采集与上报、数据分析和存储、数据展示\\n\\n![system.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2111ab12f74546a9b570ea8f5fd52cc9~tplv-k3u1fbpfcp-watermark.image?)\\n\\n### 监控目的\\n\\n![title.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b17a43984e3945199c6c4fcad74ec6f6~tplv-k3u1fbpfcp-watermark.image?)\\n\\n### 异常分析\\n\\n按照 5W1H 法则来分析前端异常，需要知道以下信息\\n\\n1.  What，发⽣了什么错误：JS错误、异步错误、资源加载、接口错误等\\n2.  When，出现的时间段，如时间戳\\n3.  Who，影响了多少用户，包括报错事件数、IP\\n4.  Where，出现的页面是哪些，包括页面、对应的设备信息\\n5.  Why，错误的原因是为什么，包括错误堆栈、⾏列、SourceMap、异常录屏\\n6.  How，如何定位还原问题，如何异常报警，避免类似的错误发生\\n\\n## 错误数据采集\\n\\n错误信息是最基础也是最重要的数据，错误信息主要分为下面几类：\\n\\n-   JS 代码运行错误、语法错误等\\n-   异步错误等\\n-   静态资源加载错误\\n-   接口请求报错\\n\\n### 错误捕获方式\\n\\n1）try/catch\\n\\n只能捕获代码常规的运行错误，语法错误和异步错误不能捕获到\\n\\n示例：\\n```\\n// 示例1：常规运行时错误，可以捕获 ✅\\n try {\\n   let a = undefined;\\n   if (a.length) {\\n     console.log('111');\\n   }\\n } catch (e) {\\n   console.log('捕获到异常：', e);\\n}\\n\\n// 示例2：语法错误，不能捕获 ❌  \\ntry {\\n  const notdefined,\\n} catch(e) {\\n  console.log('捕获不到异常：', 'Uncaught SyntaxError');\\n}\\n  \\n// 示例3：异步错误，不能捕获 ❌\\ntry {\\n  setTimeout(() => {\\n    console.log(notdefined);\\n  }, 0)\\n} catch(e) {\\n  console.log('捕获不到异常：', 'Uncaught ReferenceError');\\n}\\n```\\n\\n2） window.onerror\\n\\nwindow.onerror 可以捕获常规错误、异步错误，但不能捕获资源错误\\n\\n```\\n/**\\n* @param { string } message 错误信息\\n* @param { string } source 发生错误的脚本URL\\n* @param { number } lineno 发生错误的行号\\n* @param { number } colno 发生错误的列号\\n* @param { object } error Error对象\\n*/\\nwindow.onerror = function(message, source, lineno, colno, error) {\\n   console.log('捕获到的错误信息是：', message, source, lineno, colno, error )\\n}\\n```\\n\\n示例：\\n\\n```\\nwindow.onerror = function(message, source, lineno, colno, error) {\\n  console.log(\\\"捕获到的错误信息是：\\\", message, source, lineno, colno, error);\\n};\\n\\n// 示例1：常规运行时错误，可以捕获 ✅\\nconsole.log(notdefined);\\n\\n// 示例2：语法错误，不能捕获 ❌\\nconst notdefined;\\n\\n// 示例3：异步错误，可以捕获 ✅\\nsetTimeout(() => {\\n  console.log(notdefined);\\n}, 0);\\n\\n// 示例4：资源错误，不能捕获 ❌\\nlet script = document.createElement(\\\"script\\\");\\nscript.type = \\\"text/javascript\\\";\\nscript.src = \\\"https://www.test.com/index.js\\\";\\ndocument.body.appendChild(script);\\n```\\n\\n3） window.addEventListener\\n\\n当静态资源加载失败时，会触发 error 事件， 此时 window.onerror 不能捕获到\\n\\n示例：\\n```\\n<!DOCTYPE html>\\n<html lang=\\\"en\\\">\\n<head>\\n  <meta charset=\\\"UTF-8\\\">\\n</head>\\n<script>\\n  window.addEventListener('error', (error) => {\\n    console.log('捕获到异常：', error);\\n  }, true)\\n</script>\\n\\n<!-- 图片、script、css加载错误，都能被捕获 ✅ -->\\n<img src=\\\"https://test.cn/×××.png\\\">\\n<script src=\\\"https://test.cn/×××.js\\\"></script>\\n<link href=\\\"https://test.cn/×××.css\\\" rel=\\\"stylesheet\\\" />\\n\\n<script>\\n  // new Image错误，不能捕获 ❌\\n  // new Image运用的比较少，可以自己单独处理\\n  new Image().src = 'https://test.cn/×××.png'\\n</script>\\n</html>\\n```\\n\\n4）Promise错误\\n\\nPromise中抛出的错误，无法被 window.onerror、try/catch、 error 事件捕获到，可通过 unhandledrejection 事件来处理\\n\\n示例：\\n\\n```\\ntry {\\n  new Promise((resolve, reject) => {\\n    JSON.parse(\\\"\\\");\\n    resolve();\\n  });\\n} catch (err) {\\n  // try/catch 不能捕获Promise中错误 ❌\\n  console.error(\\\"in try catch\\\", err);\\n}\\n\\n// error事件 不能捕获Promise中错误 ❌\\nwindow.addEventListener(\\n  \\\"error\\\",\\n  error => {\\n    console.log(\\\"捕获到异常：\\\", error);\\n  },\\n  true\\n);\\n\\n// window.onerror 不能捕获Promise中错误 ❌\\nwindow.onerror = function(message, source, lineno, colno, error) {\\n  console.log(\\\"捕获到异常：\\\", { message, source, lineno, colno, error });\\n};\\n\\n// unhandledrejection 可以捕获Promise中的错误 ✅\\nwindow.addEventListener(\\\"unhandledrejection\\\", function(e) {\\n  console.log(\\\"捕获到异常\\\", e);\\n  // preventDefault阻止传播，不会在控制台打印\\n  e.preventDefault();\\n});\\n\\n```\\n\\n### Vue 错误\\n\\nVue项目中，window.onerror 和 error 事件不能捕获到常规的代码错误\\n\\n异常代码：\\n\\n```\\nexport default {\\n  created() {\\n    let a = null;\\n    if(a.length > 1) {\\n        // ...\\n    }\\n  }\\n};\\n```\\n\\nmain.js中添加捕获代码：\\n\\n```\\nwindow.addEventListener('error', (error) => {\\n  console.log('error', error);\\n});\\nwindow.onerror = function (msg, url, line, col, error) {\\n  console.log('onerror', msg, url, line, col, error);\\n};\\n```\\n\\n控制台会报错，但是 window.onerror 和 error 不能捕获到\\n\\n![error.jpg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a466fa1a02fb44b6b03f476a4bd066b1~tplv-k3u1fbpfcp-watermark.image?)\\n\\nvue 通过 `Vue.config.errorHander` 来捕获异常：\\n\\n```\\nVue.config.errorHandler = (err, vm, info) => {\\n    console.log('进来啦~', err);\\n}\\n```\\n\\n控制台打印:\\n\\n![error2.jpg](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/60cea7b4e84d4f699f11854feac23639~tplv-k3u1fbpfcp-watermark.image?)\\n\\n**errorHandler源码分析**\\n\\n在`src/core/util`目录下，有一个`error.js`文件\\n\\n```\\nfunction globalHandleError (err, vm, info) {\\n  // 获取全局配置，判断是否设置处理函数，默认undefined\\n  // 配置config.errorHandler方法\\n  if (config.errorHandler) {\\n    try {\\n      // 执行 errorHandler\\n      return config.errorHandler.call(null, err, vm, info)\\n    } catch (e) {\\n      // 如果开发者在errorHandler函数中，手动抛出同样错误信息throw err，判断err信息是否相等，避免log两次\\n      if (e !== err) {\\n        logError(e, null, 'config.errorHandler')\\n      }\\n    }\\n  }\\n  // 没有配置，常规输出\\n  logError(err, vm, info)\\n}\\n\\nfunction logError (err, vm, info) {\\n  if (process.env.NODE_ENV !== 'production') {\\n    warn(`Error in ${info}: \\\"${err.toString()}\\\"`, vm)\\n  }\\n  /* istanbul ignore else */\\n  if ((inBrowser || inWeex) && typeof console !== 'undefined') {\\n    console.error(err)\\n  } else {\\n    throw err\\n  }\\n}\\n```\\n\\n通过源码明白了，vue 使用 try/catch 来捕获常规代码的报错，被捕获的错误会通过 console.error 输出而避免应用崩溃\\n\\n可以在 Vue.config.errorHandler 中将捕获的错误上报\\n\\n```\\nVue.config.errorHandler = function (err, vm, info) { \\n  // handleError方法用来处理错误并上报\\n  handleError(err);\\n}\\n```\\n\\n### React 错误\\n\\n从 react16 开始，官方提供了 ErrorBoundary 错误边界的功能，被该组件包裹的子组件，render 函数报错时会触发离当前组件最近父组件的ErrorBoundary\\n\\n生产环境，一旦被 ErrorBoundary 捕获的错误，也不会触发全局的 window.onerror 和 error 事件\\n\\n父组件代码：\\n\\n```\\nimport React from 'react';\\nimport Child from './Child.js';\\n\\n// window.onerror 不能捕获render函数的错误 ❌\\nwindow.onerror = function (err, msg, c, l) {\\n  console.log('err', err, msg);\\n};\\n\\n// error 不能render函数的错误 ❌\\nwindow.addEventListener( 'error', (error) => {\\n    console.log('捕获到异常：', error);\\n  },true\\n);\\n\\nclass ErrorBoundary extends React.Component {\\n  constructor(props) {\\n    super(props);\\n    this.state = { hasError: false };\\n  }\\n\\n  static getDerivedStateFromError(error) {\\n    // 更新 state 使下一次渲染能够显示降级后的 UI\\n    return { hasError: true };\\n  }\\n  componentDidCatch(error, errorInfo) {\\n    // componentDidCatch 可以捕获render函数的错误 \\n    console.log(error, errorInfo)\\n    \\n    // 同样可以将错误日志上报给服务器\\n    reportError(error, errorInfo);\\n  }\\n  render() {\\n    if (this.state.hasError) {\\n      // 自定义降级后的 UI 并渲染\\n      return <h1>Something went wrong.</h1>;\\n    }\\n    return this.props.children;\\n  }\\n}\\n\\nfunction Parent() {\\n  return (\\n    <div>\\n      父组件\\n      <ErrorBoundary>\\n        <Child />\\n      </ErrorBoundary>\\n    </div>\\n  );\\n}\\n\\nexport default Parent;\\n```\\n\\n子组件代码：\\n\\n```\\n// 子组件 渲染出错\\nfunction Child() {\\n  let list = {};\\n  return (\\n    <div>\\n      子组件\\n      {list.map((item, key) => (\\n        <span key={key}>{item}</span>\\n      ))}\\n    </div>\\n  );\\n}\\nexport default Child;\\n```\\n\\n同vue项目的处理类似，react项目中，可以在 componentDidCatch 中将捕获的错误上报\\n\\n```\\ncomponentDidCatch(error, errorInfo) {\\n  // handleError方法用来处理错误并上报\\n  handleError(err);\\n}\\n```\\n\\n### 跨域问题\\n\\n如果当前页面中，引入了其他域名的JS资源，如果资源出现错误，error 事件只会监测到一个 `script error` 的异常。\\n\\n示例：\\n\\n```\\nwindow.addEventListener(\\\"error\\\", error => { \\n  console.log(\\\"捕获到异常：\\\", error);\\n}, true );\\n\\n// 当前页面加载其他域的资源，如https://www.test.com/index.js\\n<script src=\\\"https://www.test.com/index.js\\\"></script>\\n\\n// 加载的https://www.test.com/index.js的代码\\nfunction fn() {\\n  JSON.parse(\\\"\\\");\\n}\\nfn();\\n```\\n\\n报错信息：\\n\\n![scriptError.jpg](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d3a64682d05414e9e4c7a17a78895f4~tplv-k3u1fbpfcp-watermark.image?)\\n\\n只能捕获到 `script error` 的原因：\\n\\n是由于浏览器基于`安全考虑`，故意隐藏了其它域JS文件抛出的具体错误信息，这样可以有效避免敏感信息无意中被第三方(不受控制的)脚本捕获到，因此，浏览器只允许同域下的脚本捕获具体的错误信息\\n\\n解决方法：\\n\\n前端script加crossorigin，后端配置 Access-Control-Allow-Origin\\n\\n```\\n<script src=\\\"https://www.test.com/index.js\\\" crossorigin></script>\\n```\\n\\n添加 crossorigin 后可以捕获到完整的报错信息：\\n\\n![ScriptError1.jpg](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5f78998ae48140bebbae82ce6f073536~tplv-k3u1fbpfcp-watermark.image?)\\n\\n如果不能修改服务端的请求头，可以考虑通过使用 try/catch 绕过，将错误抛出\\n\\n```\\n<!doctype html>\\n<html>\\n<body>\\n  <script src=\\\"https://www.test.com/index.js\\\"></script>\\n  <script>\\n  window.addEventListener(\\\"error\\\", error => { \\n    console.log(\\\"捕获到异常：\\\", error);\\n  }, true );\\n  \\n  try {\\n    // 调用https://www.test.com/index.js中定义的fn方法\\n    fn(); \\n  } catch (e) {\\n    throw e;\\n  }\\n  </script>\\n</body>\\n</html>\\n```\\n\\n### 接口错误\\n\\n接口监控的实现原理：针对浏览器内置的 XMLHttpRequest、fetch 对象，利用 AOP 切片编程重写该方法，实现对请求的接口拦截，从而获取接口报错的情况并上报\\n\\n1）拦截XMLHttpRequest请求示例：\\n\\n```\\nfunction xhrReplace() {\\n  if (!(\\\"XMLHttpRequest\\\" in window)) {\\n    return;\\n  }\\n  const originalXhrProto = XMLHttpRequest.prototype;\\n  // 重写XMLHttpRequest 原型上的open方法\\n  replaceAop(originalXhrProto, \\\"open\\\", originalOpen => {\\n    return function(...args) {\\n      // 获取请求的信息\\n      this._xhr = {\\n        method: typeof args[0] === \\\"string\\\" ? args[0].toUpperCase() : args[0],\\n        url: args[1],\\n        startTime: new Date().getTime(),\\n        type: \\\"xhr\\\"\\n      };\\n      // 执行原始的open方法\\n      originalOpen.apply(this, args);\\n    };\\n  });\\n  // 重写XMLHttpRequest 原型上的send方法\\n  replaceAop(originalXhrProto, \\\"send\\\", originalSend => {\\n    return function(...args) {\\n      // 当请求结束时触发，无论请求成功还是失败都会触发\\n      this.addEventListener(\\\"loadend\\\", () => {\\n        const { responseType, response, status } = this;\\n        const endTime = new Date().getTime();\\n        this._xhr.reqData = args[0];\\n        this._xhr.status = status;\\n        if ([\\\"\\\", \\\"json\\\", \\\"text\\\"].indexOf(responseType) !== -1) {\\n          this._xhr.responseText =\\n            typeof response === \\\"object\\\" ? JSON.stringify(response) : response;\\n        }\\n        // 获取接口的请求时长\\n        this._xhr.elapsedTime = endTime - this._xhr.startTime;\\n\\n        // 上报xhr接口数据\\n        reportData(this._xhr);\\n      });\\n      // 执行原始的send方法\\n      originalSend.apply(this, args);\\n    };\\n  });\\n}\\n\\n/**\\n * 重写指定的方法\\n * @param { object } source 重写的对象\\n * @param { string } name 重写的属性\\n * @param { function } fn 拦截的函数\\n */\\nfunction replaceAop(source, name, fn) {\\n  if (source === undefined) return;\\n  if (name in source) {\\n    var original = source[name];\\n    var wrapped = fn(original);\\n    if (typeof wrapped === \\\"function\\\") {\\n      source[name] = wrapped;\\n    }\\n  }\\n}\\n```\\n\\n2）拦截fetch请求示例：\\n\\n```\\nfunction fetchReplace() {\\n  if (!(\\\"fetch\\\" in window)) {\\n    return;\\n  }\\n  // 重写fetch方法\\n  replaceAop(window, \\\"fetch\\\", originalFetch => {\\n    return function(url, config) {\\n      const sTime = new Date().getTime();\\n      const method = (config && config.method) || \\\"GET\\\";\\n      let handlerData = {\\n        type: \\\"fetch\\\",\\n        method,\\n        reqData: config && config.body,\\n        url\\n      };\\n\\n      return originalFetch.apply(window, [url, config]).then(\\n        res => {\\n          // res.clone克隆，防止被标记已消费\\n          const tempRes = res.clone();\\n          const eTime = new Date().getTime();\\n          handlerData = {\\n            ...handlerData,\\n            elapsedTime: eTime - sTime,\\n            status: tempRes.status\\n          };\\n          tempRes.text().then(data => {\\n            handlerData.responseText = data;\\n            // 上报fetch接口数据\\n            reportData(handlerData);\\n          });\\n\\n          // 返回原始的结果，外部继续使用then接收\\n          return res;\\n        },\\n        err => {\\n          const eTime = new Date().getTime();\\n          handlerData = {\\n            ...handlerData,\\n            elapsedTime: eTime - sTime,\\n            status: 0\\n          };\\n          // 上报fetch接口数据\\n          reportData(handlerData);\\n          throw err;\\n        }\\n      );\\n    };\\n  });\\n}\\n```\\n\\n## 性能数据采集\\n\\n谈到性能数据采集，就会提及加载过程模型图：\\n\\n![timing.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d47107de71349518cf4f43e6508fa3a~tplv-k3u1fbpfcp-watermark.image?)\\n\\n以Spa页面来说，页面的加载过程大致是这样的：\\n\\n![spa.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93ee1530332a432b904eb3f6af65cc7a~tplv-k3u1fbpfcp-watermark.image?)\\n\\n包括dns查询、建立tcp连接、发送http请求、返回html文档、html文档解析等阶段\\n\\n最初，可以通过 `window.performance.timing` 来获取加载过程模型中各个阶段的耗时数据\\n\\n```\\n// window.performance.timing 各字段说明\\n{\\n    navigationStart,  // 同一个浏览器上下文中，上一个文档结束时的时间戳。如果没有上一个文档，这个值会和 fetchStart 相同。\\n    unloadEventStart,  // 上一个文档 unload 事件触发时的时间戳。如果没有上一个文档，为 0。\\n    unloadEventEnd, // 上一个文档 unload 事件结束时的时间戳。如果没有上一个文档，为 0。\\n    redirectStart, // 表示第一个 http 重定向开始时的时间戳。如果没有重定向或者有一个非同源的重定向，为 0。\\n    redirectEnd, // 表示最后一个 http 重定向结束时的时间戳。如果没有重定向或者有一个非同源的重定向，为 0。\\n    fetchStart, // 表示浏览器准备好使用 http 请求来获取文档的时间戳。这个时间点会在检查任何缓存之前。\\n    domainLookupStart, // 域名查询开始的时间戳。如果使用了持久连接或者本地有缓存，这个值会和 fetchStart 相同。\\n    domainLookupEnd, // 域名查询结束的时间戳。如果使用了持久连接或者本地有缓存，这个值会和 fetchStart 相同。\\n    connectStart, // http 请求向服务器发送连接请求时的时间戳。如果使用了持久连接，这个值会和 fetchStart 相同。\\n    connectEnd, // 浏览器和服务器之前建立连接的时间戳，所有握手和认证过程全部结束。如果使用了持久连接，这个值会和 fetchStart 相同。\\n    secureConnectionStart, // 浏览器与服务器开始安全链接的握手时的时间戳。如果当前网页不要求安全连接，返回 0。\\n    requestStart, // 浏览器向服务器发起 http 请求(或者读取本地缓存)时的时间戳，即获取 html 文档。\\n    responseStart, // 浏览器从服务器接收到第一个字节时的时间戳。\\n    responseEnd, // 浏览器从服务器接受到最后一个字节时的时间戳。\\n    domLoading, // dom 结构开始解析的时间戳，document.readyState 的值为 loading。\\n    domInteractive, // dom 结构解析结束，开始加载内嵌资源的时间戳，document.readyState 的状态为 interactive。\\n    domContentLoadedEventStart, // DOMContentLoaded 事件触发时的时间戳，所有需要执行的脚本执行完毕。\\n    domContentLoadedEventEnd,  // DOMContentLoaded 事件结束时的时间戳\\n    domComplete, // dom 文档完成解析的时间戳， document.readyState 的值为 complete。\\n    loadEventStart, // load 事件触发的时间。\\n    loadEventEnd // load 时间结束时的时间。\\n}\\n```\\n\\n后来 window.performance.timing 被废弃，通过 [PerformanceObserver](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FPerformanceObserver \\\"https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceObserver\\\") 来获取。旧的 api，返回的是一个 `UNIX` 类型的绝对时间，和用户的系统时间相关，分析的时候需要再次计算。而新的 api，返回的是一个相对时间，可以直接用来分析\\n\\n现在 chrome 开发团队提供了 [web-vitals](https://www.npmjs.com/package/web-vitals) 库，方便来计算各性能数据（注意：web-vitals 不支持safari浏览器）\\n\\n关于 FP、FCP、LCP、CLS、TTFB、FID 等性能指标的含义和计算方式，我在\\n[「历时8个月」10万字前端知识体系总结（工程化篇）🔥](https://juejin.cn/post/7146976516692410376/#heading-63) 中有详细的讲解，这里不再赘述\\n\\n## 用户行为数据采集\\n\\n用户行为包括：页面路由变化、鼠标点击、资源加载、接口调用、代码报错等行为\\n\\n### 设计思路\\n\\n1、通过Breadcrumb类来创建用户行为的对象，来存储和管理所有的用户行为\\n\\n2、通过重写或添加相应的事件，完成用户行为数据的采集\\n\\n用户行为代码示例：\\n\\n```\\n// 创建用户行为类\\nclass Breadcrumb {\\n  // maxBreadcrumbs控制上报用户行为的最大条数\\n  maxBreadcrumbs = 20;\\n  // stack 存储用户行为\\n  stack = [];\\n  constructor() {}\\n  // 添加用户行为栈\\n  push(data) {\\n    if (this.stack.length >= this.maxBreadcrumbs) {\\n      // 超出则删除第一条\\n      this.stack.shift();\\n    }\\n    this.stack.push(data);\\n    // 按照时间排序\\n    this.stack.sort((a, b) => a.time - b.time);\\n  }\\n}\\n\\nlet breadcrumb = new Breadcrumb();\\n\\n// 添加一条页面跳转的行为，从home页面跳转到about页面\\nbreadcrumb.push({\\n  type: \\\"Route\\\",\\n  form: '/home',\\n  to: '/about'\\n  url: \\\"http://localhost:3000/index.html\\\",\\n  time: \\\"1668759320435\\\"\\n});\\n\\n// 添加一条用户点击行为\\nbreadcrumb.push({\\n  type: \\\"Click\\\",\\n  dom: \\\"<button id='btn'>按钮</button>\\\",\\n  time: \\\"1668759620485\\\"\\n});\\n\\n// 添加一条调用接口行为\\nbreadcrumb.push({\\n  type: \\\"Xhr\\\",\\n  url: \\\"http://10.105.10.12/monitor/open/pushData\\\",\\n  time: \\\"1668760485550\\\"\\n});\\n\\n// 上报用户行为\\nreportData({\\n  uuid: \\\"a6481683-6d2e-4bd8-bba1-64819d8cce8c\\\",\\n  stack: breadcrumb.getStack()\\n});\\n```\\n\\n### 页面跳转\\n\\n通过监听路由的变化来判断页面跳转，路由有`history、hash`两种模式，history模式可以监听`popstate`事件，hash模式通过重写 `pushState和 replaceState`事件\\n\\nvue项目中不能通过 `hashchange` 事件来监听路由变化，`vue-router` 底层调用的是 `history.pushState` 和 `history.replaceState`，不会触发 hashchange\\n\\nvue-router源码：\\n\\n```\\nfunction pushState (url, replace) {\\n  saveScrollPosition();\\n  var history = window.history;\\n  try {\\n    if (replace) {\\n      history.replaceState({ key: _key }, '', url);\\n    } else {\\n      _key = genKey();\\n      history.pushState({ key: _key }, '', url);\\n    }\\n  } catch (e) {\\n    window.location[replace ? 'replace' : 'assign'](url);\\n  }\\n}\\n...\\n\\n// this.$router.push时触发\\nfunction pushHash (path) { \\n  if (supportsPushState) {\\n    pushState(getUrl(path));\\n  } else {\\n    window.location.hash = path;\\n  }\\n}\\n```\\n\\n通过重写 pushState、replaceState 事件来监听路由变化\\n\\n```\\n// lastHref 前一个页面的路由\\nlet lastHref = document.location.href;\\nfunction historyReplace() {\\n  function historyReplaceFn(originalHistoryFn) {\\n    return function(...args) {\\n      const url = args.length > 2 ? args[2] : undefined;\\n      if (url) {\\n        const from = lastHref;\\n        const to = String(url);\\n        lastHref = to;\\n        // 上报路由变化\\n        reportData(\\\"routeChange\\\", {\\n          from,\\n          to\\n        });\\n      }\\n      return originalHistoryFn.apply(this, args);\\n    };\\n  }\\n  // 重写pushState事件\\n  replaceAop(window.history, \\\"pushState\\\", historyReplaceFn);\\n  // 重写replaceState事件\\n  replaceAop(window.history, \\\"replaceState\\\", historyReplaceFn);\\n}\\n\\nfunction replaceAop(source, name, fn) {\\n  if (source === undefined) return;\\n  if (name in source) {\\n    var original = source[name];\\n    var wrapped = fn(original);\\n    if (typeof wrapped === \\\"function\\\") {\\n      source[name] = wrapped;\\n    }\\n  }\\n}\\n```\\n\\n### 用户点击\\n\\n给 document 对象添加click事件，并上报\\n\\n```\\nfunction domReplace() {\\n  document.addEventListener(\\\"click\\\",({ target }) => {\\n      const tagName = target.tagName.toLowerCase();\\n      if (tagName === \\\"body\\\") {\\n        return null;\\n      }\\n      let classNames = target.classList.value;\\n      classNames = classNames !== \\\"\\\" ? ` class=\\\"${classNames}\\\"` : \\\"\\\";\\n      const id = target.id ? ` id=\\\"${target.id}\\\"` : \\\"\\\";\\n      const innerText = target.innerText;\\n      // 获取包含id、class、innerTextde字符串的标签\\n      let dom = `<${tagName}${id}${\\n        classNames !== \\\"\\\" ? classNames : \\\"\\\"\\n      }>${innerText}</${tagName}>`;\\n      // 上报\\n      reportData({\\n        type: 'Click',\\n        dom\\n      });\\n    },\\n    true\\n  );\\n}\\n```\\n\\n### 资源加载\\n\\n获取页面中加载的资源信息，比如它们的 url 是什么、加载了多久、是否来自缓存等，最终生成 [资源加载瀑布图](https://blog.csdn.net/csdn_girl/article/details/54911632)\\n\\n![waterfall .png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e92b04772b2044e5a2cc21b1b73c9acb~tplv-k3u1fbpfcp-watermark.image?)\\n\\n瀑布图展现了浏览器为渲染网页而加载的所有的资源，包括加载的顺序和每个资源的加载时间\\n\\n分析这些资源是如何加载的, 可以帮助我们了解究竟是什么原因拖慢了网页，从而采取对应的措施来提升网页速度\\n\\n可以通过 [performance.getEntriesByType('resource')](https://developer.mozilla.org/zh-CN/docs/Web/API/Performance/getEntriesByType) 获取页面加载的资源列表，同时可以结合 initiatorType 字段来判断资源类型，对资源进行过滤\\n\\n其中 [PerformanceResourceTiming](https://developer.mozilla.org/zh-CN/docs/Web/API/Performance/getEntriesByType) 来分析资源加载的详细数据\\n\\n```\\n// PerformanceResourceTiming 各字段说明\\n{\\n  connectEnd, // 表示浏览器完成建立与服务器的连接以检索资源之后的时间\\n  connectStart, // 表示浏览器开始建立与服务器的连接以检索资源之前的时间\\n  decodedBodySize, // 表示在删除任何应用的内容编码之后，从*消息主体*的请求（HTTP 或缓存）中接收到的大小（以八位字节为单位）\\n  domainLookupEnd, // 表示浏览器完成资源的域名查找之后的时间\\n  domainLookupStart, // 表示在浏览器立即开始资源的域名查找之前的时间\\n  duration, // 返回一个timestamp，即 responseEnd 和 startTime 属性的差值\\n  encodedBodySize, // 表示在删除任何应用的内容编码之前，从*有效内容主体*的请求（HTTP 或缓存）中接收到的大小（以八位字节为单位）\\n  entryType, // 返回 \\\"resource\\\"\\n  fetchStart, // 表示浏览器即将开始获取资源之前的时间\\n  initiatorType, // 代表启动性能条目的资源的类型，如 PerformanceResourceTiming.initiatorType 中所指定\\n  name, // 返回资源 URL\\n  nextHopProtocol, // 代表用于获取资源的网络协议\\n  redirectEnd, // 表示收到上一次重定向响应的发送最后一个字节时的时间\\n  redirectStart, // 表示上一次重定向开始的时间\\n  requestStart, // 表示浏览器开始向服务器请求资源之前的时间\\n  responseEnd, // 表示在浏览器接收到资源的最后一个字节之后或在传输连接关闭之前（以先到者为准）的时间\\n  responseStart, // 表示浏览器从服务器接收到响应的第一个字节后的时间\\n  secureConnectionStart, // 表示浏览器即将开始握手过程以保护当前连接之前的时间\\n  serverTiming, // 一个 PerformanceServerTiming 数组，包含服务器计时指标的PerformanceServerTiming 条目\\n  startTime, // 表示资源获取开始的时间。该值等效于 PerformanceEntry.fetchStart\\n  transferSize, // 代表所获取资源的大小（以八位字节为单位）。该大小包括响应标头字段以及响应有效内容主体\\n  workerStart // 如果服务 Worker 线程已经在运行，则返回在分派 FetchEvent 之前的时间戳，如果尚未运行，则返回在启动 Service Worker 线程之前的时间戳。如果服务 Worker 未拦截该资源，则该属性将始终返回 0。\\n}\\n```\\n\\n获取资源加载时长为 `duration` 字段，即 `responseEnd 与 startTime` 的差值\\n\\n获取加载资源列表：\\n\\n```\\nfunction getResource() {\\n  if (performance.getEntriesByType) {\\n    const entries = performance.getEntriesByType('resource');\\n    // 过滤掉非静态资源的 fetch、 xmlhttprequest、beacon\\n    let list = entries.filter((entry) => {\\n      return ['fetch', 'xmlhttprequest', 'beacon'].indexOf(entry.initiatorType) === -1;\\n    });\\n\\n    if (list.length) {\\n      list = JSON.parse(JSON.stringify(list));\\n      list.forEach((entry) => {\\n        entry.isCache = isCache(entry);\\n      });\\n    }\\n    return list;\\n  }\\n}\\n\\n// 判断资料是否来自缓存\\n// transferSize为0，说明是从缓存中直接读取的（强制缓存）\\n// transferSize不为0，但是`encodedBodySize` 字段为 0，说明它走的是协商缓存（`encodedBodySize 表示请求响应数据 body 的大小`）\\nfunction isCache(entry) {\\n  return entry.transferSize === 0 || (entry.transferSize !== 0 && entry.encodedBodySize === 0);\\n}\\n```\\n\\n一个真实的页面中，资源加载大多数是逐步进行的，有些资源本身就做了延迟加载，有些是需要用户发生交互后才会去请求一些资源\\n\\n如果我们只关注首页资源，可以在 `window.onload` 事件中去收集\\n\\n如果要收集所有的资源，需要通过定时器反复地去收集，并且在一轮收集结束后，通过调用 [clearResourceTimings](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/API/Performance/clearResourceTimings) 将 performance entries 里的信息清空，避免在下一轮收集时取到重复的资源\\n\\n## 个性化指标\\n\\n### long task\\n\\n执行时间超过50ms的任务，被称为 [long task ](https://developer.mozilla.org/zh-CN/docs/Web/API/Long_Tasks_API) 长任务\\n\\n获取页面的长任务列表：\\n\\n```\\nconst entryHandler = list => {\\n  for (const long of list.getEntries()) {\\n    // 获取长任务详情\\n    console.log(long);\\n  }\\n};\\n\\nlet observer = new PerformanceObserver(entryHandler);\\nobserver.observe({ entryTypes: [\\\"longtask\\\"] });\\n```\\n\\n### memory页面内存\\n\\n`performance.memory` 可以显示此刻内存占用情况，它是一个动态值，其中： \\n- jsHeapSizeLimit 该属性代表的含义是：内存大小的限制。\\n\\n- totalJSHeapSize 表示总内存的大小。\\n\\n- usedJSHeapSize 表示可使用的内存的大小。 \\n\\n通常，usedJSHeapSize 不能大于 totalJSHeapSize，如果大于，有可能出现了内存泄漏\\n\\n```\\n// load事件中获取此时页面的内存大小\\nwindow.addEventListener(\\\"load\\\", () => {\\n  console.log(\\\"memory\\\", performance.memory);\\n});\\n```\\n\\n### 首屏加载时间\\n\\n首屏加载时间和首页加载时间不一样，首屏指的是屏幕内的dom渲染完成的时间\\n\\n比如首页很长需要好几屏展示，这种情况下屏幕以外的元素不考虑在内\\n\\n**计算首屏加载时间流程**\\n\\n1）利用`MutationObserver`监听`document`对象，每当dom变化时触发该事件\\n\\n2）判断监听的dom是否在首屏内，如果在首屏内，将该dom放到指定的数组中，记录下当前dom变化的时间点\\n\\n3）在MutationObserver的callback函数中，通过防抖函数，监听`document.readyState`状态的变化\\n\\n4）当`document.readyState === 'complete'`，停止定时器和 取消对document的监听\\n\\n5）遍历存放dom的数组，找出最后变化节点的时间，用该时间点减去`performance.timing.navigationStart` 得出首屏的加载时间\\n\\n## 监控SDK\\n\\n监控SDK的作用：数据采集与上报\\n\\n### 整体架构\\n\\n![sdkProcess.jpg](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca8db3058b2d49608a447dbc4dccbc0c~tplv-k3u1fbpfcp-watermark.image?)\\n\\n整体架构使用 **发布-订阅** 设计模式，这样设计的好处是便于后续扩展与维护，如果想添加新的`hook`或事件，在该回调中添加对应的函数即可\\n\\n### SDK 入口\\n\\n`src/index.js`\\n\\n对外导出init事件，配置了vue、react项目的不同引入方式\\n\\nvue项目在Vue.config.errorHandler中上报错误，react项目在ErrorBoundary中上报错误\\n\\n![entry.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0124fc1be85f43f8b6172f6bdb950218~tplv-k3u1fbpfcp-watermark.image?)\\n\\n### 事件发布与订阅\\n\\n通过添加监听事件来捕获错误，利用 AOP 切片编程，重写接口请求、路由监听等功能，从而获取对应的数据\\n\\n`src/load.js`\\n\\n![replace.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/498c219e4d01449cac3be2c9a3f9db24~tplv-k3u1fbpfcp-watermark.image?)\\n\\n### 用户行为收集\\n\\n`core/breadcrumb.js`\\n\\n创建用户行为类，stack用来存储用户行为，当长度超过限制时，最早的一条数据会被覆盖掉，在上报错误时，对应的用户行为会添加到该错误信息中\\n\\n![bread.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4e5fcce29ac54bb1a2cede02b395bfbb~tplv-k3u1fbpfcp-watermark.image?)\\n\\n### 数据上报方式\\n\\n支持图片打点上报和fetch请求上报两种方式\\n\\n图片打点上报的优势：   \\n1）支持跨域，一般而言，上报域名都不是当前域名，上报的接口请求会构成跨域  \\n2）体积小且不需要插入dom中   \\n3）不需要等待服务器返回数据\\n\\n图片打点缺点是：url受浏览器长度限制\\n\\n`core/transportData.js`\\n\\n![send.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a5c83e0ee5f41428e5bca3de2f7dd2c~tplv-k3u1fbpfcp-watermark.image?)\\n\\n### 数据上报时机\\n\\n优先使用 requestIdleCallback，利用浏览器空闲时间上报，其次使用微任务上报\\n\\n![queue.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/293f0ce61c994a16aaf2ed2341803878~tplv-k3u1fbpfcp-watermark.image?)\\n\\n监控SDK，参考了 [sentry](https://github.com/getsentry/sentry-javascript)、 [monitor](https://github.com/clouDr-f2e/monitor)、 [mitojs](https://github.com/mitojs/mitojs)\\n\\n## 项目后台demo\\n\\n主要用来演示错误还原功能，方式包括：定位源码、播放录屏、记录用户行为\\n\\n## [](https://github.com/xy-sea/web-see-demo#%E5%8A%9F%E8%83%BD)\\n\\n![web-see.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/179f1b31741443eab79be2a59eb62f28~tplv-k3u1fbpfcp-watermark.image?)\\n\\n后台demo功能介绍：\\n\\n1、使用 express 开启静态服务器，模拟线上环境，用于实现定位源码的功能\\n\\n2、server.js 中实现了 reportData（错误上报）、getmap（获取 map 文件）、getRecordScreenId（获取录屏信息）、 getErrorList（获取错误列表）的接口\\n\\n3、用户可点击 'js 报错'、'异步报错'、'promise 错误' 按钮，上报对应的代码错误，后台实现错误还原功能\\n\\n4、点击 'xhr 请求报错'、'fetch 请求报错' 按钮，上报接口报错信息\\n\\n5、点击 '加载资源报错' 按钮，上报对应的资源报错信息\\n\\n通过这些异步的捕获，了解监控平台的整体流程\\n\\n## 安装与使用\\n\\nnpm官网搜索 [web-see](https://www.npmjs.com/package/web-see)\\n\\n<img src=\\\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2577f7151904489283ffa5fd6fb0213a~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"install.jpg\\\" width=\\\"90%\\\" />\\n\\n## 仓库地址\\n\\n监控SDK： [web-see](https://github.com/xy-sea/web-see)\\n\\n监控后台： [web-see-demo](https://github.com/xy-sea/web-see-demo)\\n\\n## 总结\\n\\n目前市面上的前端监控方案可谓是百花齐放，但底层原理都是相通的。从基础的理论知识到实现一个可用的监控平台，收获还是挺多的\\n\\n有兴趣的小伙伴可以结合git仓库的源码玩一玩，再结合本文一起阅读，帮助加深理解\\n\\n## 后续\\n\\n下一篇会继续讨论前端监控，讲解具体如何实现：定位源码、播放录屏等功能\\n\\n**感兴趣的小伙伴可以点个关注，后续好文不断！**",
        "tags": [
            "前端",
            "监控",
            "JavaScript"
        ]
    },
    {
        "article_id": "7170662948656906253",
        "cover_image": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dcd0c2281d7843db87c51786a92baa6c~tplv-k3u1fbpfcp-watermark.image?",
        "title": "TS泛型进阶",
        "brief": "拿下泛型，TS 还有什么难的吗？本文将带你加深入的理解和掌握泛型，以及更加熟练 TS 内置工具类型在项目中的运用",
        "user_name": "沐华",
        "view_count": 6040,
        "collect_count": 230,
        "comment_count": 18,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/854492b2fa147955b52683f84d064ab8~300x300.image",
        "category": "前端",
        "content": "大家好，我是沐华，本文主要剖析 `TS` 开发中常见工具类型的源码实现及使用方式，并且搭配与内容结合的练习，方便更好的理解和掌握，本文目标：\\n- 更加深入的理解和掌握泛型\\n- 更加熟练这些内置工具类型在项目中的运用\\n\\n### Exclude\\n\\n`Exclude<T, U>`：作用简单说就是把 `T` 里面的 `U` 去掉，再返回 `T` 里还剩下的。`T` 和 `U` 必须是同种类型(具体类型/字面量类型)。如下\\n\\n```ts\\ntype T1 = Exclude<string | number, string>;\\n// type T1  = number; \\n\\n// 上面这个肯定一看就懂，那下面这样呢\\n\\ntype T2 = Exclude<'a' | 'b' | 'c', 'b' | 'd'>;\\n// type T2  = 'a' | 'c';\\n```\\n\\n怎么就剩个 `a | c` 了？这怎么执行的？\\n\\n先看一张图\\n\\n![75c8b9738b63d4720d84d39eca8edc6.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/630dae77a48949ab9ad55b90613537f8~tplv-k3u1fbpfcp-watermark.image?)\\n\\n三元表达式大家都知道，不是返回 `a` 就是返回 `b`，这么算的话，这个 `some` 的类型应该是 `b` 才对呀，可这个结果是 `a | b` 又是怎么回事呢，这都是由于 `TS` 中的**拆分**或者说叫**分发**机制导致的\\n\\n简单说就是**联合类型并且是裸类型就会产生分发，分发就会把联合类型中的每一个类型单独拿去判断，最后返回结果组成的联合类型**，`a | b` 就是这么来的，这个特性在本文后面会提到多次所以铺垫一下，这也是为什么反 `Exclude` 放在开头的原因\\n\\n结合 `Exclude` 的实现和例子来理解下\\n\\n```ts\\n// 源码定义\\ntype Exclude<T, U> = T extends U ? never : T;\\n\\n// 例子\\ntype T2 = Exclude<'a' | 'b' | 'c', 'b' | 'd'>;\\n// type T2  = 'a' | 'c';\\n```\\n\\n上面例子中的执行逻辑：\\n\\n- 由于分发会把联合类型中的每一个类型单独拿去判断的原因，会先把 `T` ，也就是前面 `a | b | c` 给拆分再单独放入 `T extends U ? never : T` 判断\\n- 第一次判断 `a(T就是a) ` ，`U` 就是 `b | d` ，`T` 并没有继承自 `U`，判断为假，返回 `T` 也就是 `a`\\n- 第二次判断放入 `b` 判断为真，返回 `never`，`ts` 中的 `never` 我们知道就是不存在值的意思，连 `undefined` 都没有，所以 `never` 会被忽略，不会产生任何效果\\n- 第三次判断放入 `c`，判断为假，和 `a` 同理\\n- 最后**将每一个单独判断的结果组成联合类型返回**，`never` 会忽略，所以就剩下 `a | c`\\n\\n> 总之就是：如果 `T extends U`  满足分发的条件，就会把所有单个类型依次放入判断，最后返回记录的结果组合的联合类型\\n\\n### Extract\\n\\n`Extract<T, U>`：作用是取出 `T` 里面的 `U` ，返回。作用和 `Exclude` 刚好相反，传参也是一样的\\n\\n看例子理解 `Extract`\\n\\n```ts\\ntype T1 = Extract<'a' | 'b' | 'c', 'a' | 'd'>;\\n// type T1  = 'a';\\n\\n// 源码定义\\ntype Extract<T, U> = T extends U ? T : never\\n```\\n\\n和 `Exclude` 源码对比也只是三元表达式返回的 never : T 对调了一下，执行原理也是一样一样儿的，就不重复了\\n\\n###  Omit\\n\\n`Omit<T, K>`：作用是把 `T(对象类型)` 里边的 `K` 去掉，返回 `T` 里还剩下的\\n\\n`Omit` 的作用和 `Exclude` 是一样的，都能做类型过滤并得到新类型。\\n\\n不同的是 `Exclude` 主要是处理联合类型，且会触发分发，而 `Omit` 主要是处理对象类型，所以自然的这俩参数也不一样。\\n\\n用法如下\\n\\n```ts\\n// 这种场景 type 和 interface 是一样的，后面就不重复说明了\\ntype User = {\\n    name: string\\n    age: number\\n}\\ntype T1 = Omit<User, 'age'>\\n// type T1 = { name: string }\\n```\\n\\n源码定义\\n\\n```ts\\n// keyof any 就是 string | number | symbol\\ntype Omit<T, K extends keyof any> = { [P in Exclude<keyof T, K>]: T[P]; }\\n```\\n\\n- 首先第一个参数 `T` 要传对象类型， `type` 或 `interface` 都可以\\n- 第二个参数 `K` 限制了类型只能是 `string | number | symbol`，这一点跟 `js` 里的对象是一个意思，对象类型的属性名只支持这三种类型\\n- `in` 是映射类型，用来映射遍历枚举类型。大白话就是循环、循环语法，需要配合联合类型来对类型进行遍历。`in` 的右边是可遍历的枚举类型，左边是遍历出来的每一项\\n- 用 `Exclude` 去除掉传入的属性后，再遍历剩下的属性，生成新的类型返回\\n\\n示例解析：\\n\\n```ts\\ntype User = {\\n    name: string\\n    age: number\\n    gender: string\\n}\\ntype Omit<T, K extends keyof any> = { [P in Exclude<keyof T, K>]: T[P]; }\\ntype T1 = Omit<User, 'age'>\\n// type T1 = { name: string, gender: string }\\n```\\n\\n我们调用 `Omit` 传入的参数是正确的，所以就分析一下后面的执行逻辑：\\n\\n- `Exclude<keyof T, K>` 等于 `Exclude<'name'|'age'|'gender', 'age'>`，返回的结果就是 `'name'|'gender`\\n\\n- 然后遍历 `'name'|'gender'`，第一次循环 `P` 就是 `name`，返回 `T[P]` 就是 `User['name']`\\n- 第二次循环 `P` 就是 `gender`，返回 `T[P]` 就是 `User['gender']`，然后循环结束\\n- 结果就是 `{ name: string, gender: string }`\\n\\n### Pick\\n\\n`Pick<T, K>` ：作用是取出 `T(对象类型)` 里边儿的 `K`，返回。\\n\\n好像和 `Omit` 刚好相反，`Omit` 是不要 `K` ，`Pick` 是只要 `K` \\n\\n传参方式和 `Omit` 是一样的，就不赘述了，用法示例：\\n\\n```ts\\ntype User = {\\n    name: string\\n    age: number\\n    gender: string\\n}\\ntype T1 = Pick<User, 'name' | 'gender'>\\n// type T1 = { name: string, gender: string }\\n```\\n\\n源码定义\\n\\n```ts\\ntype Pick<T, K extends keyof T> = { [P in K]: T[P]; }\\n```\\n\\n- 可以看到等号左边做了泛型约束，限制了第二个参数 `K` 必须是第一个参数 `T` 里的属性。\\n- 如果第二个参数传入联合类型，会触发分发，以此来确保准确性，联合类型中的每一个单独类型都必须是第一个对象类型中的属性(不限制的话右边就要出错了)\\n- 参数都正确之后，等号右边的逻辑其实就是和 `Omit` 一模一样的了，直接遍历 `K`，取出返回就完事儿了\\n\\n### 练习一\\n\\n请利用本文上述内容完成：基于如下类型，实现一个去掉了 `gender` 的新类型，实现方法越多越好\\n\\n```ts\\ntype User = {\\n    name: string\\n    age: number\\n    gender: string\\n}\\n```\\n\\n这个？\\n```ts\\ntype T1 = { name: string, age: number }\\n```\\n？？？\\n\\n我写了几个，欢迎补充：\\n\\n```ts\\ntype T1 = Omit<User, 'gender'>\\ntype T2 = Pick<User, 'name' | 'age'>\\ntype T3 = Pick<User, Exclude<keyof User, 'gender'>>\\ntype T4 = { [P in 'name' | 'age'] : User[P] }\\ntype T5 = { [P in Exclude<keyof User, 'gender'>] : User[P] }\\n```\\n\\n### Record\\n\\n`Record<K, T>`：作用是自定义一个对象。`K` 为对象的 `key` 或 `key` 的类型，`T` 为 `value` 或 `value` 的类型。\\n\\n你有没有这样用过 ↓\\n\\n```ts\\nconst obj:any = {}\\n```\\n\\n反正我有，其实用 `Record` 定义对象，在工作中还是很好用的，而且非常灵活，不同的对象定义上也会有一点区别，如下\\n\\n**空对象**\\n\\n```ts\\n// never，会限制为空对象\\n// any 指的是 string | number | symbol 这几个类型都行\\ntype T1 = Record<any, never>\\nlet obj1:T1 = {} \\t// ok\\n// let obj1:T1 = {a:1} 这样不行，只能是空对象\\n```\\n\\n**任意对象**\\n\\n```ts\\n// 任意对象，unknown 或 {} 表示对象内容不限，空对象也行\\ntype T1 = Record<any, unknown>\\n// 或\\ntype T1 = Record<any, {}>\\nlet obj2:T1 = {} \\t// ok\\nlet obj3:T1 = {a:1}  // ok\\n```\\n\\n**自定义对象 key**\\n\\n```ts\\ntype keys = 'name' | 'age'\\ntype T1 = Record<keys, string>\\nlet obj1:T1 = {\\n    name: '沐华',\\n    age: '18'\\n    // age: 18  报错，第二个参数 string 表示 value 值都只能是 string 类型\\n}\\n\\n// 如果需要 value 是任意类型，下面两个都行\\ntype T2 = Record<keys, unknown>\\ntype T3 = Record<keys, {}>\\n```\\n\\n**自定义对象 value**\\n\\n```ts\\ntype keys = 'a' | 'b'\\n// type 或 interface 都一样\\ntype values<T> = {\\n    name?: T,\\n    age?: T,\\n    gender?: string\\n}\\n\\n// 自定义 value 类型\\ntype T1 = Record<keys, values<number | string>>\\nlet obj:T1 = {\\n    a: { name: '沐华' },\\n    b: { age: 18 }\\n}\\n\\n// 固定 value 值\\ntype T2 = Record<keys, 111>\\nlet obj1:T2 = {\\n    a: 111,\\n    b: 111\\n}\\n```\\n\\n源码定义\\n\\n```ts\\ntype Record<K extends any, T> = { [P in K]: T; }\\n```\\n\\n左边限制了第一个参数 `K` 只能是 `string | number | symbol` 类型，可以是联合类型，因为右边遍历 `K` 了，然后遍历出来的每个属性的值，直接赋值为传入的第二个参数\\n\\n### Partial\\n\\n`Partial<T>`：作用生成一个将 `T(对象类型)` 里所有属性都变成可选的之后的新类型\\n\\n示例如下：\\n\\n```ts\\ntype User = {\\n    name: string\\n    age: number\\n}\\ntype T1 = Partial<User>\\n// 简单说 T1 和 T2 是一模一样的\\ntype T2 = {\\n    name?: string\\n    age?: number\\n}\\n```\\n\\n源码定义\\n\\n```ts\\ntype Partial<T> = { [P in keyof T]?: T[P]; }\\n```\\n\\n这下看源码定义的是不是特别简单，就是循环传进来的对象类型，给每个属性加个 `?` 变成可选属生\\n\\n### Required\\n\\n`Required<T>`：作用和 `Partial<T>` 刚好相反，`Partial` 是返回所有属性都是**非必填**的对象类型，而 `Required` 则是返回所有属性都是**必填项**的对象类型。参数 `T` 也是一个对象类型。\\n\\n示例：\\n\\n```ts\\ntype User = {\\n    name?: string\\n    age?: number\\n}\\ntype T1 = Required<User>\\n// 简单说 T1 和 T2 是一模一样的\\ntype T2 = {\\n    name: string\\n    age: number\\n}\\n```\\n\\n源码定义\\n\\n```ts\\ntype Required<T> = { [P in keyof T]-?: T[P]; }\\n```\\n\\n和 `Partial` 的源码定义相比基本一样的，只是这里多了个减号 `-`，没错，就是减去的意思，`-?` 就是去掉 `?`，然后就变成必填项了，这样解释是不是很好理解\\n\\n### Readonly\\n\\n`Readonly<T>` ：作用是返回一个所有属性都是只读不可修改的对象类型，与 `Partial` 和 `Required` 是非常相似的。参数 `T` 也是一个对象类型。\\n\\n示例：\\n\\n```ts\\ntype User = {\\n    name: string\\n    age?: number\\n}\\ntype T1 = Readonly<User>\\n// 简单说 T1 和 T2 是一模一样的\\ntype T2 = {\\n    readonly name: string\\n    readonly age?: number\\n}\\n```\\n\\n```ts\\ntype Readonly<T> = { readonly [P in keyof T]: T[P]; }\\n```\\n\\n怎么样？看到这是不是越发觉得源码的类型定义越看越简单了\\n\\n我：那是不是说把所有只读类型，全都变成非只读就只需要 `-readonly` 就行了？\\n\\n你：是的，说得很对，就是这样的\\n\\n### 练习二\\n\\n从上面几个工具类型的源码定义中我们可以发现，都只是简单的一层遍历，就好像 `js` 中的浅拷贝，比如有下面这样一个对象\\n\\n```ts\\ntype User = {\\n    name: string\\n    age: number\\n    children: {\\n        boy: number\\n        girl: number\\n    }\\n}\\n```\\n\\n要把这样一个对象所有属性都改成可选属性，用 `Partial` 就行不通了，它只能改变第一层，`children` 里的所有属性都改不了，所以请写一个可以实现的类型，功能类似深拷贝的意思\\n\\n先稍微想想再往下看答案哟\\n\\n写出来一个的话，`Partial` 、`Required` 、 `Readonly` 的 “深拷贝” 类型是不是就都有了呢\\n\\n想一下\\n\\n```ts\\n// Partial 源码定义\\ntype Partial<T> = { [P in keyof T]?: T[P]; }\\n\\n// 递归 Partial\\ntype DeepPartial<T> = T extends object ? { [P in keyof T]?: DeepPartial<T[P]> }:T;\\n```\\n\\n外层再加了一个三元表达式，如果不是对象类型直接返回，如果是就遍历；然后属性值改成递归调用就可以了\\n\\n```ts\\n// 递归 Required\\ntype DeepRequired<T> = T extends object ? { [P in keyof T]-?: DeepRequired<T[P]> }:T;\\n\\n// 递归 Readonly\\ntype DeepReadonly<T> = T extends object ? { readonly [P in keyof T]: DeepReadonly<T[P]> }:T;\\n```\\n\\n### NonNullable\\n\\n`NonNullable<T>`：作用是去掉 `T` 中的 `null` 和 `undefined`。`T` 为字面量/具体类型的联合类型，如果是对象类型是没有效果的。如下\\n\\n```ts\\ntype T1 = NonNullable<string | number | undefined>;\\n// type T1 = string | number\\n\\ntype T2 = NonNullable<string[] | null | undefined>;    \\n// type T2 = string[]\\n\\ntype T3 = {\\n    name: string\\n    age: undefined\\n}\\ntype T4 = NonNullable<T3> // 对象是不行的\\n```\\n源码定义\\n```ts\\n// 4.8版本之前的版本\\ntype NonNullable<T> = T extends null | undefined ? never : T;\\n// 4.8\\ntype NonNullable<T> = T & {}\\n```\\n\\n`TS 4.8版本` 之前的就是用一个三元表达式来过滤 `null | undefined`。而在 `4.8` 版本直接就是 `T & {}`，这是什么原理呢？其实是因为这个版本对 `--strictNullChecks` 做了增加，这主要体现还是在联合类型和交叉类型上，为什么这么说？\\n\\n在 `js` 中都知道万物皆对象，原型链的最终点的正常对象就是 `Object` 了(`null` 算不正常的)，数据类型都是在原型链中继承于 `Object` 派生出来的。\\n\\n在 `ts` 中也一样，由于 `{}` 是一个空对象，所以除了 `null` 和 `undefined` 之外的基础类型都可以视作继承于 `{}` 派生出来的。或者说如果一个值不是 `null` 和 `undefined` 就等于 `这个值 & {}` 的结果，如下\\n\\n```ts\\ntype T1 = 'a' & {};  // 'a'\\ntype T2 = number & {};  // number\\ntype T3 = object & {};  // object\\ntype T4 = { a: string } & {};  // { a: string }\\ntype T5 = null & {};  // never\\ntype T6 = undefined & {};  // never\\n```\\n\\n如果 `T & {}` 中的 `T` 不是 `null/undefined` 就可以认为它肯定符合 `{}` 类型，就可以把 `{}` 从交叉类型中去掉了，如果是，则会被判为 `never`，而 `never` 是会被忽略的(上面 `Exclude` 源码定义里有提到)，所以在结果里自然就排除掉了 `null` 和 `undefined`。\\n\\n还有如果 `T & {}` 中的 `T` 是联合类型，是会触发分发的，这个就不再解释了\\n\\n### 练习三\\n\\n请实现一个能去掉对象类型中 `null` 和 `undefined` 的类型\\n\\n```ts\\n// 需要把如下类型变成 { name: string }\\ntype User = {\\n    name: string\\n    age: null,\\n    gender: undefined\\n}\\n\\n// 实现如下\\ntype ObjNonNullable<T> = { [P in keyof T as T[P] extends null | undefined ? never : P]: T[P] };\\n\\ntype T1 = ObjNonNullable<User>\\n// type T1 = { name: string }\\n```\\n\\n这里出现了一个本文第一次出现的关键字 `as`，我们知道它可以用来断言，在 `ts 4.1` 版本可以在映射类型里用 `as` 实现键名重新映射，达到过滤或者修改属性名的目的，如果指定的类型解析为 `never` 时，会被忽略不会生成这个属性\\n\\n如上只能过滤对象第一层的 `null` 和 `undefined`\\n\\n如何更进一步改成可以递归的呢？\\n\\n```ts\\ntype User = {\\n    name: string\\n    age: undefined,\\n    children: {\\n        boy: number\\n        girl: number\\n        neutral: null\\n    }\\n}\\n// 递归处理对象类型的 DeepNonNullable\\ntype DeepNonNullable<T> = T extends object ? { [P in keyof T as T[P] extends null | undefined ? never : P]: DeepNonNullable<T[P]> } : T;\\n\\ntype T1 = DeepNonNullable<User>\\n// type T1 = {\\n//    name: string;\\n//    children: {\\n//        boy: number;\\n//        girl: number;\\n//    };\\n//}\\n```\\n\\n### Awaited\\n\\n`Awaited<T>`：作用是获取 `async/await` 函数或 `promise` 的 `then()` 方法的返回值的类型。而且自带递归效果，如果是这样嵌套的异步方法，也能拿到最终的返回值类型\\n\\n示例：\\n\\n```ts\\n// Promise\\ntype T1 = Awaited<Promise<string>>;\\n// type T1 = string\\n\\n// 嵌套 Promise，会递归\\ntype T2 = Awaited<Promise<Promise<number>>>;\\n// type T2 = number\\n\\n// 联合类型，会触发分发\\ntype T3 = Awaited<boolean | Promise<number>>;\\n// type T3 = number | boolean\\n```\\n\\n来看下源码定义，看下到底是怎么执行的，是怎么拿到结果的呢？\\n\\n```ts\\n// 源码定义\\ntype Awaited<T> = T extends null | undefined\\n\\t? T\\n\\t: T extends object & { then(onfulfilled: infer F): any }\\n\\t\\t? F extends (value: infer V, ...args: any) => any\\n\\t\\t\\t? Awaited<V>\\n\\t\\t\\t: never\\n\\t\\t: T\\n```\\n\\n泛型条件有点多，就换了下行，方便看\\n\\n- 如果 `T` 是 `null` 或 `undefined` 就直接返回 `T`\\n- 如果 `T` 是对象类型，并且里面有 `then` 方法，就用 `infer` 类型推断出 `then` 方法的第一个参数`onfulfilled` 的类型赋值给 `F`，`onfulfilled` 其实就是我们熟悉的 `resolve`。所以这里可以看出或者准确的说，`Awaited` 拿的不是 `then()` 的返回值类型，而是 `resolve()` 的返回值类型\\n  - 既然 `F` 是回调函数 `resolve` ，就推断出该函数第一个参数类型赋值给 `V` ，`resolve` 的参数自然就是返回值\\n    - 传入 `V` 递归调用\\n  - `F` 不是函数就返回 `never`\\n- 如果 `T` 不是对象类型 或者 是对象但没有 `then` 方法，返回 `T` ，就是最后一行的 `T`\\n\\n### Parameters\\n\\n`Parameters<T>`：作用是获取函数所有参数的类型集合，返回的是元组。`T` 自然就是函数了\\n\\n使用示例：\\n\\n```ts\\ndeclare function f1(arg: { a: number; b: string }): void;\\n\\n// 没有参数的函数\\ntype T1 = Parameters<() => string>;\\n// type T1 = []\\n\\n// 一个参数的函数\\ntype T2 = Parameters<(s: string) => void>;\\n// type T2 = [s: string]\\n\\n// 泛型参数的函数\\ntype T3 = Parameters<<T>(arg: T) => T>;\\n// type T3 = [arg: unknown]\\n\\n// typeof f1 结果为 (arg: { a: number; b: string }) => void\\ntype T4 = Parameters<typeof f1>;\\n// type T4 = [arg: {\\n//     a: number;\\n//     b: string;\\n// }]\\n\\n// any 和 never\\ntype T5 = Parameters<any>;\\n// type T5 = unknown[]\\ntype T6 = Parameters<never>;\\n// type T6 = never\\n\\n// 下面这样传参是会报错的\\ntype T7 = Parameters<string>;\\ntype T8 = Parameters<Function>;\\n```\\n\\n```ts\\n// 源码定义\\ntype Parameters<T extends (...args: any) => any> = T extends (...args: infer P) => any ? P : never\\n```\\n\\n可以看到限制了函数类型，然后 `...args` 取参数和 `js` 中的用法是一样的，`infer` 表示待推断的类型变量，打断出 `...args` 取到的类型赋值给 `P` \\n\\n### ReturnType\\n\\n`ReturnType<T>`：作用是获取函数返回值的类型。`T` 为函数\\n\\n示例：\\n\\n```ts\\ndeclare function f1(): { a: number; b: string };\\n\\ntype T1 = ReturnType<() => string>;\\n// type T1 = string\\n\\ntype T2 = ReturnType<(s: string) => void>;\\n// type T2 = void\\n\\ntype T3 = ReturnType<<T>() => T>;\\n// type T3 = unknown\\n\\ntype T4 = ReturnType<<T extends U, U extends number[]>() => T>;\\n// type T4 = number[]\\n\\ntype T5 = ReturnType<typeof f1>;\\n// type T5 = {\\n//     a: number;\\n//     b: string;\\n// }\\n\\n// any 和 never\\ntype T6 = ReturnType<any>;\\n// type T6 = any\\ntype T7 = ReturnType<never>;\\n// type T7 = never\\n\\n// 下面这样是不行的\\ntype T8 = ReturnType<string>;\\ntype T9 = ReturnType<Function>;\\n```\\n\\n```ts\\n// 源码定义\\ntype ReturnType<T extends (...args: any) => any> = T extends (...args: any) => infer R ? R : any\\n```\\n\\n可以看到源码定义上和 `Parameters` 是基本一样的，只是把类型推断的参数换成返回值了\\n\\n### ConstructorParameters/InstanceType\\n\\n我们知道 `Parameters` 和 `ReturnType` 这一对是获取普通/箭头函数的**参数类型集合**以及**返回值类型**的了，还有一对组合`ConstructorParameters` 和 `InstanceType` 是获取**构造函数**的参数类型集合以及**返回值类型**的，和上面的比较类似我就放到一起了\\n\\n### Uppercase/Lowercase\\n\\n这俩儿的作用是转换全部字母大小写\\n\\n```ts\\ntype T1 = Uppercase<\\\"abcd\\\">\\n// type T1 = \\\"ABCD\\\"\\n\\ntype T2 = Lowercase<\\\"ABCD\\\">\\n// type T2 = \\\"abcd\\\"\\n```\\n\\n### Capitalize/Uncapitalize\\n\\n这俩儿的作用是转换首字母大小写\\n\\n```ts\\ntype T1 = Capitalize<\\\"abcd efg\\\">\\n// type T1 = \\\"Abcd efg\\\"\\n\\ntype T2 = Uncapitalize<\\\"ABCD EFG\\\">\\n// type T2 = \\\"aBCD EFG\\\"\\n```\\n\\n### 练习四\\n\\n请实现一个类型，把对象类型中的属性名换成大写，需要注意的是对象属性名支持 `string | number | symbol` 三种类型\\n\\n```ts\\ntype User1 = {\\n    name: string\\n    age: number\\n    18: number\\n}\\n\\n// 实现如下，只需调用现在的工具类型 Uppercase 就行了\\n\\n// 先取出所有字符串属性的出来，再处理返回 { NAME: string, AGE: number }\\n// type T1<T> = { [P in keyof T & string as Uppercase<P>]: T[P] }\\n// 只处理字符串属性的，其他正常返回\\ntype T1<T> = { [P in keyof T as P extends string ? Uppercase<P> : P]: T[P] }\\n\\ntype T2 = T1<User1>\\n// type T2 = {\\n//     NAME: string;\\n//     AGE: number;\\n//     18: number\\n// }\\n```\\n\\n### 综合练习\\n\\n请实现一个类型，可以把下划线属性名的对象，换成驼峰属性名的对象。这个就没有现成的工具类型调用了，所以需要我们额外实现一个\\n\\n这个练习用到了本文中的很多知识，先自己写一下咯\\n\\n```ts\\ntype User1 = {\\n    my_name: string\\n    my_age_type: number // 多个下划线\\n    my_children: {\\n        my_boy: number\\n        my_girl: number\\n    }\\n}\\n\\n// 实现如下\\ntype T1<T> = T extends string\\n\\t? T extends `${infer A}_${infer B}`\\n\\t\\t? `${A}${T1<Capitalize<B>>}` // 这里有递归处理单个属性名多个下划线\\n\\t\\t: T\\n\\t: T;\\n// 对象不递归\\n// type T2<T> = { [P in keyof T as T1<P>]: T[P] }\\n// 对象递归\\ntype T2<T> = T extends object ? { [P in keyof T as T1<P>]: T2<T[P]> } : T\\n\\ntype T3 = T2<User1>\\n// type T3 = {\\n//     myName: string;\\n//     myAgeType: number;\\n//     myChildren: {\\n//         myBoy: number;\\n//         myGirl: number;\\n//     };\\n// }\\n```\\n\\n这个练习用到了 `extends`、`infer`、`as`、`循环`、`递归`，相信能更好地帮助我们理解和运用\\n\\n### 参考资料\\n\\nhttps://www.typescriptlang.org/docs/handbook/utility-types.html\\n\\n## 结语\\n\\n如果本文对你有一点点帮助，点个赞支持一下吧，你的每一个【赞】都是我创作的最大动力 ^_^\\n\\n更多前端文章，或者加入前端交流群，欢迎关注公众号【前端快乐多】，大家一起共同交流和进步呀\\n\\n***本文正在参加[「金石计划 . 瓜分6万现金大奖」](https://juejin.cn/post/7162096952883019783 \\\"https://juejin.cn/post/7162096952883019783\\\")***\\n",
        "tags": [
            "前端",
            "TypeScript",
            "掘金·金石计划"
        ]
    },
    {
        "article_id": "7177238380852281399",
        "cover_image": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e6317ecd50a4bccbdebcccc8935e897~tplv-k3u1fbpfcp-watermark.image?",
        "title": "待寒潮散去 | 我的2022年终总结",
        "brief": "关注掘金社区也有两年多了，这期间也关注了很多掘友的年中、年终总结，但却从未参与其中，此时则是抱着极其复杂的心情写下这篇我的",
        "user_name": "Aaron_hj",
        "view_count": 1580,
        "collect_count": 2,
        "comment_count": 3,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/1b80acb39f2c7fb137d15e8264089fc3~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: fancy\\n---\\n「回顾2022，展望2023，我正在参与[2022年终总结征文大赛活动](https://juejin.cn/post/7172462429929111559 \\\"https://juejin.cn/post/7172462429929111559\\\")」\\n\\n# 前言\\n\\n关注掘金社区也有两年多了，这期间也关注了很多掘友的年中、年终总结，但却从未参与其中，此时则是抱着极其复杂的心情写下这篇我的年终总结。这篇总结的时间线不仅仅包含2022，而是包含了我从选择前端到现在的代码人生。\\n\\n# 回顾\\n现在回过头来看，我的代码人生已经走过了近两年的时间。在这个过程中，已经发生了太多的事情，也感受过太多之前从未有过的情绪。\\n\\n这两年的时光，我的工作和生活都充斥着变化。\\n\\n## 迷茫 - 选择 - 努力\\n回看2021年初，在面临毕业季考研、考公和择业的众多选择中，我选择了做一名前端er。当时面临选择的我和大多数普通大学生一样，充斥着迷茫，经历了一段时间的迷茫之后。一次自省解救了自己：\\n\\n> **当我处于迷茫，因为我一直在想，一直在想各种选择的优劣利弊，却并未有过什么行动；而想解除迷茫，不如行动起来，去多做一些尝试，或许能更快的找到适合自己的和自己想要的选择，即使不能，也比现在一直原地打转强。**\\n\\n于是，我一边备研，一边通过各方面的资源了解IT行业的各个方向。最终，在3月，做出了一个我自认为决定我以后的职业生涯的一次选择 —— **前端**\\n\\n在这之后，我开始集中学习准备前端的基础知识，框架；开始在github上找项目做实践；甚至到了解原理，学习算法。那一段时光是很充实美好的。因为我已有了目标，**我所要做的即是用我的努力确认我的选择是正确的**\\n\\n对我而言，这段努力的时光是好的，结果也是好的。基于大学科班的基础，加上积极准备的8个多月的时间，在10月收获了几个满足的offer，选择了一个大厂的实习以及一个AI独角兽的校招意向。\\n\\n**感想：**\\n\\n1. **当你处于迷茫，那是因为你只是在想，而从未行动，不如都去尝试尝试，总会找到自己想要的。**\\n2. **一旦做出选择，接下来要做的就是用努力和付出向自己证明当初选择的正确。**\\n## 实习 - 毕业\\n镜头一转，到了北京。\\n\\n当时的心情是喜悦和紧张的。喜悦是因为努力了这么久终于是有了不错的结果；紧张则是初入职场的青涩和紧张。\\n\\n当时无论是工作还是生活都是充满新奇的。工作上，到了一个新的环境、有了新的同伴、有了新的生活节奏。每天朝10晚7，工作时，和同事们高效友好的协作；休息时，和同事们一起打几把游戏。生活好不快哉。\\n\\n生活上，一到周末，就与朋友们流窜于大北京的各大历史建筑、胡同小巷和山林园区，忙着感受北京的市井气息和独特的秋冬气息。\\n\\n这段美好的时光一直维持到2021年底，在经历了第一次在北京跨年之后，迎来实习转正的关键时期。\\n\\n回顾到现在，不禁感叹**年底对我而言像是魔咒（这算是本文的一个伏笔吧🤭）**\\n\\n接着上面说，当时的我已经完成了组内的转正面试，已经被批准转正，流程已经走到写实习评语的阶段了。接下来反转来啦，年底锁HC，转正无望。。。\\n\\n当时的心情更多是无奈，无奈与相处得不错得同事say goodbye；无奈与待着挺舒服得公司say goodbye。\\n\\n不过好在抓住了之前秋招获得的校招offer，双方达成了意向，签订了三方。也算是给自己的职业生涯初期上了一份保险。\\n\\n接下来，就是正常的毕业流程。回学校，准备毕设，答辩，享受最后的大学时光。\\n\\n## 正式工作 - 人生一大坎坷\\n\\n在2022年6月，完成了最后的学业之后，本来计划来一趟轰轰烈烈的毕业旅行，却被疫情无情叫停。所以，在7月1日，我就开始了正式的职场生涯。\\n\\n这段工作的节奏和之前的实习大不相同，公司规定节奏10-9-5，又因为公司之前组织架构和人员进行了大规模缩减，导致现有业务体量和团队人员配比不成正比，业务压力也很大。再者，公司所用技术栈和之前所学完全不同，学习成本也很大。多方因素影响，这段经历是压力与焦虑并存的。\\n\\n不过好在通过一段时间的学习和调整，也是很好的适应了新环境的节奏和业务，一切都在步入正轨，寒潮也在蔓延而来 —— 多方证实公司年底有一波优化，卡试用期。在这之后的一个多月，周围弥漫着焦虑和危机感。\\n\\n结果就是，又是在年底，我主动离职了，一方面因为目前的业务的维护和迭代成本太高了，阻碍了自身的成长速度；另一方面则是因为寒潮带来的精神内耗。即使是在这如此尴尬的大环境以及对我而言如此尴尬的时间节点，我仍觉得离开是最好的选择。\\n\\n# 展望\\n\\ncallback一下：一旦选择，就努力证明自己的选择是正确的。\\n\\n离职之后，我开始注重规范作息，规范饮食，健身，没事在黄浦江边散散步，缓解焦虑，缓解自我消耗。至此，我的身体健康、心态以及学习状态都得到了很好的改善。\\n\\n现在的我，就在这种积极健康的生活状态中继续学习、深入，我当然知道现在的大环境是如何窘迫，机会和坑位都极少，但我选择将更多的注意力放在精进自身的技术上，我认为这是我此时最好的选择。\\n\\n文尽至此，不禁感叹，人生总是充斥着变化，我所能做的既是拥抱变化，完善自己，待寒潮散去。\\n\\n# 结语\\n\\n看到这，如果我的文章能给你带来一点些许的感触，可以给我点赞关注，也算是对笔者的一些鼓励，也欢迎掘友们将自己的经历和感触发表到评论区参与讨论。\\n\\n另外，笔者现在处于离职状态，如果有好的求职机会或者有任何事想要与笔者交流，可以添加我的wx：**a229484250**\\n\\n我是艾伦，期待我们在下一篇文章相遇~",
        "tags": [
            "前端",
            "后端",
            "JavaScript"
        ]
    },
    {
        "article_id": "7159155955987382309",
        "cover_image": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b361ba27cfc94e0abb0a1c5b0212f756~tplv-k3u1fbpfcp-watermark.image?",
        "title": "前端面试  第四篇  重绘和重排（回流）",
        "brief": "前端八股文 怎么能不懂一点呢~ 你会不会存在这样一些质疑： 什么是浏览器的重绘重排❓ 会不会触发重绘和重排❓ 怎么权衡重绘与重排❓",
        "user_name": "ForeverChen",
        "view_count": 2660,
        "collect_count": 90,
        "comment_count": 51,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/e84fd926aee536a6fcda8838fbecd359~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: condensed-night-purple\\n---\\n前端八股文 怎么能不懂一点呢~ <br/>\\n这是前端面试 最喜欢问的问题， 让我们一起看一下~ <br/>\\n\\n  前端在做UI交互效果的时候会不会存在这样一个质疑：`这样到底做好不好❓` <br />\\n  `主要是两个方面导致质疑的存在（~~嘿嘿，实际上是想更优秀😜）`：  <br />\\n- 一个是页面布局方面（此处不深入哦~）； <br />\\n- 一个是浏览器渲染方面(会不会触发重绘和重排❓) <br />\\n\\n`此时的你可能会有些疑问：`   <br />\\n- 什么是浏览器的重绘重排❓<br />\\n- 怎么在实际项目中把重绘重排引起的性能问题考虑进去❓<br />\\n- 怎么权衡重绘与重排❓<br />\\n\\n  以下可以部分解释以上三个疑问：\\n## 重绘 和 重排（回流）\\n>重绘不一定导致重排，但重排一定会导致重绘 <br />\\n>重排（Reflow） && 重绘（Redraw）会付出高昂的性能代价  \\n\\n  \\n ### 重绘\\n   **重绘 （`Redraw`）**：某些元素的外观被改变所触发的浏览器行为（重新计算节点在屏幕中的绝对位置并渲染的过程）； 例如：修改元素的填充颜色，会触发重绘； <br />\\n ### 重排（回流）\\n **重排 （`Reflow`）**：重新生成布局，重新排列元素（重新计算各节点和css具体的大小和位置：渲染树需要重新计算所有受影响的节点**）；例如：改元素的宽高，会触发重排； <br />\\n  **通过两者概念区别明显得知，重排要比重绘的成本大得多，我们应该尽量减少重排操作，减少页面性能消耗**\\n ### 那些操作会导致重绘与重排 ❓\\n \\n  下面情况会发生重绘：\\n  -   color\\n  -   border-style\\n  -   border-radius\\n  -   text-decoration\\n  -   box-shadow\\n  -   outline\\n  -   background\\n  -   ...\\n  <br />\\n  \\n  下面情况会发生重排：\\n  - 页面初始渲染，这是开销最大的一次重排;\\n  - 添加/删除可见的DOM元素;\\n  - 改变元素位置;\\n  - 改变元素尺寸，比如边距、填充、边框、宽度和高度等;\\n  - 改变元素内容，比如文字数量，图片大小等;\\n  - 改变元素字体大小;\\n  - 改变浏览器窗口尺寸，比如resize事件发生时;\\n  - 激活CSS伪类（例如：:hover）;\\n  - 设置 style 属性的值，因为通过设置style属性改变结点样式的话，每一次设置都会触发一次reflow;\\n  - 查询某些属性或调用某些计算方法：offsetWidth、offsetHeight等，除此之外，当我们调用getComputedStyl方法，或者IE里的 currentStyle 时，也会触发重排，原理是一样的，都为求一个“即时性”和“准确性”;\\n  -   ...\\n  <br />\\n  \\n  ### 重排影响的范围:\\n  - **全局范围（全局布局）**：从根节点html开始对整个渲染树进行重新布局；\\n  - **局部范围（局部布局）**：对渲染树的某部分或某一个渲染对象进行重新布局；\\n  \\n  ### 优化建议:\\n  `核心观念： 减少重排次数和减小重排范围`\\n  \\n  #### 样式集中改变（`减少重排次数`）：\\n\\n  ```html\\n  <!-- html -->\\n  <span id=\\\"demo\\\">\\n    我是demo\\n  </span>\\n  ```\\n  \\n  ```js\\n  // javascript\\n  // renderEle.style 逐个添加/修改属性值\\n  const renderEle = d、ocument.getElementById('demo');\\n  renderEle.style.color = 'red'; // 导致重绘\\n  renderEle.style.background= '#ccc'; // 导致重绘\\n  renderEle.style.padding = '15px 20px'; // 导致重排（重排会引起重绘）\\n  ```\\n  以上操作会导致 3次重绘 1次重排;\\n  可以动态添加class，只会导致1次重排（重排会引起重绘），从而减少重绘次数;<br/>\\n  可以合并为：\\n  ```js\\n  // javascript\\n  document.getElementById('demo').className = 'demo'; // 添加class 统一添加/修改样式\\n  ```\\n\\n  ```css\\n  /* css */\\n  .demo {\\n    color: red;\\n    background: #ccc;\\n    padding: 15px 20px;\\n  }\\n  ```\\n  #### 将 DOM 离线（`减少重排次数`）\\n  \\n   `离线操作DOM`：当对DOM 节点有较大改动的时候，我们先将元素脱离文档流，然后对元素进行操作，最后再把操作后的元素放回文档流。<br/>\\n    1. 修改DOM节点的display属性，临时将此节点从文档流中脱离，然后再恢复；\\n```html\\n<!-- html -->\\n<span id=\\\"demo\\\">\\n  我是demo\\n</span>\\n```\\n   需要频繁操作DOM 修改style\\n```js\\n  // javascript\\n  // 第一次操作修改 color、background、padding\\n  const renderEle = document.getElementById('demo');\\n  renderEle.style.color = 'red'; // 导致重绘\\n  renderEle.style.background= '#ccc'; // 导致重绘\\n  renderEle.style.padding = '15px 20px'; // 导致重排（重排会引起重绘）\\n  // ...\\n  // 第二次操作修改 marginLeft、marginTop\\n  const renderEle = document.getElementById('demo');\\n  renderEle.style.marginLeft = '15px'; // 导致重排（重排会引起重绘）\\n  renderEle.style.marginTop = '15px'; // 导致重排（重排会引起重绘）\\n  // ...\\n  // 第三次操作修改 border\\n  const renderEle = document.getElementById('demo');\\n  renderEle.style.border = '2px solid #ccc'; // 导致重排（重排会引起重绘）\\n```\\n以上操作触发多次重排、重绘;\\n可以将`renderEle`进行离线操作;\\n修改如下：\\n```js\\n  // javascript\\n  const renderEle = document.getElementById('demo');\\n  // 第一次操作修改 color、background、padding\\n  renderEle.style.display = 'none'; // 导致重排（重排会引起渲）\\n  renderEle.style.color = 'red'; // DOM不存在渲染树上不会引起重排、重绘\\n  renderEle.style.background= '#ccc';// DOM不存在渲染树上不会引起重排、重绘\\n  renderEle.style.padding = '15px 20px';// DOM不存在渲染树上不会引起重排、重绘\\n  // ...\\n  // 第二次操作修改 marginLeft、marginTop\\n  renderEle.style.marginLeft = '15px';// DOM不存在渲染树上不会引起重排、重绘\\n  renderEle.style.marginTop = '15px';// DOM不存在渲染树上不会引起重排、重绘\\n  // ...\\n  // 第三次操作修改 border\\n  renderEle.style.border = '2px solid #ccc';// DOM不存在渲染树上不会引起重排、重绘\\n  renderEle.style.display = 'block';// 导致重排（重排会引起渲）\\n```\\n  以上对隐藏的DOM元素操作不会引发其他元素的重排，这样只在隐藏和显示时触发2次重排。\\n \\n #### 脱离文档流： 使用 absolute 或 fixed 脱离文档流（`减小重排范围`）：\\n```html\\n<!-- html -->\\n<div id='demo'>\\n  <span id=\\\"demo-one\\\">\\n    我是demo 1号\\n  </span>\\n  <span id=\\\"demo-two\\\">\\n    我是demo 2号\\n  </span>\\n  <span id=\\\"demo-there\\\">\\n    我是demo 3号\\n  </span>\\n</div>\\n```\\n\\n```js\\n// javascript\\nconst renderEle = document.getElementById('demo-one');\\nrenderEle.style.padding = '15px 20px'; // 导致重排（重排会引起重绘）\\nrenderEle.style.height = '60px'; // 导致重排（重排会引起重绘）\\n```\\n将需要重排的元素，position属性设为absolute或fixed(某些特殊场合)，减小重排范围。\\n```js\\n  // javascript\\n  const renderEle = document.getElementById('demo-one');\\n  renderEle.style.position = 'fixed'; // 导致重排（重排会引起重绘）\\n  renderEle.style.padding = '15px 20px'; // 导致重排（只有当前元素）\\n  renderEle.style.height = '60px'; // 导致重排（只有当前元素）\\n```\\n这样此DOM元素就脱离了文档流，它的变化不会影响到其他元素。\\n\\n#### 善用内存：在内存中多次操作DOM，再整个添加到DOM树(`减小重排范围`)\\n举例：异步请求接口获取数据，动态渲染到页面\\n\\n```html\\n<!-- html -->\\n<div id=\\\"demo\\\">\\n  <ul id=\\\"father\\\">\\n    <li>我是0号,我后面还有1号、2号、3号、4号、5号</li>\\n  </ul>\\n</div>\\n```\\n\\n```js\\n// javascript\\nconst ulEle = document.getElementById(\\\"father\\\");\\nlet arr = [];\\nsetTimeout( () => {\\n  arr = \\\"我是0号,我后面还有1号，2号，3号，4号，5号\\\", \\\"我是2号\\\", \\\"我是3号\\\", \\\"我是4号\\\", \\\"我是5号\\\"]; // 我是动态获取的\\n  arr.forEach(element => {\\n    const childNode = document.createElement('li');\\n    childNode.innerText = element;\\n    ulEle.appendChild(childNode);// 每一次都会引起重排（重排会引起重绘）\\n  })\\n},1000)\\n```\\n导致多次重排；\\n可以进行以下修改(构建整个ul，而不是循环添加li)：\\n\\n```html\\n<!-- html -->\\n<div id=\\\"demo\\\"></div>\\n```\\n\\n```js\\n// javascript\\nconst ulEle = document.getElementById(\\\"demo\\\");\\nconst childUlNode = document.createElement('ul');\\nlet arr = [];\\nsetTimeout(() => {\\n  arr = [\\\"我是0号,我后面还有1号，2号，3号，4号，5号\\\",\\\"我是1号\\\", \\\"我是2号\\\", \\\"我是3号\\\", \\\"我是4号\\\", \\\"我是5号\\\"]; // 我是动态获取的\\n   arr.forEach(element => {\\n     const childLiNode = document.createElement('li');\\n     childLiNode.innerText = element;\\n     childUlNode.appendChild(childLiNode);\\n   })\\n},1000)\\nulEle.appendChild(childUlNode);// 只会引起一次重排（重排会引起重绘）\\n```\\n\\n#### 读写分离：将写入的值缓存，读取缓存的值（`减少重排次数`）\\n 有一些浏览器针对重排做出来优化。<br/>\\n 比如Opera：当你触发重排的条件到达一定量的时候， 或者等到一定时间的时候，或者等一个线程结束，再一起进行重排；但除了渲染树的直接变化，当获取一些属性时，浏览器为取得正确的值也会触发重排。这样就使得浏览器的优化失效了；\\n \\n```html\\n<!-- html -->\\n<span id=\\\"demo\\\">\\n  我是demo\\n</span>\\n```\\n\\n```js\\n  // javascript\\n  const offsetWidth = '100px';\\n  const renderEle = document.getElementById('demo');\\n  renderEle.style.offsetWidth = offsetWidth // 导致重绘(写入)\\n  const tempoOffsetWidth = renderEle.style.offsetWidth // 读取可能会导致重排\\n```\\n上述代码中可使用读写分离（写入值的时候进行缓存），避免多次重排；\\n```js\\n  // javascript\\n  const offsetWidth = '100px';\\n  const renderEle = document.getElementById('demo');\\n  renderEle.style.offsetWidth = offsetWidth // 导致重绘(写入)\\n  const tempoOffsetWidth = renderEle； // 避免直接读取offsetWidth\\n```\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/280d96ff3e35490f9354e3b895d2caac~tplv-k3u1fbpfcp-watermark.image?)\\n真的不能再加班了，要跑路了，内卷太可怕，消耗不起了，兄弟们\\n在下告辞！！！\\n",
        "tags": [
            "前端",
            "HTML",
            "性能优化"
        ]
    },
    {
        "article_id": "7195013123860856889",
        "cover_image": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/77a467de9a0a45bb8f6e066cf9ced429~tplv-k3u1fbpfcp-watermark.image?",
        "title": "全球首个面向遥感任务设计的亿级视觉Transformer大模型",
        "brief": "深度学习在很大程度上影响了遥感影像分析领域的研究。然而，大多数现有的遥感深度模型都是用ImageNet预训练权重初始化的，其中自然图像不可避免地与航拍图像相比存在较大的域差距。",
        "user_name": "京东云开发者",
        "view_count": 539,
        "collect_count": 0,
        "comment_count": 0,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/b9a366997037d998063135bd56302b85~300x300.image",
        "category": "人工智能",
        "content": "##### 作者：京东探索研究院\\n\\n深度学习在很大程度上影响了遥感影像分析领域的研究。然而，大多数现有的遥感深度模型都是用ImageNet预训练权重初始化的，其中自然图像不可避免地与航拍图像相比存在较大的域差距，这可能会限制下游遥感场景任务上的微调性能。\\n\\n \\n\\n为此，**京东探索研究院联合武汉大学、悉尼大学**借助迄今为止最大的遥感场景标注数据集MillionAID，从头开始训练包括卷积神经网络（CNN）和已经在自然图像计算机视觉任务中表现出了良好性能的视觉Transformer（Vision Transformer）网络，首次获得了一系列基于监督学习的遥感预训练基础骨干模型。并进一步研究了ImageNet预训练（IMP）和遥感预训练（RSP）对包括语义分割、目标检测在内的一系列下游任务的影响。\\n\\n \\n\\n实验结果证实了探索研究院先前提出的先进Vision Transformer系列模型ViTAE在遥感任务上的优越性，并发现RSP在遥感任务上的有效性以及感知相关语义方面具有的独特性。实验结果进一步表明RSP会受到上下游任务差异的影响，这些发现对遥感大规模数据集和预训练方法提出了新的要求。\\n\\n \\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/69ddeba3667f454b9e379890fc22c5ae~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n\\n**01**\\n\\n**研究背景**\\n\\n近年来，深度学习凭借自动提取反映物体固有属性的深度特征的优势，在计算机视觉领域取得了令人印象深刻的突破，遥感领域也不例外。在遥感领域，最常用的是深度模型是卷积神经网络（CNN）。 目前，几乎所有的遥感深度模型都是在计算机视觉领域最著名的图像数据集 ImageNet-1K 数据集上进行预训练，该数据集中来自 1,000 个不同类别的百万张真实世界图像使模型能够学习强大的表示。然后这些预训练后的模型被可以用做遥感任务的骨干网络进行进一步微调。\\n\\n \\n\\n尽管这些模型在遥感任务中取得了显著的效果，但仍有一些问题需要研究。直观地说，与自然图像相比，遥感图像在视角、颜色、纹理、布局、对象等方面明显存在较大的域差距。以前的方法试图通过进一步微调遥感图像数据集上的预训练模型来缩小这一差距。然而，ImageNet预训练（IMP）引入的系统偏差对性能有着不可忽视的副作用。另一方面，我们注意到，随着遥感技术的进步，各种各样的传感器捕捉到了丰富的遥感图像，可以用于预训练。作为一个代表性的例子，MillionAID 是迄今为止最大的遥感图像数据集，它是从包含多种传感器图像的谷歌地球（GE）上收集的，并且具有类似ImageNet-1K的百万级图像数量规模，这使遥感预训练（RSP）成为可能。\\n\\n \\n\\nRSP能够从头开始训练深度模型，这意味着候选模型不必局限于现成的CNN。因此，在本文中，我们也研究了视觉Transformer（Vision Transformer）的骨干网络，它们在计算机视觉领域表现出了令人惊讶的性能。与CNN中擅长局部建模的卷积相比，Vision Transformer中的多头自注意（MHSA）能够灵活地捕捉不同的全局上下文。最近，探索研究院提出的ViTAE模型探索了卷积和MHSA的平行结构，以同时建模局部性和长程依赖性，在ImageNet分类任务和下游视觉任务上取得了很好的结果。此外，它还通过扩张卷积模块和层级设计提取多尺度特征，这对于计算机视觉下游任务，尤其是在遥感图像理解任务，都具有重要的价值。因此我们研究了CNN和层级Vision Transformer网络经过RSP后，在场景识别、语义分割、目标检测和变化检测等遥感任务上的微调性能。为了实现这些目标，我们在九个流行的数据集上进行了广泛的实验，并得出了一些有益的结论。RSP是遥感图像理解中的一个新兴研究方向，但仍处于探索阶段，尤其是基于Vision Transformer这种新型网络架构的预训练方法。我们希望这项研究能够填补这一空白，并为未来的研究提供有用的见解。\\n\\n \\n\\n**02**\\n\\n**MillionAID, ViTAE** **和ViTAEv2的介绍**\\n\\n \\n\\n**1.MillionAID**\\n\\nMillionAID 是迄今为止遥感领域最大的数据集。它包含 100,0848 个不重叠的场景，有51类，每类大约有2,000-45,000图像。该数据集来自谷歌地球，由包括但不限于 SPOT、IKONOS、WorldView 和 Landsat 系列的多种传感器组成，因而图像分辨率不同。最大分辨率可达0.5m，最小的则有153m。图像大小范围从 110*110 到 31,672*31,672。该数据集均为RGB图像，非常适合训练典型的视觉神经网络模型。\\n\\n \\n\\n**2.ViTAE** **和ViTAEv2**\\n\\n  \\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d717f35bbb2d456da34851ae9466a762~tplv-k3u1fbpfcp-watermark.image?)\\n\\nViTAE是探索研究院最近提出的先进Vision Transformer模型，它采用深窄式设计，在网络开始时迅速降采样，然后将网络加深，在提高性能的同时降低模型大小和计算成本。ViTAE 模型首先通过三个Reduction Cell将输入图像下采样到1/16分辨率。与 ViT 类似，在添加位置编码之前，将class token与第三个Reduction Cell的输出连接。然后堆叠多个Normal Cell，并始终保持特征图分辨率。最后一个Normal Cell的class token输入到线性层进行分类。ViTAE 模型在 ImageNet 数据集上分类性能表现出色，但它不方便像CNN那样产生层次化的中间特征，从而迁移到分割、检测和姿态估计等其它下游任务（目前有一些新技术来解决这个问题，例如ViTDet，并已取得较好成果，请关注我们的复现Repo：https://github.com/ViTAE-Transformer/ViTDet）。\\n\\n \\n\\n在此基础上，探索研究院提出了 ViTAEv2，它采用了 ResNet 和 Swin 等流行骨干网络的层次化设计。在 ViTAEv2 中，网络被分成四个阶段。每个阶段首先采用Reduction Cell进行下采样，然后堆叠多个 Normal Cell进行特征变换。在最后一个阶段的Normal Cell后使用全局平均池化层来替换class token。当对下游任务进行微调时，该池化层被移除，剩下的网络与相应任务的解码器相连。图 2 显示了原始 ViTAE 和 ViTAEv2的网络架构。\\n\\n \\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e386cc2d0d84e3397570cb810dda3bb~tplv-k3u1fbpfcp-watermark.image?)\\n \\nReduction Cell和Normal Cell是 ViTAE 中最重要的两个模块，它们是基于典型的Transformer模块来构建的。Reduction Cell用于下采样并提供多尺度上下文。具体来说，在输入归一化层和 MHSA 层之前，这些特征会通过一个金字塔缩减模块（PRM）。该模块包含具有不同扩张率的多个并行的扩张卷积，其中步幅大小控制了空间降采样率。在 PRM 后，来自平行分支的特征在通道维连接。PRM 将 CNN 的尺度不变性引入 ViTAE，而局部性建模则是通过将输入到PRM 的特征同时送入到并行卷积模块 （PCM） 中来完成。PCM 位于与包含 PRM 和 MHSA 的全局依赖路径平行的附加分支中，它由三个连续的卷积层组成。通过调整步幅，PCM 的下采样率与 PRM 相同。来自MHSA、PCM 和原始残差分支的三个特征在输入前馈网络（FFN）之前进行加法融合。需要注意的是，Normal Cell和Reduction Cell具有类似结构，但是不包括 PRM模块。\\n\\n \\n\\n受 Swin Transformer的启发，ViTAEv2中上述cell中的一些 MHSA 被替换为窗口MHSA（WMHSA）以降低计算成本。考虑到后期特征尺寸变小，不需要用窗口划分特征。因此，只有前两个阶段的 MHSA 被 WMHSA 替代。需要说明的是，ViTAEv2采用的 WMHSA 不需要像Swin Transformer那样进行循环偏移，因为 WMHSA 是在 PRM 的合并多尺度特征上进行的，其中不同区域之间已经通过扩张卷积的重叠感受野实现了信息交换。此外，因为卷积已经能够编码位置信息，ViTAEv2也不需要再使用相对位置编码。ViTAE 和 ViTAEv2 中不同cell的详细结构和比较如图3所示。\\n\\n \\n\\n在本次研究中，我们主要评估原始 ViTAE 的“Small”版本，名为 ViTAE-S。相应的，我们还采用了 ViTAEv2-S 模型，因为它具有出色的表征能力和对下游任务更好的可迁移性。\\n\\n \\n\\n**03**\\n\\n**遥感预训练的实施**\\n\\n \\n\\n**1.** **确定预训练模型**\\n\\n我们首先确定用于RSP的深度模型的类型。为此，我们从MillionAID官方训练集中构建了一个迷你训练集和迷你评估集，分别有9775和225张图像。注：后一组是通过从每个类别中随机选择5张图像来平衡类别。对于CNN，使用了经典的ResNet-50 。由于本研究主要探讨RSP下的CNN和Vision Transformer模型的性能，因此我们还评估了一系列典型的基于Vision Transformer的网络，包括DeiT-S 、PVT-S 和Swin-T。选择特定版本模型的一个考量是为了确保这些模型和ResNet-50以及ViTAE-S模型具有相似的参数量。此外，考虑到ViT是视觉Transformer的最基本模型，我们选择了其最小版本ViT-B 模型以供参考。\\n\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a9e3b0336e114b01826592c64c59203b~tplv-k3u1fbpfcp-watermark.image?)\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9487e9a9a6444d49a752c088264fc656~tplv-k3u1fbpfcp-watermark.image?)\\n\\n表II展示了各个模型的结果，可以看出，尽管ViT-B的参数最多，但其性能不如经典的ResNet-50。DeiT-S表现最差，因为我们没有采用教师模型辅助训练。由于我们的任务是利用遥感图像进行预训练，因此获取相应的教师模型可以认为是我们的目标而不是前提。通过引入特征金字塔的设计范式，PVT-S与ViT-B相比提高了准确性。在此基础上，原始ViTAE-S模型进一步考虑了局部性和尺度不变性这些传统CNN具有的归纳偏置。\\n\\n \\n\\n然而，由于早期下采样模块（Reduction Cell, RC）中的特征分辨率较大，需要更多的计算，因此需要花费较多的训练时间。Swin-T通过在固定窗口中限制MHSA来解决这个问题，并采用窗口偏移来隐式促进窗口之间的通信。ViTAEv2引入了这种窗口多头自注意力（Window MHSA, WMHSA），并因为卷积旁路已经能够促进跨窗信息交互，从而省去了窗口偏移和相对位置编码操作。最终，ViTAEv2-S实现了最佳性能，并以2.3%的top-1准确率超过了第二名。\\n\\n \\n\\n基于上述结果，我们选择候选模型的具体程序如下。首先，我们选择ResNet-50作为常规CNN中的代表网络。经过遥感预训练的ResNet-50，可以在一系列遥感数据集上提供一组新的CNN参考基线。由于准确率低、参数多，我们没有选择DeiT-S和ViT-B模型作为候选模型。此外，由于堆叠Transformer的设计，它们很难迁移到下游任务中。（目前有一些新技术来解决这个问题，例如ViTDet，并已取得较好成果，请关注我们的复现Repo：https://github.com/ViTAE-Transformer/ViTDet）。\\n\\nSwin Transformer也具有PVT的特征金字塔结构，并采用WMHSA取代全局MHSA，节省了显存和计算量。由于Swin-T的top-1精度大于PVT且需要的训练时间较少，因此我们在后续实验中也选择了Swin-T作为候选模型。对于ViTAE模型，我们选择性能最强的模型，即ViTAEv2-S，以期望在后续任务（如遥感场景识别）中具有良好的性能。\\n\\n \\n\\n**2.** **获得合适的权重**\\n\\n在确定上述候选模型后，我们对它们进行 RSP 以获得预训练的权重。具体来说，为了保持类别平衡，我们在 MillionAID 数据集的每个类别中随机选择 1,000 张图像，形成包含 51,000 张图像的验证集，与包含 50,000 张图像的 ImageNet 验证集的规模相当，并把剩下的 949,848 张图像用于训练。 \\n\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42e09df555c24b179caa142ca6767033~tplv-k3u1fbpfcp-watermark.image?)\\n\\n为了获得合适的预训练权重，我们在不同训练代数（epoch）的配置下分别训练 ViTAEv2-S 模型。结果如表III所示。可以观察到模型在大约 40 个 epoch 后开始性能饱和，因为与训练 20 个 epoch 相比，top-1 准确率仅提高了 0.64%，而接下来的 20 个 epoch 只带来了 0.23% 的增益。因此，我们首先选择训练了 40 个 epoch 的网络权重作为 ViTAEv2-S 的 RSP 参数，并应用于后续任务。直觉上，在大规模预训练数据集上表现良好的模型在下游任务上也会表现良好。因此，我们还在下游任务中使用了经过 100 个 epoch 训练的网络权重。这些模型分别用后缀“E40”和“E100”表示。\\n\\n \\n\\n对于 ResNet-50 和 Swin-T，我们遵循Swin 的训练设置，即模型训练了 300 个 epoch。在实验中，我们观察到 Swin-T-E120 在验证集上的 top-1 准确率大致相当于 ViTAEv2-S-E40。因此，我们也选择了 Swin-T-E120 的训练权重。同样，我们也选择了最终的网络权重 Swin-T-E300 作为与 ViTAEv2-S-E100 的比较。为了使实验公平，还考虑了使用 40 个 epoch 训练的 ResNet-50 和 Swin-T 的权重，因为它们与 ViTAEv2-S-E40 经过了同样的训练代数。\\n\\n \\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/777601fb2c5c4705aab44a7000363985~tplv-k3u1fbpfcp-watermark.image?)\\n\\n最终的预训练模型列在表IV中。可以看出，验证集准确率几乎随着训练 epoch 的增加而增加。但是，Swin-T-E300 的性能略低于 Swin-T-E120。尽管如此，我们仍然保留了Swin-T-E300 模型。因为模型在训练阶段见到更多的样本之后，它可能具有更强的泛化能力。\\n\\n \\n\\n**04**\\n\\n**下游任务上的微调实验**\\n\\n**1.** **场景识别**\\n \\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/625151a372ac4135aa0cb66856810d59~tplv-k3u1fbpfcp-watermark.image?)\\n\\n**定量实验：** 表 V 展示了使用不同方法预训练的上述候选模型和其他 SOTA 方法的结果。最后三组中的粗体字表示每组中最好的结果，而“*”表示所有模型中最好的（在其他任务中含义相同）。与 ImageNet 预训练的 ResNet-50 相比，我们的遥感预训练 ResNet-50 在所有设置下均提高了准确性。这些结果意味着 RSP 为后续微调过程的优化带来了更好的起点。同样，RSP-Swin-T 在三个设置上的表现优于 IMP-Swin-T，在其他两个设置上也取得了可比较的结果。此外，与其他复杂方法相比，ResNet-50 和 Swin-T 仅使用 RSP 权重而不改变网络结构的情况下就取得了有竞争力的结果，从而证明了遥感预训练的价值。\\n\\n \\n\\n此外，在比较 ImageNet 预训练的 ResNet-50 和 Swin-T 时，我们可以发现 IMP-Swin-T 在所有设置上的表现都更好，因为Vision Transformer具有更强的上下文建模能力。不过在通过 RSP 权重进行初始化后，ResNet 变得更具竞争力。由于 ViTAEv2-S同时具有局部建模能力和远程依赖建模能力，无论 IMP 和 RSP，它在几乎所有设置上都优于 ResNet-50 和 Swin-T。此外，RSP-ViTAEv2-S 在除 AID （5:5） 之外的几乎所有设置上都实现了最佳性能。\\n\\n \\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70c8bd5663a34d56bc569a142ba5b633~tplv-k3u1fbpfcp-watermark.image?)\\n\\n**定性实验**：图4 显示了不同评估模型来自各种场景的图像的不同区域的响应。与 IMP-ResNet-50 相比，RSP-ResNet-50 更关注重要目标。这意味着 RSP 有助于 ResNet-50 学习更好的表示，归功于 MillionAID 数据集中提供的大量语义相似的遥感图像。令人惊讶的是，IMP-Swin-T 模型主要关注背景区域，但经过 RSP 之后，其前景响应得到了显著增强。ViTAEv2-S通过结合CNN和视觉转换器的优势，同时具备局部和全局上下文捕捉能力，实现了对整个场景的全面感知。RSP-ViTAEv2-S 不仅关注主要对象，还考虑了背景中的相关区域。在前景物体上，RSP-ViTAEv2-S 也能给予更高的关注度，在对象分布复杂的场景，RSP-ViTAEv2-S能够形成统一且完整的地物表征，有效感知场景的整体信息。\\n\\n \\n\\n**2.** **语义分割**\\n\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/247ad7d810f94065b538f40c06fb5bda~tplv-k3u1fbpfcp-watermark.image?)\\n\\n**定量实验：** 表VII 展示了采用UperNet 框架时，我们的方法和其他 SOTA 方法在iSAID数据集上的分割结果。可以看出，将骨干网络从 ResNet-50 更改为 Swin-T，再更改为 ViTAEv2-S 时，性能有所提高。结果与上述场景识别结果一致，表明视觉Transformer具有更好的表示能力。另一方面，经过ImageNet预训练的IMP-Swin-T 取得了具有竞争力的结果，而IMP-ViTAEv2-S 在 iSAID 数据集上取得了最佳性能。表VII 还显示了 RSP 模型的优势在于感知一些具有明确遥感语义的类别，例如“桥梁”，这符合之前场景识别任务中的发现。\\n\\n \\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78e68eb040114c1b8164efd773edc1be~tplv-k3u1fbpfcp-watermark.image?)\\n\\n**定性实验：** 图 6 中展示了在 Potsdam 数据集上采用不同预训练骨干网络的UperNet 分割模型的一些视觉分割结果。对于长条形地物，其长度较长，要求模型能够捕获长程上下文，而宽度又较窄，对模型的局部感知能力又提出了要求，而ViTAEv2网络因为将CNN的局部性和尺度不变性引入到Vision Transfomer网络中，同时具有了CNN和Transformer的优势，因而能够同时实现全局和局部感知。因此，只有ViTAEv2-S成功连接了长条状低矮植被（如红框所示）。\\n\\n**3.** **目标检测**\\n\\n \\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a50c26b30d248c98f7847ce3489db4e~tplv-k3u1fbpfcp-watermark.image?)\\n\\n**定量实验：** 表VIII 显示了 目标检测实验的结果。在具有挑战性的 DOTA 数据集上，可以看出使用先进的 ORCN 检测框架，采用ResNet-50 或 Swin-T 骨干网络的模型表现良好。ViTAEv2-S 通过引入了 CNN 的局部性和尺度不变性等归纳偏差，获得了惊人的性能，将 ORCN 基线提高了近 2% mAP。需要注意的另一点是，RSP在这三个骨干网络上的性能都优于IMP。RSP-ViTAEv2-S 的总体mAP比IMP-ViTAEv2-S 高，因为 RSP 在“桥梁”以及包括“直升机”和“飞机”在内的飞行器类别上具有显着优势，而在其他类别上，这两种模型之间的差距并不很大。\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e35d11e3f9b5418ab1aeff1dc400f558~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n**定性实验：** 图7 可视化了 DOTA 测试集上使用 ViTAEv2-S 骨干网络的 ORCN 模型的一些检测结果。红框表示，当对象密集分布时，RSP-ViTAEv2-S 仍然可以预测正确的对象类别，而 IMP-ViTAEv2-S 被密集上下文混淆并做出错误预测。对于长条形的“桥梁”类别，IMP-ViTAEv2-S 产生了漏检（见黄色框），而 RSP-ViTAEv2-S 模型以更高的置信度分数成功检测到该物体，这再一次呼应了先前的发现。\\n\\n**4.** **变化检测**\\n\\n \\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2bfc30b0fdc344dd8f057ab9f1b6a14d~tplv-k3u1fbpfcp-watermark.image?)\\n\\n**定量实验：** 表X 中展示了采用不同预训练骨干网络的BIT 框架在变化检测任务上的定量实验结果。可以看到，自监督的 SeCo 预训练权重在此任务上表现良好，虽然SeCo 的目标是经过对比学习以实现季节不变性特征学习，但由于其采用了多头子空间嵌入的方式对变化特征进行编码，所以其仍然能在具体的分支上学习到对季节变化敏感的特征表示。尽管如此，通过 IMP 或 RSP 预训练的 ViTAEv2-S 的性能优于 SeCo-ResNet-50，显示了使用先进骨干网络的好处。与其他方法相比，ViTAEv2-S取得了最佳性能，显示了将先进的Vision Transformer模型应用于遥感领域的潜力。\\n\\n \\n\\n通过不同模型在不同任务下RSP和IMP下的性能对比，我们可以推断出变化检测所需表示的粒度应该介于分割和检测之间，因为它虽然是一个分割任务，但是只有两个类别，不需要去识别特定的语义类别。\\n\\n \\n\\n \\n\\n**定性实验：** 图8展示了一些视觉变化检测结果。可以看出，IMP 的 ResNet-50 和 Swin-T 并不能很好地检测到自然场景中田野内道路的变化。采用 RSP 可以部分缓解这个问题。SeCo-ResNet-50 进一步提高了道路区域的检测，这与表X 中的结果一致。与上述模型相比，ViTAEv2-S 模型有效地捕捉到了道路细节。在人工变化的场景中，ViTAEv2-S 模型解决了所有其他模型结果中存在的对象粘连问题，这表明 ViTAEv2-S 的特征在区分物体和背景方面更具判别力。\\n\\n \\n\\n**5.** **不同遥感预训练骨干网络的综合比较**\\n\\n \\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42f9ec57ac9341bba4e5dbe34672194b~tplv-k3u1fbpfcp-watermark.image?)\\n\\n最后，我们全面比较了 RSP 在所有任务上的不同骨干网络的性能。具体来说，我们对每个任务的所有数据集的分数进行平均计算，结果如表XI。可以发现，预训练更多 epoch 的骨干通常在下游任务上表现更好，因为它们获得了更强的表示。尽管也有例外，例如预训练300代的 Swin-T 模型在对象检测任务表现不如预训练120代的对应模型，这暗示任务差异也很重要。结合了 CNN 和Vision Transformer优势的ViTAEv2-S模型在所有任务上都表现出了最好的性能。\\n\\n \\n\\n**05**\\n\\n**结论**\\n\\n \\n\\n在这项研究中，我们在最大的遥感数据集 MillionAID 上研究了基于 CNN 和Vision Transformer的遥感预训练问题，并综合评估了它们在场景识别、语义分割、对象检测和变化检测四个下游任务上的表现，并将它们与 ImageNet 预训练和其他 SOTA 方法进行比较。通过综合分析实验结果，我们得出以下结论：\\n\\n（1） 与传统的 CNN 模型相比，视觉Transformer在一系列遥感任务上表现出色，特别是 ViTAEv2-S这种将 CNN 的固有归纳偏置引入到Vision Transformer的先进模型，在这些任务的几乎所有设置中都实现了最佳性能。\\n\\n（2） 经典 IMP 使深度模型能够学习更通用的表示。因此，IMP 在处理遥感影像数据时，仍可以产生具有竞争力的基线结果。RSP 产生了可与 IMP相当或者更好的结果，并且由于减轻了上游预训练任务和下游任务之间的数据差异，因此在某些特定类别（例如“桥梁”和“飞机”）上表现更为出色。\\n\\n（3） 任务之间的差异对 RSP 的性能也有影响。如果特定下游任务所需的表示更接近上游预训练任务（例如场景识别），则 RSP 通常会带来更好的性能。\\n\\n \\n\\n我们希望这项研究可以为遥感社区提供有关使用先进Vision Transformer和遥感预训练的有用见解。为了方便大家使用，所有遥感预训练模型及相关代码均已开源，详见https://github.com/ViTAE-Transformer/ViTAE-Transformer-Remote-Sensing 。另外，关于采用非层次化Vision Transformer模型应用于下游任务的研究进展，可以关注ViTDet的方法以及我们的复现代码：https://github.com/ViTAE-Transformer/ViTDet 。我们也会在ViTAE-Transformer-Remote-Sensing的官方repo中不断更新相应的结果。\\n\\n \\n论文链接：https://arxiv.org/abs/2204.02825\\n\\n项目地址：https://github.com/ViTAE-Transformer/ViTAE-Transformer-Remote-Sensing\\n\\n \\n\\n参考文献\\n\\n[1] D.Wang, J. Zhang, B.Du, G-S.Xia and and D. Tao, “An Empirical Study of Remote Sensing Pretraining”, arXiv preprint, axXiv: 2204: 02825, 2022.\\n\\n[2] Y. Long, G.-S. Xia, S. Li, W. Yang, M. Y. Yang, X. X. Zhu, L. Zhang, and D. Li, “On creating benchmark dataset for aerial image interpretation: Reviews, guidances and million-aid,” IEEE JSTARS, vol. 14, pp. 4205–4230, 2021.\\n\\n[3] Y. Xu, Q. Zhang, J. Zhang, and D. Tao, “Vitae: Vision transformer advanced by exploring intrinsic inductive bias,” NeurIPS, vol. 34, 2021.\\n\\n[4] Q. Zhang, Y. Xu, J. Zhang, and D. Tao, “Vitaev2: Vision transformer advanced by exploring inductive bias for image recognition and beyond,” arXiv preprint arXiv:2202.10108, 2022.\\n\\n[5] T. Xiao, Y. Liu, B. Zhou, Y. Jiang, and J. Sun, “Unified perceptual parsing for scene understanding,” in ECCV, 2018, pp. 418–434.\\n\\n[6] X. Xie, G. Cheng, J. Wang, X. Yao, and J. Han, “Oriented r-cnn for object detection,” in ICCV, October 2021, pp. 3520–3529.\\n\\n[7] H. Chen, Z. Qi, and Z. Shi, “Remote Sensing Image Change Detection With Transformers,” IEEE TGRS., vol. 60, p.3095166, Jan. 2022.\\n\\n[8] Y. Li, H. Mao, R. Girshick, K. He. Exploring Plain Vision Transformer Backbones for Object Detection[J]. arXiv preprint arXiv:2203.16527, 2022.",
        "tags": [
            "图像识别",
            "视觉设计",
            "设计模式"
        ]
    },
    {
        "article_id": "7195038860672729148",
        "cover_image": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9229d217a5f643f3b5719809546d30a1~tplv-k3u1fbpfcp-watermark.image?",
        "title": "重磅好文透彻理解,异构图上 Node 分类理论与DGL源码实战",
        "brief": "重磅好文透彻理解,异构图上 Node 分类理论与DGL源码实战 书接上文，关注过作者历史文章的读者都知道，图上机器学习/深度学习系列文章 从 一文揭开图机器学习的面纱，你确定不来看看吗 开始，已经陆续",
        "user_name": "算法全栈之路",
        "view_count": 561,
        "collect_count": 0,
        "comment_count": 0,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/36781aea4e3055ff728dde4d90580bd5~300x300.image",
        "category": "人工智能",
        "content": "重磅好文透彻理解,异构图上 Node 分类理论与DGL源码实战\\n\\n* * *\\n\\n书接上文，关注过作者历史文章的读者都知道，**图上机器学习/深度学习系列文章** 从 [一文揭开图机器学习的面纱，你确定不来看看吗](https://mp.weixin.qq.com/s/6dDz9QFjQOh5RuK4pMx9Kg) 开始，已经陆续和大家一起了解了 **同构图上的链接预测、节点分类与回归、边分类与回归** 等机器学习任务，不熟悉的同学可以去作者的历史文章里查找哦。\\n\\n如上所说，以前介绍 **图上机器学习任务** 的文章， 均是在 **同构图** 上进行的，忽略了图上不同节点以及不同边的独特性质，而是把所有节点当作一种节点来看待的。这个虽然可以解决一部分问题，但是该**关系建模能力也不足以覆盖现实世界** 中复杂多变的多种关系，所以就轮到我们的 **异构图关系建模** 文章出马了。\\n\\n针对 **异构图** 上关系的建模，因为其 **工程实现的复杂性** ，目前的学术界和工业界均存在一定的 **实现难度** 。我知道的甚至很多图深度学习框架在最新的版本里还 **不支持** 对异构图的建模。好在亚马逊的DGL框架在最新的几个版本中，已经更新了对异构图的工程实现，下面就让我们结合DGL的实现源码来一起了解下 **异构图上节点分类/回归任务** 吧 ～ go go go !!!\\n\\n注意：我们的文章里，把分类回归任务一起囊括了因为这来那个任务除了 **输入和损失不同** 以外，网络结构并没有别的不同，分类回归任务彼此修改互用也比较容易，这里就不再进行区分了。本文说是节点分类任务，但是其实回归任务也差不太多。\\n\\n* * *\\n\\n### (1) 异构图节点分类任务理论基础\\n\\n按照惯例，我们还是先从基础定义引出下文的话题。\\n\\n在以前的文章 [一文揭开图机器学习的面纱，你确定不来看看吗](https://mp.weixin.qq.com/s/6dDz9QFjQOh5RuK4pMx9Kg) 中，我们说图的分类的时候说到了异构图，文中说：**图中节点类型和边类型超过两种的图称为异构图**。这意思就是说异构图中的节点和同2个节点的边可能有多种，例如：图中包括用户，商品，IP三种类型的节点，其中用户和商品之间又有加购物车与购买这两种关系的边。本文所说的图就是这种类型的 **比较复杂** 的图。\\n\\n从 **同构图推广** 来看，既然在异构图中区分了 **节点和边** 的不同类型，那我们在处理根据 **异构图的局部与全局结构特性** 对某个节点进行 **定性分析** 或则 进行两个节点之间 **关系预测** 的时候，就需要从 **更细粒度** 上去对不同的节点和边的关系进行 **区分** 。既然2个节点的某一种关系决定了一种类型的边，一种比较好的方式是： **根据关系(边)类型去组织不同类型的节点** ，然后进行异构图卷积操作，得到对各个类型的节点的 Embeding，在基于此最终完成 **异构图上的机器学习任务** ，就像DGL官方源码实现的那样。\\n\\n所谓 **异构图卷积，顾名思义**： 就是对 **各种边的关系各自分别进行卷积** ，然后将这些关系对应的各种类型的同类型节点进行融合，默认是Sum , 得到各种同类型节点的Embeding, 注意这里每种类型节点只有一个Embeding。 对于 **节点分类** 任务，最后在异构图卷积层结束的时候，可以直接接激活函数，然后分别对每种类型的节点计算出一个Logit, 和有监督的某种类型的 label 计算损失进行回传即可。感兴趣的同学，可以看 **DGL实现的RGCB节点分类任务的源码验证明晰** 以上所说的逻辑。\\n\\n这里需要**特别强调注意** 的是： **在异构图RGCN采样的时候，采样了几层邻居节点，异构图卷积层就有几层异构卷积layer, 分别有每个异构卷积layer去处理每一层的邻居节点**。\\n\\n因为采样是由内向外采样的，而聚合是由外向内聚合的。这里要引入DGL实现采样得到的Block的概念，通俗理解 **Block其实就是采样得到的子图，而这些子图里的边也有对应这开始节点和结束节点以及边类型等和 全Graph同等 的一些属性** 。\\n\\n我们可以这样**理解** ：**DGL实现的Block可以把看作一个数组，数组里的每一个元素是图上一层邻居的采样，Block内部节点是 从远到近的顺序排列内部的Block的，Block数组的下标从小到大对应着采样范围由外到内、覆盖范围由远及近，并且 blocks[i+1]的 source node 和 blocks[i]的target node是可以对应上的。我们知道邻居节点采样其实是按照边的关系去采来确认邻居的，所以在DGL的采样过程中，让 blocks[0]的 src node 包含了 blocks[0]的所有dst node，并且dst 节点出现在src 节点序列的前面若干位置** 。\\n\\n所以我们在代码实现的时候，将 **外层对应节点的Embeding作为内层节点的输入，构成两个互相挨着的卷积层** ，这里采样与工程实现是 **完美互相契合** 的。有疑问的同学，可以去看源码验证哦 ～\\n\\n好吧，整体对异构图的节点分类任务 **抽象** 一下： 既然我们要对异构图上某节点进行分类，那我们就需要综合异构图上该节点邻居节点的信息，得出所求节点的Embeding 信息。 而该节点周围有多种类别关系的节点，则我们就对各个关系分别进行卷积，求得各个关系里面各个节点的Embeding, 然后将多种关系涵盖的多类同类节点 Embeding进行聚合，后面可以接全链接层，也可以不接全链接层直接接激活函数，得到各个节点类型的结果作为输出。对于异构图，最终 **节点分类任务的 Logit 也是 按照节点类别的个数有多个** 。\\n\\n当然针对异构图，我们可以采用 [GraphSage还是HAN ？吐血力作综述Graph Embeding 经典好文](https://mp.weixin.qq.com/s/T1oLgGMUEZYfTGrHVT7-9A) 文章后半部分里介绍的，使用 **MetaPath 结合 Attention 进行 Node 节点级别 与 path语义级别的融合**，类似于 **HAN** 的处理方式。但是 **万丈高楼平地起** ，写代码和写文章，也得慢慢来一点一点儿实现不是～\\n\\n**异构图RGCN节点分类任务** 整体的流程解析就到这里吧，感觉这个地方，还是得看源码才能说清楚。因为整个源码流程比较长，也为了让最后整个代码demo能够完美的运行起来，本篇文章的代码将从 **讲述一个工程的实现** 开始。\\n\\n所以，本文 就让我们一起实现 **基于DGL和异构图的RGCN来进行节点分类回归任务** 。下面就让我们开始 coding 吧 ～\\n\\n* * *\\n\\n### (2) 代码时光\\n\\n开篇先吼一嗓子 ， **talk is cheap , show me the code !!!**\\n\\n本文的代码讲的是 **基于DGL和RGCN实现的异构图上节点分类任务**，整个源码流程是一个 **小型的工业可用的工程**，基于dgl实现，觉得有用赶紧收藏转发吧～\\n\\n**life is short , i use python !!!**\\n\\n#### (2.1) 数据准备\\n\\n我们假设可以输入类似于这样的数据, 其中每2列对应这一种关系，例如 用户2352193 购买了商品CEEC9EBF7，用户用了IP 174.74.201.9登录了账号，用户用IP 174.74.201.9 购买了商品 CEEC9EBF7, label 表示着该用户真的购买商品，最终的节点分类任务是预测用户的购买意愿，是否是我们的高意图潜在用户，二分类。\\n\\n我们可以把这样一份数据存入 `source_data.csv` 文件中，用 pandas 接口把数据读入： `raw_pdf = pd.read_csv('./source_data.csv')`\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/74f5fa7363d34c0894ca2005cf16444b~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n因为对于 **异构图** 模型，节点和边的类型均有多种，为了处理方便，我们可以把各种类型的节点进行编码，再到后期对其进行解码，对 pandas 的 dataframe 数据结构的编解码，我们可以使用下面的代码：\\n\\n```\\n@ 欢迎关注微信公众号：算法全栈之路\\n\\n#编码方法\\ndef encode_map(input_array):\\n    p_map={}\\n    length=len(input_array)\\n    for index, ele in zip(range(length),input_array):\\n        # print(ele,index)\\n        p_map[str(ele)] = index\\n    return p_map\\n\\n#解码方法\\ndef decode_map(encode_map):\\n    de_map={}\\n    for k,v in encode_map.items():\\n        # index,ele \\n        de_map[v]=k\\n    return de_map\\n```\\n\\n然后用其中的各列node 进行 编码\\n\\n```\\n@ 欢迎关注微信公众号：算法全栈之路\\n\\nuserid_encode_map=encode_map(set(graph_features_pdf['user_id'].values))\\n# 解码map \\nuserid_decode_map=decode_map(userid_encode_map)\\ngraph_features_pdf['user_id_encoded'] = graph_features_pdf['user_id'].apply(lambda e: userid_encode_map.get(str(e),-1))\\n# print unique值的个数 \\nuserid_count=len(set(graph_features_pdf['user_id_encoded'].values))\\nprint(userid_count)\\n```\\n\\n这里仅仅以 用户节点编码 为例，itemId和 IP同理编解码即可。 最后我们可以把图数据保存，供以后的异构图代码 demo使用。\\n\\n```\\n@ 欢迎关注微信公众号：算法全栈之路\\n\\nfinal_graph_pdf=graph_features_pdf[['user_id_encoded','ip_encoded','item_id_encoded','label']].sort_values(by='user_id_encoded', ascending=True)\\nfinal_graph_pdf.to_csv('result_label.csv',index=False)\\n```\\n\\n基于此，异构图的基础准备数据就结束了，下面开始正式的coding了。\\n\\n* * *\\n\\n#### （2.2） 导包\\n\\n老规矩，先导包，基于DGL和RGCN实现的异构图上节点分类任务只需要这些包就可以了。\\n\\n```\\n@ 欢迎关注微信公众号：算法全栈之路\\n\\nimport argparse\\nimport torch\\nimport torch.nn as nn\\nimport dgl\\nimport torch.optim as optim\\nfrom dgl.dataloading import MultiLayerFullNeighborSampler, EdgeDataLoader\\nfrom dgl.dataloading.negative_sampler import Uniform\\nimport numpy as np\\nimport pandas as pd\\nimport itertools\\nimport os\\nimport tqdm\\nfrom dgl import save_graphs, load_graphs\\nimport dgl.function as fn\\nimport torch\\nimport dgl\\nimport torch.nn.functional as F\\nfrom dgl.nn.pytorch import GraphConv, SAGEConv, HeteroGraphConv\\nfrom dgl.utils import expand_as_pair\\nimport tqdm\\nfrom collections import defaultdict\\nimport torch as th\\nimport dgl.nn as dglnn\\nfrom dgl.data.utils import makedirs, save_info, load_info\\nfrom sklearn.metrics import roc_auc_score\\nimport gc\\ngc.collect()\\n```\\n\\n推荐一个工具，**tqdm 很好用** 哦，结合 **dataloading接口** ， 可以看到模型训练以及数据处理执行的进度，赶紧用起来吧～\\n\\n这里的 sklearn 工具 的导入，仅仅是为了调用他来进行分类模型的离线指标评估，得到AUC等指标而已。\\n\\n**各种模型工具无所谓分类，能解决问题的就是好工具，混用又有何不可呢？ 实用就行**！\\n\\n* * *\\n\\n#### （2.3） 构图\\n\\n数据有了，接下来就是构图了，我们构建的是包含 **三种节点的异构图** 。\\n\\n```\\n@ 欢迎关注微信公众号：算法全栈之路\\n\\n# user 登录 ip\\nu_e_ip_src = final_graph_pdf['user_id_encoded'].values\\nu_e_ip_dst = final_graph_pdf['ip_encoded'].values\\n# user 购买 item \\nu_e_item_src = final_graph_pdf['user_id_encoded'].values\\nu_e_item_dst = final_graph_pdf['item_id_encoded'].values\\n# item和ip 共同出现 \\nip_e_item_src = final_graph_pdf['ip_encoded'].values\\nip_e_item_dst = final_graph_pdf['item_id_encoded'].values\\n# user 购买 label\\nuser_node_buy_label = final_graph_pdf['label'].values\\n\\nhetero_graph = dgl.heterograph({\\n    ('user', 'u_e_ip', 'ip'): (u_e_ip_src, u_e_ip_dst),\\n    ('ip', 'u_eby_ip', 'user'): (u_e_ip_dst, u_e_ip_src),\\n    ('user', 'u_e_item', 'item'): (u_e_item_src, u_e_item_dst),\\n    ('item', 'u_eby_item', 'user'): (u_e_item_dst, u_e_item_src),\\n    ('ip', 'ip_e_item', 'item'): (ip_e_item_src, ip_e_item_dst),\\n    ('item', 'item_eby_ip', 'ip'): (ip_e_item_dst, ip_e_item_src)\\n})\\n\\n# 给 user node 添加标签\\nhetero_graph.nodes['user'].data['label'] = torch.tensor(user_node_buy_label)\\nprint(hetero_graph)\\n```\\n\\n这里的 **异构图**是 无向图 ，**因为无向，所以双向**。 构图的时候就需要构建 **双向的边**。 代码很好理解，就不再赘述了哈。\\n\\n* * *\\n\\n#### （2.4） 模型的自定义函数\\n\\n这里定义了 **异构图上RGCN** 会用到的模型的一系列自定义函数，综合看代码注释，结合上文第一小节的抽象理解，希望能理解的更加深入哦。\\n\\n```\\n@ 欢迎关注微信公众号：算法全栈之路\\n\\nclass RelGraphConvLayer(nn.Module):\\n\\n    def __init__(self,\\n                 in_feat,\\n                 out_feat,\\n                 rel_names,\\n                 num_bases,\\n                 *,\\n                 weight=True,\\n                 bias=True,\\n                 activation=None,\\n                 self_loop=False,\\n                 dropout=0.0):\\n        super(RelGraphConvLayer, self).__init__()\\n        self.in_feat = in_feat\\n        self.out_feat = out_feat\\n        self.rel_names = rel_names\\n        self.num_bases = num_bases\\n        self.bias = bias\\n        self.activation = activation\\n        self.self_loop = self_loop\\n\\n        # 这个地方只是起到计算的作用, 不保存数据\\n        self.conv = HeteroGraphConv({\\n            # graph conv 里面有模型参数weight,如果外边不传进去的话,里面新建\\n            # 相当于模型加了一层全链接, 对每一种类型的边计算卷积\\n            rel: GraphConv(in_feat, out_feat, norm='right', weight=False, bias=False)\\n            for rel in rel_names\\n        })\\n\\n        self.use_weight = weight\\n        self.use_basis = num_bases < len(self.rel_names) and weight\\n        if self.use_weight:\\n            if self.use_basis:\\n                self.basis = dglnn.WeightBasis((in_feat, out_feat), num_bases, len(self.rel_names))\\n            else:\\n                # 每个关系,又一个weight,全连接层\\n                self.weight = nn.Parameter(th.Tensor(len(self.rel_names), in_feat, out_feat))\\n                nn.init.xavier_uniform_(self.weight, gain=nn.init.calculate_gain('relu'))\\n\\n        # bias\\n        if bias:\\n            self.h_bias = nn.Parameter(th.Tensor(out_feat))\\n            nn.init.zeros_(self.h_bias)\\n\\n        # weight for self loop\\n        if self.self_loop:\\n            self.loop_weight = nn.Parameter(th.Tensor(in_feat, out_feat))\\n            nn.init.xavier_uniform_(self.loop_weight,\\n                                    gain=nn.init.calculate_gain('relu'))\\n\\n        self.dropout = nn.Dropout(dropout)\\n\\n    def forward(self, g, inputs):\\n        \\n        g = g.local_var()\\n        if self.use_weight:\\n            weight = self.basis() if self.use_basis else self.weight\\n            # 这每个关系对应一个权重矩阵对应输入维度和输出维度\\n            wdict = {self.rel_names[i]: {'weight': w.squeeze(0)}\\n                     for i, w in enumerate(th.split(weight, 1, dim=0))}\\n        else:\\n            wdict = {}\\n\\n        if g.is_block:\\n            inputs_src = inputs\\n            inputs_dst = {k: v[:g.number_of_dst_nodes(k)] for k, v in inputs.items()}\\n        else:\\n            inputs_src = inputs_dst = inputs\\n\\n        # 多类型的边结点卷积完成后的输出\\n        # 输入的是blocks 和 embeding\\n        hs = self.conv(g, inputs, mod_kwargs=wdict)\\n\\n        def _apply(ntype, h):\\n            if self.self_loop:\\n                h = h + th.matmul(inputs_dst[ntype], self.loop_weight)\\n            if self.bias:\\n                h = h + self.h_bias\\n            if self.activation:\\n                h = self.activation(h)\\n            return self.dropout(h)\\n\\n        #\\n        return {ntype: _apply(ntype, h) for ntype, h in hs.items()}\\n\\n\\nclass RelGraphEmbed(nn.Module):\\n    r\\\"\\\"\\\"Embedding layer for featureless heterograph.\\\"\\\"\\\"\\n\\n    def __init__(self,\\n                 g,\\n                 embed_size,\\n                 embed_name='embed',\\n                 activation=None,\\n                 dropout=0.0):\\n        super(RelGraphEmbed, self).__init__()\\n        self.g = g\\n        self.embed_size = embed_size\\n        self.embed_name = embed_name\\n        self.activation = activation\\n        self.dropout = nn.Dropout(dropout)\\n\\n        # create weight embeddings for each node for each relation\\n        self.embeds = nn.ParameterDict()\\n        for ntype in g.ntypes:\\n            embed = nn.Parameter(torch.Tensor(g.number_of_nodes(ntype), self.embed_size))\\n            nn.init.xavier_uniform_(embed, gain=nn.init.calculate_gain('relu'))\\n            self.embeds[ntype] = embed\\n\\n    def forward(self, block=None):\\n        \\n        return self.embeds\\n\\nclass EntityClassify(nn.Module):\\n    def __init__(self,\\n                 g,\\n                 h_dim, out_dim,\\n                 num_bases=-1,\\n                 num_hidden_layers=1,\\n                 dropout=0,\\n                 use_self_loop=False):\\n        super(EntityClassify, self).__init__()\\n        self.g = g\\n        self.h_dim = h_dim\\n        self.out_dim = out_dim\\n        self.rel_names = list(set(g.etypes))\\n        self.rel_names.sort()\\n        if num_bases < 0 or num_bases > len(self.rel_names):\\n            self.num_bases = len(self.rel_names)\\n        else:\\n            self.num_bases = num_bases\\n        self.num_hidden_layers = num_hidden_layers\\n        self.dropout = dropout\\n        self.use_self_loop = use_self_loop\\n\\n        self.embed_layer = RelGraphEmbed(g, self.h_dim)\\n        self.layers = nn.ModuleList()\\n        # i2h\\n        self.layers.append(RelGraphConvLayer(\\n            self.h_dim, self.h_dim, self.rel_names,\\n            self.num_bases, activation=F.relu, self_loop=self.use_self_loop,\\n            dropout=self.dropout, weight=False))\\n\\n        # h2h , 这里不添加隐层,只用2层卷积\\n        # for i in range(self.num_hidden_layers):\\n        #    self.layers.append(RelGraphConvLayer(\\n        #        self.h_dim, self.h_dim, self.rel_names,\\n        #        self.num_bases, activation=F.relu, self_loop=self.use_self_loop,\\n        #        dropout=self.dropout))\\n        # h2o\\n\\n        self.layers.append(RelGraphConvLayer(\\n            self.h_dim, self.out_dim, self.rel_names,\\n            self.num_bases, activation=None,\\n            self_loop=self.use_self_loop))\\n\\n    # 输入 blocks,embeding\\n    def forward(self, h=None, blocks=None):\\n        if h is None:\\n            # full graph training\\n            h = self.embed_layer()\\n        if blocks is None:\\n            # full graph training\\n            for layer in self.layers:\\n                h = layer(self.g, h)\\n        else:\\n            # minibatch training\\n            # 输入 blocks,embeding\\n            for layer, block in zip(self.layers, blocks):\\n                h = layer(block, h)\\n        return h\\n\\n    \\n    def inference(self, g, batch_size, device=\\\"cpu\\\", num_workers=0, x=None):\\n\\n        if x is None:\\n            x = self.embed_layer()\\n\\n        for l, layer in enumerate(self.layers):\\n            y = {\\n                k: th.zeros(\\n                    g.number_of_nodes(k),\\n                    self.h_dim if l != len(self.layers) - 1 else self.out_dim)\\n                for k in g.ntypes}\\n\\n            \\n            sampler = dgl.dataloading.MultiLayerFullNeighborSampler(1)\\n            dataloader = dgl.dataloading.NodeDataLoader(\\n                g,\\n                {k: th.arange(g.number_of_nodes(k)) for k in g.ntypes},\\n                sampler,\\n                batch_size=batch_size,\\n                shuffle=True,\\n                drop_last=False,\\n                num_workers=num_workers)\\n            \\n            for input_nodes, output_nodes, blocks in tqdm.tqdm(dataloader):\\n                # print(input_nodes)\\n                block = blocks[0].to(device)\\n                        \\n                h = {k: x[k][input_nodes[k]].to(device) for k in input_nodes.keys()}\\n                h = layer(block, h)\\n\\n                for k in h.keys():\\n                    y[k][output_nodes[k]] = h[k].cpu()\\n\\n            x = y\\n        return y\\n```\\n\\n上面的代码主要分为三大块：分别是 **RelGraphConvLayer**、 **RelGraphEmbed** 以及 **EntityClassify** 。\\n\\n首先就是：**RelGraphConvLayer** 。我们可以看到 RelGraphConvLayer 就是我们的 **异构图卷积层layer** , 其主要是调用了DGL实现的 HeteroGraphConv算子，从上面第一小节我们也详细阐述了异构图卷积算子其实就是： **对各种关系分别进行卷积然后进行同类型的节点的融合**。\\n\\n这里我们需要重点关注的是：**RelGraphConvLayer层的返回**，从代码中，我们可以看到，对于每种节点类型是返回了一个Embeding, 维度是 out_feat。如果是带了激活函数的，则是返回激活后的一定维度的一个tensor。\\n\\n过来是 **RelGraphEmbed**。 从代码中可以看到： 这个python类仅仅返回了一个字典，但是这个字典里却包括了 多个 **Embeding Variable**, 注意这里的 Variable 均是可以 **随着网络训练变化更新** 的。我们可以根据节点类型，节点ID取得对应元素的 **Embeding** 。 这种实现方法是不是解决了 前文 [GraphSage与DGL实现同构图 Link 预测，通俗易懂好文强推](https://mp.weixin.qq.com/s/JLJDuiDmRzo53tgOMCrwcQ) 和 [基于GCN和DGL实现的图上 node 分类, 值得一看!!!](https://mp.weixin.qq.com/s/hmKZuTWYZJmFJHFbshkuQQ) 所提到的 **动态更新的Embeding** 的问题呢。\\n\\n最后就是 **EntityClassify类** 了，我们可以看到 这个就是最终的 **模型RGCN结构** 了，包括了 **模型训练的 forward 和用于推断的inference方法**\\n\\n。这里的 inference 可以用于 各个节点的embedding的导出， 我们在后文有实例代码，接着看下去吧～\\n\\n**注意看** forword 方法里 的 `for layer, block in zip(self.layers, blocks)` 这个位置， 这里就是我们前一小节所说的 采样层数和模型的卷积层数目是相同的说法的由来，可以结合上文说明理解源码哦。\\n\\n* * *\\n\\n#### （2.5） 模型采样超参与节点采样介绍\\n\\n先上代码。\\n\\n```\\n@ 欢迎关注微信公众号：算法全栈之路\\n\\n# 根据节点类型和节点ID抽取embeding 参与模型训练更新 \\ndef extract_embed(node_embed, input_nodes):\\n    emb = {}\\n    for ntype, nid in input_nodes.items():\\n        nid = input_nodes[ntype]\\n        emb[ntype] = node_embed[ntype][nid]\\n    return emb\\n\\n# 采样定义,有监督采样和无监督采样不一样\\nbatch_size = 20480\\nneg_sample_count = 1\\n# 采样2层全部节点\\nsampler = MultiLayerFullNeighborSampler(2)\\n\\n# 用户节点采样，这里是对用户的所有邻居采样了2层节点\\nhetero_graph.nodes['user'].data['train_mask'] = torch.zeros(unique_userid_count, dtype=torch.bool).bernoulli(1.0)\\nall_userid_idx = torch.nonzero(hetero_graph.nodes['user'].data['train_mask'], as_tuple=False).squeeze()\\nuser_loader = dgl.dataloading.NodeDataLoader(hetero_graph, {\\\"user\\\": train_userid_nodeids}, sampler,batch_size=batch_size, shuffle=True, num_workers=0)\\n\\n# 训练集和测试集split \\ntrain_count=(int)(len(all_userid_idx) * 0.9)\\nprint(train_count)\\ntrain_userid_nodeids = all_userid_idx[:train_count]\\ntest_userid_nodeids = all_userid_idx[train_count:]\\n\\n# IP节点的邻居采样 \\nhetero_graph.nodes['ip'].data['train_mask'] = torch.zeros(unique_ip_count, dtype=torch.bool).bernoulli(1.0)\\ntrain_ip_nodeids = hetero_graph.nodes['ip'].data['train_mask'].nonzero(as_tuple=True)[0]\\nip_loader = dgl.dataloading.NodeDataLoader(hetero_graph, {\\\"ip\\\": train_ip_nodeids}, sampler,\\n                                           batch_size=batch_size, shuffle=True, num_workers=0)\\n# item 邻居节点采样 \\nhetero_graph.nodes['item'].data['train_mask'] = torch.zeros(unique_ip_prefix_count, dtype=torch.bool).bernoulli(1.0)\\ntrain_ipprefix_nodeids = hetero_graph.nodes['item'].data['train_mask'].nonzero(as_tuple=True)[0]\\nipprefix_loader = dgl.dataloading.NodeDataLoader(hetero_graph, {\\\"item\\\": train_ipprefix_nodeids}, sampler,batch_size=batch_size, shuffle=True, num_workers=0)\\n```\\n\\n这里的代码作者花了大量时间进行优化，**注释和组织形式** 尽量写的非常清晰，非常容易理解。\\n\\n我们这里选择了 **NodeDataLoader** 来进行训练数据的读入，这其实是一种 **分batch训练** 的方法，而 **不是一次性把图全读入内存** 进行训练，而是每次选择 **batch的种子节点以及他们采样的邻居节点** 读入内存参与训练，这也让大的图神经网络训练成为了可能，是 **DGL图深度框架 非常优秀** 的实现 ！！！ **大赞 ！**\\n\\n需要 **注意**的是 ： **extract_embed** 这个方法可以抽取出对应类别对应节点的 Embeding。 我们这里用了 `MultiLayerFullNeighborSampler` 这个接口，对每个种子节点采样了2层的全部邻居参与训练，中间因为是节点分类任务，这里需要将该邻居采样算子 和 `dgl.dataloading.NodeDataLoader` 结合使用。\\n\\n而 **NodeDataLoader** 的第二个参数属于一个字典，其中可以放多个 节点类型以及对应的种子nids , 这里为了方便理解，把拆解成了多个 **data_loader**，来分别对多个类型的节点在图上进行全部邻居的采样，这里的 **实现是等价** 的。\\n\\n作者亲测，图训练的 **batch_size 能选择大尽可能大一些** 吧，不然训练模型会非常慢的～\\n\\n* * *\\n\\n#### （2.6） 模型训练超参与单epoch训练\\n\\n```\\n@ 欢迎关注微信公众号：算法全栈之路\\n\\n# 模型定义\\nnum_class = 2\\nn_hetero_features = 16\\nlabels = hetero_graph.nodes['user'].data['label']\\n\\nhidden_feat_dim = n_hetero_features\\n\\nembed_layer = RelGraphEmbed(hetero_graph, hidden_feat_dim)\\nall_node_embed = embed_layer()\\n\\nmodel = EntityClassify(hetero_graph, hidden_feat_dim, num_class)\\n# 优化模型所有参数,主要是weight以及输入的embeding参数\\nall_params = itertools.chain(model.parameters(), embed_layer.parameters())\\noptimizer = torch.optim.Adam(all_params, lr=0.01, weight_decay=0)\\n\\ndef train_nodetype_one_epoch(ntype, spec_dataloader):\\n    losses = []\\n    # input_nodes 代表计算 output_nodes 的表示所需的节点,input_nodes包含了output_nodes。\\n    # 块 包含了每个GNN层要计算哪些节点表示作为输出，要将哪些节点表示作为输入，以及来自输入节点的表示如何传播到输出节点。\\n    for input_nodes, output_nodes, blocks in tqdm.tqdm(spec_dataloader):\\n        emb = extract_embed(all_node_embed, input_nodes)\\n        batch_tic = time.time()\\n        seeds = output_nodes[ntype]\\n        lbl = labels[seeds]  # 只取output_nodes部分结点参与训练\\n        logits = model(emb, blocks)[ntype]\\n        \\n        loss = F.cross_entropy(logits, lbl)\\n        loss.backward()\\n        optimizer.step()\\n         \\n        train_acc = torch.sum(logits.argmax(dim=1) == lbl).item() / len(seeds)\\n        \\n        print('AUC', roc_auc_score(lbl, logits.argmax(dim=1) ))\\n        print(\\\"Epoch {:05d}  | Train Acc: {:.4f} | Train Loss: {:.4f} | Time: {:.4f}\\\".\\n              format(epoch, train_acc, loss.item(), time.time() - batch_tic))\\n```\\n\\n从上面的代码我们可以看到： 最终我们是进行了 **2分类** ，中间的调用了上面模型定义类 **EntityClassify** 来定义 **异构图上RGCN的模型** 结构，因为是分类问题，损失函数选择了 **交叉熵损失** 。\\n\\n**需要注意**的是： ` all_params = itertools.chain(model.parameters(), embed_layer.parameters())  `这一行代码，我们定义优化器的参数时，将我们自定义的 可随网络更新的 Variable 加入了`  itertools.chain ` 参与模型的训练。\\n\\n**另一个需要注意**的点是： **spec_dataloader** 这个地方，它的返回是 **input_nodes, output_nodes和 blocks 这三个元素的tuple** 。 其中，**input_nodes 代表计算 output_nodes 的表示所需的节点,input_nodes包含了output_nodes。块 包含了每个GNN层要计算哪些节点表示作为输出，要将哪些节点表示作为输入，以及来自输入节点的表示如何传播到输出节点**。\\n\\n这就有了我们进行模型训练所需要的图上结构的全部信息了。\\n\\n* * *\\n\\n#### （2.6） 模型多种节点训练\\n\\n```\\n@ 欢迎关注微信公众号：算法全栈之路\\n\\n# 开始train 模型\\nfor epoch in range(20):\\n    print(\\\"start epoch:\\\", epoch)\\n    model.train()\\n    train_nodetype_one_epoch('user', user_loader)\\n    train_nodetype_one_epoch('user', user_loader)\\n    train_nodetype_one_epoch('user', user_loader)\\n```\\n\\n从代码中我们可以知道： 对于异构图，其实我们也是以 **各种类型的节点作为种子节点， 然后进行图上的邻居采样，分别进行训练然后更新整个模型结构** 的。\\n\\n* * *\\n\\n#### （2.7） 模型保存与节点Embeding导出\\n\\n```\\n@ 欢迎关注微信公众号：算法全栈之路\\n\\n# 图数据和模型保存\\nsave_graphs(\\\"graph.bin\\\", [hetero_graph])\\ntorch.save(model.state_dict(), \\\"model.bin\\\")\\n\\n# 每个结点的embeding,自己初始化,因为参与了训练,这个就是最后每个结点输出的embeding\\nprint(\\\"node_embed:\\\", all_node_embed['user'][0])\\n\\n# 模型预估的结果,最后应该使用 inference,这里得到的是logit\\n# 注意,这里传入 all_node_embed,选择0,选1可能会死锁,最终程序不执行\\ninference_out = model.inference(hetero_graph, batch_size, 'cpu', num_workers=0, all_node_embed)\\nprint(inference_out[\\\"user\\\"].shape)\\nprint(inference_out['user'][0])\\n```\\n\\n这里我们可以看到， 我们使用了 `model.inference` 接口进行模型的节点 Embeding导出。\\n\\n这里**需要注意**的是： 这个地方 **num_workers应该设置0** ,即为不用多线程, 不然会互锁,导致预估任务不执行。这里是 **深坑** 啊，反正经过很长时间的纠结和查找，最终发现是这个原因，希望读者可以避免遇到相似的问题 ～\\n\\n其实对于异构图，要写出对它的一些应用的理解，我也是怯生生的。但是，**凡事必先骑上虎背** 。管它呢，上吧，能写到哪一步是哪一步吧！ 欢迎关注作者并留言和我一起讨论，彼此一起学习交流 ～\\n\\n到这里，**重磅好文透彻理解, 异构图上 Node 分类理论与DGL源码实战** 的全文就写完了。上面的代码demo 在环境没问题的情况下，全部复制到一个python文件里，就可以完美运行起来。本文的 **代码是一个小型的商业可以用的工程项目**，希望可以对你有参考作用 ～\\n\\n* * *\\n\\n码字不易，觉得有收获就动动小手转载一下吧，你的支持是我写下去的最大动力 ～\\n\\n更多更全更新内容，欢迎关注作者的公众号： 算法全栈之路\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/288b40d0fa1144a5a29725f916ff7b25~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n- END -",
        "tags": [
            "机器学习",
            "深度学习",
            "人工智能"
        ]
    },
    {
        "article_id": "7193879407608463416",
        "cover_image": "https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0440559977db44628249905e42e042f9~tplv-k3u1fbpfcp-watermark.image?",
        "title": "Scrollend：超实用的全新JavaScript事件",
        "brief": "大家好，我是 CUGGZ。 在开发中，可能会遇到**当页面滚动停止之后执行某些操作的需求**。在 `scrollend` 事件之前，并没有可靠的方法来检测页面滚动是否完成。这意味着事件会延迟触发，或者",
        "user_name": "CUGGZ",
        "view_count": 1045,
        "collect_count": 7,
        "comment_count": 1,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/61130727b6e6bf9ed813434aeaed8ac3~300x300.image",
        "category": "前端",
        "content": "大家好，我是 CUGGZ。\\n\\n在开发中，可能会遇到**当页面滚动停止之后执行某些操作的需求**。在 `scrollend` 事件之前，并没有可靠的方法来检测页面滚动是否完成。这意味着事件会延迟触发，或者当用户的手指仍在屏幕上时触发。这种不可靠性导致了错误和用户体验不佳。\\n## 概述\\n以前可能会**使用定时器来检测滚动停止**：\\n```javascript\\ndocument.onscroll = event => {\\n  clearTimeout(window.scrollEndTimer)\\n  window.scrollEndTimer = setTimeout(callback, 100)\\n}\\n```\\n这个 `setTimeout()` 可以知道滚动是否停止了 100 毫秒。这使它更像是滚动**已暂停事件**，而不是滚动已结束事件。\\n\\n有了 `scrollend` 事件，浏览器就会帮我们完成滚动停止的监听：\\n```javascript\\ndocument.onscrollend = event => {…}\\n```\\n可以在 Codepen 查看示例：[https://codepen.io/web-dot-dev/pen/rNrJRKg](https://codepen.io/web-dot-dev/pen/rNrJRKg)，当滚动停止时会有提示。核心代码如下：\\n```css\\ndocument.onscrollend = event => {\\n  Toast('scroll end')\\n}\\n```\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a9cbe0ae6fd4282bce4101cef6c483e~tplv-k3u1fbpfcp-zoom-1.image)\\n## 使用\\n`scrollend` 事件会在以下情况被触发：\\n\\n- 用户的触摸已被释放；\\n- 用户的指针已释放滚动条；\\n- 用户的按键已被释放；\\n- 滚动到片段已完成；\\n- 滚动捕捉已完成；\\n- `scrollTo()`已完成；\\n- 用户已滚动视觉视口。\\n\\n`scrollend` 事件在以下情况不会触发：\\n\\n- 用户的手势没有导致任何滚动位置变化；\\n- `scrollTo()` 没有产生任何移动。\\n\\n这个事件花了很长时间才出现在 Web 平台上的一个原因就是有许多小细节需要进行规范。最复杂的就是视觉视口与文档的滚动结束细节。对于放大的网页，在此缩放状态下，可以四处滚动，但不一定是在滚动文档。不过，即使是这个视觉视口用户驱动的滚动交互也会在完成后发出 `scrollend` 事件。\\n\\n与其他滚动事件一样，可以通过多种方式注册侦听器：\\n```javascript\\naddEventListener(\\\"scrollend\\\", (event) => {\\n  // scroll ended\\n});\\n\\naScrollingElement.addEventListener(\\\"scrollend\\\", (event) => {\\n  // scroll ended\\n});\\n```\\n也可以使用事件属性：\\n```javascript\\ndocument.onscrollend = (event) => {\\n  // scroll ended\\n};\\n\\naScrollingElement.onscrollend = (event) => {\\n  // scroll ended\\n};\\n```\\n## 浏览器支持\\n目前仅 Firefox 109 版本支持 `scrollend` 事件。不久的将来，Chrome 111 版本也将支持该事件。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4760488c65b54001b410273c19ff2f70~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n如果现在想要使用这个事件，可以在开始时检查支持情况，如果不支持该事件就继续使用当前的滚动结束策略（如果有的话）：\\n```javascript\\nif ('onscrollend' in window) {\\n  document.onscrollend = callback\\n}\\nelse {\\n  document.onscroll = event => {\\n    clearTimeout(window.scrollEndTimer)\\n    window.scrollEndTimer = setTimeout(callback, 100)\\n  }\\n}\\n```\\n这样就能在可用时渐进增强 `scrollend` 事件。当然也可以使用 polyfill：[https://github.com/argyleink/scrollyfills](https://github.com/argyleink/scrollyfills)\\n\\n首先在终端中安装npm包：\\n```javascript\\nnpm i -D scrollyfills\\n```\\n然后在要的地方使用 `scrollend` 事件：\\n```javascript\\nimport {scrollend} from 'scrollyfills';\\n\\nsomeElementThatScrolls.addEventListener('scrollend', event => {\\n  console.log('scroll has ended');\\n});\\n```\\npolyfill 将渐进增强以使用浏览器内置的 scrollend 事件（如果可用）。 如果它不可用，脚本会监视指针事件并滚动以对它可能结束的事件进行最佳评估。\\n> **参考：**[https://developer.chrome.com/blog/scrollend-a-new-javascript-event/](https://developer.chrome.com/blog/scrollend-a-new-javascript-event/)\\n\\n",
        "tags": [
            "前端",
            "JavaScript",
            "CSS"
        ]
    },
    {
        "article_id": "7194717936248946744",
        "cover_image": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd5364861627478d9888cb95ec4fe9d7~tplv-k3u1fbpfcp-watermark.image?",
        "title": "我的开源之旅&新手如何参与开源社区",
        "brief": "还记得你的第一个 PR 吗，当时的心情是怎样的。本篇文章讲讲我的开源之旅，以及新手程序员如何参与进来。",
        "user_name": "李瑞丰_liruifengv",
        "view_count": 1419,
        "collect_count": 6,
        "comment_count": 7,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/e1c18c101771f94ec8ffae3b4bb50d07~300x300.image",
        "category": "前端",
        "content": "大家好，我是程序猿李瑞丰。\\n\\n这几年我也零零散散的在 GitHub 参与了一些开源项目，贡献了几个 PR（蹭了不少）。今天就讲一讲我的开源之旅，以及刚入门的程序员新手，如何快速参与进来。文末有彩蛋。\\n\\n## 我的开源之旅\\n\\n### 第一个 PR\\n\\n2019 年 7 月 10 日，我在 GitHub 上提交了我的[第一个 PR](https://github.com/geoman-io/leaflet-geoman/pull/466)，出发点是我在工作中使用这个开源项目，发现没有中文翻译，我就贡献了中文翻译。\\n\\n### vue-cli 的 PR\\n\\n2019 年 7 月 24 日，我在逛 GitHub 的时候，看到 vue-cli 的 issue 中，有一个[问题](https://github.com/vuejs/vue-cli/issues/3947)，使用 vue-cli 创建项目时，同时选择 typescript 和 eslint 的时候，lint-staged 默认配置没有包含对 ts 文件的检查。\\n\\n提出这个 issue 的同学，很贴心的指出了对应源码的位置。我看到后，就顺手去修复了，很简单，if 判断 typescript，纯属捡漏。\\n\\n[链接在此](https://github.com/vuejs/vue-cli/pull/4347)。当然后续这段代码被优化了。但这个 PR 被 merge 的时候，我内心是十分激动的，毕竟 vue 和 vue-cli 是我平时工作用的项目，也是大部分程序猿都用过并熟知的，那一刻成就感十足。\\n\\n### 零零散散\\n\\n中间零零散散的提了好多 PR，有合并的，也有未合并的。有的是修复错别字，有的是修复半角圆角标点符号等等。也有一些文档的中文翻译。\\n\\n### Deno 的第一个 PR\\n\\nDeno 是一个 JS 运行时，由 Node.js 的创始人 ry 发起并开发的。我们并不清楚 Deno 能否替代 Node.js，但在项目早期， Deno 完善并被广泛使用之前，我们可以早一点参与进来。\\n\\n要感谢我的大佬[迷渡@justjavac](https://github.com/justjavac)，他是 Deno 的中国布道者，同时参与了 Deno 的核心代码开发。\\n\\n在大佬的指导下，我完成了我在 Deno 中的第一个 [PR](https://github.com/denoland/deno/pull/11851)。\\n\\n起初是大佬发现 Deno 的 `Blob` 的 `SymbolToStringTag` 实现没有通过 [wpt](https://github.com/denoland/wpt/blob/master/WebIDL/ecmascript-binding/class-string-interface.any.js#L3-L11) 的测试，给我一个贡献的机会，让我去改。关于 SymbolToStringTag 大家可以去 MDN 自行搜索了解。\\n\\n发展: Deno 的维护者 lucaca，告诉我不光是 `Blob` 需要正确设置 `SymbolToStringTag`。其他的内置类都有同样的问题。让我在 `webidl.configurePrototype` 的方法里进行处理。\\n\\n```js\\nObjectDefineProperty(prototype.prototype, SymbolToStringTag, {\\n  value: prototype.name,\\n  enumerable: false,\\n  configurable: true,\\n  writable: false,\\n})\\n```\\n\\n这次的机会，让我对 Deno 的源码有了初始了解，对开源也更加感兴趣了。\\n\\n### 更多的参与到 Deno 中来\\n\\n后来我给 Deno 提了更多的 PR，期望能更多的参与进来。\\n\\n- [fix(napi_sym): fix readme path](https://github.com/denoland/deno/pull/16203)\\n- [fix(ext/crypto): fix importKey error when leading zeroes](https://github.com/denoland/deno/pull/16009)\\n- [fix(ext/console): fix error when logging a proxied Date](https://github.com/denoland/deno/pull/16018)\\n- [docs(encoding): remove await](https://github.com/denoland/deno_std/pull/2831)\\n\\n- [docs: removed types from jsdoc directives](https://github.com/denoland/deno_std/pull/2988)\\n\\n- [docs(encoding/front_matter): fix doc error when render page](https://github.com/denoland/deno_std/pull/2985)\\n\\n### Astro\\n\\n[Astro](https://astro.build/) 是基于 Vite 的上层框架，首创群岛架构。可以快速构建内容网站如官网博客等，SEO 友好，SSG、SSR 可选。\\n\\nAstro 在 2022 年非常火爆，我也尝了把鲜，使用 Astro 把我的[个人博客](https://github.com/liruifengv/sayhub)进行了重构。\\n\\n一个新兴起的热门开源项目，那么当然也不能错过，蹭 PR 小能手的我，同样给 Astro 提了几个 PR。\\n\\n- [withastro/astro](https://github.com/withastro/astro/pulls?q=is%3Apr+author%3Aliruifengv+is%3Aclosed)\\n\\n- [withastro/docs](https://github.com/withastro/docs/pulls?q=is%3Apr+author%3Aliruifengv+is%3Aclosed)\\n\\n## 新手如何参与\\n\\n那么问题来了，讲了这么多，新手如何参与进来呢。根据我的一点点经验，可以从以下几点着手\\n\\n### 如何寻找可以贡献的开源项目\\n\\n- 从错别字改起。每天花一点时间逛一会 GitHub，查找你感兴趣的开源项目的 README 以及官方文档，可能有错别字，可能有中英文标点符号混用，勿以 PR 小而不为。\\n\\n- 你工作中用到的开源项目。使用开源项目中，难免会遇到多多少少的 bug，如果确实是该开源项目的 bug，有能力的话就可以去查看对应源码，看能否修改，PR 不是来了么。\\n\\n- 新兴的开源项目。开源项目的早期，往往还不太完善，代码、文档都需要开源社区来一起参与贡献，例如 Deno、Astro。\\n\\n- 英文文档的多语言翻译。很多老外的开源项目，是没有中文翻译的，你可以参与进去，一方面锻炼英文，一方面能更了解该项目。\\n\\n### 操作步骤\\n\\n- fork 项目到自己的仓库。\\n\\n- 创建分支，名字随便起。不建议在主分支直接修改，主分支可以跟上游仓库保持同步。\\n\\n- git clone 到本地，修改代码。\\n\\n- 如果是简单的错别字修改，可以在 GitHub 上在线修改。\\n\\n- commit&push 到自己的远程仓库。\\n\\n- 向上游仓库 Open pull request。\\n\\n### 提交 PR 的注意事项\\n\\n- 第一步要阅读你目标项目的贡献指南。正规的开源项目，都会写有贡献指南，一般可以在 README 找到，它会指导你如何运行、打包项目，如何 PR。例如 [Deno](https://deno.land/manual@v1.30.0/references/contributing)。\\n\\n- 代码风格校验。注意开源项目使用的代码风格，提交前记得运行项目的 format 和 lint。\\n\\n- 单元测试。好的开源项目都会有单元测试，如果你改了 bug 或者新增 feature，最后增加对应的单元测试，并且运行测试通过。\\n\\n- [约定式提交](https://www.conventionalcommits.org/zh-hans/v1.0.0/)。你的 commit-message 和 PR title，需要符合约定式提交规范。PR 标题是必须的，一般项目都会使用 squash merge，多个 commit 会合并成一个。\\n\\n- PR 的描述清楚。在 PR 的描述里，说清楚你修改的东西，一般都有模板，新增了 feature，修复了 bug，记得关联对应的 issue。\\n\\n- GitHub CI。开源项目都有 GitHub CI，是利用 GitHub Action，对提交的代码进行检查，一般都会运行 format、lint、单元测试、打包等操作。注意 CI 是否通过，挂了之后要及时修复。\\n\\n- 最后，不要怕，我遇到的好多维护者都很友好，他们会指导你如何修改你的 PR，跟你讨论。\\n\\n### 工具推荐\\n\\n- [DeepL 翻译](https://www.deepl.com/translator)。\\n- [octotree 扩展](https://chrome.google.com/webstore/detail/octotree-github-code-tree/bkhaagjahfmjljalopjnoealnfndnagc?hl=zh-CN) 可以在 github 左侧生成目录树，方便阅读源码。\\n- [grammarly](https://app.grammarly.com/) 辅助英文写作。\\n\\n## 彩蛋，一个 PR 机会\\n\\n最后，有一个 PR 的机会，手慢无。\\n\\n我在翻译 Astro 的文档：「[将现有项目迁移到 Astro](https://docs.astro.build/zh-cn/guides/migrate-to-astro/)」的时候，不小心留下一个错别字。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c9dfbfd3b2e64ad38d0ccb56ee0f55ba~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n感兴趣的同学可以修改一下。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f0ad5eb195bf4d5d975e8207e80bdca1~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n修复之后，你的头像就会出现在[这里](https://docs.astro.build/zh-cn/getting-started/)。找到我的头像了吗？\\n\\n今天就到这里了，我们下回再见。\\n",
        "tags": [
            "GitHub",
            "前端",
            "Vue.js"
        ]
    },
    {
        "article_id": "7183718559053250615",
        "cover_image": "",
        "title": "图解设计模式（16种）",
        "brief": "入行几年，可能发现除了发布订阅者模式和单例模式知道些外，其他的模式只是对其名称有所耳闻，只知其名，不知其义。好像这丝毫不影响我搬砖，那么学习总结设计模式的意义在哪里？",
        "user_name": "bqb",
        "view_count": 4437,
        "collect_count": 181,
        "comment_count": 15,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/e40655a4d62c0313136fc23d36050e80~300x300.image",
        "category": "前端",
        "content": "入行几年，可能发现除了发布订阅者模式和单例模式知道些外，其他的模式只是对其名称有所耳闻，`只知其名，不知其义`。\\n\\n好像这丝毫不影响我搬砖，那么学习总结`设计模式的意义`在哪里？\\n\\n就好比，盖了个新房，十年八年的屋顶也不会漏雨。但是，万一哪一天，有块瓦破了，需要去屋顶换瓦，那么这个时候，梯子没有，瓦片没有。看着滴滴答答的雨水，是不是莫名的心酸。这个时候，就想，有梯子有瓦片该多好。\\n\\n学习设计模式，就是在晴天准备梯子和瓦片，用不到则已，万一用到了，我们就可以踩着梯子换瓦片。\\n\\n那么该`如何学习设计模式`呢？\\n\\n几年前遇到了某个问题，现在想起，可能具体代码实现是忘记了。但是解决问题的思路，大概还是能七七八八的记起来的。\\n\\n所以，我认为学习设计模式的思想更为重要，具体的实现，每个设计模式可能不止一种实现方式。比如状态模式，我们可以通过修改对象状态进行状态切换，但是，也可以利用数组天然的有序性进行具体行为的组装。\\n\\n本文一万三千字符，阅读比较耗时，可以在右侧点击目录进入具体的设计模式。下面开始正文...\\n\\n## 一、定义\\n是软件设计过程中针对特定问题简洁优雅的解决方案。\\n\\n是经过大量实际项目在很长时间中验证得到的最佳实践。\\n\\n是软件开发前辈在成功和失败中总结的智慧传承。\\n## 二、比喻\\n听到`庄周梦蝶`的成语，就能能感受到庄周和蝴蝶不分你我的优美意境。\\n\\n听到`庖丁解牛`的成语，我们会为庖丁娴熟的技能由衷的赞叹。\\n\\n听到`海市蜃楼`的成语，就知道是一个虚无缥缈的事物。\\n\\n当听到`单例模式`，就知道该模式指的是全局只创建一个实例。\\n\\n当听到`发布订阅模式`，就知道是用来解决事件发布者和事件监听者之间时间解耦关系。\\n\\n当听到`中介者模式`，就知道是用来解耦多个对象之间错综复杂的交互关系。\\n\\n`所以，成语之于成语背后的故事。就如，模式之于背后的解决方案。`\\n\\n## 三、使用时机\\n如果设计模式使用不合时宜，会出现`似是而非、张冠李戴`的情况。\\n\\n如果能深刻的理解各个设计模式的原理，那么就相当于掌握了`大用小用之辩，方可游刃有余`。\\n\\n## 四、使用原则\\n区分可变与不可变的部分，并将变化的地方进行封装。\\n\\n## 五、区分方式\\n设计模式区分不在于其实现方式，而在于其解决的问题场景。\\n\\n## 六、按照结构分类\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/95bd5c5ebe9941b7b4f072b1e001bcdd~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## 七、图示和简单案例说明\\n\\n### （一）创建型\\n#### 1、原型模式\\n我们知道`JavaScript`中几乎所有的数据都是对象，即使不是，通过包装类`Number`、`Boolean`和`String`进行转换。\\n\\n而且，对象的产生可以通过`new 构造函数`的方式产生。那么，构造函数可以通过属性`prototype`的属性，为其定义属性或者方法。\\n\\n通过`new`可以产生多个对象，每个对象都可以访问构造函数`prototype`上的属性和方法。\\n\\n这种模式就可以称为`原型模式`，因为是通过构造函数创建实例对象，`原型模式`属于创建型模式。\\n\\n可以参照如下流程图：\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7885a99adb2f419c9c176f2b210dd473~tplv-k3u1fbpfcp-watermark.image?)\\n\\n举个简单的例子：\\n```\\nvar Person = function (name, hobby) {\\n    this.name = name;\\n    this.hobby = hobby;\\n}\\nPerson.prototype.basicInfo = {\\n    'address': '北京市 海淀区',\\n    'school': '某某大学',\\n    'major': '计算机',\\n}\\n\\nPerson.prototype.sayHi = function () {\\n    console.log('大家好，我是' + this.name, '我的爱好是' + this.hobby);\\n}\\n\\nvar perosn1 = new Person('张三', '踢足球')\\nperosn1.sayHi();\\nconsole.log(perosn1.basicInfo);\\n\\nvar person2 = new Person('李四', '玩游戏')\\nperson2.sayHi();\\nconsole.log(perosn1.basicInfo);\\n\\nvar person3 = new Person('王五', '下象棋')\\nperson3.sayHi();\\nconsole.log(perosn1.basicInfo);\\n\\nvar person4 = new Person('赵六', '看电影')\\nperson4.sayHi();\\nconsole.log(perosn1.basicInfo);\\n```\\n当前例子中，构造函数是`Person`，原型上定义了公共的基本信息`basicInfo`和方法`sayHi`。通过`new`的方式，创建了`person1`、`person2`、`person3`和`person4`。每个对象都可以执行方法`sayHi`，也可以打印公共属性`basicInfo`。\\n\\n#### 2、单例模式\\n\\n一个环境中有且只有一个实例，并且当前环境可以访问到它。\\n\\n往小了说，当前环境可以是一个函数作用域、块级作用域。往大了说可以是全局`window`或者`global`环境。\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/489d186ed5fa43828eecdbf56c47a584~tplv-k3u1fbpfcp-watermark.image?)\\n\\n举个简单的例子：\\n```\\n// 定义可以表示单例模式函数\\nvar SingleInstanceMode = function (fn) {\\n    var instance;\\n    return function () {\\n        return instance || (instance = fn.call(this, arguments))\\n    }\\n}\\n// 定义产生实例的目标函数\\nvar targetFn = function () {\\n    return {\\n        info: '这是唯一一个实例'\\n    }\\n}\\n// 将目标函数传入单例模式中\\nvar createSingleInstance = SingleInstanceMode(targetFn)\\n\\n// 创建实例1\\nvar instance1 = createSingleInstance();\\n// 创建实例2\\nvar instance2 = createSingleInstance();\\n// 判断两实例是否相等\\nconsole.log(instance1 === instance2) // true: 表示全局只有唯一一个实例\\n```\\n当前例子中首先定义可表示单例模式的函数，函数中通过闭包的方式锁定变量`instance`，在执行创建单例的函数时，如果环境中已经存在一个实例则直接返回，否则才去进行实例的创建。这就是单例模式的一种实现方式。\\n\\n#### 3、工厂模式\\n工厂模式指的是，批量创建对象的时候可以避免使用`new` + `构造函数`的方式去暴露创建对象的行为，而是通过工厂模式将创建对象的行为隐藏到工厂函数内部，不仅可以批量的生产对象，而且还可以通过传入参数改变产出产品的形态。\\n\\n画个工厂简单的流程图如下：\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/447e21345c2749c68dc764e249606648~tplv-k3u1fbpfcp-watermark.image?)\\n\\n这里我们不需要关注车间一、二、三和四具体是咋操作的，只需要关系工厂入口我们输入的参数，和工厂出口产出的产品，举个例子如下：\\n```\\n// 定义可以生产服装的工厂\\nvar factory = function (type, height) {\\n    // 定义衬衫、短裤和皮夹克的车间\\n    var workshop = {\\n        1: function (height) {\\n            var obj = new Object()\\n            obj.name = '衬衫'\\n            obj.height = height;\\n            return obj;\\n        },\\n        2: function (height) {\\n            var obj = new Object()\\n            obj.name = '短裤'\\n            obj.height = height;\\n            return obj;\\n        },\\n        3: function (height) {\\n            var obj = new Object()\\n            obj.name = '皮夹克'\\n            obj.height = height;\\n            return obj;\\n        },\\n        4: function (height) {\\n            var obj = new Object()\\n            obj.name = '西装'\\n            obj.height = height;\\n            return obj;\\n        },\\n    }\\n    // 不同的车间进行不同的服装生成\\n    return workshop[type](height)\\n}\\n// 每个车间先生成一件衣服试试机器\\nvar shirt1 = factory(1, '175cm')\\nvar shorts1 = factory(2, '178cm')\\nvar jacket1 = factory(3, '180cm')\\nvar suit1 = factory(4, '185cm')\\n\\n// 机器试着没问题，再批量生成一批衬衫\\nvar shirt1 = factory(1, '172cm')\\nvar shirt2 = factory(1, '173cm')\\nvar shirt3 = factory(1, '174cm')\\nvar shirt4 = factory(1, '175cm')\\nvar shirt5 = factory(1, '176cm')\\nvar shirt6 = factory(1, '177cm')\\nvar shirt7 = factory(1, '178cm')\\nvar shirt8 = factory(1, '179cm')\\n```\\n当前例子中，我们不必知道工厂内部各个车间的具体情况，只需要知道服装编号`1`代表`衬衫`、`2`代表`短裤`、`3`代表`皮夹克`、`4`代表`西装`，然后再告诉工厂穿衣者的身高，即可批量生成出一批衬衫。\\n\\n当然我们也可以根据实际需求对工厂内部进行改造，改造成为我们需要的工厂。\\n\\n### （二）结构型\\n#### 4、装饰者模式\\n\\n先举个例子作为引子，假如小帅刚造了一个手机。\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/82e79bcc67aa4e25a3457b48a3cbf7f3~tplv-k3u1fbpfcp-watermark.image?)\\n\\n小帅看着不够帅，于是加了个带有“帅”字的吊坠。\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4bf4a5a4944b48278e8f6054f5850abe~tplv-k3u1fbpfcp-watermark.image?)\\n\\n其实这个吊坠有没有，手机的功能丝毫不受影响。有了吊坠，小帅觉得会手机看起来更“帅”一点点，手机还是那个手机，人机交互窗口还是窗口触摸屏，并没有变成古老的按键方式。（人机交互的屏幕即是人和手机交互的接口）\\n\\n> 装饰者模式以其不改变原对象，并且与原对象有着相同接口的特点，广泛应用于日常开发和主流框架的功能中。\\n\\n假如我们开发了一个移动端网页，有图书搜索、小游戏、音频播放和视频播放等主要功能，初期，我们并不知道这几个功能用户的使用规律。\\n\\n有一天，产品经理说，我想要各个功能用户的使用规律，并且通过echarts绘制折线图和柱状图，能加吗？\\n\\n这就加......\\n\\n起初:\\n\\n```\\n<button id=\\\"smallGameBtn\\\">小游戏</button>\\n<script>\\n    var enterSmallGame = function () {\\n        console.log('进入小游戏')\\n    }\\n    document.getElementById('smallGameBtn').onclick = enterSmallGame;\\n</script>\\n```\\n通过装饰者模式增加数据埋点之后:\\n```\\n<button id=\\\"smallGameBtn\\\">小游戏</button>\\n<script>\\n     Function.prototype.after= function (afterFn) {\\n        var selfFn = this;\\n        return function () {\\n            var ret = selfFn.apply(this, arguments)\\n            afterFn.apply(this.arguments)\\n            return ret\\n        }\\n    }\\n    var enterSmallGame = function () {\\n        console.log('进入小游戏')\\n    }\\n\\n    var dataLog = function () {\\n        console.log('数据埋点')\\n    }\\n\\n    enterSmallGame = enterSmallGame.after(dataLog)\\n\\n    document.getElementById('smallGameBtn').onclick = enterSmallGame;\\n</script>\\n```\\n\\n定义`Function.prototype.after`函数，其中通过闭包的方式缓存`selfFn`，然后返回一个函数，该函数首先执行`selfFn`，再执行`afterFn`，这里也很清晰的可以看出两个函数的执行顺序。\\n\\n在当前例子中，首先执行进入小游戏的功能，然后，再执行数据埋点的功能。\\n\\n可以看出，加了数据埋点，执行函数是`enterSmallGame`，不加也是。同时，也未对原始函数`enterSmallGame`内部进行修改。\\n\\n#### 5、代理模式\\n先举个例子作为引子，我们的本体是计算器，每天会进行大量的计算。\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/529f6c10059e4caaaa159213a0d7b1da~tplv-k3u1fbpfcp-watermark.image?)\\n\\n我们发现也会有不少重复的计算，我们引入一个代理。\\n\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/956b416fe36041cbb23e511853e4c9c9~tplv-k3u1fbpfcp-watermark.image?)\\n\\n图示中，访问代理进行数据的计算，如果是重复的计算，缓存代理直接返回结果。如果是首次计算，缓存代理将其传递给本体进行计算。\\n\\n> 当本体处于保护、缓存、虚拟或者过滤等情况下时，一个数据不适合被访问或者一个方法不能被直接调用，可以采用代理模式，先创建一个代理（本体对象或者方法的替身），作为访问者和本体之间的中介或者桥梁。\\n\\n再通过代码对比只是用本体进行计算，和使用代理方式进行计算的异同。\\n\\n```\\n// 本体计算乘积\\nvar mult = function(){\\n    var a = 1; \\n    for ( var i = 0, l = arguments.length; i < l; i++ ){ \\n        a = a * arguments[i]; \\n    } \\n    return a; \\n}; \\n// 代理计算乘积\\nvar proxyMult = (function(){ \\n    var cache = {}; \\n    return function(){ \\n        var args = Array.prototype.join.call( arguments, ',' ); \\n        if ( args in cache ){ \\n            return cache[ args ]; \\n        } \\n        return cache[ args ] = mult.apply( this, arguments ); \\n    } \\n})(); \\n```\\n以上是本体和代理，都可以通过传递参数计算乘积，有以下两种访问方式：\\n- 本体计算乘积\\n```\\nconsole.log(mult( 1, 2, 3, 4 )); // 24\\n```\\n计算会得出24的乘积，如果再次计算会再次进行计算，如果数据量比较大的话，会重复计算；\\n- 代理计算乘积\\n```\\nconsole.log(proxyMult( 1, 2, 3, 4 )); // 24\\n```\\n第一次计算会计算出24的乘积，并将其存到cache中，如cache[\\\"1,2,3,4\\\"] = 24,第二次计算的时候，发现cache中有键为\\\"1,2,3,4\\\"的乘积，无需重复计算，直接返回。\\n\\n#### 6、适配器模式\\n先举个两实体不匹配例子：\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f87c6b19509467b9019bbb390adde3b~tplv-k3u1fbpfcp-watermark.image?)\\n\\n假如这两块要契合在一起，怎么办？\\n\\n咱们先给A实体造个适配器，如下：\\n\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/671c81ac22d94e1aae0b2552eeb04fa6~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n再把A实体往右推一下：\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a87e12fff52c4b5787878bd42fadee5f~tplv-k3u1fbpfcp-watermark.image?)\\n\\n通过适配器，咱们就把A实体和B实体结合到了一起了。\\n\\n> 适配器模式是用来解决两个软件实体之间不兼容的问题的设计模式。可以在不改变实体内部结构的情况下，在其中一个实体外层包装一个适配器，再去将两个实体进行配合使用。\\n\\n再看适配器在代码中的例子：有个实体A，需要将实体A传入实体B中，实体B返回其`name`对应的数据，包含名称、地址和年龄。\\n\\n\\n```\\n// 实体A\\nvar instanceA = [{\\n        name: '张三',\\n        address: '北京',\\n        age: 20,\\n    },\\n    {\\n        name: '李四',\\n        address: '天津',\\n        age: 25,\\n    },\\n    {\\n        name: '王五',\\n        address: '河北',\\n        age: 30,\\n    }\\n]\\n// 实体B\\nvar instanceB = function (data, name) {\\n    return data[name]\\n}\\n// 实体A在实体B中进行调用\\nconsole.log(instanceB(instanceA, '张三')) // undefined\\n```\\n\\n这里先定义实体A作为数据，定义实体B作为调用函数，将实体A放入实体B中，我们执行可以发现返回的是`undefined`。\\n\\n此时，我们定义一个适配器。\\n\\n```\\nvar dataAdapter = function (arr) {\\n    return arr.reduce((accumulator, currentValue) => {\\n        accumulator[currentValue['name']] = currentValue\\n        return accumulator\\n    }, {})\\n}\\n```\\n通过适配器，将数组对象转换成`name`作为`key`，`{name:xxx, address:xxx, age:xxx}`作为`value`的对象。\\n\\n然后，将实体A进行适配器的处理，再塞入到实体B中。\\n```\\nconsole.log(instanceB(dataAdapter(instanceA), '张三')) // {\\\"name\\\": \\\"张三\\\", \\\"address\\\": \\\"北京\\\", \\\"age\\\": 20}\\n```\\n这样，通过适配器`dataAdapter`，就可以将实体A在实体B进行使用，实现了两个不同实体之间不兼容的问题。\\n#### 7、组合模式\\n搬了一天砖后，拖着疲惫的身体回家，打开家门...\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4e83c9c32e144deebd9037e981fdce19~tplv-k3u1fbpfcp-watermark.image?)\\n\\n从图中可以看出，开烤箱后的组合行为是烤面包和烤肠。\\n\\n进厨房后的组合行为，是开烤箱后的组合行为、煮鸡蛋和煮咖啡共同组成。\\n\\n回家后的行为，是由关门、开灯、进厨房的组合行为和打开电视共同组成。\\n\\n这样，就可以组成一颗行为树，但是，可以发现，蓝色区域是多个行为的组合，而非行为的自身执行，真正的执行由具体的行为动作完成。\\n\\n我们先定义一个可以返回组合行为对象添加和执行的函数：\\n```\\nvar JointCommand = function () {\\n    return {\\n        commandList: [],\\n        add: function (command) {\\n            this.commandList.push(command)\\n        },\\n        execute: function () {\\n            for (let i = 0, command; command = this.commandList[i++];) {\\n                command.execute();\\n            }\\n        }\\n    }\\n}\\n```\\n`JointCommand`执行后返回的对象表示组合对象，`commandList`表示命令或者行为的组合，`add`用来为组合命令添加命令，`execute`表示组合对象的执行，本质上是调用组合命令列表中的`command.execute()`。\\n\\n其中，`command`也可能是组合对象，执行组合对象的时候，该列表层后续的`command`暂时不执行。会以深度遍历的方式，先执行组合对象的列表命令。依次类推，最终的叶子对象执行完后将执行权交给父级，层层向上，最终会完成整棵树的命令执行。\\n\\n下面我们先从整棵树的叶子对象开始进行分析。\\n\\n**（1）开烤箱后的行为**\\n\\n```\\n// 烤面包和烤肠\\nvar cookieToattCommand = {\\n    execute: function () {\\n        console.log('烤面包')\\n    }\\n}\\nvar roastSausageCommand = {\\n    execute: function () {\\n        console.log('烤香肠')\\n    }\\n}\\n// 开烤箱后的组合行为\\nafterOpenOvenCommand = JointCommand();\\nafterOpenOvenCommand.add(cookieToattCommand);\\nafterOpenOvenCommand.add(roastSausageCommand);\\n```\\n定义烤面包和烤肠的单个对象，包含`execute`方法。\\n\\n再执行`JointCommand`返回打开烤箱组合对象。\\n\\n最后通过`afterOpenOvenCommand.add(cookieToattCommand)`和`afterOpenOvenCommand.add(roastSausageCommand)`的方式为打开烤箱后的组合对象添加烤面包和烤香肠命令。\\n\\n**（2）进入厨房后的行为**\\n```\\nvar boiledEggCommand = {\\n    execute: function () {\\n        console.log('煮鸡蛋')\\n    }\\n}\\nvar makeCoffeeCommand = {\\n    execute: function () {\\n        console.log('煮咖啡')\\n    }\\n}\\n// 进入厨房后的组合行为\\nafterEnterKitchenCommand = JointCommand();\\n\\nafterEnterKitchenCommand.add(afterOpenOvenCommand);\\nafterEnterKitchenCommand.add(boiledEggCommand);\\nafterEnterKitchenCommand.add(makeCoffeeCommand);\\n```\\n定义煮鸡蛋和煮咖啡的单个对象，包含`execute`方法。\\n\\n再执行`JointCommand`返回进入厨房组合对象。\\n\\n和打开烤箱不同的地方在于，通过`afterEnterKitchenCommand.add(afterOpenOvenCommand)`的方式为`commandList`添加的是打开烤箱后的组合对象。\\n\\n最后通过`afterEnterKitchenCommand.add(boiledEggCommand)`和`afterEnterKitchenCommand.add(makeCoffeeCommand)`的方式为进入厨房后的组合对象添加煮鸡蛋和煮咖啡命令。\\n\\n**（3）回家后的行为**\\n```\\nvar closeDoorCommand = {\\n    execute: function () {\\n        console.log('关门')\\n    }\\n}\\nvar turnOnLightCommand = {\\n    execute: function () {\\n        console.log('开灯')\\n    }\\n}\\nvar turnOnTvCommand = {\\n    execute: function () {\\n        console.log('打开电视')\\n    }\\n}\\n// 回家后的组合行为\\nafterGoHomeCommand = JointCommand();\\nafterGoHomeCommand.add(closeDoorCommand);\\nafterGoHomeCommand.add(turnOnLightCommand);\\nafterGoHomeCommand.add(afterEnterKitchenCommand);\\nafterGoHomeCommand.add(turnOnTvCommand);\\n```\\n\\n定义关门、开灯和打开电视的单个对象，包含`execute`方法。\\n\\n再执行`JointCommand`返回回家后的组合对象。\\n\\n最后通过`afterGoHomeCommand.add(closeDoorCommand)`、`afterGoHomeCommand.add(turnOnLightCommand)`、`afterGoHomeCommand.add(afterEnterKitchenCommand)`和`afterEnterKitchenCommand.add(turnOnTvCommand)`的方式为回家后的组合对象添加`关门`、`开灯`、`进入厨房组合对象`和`打开电视`。\\n\\n这里需要注意，进入厨房后的组合对象已经是一棵树了，是回家后组合对象的子树。\\n\\n当执行`afterGoHomeCommand.execute()`后的执行结果是：\\n\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f9c9a80137c4003afae38f90c1a048e~tplv-k3u1fbpfcp-watermark.image?)\\n\\n深度遍历流程图如下：\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/505c248cc8a148f681bb44f07c53dcc2~tplv-k3u1fbpfcp-watermark.image?)\\n\\n**小结**\\n\\n组合模式，在执行根组合对象、节点组合对象和叶子对象时都是`execute`，也就说不管从哪里开始，都可以执行`execute`，这让组合模式的使用变得简单。访问者几乎没有上手成本。简单得像摁个按钮，只需要知道开灯、开电视、开烤箱、咖啡机等设备的开关一样。\\n\\n可以通过`afterEnterKitchenCommand.execute()`进行进入厨房后的组合行为执行。\\n\\n可以通过`afterOpenOvenCommand.execute()`进行打开烤箱后的组合行为执行。\\n\\n也可以通过`turnOnLightCommand.execute()`和`turnOnTvCommand.execute()`进行叶子对象的执行，分别执行了开灯和打开电视的命令。\\n\\n最后抽象组合模式的树形结构：\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc90b8cd602e474d87257f2475ecbc70~tplv-k3u1fbpfcp-watermark.image?)\\n\\n> 组合模式表示的是局部和整体的关系，局部和整体的关系往往是通过树来描述的。树我们知道由根、枝干和叶子构成，同样，抽象的树也是由根节点，节点和叶子节点构成。\\n\\n#### 8、享元模式\\n> 享元模式是一种用于性能优化的模式，其主要方式是通过运用共享技术来实现复杂对象总量的减少。将结构整体合理划分内部状态和外部状态，内部状态是那种不变化的，稳定的，也可以称之为`享元`，外部状态是那种变化的，不定的。\\n\\n先举个例子：餐馆，如果使用一次性筷子，就餐次数增加一次，就需要多一双筷子。\\n\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c75670528b934228a667d82e1a74a9e5~tplv-k3u1fbpfcp-watermark.image?)\\n\\n那么，假如每天`500`个就餐次数，一年就是`500 × 365 = 182500`。\\n\\n用代码实现一次性筷子的创建和销毁情况：\\n```\\n// 筷子序列号\\nvar serialNumber = 1;\\n// 筷子构造函数\\nvar Chopsticks = function (serialNumber) {\\n    this.serialNumber = serialNumber;\\n}\\n// 筷子管理\\nvar chopsticksManager = (function () {\\n    var outerData = []\\n    return {\\n        add: function (count) {\\n            for (var i = 0; i < count; i++) {\\n                outerData.push(new Chopsticks(serialNumber++))\\n            }\\n            return outerData;\\n        },\\n        destroy: function () {\\n            while (outerData.length) {\\n                outerData.pop();\\n            }\\n        },\\n    }\\n})()\\n// 一次性筷子的创建\\nvar chopsticksArr = chopsticksManager.add(182500)\\n// 一次性筷子的销毁\\nchopsticksManager.destroy()\\n```\\n在当前例子中，我们定义了筷子构造函数，然后通过`chopsticksManager`进行筷子的管理。我们不考虑筷子分批次创建和分批次销毁的情况，我们汇总成一次进行处理。通过`chopsticksArr = chopsticksManager.add(182500)`的方式去创建`182500`双筷子，使用后，再通过`chopsticksManager.destroy()`的方式去销毁筷子，这个过程中我们进行了`182500`次筷子的创建。\\n\\n为了减少一次性筷子，使用公筷，我们定义`1000`双公筷。\\n\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b59d2fef89a46b287ba0ecefab3d8c2~tplv-k3u1fbpfcp-watermark.image?)\\n\\n用代码实现使用公筷后，使用公筷和公筷回收的情况：\\n```\\n// 筷子序列号\\nvar serialNumber = 1;\\n// 筷子构造函数\\nvar Chopsticks = function (serialNumber, type) {\\n    this.serialNumber = serialNumber; // 公筷序列号\\n    this.type = type; // 这双公筷的使用状态\\n}\\n// 筷子管理\\nvar chopsticksManager = (function () {\\n    var innerData = [] // 提升为内部状态的享元池\\n    var recycleData = [] // 公筷回收池\\n    return {\\n        // 创建公筷\\n        add: function (count) {\\n            for (var i = 0; i < count; i++) {\\n                innerData.push(new Chopsticks(serialNumber++))\\n            }\\n            return innerData;\\n        },\\n        // 使用公筷\\n        use: function (count) {\\n            for (let i = 0; i < count; i++) {\\n                var item = innerData.pop()\\n                item.type = 'hasUsed' // 标注为已经被使用\\n                recycleData.push(item);\\n            }\\n        },\\n        // 回收公筷\\n        recycle: function () {\\n            let recycleDataLength = recycleData.length\\n            for (let i = 0; i < recycleDataLength; i++) {\\n                var item = recycleData.pop()\\n                item.type = 'hasRecycled'; // 标注为已经被回收\\n                innerData.push(item);\\n            }\\n        },\\n    }\\n})()\\n// 公筷创建，公筷创建是日常客流的二倍，以防客流突然增多\\nvar chopsticksArr = chopsticksManager.add(1000);\\n\\n// 有一天客流325\\nchopsticksManager.use(325); // 筷子的使用\\nchopsticksManager.recycle(); // 筷子的回收\\n\\n// 有一天客流732\\nchopsticksManager.use(732); // 筷子的使用\\nchopsticksManager.recycle(); // 筷子的回收\\n\\n// 有一天客流210\\nchopsticksManager.use(210); // 筷子的使用\\nchopsticksManager.recycle(); // 筷子的回收\\n\\n// 日复一日，年复一年，筷子的使用就从公筷池中使用，洗净消毒回收\\n```\\n\\n在当前例子中，我们定义了筷子构造函数，然后通过`chopsticksManager`进行筷子的管理。通过`chopsticksArr = chopsticksManager.add(1000)`的方式去创建`1000`双公筷，通过`chopsticksManager.use(325)`的方式去使用，使用后再通过`chopsticksManager.recycle()`的方式去洗净消毒回收。\\n\\n那么，在整个升级改造过程中，我们节省了超`十八万双`一次性筷子。\\n\\n一次性筷子是没有享元的情况，使用公筷后，`1000`双公筷相当于`1000`个享元，在公筷池中，我们可以进行公筷的取出，和公筷清洗和消毒后的放回。就相当于，我们在享元池中进行享元的取出和放回。\\n\\n### （三）行为型\\n#### 9、策略模式\\n> 策略模式指的是，定义一系列的算法，把它们一个个的封装起来，通过传递一些参数，使他们可以相互替换。\\n\\n举个周末从家去咖啡馆的例子：\\n\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30a02efd7581438bbbb6c1410207475a~tplv-k3u1fbpfcp-watermark.image?)\\n\\n从家去咖啡馆，有跑步、骑行和漫步的方式。也就是说，从家到咖啡馆，有三种策略可选择。\\n\\n##### （1）策略模式的极简实现**\\n\\n通过对象的键值映射关系，定义策略和具体实现之间的关系：\\n```\\nvar strategies = {\\n    A: xxx,\\n    B: yyy,\\n    C: zzz\\n}\\n```\\n其中，`A`、`B`和`C`指的策略名称，`xxx`、`yyy`和`zzz`指的是具体函数（算法）。\\n\\n##### （2）策略模式的简单案例**\\n\\n**① 工具函数**\\n\\n当项目搭建的过程中，可以通过策略模式，封装常用的优化函数防抖和节流。\\n```\\nconst tools = {\\n    throttle: function (fn, time) {\\n        // ...\\n    },\\n    debounce: function (fn,time) {\\n        // ...\\n    },\\n}\\n```\\n**② 提示样式**\\n`vue`框架下页面中的弱提示`toast`样式，也可以根据类型进行样式的预置，比如，先在`style`中定义预置的样式\\n```\\n<style scoped>\\n     /*@style：defaultActive默认状态下的样式*/\\n    .defaultActive {\\n        background-color: rgba(0, 0, 0, 0.8);\\n        color: #fff;\\n    }\\n    /*@style：successActive成功状态下的样式*/\\n    .successActive {\\n        background-color: #f0f9eb;\\n        color: #67c23a;\\n    }\\n    /*@style：infoActive信息状态下的样式*/\\n    .infoActive {\\n        background-color: #f4f4f5;\\n        color: #909399;\\n    }\\n    /*@style：warningActive警告状态下的样式*/\\n    .warningActive {\\n        background-color: #fdf6ec;\\n        color: #e6a23c;\\n    }\\n    /*@style：errorActive错误状态下的样式*/\\n    .errorActive {\\n        background-color: #fef0f0;\\n        color: #f56c6c;\\n    }\\n</style>\\n```\\n利用`vue`的计算属性，将传入的类型和字符串'Active'拼接组成策略，如'defaultActive'、'successActive'、'infoActive'、'warningActive'和'errorActive'\\n```\\n<script>\\n    export default {\\n        computed: {\\n            className () {\\n                return this.type + 'Active'\\n            }\\n        }\\n    };\\n</script>\\n```\\n在`template`视图端进行\\\"策略\\\"和样式的关联\\n```\\n<template>\\n    <div class=\\\"toast\\\" :class=className>\\n        {{msg}}\\n    </div>\\n</template>\\n```\\n##### 小结\\n\\n策略模式，可以利用对象的键值映射关系以及函数是一等公民的特性，以`key`来作为策略名称，以函数作为值定义具体算法，利用这些`javascript`特性可以更为简单的实现策略模式。\\n\\n#### 10、迭代器模式\\n> 迭代器模式，指的是提供一种方法顺序访问一个聚合对象或者数组中的各种元素，而又不暴露该对象的内部表示。\\n\\n##### （1）内部迭代器\\n内部迭代器是自动的，将回调函数传入迭代器进行执行，访问到每一个元素都会执行传入迭代器中的回调函数。\\n\\n模拟内部迭代器如下：\\n```\\n// 定义数组原型上的mapFn内部迭代器\\nArray.prototype.mapFn = function (callback) {\\n    let arr = this;\\n    let newArr = []\\n    for (let i = 0; i < arr.length; i++) {\\n        newArr[i] = callback(arr[i], i, arr)\\n    }\\n    return newArr\\n}\\n// 定义原始数组\\nvar arr = [1, 2, 3, 4, 5];\\n// 定义回调函数\\nvar callback = val => val * 2;\\n// 执行数组的mapFn方法调用回调函数callback\\nvar newArr = arr.mapFn(callback);\\n// 打印返回值\\nconsole.log(newArr)\\n```\\n`callback`函数可以传入三个参数，第一个参数表示当前的值，第二个参数表示当前索引，第三个参数表示正在操作的数组。返回值为新数组。\\n\\n当前例子中，`callback`指的是`val => val * 2`,通过数组的`mapFn`方法执行`callback`函数，返回值为新的数组`newArr`。\\n\\n在实际的使用中，`Array.prototype.mapFn`的内部实现是看不到的，就像我们看不到数组的操作`map`和`forEach`一样，这里如果将`Array.prototype.mapFn`作为黑盒子。就有如下的流程：\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e08b6652286e493dbcde11c8c3bbfada~tplv-k3u1fbpfcp-watermark.image?)\\n\\n##### （2）外部迭代器\\n外部迭代器是非自动的，提供了`next`方法，需要手动的去执行`next()`以进行下一个元素的访问。\\n```\\n// 定义迭代器生成函数\\nfunction makeIterator(array) {\\n    var nextIndex = 0;\\n    return {\\n        next: function () {\\n            return nextIndex < array.length ? {\\n                value: array[nextIndex++],\\n                done: false\\n            } : {\\n                value: undefined,\\n                done: true\\n            };\\n        }\\n    };\\n}\\n// 产生迭代器\\nvar it = makeIterator(['a', 'b']);\\n\\n// 通过迭代器暴露出来的next方法，外部调用迭代器\\nconsole.log(it.next()) // { \\\"value\\\": \\\"a\\\", \\\"done\\\": false }\\nconsole.log(it.next()) // { \\\"value\\\": \\\"b\\\", \\\"done\\\": false }\\nconsole.log(it.next()) // { \\\"value\\\": undefined, \\\"done\\\": true }\\n```\\n`makeIterator`返回`next`方法，每一次执行都会执行下一个迭代。`done`是否迭代结束，`value`是当前迭代获取到的值。如果`done`为`true`，对应的`value`就是`undefined`。\\n\\n在实际的使用中，`makeIterator`的内部实现是看不到的，这里如果将`makeIterator`作为黑盒子。就有如下的流程：\\n\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ced9cb859ff464291f8e5667ea23d0f~tplv-k3u1fbpfcp-watermark.image?)\\n\\n##### 小结\\n目前`JavaScript`已经内置了多种内部迭代器，比如`forEach`、`map`、`filter`和`reduce`等，内部执行回调函数`function(value, index, currentArr){ xxxx }`对每个访问到的元素进行处理。通过`generate`和`yield`配合使用也可以产生外部迭代器，通过`next()`方法进行下一步的执行。\\n#### 11、发布订阅者模式\\n发布订阅者模式，我们从一条古老的街道说起\\n##### （1）有一条古老的街道\\n有一条古老的街道，有一天，开了一个报社，是关于财经的。（定义一个发布者类`Publish`）\\n\\n我们叫它“财经报社”。（实例化时定义报社名称`publisherName`）\\n\\n它有一张订阅者登记表。（实例化时定义一个包含订阅者名称的登记表`watcherLists`）\\n\\n用户登记表可以记录订阅者的名字。（添加订阅者名的方法`addWatcher`）\\n\\n送报员把报纸送到每一个订阅者手里。（通知订阅者的方法`notify`）\\n\\n订阅者不订阅时，报社可以移出订阅者的名字。（移出订阅者的方法`removeWatcher`）\\n\\n报社万一哪天关门时，会清空订阅者列表。（清空订阅者的方法`清空发布者列表`）\\n\\n上面的每一句话，都代表了一个伪代码，下面具体实现一个发布者类：\\n\\n```\\nclass Publish {\\n    constructor(publisherName) {\\n         // 发布者名称\\n        this.publisherName = publisherName;\\n         // 订阅者列表\\n        this.watcherLists = []\\n    }\\n    // 添加订阅者\\n    addWatcher(watcher) {\\n        this.watcherLists.push(watcher)\\n    }\\n    // 通知订阅者\\n    notify() {\\n        const watcherLists = this.watcherLists.slice()\\n        for (let i = 0, l = watcherLists.length; i < l; i++) {\\n            watcherLists[i].update()\\n        }\\n    }\\n    // 移除订阅者\\n    removeWatcher(watcherName) {\\n        if (!this.watcherLists.includes(watcherName)) {\\n            return;\\n        }\\n        for (let i = 0; i < this.watcherLists.length; i++) {\\n            if (this.watcherLists[i].watcherName === watcherName) {\\n                this.watcherLists[i].removePublishers(this.publisherName)\\n                this.watcherLists.splice(i, 1)\\n            }\\n        }\\n    }\\n    // 清空订阅者列表\\n    clearWatchers() {\\n        const watcherLists = this.watcherLists.slice()\\n        for (let i = 0, l = watcherLists.length; i < l; i++) {\\n            watcherLists[i].removePublishers(this.publisherName)\\n        }\\n\\n        this.watcherLists = []\\n    }\\n}\\n```\\n\\n财经报馆开业，我们`new`个报馆实例。\\n```\\nconst financialNewspaper = new Publish('财经报社')\\n```\\n##### （2）来了两个财经爱好者\\n有一天来了两个财经爱好者。（定义一个订阅者类`Watcher`）\\n\\n订阅者是有名称的。（实例化时定义报社名称`watcherName`）\\n\\n订阅者订阅的可能不止一家报社。（实例化时定义一个包含报社（发布者）的笔记本`publishers`）\\n\\n订阅者收到报纸后的行为。（实例时定义定义订阅者的行为（事件）`fn`）\\n\\n订阅者是通过什么样的方式接收报纸的。（定义接收报纸（发布者发布的消息）的途径，这里统一为信箱方式`update`）\\n\\n订阅者可以订阅其他报社的报纸。（添加发布者的方式`addPublisher`）\\n\\n订阅者也可以取消某家报社的报纸。（移除发布者的方式`removePublishers`）\\n\\n订阅者离开这条街道时，清空报社名称的笔记本。（清空发布者列表`clearPublishers`）\\n\\n上面的每一句话，都代表了一个伪代码，下面具体实现一个订阅者类：\\n```\\nclass Watcher {\\n    constructor(watcherName, fn) {\\n        this.watcherName = watcherName; // 订阅者名称\\n        this.publishers = [] // 发布者列表\\n        this.fn = fn // 监听者收到消息后的反应（事件）\\n    }\\n    // 更新自身事件(行为)\\n    update() {\\n        this.fn();\\n    }\\n    // 添加发布者\\n    addPublisher(publisher) {\\n        this.publishers.push(publisher)\\n    }\\n    // 移除发布者\\n    removePublishers(publisherName) {\\n        if (!this.publishers.includes(publisherName)) {\\n            return;\\n        }\\n        for (let i = 0; i < this.publishers.length; i++) {\\n            if (this.publishers[i].publisherName === publisherName) {\\n                this.publishers[i].removeWatcher(this.watcherName) // 通知发布者删除订阅者\\n                this.publishers.splice(index, 1) // 从发布者列表中清除发布者\\n            }\\n        }\\n    }\\n    // 清空发布者列表\\n    clearPublishers() {\\n        const publishers = this.publishers.slice()\\n        for (let i = 0, l = publishers.length; i < l; i++) {\\n            publishers[i].removeWatcher(this.watcherName)\\n        }\\n\\n        this.publishers = []\\n    }\\n}\\n```\\n关于订阅者，我们`new`两个订阅者实例。\\n```\\nconst watcherA = new Watcher('watcherA', function () {\\n    console.log('喝着茶，看着报纸')\\n})\\n// 定义订阅者B\\nconst watcherB = new Watcher('watcherB', function () {\\n    console.log('大清早，晨读报纸')\\n})\\n```\\n\\n财经报刊添加了两个订阅者`watcherA`和`watcherB`。\\n```\\nfinancialNewspaper.addWatcher(watcherA)\\nfinancialNewspaper.addWatcher(watcherB)\\n// 可以打印发布者和发布者收集的订阅者列表\\nconsole.log(financialNewspaper, financialNewspaper.watcherLists);\\n```\\n\\n\\n两个细心的订阅者把财经报刊记录在了小本本上。\\n```\\nwatcherA.addPublisher(financialNewspaper);\\nwatcherB.addPublisher(financialNewspaper);\\n// 可以打印订阅者和订阅者订阅的报刊种类\\nconsole.log(watcherA, watcherA.publishers);\\nconsole.log(watcherB, watcherB.publishers);\\n```\\n##### （3）订阅者收到报纸\\n第二天，送报员就把报纸投进了门口邮箱（相当于财经报刊进行了消息发布）\\n```\\nfinancialNewspaper.notify()\\n// watcherA和watcherB收到报纸（消息）后，就触发了他们的行为\\n// watcherA：'喝着茶，看着报纸'\\n// watcherB：'大清早，晨读报纸'\\n```\\n##### （4）财经报社又来了个订阅者\\n有一天财经报社来了个`watcherC`，也订阅了报刊。\\n\\n我们再`new`个订阅者`watcherC`:\\n```\\nconst watcherC = new Watcher('watcherC', function () {\\n    console.log('大晚上，熬夜看报纸')\\n})\\n```\\n报社把订阅者`watcherC`记录在了登记表上。\\n```\\nfinancialNewspaper.addWatcher(watcherC)\\n```\\n\\n同样细心的订阅者`watcherC`也把财经报社记录在了小本本上。\\n```\\nwatcherC.addPublisher(financialNewspaper);\\n```\\n\\n##### （5）街道上又开了家体育类报社\\n有一天街道上又开了个体育报社。\\n\\n我们先`new`一个体育报社。\\n```\\nconst sportsNewspaper = new Publish('体育报社')\\n```\\n`watcherA`和`watcherC`也是体育爱好者，所以订阅了体育报刊。\\n\\n体育报社需要登记两个订阅者的姓名。\\n```\\nsportsNewspaper.addWatcher(watcherA)\\nsportsNewspaper.addWatcher(watcherC)\\n```\\n\\n这两订阅者，又各自把体育报社记录在了小本本上。\\n```\\nwatcherA.addPublisher(sportsNewspaper);\\nwatcherC.addPublisher(sportsNewspaper);\\n\\n```\\n##### （6）有订阅者取消体育报刊的报纸\\n订阅者`watcherC`本来不喜欢运动，起初订阅体育报刊纯粹为了凑热闹，三天的劲头已过，他决定取消体育报刊的报纸。\\n```\\nwatcherC.removePublishers('sportsNewspaper')\\n```\\n##### （7）有订阅者要离开这条街道\\n有一天，`watcherA`要出国留学，所以就从小本本上划掉了记录的报刊名称，并且通知报社取消报纸的订阅，第二天，送报员就没再给`watherA`送报纸。\\n```\\nwatcherA.clearPublishers()\\n```\\n\\n这里`watcherC`清掉小本本上名称的同时，也会通知到报社，体育报社和财经报社同样会在等级表上清除`watcherC`的名称。\\n```\\nclearPublishers() {\\n    const publishers = this.publishers.slice()\\n    for (let i = 0, l = publishers.length; i < l; i++) {\\n        publishers[i].removeWatcher(this.watcherName)\\n    }\\n\\n    this.publishers = []\\n}\\n```\\n##### （8）有报社要关门\\n岁月如梭，多年过去啦。\\n\\n随着移动互联网的兴起，纸媒受到影响，这条街道的财经报社决定关门。\\n```\\nfinancialNewspaper.clearWatchers()\\n```\\n\\n第二天就不再给登记表上的订阅者送报啦，订阅者收到消息后，从小本本上划掉了财经类报刊的名字。\\n```\\nclearWatchers() {\\n    const watcherLists = this.watcherLists.slice()\\n    for (let i = 0, l = watcherLists.length; i < l; i++) {\\n        watcherLists[i].removePublishers(this.publisherName)\\n    }\\n\\n    this.watcherLists = []\\n}\\n```\\n\\n*这里描述了发布者的产生、订阅者的产生、发布者发布消息的方式、订阅者接受消息的途径、订阅者接收到消息的行为、发布者的新增、订阅者的新增、发布者的离开和订阅者的离开等关系和逻辑。代码具体的执行结果，还需要学友自行运行验证。*\\n\\n##### 小结\\n发布订阅者模式又叫观察者模式，它定义了对象间的一种一对多的关系。这种关系，既指一个发布者可以对应多个订阅者，又可以指一个订阅者也订阅多个发布者的消息。\\n\\n#### 12、命令模式\\n> 命令者模式，指的是执行主体可以执行某些特定事件，并且，支持队列等待、调起执行和事件撤销等行为。\\n\\n假如有个五子棋的场景，黑棋是真人，白棋是电脑，黑棋先落子，可以悔棋。\\n\\n我们先来定义一个执行者主体类：\\n```\\nclass CommandSubject {\\n    constructor(name) {\\n        // 命令执行者\\n        this.executer = name;\\n        // 命令所在位置的列表\\n        this.posList = []\\n        // 演算步骤\\n        this.computedStep = []\\n    }\\n\\n    // 命令执行函数\\n    execute(pos /*落子位置*/ ) {\\n        // 执行命令\\n        console.log(`棋子落在了[${pos[0]}, ${pos[1]}]的位置`)\\n        // 记录位置\\n        this.posList.push(pos)\\n    }\\n    // 撤回操作\\n    undo(step /* 撤回步数*/ ) {\\n        // 撤回命令\\n        for (let i = 0; i < step; i++) {\\n            // 撤回的位置\\n            const pos = this.posList.pop();\\n            console.log()\\n            // 撤回的操作\\n            console.log(`撤回[${pos[0]}, ${pos[1]}]位置的棋子`)\\n        }\\n    }\\n    // 执行演算步骤\\n    executeComputedCommand() {\\n        // 请自行实现吆\\n    }\\n\\n}\\n```\\n我们`new`一个黑棋执行者。\\n```\\nvar blackSubject = new CommandSubject('黑棋执行者');\\n```\\n假如黑棋执行者，和电脑共对弈 `4` 步。\\n```\\nblackSubject.execute([3, 4])\\nblackSubject.execute([4, 2])\\nblackSubject.execute([5, 3])\\nblackSubject.execute([5, 4])\\nconsole.log(blackSubject.posList)\\n```\\n此时的局势如图：\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6deaefecd5744ebaa9a49aad399c65f1~tplv-k3u1fbpfcp-watermark.image?)\\n\\n黑棋执行者觉得下错了，想悔棋 `2` 步。\\n```\\nblackSubject.undo(2)\\n```\\n此时的局势如图：\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/049d40dbb29b4e428c16c8c157bc1357~tplv-k3u1fbpfcp-watermark.image?)\\n\\n下棋时可能我们还会想一下接下来会走那几步，涉及到演算，假如我们演算了 `3` 步，那么这 `3` 步不是一下就落子的，而是等白棋落子后，黑棋执行者才能落子，这就是命令执行的队列问题。请自行实现吆~\\n\\n如果感兴趣，也可以再`new`一个白棋执行者，互动下棋吆~\\n\\n#### 13、模板方法模式\\n模板方法模式由父类和子类构成，通过父类确定整个系统的执行流程，子类负责具体的流程实现，可以通过继承的方式重写父类的某些方法，但是不能改变功流程的执行顺序。体现了抽象与实现分离编程思想。\\n\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/54e5603b5d08408e855ed74220932c98~tplv-k3u1fbpfcp-watermark.image?)\\n\\n图中，父类控制了整个系统的执行流程，子类负责具体的流程实现。\\n\\n##### （1）经典案例饮料冲制流程\\n我们知道，冲制饮料一般有以下步骤：<br>\\n①把水煮沸<br>\\n②用沸水冲泡饮料<br>\\n③把饮料倒进杯子<br>\\n④加调料<br>\\n示例代码：<br>\\n\\n        // 父类：实现泡制饮料的子类功能的流程，本次功能有4个流程，如下：\\n        var Beverage = function () {}\\n        // 然后，我们梳理冲制饮料的流程\\n        Beverage.prototype.boilWater = function () {\\n            console.log('公共流程：把水煮沸')\\n        }\\n        Beverage.prototype.brew = function () {\\n            throw new Error( '子类必须重写 brew 方法' );\\n        }\\n        Beverage.prototype.pourInCup = function () {\\n            throw new Error( '子类必须重写 pourInCup 方法' );\\n        }\\n        Beverage.prototype.addCondiments = function () {\\n            throw new Error( '子类必须重写 addCondiments 方法' );\\n        } \\n        // 冲制饮料\\n        Beverage.prototype.init = function () {\\n            this.boilWater();\\n            this.brew();\\n            this.pourInCup();\\n            this.addCondiments();\\n        }\\n        // 子类：具体实现泡制一杯茶的的流程\\n        var Tea = function () {}\\n        Tea.prototype = new Beverage();\\n        Tea.prototype.brew = function () {\\n            console.log('用水泡茶');\\n        }\\n        Tea.prototype.pourInCup = function () {\\n            console.log('将茶倒进杯子');\\n        }\\n        Tea.prototype.addCondiments = function () {\\n            console.log('加冰糖');\\n        }\\n        var tea = new Tea();\\n        tea.init()\\n&emsp;&emsp;从以上例子可以看出，父类已经制定了泡制饮料的流程，并且确定了不管哪种饮料都需要把水煮沸的公共方法`boilWater`，至于`brew`、`pourInCup`和`addCondiments`泡制茶、黑咖啡、牛奶和豆浆等饮料都有所不同，由子类去具体实现。\\n\\n抽象的父类已经产生，接下来就是泡制茶的子类的具体实现，子类首先继承父类的泡制饮料的确定流程。其中，将水烧开继承父类，`brew`、`pourInCup`和`addCondiments`方法由子类进行重写，至此，泡茶的流程已经完成，黑咖啡、牛奶和豆浆等饮料同理。\\n\\n以上例子执行结果是：\\n\\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/752b89b2caa245c5a575097f7ca49208~tplv-k3u1fbpfcp-watermark.image)\\n\\n##### （2）框架案例`vue`的主流程\\n`vue2.0`是最受欢迎的前端框架之一，以其小而美的特点，成为众多前端小伙伴的首选。使用`vue`的过程中，全局方法的定义、生命周期的使用、组件的封装和路由的实现等都感觉隐隐约约都被一种力量牢牢锁定，`vue`各个功能在使用的过程有序进行着。翻看`vue`源码时才发现：\\n```\\nimport { initMixin } from './init'\\nimport { stateMixin } from './state'\\nimport { renderMixin } from './render'\\nimport { eventsMixin } from './events'\\nimport { lifecycleMixin } from './lifecycle'\\nimport { warn } from '../util/index'\\n\\nfunction Vue (options) {\\n  if (process.env.NODE_ENV !== 'production' &&\\n    !(this instanceof Vue)\\n  ) {\\n    warn('Vue is a constructor and should be called with the `new` keyword')\\n  }\\n  this._init(options)\\n}\\n// Vue类由各种initMixin、stateMixin、eventsMixin、lifecycleMixin和renderMixin的方法有序的混入各种功能\\ninitMixin(Vue)\\nstateMixin(Vue)\\neventsMixin(Vue)\\nlifecycleMixin(Vue)\\nrenderMixin(Vue)\\n\\nexport default Vue\\n```\\n我们发现，`Vue`本质上是一个构造函数，在其`new`的时候，会执行内部唯一的初始化方法`this._init`。\\n\\n初始化方法在`initMixin`中实现：\\n```\\n\\n  Vue.prototype._init = function (options?: Object) {\\n    const vm: Component = this\\n    // ...\\n    initLifecycle(vm)\\n    initEvents(vm)\\n    initRender(vm)\\n    callHook(vm, 'beforeCreate')\\n    initInjections(vm) // resolve injections before data/props\\n    initState(vm)\\n    initProvide(vm) // resolve provide after data/props\\n    callHook(vm, 'created')\\n    // ...\\n    if (vm.$options.el) {\\n      vm.$mount(vm.$options.el)\\n    }\\n  }\\n}\\n```\\n可以看出，初始化`this._init`方法是由如图的一些方法确定有序执行的。`vue`的创建过程中的初始化方法`this_init`就是一种模板方法模式。\\n\\n##### 小结\\n模板方法模式是众多设计模式之一，解决的主要业务场景是父类创建确定的子类功能或者任务的执行流程，子类继承的时候可以重写父类的某些方法。\\n\\n#### 14、职责链模式\\n> 职责链模式，指的是由拥有处理能力的职责节点对象组成一个链条，一个请求从链条的开始或者中间进入，都有机会被后续的职责节点对象处理。进入职责链的请求，会沿着后续链条被传递，直到请求被处理才会终止传递。\\n\\n身在帝都，每天挤地铁去搬砖，发现月初、月中和月末地铁的票价都不一样。\\n\\n查看规则才发现，乘车消费超过`150元`打五折，超过`100元`打八折，不足`100元`不打折。\\n\\n这里通过职责链模拟一个处理订单金额的功能，该方法传入消费总金额和当前车程的常规票价。\\n\\n先看流程图：\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a8500341a8b84043bd62e08e09c96f94~tplv-k3u1fbpfcp-watermark.image?)\\n\\n先进入总消费大于`150元`的流程，当前消费金额是否大于`150元`，返回金额，请求结束。如果不是，进入下一个总消费大于`100元的`流程。\\n\\n进入总消费大于`100元`的流程，当前消费金额是否大于`100元`，返回金额，请求结束。如果不是，进入下一个总消费不足`100元的`流程。\\n\\n在总消费不足`100元的`流程中，所有的请求都会被处理。\\n\\n下面进行具体的代码实现：\\n```\\n// 1、定义各职责节点对象\\n// 定义超过150元的职责节点对象\\nvar consumption150 = function (consumption, fare) {\\n    if (consumption > 150) {\\n        console.log(`地铁总消费大于150元，本次${fare}元的票价折扣价${fare * 0.5}`);\\n    } else {\\n        return 'nextProcess'; // 传递给下一个流程\\n    }\\n};\\n// 定义超过100元的职责节点对象\\nvar consumption100 = function (consumption, fare) {\\n    if (consumption > 100) {\\n        console.log(`地铁总消费大于100元，本次${fare}元的票价折扣价${fare * 0.8}`);\\n    } else {\\n        return 'nextProcess'; // 传递给下一个流程\\n    }\\n};\\n// 定义不足100元的职责节点对象\\nvar consumptionNormal = function (consumption, fare) {\\n    console.log(`地铁总消费不足100元，本次${fare}元的票价依然收费${fare}元`);\\n};\\n\\n// 2、设置链条构造函数\\nvar Chain = function (selfFn) {\\n    this.selfFn = selfFn; // 自身函数\\n    this.process = null; // 下一个职责节点\\n};\\nChain.prototype.setNextProcess = function (process) {\\n    return this.process = process; // 设置当前节点对象的下一个节点对象\\n};\\nChain.prototype.handleRequest = function () {\\n    // 执行自身函数，并返回执行结果\\n    var ret = this.selfFn.apply(this, arguments);\\n    // 返回nextProcess表示当前职责节点不能处理请求，此时将请求交个下一个职责节点\\n    if (ret === 'nextProcess') {\\n        return this.process && this.process.handleRequest.apply(this.process, arguments);\\n    }\\n    return ret;\\n};\\n// 创建节点，包含自身selfFn和是否成功请求的标志nextProcess\\nvar chainconsumption150 = new Chain(consumption150);\\nvar chainconsumption100 = new Chain(consumption100);\\nvar chainconsumptionNormal = new Chain(consumptionNormal);\\n\\n// 3、设置节点间的链条关系，形成职责链\\nchainconsumption150.setNextProcess(chainconsumption100);\\nchainconsumption100.setNextProcess(chainconsumptionNormal);\\n```\\n##### （1）职责链可以从任意节点进入\\n现在可以通过`chainconsumption150.handleRequest(120, 8)`的方式进入到职责链的第一个职责节点对象中。\\n\\n也可以通过`chainconsumption100.handleRequest(120, 8)`的方式进入到职责链的第二个职责节点对象中。\\n\\n##### （2）职责链可以进行扩展\\n假如，总消费超过`300元`以后，可以打四折。\\n\\n①定义职能节点对象\\n```\\nvar consumption300 = function (consumption, fare) {\\n    if (consumption > 300) {\\n        console.log(`地铁总消费大于300元，本次${fare}元的票价折扣价${fare * 0.4}`);\\n    } else {\\n        return 'nextProcess'; // 传递给下一个流程\\n    }\\n};\\n```\\n②创建链条节点\\n\\n```\\nvar chainconsumption300 = new Chain(consumption300);\\n```\\n③把节点塞入到链条中\\n```\\nchainconsumption300.setNextProcess(chainconsumption150);\\n```\\n\\n##### 小结\\n职责链模式，支持链条长度的扩展，也支持在链条中进入的位置。\\n\\n#### 15、中介者模式\\n> 中介者模式的作用就是解决对象与对象之间错综复杂的交互关系，增加一个中介者以后，所有相关的对象都通过中介者对象来通信，当一个对象发生改变后，只需要通知中介者对象即可。\\n\\n##### （1）一个卖主，多个买主\\n假设有`卖家A`有一套`面积：100平米，价格：20000元/平米`的房子急需出售，他目前知道有三个买主在找房，对应关系如图：\\n\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3fa9432920e4ca4bcec8f33f977b28e~tplv-k3u1fbpfcp-watermark.image?)\\n\\n通过代码实现卖家找买家：\\n```\\n// 卖家类\\nvar Seller = function (name, info) {\\n    this.name = name;\\n    this.info = info;\\n}\\n// 卖家找买家的函数\\nSeller.prototype.match = function (buyer) {\\n    // 定义买家要求\\n    const buyerDemand = buyer.demand;\\n    // 获取需求数字\\n    const reg = /\\\\d+/\\n    // 1、买家的要求\\n    let buyerRequestArea = buyerDemand.area.match(reg);\\n    buyerRequestArea = parseInt(buyerRequestArea);\\n    let buyerRequestprice = buyerDemand.price.match(reg);\\n    buyerRequestprice = parseInt(buyerRequestprice);\\n    // 2、卖家的条件\\n    let sellerOwnArea = this.info.area.match(reg);\\n    sellerOwnArea = parseInt(sellerOwnArea);\\n    let sellerOwnprice = this.info.price.match(reg);\\n    sellerOwnprice = parseInt(sellerOwnprice);\\n    return sellerOwnArea >= buyerRequestArea && sellerOwnprice <= buyerRequestprice;\\n}\\n// 买家类\\nvar Buyer = function (name, demand) {\\n    this.name = name;\\n    this.demand = demand;\\n}\\n\\n// 定义卖家\\nvar sellA = new Seller('卖家A', {\\n    area: '100平米', // 卖家尺寸\\n    price: '20000元/平米' // 卖家要价\\n});\\n\\nvar buyerX = new Buyer('买家X', {\\n    area: '110平米', // 买家要求尺寸\\n    price: '10000元/平米' // 买家最高愿意支付\\n})\\nvar buyerY = new Buyer('买家Y', {\\n    area: '120平米', // 买家要求尺寸\\n    price: '30000元/平米' // 买家最高愿意支付\\n})\\nvar buyerZ = new Buyer('买家Z', {\\n    area: '99平米', // 买家要求尺寸\\n    price: '30000元/平米' // 买家最高愿意支付\\n})\\n// 卖家开始找买主\\nconsole.log(sellA.match(buyerX)); // true：没找到\\nconsole.log(sellA.match(buyerY)); // true：没找到\\nconsole.log(sellA.match(buyerZ)); // true：找到了\\n```\\n\\n当前例子中，先定义卖家类，并为卖家定义`match`方法去匹配买家，如果其售卖面积大于买家要求，且售卖价格低于买家最高愿意支付，我们认为该买主是意向客户。\\n\\n当前例子中刚好找到第三个`买家Z`的时候，就找到了。但是实际情况可能是找了几十个也没找到合适的意向客户。\\n\\n##### （2）多个卖主，多个买主\\n假设又有`卖主B`和`卖主C`也加入了卖方行列中，此时的对应关系如图：\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36c9c03734d3421fa5c603845d460fa3~tplv-k3u1fbpfcp-watermark.image?)\\n\\n如果，我们依然按照以上的方式为`卖主B`和`卖主C`寻找`买主`，那么，此时的对应关系就已经开始复杂起来。如果有成千上万个`卖主`和`买主`在进行交易的匹配，交易状况就更加复杂，一个卖主可能会和几十个买主沟通筛选，一个买主也可能和几十个卖主沟通筛选。\\n\\n这个时候，就有必要通过中介者模式进行改造了，为了展示主要逻辑，以下去掉价格和平米单价的单位。\\n```\\n// 卖家类\\nvar Seller = function (name, info) {\\n    this.name = name;\\n    this.info = info;\\n}\\n\\n// 买家类\\nvar Buyer = function (name, demand) {\\n    this.name = name;\\n    this.demand = demand;\\n}\\n\\n// 引入中介者\\nvar broker = (function () {\\n    var sellerList = [];\\n    var buyerList = [];\\n    var operations = {}\\n    operations.addSellers = function (seller) {\\n        sellerList.push(seller)\\n    }\\n\\n    operations.addBuyers = function (buyer) {\\n        buyerList.push(buyer)\\n    }\\n\\n    operations.findBuyer = function (seller) {\\n        const result = []\\n        // 遍历所有的买家\\n        buyerList.map(v => {\\n            console.log(v.demand, seller);\\n            if (seller.info.price <= v.demand.price && seller.info.area >= v.demand.area) {\\n                result.push(v);\\n            }\\n        })\\n        return result\\n    }\\n\\n    operations.findSeller = function (buyer) {\\n        const result = []\\n        // 遍历所有的买家\\n        sellerList.map(v => {\\n            if (v.info.price <= buyer.demand.price && v.info.area >= buyer.demand.area) {\\n                result.push(v);\\n            }\\n        })\\n        return result;\\n    }\\n\\n    return operations;\\n})()\\n\\n// 定义卖家，并将其添加到中介者卖家列表中\\nvar sellA = new Seller('卖家A', {\\n    area: 100, // 卖家尺寸\\n    price: 20000 // 卖家要价\\n});\\nvar sellB = new Seller('卖家B', {\\n    area: 90, // 卖家尺寸\\n    price: 18000 // 卖家要价\\n});\\n\\nvar sellC = new Seller('卖家C', {\\n    area: 120, // 卖家尺寸\\n    price: 22000 // 卖家要价\\n});\\n\\nbroker.addSellers(sellA)\\nbroker.addSellers(sellB)\\nbroker.addSellers(sellC)\\n\\n// 定义买家，并将其添加到中介者买家列表中\\nvar buyerX = new Buyer('买家X', {\\n    area: 110, // 买家要求尺寸\\n    price: 10000 // 买家最高愿意支付\\n})\\nvar buyerY = new Buyer('买家Y', {\\n    area: 80, // 买家要求尺寸\\n    price: 30000 // 买家最高愿意支付\\n})\\nvar buyerZ = new Buyer('买家Z', {\\n    area: 100, // 买家要求尺寸\\n    price: 30000 // 买家最高愿意支付\\n})\\n\\nbroker.addBuyers(buyerX)\\nbroker.addBuyers(buyerY)\\nbroker.addBuyers(buyerZ)\\n```\\n例子中，我们除了定义卖家类和买家类，我们还引入了中介者，中介者拥有卖家信息列表，也拥有买家信息列表。当有卖家需要卖方时，可以将房屋信息和个人姓名留给中介者，中介者将其推入到卖家信息列表中。当有买家需要买房时，可以将购买需求留给中介者，中介者将其推入到买家需求列表中。\\n\\n有一天，`卖家A`告诉中介者，他着急用钱，他的房子着急出手。于是中介者开始帮其寻找买主：\\n```\\nvar buyers = broker.findBuyer(sellA)\\n```\\n\\n有一天，`买家Z`告诉中介者，他现在手头有钱了，想全款买套房。于是中介者开始帮其寻找买主：\\n```\\nvar sellers = broker.findSeller(buyerZ)\\n```\\n##### 小结\\n我们发现，引入中介者以后，卖家和买家再也不用去为寻找买家或者卖家而烦恼，中介者拥有大量的卖主和买主信息，为其快速精准匹配。这大概也是中介这个职业兴起，并且长盛不衰的原因之一。\\n#### 16、状态模式\\n> 状态模式，指的是事物内部状态的变化，会导致事物具体行为的变化。并且，状态的切换可以是循环的。最简单的例子是生活中的开关，基本都是状态模式的使用。\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/958d7c7cec104efb90ddbf36258b61ba~tplv-k3u1fbpfcp-watermark.image?)\\n\\n##### （1）利用实例对象的切换\\n```\\n// 定义灯类\\nvar Light = function () {\\n    this.currState = stateManager.off; // 灯的状态\\n    this.button = null; // 开关\\n};\\nLight.prototype.init = function () {\\n    var button = document.createElement('button'),\\n        self = this;\\n    button.innerHTML = '关灯';\\n    this.button = document.body.appendChild(button);\\n    this.button.onclick = function () {\\n        self.currState.changeState.call(self); // 把请求委托给 stateManager 状态机\\n    }\\n};\\n// 定义灯的状态管理对象\\nvar stateManager = {\\n    off: {\\n        changeState: function () {\\n            this.button.innerHTML = '开灯';\\n            this.currState = stateManager.on;\\n        }\\n    },\\n    on: {\\n        changeState: function () {\\n            this.button.innerHTML = '关灯';\\n            this.currState = stateManager.off;\\n        }\\n    }\\n};\\n// 实例化灯\\nvar light = new Light();\\n// 登初始化\\nlight.init();\\n```\\n在当前例子中，首先定义灯类`Light`，其中有属性`currState`表示当前状态，`button`表示开关。定义的`init`方法会首先创建开关，再为开关绑定切换开关状态的函数`changeState`。\\n\\n定义的状态管理对象中包含属性`off`和`on`的具体行为对象，每个行为的执行都是通过其中的`changeState`函数来实现，该函数触发时就会将当前灯的状态进行切换。\\n##### （2）利用数组的有序性\\n```\\n// 定义灯的类\\nvar Light = function () {\\n    this.currentIndex = 0; // 设置初始索引\\n    this.button = null; // 开关\\n};\\nLight.prototype.init = function () {\\n    var button = document.createElement('button'),\\n        self = this;\\n    button.innerHTML = '关灯';\\n    this.button = document.body.appendChild(button);\\n    this.button.onclick = function () {\\n        excuteStateFn(self);\\n    }\\n};\\n// 定义状态状态切换列表\\nvar stateList = [\\n    function changeState(light) {\\n        light.button.innerHTML = '开灯';\\n    },\\n    function changeState(light) {\\n        light.button.innerHTML = '关灯';\\n    }\\n]\\n// 定义状态切换执行函数\\nfunction excuteStateFn(light) {\\n    light.currentIndex >= stateList.length && (light.currentIndex = 0); // 进行边界状态的控制\\n    stateList[light.currentIndex++](light) // 切换状态\\n\\n}\\n// 实例化灯\\nvar light = new Light();\\n// 灯进行初始化\\nlight.init();\\n```\\n\\n在当前例子中，首先定义灯类`Light`，其中有属性`currentIndex`表示行为对应的索引，`button`表示开关。定义的`init`方法会首先创建开关，再为开关绑定切换开关状态的函数`excuteStateFn(self)`。\\n\\n定义的状态切换列表中`stateList`包含数组元素`off`和`on`的具体行为函数。\\n\\n再定义行为切换执行函数`excuteStateFn`，每个行为的执行都是通过执行当前索引对应的行为函数`stateList[light.currentIndex++](light)`来实现的，通过修改当前索引的值来切换下一次执行的状态索引。\\n##### 小结\\n状态模式的实现不止一种实现思路，可以利用行为函数执行时修改当前实例对象的状态实现，也可以利用数组天然的有序性通过索引的改变指向对应的执行函数，当然，还可能有其他实现方式。只要遵循状态模式`状态的切换可以是循环的`，任何实现都是正确的。\\n\\n## 总结\\n以上简单介绍了十六种设计模式，当然除此之外，还有其他的设计模式。也许，不远的将来，会有新的，被众多人所承认的设计模式产生。\\n\\n通过以上介绍我们可以先略微掌握设计模式的`道`，不断`修道`，终会将设计模式`内化`，在合适的场景，可能会起到事半功倍的效果，扳子、钳子、改锥、电钻我们都有，万一哪天要打个孔，上个螺丝，就变得非常简单。\\n\\n学习设计模式也是，在某些错综复杂的场景中，拿出一两个设计模式思想，高效处理业务难点，就如打个孔，上个螺丝那么简单。\\n\\n参考资料\\n--\\n《JavaScript》设计模式与开发实践\\n\\n写在最后\\n--\\n`2023年`，新的一年，新的征程，希望各位学友`狡兔三窟`，即使被裁也能很快找到下一个`窟`，一起加油。\\n\\n`2023年`，希望自己能够有高质量的文章输出，持续分享。\\n\\n文中纰漏在所难免，`如有纰漏请贵手留言`。\\n\\n本文如有帮助，`点赞`就是对我最大的肯定和支持吆❤\\n\\n\\n",
        "tags": [
            "前端",
            "设计模式",
            "架构"
        ]
    },
    {
        "article_id": "7191076198506561573",
        "cover_image": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7fe37baf75494af8bc0a63295702a12f~tplv-k3u1fbpfcp-watermark.image?",
        "title": "如何使用jenkins搭建一个中小企业前端项目部署环境",
        "brief": "文章内容 传统发布和现在发布的对比和区别 项目案例-手动上传服务器，使用jenkins上传服务器 配置不同的发布环境 配置域名 配置https 配置钉钉机器人通知 服务器购买：抢占式实例 Jenkin",
        "user_name": "白哥学前端",
        "view_count": 8048,
        "collect_count": 171,
        "comment_count": 8,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/576223ba364f16d3fcd12461465e0aa1~300x300.image",
        "category": "前端",
        "content": "\\n**文章内容**\\n\\n1. 传统发布和现在发布的对比和区别\\n2. 项目案例-手动上传服务器，使用jenkins上传服务器\\n3. 配置不同的发布环境\\n4. 配置域名\\n5. 配置https\\n6. 配置钉钉机器人通知\\n\\n服务器购买：抢占式实例\\n## **Jenkins 安装**\\n示例服务器为 阿里云 CentOS 服务器。**安全组中增加 8080 端口 Jenkins 默认占用**\\nJenkins 安装大体分两种方式，一种使用 Docker 另一种则是直接安装，示例选择后者。不管使用哪种方式安装，最终使用层面都是一样的。\\n\\nLinux安装过程\\n```\\n# 下载 Jenkins 资源\\nsudo wget -O /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat/jenkins.repo\\n# 这一步如果出现报错，使用下面的命令解决\\nsudo yum install -y ca-certificates\\n\\n# 获取并导入信任的包制作者的秘钥\\nsudo rpm --import https://pkg.jenkins.io/redhat/jenkins.io.key\\n# 升级 yum 源中的所有包\\nsudo yum upgrade\\n# Jenkins 依赖于 java 所以需要安装 JDK\\nsudo yum install java-11-openjdk\\n# 安装 Jenkins\\nsudo yum install jenkins\\n```\\n\\n```\\n# 启动 Jenkins 服务\\nsystemctl start jenkins\\n# 重启 Jenkins 服务\\nsystemctl restart jenkins\\n# 停止 Jenkins 服务\\nsystemctl stop jenkins\\n# 查看 Jenkins 服务状态\\nsystemctl status jenkins\\n```\\n启动过程稍微得等30s，启动服务后访问服务器地址 + 8080 端口（提前打开安全组8080），Jenkins 默认为 8080 端口。\\n\\n登录页面\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03ee0b1d369942e0bba8b11ba4ab418e~tplv-k3u1fbpfcp-zoom-1.image)\\n查找密码:首次进入使用 cat /var/lib/jenkins/secrets/initialAdminPassword 查看密码。\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05561ac2f0a447ecb3746f18ccebc5a2~tplv-k3u1fbpfcp-zoom-1.image)\\n选择推荐的插件，进行安装，安装过程稍长（5分钟以上）\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e3149366746411cb3aa20e21ef0f867~tplv-k3u1fbpfcp-zoom-1.image)\\n安装完成以后创建用户\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee807bd4430c4d7caa1b1f4b3943d2a8~tplv-k3u1fbpfcp-zoom-1.image)\\n账户：xiumubai 密码：*****\\n访问地址：[http://8.218.133.146:8080/](http://8.218.133.146:8080/)\\n后面的步骤一下点下一步就行了，最后进入首页\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e781b79bd7a44999b0b9f12f9907f10b~tplv-k3u1fbpfcp-zoom-1.image)\\n## 构建目标：拉取 github 代码\\n服务器要具备 git 环境。 yum install git\\n点击 **新建 Item** 创建一个 Freestyle Project\\n在 **源码管理** 处选择 git ，输入仓库地址，点击添加。\\t\\n项目示例：[https://github.com/xiumubai/guigu-oa-web.git](https://github.com/xiumubai/guigu-oa-web.git)\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af50f808653749218cee56662c6cf8d8~tplv-k3u1fbpfcp-zoom-1.image)\\n安装完成以后重启jenkins\\n然后到 **系统管理 -> 全局工具配置** 中配置 Node\\n因为我们的项目需要使用npm，所以需要node\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8186e31ca2f4310bc59765ad91857e4~tplv-k3u1fbpfcp-zoom-1.image)\\n随后去修改刚才创建的任务。在 **构建环境** 中会多出一个选项 Provide Node & npm bin/ folder to PATH 勾选即可。\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca9d7176032e4242a07632434af83ba5~tplv-k3u1fbpfcp-zoom-1.image)\\n为了我们能够在github上拉取代码，需要我们添加`git token`，在github中添加一个token\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/02e0823cc609425d94c7ffa6538e9f14~tplv-k3u1fbpfcp-zoom-1.image)\\n找到`系统设置`，找到`github`服务器，点击`添加`\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f3123ae8c40e4652bd6de5d7f795fefb~tplv-k3u1fbpfcp-zoom-1.image)\\n类型选择`Secret text`\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc7ea99c70994d49831d746a263e39c2~tplv-k3u1fbpfcp-zoom-1.image)\\n把刚生成的github token复制到这里，点击添加。\\n回到项目的设置中，找到`构建环境`\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b79f4525b16a41c5b00405dce9e69131~tplv-k3u1fbpfcp-zoom-1.image)\\n把我们刚才生成好的Secret text 选中即可。\\n\\n然后在 `Build Steps` 中选择 **增加构建步骤 -> 执行 shell** 输入打包发布相关的命令。Jenkins 会逐行执行。\\n```\\nnode -v\\nnpm -v\\nrm -rf node_modules\\nnpm install\\nnpm run build\\n```\\n**构建后操作**\\n构建完成以后，我们需要把构建的产物推送到我们的服务器，所以需要用到`ssh publisher`这个插件。\\n安装插件，`ssh publisher`，然后配置好要发布的服务器环境。\\n打开`系统设置`，找到`** **Publish over SSH`\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/faec0a560dc248078ef223c6a3416aa1~tplv-k3u1fbpfcp-zoom-1.image)\\n配置好我们需要发布的服务器，这样才能连接上我们的服务器，推送代码。\\n回到任务的设置中，选择我们刚才配置好的服务器\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7eba78898d7542e4940309e28573e13f~tplv-k3u1fbpfcp-zoom-1.image)\\n上面需要填写好上传的文件和目标地址。\\n最后配置好nginx的地址即可。\\n```\\nserver {\\n      listen       80;\\n      listen       [::]:80;\\n      server_name  _;\\n      #root         /usr/share/nginx/html;\\n    \\t# 这里是我们配置的服务器访问的静态页面路径\\n      root          /www/oa-web;\\n      # Load configuration files for the default server block.\\n      include /etc/nginx/default.d/*.conf;\\n\\n      error_page 404 /404.html;\\n      location = /404.html {\\n      }\\n\\n      error_page 500 502 503 504 /50x.html;\\n\\n      location = /50x.html {\\n      }\\n  }\\n```\\n配置完成以后，点击`立即构建`，等构建完毕以后，在浏览器中访问：[http://8.218.133.146](http://8.218.133.146/#/)即可看到我们刚才部署好的页面了。\\n## 拉取github不同代码分支，发布不同的环境\\n我们在选择部署的时候需要根据不同的分支去部署，然后部署到不同的环境\\n安装好`git paremeters`插件\\n然后配置参数\\n**配置分支参数**\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3edbd0a4c55e4262a87e384d223b39e4~tplv-k3u1fbpfcp-zoom-1.image)\\n**配置选项参数**\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/360312c993164121980cd294946a619e~tplv-k3u1fbpfcp-zoom-1.image)\\n配置完成以后，我们的构建页面就是这样的\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d929466bcf34f63bcf0aa419a808d15~tplv-k3u1fbpfcp-zoom-1.image)\\n继续回到配置修改`源码管理`\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c0a2347a7f4451eb56c63e58798b5d8~tplv-k3u1fbpfcp-zoom-1.image)\\n这里指定分支的时候就需要使用生命写好的参数`release`\\n`构建后操作`\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d7e78735ca0241cf85f6eacb45decbbb~tplv-k3u1fbpfcp-zoom-1.image)\\n这里的文件目录就需要根据env来配置，发布不同的环境，当打不以后，我们的目录就变成这样的了\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56a9541a14254d1892d14944c1c9108f~tplv-k3u1fbpfcp-zoom-1.image)\\n在oa-web下面会有`dev`和`pre`两个目录表示不同的环境，我们只要给这两个文件在nginx中配置不同的域名即可访问了。\\n## 配置域名\\n提前解析两个域名\\n```\\npre.xiumubai.com\\ndev.xiumubai.com\\n```\\n配置nginx解析\\n```\\n# 线上环境的配置\\nserver {\\n    listen       80;\\n    listen       [::]:80;\\n    server_name  pre.xiumubai.com;\\n    #root         /usr/share/nginx/html;\\n    root \\t      /www/oa-web/pre;\\n    # Load configuration files for the default server block.\\n    include /etc/nginx/default.d/*.conf;\\n\\n    error_page 404 /404.html;\\n    location = /404.html {\\n    }\\n\\n    error_page 500 502 503 504 /50x.html;\\n    location = /50x.html {\\n    }\\n}\\n\\n# 测试环境的配置\\nserver {\\n    listen       80;\\n    listen       [::]:80;\\n    server_name  dev.xiumubai.com;\\n    #root         /usr/share/nginx/html;\\n    root \\t      /www/oa-web/dev;\\n    # Load configuration files for the default server block.\\n    include /etc/nginx/default.d/*.conf;\\n\\n    error_page 404 /404.html;\\n    location = /404.html {\\n    }\\n\\n    error_page 500 502 503 504 /50x.html;\\n    location = /50x.html {\\n    }\\n}\\n```\\n当部署成功以后，我们就可以使用\\n[http://pre.xiumubai.com/#/](http://pre.xiumubai.com/#/)和[http://dev.xiumubai.com/#/](http://pre.xiumubai.com/#/)来访问我们的项目了。\\n## 配置https\\n需要去自己买个免费证书，绑定域名，然后下载好证书上传到服务器即可。\\n```\\nserver {\\n        listen 443 ssl;\\n        server_name  pre.xiumubai.com;\\n         #这里是证书路径\\n  \\tssl_certificate  cert/pre.xiumubai.com.pem; \\n         #这里是私钥路径\\n  \\tssl_certificate_key cert/pre.xiumubai.com.key;\\n\\troot \\t      /www/oa-web/pre;\\n        # Load configuration files for the default server block.\\n        include /etc/nginx/default.d/*.conf;\\n\\n        error_page 404 /404.html;\\n        location = /404.html {\\n        }\\n\\n        error_page 500 502 503 504 /50x.html;\\n        location = /50x.html {\\n        }\\n    }\\n\\n\\n```\\n当我们使用[https://pre.xiumubai.com/#/](https://pre.xiumubai.com/#/)访问的时候，浏览器会出现一个🔒\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56876c5385c945db825606e3fbff2be5~tplv-k3u1fbpfcp-zoom-1.image)代表我们的https已经配置成功了。\\n再配置一下当我们访问[http://pre.xiumubai.com/#/](https://pre.xiumubai.com/#/)强制跳转到了[https://pre.xiumubai.com/#/](https://pre.xiumubai.com/#/)\\n```\\nserver {\\n    listen       80;\\n    listen       [::]:80;\\n    server_name  pre.xiumubai.com;\\n\\t\\t# 访问http的时候自动跳转到https\\n\\t\\trewrite ^(.*)$ https://$host$1 permanent;\\n    \\n}\\n```\\n\\n## 配置钉钉机器人\\n在jenkins中安装插件`dingtalk`，在系统管理中，最下面找到`钉钉`，配置机器人消息\\n我们提前在钉钉群中添加一个机器人，然后复制`webhooks`\\n填写好名称和webhooks，点击测试，关键字要和添加钉钉机器人的关键字一样的。\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/645140f7d0f345d2a4d3a8a5557d6933~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n然后提交即可。\\n回到我们的任务中的配置，添加钉钉机器人\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca8f936a8c72498d90eac46fd55f9aed~tplv-k3u1fbpfcp-zoom-1.image)\\n当我们的任务构建以后，就会收到消息了。\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5db8925acef94745901acc3cbca6986e~tplv-k3u1fbpfcp-zoom-1.image)\\n## 执行条件判断\\n当我们在shell需要根据条件来判断执行不同的命令的时候，就可以这么写了，比如我现在需要在测试环境打包`npm run build:test`,线上环境打包`npm run buld`，可以这么写\\n```\\nnode -v\\nrm -rf node_modules\\nnpm install\\nif test $env = \\\"test\\\"; then\\n    echo 'test'\\n\\tnpm run build:test\\nelse\\n\\techo 'prod'\\n\\tnpm run build\\nfi\\n```\\n\\n这样，我们就可以选择不同的环境，来部署代码了。\\n\\n本期分享到这里就结束了，当然我们还有很多事情还需要做的，怎么把静态资源部署到CDN，怎么做回滚，怎么做灰度发布，负载均衡等等一系列，后面等研究明白了，再给大家分享。\\n\\n\\n",
        "tags": [
            "前端",
            "云原生",
            "Jenkins"
        ]
    },
    {
        "article_id": "7165706791450312717",
        "cover_image": "",
        "title": "实现Echarts 3D立体中国地图实现、世界地图、以及互相切换功能",
        "brief": "本文正在参加「金石计划 . 瓜分6万现金大奖」 在以往的地图里做了修改，加了一个3D立体效果的 效果图如下： 我这里采用的是echars地图实现，技术栈是vue 准备工作 需要引用几个文件echars",
        "user_name": "vaelcy",
        "view_count": 2134,
        "collect_count": 32,
        "comment_count": 5,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/a42f014b926776d05b11372924058471~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: cyanosis\\n---\\n***本文正在参加[「金石计划 . 瓜分6万现金大奖」](https://juejin.cn/post/7162096952883019783 \\\"https://juejin.cn/post/7162096952883019783\\\")***\\n\\n> 学习过程中将笔记整理跟大家分享，希望对大家也有所帮助，共同成长进步💪~\\\\\\n> 如果大家喜欢，可以点赞或留言💕~~~~，谢谢大家⭐️⭐️⭐️~~~\\n\\n在以往的地图里做了修改，加了一个3D立体效果的\\n\\n### 效果图如下：\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b0f952c5b2548df8fa5d78743364599~tplv-k3u1fbpfcp-watermark.image?)\\n\\n我这里采用的是echars地图实现，技术栈是vue\\n\\n### 准备工作\\n\\n需要引用几个文件echars.js、china.js、world.js、geoAtlasJson.js\\n\\n```html\\n    <!-- 中国地图 -->\\n    <script src=\\\"../../static/modify_echarts-4.7.0/china.js\\\"></script>\\n    <!-- 世界地图 -->\\n    <script src=\\\"../../static/modify_echarts-4.7.0/world.js\\\"></script>\\n    <script src=\\\"../js/geoAtlasJson.js\\\"></script>\\n```\\n## 一级页面部分\\n\\n### HTML部分\\n创建两个容器，分别放置中国地图和世界地图\\n```html\\n    <div>\\n        <div class=\\\"chinaMap\\\" ref=\\\"chinaMap\\\"></div>\\n        <div class=\\\"miniWorldMap\\\" ref=\\\"miniWorldMap\\\"></div>\\n    </div>\\n```\\n### data数据部分\\n```js\\ndata: function () {\\n    return {\\n        chinaMap: \\\"\\\",//中国地图\\n        worldMap: \\\"\\\",//世界地图\\n        worldoption: {},\\n        chinaoption: {},\\n    }\\n},\\nmounted: function () {\\n    setTimeout(() => {\\n        this.$nextTick(function () {\\n            this.chinaConfigure();\\n            this.worldConfigure();\\n        });\\n    }, 0)\\n},\\n```\\n### 中国地图配置部分\\n```js\\nmethods: {\\n    // 中国地图配置代码\\n    chinaConfigure(mapdata) {\\n        this.chinaMap = echarts.init(document.querySelector('.chinaMap'));\\n        //1.中国地图\\n        var chinaMap = \\\"../../static/echartsMapjsondata/json/province/china.json\\\";\\n        //2.台湾省地图\\n        var taiWanMap = \\\"../../static/echartsMapjsondata/json/province/taiwan.json\\\";\\n        //3.海南省地图\\n        var haiNanMap = \\\"../../static/echartsMapjsondata/json/province/hainan.json\\\";\\n        //4.安徽省地图\\n        var anHuiMap = \\\"../../static/echartsMapjsondata/json/province/anhui.json\\\";\\n        //5.江西省地图\\n        var jiangXiMap = \\\"../../static/echartsMapjsondata/json/province/jiangxi.json\\\";\\n        //6.湖南省地图\\n        var huNanMap = \\\"../../static/echartsMapjsondata/json/province/hunan.json\\\";\\n        //7.云南省地图\\n        var yunNanMap = \\\"../../static/echartsMapjsondata/json/province/yunnan.json\\\";\\n        //8.贵州省地图\\n        var guiZhouMap = \\\"../../static/echartsMapjsondata/json/province/guizhou.json\\\";\\n        //9.广东省地图\\n        var guangDongMap = \\\"../../static/echartsMapjsondata/json/province/guangdong.json\\\";\\n        //10.福建省地图\\n        var fuJianMap = \\\"../../static/echartsMapjsondata/json/province/fujian.json\\\";\\n        //11.浙江省地图\\n        var zheJiangMap = \\\"../../static/echartsMapjsondata/json/province/zhejiang.json\\\";\\n        //12.江苏省地图\\n        var jiangSuMap = \\\"../../static/echartsMapjsondata/json/province/jiangsu.json\\\";\\n        //13.四川省地图\\n        var siChuanMap = \\\"../../static/echartsMapjsondata/json/province/sichuan.json\\\";\\n        //14.重庆市市地图\\n        var chongQingMap = \\\"../../static/echartsMapjsondata/json/province/chongqing.json\\\";\\n        //15.湖北省地图\\n        var huBeiMap = \\\"../../static/echartsMapjsondata/json/province/hubei.json\\\";\\n        //16.河南省地图\\n        var heNanMap = \\\"../../static/echartsMapjsondata/json/province/henan.json\\\";\\n        //17.山东省地图\\n        var shanDongMap = \\\"../../static/echartsMapjsondata/json/province/shandong.json\\\";\\n        //18.吉林省地图\\n        var jiLinMap = \\\"../../static/echartsMapjsondata/json/province/jilin.json\\\";\\n        //19.辽宁省地图\\n        var liaoNingMap = \\\"../../static/echartsMapjsondata/json/province/liaoning.json\\\";\\n        //20.天津市市地图\\n        var tianJinMap = \\\"../../static/echartsMapjsondata/json/province/tianjin.json\\\";\\n        //21.北京市市地图\\n        var beiJingMap = \\\"../../static/echartsMapjsondata/json/province/beijing.json\\\";\\n        //22.河北省地图\\n        var heBeiMap = \\\"../../static/echartsMapjsondata/json/province/hebei.json\\\";\\n        //23.山西省地图\\n        var shanXiMap = \\\"../../static/echartsMapjsondata/json/province/shanxi.json\\\";\\n        //24.陕西省地图\\n        var shanXi2Map = \\\"../../static/echartsMapjsondata/json/province/shanxi1.json\\\";\\n        //25.宁夏回族自治区省地图\\n        var ningXiaMap = \\\"../../static/echartsMapjsondata/json/province/ningxia.json\\\";\\n        //26.青海省地图\\n        var qingHaiMap = \\\"../../static/echartsMapjsondata/json/province/qinghai.json\\\";\\n        //27.西藏自治区地图\\n        var xiZangMap = \\\"../../static/echartsMapjsondata/json/province/xizang.json\\\";\\n        //28.黑龙江省地图\\n        var heiLongJiangMap = \\\"../../static/echartsMapjsondata/json/province/heilongjiang.json\\\";\\n        //29.内蒙古自治区地图\\n        var neimengGuMap = \\\"../../static/echartsMapjsondata/json/province/neimenggu.json\\\";\\n        //30.甘肃省地图\\n        var ganSuMap = \\\"../../static/echartsMapjsondata/json/province/gansu.json\\\";\\n        //31.新疆维吾尔自治区省地图\\n        var xinJiangMap = \\\"../../static/echartsMapjsondata/json/province/xinjiang.json\\\";\\n        //32.广西壮族自治区地图\\n        var guangxiMap = \\\"../../static/echartsMapjsondata/json/province/guangxi.json\\\";\\n        //33.上海地图\\n        var shangHai = \\\"../../static/echartsMapjsondata/json/province/shanghai.json\\\";\\n        var mapJson = [\\n            {\\n                name: \\\"台湾\\\",\\n                json: taiWanMap,\\n            },\\n            {\\n                name: \\\"海南\\\",\\n                json: haiNanMap,\\n            },\\n            {\\n                name: \\\"安徽\\\",\\n                json: anHuiMap,\\n            },\\n            {\\n                name: \\\"江西\\\",\\n                json: jiangXiMap,\\n            },\\n            {\\n                name: \\\"湖南\\\",\\n                json: huNanMap,\\n            },\\n            {\\n                name: \\\"云南\\\",\\n                json: yunNanMap,\\n            },\\n            {\\n                name: \\\"贵州\\\",\\n                json: guiZhouMap,\\n            },\\n            {\\n                name: \\\"广东\\\",\\n                json: guangDongMap,\\n            },\\n            {\\n                name: \\\"福建\\\",\\n                json: fuJianMap,\\n            },\\n            {\\n                name: \\\"浙江\\\",\\n                json: zheJiangMap,\\n            },\\n            {\\n                name: \\\"江苏\\\",\\n                json: jiangSuMap,\\n            },\\n            {\\n                name: \\\"四川\\\",\\n                json: siChuanMap,\\n            },\\n            {\\n                name: \\\"重庆\\\",\\n                json: chongQingMap,\\n            },\\n            {\\n                name: \\\"湖北\\\",\\n                json: huBeiMap,\\n            },\\n            {\\n                name: \\\"河南\\\",\\n                json: heNanMap,\\n            },\\n            {\\n                name: \\\"山东\\\",\\n                json: shanDongMap,\\n            },\\n            {\\n                name: \\\"吉林\\\",\\n                json: jiLinMap,\\n            },\\n            {\\n                name: \\\"辽宁\\\",\\n                json: liaoNingMap,\\n            },\\n            {\\n                name: \\\"天津\\\",\\n                json: tianJinMap,\\n            },\\n            {\\n                name: \\\"北京\\\",\\n                json: beiJingMap,\\n            },\\n            {\\n                name: \\\"河北\\\",\\n                json: heBeiMap,\\n            },\\n            {\\n                name: \\\"山西\\\",\\n                json: shanXiMap,\\n            },\\n            {\\n                name: \\\"陕西\\\",\\n                json: shanXi2Map,\\n            },\\n            {\\n                name: \\\"宁夏\\\",\\n                json: ningXiaMap,\\n            },\\n            {\\n                name: \\\"青海\\\",\\n                json: qingHaiMap,\\n            },\\n            {\\n                name: \\\"西藏\\\",\\n                json: xiZangMap,\\n            },\\n            {\\n                name: \\\"黑龙江\\\",\\n                json: heiLongJiangMap,\\n            },\\n            {\\n                // name: \\\"内蒙古自治区\\\",\\n                name: \\\"内蒙古\\\",\\n                json: neimengGuMap,\\n            },\\n            {\\n                name: \\\"甘肃\\\",\\n                json: ganSuMap,\\n            },\\n            {\\n                name: \\\"新疆\\\",\\n                json: xinJiangMap,\\n            },\\n            {\\n                name: \\\"广西\\\",\\n                json: guangxiMap,\\n            },\\n            {\\n                name: \\\"上海\\\",\\n                json: shangHai,\\n            },\\n        ];\\n        //设置初始地图\\n        var mapname = this.chinaMap;\\n        var data = [];\\n        data = mapdata;\\n        // console.log(data)\\n        //自己设置的假数据方便大家查看数据格式\\n        // var data = [\\n        //     { _id: \\\"台湾\\\", value: 1, NDTZJH: 188, GSZE: \\\"3,330,156\\\", count: \\\"9,01,302\\\" },\\n        //     { _id: \\\"北京\\\", value: 2, NDTZJH: 488, GSZE: \\\"3,330,156\\\", count: \\\"9,01,302\\\" },\\n        //     { _id: \\\"天津\\\", value: 3, NDTZJH: 288, GSZE: \\\"3,330,156\\\", count: \\\"9,01,302\\\" },\\n        //     { _id: \\\"河北\\\", value: 4, NDTZJH: 388, GSZE: \\\"3,330,156\\\", count: \\\"9,01,302\\\" },\\n        //     { _id: \\\"山西\\\", value: 5, NDTZJH: 188, GSZE: \\\"3,330,156\\\", count: \\\"9,01,302\\\" },\\n        //     { _id: \\\"内蒙古\\\", value: 6, NDTZJH: 88, GSZE: \\\"3,330,156\\\", count: \\\"9,01,302\\\" },\\n        //     { _id: \\\"辽宁\\\", value: 7, NDTZJH: 488, GSZE: \\\"3,330,156\\\", count: \\\"9,01,302\\\" },\\n        //     { _id: \\\"吉林\\\", value: 8, NDTZJH: 588, GSZE: \\\"3,330,156\\\", count: \\\"9,01,302\\\" },\\n        //     { _id: \\\"黑龙江\\\", value: 9, NDTZJH: 688, GSZE: \\\"3,330,156\\\", count: \\\"9,01,302\\\" },\\n        //     { _id: \\\"上海\\\", value: 10, NDTZJH: 788, GSZE: \\\"3,330,156\\\", count: \\\"9,01,302\\\" },\\n        //     { _id: \\\"江苏\\\", value: 11, NDTZJH: 388, GSZE: \\\"3,330,156\\\", count: \\\"9,01,302\\\" },\\n        //     { _id: \\\"浙江\\\", value: 12, NDTZJH: 58, GSZE: \\\"3,330,156\\\", count: \\\"9,01,302\\\" },\\n        //     { _id: \\\"安徽\\\", value: 13, NDTZJH: 88, GSZE: \\\"3,330,156\\\", count: \\\"9,01,302\\\" },\\n        //     { _id: \\\"福建\\\", value: 14, NDTZJH: 88, GSZE: \\\"3,330,156\\\", count: \\\"9,01,302\\\" },\\n        //     { _id: \\\"江西\\\", value: 15, NDTZJH: 88, GSZE: \\\"3,330,156\\\", count: \\\"9,01,302\\\" },\\n        //     { _id: \\\"山东\\\", value: 16, NDTZJH: 88, GSZE: \\\"3,330,156\\\", count: \\\"9,01,302\\\" },\\n        //     { _id: \\\"河南\\\", value: 17, NDTZJH: 88, GSZE: \\\"3,330,156\\\", count: \\\"9,01,302\\\" },\\n        //     { _id: \\\"湖北\\\", value: 18, NDTZJH: 88, GSZE: \\\"3,330,156\\\", count: \\\"9,01,302\\\" },\\n        //     { _id: \\\"湖南\\\", value: 19, NDTZJH: 88, GSZE: \\\"3,330,156\\\", count: \\\"9,01,302\\\" },\\n        //     { _id: \\\"重庆\\\", value: 20, NDTZJH: 88, GSZE: \\\"3,330,156\\\", count: \\\"9,01,302\\\" },\\n        //     { _id: \\\"四川\\\", value: 21, NDTZJH: 88, GSZE: \\\"3,330,156\\\", count: \\\"9,01,302\\\" },\\n        //     { _id: \\\"贵州\\\", value: 22, NDTZJH: 88, GSZE: \\\"3,330,156\\\", count: \\\"9,01,302\\\" },\\n        //     { _id: \\\"云南\\\", value: 23, NDTZJH: 88, GSZE: \\\"3,330,156\\\", count: \\\"9,01,302\\\" },\\n        //     { _id: \\\"西藏\\\", value: 24, NDTZJH: 88, GSZE: \\\"3,330,156\\\", count: \\\"9,01,302\\\" },\\n        //     { _id: \\\"陕西\\\", value: 25, NDTZJH: 88, GSZE: \\\"3,330,156\\\", count: \\\"9,01,302\\\" },\\n        //     { _id: \\\"甘肃\\\", value: 26, NDTZJH: 88, GSZE: \\\"3,330,156\\\", count: \\\"9,01,302\\\" },\\n        //     { _id: \\\"青海\\\", value: 27, NDTZJH: 88, GSZE: \\\"3,330,156\\\", count: \\\"9,01,302\\\" },\\n        //     { _id: \\\"宁夏\\\", value: 28, NDTZJH: 118, GSZE: \\\"3,330,156\\\", count: \\\"9,01,302\\\" },\\n        //     { _id: \\\"新疆\\\", value: 29, NDTZJH: 88, GSZE: \\\"3,330,156\\\", count: \\\"9,01,302\\\" },\\n        //     { _id: \\\"广东\\\", value: 30, NDTZJH: 88, GSZE: \\\"3,330,156\\\", count: \\\"9,01,302\\\" },\\n        //     { _id: \\\"广西\\\", value: 31, NDTZJH: 88, GSZE: \\\"3,330,156\\\", count: \\\"9,01,302\\\" },\\n        //     { _id: \\\"海南\\\", value: 32, NDTZJH: 28, GSZE: \\\"3,330,156\\\", count: \\\"9,01,302\\\", },\\n        //     { _id: \\\"白城\\\", value: 132, NDTZJH: 128, GSZE: \\\"3,330,156\\\", count: \\\"9,01,302\\\" },\\n        // ];\\n        this.chinaMap.on('click', function (e) {\\n            var chooseName = mapJson.filter((item) => {//我们根据名字来判断是否选择一种\\n                if(item.name == e.name.substring(0,2) ){\\n                    return item.name == e.name.substring(0,2);\\n                }else if(item.name == e.name.substring(0,3)){\\n                    return item.name == e.name.substring(0,3);\\n                }\\n            });\\n            // console.log(chooseName)\\n            //这里的chooseName是一个数组，我们需要获取到json 有兴趣可以打印\\n            window.sessionStorage.setItem('mapnamedata',JSON.stringify(chooseName));\\n            window.parent.parent.location = \\\"../group_summarize/group_summarizesec.html\\\";\\n\\n        })\\n        window.onresize = this.chinaMap.resize //实现地图自适应\\n        var geoCoordMap = {\\n            '台湾省': [122, 23],\\n            '黑龙江省': [126.661669, 45.742347],\\n            '内蒙古省': [110.3467, 41.4899],\\n            \\\"吉林省\\\": [125.8154, 44.2584],\\n            '北京省': [116.4551, 40.2539],\\n            \\\"辽宁省\\\": [123.1238, 42.1216],\\n            \\\"河北省\\\": [114.4995, 38.1006],\\n            \\\"天津省\\\": [117.4219, 39.4189],\\n            \\\"山西省\\\": [112.3352, 37.9413],\\n            \\\"陕西省\\\": [109.1162, 34.2004],\\n            \\\"甘肃省\\\": [103.5901, 36.3043],\\n            \\\"宁夏省\\\": [106.3586, 38.1775],\\n            \\\"青海省\\\": [101.4038, 36.8207],\\n            \\\"新疆省\\\": [87.9236, 43.5883],\\n            \\\"西藏省\\\": [88.388277, 31.56375],\\n            \\\"四川省\\\": [103.9526, 30.7617],\\n            \\\"重庆省\\\": [108.384366, 30.439702],\\n            \\\"山东省\\\": [117.1582, 36.8701],\\n            \\\"河南省\\\": [113.4668, 34.6234],\\n            \\\"江苏省\\\": [118.8062, 31.9208],\\n            \\\"安徽省\\\": [117.29, 32.0581],\\n            \\\"湖北省\\\": [114.3896, 30.6628],\\n            \\\"浙江省\\\": [119.5313, 29.8773],\\n            \\\"福建省\\\": [119.4543, 25.9222],\\n            \\\"江西省\\\": [116.0046, 28.6633],\\n            \\\"湖南省\\\": [113.0823, 28.2568],\\n            \\\"贵州省\\\": [106.6992, 26.7682],\\n            \\\"云南省\\\": [102.9199, 25.4663],\\n            \\\"广东省\\\": [113.12244, 23.009505],\\n            \\\"广西省\\\": [108.479, 23.1152],\\n            \\\"海南省\\\": [110.3893, 19.8516],\\n            '上海省': [121.4648, 31.2891],\\n        };\\n        //给每个地区赋值\\n        var convertData = function (data) {\\n            //定义一个数组\\n            var res = [];\\n            //循环遍历每个区域值\\n            for (var i = 0; i < data.length; i++) {\\n                //获取坐标\\n                var geoCoord = geoCoordMap[data[i]._id];\\n                //判断是否有坐标\\n                if (geoCoord) {\\n                    //往数组里设置值\\n                    res.push({\\n                        name: data[i]._id,\\n                        value: geoCoord.concat(i + 1),\\n                        NDTZJH: data[i].NDTZJH || 0,//年度投资计划\\n                        GSZE: data[i].GSZE || 0,//概算总额\\n                        count: data[i].count || 0,//项目数量\\n                        LJZWC: data[i].LJZWC || 0,//累计投资完成\\n                        NDTZWC: data[i].NDTZWC || 0,// 年度投资完成\\n                    });\\n                }\\n            }\\n            return res;\\n        };\\n        this.chinaoption = {\\n            backgroundColor: 'transparent',\\n            geo: {\\n                    type: 'map',\\n                    map: 'china',\\n                    layoutCenter: ['50%', '50%'], //地图位置\\n                    layoutSize: '115%',\\n                    roam: false,\\n                    label: {\\n                        emphasis: {\\n                            show: false,\\n                            textStyle: {\\n                                color: '#fff',\\n                                align: 'center',\\n                            },\\n                        },\\n                    },\\n                    zoom: 1,\\n                    itemStyle: {\\n                        normal: {\\n                            shadowColor: '#0E4A92',\\n                            shadowOffsetX: -10,\\n                            shadowOffsetY: 10,\\n                            opacity: 1,\\n                        },\\n                        emphasis: {\\n                            show: true,\\n                            areaColor: '#90BFFC',\\n\\n                        },\\n                    },\\n                    animation: false,\\n            },\\n            tooltip: {\\n                trigger: 'item',\\n                show: true,\\n                backgroundColor: \\\"transparent\\\",\\n                formatter: function (params) {\\n                    if (params.data) {\\n                        var htmlStr = '';\\n                        htmlStr += '<div class=\\\"bgboder\\\">';\\n                        htmlStr += '<div id=\\\"city\\\">' + params.name + '</div><div id=\\\"trans\\\">aaaaa：' + params.data.NDTZJH + '<span>  万元</span>' + '</div><div id=\\\"trans\\\">bbbb：' + params.data.NDTZWC + '<span>  万元</span>' + '</div><div id=\\\"trans\\\">cccc：' + params.data.GSZE + '<span>  万元</span>' + '</div><div id=\\\"trans\\\">dddd：' + params.data.LJZWC + '<span>  个</span>' + '</div>';\\n                        htmlStr += '</div>';\\n                        return htmlStr;\\n                    }\\n                },\\n                textStyle: {\\n                    width: 300,\\n                    height: 300,\\n                }\\n            },\\n            visualMap: {\\n                type: 'piecewise',\\n                inRange: {\\n                    color: ['#02F6F9', '#02F6F9', '#02F6F9']\\n                },\\n                pieces: [\\n                    // { min: 0, max: 99, color: 'transparent' }, //把地图小点设置成透明颜色transparent\\n                    {  color: 'red' },\\n                    {\\n                        min: 100,\\n                        max: 10000,\\n                        color: {\\n                            type: 'radial',\\n                            x: 0.5,\\n                            y: 0.5,\\n                            r: 0.5,\\n                            colorStops: [\\n                                { offset: 0, color: 'rgba(11,28,92,0)' },\\n                                { offset: 0.8, color: 'rgba(10,94,137, 0.5)' },\\n                                { offset: 1, color: 'rgba(2, 246, 249, 1)' }\\n                            ],\\n                            globalCoord: false // 缺省为 false\\n                        }\\n                    }\\n                ],\\n                show: false,\\n                textStyle: {\\n                    color: '#ffffff',\\n                    fontSize: 16\\n                }\\n            },\\n            series: [\\n                {\\n                    type: 'map',\\n                    map: 'china',\\n                    layoutCenter: ['50%', '50%'], //地图位置\\n                    layoutSize: '115%',\\n                    roam: false,\\n                    label: {\\n                        normal: {\\n                            show: true, // 是否显示对应地名\\n                            textStyle: {\\n                                color: '#fff'\\n                            }\\n                        },\\n                        emphasis: { // 对应的鼠标悬浮效果\\n                            show: true,\\n                            textStyle: {\\n                                color: '#fff'\\n                            }\\n                        }\\n                    },\\n                    itemStyle: {\\n                        normal: {\\n                            borderColor: '#49A5E8',\\n                            borderWidth: 0.8,\\n                            areaColor: '#02439E',\\n                        },\\n                        emphasis: {//鼠标移入的高亮状态\\n                            show: true,\\n                            areaColor: '#01215c',//\\n                        },\\n                    },\\n                    animation: false,\\n                },\\n                {\\n                    type: 'scatter',\\n                    coordinateSystem: 'geo',\\n                    data: convertData(data),\\n                    //symbol:'triangle',\\n                    symbolSize: 5,\\n                },\\n\\n            ]\\n        }\\n        //加了一个点击后高亮显示效果片段代码，这里可以不用加，在有需求的时候可以加上\\n        // 全部取消高亮\\n        this.chinaMap.on('click', function (params) {\\n            this.chinaMap.dispatchAction({\\n                type: 'downplay',\\n                // dataIndex: params.dataIndex,\\n                seriesIndex: 0,\\n            });\\n        });\\n        // 设置高亮\\n        this.chinaMap.on('click', function (params) {\\n            this.chinaMap.dispatchAction({\\n                type: 'highlight',\\n                dataIndex: params.dataIndex,\\n                seriesIndex: 0,\\n            });\\n        });\\n        this.chinaMap.setOption(this.chinaoption);\\n        window.onresize = () => {\\n            this.chinaMap.resize()\\n        }\\n        window.addEventListener('resize', () => {\\n            this.chinaMap.resize()\\n        })\\n    },\\n\\n         \\n```\\n### 世界地图配置部分\\n```js\\n// 世界地图\\nworldConfigure() {\\n    this.worldMap = echarts.init(document.querySelector('.miniWorldMap'));\\n    this.worldoption = {\\n        series: [\\n            {\\n                name: 'World Population (2010)',\\n                type: 'map',\\n                mapType: 'world',\\n                clickable: false,\\n                // selectedMode:true,\\n                silent: true,\\n                // zoom:2,//地图放大1.2倍\\n                // roam: true,\\n                itemStyle: {\\n                    normal: {\\n                        areaColor: '#1044A9',\\n                        borderColor: 'none'\\n                    },\\n                    emphasis: {//对应的鼠标悬浮效果\\n                        show: true,\\n                        itemStyle: { areaColor: '#1044A9' }\\n                    }\\n\\n                },\\n                label: {\\n                    show: false,\\n                },\\n                emphasis: {\\n                    show: false\\n                },\\n                data: [\\n                    { name: 'Afghanistan', value: 28397.812 },\\n                    { name: 'Angola', value: 19549.124 },\\n                    { name: 'Albania', value: 3150.143 },\\n                    { name: 'United Arab Emirates', value: 8441.537 },\\n                    { name: 'Argentina', value: 40374.224 },\\n                    { name: 'Armenia', value: 2963.496 },\\n                    { name: 'French Southern and Antarctic Lands', value: 268.065 },\\n                    { name: 'Australia', value: 22404.488 },\\n                    { name: 'Austria', value: 8401.924 },\\n                    { name: 'Azerbaijan', value: 9094.718 },\\n                    { name: 'Burundi', value: 9232.753 },\\n                    { name: 'Belgium', value: 10941.288 },\\n                    { name: 'Benin', value: 9509.798 },\\n                    { name: 'Burkina Faso', value: 15540.284 },\\n                    { name: 'Bangladesh', value: 151125.475 },\\n                    { name: 'Bulgaria', value: 7389.175 },\\n                    { name: 'The Bahamas', value: 66402.316 },\\n                    { name: 'Bosnia and Herzegovina', value: 3845.929 },\\n                    { name: 'Belarus', value: 9491.07 },\\n                    { name: 'Belize', value: 308.595 },\\n                    { name: 'Bermuda', value: 64.951 },\\n                    { name: 'Bolivia', value: 716.939 },\\n                    { name: 'Brazil', value: 195210.154 },\\n                    { name: 'Brunei', value: 27.223 },\\n                    { name: 'Bhutan', value: 716.939 },\\n                    { name: 'Botswana', value: 1969.341 },\\n                    { name: 'Central African Republic', value: 4349.921 },\\n                    { name: 'Canada', value: 34126.24 },\\n                    { name: 'Switzerland', value: 7830.534 },\\n                    { name: 'Chile', value: 17150.76 },\\n                    { name: 'China', value: 1359821.465 },\\n                    { name: 'Ivory Coast', value: 60508.978 },\\n                    { name: 'Cameroon', value: 20624.343 },\\n                    { name: 'Democratic Republic of the Congo', value: 62191.161 },\\n                    { name: 'Republic of the Congo', value: 3573.024 },\\n                    { name: 'Colombia', value: 46444.798 },\\n                    { name: 'Costa Rica', value: 4669.685 },\\n                    { name: 'Cuba', value: 11281.768 },\\n                    { name: 'Northern Cyprus', value: 1.468 },\\n                    { name: 'Cyprus', value: 1103.685 },\\n                    { name: 'Czech Republic', value: 10553.701 },\\n                    { name: 'Germany', value: 83017.404 },\\n                    { name: 'Djibouti', value: 834.036 },\\n                    { name: 'Denmark', value: 5550.959 },\\n                    { name: 'Dominican Republic', value: 10016.797 },\\n                    { name: 'Algeria', value: 37062.82 },\\n                    { name: 'Ecuador', value: 15001.072 },\\n                    { name: 'Egypt', value: 78075.705 },\\n                    { name: 'Eritrea', value: 5741.159 },\\n                    { name: 'Spain', value: 46182.038 },\\n                    { name: 'Estonia', value: 1298.533 },\\n                    { name: 'Ethiopia', value: 87095.281 },\\n                    { name: 'Finland', value: 5367.693 },\\n                    { name: 'Fiji', value: 860.559 },\\n                    { name: 'Falkland Islands', value: 49.581 },\\n                    { name: 'France', value: 63230.866 },\\n                    { name: 'Gabon', value: 1556.222 },\\n                    { name: 'United Kingdom', value: 62066.35 },\\n                    { name: 'Georgia', value: 4388.674 },\\n                    { name: 'Ghana', value: 24262.901 },\\n                    { name: 'Guinea', value: 10876.033 },\\n                    { name: 'Gambia', value: 1680.64 },\\n                    { name: 'Guinea Bissau', value: 10876.033 },\\n                    { name: 'Equatorial Guinea', value: 696.167 },\\n                    { name: 'Greece', value: 11109.999 },\\n                    { name: 'Greenland', value: 56.546 },\\n                    { name: 'Guatemala', value: 14341.576 },\\n                    { name: 'French Guiana', value: 231.169 },\\n                    { name: 'Guyana', value: 786.126 },\\n                    { name: 'Honduras', value: 7621.204 },\\n                    { name: 'Croatia', value: 4338.027 },\\n                    { name: 'Haiti', value: 9896.4 },\\n                    { name: 'Hungary', value: 10014.633 },\\n                    { name: 'Indonesia', value: 240676.485 },\\n                    { name: 'India', value: 1205624.648 },\\n                    { name: 'Ireland', value: 4467.561 },\\n                    { name: 'Iran', value: 240676.485 },\\n                    { name: 'Iraq', value: 30962.38 },\\n                    { name: 'Iceland', value: 318.042 },\\n                    { name: 'Israel', value: 7420.368 },\\n                    { name: 'Italy', value: 60508.978 },\\n                    { name: 'Jamaica', value: 2741.485 },\\n                    { name: 'Jordan', value: 6454.554 },\\n                    { name: 'Japan', value: 127352.833 },\\n                    { name: 'Kazakhstan', value: 15921.127 },\\n                    { name: 'Kenya', value: 40909.194 },\\n                    { name: 'Kyrgyzstan', value: 5334.223 },\\n                    { name: 'Cambodia', value: 14364.931 },\\n                    { name: 'South Korea', value: 51452.352 },\\n                    { name: 'Kosovo', value: 97.743 },\\n                    { name: 'Kuwait', value: 2991.58 },\\n                    { name: 'Laos', value: 6395.713 },\\n                    { name: 'Lebanon', value: 4341.092 },\\n                    { name: 'Liberia', value: 3957.99 },\\n                    { name: 'Libya', value: 6040.612 },\\n                    { name: 'Sri Lanka', value: 20758.779 },\\n                    { name: 'Lesotho', value: 2008.921 },\\n                    { name: 'Lithuania', value: 3068.457 },\\n                    { name: 'Luxembourg', value: 507.885 },\\n                    { name: 'Latvia', value: 2090.519 },\\n                    { name: 'Morocco', value: 31642.36 },\\n                    { name: 'Moldova', value: 103.619 },\\n                    { name: 'Madagascar', value: 21079.532 },\\n                    { name: 'Mexico', value: 117886.404 },\\n                    { name: 'Macedonia', value: 507.885 },\\n                    { name: 'Mali', value: 13985.961 },\\n                    { name: 'Myanmar', value: 51931.231 },\\n                    { name: 'Montenegro', value: 620.078 },\\n                    { name: 'Mongolia', value: 2712.738 },\\n                    { name: 'Mozambique', value: 23967.265 },\\n                    { name: 'Mauritania', value: 3609.42 },\\n                    { name: 'Malawi', value: 15013.694 },\\n                    { name: 'Malaysia', value: 28275.835 },\\n                    { name: 'Namibia', value: 2178.967 },\\n                    { name: 'New Caledonia', value: 246.379 },\\n                    { name: 'Niger', value: 15893.746 },\\n                    { name: 'Nigeria', value: 159707.78 },\\n                    { name: 'Nicaragua', value: 5822.209 },\\n                    { name: 'Netherlands', value: 16615.243 },\\n                    { name: 'Norway', value: 4891.251 },\\n                    { name: 'Nepal', value: 26846.016 },\\n                    { name: 'New Zealand', value: 4368.136 },\\n                    { name: 'Oman', value: 2802.768 },\\n                    { name: 'Pakistan', value: 173149.306 },\\n                    { name: 'Panama', value: 3678.128 },\\n                    { name: 'Peru', value: 29262.83 },\\n                    { name: 'Philippines', value: 93444.322 },\\n                    { name: 'Papua New Guinea', value: 6858.945 },\\n                    { name: 'Poland', value: 38198.754 },\\n                    { name: 'Puerto Rico', value: 3709.671 },\\n                    { name: 'North Korea', value: 1.468 },\\n                    { name: 'Portugal', value: 10589.792 },\\n                    { name: 'Paraguay', value: 6459.721 },\\n                    { name: 'Qatar', value: 1749.713 },\\n                    { name: 'Romania', value: 21861.476 },\\n                    { name: 'Russia', value: 21861.476 },\\n                    { name: 'Rwanda', value: 10836.732 },\\n                    { name: 'Western Sahara', value: 514.648 },\\n                    { name: 'Saudi Arabia', value: 27258.387 },\\n                    { name: 'Sudan', value: 35652.002 },\\n                    { name: 'South Sudan', value: 9940.929 },\\n                    { name: 'Senegal', value: 12950.564 },\\n                    { name: 'Solomon Islands', value: 526.447 },\\n                    { name: 'Sierra Leone', value: 5751.976 },\\n                    { name: 'El Salvador', value: 6218.195 },\\n                    { name: 'Somaliland', value: 9636.173 },\\n                    { name: 'Somalia', value: 9636.173 },\\n                    { name: 'Republic of Serbia', value: 3573.024 },\\n                    { name: 'Suriname', value: 524.96 },\\n                    { name: 'Slovakia', value: 5433.437 },\\n                    { name: 'Slovenia', value: 2054.232 },\\n                    { name: 'Sweden', value: 9382.297 },\\n                    { name: 'Swaziland', value: 1193.148 },\\n                    { name: 'Syria', value: 7830.534 },\\n                    { name: 'Chad', value: 11720.781 },\\n                    { name: 'Togo', value: 6306.014 },\\n                    { name: 'Thailand', value: 66402.316 },\\n                    { name: 'Tajikistan', value: 7627.326 },\\n                    { name: 'Turkmenistan', value: 5041.995 },\\n                    { name: 'East Timor', value: 10016.797 },\\n                    { name: 'Trinidad and Tobago', value: 1328.095 },\\n                    { name: 'Tunisia', value: 10631.83 },\\n                    { name: 'Turkey', value: 72137.546 },\\n                    { name: 'United Republic of Tanzania', value: 44973.33 },\\n                    { name: 'Uganda', value: 33987.213 },\\n                    { name: 'Ukraine', value: 46050.22 },\\n                    { name: 'Uruguay', value: 3371.982 },\\n                    { name: 'United States of America', value: 312247.116 },\\n                    { name: 'Uzbekistan', value: 27769.27 },\\n                    { name: 'Venezuela', value: 236.299 },\\n                    { name: 'Vietnam', value: 89047.397 },\\n                    { name: 'Vanuatu', value: 236.299 },\\n                    { name: 'West Bank', value: 13.565 },\\n                    { name: 'Yemen', value: 22763.008 },\\n                    { name: 'South Africa', value: 51452.352 },\\n                    { name: 'Zambia', value: 13216.985 },\\n                    { name: 'Zimbabwe', value: 13076.978 }\\n                ]\\n            }\\n        ]\\n    };\\n    this.worldMap.setOption(this.worldoption);\\n    window.onresize = () => {\\n        this.worldMap.resize()\\n    }\\n    window.addEventListener('resize', () => {\\n        this.worldMap.resize()\\n    })\\n    this.chgMap();\\n},\\n\\n```\\n### 切换地图函数配置\\n`注：切换的时候哪些属性想展示不展示可以自己去设置，我这里只设置了一些我想需要的`\\n```js\\n// 切换地图\\nchgMap() {\\n    var worldBox = document.querySelector(\\\".miniWorldMap\\\");\\n    var flag = true;\\n    var mid = this.chinaoption;\\n    var _this = this;\\n    worldBox.onclick = function () {\\n        if (flag) {\\n            _this.chinaMap.clear();//清空图表\\n            _this.chinaMap.setOption(_this.worldoption);//把中国地图切换为世界地图\\n            _this.worldMap.clear();//清空图表\\n            //把中国地图上的文字隐藏\\n            _this.chinaoption.series[0].label.normal.show = false;\\n            _this.chinaoption.series[0].itemStyle.emphasis.show = false;\\n            _this.chinaoption.series[0].label.emphasis.show = false;\\n            _this.chinaoption.tooltip.show = false;//隐藏提示悬浮框\\n            _this.chinaoption.series[0].itemStyle.emphasis.areaColor = '#01215c';\\n            _this.worldMap.setOption(_this.chinaoption);//把世界地图切换为中国地图\\n            _this.worldMap.off('click');\\n            flag = false;\\n        } else {\\n            _this.chinaMap.clear();\\n            _this.chinaoption.series[0].label.normal.show = true;//把中国地图上的文字重新展示\\n            _this.chinaoption.series[0].itemStyle.emphasis.show = true;\\n            _this.chinaoption.tooltip.show = true;//隐藏提示悬浮框\\n            _this.chinaoption.series[0].itemStyle.emphasis.areaColor = '#01215c';\\n            _this.chinaMap.setOption(_this.chinaoption);//把中国地图切换为中国地图\\n            _this.worldMap.clear();//清空图表\\n            _this.worldMap.setOption(_this.worldoption);//把世界地图切换为世界地图\\n            _this.worldMap.off('click');\\n            flag = true;\\n        }\\n    }\\n},\\n\\n```\\n\\n还有中国地图下钻二级页面这里不写了，可以直接去这篇文章里看二级页面部分https://juejin.cn/post/7085536087078076430#heading-0\\n\\n最后感谢大家阅读，如果喜欢可以点赞或留言💕~~~~，谢谢大家⭐️⭐️⭐️~~~\\n\\n### 近期热门文章\\n\\n-   [lucky-canvas 抽奖](https://juejin.cn/post/7104094465048084511 \\\"https://juejin.cn/post/7104094465048084511\\\")\\n-   [宏任务和微任务的理解](https://juejin.cn/post/7103679289245040653 \\\"https://juejin.cn/post/7103679289245040653\\\")\\n-   [Js数组去重的多种方法](https://juejin.cn/post/7103362671730229284 \\\"https://juejin.cn/post/7103362671730229284\\\")\\n-   [Echarts 特殊环形图展示](https://juejin.cn/post/7102257686984523789 \\\"https://juejin.cn/post/7102257686984523789\\\")\\n-   [Echarts堆叠柱状图百分比显示，tooltip展示百分比和数量](https://juejin.cn/post/7105940204628017182 \\\"https://juejin.cn/post/7105940204628017182\\\")\\n-   [Echarts 横向堆叠柱状图 + markLine](https://juejin.cn/post/7104465447721893924 \\\"https://juejin.cn/post/7104465447721893924\\\")\\n-   [vue使用echarts 实现世界地图、中国地图、以及下钻地图绘制](https://juejin.cn/post/7085536087078076430 \\\"https://juejin.cn/post/7085536087078076430\\\")\\n-   [JavaScript 的几种循环方式](https://juejin.cn/post/7087506699057135653 \\\"https://juejin.cn/post/7087506699057135653\\\")\\n-   [Js 数据类型转换的几种方式](https://juejin.cn/post/7081824331709284359 \\\"https://juejin.cn/post/7081824331709284359\\\")\\n-   [手写【横柱带斜三角】进度条实现](https://juejin.cn/post/7081465823574884382 \\\"https://juejin.cn/post/7081465823574884382\\\")\\n\\n## 专栏推荐\\n\\n推荐一下自己的专栏，欢迎大家收藏关注😊~\\n\\n-   [面试集](https://juejin.cn/column/6997234823186087973 \\\"https://juejin.cn/column/6997234823186087973\\\")\\n-   [原生js集](https://juejin.cn/column/6997235219774308360 \\\"https://juejin.cn/column/6997235219774308360\\\")\\n-   [vue集](https://juejin.cn/column/6997235875461480478 \\\"https://juejin.cn/column/6997235875461480478\\\")\\n-   [可视化集](https://juejin.cn/column/6997236383643336717 \\\"https://juejin.cn/column/6997236383643336717\\\")\\n-   [css集](https://juejin.cn/column/6997235770020855816 \\\"https://juejin.cn/column/6997235770020855816\\\")\\n",
        "tags": [
            "掘金·金石计划",
            "前端",
            "数据可视化"
        ]
    },
    {
        "article_id": "7156996091945173022",
        "cover_image": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f1115d9d64540568ffe9ea85a7df656~tplv-k3u1fbpfcp-watermark.image?",
        "title": "JavaScript基础笔记整理(六)",
        "brief": "了解构造函数原型对象的语法特征，掌握 JavaScript 中面向对象编程的实现方式，基于面向对象编程思想实现 DOM 操作的封装",
        "user_name": "点点VS叉叉",
        "view_count": 3460,
        "collect_count": 60,
        "comment_count": 5,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/4b582ed92f03f5ebb3f62bf70079243c~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: healer-readable\\n---\\n\\n\\n持续创作，加速成长！这是我参与「掘金日新计划 · 10 月更文挑战」的第24天，[点击查看活动详情](https://juejin.cn/post/7147654075599978532 \\\"https://juejin.cn/post/7147654075599978532\\\")\\n\\n## JavaScript 重点知识\\n\\n> 了解构造函数原型对象的语法特征，掌握 JavaScript 中面向对象编程的实现方式，基于面向对象编程思想实现 DOM 操作的封装。\\n\\n-   了解面向对象编程的一般特征\\n-   掌握基于构造函数原型对象的逻辑封装\\n-   掌握基于原型对象实现的继承\\n-   理解什么原型链及其作用\\n-   能够处理程序异常提升程序执行的健壮性\\n\\n### 一、面向对象\\n\\n> 学习 JavaScript 中基于原型的面向对象编程序的语法实现，理解面向对象编程的特征。\\n\\n面向对象编程是一种程序设计思想，它具有 3 个显著的特征：封装、继承、多态。\\n\\n#### 1.1 封装\\n\\n封装的本质是将具有关联的代码组合在一起，其优势是能够保证代码复用且易于维护，函数是最典型也是最基础的代码封装形式，面向对象思想中的封装仍以函数为基础，但提供了更高级的封装形式。\\n\\n##### 命名空间\\n\\n先来回顾一下以往代码封装的形式：\\n\\n```\\n<script>\\n  // 普通对象（命名空间）形式的封装\\n  let beats = {\\n    name: '狼',\\n    setName: function (name) {\\n      this.name = this.name;\\n    },\\n    getName() {\\n      console.log(this.name);\\n    }\\n  }\\n​\\n  beats.setName('熊');\\n  beats.getName();\\n</script>\\n```\\n\\n以往以普通对象（命名空间）形式封装的代码只是单纯把一系列的变量或函数组合到一起，所有的数据变量都被用来共享（使用 this 访问）。\\n\\n##### 构造函数\\n\\n对比以下通过面向对象的构造函数实现的封装：\\n\\n```\\n<script>\\n  function Person() {\\n    this.name = '佚名';\\n    // 设置名字\\n    this.setName = function (name) {\\n      this.name = name;\\n    }\\n    // 读取名字\\n    this.getName = () => {\\n      console.log(this.name);\\n    }\\n  }\\n​\\n  // 实例对像，获得了构造函数中封装的所有逻辑\\n  let p1 = new Person();\\n  p1.setName('小明');\\n  console.log(p1.name);\\n​\\n  // 实例对象\\n  let p2 = new Person();\\n  console.log(p2.name);\\n</script>\\n```\\n\\n同样的将变量和函数组合到了一起并能通过 this 实现数据的共享，所不同的是借助构造函数创建出来的实例对象之间是彼此不影响的。\\n\\n总结：\\n\\n0.  构造函数体现了面向对象的封装特性\\n0.  构造函数实例创建的对象彼此独立、互不影响\\n0.  命名空间式的封装无法保证数据的独立性\\n\\n注：可以举一些例子，如女娲造人等例子，加深对构造函数的理解。\\n\\n##### 原型对象\\n\\n实际上每一个构造函数都有一个名为 `prototype` 的属性，译成中文是原型的意思，`prototype` 的是对象类据类型，称为构造函数的原型对象，每个原型对象都具有 `constructor` 属性代表了该原型对象对应的构造函数。\\n\\n```\\n<script>\\n  function Person() {\\n    \\n  }\\n​\\n  // 每个函数都有 prototype 属性\\n  console.log(Person.prototype);\\n</script>\\n```\\n\\n了解了 JavaScript 中构造函数与原型对象的关系后，再来看原型对象具体的作用，如下代码所示：\\n\\n```\\n<script>\\n  function Person() {\\n    // 此处未定义任何方法\\n  }\\n​\\n  // 为构造函数的原型对象添加方法\\n  Person.prototype.sayHi = function () {\\n    console.log('Hi~');\\n  }\\n    \\n  // 实例化\\n  let p1 = new Person();\\n  p1.sayHi(); // 输出结果为 Hi~\\n</script>\\n```\\n\\n构造函数 `Person` 中未定义任何方法，这时实例对象调用了原型对象中的方法 `sayHi`，接下来改动一下代码：\\n\\n```\\n<script>\\n  function Person() {\\n    // 此处定义同名方法 sayHi\\n    this.sayHi = function () {\\n      console.log('嗨!');\\n    }\\n  }\\n​\\n  // 为构造函数的原型对象添加方法\\n  Person.prototype.sayHi = function () {\\n    console.log('Hi~');\\n  }\\n​\\n  let p1 = new Person();\\n  p1.sayHi(); // 输出结果为 嗨!\\n</script>\\n```\\n\\n构造函数 `Person` 中定义与原型对象中相同名称的方法，这时实例对象调用则是构造函中的方法 `sayHi`。\\n\\n通过以上两个简单示例不难发现 JavaScript 中对象的工作机制：**当访问对象的属性或方法时，先在当前实例对象是查找，然后再去原型对象查找，并且原型对象被所有实例共享。**\\n\\n```\\n<script>\\n    function Person() {\\n    // 此处定义同名方法 sayHi\\n    this.sayHi = function () {\\n      console.log('嗨!' + this.name);\\n    }\\n  }\\n​\\n  // 为构造函数的原型对象添加方法\\n  Person.prototype.sayHi = function () {\\n    console.log('Hi~' + this.name);\\n  }\\n  // 在构造函数的原型对象上添加属性\\n  Person.prototype.name = '小明';\\n​\\n  let p1 = new Person();\\n  p1.sayHi(); // 输出结果为 嗨!\\n  \\n  let p2 = new Person();\\n  p2.sayHi();\\n</script>\\n```\\n\\n总结：**结合构造函数原型的特征，实际开发重往往会将封装的功能函数添加到原型对象中。**\\n\\n#### 1.2 继承\\n\\n继承是面向对象编程的另一个特征，通过继承进一步提升代码封装的程度，JavaScript 中大多是借助原型对象实现继承的特性。\\n\\n龙生龙、凤生凤、老鼠的儿子会打洞描述的正是继承的含义，分别封装中国人和日本人的行为特征来理解编程中继承的含义，代码如下：\\n\\n```\\n<script>\\n  // 封装中国人的行为特征\\n  function Chinese() {\\n    // 中国人的特征\\n    this.arms = 2;\\n    this.legs = 2;\\n    this.eyes = 2;\\n​\\n    this.skin = 'yellow';\\n    this.language = '中文';\\n​\\n    // 中国人的行为\\n    this.walk = function () {}\\n    this.sing = function () {}\\n    this.sleep = function () {}\\n  }\\n​\\n  // 封装日本人的行为特征\\n  function Japanese() {\\n    // 日本人的特征\\n    this.arms = 2;\\n    this.legs = 2;\\n    this.eyes = 2;\\n​\\n    this.skin = 'yellow';\\n    this.language = '日文';\\n​\\n    // 日本人的行为\\n    this.walk = function () {}\\n    this.sing = function () {}\\n    this.sleep = function () {}\\n  }\\n</script>\\n```\\n\\n其实我们都知道无论是中国人、日本人还是其它民族，人们的大部分特征是一致的，然而体现在代码中时人的相同的行为特征被重复编写了多次，代码显得十分冗余，我们可以将重复的代码抽离出来：\\n\\n##### 原型继承\\n\\n基于构造函数原型对象实现面向对象的继承特性。\\n\\n```\\n<script>\\n  // 所有人\\n  function Person() {\\n    // 人的特征\\n    this.arms = 2;\\n    this.legs = 2;\\n    this.eyes = 2;\\n    \\n    // 人的行为\\n    this.walk = function () {}\\n    this.sing = function () {}\\n    this.sleep = function () {}\\n  }\\n  \\n  // 中国人\\n  function Chinese() {\\n    this.skin = 'yellow';\\n    this.language = '中文';\\n  }\\n  // 日本人\\n    function Japanese() {\\n    this.skin = 'yellow';\\n    this.language = '日文';\\n  }\\n</script>\\n```\\n\\n上述代码可以理解成将 `Chinese` 和 `Japanese` 共有的属性和方法提取出来了，也就是说 `Chinese` 和 `Japanese` 需要【共享】一些属性和方法，而原型对象的属性和方法恰好是可以被用来共享的，因此我们看如下代码：\\n\\n```\\n<script>\\n  // 中国人\\n  function Chinese() {\\n    this.skin = 'yellow';\\n    this.language = '中文';\\n  }\\n  // 日本人\\n    function Japanese() {\\n    this.skin = 'yellow';\\n    this.language = '日文';\\n  }\\n  \\n  // 人们【共有】的行为特征\\n  let people = {\\n    // 人的特征\\n    arms: 2,\\n    legs: 2,\\n    eyes:2,\\n    // 人的行为\\n    walk: function () {},\\n    sleep: function () {},\\n    sing: function () {}\\n  }\\n  \\n  // 为 prototype 重新赋值\\n  Chinese.prototype = people;\\n  Chinese.prototype.constructor = Chinese;\\n</script>\\n```\\n\\n如下图所示：\\n\\n创建对象 `people` 将公共的的属性和方法独立出来，然后赋值给构造函数的 `prototype` 这样无论有多少个民族都可以共享公共的属性和方法了：\\n\\n```\\n<script>\\n  // 人们【共有】的行为特征\\n  let people = {\\n    // 人的特征\\n    arms: 2,\\n    legs: 2,\\n    eyes:2,\\n    // 人的行为\\n    walk: function () {},\\n    sleep: function () {},\\n    sing: function () {}\\n  }\\n  \\n  // 中国人\\n  function Chinese() {\\n    this.skin = 'yellow';\\n    this.language = '中文';\\n  }\\n  // 日本人\\n    function Japanese() {\\n    this.skin = 'yellow';\\n    this.language = '日文';\\n  }\\n  \\n  function Englist() {\\n    this.skin = 'white';\\n    this.language= '英文';\\n  }\\n  \\n  // 中国人\\n  Chinese.prototype = people;\\n  Chinese.prototype.constructor = Chinese;\\n  \\n  let c1 = new Chinese();\\n    \\n  // 日本人\\n  Japanese.prototype = people;\\n  Janpanese.prototype.constructor = Japanese;\\n  // 英国人\\n  English.prototype = people;\\n  English.prototype.constructor = English;\\n  \\n  // ...\\n</script>\\n```\\n\\n继承是一种可以“不劳而获”的手段！！！上述代码中 `Chinese`、`Japanese`、`English` 都轻松的获得了 `people` 的公共的方法和属性，我们说 `Chinese`、`Japanese`、`English` 继承了 `people`。\\n\\n上述代码中是以命名空间的形式实现的继承，事实上 JavaScript 中继承更常见的是借助构造函数来实现：\\n\\n```\\n<script>\\n  // 所有人\\n  function Person() {\\n    // 人的特征\\n    this.arms = 2;\\n    this.legs = 2;\\n    this.eyes = 2;\\n​\\n    // 人的行为\\n    this.walk = function () {}\\n    this.sing = function () {}\\n    this.sleep = function () {}\\n  }\\n​\\n  // 封装中国人的行为特征\\n  function Chinese() {\\n    // 中国人的特征\\n    this.skin = 'yellow';\\n    this.language = '中文';\\n  }\\n​\\n  // 封装日本人的行为特征\\n  function Japanese() {\\n    // 日本人的特征\\n    this.skin = 'yellow';\\n    this.language = '日文';\\n  }\\n​\\n  // human 是构造函数 Person 的实例\\n  let human = new Person();\\n​\\n  // 中国人\\n  Chinese.prototype = human;\\n  Chinese.prototype.constructor = Chinese;\\n  // 日本人\\n  Japanese.prototype = human;\\n  Japanese.prototype.constructor = Japanese;\\n</script>\\n```\\n\\n如下图所示：\\n\\n##### 原型链\\n\\n基于原型对象的继承使得不同构造函数的原型对象关联在一起，并且这种关联的关系是一种链状的结构，我们将原型对象的链状结构关系称为原型链，\\n\\n```\\n<script>\\n  // Person 构造函数\\n  function Person() {\\n    this.arms = 2;\\n    this.walk = function () {}\\n  }\\n\\t\\n  // Person 原型对象\\n  Person.prototype.legs = 2;\\n  Person.prototype.eyes = 2;\\n  Person.prototype.sing = function () {}\\n  Person.prototype.sleep = function () {}\\n\\t\\n  // Chinese 构造函数\\n  function Chinese() {\\n    this.skin = 'yellow';\\n    this.language = '中文';\\n  }\\n\\t\\n  // Chinese 原型对象\\n  Chinese.prototype = new Person();\\n  Chinese.prototype.constructor = Chinese;\\n\\t\\n  // 实例化\\n  let c1 = new Chinese();\\n\\n  console.log(c1);\\n</script>\\n```\\n\\n在 JavaScript 对象中包括了一个非标准备的属性 `__proto__` 它指向了构造函数的原型对象，通过它可以清楚的查看原型对象的链状结构。\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e8881e0e0f34f3cb184bb290f4e6a53~tplv-k3u1fbpfcp-watermark.image?)\\n",
        "tags": [
            "掘金·日新计划",
            "前端",
            "JavaScript"
        ]
    },
    {
        "article_id": "7173575045304811556",
        "cover_image": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7fa0a820835c4a9a8197ebe3d3faabea~tplv-k3u1fbpfcp-watermark.image?",
        "title": "这么简单的 CSS 动效，快来瞧瞧",
        "brief": "本文正在参加「金石计划 . 瓜分6万现金大奖」 前言 这几天逛网站浏览网页的时候，看到一个不错的CSS效果，便想来实现一下。整个效果实现起来比较简单，但是并不缺少交互感，因此来分享一下这个CSS效果。",
        "user_name": "一条会coding的Shark",
        "view_count": 2725,
        "collect_count": 16,
        "comment_count": 5,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/4798dc1db39238560a22e2b3ef73010a~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: cyanosis\\n---\\n***本文正在参加[「金石计划 . 瓜分6万现金大奖」](https://juejin.cn/post/7162096952883019783 \\\"https://juejin.cn/post/7162096952883019783\\\")***\\n\\n## 前言\\n这几天逛网站浏览网页的时候，看到一个不错的`CSS`效果，便想来实现一下。整个效果实现起来比较简单，但是并不缺少交互感，因此来分享一下这个`CSS`效果。\\n\\n## 效果展示\\n\\n![light.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/37dd5f7524e545a9be8505dcb3f50521~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## HTML 搭建\\n`HTML`部分一如既往地简单，认清楚它的布局设计排版，剩下的就靠`div`一步步搭起来即可。\\n```\\n <div class=\\\"light\\\">\\n    <div class=\\\"wire\\\"></div>\\n    <div class=\\\"bulb\\\"></div>\\n    <div class=\\\"switch\\\">\\n      <div class=\\\"btn\\\"></div>\\n    </div>\\n  </div>\\n```\\n这一部分表示地很清楚，分为三个部分 —— **rope，bulb 以及 switch**。三个单词意思分别对应绳子、灯泡以及开关，从效果上看正好对应三个部分。\\n\\n## CSS 搭建\\n`CSS`部分才是精华了，从效果图我们能看出，灯泡要么用图片实现，要么用`CSS`写出来，如果图片来实现的话就很简单了，但是我们这里用的是`CSS`写出一个简易版灯泡的，而灯光切换的效果则是通过控制颜色的变化来实现，至于如何控制，当然是由`JS`来实现交互，后面会提到。现在我们来实现`CSS`效果吧。\\n\\n首先是对整体样式的设置，相关代码如下：\\n```\\n body{\\n    display: flex;\\n    justify-content: center;\\n    align-items: center;\\n    min-height: 100vh;\\n    background: #222;\\n  }\\n```\\n### 灯泡样式设计\\n然后开始用`CSS`实现灯泡效果了。先来实现灯泡吧。我们先做一个圆形，再往圆形上加入一个类似于灯泡盖的东西即可。具体可参考灯泡图片。至于为什么会加入 **z-index** 属性，后面会有说明。\\n\\n```\\n  .bulb{\\n    position: relative;\\n    width: 80px;\\n    height: 80px;\\n    background: #444;\\n    border-radius: 50%;\\n    z-index: 10;\\n  }\\n  .bulb::before{\\n    content: '';\\n    position: absolute;\\n    top: -50px;\\n    left: 22.5px;\\n    width: 35px;\\n    height: 80px;\\n    background: #444;\\n    border-top: 30px solid #000;\\n    border-radius: 10px;\\n  }\\n```\\n效果如下：\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5c20470d0534e81a07aa17e7d301797~tplv-k3u1fbpfcp-watermark.image?)\\n\\n### 绳子设计\\n灯泡有了，然后该有个挂灯泡的绳子了，使用绝对定位让它到合适的位置即可。这里需要注意的是层级问题，这就是为什么前面要设置一个 **z-index** 属性了，如果不注意层级关系的话，会导致绳子出现在灯泡前面。相关代码如下：\\n```\\n  .rope{\\n    position: absolute;\\n    left: calc(50% - 2px);\\n    bottom: 50%;\\n    width: 4px;\\n    height: 60vh;\\n    background: #000;\\n  }\\n```\\n\\n### 开关按钮设计\\n最后就是开关 **switch** 的样式设计了。\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/defd4cb55b9640a198408aec0bcde3d2~tplv-k3u1fbpfcp-watermark.image?)\\n\\n整个效果里除了灯泡就是开关部分了。开关是直接影响到交互体验的，所以需要做得更逼真。\\n```\\n  .switch{\\n    position: absolute;\\n    bottom: 50px;\\n    right: 50px;\\n    width: 80px;\\n    height: 80px;\\n    background: linear-gradient(#eee,#eee,#eee);\\n    border: 3px solid #000;\\n    border-radius: 10px;\\n    display: flex;\\n    justify-content: center;\\n    align-items: center;\\n  }\\n```\\n整体来看还是很容易处理的，在开关里有个按钮，因此在 **switch** 样式中使用 **flex** 布局，为后续加入的按钮做好水平居中效果。\\n\\n完成 **switch** 的布局，按钮处理起来就很方便了。基本上和处理 **switch** 样式一个思路。这里加入了`cursor: pointer`，表示当鼠标移动到按钮是箭头会变成小手，让点击的过程更形象。\\n```\\n  .switch .btn{\\n    position: relative;\\n    width: 25px;\\n    height: 40px;\\n    background: linear-gradient(#777,#fff,#777);\\n    border-radius: 6px;\\n    border: 2px solid #000;\\n    cursor: pointer;\\n  }\\n```\\n\\n## JS 搭建\\n这里通过`JS`来实现简单交互，主要是控制灯光切换的效果。在按钮上加一个点击事件，这里应用到 **classList.toggle** 方法，这个方法可以给`DOM`元素添加类。\\n\\n简单点理解就是它可以切换类名，它是实现交互效果的关键方法。相关代码如下：\\n\\n```\\n<script>\\n    let btn = document.querySelector('.btn')\\n    let body = document.querySelector('body')\\n    btn.onclick = function(){\\n      body.classList.toggle('on')\\n    }\\n</script>\\n```\\n### 切换后的样式\\n按钮点击后给`body`加上`on`的类名，并在`CSS`中加入有关于`on`切换的样式，代码如下：\\n```\\n// 切换后的背景颜色\\nbody.on{\\n  background: radial-gradient(#555,#111);\\n}\\n```\\n为了有更逼真的效果，也给按钮部分设置了切换后的`CSS`样式，相关代码如下：\\n```\\n.on .switch .btn::before{\\n  top: 15%;\\n}\\n```\\n\\n![btn.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/853e6c32a8314bcba96d01f51446676c~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## 码上掘金\\n\\n[代码片段](https://code.juejin.cn/pen/7174962310971129912)\\n\\n## 总结\\n这是一个很简单的`CSS`效果，虽然`CSS`部分和`JS`部分都不难，很容易理解，但是最终做出来的效果却一点也不失交互性和体验感，整体而言是比较成功的，非常适合大家用它来玩玩`CSS`，并且可以基于它来增加一些不一样的东西，使得它更加逼真，以此来丰富这个效果。\\n\\n",
        "tags": [
            "CSS",
            "掘金·金石计划",
            "前端"
        ]
    },
    {
        "article_id": "7182279467245502525",
        "cover_image": "https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1651319dcb104c13a8a5474d60d528d7~tplv-k3u1fbpfcp-watermark.image?",
        "title": "马上2023年了，你为什么要关注Donut",
        "brief": "还剩下几天，跌宕起伏的2022年就要过去了。这一年疫情下的起起落落，习惯了居家办公隔离，习惯了日常核酸检测，习惯了到处扫码进门，而最近可能大部分同学又经历过🐑了的日子。 年关将近，也可能有一部分",
        "user_name": "ad6623",
        "view_count": 5682,
        "collect_count": 52,
        "comment_count": 26,
        "avatar": "https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/leancloud-assets/IvUZIv4sIOEAw41yNifidfrM9UlOXdf1Fmspj73i~tplv-t2oaga2asx-image.image",
        "category": "前端",
        "content": "## 前言\\n还剩下几天，跌宕起伏的2022年就要过去了。这一年疫情下的起起落落，习惯了居家办公隔离，习惯了日常核酸检测，习惯了到处扫码进门，而最近可能大部分同学又经历过🐑了的日子。\\n\\n年关将近，也可能有一部分同学也遇到了突如其来的“毕业”。这是一个困难的时刻，但是冬天总会过去，春天终究会到来。正如老话讲的，“留的青山在，不怕没柴烧”。我们能做的唯有不断提升自己。你就是你自己的“青山”。要努力学习新的技术来让自己的“青山”变得更加高大强壮。\\n\\n说到新东西，在这个新旧交替的时刻，来关注一下新鲜出炉的甜甜圈（Donut）吧。\\n\\n（本篇不会具体介绍如何安装配置开发环境，也不会搬运API流水账，这些东西大家直接去看文档就行了。）\\n\\n## 什么是 Donut\\n[Donut](https://dev.weixin.qq.com/)是腾讯最近悄悄推出的一个前端开发“平台”。注意是“平台”而不是“框架“。这两个词的差别足以看出Donut的野心不小。打开[Donut官方文档](https://dev.weixin.qq.com/docs/donut/)。其简介就是一句话：\\n\\n> Donut 平台覆盖开发、部署、产品体验分析全产品开发周期的各种需求。开发者可以专注于代码逻辑，其他的都交给我们。\\n\\n喏，你只管码代码，剩下的都不用管了。还有这种好事？那我们就顺着文档再看看Donut具体能干个啥。\\n\\n## Donut 特色能力\\n\\n### 多端框架\\n\\n> Donut 多端框架是支持使用小程序原生语法开发移动应用的框架，开发者可以一次编码，分别编译为小程序和 Android 以及 iOS 应用，实现多端开发；能帮助企业有效降低多端应开发的技术门槛和研发成本，以及提升开发效率和开发体验。 [了解更多](https://dev.weixin.qq.com/docs/framework/getting_started/quickstart.html)\\n\\n第一个能力就是多端框架。你看，这里出现框架了，果然框架只是Donut这个平台的一部分。从上面的介绍我们能看出这个多端框架可以把原来只能在微信中运行的小程序扩展到自家的Android和iOS应用，这不就是跨平台么。虽然市面上已经有一些跨平台解决方案了，专注于小程序容器的有mPaas, FinClip, uniSDK等。自成体系的如Flutter等。但这可是微信自家的小程序容器啊。微信啊，还要啥自行车？\\n\\n![1.79f2646f.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b94ba9cbe3d341f7a51a29a4dd6269f9~tplv-k3u1fbpfcp-watermark.image?)\\n\\n你可以把现有小程序直接转化为一个完整app，也可以在已有app里把小程序给嵌进去当个模块来用。本已臃肿的app就要变得更加臃肿了。\\n\\n### 身份管理\\n\\n> 当小程序通过多端框架构建成可运行的移动应用时，如APP、H5网页等，需要搭建新的用户注册、登录、管理体系。身份管理在多端场景中，提供便捷易用的SaaS组件，可快速完成搭建。 [了解更多](https://dev.weixin.qq.com/docs/auth/)\\n\\n提供一套身份管理体系，用户名/密码登录或者手机验证码登录可以直接用。还支持微信等第三方登录。这个东西有没有用就看自家产品的需求了。如果是想快速开发一个小的app的话，我觉得可以用一下，省去了很多注册登录相关的工作。\\n\\n### 安全网关\\n\\n>「安全网关」是小程序开发团队推出的面向APP、微信/企业微信小程序、公众号H5/web的安全接入网关，提供微信私有链路、流量治理、弱网加速等能力，全方位保障业务安全高效稳定运行。 [了解更多](https://dev.weixin.qq.com/docs/gateway/)\\n\\n网关也给你提供了。不用去考虑弱网加速，反爬虫反刷，反抓包。容灾备份啥的也都给你考虑到了，真是很贴心啊。但还是那句话，有没有用就看自家产品的需求了。已经自有成熟的app就可能用不到了。\\n\\n![DIwXQ1199C3yClLZ6osuzVI3FsSJ1NHIKLCtap_mf4qHXsFTDySp51BGFcpotjRF4fBd3-0gHY-YtgmNUa1-XQ.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1692c6638f55408aba69db66562af4c6~tplv-k3u1fbpfcp-watermark.image?)\\n\\n### 产品体验分析\\n\\n> 体验分析是面向小程序、网页等应用的用户体验分析工具。可以从用户视角对于应用中的交互行为进行数据采集并还原分析。 [了解更多](https://dev.weixin.qq.com/docs/analysis/)\\n\\n这个就是各种常规的用户体验分析工具了。支持会话回放，热力图，路径分析，漏斗分析等等，这可能是产品经理的最爱。对于程序员来讲最大的好处是零代码埋点。不用在各个平台的app里各种插埋点代码了。回放还可以还原用户操作流程。再也不能以无法复现作为理由啦。\\n\\n![ReyPuPN7ayInF2vOpGTCKG3GNEytniYy1DciYDid79NJJL2XOOd2CxqZCTXcErXMzhQJoLK6NfG10BhogeDxiA.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/48ee25ffc92441e595e1e4f0bccf57ba~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## 你为什么要关注Donut\\n介绍完Donut，那我们就来看看为啥要关注这个新平台。\\n\\n### 首先，新\\n就是因为这是个**新**平台。早点了解新的东西总会让我们快人一步。虽然市面上已经有了那些个跨平台解决方案，各有优缺点。但是并没有哪个方案已经占据了绝对优势，所以我们还需要继续探索了解新的方案。\\n\\n### 其次，Donut是微信的\\n也就是它背靠是微信生态。虽然各家都有小程序，也相互之间不是那么兼容，但不可否认，微信家的小程序优势是比较大的，为啥？因为微信生态的社交网络啊。不要小瞧社交网络，基于微信生态可是诞生了拼多多这样的大厂呢，羊了个羊也都玩过吧，可见其影响力是其他小程序平台无法比拟的。而Donut是微信亲儿子，兼容性必然是要比其他几家好的多。这样无论是从单一小程序扩展到独立app还是给已有app赋予小程序能力都可以快速无痛完成。\\n\\n### 第三，为了明年\\n年底了，马上过完节上班各位就要考虑明年的KPI怎么完成，OKR怎么设定目标了。如果你还在为此发愁的话，那就考虑下把Donut加入你的KPI/OKR吧。过完节先快人一步和自己的leader做下技术讨论，率先在团队内部做技术分享，你就是新年后团队内最靓的仔。\\n\\n### 第四，一些具体细节\\n\\n我们要了解下Donut多端框架里具体有啥需要关注的地方。\\n\\n既然要跨端，那各端不同特性的适配就是个问题了，为此，Donut框架引入了条件编译，目前支持wxml、wxs、js/ts、json，less/sass等。支持的目标平台有小程序，ios和android。你的代码有可能会变成以下这样：\\n\\n wxml\\n```  \\n  <!-- #if MP -->\\n  <view class=\\\"test-view\\\">wechat</view>\\n  <!-- #elif IOS -->\\n  <view class=\\\"test-view\\\">ios</view>\\n  <!-- #elif ANDROID -->\\n  <view class=\\\"test-view\\\">android</view>\\n  <!-- #endif -->\\n  ```\\n  wxss  \\n  ```\\n  .test-view{\\n  /* #if MP */\\n  color: red;\\n  /* #elif IOS */\\n  color: green;\\n  /* #elif ANDROID */\\n  color: yellow;\\n  /* #endif */\\n  }\\n  ```\\n  js\\n  ```\\n// #if MP\\nwx.showToast({\\n    title: \\\"wechat toast\\\"\\n})\\n// #elif IOS\\nwx.showToast({\\n    title: \\\"ios toast\\\"\\n})\\n// #elif ANDROID\\nwx.showToast({\\n    title: \\\"android toast\\\"\\n})\\n// #endif\\n```\\n\\n\\n\\n虽然谁也不想在好好的代码里面到处塞`#if`。但这也是没有办法的事，只能尽量控制了。\\n\\n如果你的通过Donut将小程序嵌入已有app的话，那显然希望嵌入的小程序和已有app可以通信。Donut框架SDK提供了这样的能力。\\n名称                                                                                                                                      | 功能说明        |\\n| --------------------------------------------------------------------------------------------------------------------------------------- | ----------- |\\n| [wx.miniapp.invokeMiniappNativeExtensio](https://dev.weixin.qq.com/docs/framework/dev/jsapi/miniapp/invokeMiniappNativeExtensio.html)   | 给客户端原生发送消息  |\\n| [wx.miniapp.onMiniappNativeExtensionMsg](https://dev.weixin.qq.com/docs/framework/dev/jsapi/miniapp/onMiniappNativeExtensionMsg.html)   | 监听客户端原生消息   |\\n| [wx.miniapp.offMiniappNativeExtensionMsg](https://dev.weixin.qq.com/docs/framework/dev/jsapi/miniapp/offMiniappNativeExtensionMsg.html) | 取消监听客户端原生消息 |\\n\\n可以从小程序给客户端发消息，也可以在小程序里监听从客户端发过来的消息。看起来还比较简陋，但至少可以把小程序和原生app在运行时连通起来了。这意味着在app状态下小程序可以突破其在微信中运行的限制。从而释放更多的能力空间。\\n\\n然后就是将app原有的微信opensdk能力也开放给内嵌小程序：\\n名称                                                                                                                            | 功能说明                                                                                                                    |\\n| ----------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------- |\\n| 微信登录                                                                                                                          | 官方提供 wx.login 和 wx.miniapp.login 两个api，详情可查看[微信登录](https://dev.weixin.qq.com/docs/framework/dev/jsapi/WeChatLogin.html) |\\n| [wx.miniapp.login](https://dev.weixin.qq.com/docs/framework/dev/jsapi/miniapp/login.html)                                     | 微信登录                                                                                                                    |\\n| [wx.miniapp.requestPayment](https://dev.weixin.qq.com/docs/framework/dev/jsapi/miniapp/requestPayment.html)                   | 微信支付                                                                                                                    |\\n| [wx.miniapp.launchMiniProgram](https://dev.weixin.qq.com/docs/framework/dev/jsapi/miniapp/launchMiniProgram.html)             | 跳转微信小程序                                                                                                                 |\\n| [wx.miniapp.shareTextMessage](https://dev.weixin.qq.com/docs/framework/dev/jsapi/miniapp/shareTextMessage.html)               | 分享文本到微信                                                                                                                 |\\n| [wx.miniapp.shareImageMessage](https://dev.weixin.qq.com/docs/framework/dev/jsapi/miniapp/shareImageMessage.html)             | 分享图片到微信                                                                                                                 |\\n| [wx.miniapp.shareMiniProgramMessage](https://dev.weixin.qq.com/docs/framework/dev/jsapi/miniapp/shareMiniProgramMessage.html) | 分享小程序到微信                                                                                                                |\\n| [wx.miniapp.shareWebPageMessage](https://dev.weixin.qq.com/docs/framework/dev/jsapi/miniapp/shareWebPageMessage.html)         | 分享网页到微信\\n\\n这里功能上并未超越微信opensdk，只不过现在可以从小程序内直接调用而免去了小程序到微信opensdk的转接工作量。只是不知道如果app使用的是第三方分享sdk的话将来估计的考虑一下怎么再把分享能力收起来。\\n\\n### 最后，一些期待\\n目前，Donut多端框架在构建app的时候会把小程序代码和资源打包，然后塞进apk或ipa里面，在app运行的时候读取的小程序代码和资源是来自本地的。换句话说，Donut官方不支持热更新。如果要支持热更新的话可能需要Android或iOS开发者去分析本地包然后自己想想办法了。所以期待官方后期如果能支持热更新那就起飞了。\\n\\n小程序嵌入app之后，目前大部分微信的开放能力是不支持的。例如，获取用户信息，微信运动，订阅消息等等都是不支持的，这个也只能期望后期会支持吧。毕竟微信的生态如果能更多开放出来的话，会有更大的优势。\\n\\n框架现在只支持微信小程序，androiod和ios平台。这个当然是期待后期官方支持更多平台了。\\n\\n## 总结\\n本文就微信新推出的Donut平台做了个简单介绍。虽然目前处于公测阶段，还比较早期，不适合现在就集成上线。不过从目前看到的能力来说，我认为Donut还是值得持续关注的。毕竟如果能够更加方便的利用微信生态，可能会为我们自己的产品带来较大的提升。大家如果有什么感想，欢迎在讨论区留言。\\n\\n<p align=center>（全文完）</p>",
        "tags": [
            "前端",
            "微信小程序",
            "JavaScript"
        ]
    },
    {
        "article_id": "7178666619135066170",
        "cover_image": "",
        "title": "前端亮点 or 提效？从开发一款 Node CLI 开始！",
        "brief": "还在为提效发愁吗？手把手带你完成 Node CLI 核心开发，深入使用 Node CLI 生态库，文末准备了 190+ 个Node工具包福利~",
        "user_name": "Calmer08",
        "view_count": 11944,
        "collect_count": 214,
        "comment_count": 10,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/be09c19bf323be41d840869d07b20abe~300x300.image",
        "category": "开发工具",
        "content": "---\\ntheme: juejin\\n---\\n\\n&nbsp;&nbsp;&nbsp;&nbsp;  工作中还在为如何提效，如何做出工作亮点发愁吗？细心发现痛点 + 开发一款 Node Cli 或许是你的选择，本文将手把手带你完成 Node CLI 核心开发，并且深入使用 Node CLI 生态库（含细节代码示例），文末准备了 190+ 个Node工具包福利~\\n\\n![Node CLI (1).png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8aa3632a57eb405496f364b4baf54eec~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n\\n\\n\\n## 一、什么是 CLI\\n\\nCLI 全称是 Command Line Interface，是一类通过命令行交互的终端工具。Web开发中，我们无时无刻都在使用CLI 辅助开发，提升操作效率，比如 git、npm、webpack、vite 等\\n\\n## 二、为什么需要 CLI\\n\\nCLI 可以帮助我们更高效的操作计算机系统，工作中，我们可以我们将有规律可循的、重复的、繁琐的、模板化的工作，集成到CLI工具中。一个命令，即可快速的完成一些列操作\\n\\n相比于 GUI 工具（用户图形界面）\\n\\n-   **GUI**：更侧重易用性，用户通过点击图形界面，完成相关\\n-   **CLI**：更侧重操作效率，通过命令组合自动化操作、批量操作等\\n\\n\\n## 三、Node CLI 开发核心步骤\\n\\n**前置说明**：略过 `npm init -y` 初始化项目等操作\\n\\n \\n\\n### 3.1、定义命令文件\\n\\n-   项目中定义 JS命令文件，文件头部必须有 `#!/usr/bin/env node`\\n\\n```\\n#!/usr/bin/env node\\n\\nconsole.log('Hello Node CLI');\\n```\\n\\n-   头部声明代码，是告诉系统使用 NodeJS 执行脚本；如不声明，默认按shell去解析执行\\n\\n```\\nwhich env ---> /usr/bin/env\\n```\\n\\n### 3.2、定义终端命令\\n\\n-   `package.json` 文件中，声明 `bin` 字段；格式为：`<command>: <JS file>`\\n\\n```\\n{\\n    \\\"bin\\\": {\\n        \\\"test-cli\\\": \\\"./bin/command.js\\\"\\n    }\\n}\\n```\\n\\n### 3.3、调试 CLI 工具\\n\\n-   Node CLI 或 依赖包，可通过软链接进行本地调试\\n-   创建软链接：在CLI根目录下执行 `npm link`，\\n-   调试 CLI：终端运行命令 `test-cli`，即可看到输出 `Hello Node CLI`\\n\\n\\n### 3.4、发布 CLI 工具\\n- 登录 npm：`npm login`\\n- 发布 CLI：`npm publish`\\n\\n\\n---\\n至此，你已经掌握了发布一款简单指令的 Node CLI，但这只是一个 DEMO，下面继续学习实操部分吧~\\n\\n\\n\\n## 四、Node CLI 最佳实践\\n\\n### 4.1、遵循 POSIX 参数\\n\\n**[POSIX](https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap12.html) 语法已被广泛接受为命令行工具的标准，我们开发命令行工具时，应该遵守它。** 常见规则举例如下：\\n\\n- 可以指令帮助或示例中将选项参数或选项标记为方括号（ `[]` ）表示它们是可选的；或带有尖括号（ `<>` ）表示它们是必需的。\\n-   允许使用短格式的单个字母参数作为长格式参数的别名（请参阅 [GNU 编码标准](https://www.gnu.org/prep/standards/html_node/Command_002dLine-Interfaces.html)）\\n-   使用缩写形式单数指定的选项 - 可以包含一个字母数字字符。\\n-   指定多个没有值的选项可以进行分组，例如 `myCli -abc` 等效于 `myCli -a -b -c`\\n\\n  \\n命令行高级用户希望您的命令行应用程序具有与其他 Unix 应用程序类似的约定\\n\\n### 4.2、遵循 [Semver](https://semver.org/) 版本\\n\\n**版本格式**  `X.Y.Z-[state]`\\n\\n-   `X` 代表 主版本号：功能新增、移除，API不向下兼容\\n-   `Y` 代表 次版本号：功能新增，API向下兼容\\n-   `Z` 代表 修订版本号：问题修复，API向下兼容\\n-   ` [state]  `状态解释如下\\n\\n| 描述方式  | 说明                | 含义                                                         |\\n| ----- | ----------------- | ---------------------------------------------------------- |\\n| alpha | alpha 版           | 内测版本：bug 较多                                                |\\n| beta  | beta 版            | 公测版本：存在bug，有缺陷                                             |\\n| gamma | Gamma 版           | 相当成熟的测试版：与发行版相差无几（一般略过此版本）                                 |\\n| rc    | Release Candidate | 发行倒计时版本：实现了全部功能，修复了大部分 bug，接近发布倒计时，有时会进一步细分为 `rc.1`、`rc.2` |\\n\\n\\n### 4.3、提供丰富且友好的交互\\n\\n-   提供丰富的交互，如 select 选择、filter 筛选、帮助提示等，让人操作更便捷\\n\\n![](https://raw.githubusercontent.com/enquirer/enquirer/master/media/survey-prompt.gif)\\n\\n-   提供富有色彩的体验，让人心旷身体\\n\\n    ![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/625e3fefb6eb4b9a99a1d0f81a64f12f~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n-   提供多样的 loading，让人减少等待烦恼\\n\\n## 五、Node CLI 生态库（详细用法）\\n### 5.1、注册解析命令 [commander](https://github.com/tj/commander.js)\\n\\n**描述**：commander 提供了完整的 Node 命令行解决方案，可以更便捷的进行命令注册及解析\\n\\n**demo 版本**：9.4.1\\n\\n**demo 01**：注册主命令 及 相关选项\\n\\n```\\n#!/usr/bin/env node\\nconst { Command } = require('commander')\\nconst pkginfo = require('pkginfo')\\nconst program = new Command()\\n\\nprogram.version(pkginfo.version, '-v, --version', '@calmer/terminal-cli 当前版本')\\n\\n// ⭐ 注册主命令相关选项\\nprogram\\n  // .description('命令描述') // 命令描述\\n  .option('-d, --dir <dirname>', '带参选项描述', '选项默认值') // 带参选项（选项全称 取值时转成驼峰写法），支持设置默认值\\n  .option('-c, --copy', '布尔选项描述') // 布尔选项（区别于 选项全称后有没有 <xxx>），指令中-c，选项copy属性值为true\\n  .option('-rm, --remove <dirname...>', '带参选项描述') // 数组参数必填，指令中多个参数空格分割，不支持设置默认值\\n  .option('-i, --ip [dirname...]', '带参选项描述') // 数组参数，非必填(不填值为true)，指令中多个参数空格分割，不支持设置默认值\\n  .action(async (options: object) => {\\n    console.log('action', options) // option.dir   option.copy\\n  })\\n\\n// 解析用户执行命令传入的参数\\nprogram.parse(process.argv)\\n\\n/*\\n    命令行输入option方式\\n    \\n    serve -d 80\\n    serve -d80\\n    serve --dir 80\\n    serve --dir=80\\n*/\\n// 扩展：如下获取选项对象\\nprogram.opts(); \\n```\\n\\n**demo 02：注册子命令、参数、选项**\\n\\n```\\nprogram\\n  .command('gen')\\n  .description('子命令描述') // 命令描述\\n  .option('-e, --ele <ddd>', '布尔选项描述') // 选项不能和主命令选项重名，否则为空\\n  .argument('<argument1Name>', '参数1描述') // 参数，必填\\n  .argument('<argument2Name>', '参数2描述') // 参数，必填\\n  /*\\n        argument 与 option 共存时：参数1为argument，参数2为option；否则参数1是argument或option\\n        添加多个argument时，依次为action的参数1、参数2、参数3\\n    */\\n  .action(async (argument1Name: string, argument2Name: string, options: object) => {\\n    console.log('action', argument1Name, argument2Name, options)\\n  })\\n```\\n\\n**demo 03：命令钩子**（主命令、子命令）\\n\\n```\\nprogram\\n  .option('-t, --trace', 'display trace statements for commands')\\n  /*\\n        钩子\\n            preAction   action函数执行前（主+子命令）（thisCommand, actionCommand）\\n            postAction  action函数执行后（主+子命令）（thisCommand, actionCommand）\\n            preSubcommand   action命令解析前（子命令）（thisCommand, subcommand）\\n        参数\\n            thisCommand主命令，subCommand子命令、actionCommand 触发action的命令，对象API如下\\n                name()  命令名\\n                opts()  选项对象\\n                args    参数、选项的集合，按指令写入顺序以数组方式输出\\n    */\\n  .hook(\\n    'preSubcommand',\\n    (\\n      thisCommand: { opts: Function; name: Function },\\n      actionCommand: { name: Function; opts: Function; args: string[] }\\n    ) => {\\n      // 找选项\\n      console.log('thisCommand', thisCommand.name())\\n      console.log('actionCommand', actionCommand.name())\\n    }\\n  )\\n```\\n\\n**demo 04：自定义监听事件**（目前只确定 可以监听主命令 option）\\n\\n```\\nprogram.on('option:dir', function (optionValue: any) {\\n  console.log('option:dir', optionValue)\\n})\\n```\\n\\n### 5.2、交互式命令工具 [inquirer](https://github.com/SBoudrias/Inquirer.js)\\n\\n**介绍**：inquirer 是一个 命令行交互工具，提供多种表单选项，优化命令行交互\\n\\n**demo 版本**：8.2.5\\n\\n**demo 01：** 核心使用流程\\n-  `validate`、`filter` 函数：返回 true 代表校验通过，返回具体内容作为错误输出 中止程序\\n\\n```\\nimport inquirer from 'inquirer';\\n\\n\\n/*\\n        type \\t表单类型\\n  name\\t答案变量\\n  message\\t提示信息\\n  default\\t默认值\\n*/\\ninquirer.prompt({\\n  type: 'input' // 交互组件类型\\n  name: 'name' // 数据属性名称\\n  message: '用户名' // 交互提示\\n  default: '' // 默认值\\n  choices: '' // 当交互类型为`选择类型`时, 该属性配置可选项目\\n\\n  // 校验函数, 函数以当前回答为参数。 返回: true 通过 false 不通过,无提示 Error 不通过,显示错误信息\\n  validate(value){\\n    return !value.length ? new Error('项目名称不能为空') : true\\n  }\\n\\n  // 过滤器, 返回修改后的回答。优先级高于 `validte`\\n  filter(value){\\n     return /vue/.test(value) ? `${value}-demo` : value\\n  }\\n\\n  // 转换器, 返回转换后的值，只作为显示，不影响收集结果\\n  transformer(value){\\n     return /vue/.test(value) ? `${value}-demo` : value\\n  },\\n\\n  // 是否显示问题\\n  when(answers){\\n     return !!answers.company\\n  },\\n\\n  // message 前缀\\n  prefix: '',\\n\\n  // message 后缀\\n  suffix: '',\\n\\n  // 如果回答已存在, 是否依然提问\\n  askAnswered: false,\\n}).then((answers) => {\\n        // answers.project\\n}).catch((error) => {\\n  console.error('出错啦！', error);\\n});\\n\\n\\n// 使用方式二\\n(async () => {\\n  const { project } = await inquirer.prompt({\\n    type: 'input',\\n    name: 'project',\\n    message: '项目名称',\\n    default: 'copyLeft',\\n  });\\n\\n  console.log(project);\\n});\\n```\\n\\n**demo 02**：`when` 提示列表中，决定是否下一步\\n\\n```\\ninquirer.prompt([{\\n    type: \\\"confirm\\\",\\n    message: \\\"是否发送 Kim 通知？\\\",\\n    name: \\\"confirm\\\",\\n}, {\\n    type: \\\"checkbox\\\",\\n    message: \\\"选择更新类型（可多选）:\\\",\\n    name: \\\"updateTypes\\\",\\n    when: function (answers) { // 当confirm为true的时候才会提问当前问题\\n        return answers.confirm\\n    },\\n    choices: [\\n        \\\"feat（新功能）\\\",\\n        \\\"fix（修补bug）\\\",\\n        \\\"docs（更新文档）\\\",\\n        \\\"style（代码格式优化：不影响代码运行的变动，注意这里指的不是css style）\\\",\\n        \\\"refactor（重构：即不是新增功能，也不是修改bug的代码变动）\\\",\\n        \\\"chore（构建优化，工具优化等）\\\",\\n        \\\"test（增加测试用例，测试代码等）\\\",\\n        \\\"revert（回滚提交）\\\"\\n    ],\\n    validate: (answer) => {\\n        if (!answer.length) {\\n            return '请选择更新类型';\\n        }\\n\\n        return true;\\n    },\\n}]);\\n```\\n\\n**demo 03**：input 输入框\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a887fc30b6604871a631834e05715e6f~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n```\\ninquirer.prompt({\\n  type: 'input',\\n  name: 'name',\\n  message: '请输入',\\n  default: '默认输入的内容'\\n})\\n```\\n\\n**demo 04**：input 数值输入框\\n- 特征：输入非数值不生效\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/757c1a6d26cc47b982249eef7236c23c~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n```\\ninquirer.prompt({\\n  type: 'number',\\n  name: 'age',\\n  message: '请输入',\\n  default: 111\\n})\\n```\\n\\n\\n**demo 05**：password 密码输入框\\n\\n- 特征：输入的内容不在终端显示\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4fe01aaf289d43759069ecfb7fd280e1~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n```\\ninquirer.prompt({\\n  type: 'password',\\n  name: 'password',\\n  message: '请输入',\\n  default: '密码'\\n})\\n```\\n    \\n\\n**demo 06**：list 单选\\n\\n- 特征：单选列表，没有序号，没有关键字搜索\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42885f3e116c4b9a853cd86ec5dd4098~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n```\\ninquirer.prompt({\\n  type: 'list',\\n  name: 'listAnswer',\\n  message: '单选',\\n  choices: [\\n    { name: '1', value: 1 },\\n    { name: '2', value: 2 },\\n    { name: '3', value: 3 }\\n  ]\\n})\\n```\\n\\n\\n**demo 07**：rawlist 列表\\n\\n- 特征：可输入答案的列表，有序号，没有关键字搜索\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/25f5ba43d0764376b3fbb54afc5f4f28~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n```\\ninquirer.prompt({\\n  type: 'rawlist',\\n  name: 'rawlistAnswer',\\n  message: '列表',\\n  choices: [\\n    { name: '1', value: 1 },\\n    { name: '2', value: 2 },\\n    { name: '3', value: 3 }\\n  ]\\n})\\n```\\n\\n  \\n-   **demo 08**：checkbox 多选\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/141f0af099114a69babbdbfa11ded4e6~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n```\\ninquirer.prompt({\\n  type: 'checkbox',\\n  name: 'checkboxAnswer',\\n  message: '多选',\\n  choices: [\\n    { name: '1', value: 1 },\\n    { name: '2', value: 2 },\\n    { name: '3', value: 3 }\\n  ]\\n})\\n```\\n\\n**demo 09**：confirm 判断\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed77aae7719d40b1955bd8a3360a2f4c~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n```\\ninquirer.prompt({\\n  type: 'confirm',\\n  name: 'confirmAnswer',\\n  message: '判断',\\n})\\n```\\n\\n\\n**demo 10**：插件机制、autocomplete 需要单独引入\\n\\n-   特征：支持过滤可选项\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/12026773588640aeb8e9da5bc2b2b8ca~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n```\\nimport inquirer from 'inquirer';\\nimport inquirerPrompt from 'inquirer-autocomplete-prompt';\\n\\ninquirer.registerPrompt('autocomplete', inquirerPrompt);\\n\\ninquirer.prompt({\\n  // @ts-ignore\\n  type: 'autocomplete',\\n  name: 'component',\\n  message: '请选择要开发的组件',\\n        source: (answersSoFar, input) => {\\n    return [1, 2].filter(val => val.includes(input))\\n  },\\n}).then((answers) => {\\n  console.log('inquirer-answers', answers);\\n})\\n```\\n\\n \\n**demo 11：** Separator 分割线\\n\\n- 特征：可选列表之间插入分割线\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d6bbc33fe2a249bb83c926ad854a9b6e~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n```\\ninquirer.prompt([\\n  {\\n    type: 'checkbox',\\n    name: '多选',\\n    message: 'checkbox',\\n    choices: [ \\\"Choice A\\\", new inquirer.Separator(), \\\"choice B\\\" ]\\n  }\\n])\\n```\\n\\n\\n### 5.3、命令行提示图标 [Ora](https://github.com/sindresorhus/ora)\\n\\n场景：命令行提示图标或小动画\\n\\n**demo 版本**：0.6.0\\n\\n\\n![Kapture 2022-12-18 at 21.04.57.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d44eb9da4554b0dbf619ce8c7d2752e~tplv-k3u1fbpfcp-watermark.image?)\\n\\n```\\nimport ora from 'ora';\\n\\nconst spinner = ora({\\n  text: \\\"链接网络中\\\"\\n}).start(); // 开始状态 => 加载状态\\n\\nsetTimeout(() => {\\n  spinner.color = \\\"yellow\\\";\\n  spinner.text = \\\"网速有点慢\\\";\\n}, 1000); // 还是 加载状态, 更新文案和颜色\\n\\nsetTimeout(() => {\\n  spinner.succeed(\\\"下载成功\\\"); // 加载状态 => 成功状态\\n}, 2000);\\n```\\n\\n```\\nimport ora from 'ora'\\n\\nconst spinerList = [ // 挑了几个更加图形化的模式\\n    'timeTravel',\\n    'speaker',\\n    'soccerHeader',\\n    'fistBump',\\n    'weather',\\n    'moon',\\n    'earth',\\n    'smiley'\\n]\\nlet index = 0\\n\\nconst spinner = ora({\\n    prefixText: 'spinnerName：‘timeTravel’',\\n    spinner: 'timeTravel'\\n}).start()\\n\\nsetInterval(function () {\\n    spinner.prefixText = `spinnerName: timeTravel`\\n    spinner.spinner = spinerList[index]\\n    index = ++index % spinerList.length;\\n}, 1500)\\n```\\n\\n**cli-spinners 是 ora 的核心库：** 如果场景不复杂，可以使用它。\\n\\n```\\nconst Spinner = require('cli-spinner').Spinner;\\nconst spinner = new Spinner('loading.. %s');\\nspinner.setSpinnerString('|/-\\\\');\\n\\nspinner.start()\\n\\nsetTimeout(() => {\\n    spinner.stop()\\n}, 3000);\\n```\\n\\n\\n### 5.4、命令行字符颜色 [chalk](https://github.com/chalk/chalk)\\n\\n- 场景：终端打印输出各种样式的字符（颜色、背景色、下划线等）\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa128efdfd73484f8d57049e54ff26d3~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n```\\nimport chalk from 'chalk';\\n\\nconsole.log(chalk.blue('Hello world!'));\\nconsole.log(chalk.blue.bgRed.bold('Hello world!'));\\n```\\n\\n  \\n\\n\\n### 5.5、命令行进度条 [progress](https://github.com/visionmedia/node-progress)\\n\\n场景：终端展示进度条\\n\\n```\\nvar ProgressBar = require('progress');\\n\\nvar bar = new ProgressBar(':bar', { total: 10 });\\nvar timer = setInterval(function () {\\n  bar.tick();\\n  if (bar.complete) {\\n    console.log('\\\\ncomplete\\\\n');\\n    clearInterval(timer);\\n  }\\n}, 100);\\n```\\n\\n  \\n\\n\\n### 5.6、命令行可视化组件 [blessed-contrib](https://github.com/yaronn/blessed-contrib)\\n\\n场景如下图\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5bc33c344db6491e817a8f78c9107475~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n  \\n\\n\\n### 5.7、终端持久化存储 configstore、conf\\n\\n场景：需要为 CLI 应用程序提供存储持久性，多次调用CLI命令时，记录用户之前选择，提升用户体验\\n\\n[configstore](https://www.npmjs.com/package/configstore) 库\\n\\n```\\nimport Configstore from 'configstore';\\n\\n\\nconst config = new Configstore('name', {foo: 'bar'});\\nconsole.log(config.get('foo'));\\n//=> 'bar'\\n\\nconfig.set('awesome', true);\\nconsole.log(config.get('awesome'));\\n//=> true\\n\\n// Use dot-notation to access nested properties.\\nconfig.set('bar.baz', true);\\nconsole.log(config.get('bar'));\\n//=> {baz: true}\\n\\nconfig.delete('awesome');\\nconsole.log(config.get('awesome'));\\n//=> undefined\\n```\\n\\n[conf](https://www.npmjs.com/package/conf) 库\\n\\n```\\nconst Conf = require('conf');\\n\\nconst config = new Conf();\\n\\nconfig.set('unicorn', '🦄');\\nconsole.log(config.get('unicorn'));\\n//=> '🦄'\\n\\n// Use dot-notation to access nested properties\\nconfig.set('foo.bar', true);\\nconsole.log(config.get('foo'));\\n//=> {bar: true}\\n\\nconfig.delete('unicorn');\\nconsole.log(config.get('unicorn'));\\n//=> undefined\\n```\\n\\n\\n### 5.8、JS 中执行 Shell 脚本\\n\\n#### 方案一：Node 子进程 child_process\\n\\n**Node 子进程** `require('child_process')` **有 7个函数 可以执行 shell 语句、文件：**\\n\\n**4个异步函数：** `spawn`、`fork`、`exec`、`execFile`\\n\\n**3个同步函数**：`spawnSync`、`execSync`、`execFileSync`\\n\\n`spawn`**是最基本的创建子进程函数，其他方法都是对此的封装**\\n\\n-   `spawn`：通过监听子进程对象的 `stdout`、`stderr`，实时接收 指令执行输出、异常\\n\\n```\\n#!/usr/bin/env node\\n\\nimport {\\n    spawn\\n} from 'child_process';\\n\\nconst child = spawn('npm', ['install']);\\n\\nchild.stdout.on('data', function (data) {\\n    console.log(data);\\n});\\n\\nchild.stderr.on('data', function (data) {\\n    console.log('Error:', data);\\n});\\n```\\n\\n-   `exec` 与 `spawn` 的差异点，如下\\n    -   指令描述简单：更接近 shell 指令，`spawn` 以数组参数描述，不方便编写\\n    -   `exec`方方多一个回调函数，可以统一输出 子进程执行指令的数据\\n    -   统一输出的子进程数据量限制：默认200kb，超出会报错中止程序，默认值可以调大，但总是有风险\\n\\n```\\n#!/usr/bin/env node\\n\\nimport {\\n    exec\\n} from 'child_process';\\n\\nconst child = exec('npm install', function (err, stdout, stderr) {\\n    if (err) throw err;\\n    console.log(stdout);\\n});\\n\\nchild.stdout.on('data', function (data) {\\n    console.log(data);\\n});\\n\\nchild.stderr.on('data', function (data) {\\n    console.log('Error:', data);\\n});\\n```\\n\\n-   `execFile` 与 `exec` 特性一致，用于执行脚本文件\\n-   `fork`：与 `spawn` 的差异点是，父子进程可以主动通信（EventEmitter 模块接口实现的）\\n\\n```\\n// parent.js\\nconst {fork} = require('child_process');\\nconst forked = fork('child.js');\\nforked.on('message', (msg) => {\\n    console.log('messsgae from child', msg);\\n});\\n\\nforked.send({hello: 'world'});\\n```\\n\\n```\\n// child.js\\nprocess.on('message', (msg) => {\\n    console.log('message from parent:', msg);\\n});\\nlet conter = 0;\\nsetInterval(() => {\\n    process.send({counter: counter++});\\n}, 1000);\\n```\\n\\n\\n#### 方案二：工具库 shell.js\\n\\n**shell.js 模块重新包装了 child_process，调用系统命令更加方便，对Node版本要求不高**\\n\\n```\\nconst shell = require('shelljs');\\n\\n// 判断是否有相关开发环境\\nfunction hasGitNpm() {\\n  if (!shell.which('git')) {\\n    console.log('Sorry, this script requires git');\\n    shell.exit(1);\\n  }\\n\\n  if (!shell.which('npm')) {\\n    console.log('Sorry, this script requires npm');\\n    shell.exit(1);\\n  }\\n}\\n\\nhasGitNpm();\\n\\n// 安装 npm 包\\nfunction installPkg(pkg, type) {\\n  const npm = shell.which('npm');\\n  if (!npm) {\\n    console.log('请先安装 npm');\\n    return;\\n  }\\n  const { code } = shell.exec(\\n    `${npm.stdout} install ${pkg} ${type || '--save'}`\\n  );\\n  if (code) {\\n    console.log(`安装 ${pkg} 失败，请手动安装`);\\n  }\\n}\\n```\\n\\n#### 方案三：工具库 [zx](https://github.com/google/zx)\\n\\n**zx 基于child_process，调用系统命令，更接近于写 shell 语句，对Node环境要求 >= 16.0.0**\\n\\n**特点：**\\n\\n-   语法更接近 shell 语句\\n-   支持 ts，自动编译.ts为.mjs文件，.mjs文件是ESM 文件，直接使用 `import`，不用工具转移\\n-   自带fetch库，可以进行网络请求\\n-   自带chalk库，可以打印有颜色的字体\\n-   自带错误处理nothrow方法，如果bash命令出错，可以包裹在这个方法里忽略错误\\n-   自带支持管道操作pipe方法\\n\\n**示例：**\\n\\n执行指令 `zx ./index.mjs` 运行如下脚本\\n\\n```\\n#!/usr/bin/env zx\\n\\nawait $`cat package.json | grep name`\\n\\nlet branch = await $`git branch --show-current`\\nawait $`dep deploy --branch=${branch}`\\n\\nawait Promise.all([\\n  $`sleep 1; echo 1`,\\n  $`sleep 2; echo 2`,\\n  $`sleep 3; echo 3`,\\n])\\n\\nlet name = 'foo bar'\\nawait $`mkdir /tmp/${name}`\\n```\\n\\n  \\n\\n\\n## 六、npm script 高频操作\\n\\n### 6.1、命令行传参\\n\\n**方式一：** Node 文件中获取命令行参数，借助 `cross-env`\\n- 传参\\n\\n```\\n{\\n    \\\"scripts\\\": {\\n        \\\"test\\\": \\\"cross-env NODE_ENV=production node ./src/index.js\\\"\\n    }\\n}\\n```\\n\\n-   获取：`./src/index.js` 文件中获取如下\\n\\n```\\nconsole.log(process.env.NODE_ENV)\\n```\\n\\n**方式二：** Shell 文件中获取命令行参数，借助 `cross-env-shell`\\n-  传参\\n\\n```\\n{\\n    \\\"scripts\\\": {\\n        \\\"test\\\": \\\"cross-env-shell GREETING=Hi sh ./src/index.sh\\\"\\n    }\\n}\\n```\\n\\n-   获取：`./src/index.sh` 文件中获取如下\\n\\n```\\necho $GREETING\\n```\\n\\n**方式三：** Node 文件中获取命令行参数，借助进程参数 `process.argv`\\n-   传参\\n\\n```\\n{\\n    \\\"scripts\\\": {\\n        \\\"test\\\": \\\"node ./src/index.js -build --show\\\"\\n     }\\n}\\n```\\n\\n-   获取：`./src/index.js` 文件中获取如下\\n\\n```\\n#!/usr/bin/env node\\nimport minimist from 'minimist';\\n\\n// 方式1\\nconsole.log('hello ', process.argv.splice(2)); // ['-build', '--show']\\n\\n// 方式2\\nconst isShow = require('minimist')(process.argv.slice(2)).show;\\n```\\n\\n\\n\\n### 6.2、自定义命令\\n\\n**定义命令：** 在 package.json 文件的 `scripts` 字段中声明，命令值为 Shell语法\\n\\n```\\n{\\n  \\\"scripts\\\": {\\n    \\\"dev\\\": \\\"npm run start\\\"\\n  }\\n}\\n```\\n\\n**执行命令**：项目根目录执行 `npm run xxx`\\n\\n**执行原理**：执行指令时，会自动创建一个临时 Shell 脚本，执行命令\\n\\n\\n| 符号 | 解释 |\\n| --- | --- |\\n| `*` | 表示任意脚本名，防止被转译，需要 `*`\\n| `**` | 表示任意层目录\\n| `&` | 连接命令，并行执行\\n| `&&` | 连接命令，串行执行\\n\\n```\\n{\\n    \\\"scripts\\\": {\\n        \\\"lint\\\": \\\"jshint **/*.js\\\",\\n        \\\"test\\\": \\\"tap test/*.js\\\",\\n        \\\"build1\\\": \\\" npm run script1.js & npm run script2.js\\\"\\n        \\\"build2\\\": \\\" npm run script1.js && npm run script2.js\\\"\\n    }\\n}\\n```\\n\\n### 6.3、自定义命令钩子\\n\\n-   npm 提供了 `pre` 和 `post` 两个钩子，分别代表**前置钩子、后置钩子**\\n-   自定义命令也可以添加 前置、后置钩子\\n\\n```\\n{\\n    \\\"scripts\\\": {\\n        \\\"lint\\\": \\\"jshint **/*.js\\\",\\n        \\\"test\\\": \\\"tap test/*.js\\\",\\n        \\\"build\\\": \\\" npm run script1.js & npm run script2.js\\\"\\n        \\\"prebuild\\\": \\\" npm run script1.js && npm run script2.js\\\"\\n    }\\n}\\n```\\n\\n-   执行 `npm run build` 时，相当于依次执行如下\\n\\n```\\nnpm run prebuild \\nnpm run build \\nnpm run postbuild\\n```\\n\\n\\n### 6.4、获取 script 命令名\\n\\n```\\nconst TARGET = process.env.npm_lifecycle_event;\\n\\nif (TARGET === 'test') {\\n  console.log(`正在执行 npm run test`);\\n}\\n```\\n\\n## 七、Node 工具库清单\\n\\n整理了一份尽量全的 Node工具库清单，希望日后能帮助到你在开发中提效哦~ 【彩蛋 ①】\\n\\n分5类（**命令行交互、文件处理、数据处理、邮件处理、网络部署**）展示 190+ Node 工具库！\\n\\n\\n### 7.1、命令行交互\\n| 库 | 场景 |\\n| --- | --- |\\n| Commander.js |\\t完整的 node.js 命令行解决方案 | \\n| Inquirer.js\\t| 一组通用的交互式命令行用户界面 | \\n| [cross-spawn](https://github.com/moxystudio/node-cross-spawn) | 兼容 node 子进程 spawn 跨平台|\\n| [semver](https://github.com/npm/node-semver) | 根据 Semver 语义规范，对比 获取版本号|\\n| [pkginfo](https://github.com/indexzero/node-pkginfo) | 获取 package.json 内容 |\\n| [yargs](https://github.com/yargs/yargs) | 更简易的处理命令行参数小工具，比 commander.js 优秀的是参数不全会自动给出提示|\\n| [ora](https://github.com/sindresorhus/ora) | 在命令行显示 loading 等动画|\\n| [minimist](https://github.com/substack/minimist) | 简单的参数处理包，对process.argv.slice(2) 数组进行 key-value 处理\\n| [figlet](https://github.com/patorjk/figlet.js) | 输出终端图案 [FIGlet 初识](https://aotu.io/notes/2016/11/22/figlet/index.html)|\\n| [TheaterJS](https://github.com/Zhouzi/TheaterJS) | 模拟人打字效果的 JS 库|\\n| [screenfull.js](https://github.com/sindresorhus/screenfull.js) | 全屏滚动插件|\\n| [image-compress-without-backend](https://github.com/zerosoul/image-compress-without-backend/blob/master/demo.pc.png) | 浏览器端图片压缩工具 无后端|\\n| [zooming](https://github.com/kingdido999/zooming) | 前端 zoom 放大、缩小镜功能|\\n| [html5tooltipsjs](https://github.com/ytiurin/html5tooltipsjs) | 鼠标移入后出现 tooltip 提示框|\\n| [ua-parser-js](https://github.com/faisalman/ua-parser-js) | 获取浏览器信息|\\n| [open](https://github.com/sindresorhus/open) | 自动打开浏览器页面 |\\n| [Alertify.js](http://alertifyjs.com/) | 开发漂亮的浏览器对话框和通知，可替代浏览器默认对话框|\\n| [browser-sync](https://github.com/BrowserSync/browser-sync) | 取代 LiveReload 为新型浏览器自动刷新插件，提高多浏览器开发效率|\\n| [node-inspector](https://github.com/node-inspector/node-inspector) | 在浏览器中调试 node [参考](https://github.com/node-inspector/node-inspector#quick-start)|\\n| envinfo | 生成故障排除软件问题(如操作系统、二进制版本、浏览器、已安装语言等)时所需的通用详细信息的报告 |\\n| bcat | 将命令管道输出到 Web 浏览器\\n| browser-run | 在浏览器环境中轻松运行代码 |\\n| log-symbols | 用不同颜色的符号记录不同级别的日志 |\\n| figures | 支援 Windows CMD 回退方案的 Unicode 符号 |\\n| boxen | 在终端中创建方框 |\\n| terminal-link | 在终端中创建可点击的链接 |\\n| terminal-image | 在终端里展示图片 |\\n| string-width | 获取字符串的可视宽度，显示字符串所需的列数 |\\n| cli-truncate | 在终端中将字符串截断为特定宽度 |\\n| first-run | 检查是否是第一次运行该进程 |\\n| blessed | 类似于 Curses 的库 |\\n| Inquirer.js | 交互式的命令行提示工具 |\\n| yn | 将包含 yes/no 语义的字符串解析为布尔值 |\\n| cli-table3 | 漂亮的 Unicode 表 |\\n| drawille | 使用 Unicode 盲文字符在终端上绘图 |\\n| update-notifier | 升级 CLI 应用程序的通知 |\\n| ascii-charts | 终端下的 ASCII 柱状图 |\\n| progress | 灵活的 ASCII 进度条 |\\n| insight | 使用 metrics 向 Google Analytics 发送匿名报告来帮助你理解你的工具是怎样被使用的 |\\n| cli-cursor | 显示或关闭 CLI 光标 |\\n| columnify | 将控制台文本打印按列输出，支持单元格修饰 |\\n| cli-columns | 列式输出 Unicode 和 Ansi-safe |\\n| cfonts | 控制台下的性感 ASCII 字体 |\\n| multispinner | 多样的、可同时独立控制的 CLI 旋转指示器 |\\n| omelette | Shell 下的自动补全 |\\n| cross-env | 跨平台的环境变量设置 |\\n| shelljs | 可移植的 Unix shell 命令 |\\n| sudo-block | 禁止用户用 root 权限使用你的程序 |\\n| loud-rejection | 强制对未加处理的 promise rejections 错误给出提示 |\\n| sparkly | 生成迷你图 `▁▂▃▅▂▇` |\\n| Bit | 在存储库中创建、维护、查找和使用小型模块和组件 |\\n| gradient-string | 为终端输出添加漂亮的色彩渐变 |\\n| oclif | CLI 框架，包括解析器、自动文档、测试和插件 |\\n| term-size | 准确地获得终端窗口大小 |\\n| Cliffy | CLI 的交互式框架 |\\n| np | 更好的 `npm publish` |\\n| npm-name | 检查包名在 npm 上是否可用 |\\n| gh-home | 打开当前目录下项目的 GitHub 主页 |\\n| npm-home | 打开一个包的 npm 主页 |\\n| emoj | 命令行下从文本中查找相关的 emoji |\\n| pageres | 获取网站的截图 |\\n| vtop | 有漂亮图表的更好用的 top |\\n| clipboard-cli | 在终端里复制粘贴 |\\n| dev-time | 获取 GitHub 用户当前的本地时间 |\\n| David | 当 npm 软件包中的依赖过时通知你 |\\n| normit | 在您的终端中使用语音合成功能进行 Google 翻译 |\\n| fkill | 跨平台的进程强杀命令 |\\n| pjs | 用 JavaScript 实现的快速过滤、映射和累加器的管道命令 |\\n| license-checker | 对你应用中的依赖进行许可证检查 |\\n| tmpin | 对所有允许文件输入的 CLI 程序添加 stdin 支持 |\\n| wallpaper | 更换桌面壁纸 |\\n| brightness | 更改屏幕亮度 |\\n| alex | 捕捉写作中出现的不当表达 |\\n| subdownloader | 电影和电视剧的字幕下载器 |\\n| dark-mode | 开关 macOS 暗黑模式 |\\n| Jsome | 使用自定义颜色和缩进打印漂亮的 JSON |\\n| itunes-remote | 交互式控制 iTunes |\\n| mobicon | 移动端应用图标生成器 |\\n| mobisplash | 移动端应用启动页生成器 |\\n| diff2html-cli | 生成漂亮的 HTML 展示 git diff 命令的结果 |\\n| Cash | 用纯 JavaScript 编写的跨平台类 Unix Shell |\\n| trymodule | 在终端中使用 npm 软件包 |\\n| jscpd | 源代码重复代码检测 |\\n| atmo | 模拟服务器端 API |\\n| auto-install | 编写代码时自动安装依赖 |\\n| cost-of-modules | 查找使性能降低的依赖 |\\n| localtunnel | 向公网开放你的 localhost |\\n| svg-term-cli | 基于 SVG 分享终端会话 |\\n| gtop | 终端下的系统监控仪表板 |\\n| themer | 为您的编辑器、终端、壁纸、Slack 等生成主题 |\\n| carbon-now-cli | 为你的代码生成精美的图片 |\\n| taskbook | 命令行环境下的任务、板块和笔记管理器 |\\n\\n\\n\\n\\n\\n### 7.2、文件处理\\n| 库 | 场景 |\\n| --- | --- |\\n| [glob](https://www.npmjs.com/package/glob) | 很便捷的获取文件（循环 + 正则）| \\n| [fs-extra](https://github.com/jprichardson/node-fs-extra) | 读 fs 模块的增强版，兼容 fs|\\n| [chokidar](https://github.com/paulmillr/chokidar) | 监听文件变动，代替 fs.watch 高性能 |\\n| [dotenv](https://github.com/motdotla/dotenv) | 可以将.env 文件内包含的变量，自动注入到 process.env 中|\\n| [onchange](https://github.com/Qard/onchange) | 监听文件变化并自动运行 npm script|\\n| [cpx2](https://www.npmjs.com/package/cpx2) | 监听文件变化，自动拷贝 | \\n| [readable-stream](https://github.com/nodejs/readable-stream) | stream 处理库 |\\n| [temp](https://www.npmjs.com/package/temp) | 临时文件操作库 |\\n| [mkdirp](https://github.com/substack/node-mkdirp) | 新建文件夹，省去 新建、进入、新建 等繁琐步骤|\\n| [ejsExcel](https://github.com/sail-sail/ejsExcel) | 是一个 Excel 模版引擎，可以在格式复杂的 excel 中填入信息|\\n| [markdown](https://github.com/younghz/Markdown) | 把 markdown 字符转为 html 字符|\\n| [markdown-it](https://github.com/markdown-it/markdown-it) | 新型 Markdown 解析器，快速，支持插件 |\\n| trash | 比 `rm` 更安全的选择」 |\\n| cpy | 复制文件 |\\n| empty-trash | 清空文件夹 |\\n| npkill | 轻松查找和删除过时且臃肿的 node_modules 文件夹 |\\n| pen | 用你喜爱的编辑器编写 Markdown，在浏览器中提供实时预览 |\\n| lessmd | 终端环境下的 Markdown 预览器 |\\n| cpy  | 文件拷贝 |\\n| rimraf  | 像 rm -rf 一样的递归删除 |\\n| make-dir  | 像 mkdir -p 一样的递归创建目录 |\\n| graceful-fs  | 功能增强版的 fs 模块 |\\n| chokidar  | 像 macOS 上使用原生 fsevents 一样监听 fs.watch 和 fs.watchFile 的文件系统监听器 |\\n| find-up  | 沿父目录向上查找文件 |\\n| proper-lockfile  | 进程间和机器间 lockfile 工具 |\\n| load-json-file  | 读取、解析 JSON 文件 |\\n| write-json-file  | 自动将 JSON 序列化写入到文件 |\\n| fs-write-stream-atomic  | 类似 fs.createWriteStream() 的原子操作 |\\n| filenamify  | 将字符串转换为有效的文件名 |\\n| lnfs  | 像 ln -fs 一样，强制创建符号链接 |\\n| istextorbinary  | 检查文件是文本还是二进制 |\\n| fs-jetpack  | 完全重新设计的、方便日常使用的文件系统 API |\\n| fs-extra  | 增加额外方法的 fs 模块 |\\n| pkg-dir  | 查找 npm 包的根目录 |\\n| filehound  | 灵活、流畅的用于文件系统搜索的接口 |\\n| move-file  | 甚至可以跨设备使用的移动文件工具 |\\n| tempy  | 随机获取临时文件或目录的路径 |\\n\\n\\n\\n### 7.3、数据处理\\n| 库 | 场景 |\\n| --- | --- |\\n| [nanoid](https://github.com/ai/nanoid) | 生成唯一的字符串 ID|\\n| [pinyin](https://github.com/hotoo/pinyin) | 前端/nodejs 汉字转拼音|\\n| [lunr.js](http://rank.chinaz.comwww.febeacon.com/lunr-docs-zh-cn/) | 全文搜索引擎，可以为 JSON 创建索引 并 检索|\\n| [crypto-js](https://github.com/brix/crypto-js) | crypto-js 是一个强大的加密库，支持大量加密算法|\\n| [decimal.js](https://github.com/MikeMcl/decimal.js/) | 是一个科学计算库，可以进行任意精度的十进制运算|\\n| [validator](https://github.com/validatorjs/validator.js) | 验证库|\\n| [jsonwebtoken](https://github.com/auth0/node-jsonwebtoken) | 生成与解析 token [参考](https://github.com/auth0/node-jsonwebtoken) | \\n| [json5](https://github.com/json5/json5) | JSON5 是对 JSON 的扩展，JSON 格式更加宽泛 [参考](https://github.com/json5/json5) |\\n| [jsondiffpatch](https://github.com/benjamine/jsondiffpatch) | 对比 JSON，生成 diff、patch 信息 [参考](https://github.com/benjamine/jsondiffpatch) \\n| [joi](https://github.com/sideway/joi) | JavaScript 最强大的模式描述语言和数据验证器 |\\n| [ajv](https://github.com/ajv-validator/ajv) | JSON Schema 验证工具，最快的 JSON 概要验证器，支持 v5、v6 和v7 方案 | \\n| [superstruct](https://github.com/ianstormtaylor/superstruct) | json/js 对象 验证 validate 库 |\\n| yaml-front-matter | 解析 yaml 或 json |\\n| hash-sum | 非常快的唯一哈希生成器 |\\n| deepmerge | 深度合并两个或多个对象的可枚举属性。 |\\n| leven | 测量两字符串之间的差异最快的 JS 实现之一 |\\n| lru cache | 删除最近最少使用的项的缓存对象 |\\n| strip-ansi | 从字符串中去掉 ANSI 转义码 |\\n| is-my-json-valid  |  极速 JSON 格式校验工具 |\\n| property-validator  |  用于 Express 的属性校验工具 |\\n| schema-inspector  |  JSON API 清理和验证 |\\n| Superstruct  |  简单基础的 JavaScript 和 TypeScript 数据验证器 |\\n\\n\\n### 7.4、邮件处理\\n| 库 | 场景 |\\n| --- | --- |\\n| [nodemailer](https://www.cnblogs.com/HJ412/p/11560364.html) | 处理电子邮件的最快方式 |\\n| emailjs| 向任何 SMTP 服务器发送带有附件的文本 / HTML 电子邮件 |\\n| email-templates| 创建、预览和发送自定义电子邮件 |\\n| MJML| 旨在减少创建响应式电子邮件困难的一种标记语言 |\\n\\n\\n### 7.5、网络部署\\n| 库 | 场景 |\\n| --- | --- |\\n| [nodemon](https://github.com/remy/nodemon) | 支持热加载和自动重启，可以检测代码文件变化，并实时重启程序，适合开发阶段使用！|\\n| [pm2](https://github.com/Unitech/pm2) | 支持热启动、负载、集群、监控、重启等功能，一旦 node.js 程序崩溃，pm2 可以自动重启 Node.js 程序|\\n| [http-server](https://github.com/http-party/http-server) | 零配置启动一个 HTTP 服务，访问 html 文件|\\n| [json-server](https://github.com/typicode/json-server) | 启动服务 访问 json|\\n| [http-proxy](https://github.com/http-party/node-http-proxy) | node http 代理库，使用起来较原生|\\n| [http-proxy-middleware](https://github.com/chimurai/http-proxy-middleware) | http 代理库，express 中间件|\\n| [socket.io](https://github.com/socketio/socket.io) | 用极其简单的语法，在服务端与客户端之间，建立可靠的 webSocket 长连接通信|\\n| [oauth](https://github.com/nodejs/readable-stream) | oauth 认证库|\\n| torrent | 下载种子 | \\n| iponmap | IP 地址查找器 | \\n| speed-test | 测试你的互联网连接速度和 ping 值 | \\n| discharge | 轻松将静态网站部署到 Amazon S3 | \\n| wifi-password | 获取当前 wifi 的密码 | \\n| download-git-repo | 拉取 Git 代码 |\\n| default-gateway | 通过对 OS 路由接口的 exec 调用获得机器的默认网关 |\\n| address | 获取当前机器的 IP, MAC 和 DNS 服务器。 |\\n| portfinder | 自动寻找  `8000`至`65535`内可用端口号 |\\n| is-up | 检测网站是否可以正常访问 |\\n| is-online | 检测网络连接是否正常 |\\n| public-ip | 获取你的公网 IP 地址 |\\n| got  | 为内置的 http 模块提供更好的接口 | \\n| gh-got  | 为 got 和 GitHub API 交互提供更方便的封装 | \\n| axios  | 基于 Promise 的 HTTP 客户端（也可以在浏览器中工作） | \\n| wreck  | HTTP 客户端工具. | \\n| download  | 使下载和提取文件变得轻松 | \\n| http-proxy  | HTTP 代理 | \\n| superagent  | HTTP 请求库 | \\n| node-fetch  | Node.js 的window.fetch | \\n| flashheart  | REST 客户端 | \\n| http-fake-backend  | 使用 JSON 文件或者 JavaScript 对象 建立一个伪装的可自定义路由的后端服务 | \\n| cacheable-request  | 使用符合 RFC 的缓存支持封装原始的 HTTP 请求. | \\n| gotql  | 基于 got 构建的 GraphQL 请求库 | \\n| global-agent  | 可以使用环境变量配置的全局 HTTP / HTTPS 代理 | \\n| smoke  | 可记录的基于文件的模拟 HTTP 服务 | \\n| http-server | 简单、零配置的命令行 HTTP 服务器 |\\n| Live Server | 具有热重启功能的开发环境 HTTP 服务器 |\\n\\n\\n## 八、第②个彩蛋（第①个你找到了吗？）\\n\\n感谢大家花时间阅读学习，献上 [node-cli-template](https://github.com/HermitGeek/node-cli-template)，欢迎 Star ✨\\n\\n\\n",
        "tags": [
            "前端",
            "Node.js",
            "掘金·日新计划"
        ]
    },
    {
        "article_id": "7186161640121827387",
        "cover_image": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c566e1ae805475d947766fdfe6521fa~tplv-k3u1fbpfcp-watermark.image?",
        "title": "新时代的 SSR 框架破局者：qwik",
        "brief": "抛弃完全多余的 hydration ，让你的SSR应用性能突破天际。今天我们来聊聊一种全新的服务端渲染思路，一起来看看号称世界上第一个SSR框架：qwik。",
        "user_name": "19组清风",
        "view_count": 9309,
        "collect_count": 119,
        "comment_count": 24,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/0b2bf89c8fa30c59c10753d91dd327d7~300x300.image",
        "category": "前端",
        "content": "# 引言\\n\\n今天这篇文章中和大家聊一聊**号称世界上第一个 O(1) 的 JavaScript SSR 框架：qwik。**\\n\\n别担心，如果你不是特别了解 SSR 也没关系，文章大概会从以下几个方面作为切入点：\\n\\n+ 🌟 首先会围绕对比 SSR 与 SPA 各自的优劣势，从而展开 SSR 的运行机制以及 SSR 相较于 SPA 究竟为了解决什么问题。\\n\\n+ 🌟 之后，会根据 NextJs 的运行机制思考针对目前主流 SSR 框架设计思路上存在的不足从而引出 qwik 为何会在众多成熟框架中脱颖而出。\\n\\n+ 🌟 最后，笔者会针对于 qwik 提出自己的看法以及聊聊目前 qwik 存在的”问题“。\\n\\n诸如社区内部 SSR 框架其实已经产生了非常优秀的作品，比如大名鼎鼎的 NextJS 以及新兴势力代表的 Remix 和 isLands 架构的 Astro、Fresh 等等优秀框架。\\n\\n为何 qwik 可以在众多老牌优秀框架中脱颖而出。接下来，让我们一起来一探究竟吧。\\n\\n# SSR & CSR \\n\\n目前业内存在非常多基于 SSR 的优秀框架，比如 Next、Remix、Nuxt 等等。\\n\\n针对于 Qwik 我们先来聊聊基于 Next 体系的传统 SSR 方案。\\n\\n## Client Side Rendering\\n\\n在开始 SSR 之前我们先来聊聊它的对立面，所谓的 CSR(Client Side Rendering)。 \\n\\n服务器端渲染 (SSR) 是一种在服务器中进行渲染 HTML 而不是由浏览器中执行 JS 获得网页(SPA)的技术。\\n\\n目前国内社区中主流框架比如 VueJs、React 等严格意义上来说都是基于 CSR(Client Side Rendering) 的产物。\\n\\n所谓 CSR 的意味着当发出一个请求时，服务器会返回一个空的 HTML 页面以及对应的 JavaScript 脚本。\\n\\n比如\\n\\n```html\\n<html>\\n<head> \\n   <title>携程商旅</title> \\n</head> \\n \\n<body> \\n     <div id=\\\"root\\\"> </div> \\n     <script src=\\\"./index.js\\\"> </script> \\n </body>\\n </html>\\n```\\n\\n当浏览器下载完成对应的 JS 脚本后才会动态执行对应的 JS 脚本然后在返回的 HTML 页面上进行渲染页面内容。\\n\\n你可以简单的理解为上述的 `./index.js` 会在客户端下载完成后执行该脚本，从而执行 `document.getElementById('root').innerHTML = '...'` 来进行页面渲染。\\n\\n**这种方式并不是从服务端下发的 HTML 文件来进行渲染页面，相反而是通过浏览器获取到服务端下发 HTML 中的所有的 JS 文件后执行 JS 代码从而在客户端通过脚本进行页面渲染。**\\n\\n以及通常在 CSR 中当我们点击任何页面中的导航链接并不会向服务端发起请求，而是通过下载的 JS 脚本中的路由模块(比如 ReactRouter、VueRouter 这样的模块)重新执行 JS 来处理页面跳转从而进行页面重新渲染。\\n\\n上面的概念是非常典型的 CSR ，浏览器仅仅接受一个***用作网页容器的 HTML 页面***，这样的方式通常也被称为**单页面应用 (SPA)**。\\n\\n### 优势\\n\\n那么上述我们提到的 CSR 广泛存在于目前大量页面中，必然存在它自己的优势。\\n\\n**在页面初始化访问后加载速度极快且响应非常迅速。** 在页面初始化后，网站所有的 HTML 内容都是在客户端通过执行 JS 生成，并不需要再次请求服务器即可重新渲染 HTML 。\\n\\n此外，有关任何实时的数据获取都可以通过 AJAX 请求对于页面进行局部更新从而刷新页面。\\n\\n### 劣势\\n\\n可是，CSR 真的有那么完美吗。任何一件技术方案一定存在它的两面性，我们来看看 CSR 方式究竟存在哪些问题：\\n\\n1. **初始加载时间长**。首次请求完服务器获取到 HTML 页面后，初始化的页面仍然需要在一段时间内处于白屏状态。\\n    \\n    在初始渲染之前，浏览器必须等待 HTML 页面中的所有 Javascript 脚本加载完成并且执行完毕，此时页面才会进行真正的渲染。\\n    \\n> 当然，使用代码拆分或延迟加载等多种方案可以有效的减少上述的问题。但是这些方式始终是治标不治本，因为它并没有从本质上解决 CSR 存在的问题。\\n\\n2. **SEO（搜索引擎优化） 的负面影响。** \\n    \\n    上边我们提到过，所谓 CSR 本质上首先会返回一个空的 HTML 页面，所以这也就造成了在搜索引擎对于该页面的数据爬取中会认为它是一个空页面。从而影响对应的搜索结果排名。\\n    \\n    虽然说在最新的 Google 中已经可以触发执行 JS 对于网站进行关键字排名，但是在 JS 体积足够大的时候针对于 SEO 仍然是存在一部分问题导致无法解析出正确的关键字匹配。\\n    \\n当然 CSR 还存在一些其他方面的缺点，比如网站强依赖于 JS 当用户禁用 JS 时网站只能是白屏展现给用户等等之类。\\n\\n## Server Side Render\\n\\n简单聊完客户端渲染后，我们稍微来看看所谓的服务端渲染是什么含义。\\n\\n基于旧时代的类似 Java 的 JSP 页面我在这里就不赘述了，显然 JSP 的方式每个 HTML 都需要单独请求服务器返回对应的 HTML 内容严格意义上来说这也是 SSR 的方式但是很明显这已经被时代淘汰了。\\n\\n目前国内各家公司广泛应用的服务端渲染技术大概的思路是这样的（Next 的 SSR 模式也是同样的思路）：\\n\\n当用户首次访问你的应用站点时：\\n\\n   1. 首先服务器会根据对应的 URL 在服务端根据对应路径渲染对应的 HTML 模版。\\n   \\n       注意这里渲染的 HTML 模版是具有该页面真正的内容。同时它并不具备任何交互逻辑（比如 DOM 元素的点击事件），这是一份完全的静态站点。\\n       \\n   2. 服务器会下发这份仅具有静态内容的 HTML 模版，同时这份模版中也会包含对应的 JavaScript 执行脚本。\\n    \\n        第一时间会展示给用户对应的 HTML 页面，此时对于访问站点的用户来说**首屏渲染相较于 SPA 应用来说会非常快**。因为它并不需要在客户端浏览器上再次下载和执行 JavaScript 脚本来进行页面渲染。\\n        \\n        其次，针对于 SEO 的优化也会非常良好，因为服务器上下发的 HTML 页面是包含当前站点的真实 HTML 结构，对于搜索引擎的爬虫来说会非常容易的匹配到当前关键字。\\n        \\n   3. 之后，浏览器会下载当前这份 HTML 的 JS 脚本。\\n       \\n       因为首先呈现给用户的一份静态的 HTML 页面，并不具备任何交互效果。我们需要为页面上的元素增加对应交互，HTML 页面中的 JS 脚本中会包含网站的交互逻辑。\\n       \\n   4. 最后，当下载完 HTML 脚本中的 JS 脚本后，自然会执行这些 script 脚本。从而发生一种被称为 **# hydrate(水合)** 的方式，从而为页面上静态 HTML 元素再次添加对应的事件处理从而保证页面具有交互性。\\n\\n   **当 hydration 过程完成后，会由我们的客户端框架接管网站的后续渲染。**\\n   在后续的导航链接跳转和页面渲染中和服务器已经没有任何关系了，我们完全可以利用客户端的路由切换（History Api/Hash Api）利用 JS 进行页面渲染从而保证切换页面不用再次请求浏览器保证非常及时的页面交互。\\n\\n### hydration \\n\\n上述过程中有一个非常重要的关键字 hydration（水合）。\\n\\n**首次访问页面时，页面的静态 HTML 是在服务端生成的。** 在服务端我们将生成的静态 HTML 以及 HTML 中携带的 JS 脚本发送到客户端。\\n\\n此时静态 HTML 会立即显示在用户视野中，然后浏览器会利用网络进程下载当前 HTML 脚本中的 JS 脚本。\\n\\n当 JS 脚本下载完成后，会立即执行同时发生一种被称为 **hydration** 的过程。\\n\\n所谓的 **hydration** 简单来说，也就是客户端下载完成 JS 脚本后，浏览器会执行下载的 JS 脚本这些脚本中有部分内容会将**已经存在的 HTML 内容通过执行下载的 JS 脚本添加上对应的事件监听器** 从而保证页面的交互。\\n\\n**注意**，在 React、Vue 中 hydration 并不意味这重新渲染。因为在 Server 端已经渲染了和 Client 完全相同的 DOM 结构所以完全没有必要在此重新渲染。\\n\\n所以 hydration 的过程是给当前页面中已经生成的 HTML 页面添加上对应的事件监听器。\\n\\n> 这也是为什么在 Next 等框架中为什么必须要保证 Server 端和 Client 的渲染 HTML 结构必须一致的原因。\\n\\n比如我们以 Next 举例来说（Vue 也是同样的道理）：\\n\\n1. 当用户访问 www.trip.biz.com 时，服务端接收到请求调用 ReactDOMServer.renderToString() 生成当前页面的 HTML 静态结构。\\n\\n2. 服务器会下发这个 HTML 页面给客户端，同时这个 HTML 页面上也会携带一部分 JS 脚本 script 标签。\\n\\n3. 用户的浏览器中会立即展现到该 HTML 页面，同时也会下载对应 JS 脚本并执行。\\n\\n4. 当 JS 脚本执行完毕后，客户端会调用 ReactDOM.hydrate() 发生水合为当前页面的 HTML 页面添加事件交互处理，同时后续由 JS 接管页面的跳转渲染。\\n\\n> 针对于第一步 Next 中存在 [Automatic Static Optimization](https://nextjs.org/docs/advanced-features/automatic-static-optimization) 的优化，并不一定会在每次访问时调用 renderToString 方法，有可能在构建时也会直接生成对应的 HTML 模版。\\n\\n> 当然，在最新的 Next 版本中已经支持了[Stream](https://nextjs.org/blog/next-13#streaming)以及 [Server Components](https://nextjs.org/blog/next-13#server-components)。\\n\\n整个过程就像是这张图中的样子：\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d6b5aa457ede4eed97f91ddef7e74dfe~tplv-k3u1fbpfcp-watermark.image?)\\n\\n### 优势\\n\\n简单聊过了所谓 SSR 的原理后，如果你有认真看上述的内容。其实我相信相较于 CSR ，SSR 这种方式的好处不言而喻：\\n\\n1. 更好的搜索引擎优化 SEO 方式，HTML 模板是从服务端直接下发这也就导致搜索引擎爬虫中更多的关键字匹配。\\n\\n2. 更快的首屏渲染，因为相较于 SPA 它少了在 Client 中下载和执行 JS 脚本后渲染的过程。\\n\\n3. 页面不需要 JS 也可以正常渲染，虽然没有 JS 意味着页面失去了可交互性。但对于禁用 JS 的用户来说，展示一些静态内容总比 SPA 应用的白屏来的更加友好一些对吧。\\n\\n### 劣势\\n\\n当然，任何技术方案在不同场景下也存在它自己的不足。\\n\\n1. 强依赖于服务。\\n\\n    针对于 CSR 的方式它是一种纯静态资源。我们可以直接将它放在 CDN 上就可以良好的用户访问到，而 SSR 的方式必须依赖于一个服务器进行服务端预渲染。（当然纯 SSG 应用我们不在这个讨论范围之内）\\n    \\n    同时，有服务的地方就存在并发压力。当你需要为你的应用考虑服务端渲染的方式时，一定不要忘记为你的服务器进行压测。\\n    \\n2. [Time to Interactive](https://web.dev/tti/) 可交互时间 (TTI) 的增长，虽然说 SSR 的方式有效的缩短了首屏加载的方式，但是会增加所谓的TTI（可交互时间）。\\n\\n    所谓的 TTI 指标测量页面从开始加载到主要子资源完成渲染，并能够快速、可靠地响应用户输入所需的时间。\\n    \\n    因为 SSR 的方式在用户访问时会下发当前页面中静态的 HTML 内容，也就是所谓的 [First Contentful Paint 首次内容绘制 (FCP)](https://web.dev/fcp/) 会非常快速，但是页面需要用户交互效果缺又需要下载和执行完成 JS 脚本发生 hydatrion 后才具有交互性。\\n    \\n    这也就造成页面的 TTI 相较于 CSR 方式会有所差劲，因为 CSR 在渲染完成后就会立即具有交互性（不需要其他任何多余步骤）。\\n\\n## qwik\\n\\n上述聊了那么多前置内置，终于要和大家切入正题了。\\n\\n所谓磨刀不费砍柴功，上边和大家强调现阶段 SSR 的方案以及对应的优劣势就是为了引入下面的内容。\\n\\n首先，这篇文章的目的是为了让大家在当前众多 SSR 框架中**思考性能方面**是否可以有所提升的，在服务器方面不会过多的深入。\\n\\n我们可以稍微思考下上述服务器端渲染的过程：\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d6b5aa457ede4eed97f91ddef7e74dfe~tplv-k3u1fbpfcp-watermark.image?)\\n\\n**第一步我们需要在服务端获取对应页面的 HTML 页面，大多数情况（非纯静态页面）就需要在服务端掉用对应渲染方法渲染出 HTML 页面。**\\n\\n**那么，如果我们能在第一步渲染 HTML 页面时，就添加对应的事件处理。后续的 3 步是不是完全可以省略下来了对吧。**\\n\\n其实社区内部之前已经有非常多的方案来提升所谓 SSR 框架的性能方案。\\n\\n比如 Remix 的 HTTP [stale-while-revalidate 缓存指令](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate)\\n\\n比如 [astro](https://astro.build/) 等新兴框架的 Islands 架构方案，关于 Islands 有兴趣的朋友可以参考神三元的这篇 [Islands 架构原理和实践](https://juejin.cn/post/7155300194773860382#heading-10)。\\n\\n针对于上面的概念，我们直接来看看 qwik 中提到的 Hydration is Pure Overhead （完全多余的 Hydration）。\\n\\n### Hydration 造成的开销\\n\\n首先针对于 Hydration 的过程，我们提过到首先会在服务器上进行一次静态 HTML 渲染，之后当 HTML 下发到客户端后又会再次进行 hydrate 的过程，在客户端进行重新执行脚本添加事件。\\n\\nHydration 过程的难点就在于我们需要知道需要什么事件处理程序，以及将该事件处理程序附加在哪个对应的 DOM 节点上。\\n\\n这个过程中，我们需要处理：\\n\\n+ 每一个事件处理程序中的内容，绝大多数框架中的状态都做为闭包函数保存在内容中。所以需要 hydration 的过程来重新获取状态。\\n\\n+ 其次，在搞清楚了每个事件处理函数的内容后。我们也需要将对应的事件处理函数附加到对应的 DOM 节点上，同时还要确保该监听器的正确事件类型。\\n\\n更加复杂每个事件处理函数中的内容是一个闭包函数，这个函数内部需要处理两种状态，APP_STATE 以及 FRAMEWORK_STATE。\\n\\n+ APP_STATE：应用程序的状态。简单来说应用程序的状态就是 HTML 事件中的各个状态事件，如果不存在这些事件状态那么所有的内容都是没有任何交互效果的。\\n\\n+ FRAMEWORK_STATE：框架内部状态。通常我们会利用诸如 React 或者 Vue 等框架进行接替渲染。如果没有 FRAMETER_STATE，框架内部就不知道应该更新哪些DOM节点，也不知道应该在什么时候更新它们。\\n\\n**通俗来说 Hydration 就是在客户端重新执行 JS 去修复应用程序内部的 APP_STATE 以及 FRAMEWORK_STATE。**\\n\\n同样还是这这张图\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ffd50eb2803a4bc1aae9276f960a214e~tplv-k3u1fbpfcp-watermark.image?)\\n\\n在图中的前三个阶段可以被称为 RECOVERY 阶段，这三个阶段主要是在重建你的应用程序。\\n\\n当从 Server 端下发的 HTML 静态页面后，我们希望它是具有交互效果的 HTML 正常应用程序。\\n\\n那么此时 hydartion 的过程必须经历下载 HTML 、下载所有相关 JS 脚本、解析并且执行下载的 JS 脚本。\\n\\n`RECOVERY` 阶段是和 hydartion 的页面的复杂性成正比，在移动设备上很容易花费 10 秒。\\n\\n由于`RECOVERY`是昂贵的部分，大多数应用程序的启动性能都不是最佳的，尤其是在移动设备上。\\n\\n**前三个阶段被称为 `RECOVERY` 的阶段其实是完全没有必要的**，因为在服务端我们已然渲染过对应的 HTML ，但是为了应用程序的可交互性以及服务端仅保留了静态的 HTML 模版导致不得不在 Client 上继续执行一次 Server 端的逻辑。\\n\\n总而言之，hydration 其实是通过下载并重新执行 SSR/SSG 呈现的 HTML 中的所有 JS 脚本并执行来恢复组建中的事件处理程序。\\n\\n同一个应用程序，会被发送到客户端两次，一次作为 HTML，另一次作为 JavaScript。\\n\\n此外，框架必须立即执行 JavaScript 以恢复在服务器上被丢掉的 `APP_STATE`和`FRAMEWORK_STATE`。所有这些工作只是为了检索服务器已经拥有但丢弃的东西！！\\n\\n比如这样一个例子：\\n\\n```tsx\\nexport const Main = () => <>\\n   <Greeter />\\n   <Counter value={10}/>\\n</>\\n\\nexport const Greeter = () => {\\n  return (\\n    <button onClick={() => alert('Hello World!'))}>\\n      Trip Biz\\n    </button>\\n  )\\n}\\n\\nexport const Counter = (props: { value: number }) => {\\n  const store = useStore({ count: props.number || 0 });\\n  return (\\n    <button onClick={() => store.count++)}>\\n      {store.count}\\n    </button>\\n  )\\n}\\n```\\n\\n上边的例子中我们编写了一个 Counter 的计数器组件，在传统 SSR 过程中该组件会被渲染成为：\\n\\n```html\\n<button>Greet</button>\\n<button>10</button>\\n```\\n\\n可以看到上边的两个按钮**不拥有任何处理状态的能力。**\\n\\n要使网页具有交互性，必须要做的就是通过下载对应 HTML 页面中的 script 脚本并执行代码从而恢复按钮上的交互逻辑和状态。\\n\\n**为了具有交互性，客户端不得不执行代码实例化组件后重新创建状态。**\\n\\n当上述过程完成后，你的应用程序才会真正具有可交互性。无疑，同一个组件的渲染逻辑被执行了两遍，这是一个非常冗余且耗费性能的过程。\\n\\n### Resumability: 更加优雅的 hydartion 替代方案\\n\\n所以为了消除额外的开销，我们需要思考如何避免重复的 `RECOVERY` 阶段。同时还要避免上面的第四步，第四步是执行脚本后给现有的 HTML 附加正确的事件处理程序。\\n\\nqwik 中提出了一个全新的思路来规避 `RECOVERY` 带来的外开销：\\n\\n1.  **将所有必需的信息序列化为 HTML 的一部分。**\\n\\n    qwik 将需要的状态以及事件序列化保存在 Server 端下发的 HTML 模版中，需要序列化信息需要包括`WHAT`（事件处理函数内容）, `WHERE`（哪些节点需要哪些类型的事件处理函数）, `APP_STATE`（应用状态）, 和`FRAMEWORK_STATE`（框架状态）。\\n\\n2. **依赖于事件冒泡来拦截所有事件的全局事件处理程序。**\\n   \\n   qwik 中事件处理程序是在全局处理的，这样我们就不必在在特定的 DOM 元素上单独注册所有事件。\\n   \\n3. qwki 内部存在一个可以延迟恢复事件处理程序的工厂函数。\\n\\n    该工厂函数主要用于处理 WHAT 阶段，也就是用来识别某个事件处理函数中应该存在什么脚本逻辑。\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d6fd763b0dc04b709aa2b192ea579a65~tplv-k3u1fbpfcp-watermark.image?)\\n\\n我们可以看到所谓的 Resumable 对比 Hydration 明显可以省略不需要后三个阶段，直接获取 HTML 后页面其实就已经准备完毕，这无疑对于性能的提升是巨大的。\\n\\n\\n**对比传统的 hydration 方案，在客户端获得服务端下发的 HTML 后会立即请求需要的 JS 脚本并执行从而为页面附加对应的交互效果。**\\n\\n**而 qwik 提出的概念恰恰相反，获取完服务端下发的 HTML 页面后所有的交互效果实际上都是一种惰性创建的效果。**\\n\\n**因为我们在 HTML 中的每个元素中都已经通过序列化从而在它的标签属性上记录了对应事件处理函数的位置以及脚本内容（自然内容中也包含对应的状态），所以当获得 HTML 页面后其实就可以说此时页面已经加载完毕了而不需要任何实时的 JS 执行。**\\n\\n这样做的好处是在 qwki 中完全可以省略 hydration 的多余步骤，甚至可以说完全抛弃了 hydration 的概念。\\n\\n客户端完全不必和服务端的 HTML 进行水合，相同的渲染内容仅仅是在 Server 端进行一次渲染客户端即可拥有对应的事件处理内容。\\n\\n简单来讲**Qwik的工作原理就是在服务端序列化 HTML 模版，从而在客户端延迟创建事件处理程序，这也是它为什么非常快速的原因。**\\n\\n### qwik 工作机制\\n\\n上边我们讲到了 qwik 的原理部分，同样拿上边的计数器的例子我们来对比下：\\n\\n```tsx\\nexport const Main = () => <>\\n   <Greeter />\\n   <Counter value={10}/>\\n</>\\n\\nexport const Greeter = () => {\\n  return (\\n    <button onClick={() => alert('Hello World!'))}>\\n      Trip Biz\\n    </button>\\n  )\\n}\\n\\nexport const Counter = (props: { value: number }) => {\\n  const store = useStore({ count: props.number || 0 });\\n  return (\\n    <button onClick={() => store.count++)}>\\n      {store.count}\\n    </button>\\n  )\\n}\\n```\\n\\n在 qwik 编译后，服务端会序列化对应组件的 HTML 结构从而下发如下的模板：\\n\\n```html\\n<div q:host>\\n  <div q:host>\\n    <button on:click=\\\"./chunk-a.js#button\\\">Trip Biz</button>\\n  </div>\\n  <div q:host>\\n    <button q:obj=\\\"1\\\" on:click=\\\"./chunk-b.js#count[0]\\\">10</button>\\n  </div>\\n</div>\\n<script id=\\\"qwikloader\\\">/* qwik 中设置全局事件监听器的代码 */</script>\\n<script id=\\\"qwik/json\\\">/* 用于反序列化的 JSON 相关信息 */</script>\\n```\\n\\n\\n我们可以看到经过 qwik 编译后的 html 结构并不单单只有 DOM 元素，同时会在对应需要状态 & 事件的 DOM 元素上通过 HTML 元素属性来记录当前元素的事件和状态信息，这既是 qwik 中的序列化。\\n\\n\\n比如上边 button 的 `on:click` 属性记录了该元素后续需要恢复的所有信息。\\n\\n**需要注意的是序列化这一步是在服务端渲染时完成的，这也就意味着后续客户端可以通过服务端序列化的属性信息进行反序列化从而达到所谓的可恢复性而不需要重复执行组件。**\\n\\n当然你可能会好奇 qwik 是如何进行这些事件 & 状态的恢复，qwik 正是通过在返回的 HTML 页面中内嵌的所谓 qwikloader 的 script 脚本（这段脚本的大小不超过 1kb）配合 qwikjson 映射表，从而在全局进行恢复事件和状态的逻辑。\\n\\n正因为这个原因，使得 qwik相较于传统 SSR 的 hydration 在 Client 中再次执行渲染从而水合页面状态和事件处理程序，这简直可以说是接近零 JS 的执行过程。\\n\\n最终在用户触发事件时候达到惰性的创建事件并执行，这个过程中完全没有重复任何服务器已经完成的任何工作。\\n\\n整个工作过程就像下面这张图描述的那样：\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/84a3047a2d5347b993c8809d50b3be9d~tplv-k3u1fbpfcp-watermark.image?)\\n\\n上边的这张图完美的描述了 qwik 的工作原理，相信经过上述的描述大家对于这张图中想表达的思想已经可以完美的理解了。\\n\\n利用 qwik 的这个优势，在绝大多数应用中我们可以利用 qwik 保证你的 SSR 应用在保证快速的 FCP 的前提也同样拥有与之不相上下的 TTI 体验效果。\\n\\n### 惰性加载脚本会影响用户交互体验吗\\n\\n当然上文说过任何框架的优势和劣势都不是绝对的，在笔者看来 qwik 的确会存在以下一些问题。\\n\\n大多数同学看完上边的内容我相信也会存在“惰性加载脚本会影响用户交互体验吗”这样的疑问。\\n\\n首先，qwik 中既然选择在触发用户行为时，再惰性加载并执行响应的 JS 脚本。那么难免需要在用户触发交互时动态生成对应的事件处理函数进行执行。\\n\\n这样的方式相较于传统 hydration 的确会存在一些不足，需要额外生成事件会额外造成交互响应时间的损耗而传统 SSR 方式在页面首次加载时就已经绑定好（相当于生成了）相应的事件处理函数。\\n\\n就惰性加载生成事件这点在我看来：\\n\\n   针对于动态加载 JS 脚本，其实已经存在诸如非常多的 prefetch 等等预加载技术。\\n   \\n   无论是基于传统 Next 方案还是基于 qwik 这种惰性可恢复的方案，利用 prefetch 等预加载技术优先在网络空闲时加载响应重要的 JS 脚本都是非常有必要的，所以这点在我看来并不是特别重要的问题。\\n   \\n   \\n### 延迟加载会带来 bundle 数量的上升吗\\n\\nqwik 推崇的延迟加载其实已经是一项非常成熟的构建技术了。无论是使用 webpack、rollup 又或是其他任何构建工具都存在延迟加载 & 代码分割的技术。\\n\\n传统构建工具中关于代码分割会带来以下两点的困难：\\n\\n1. 需要开发人员自行去处理更加细粒度的代码分割，当然这并不是最主要的。因为目前我们可以利用 [Magic Comments](https://webpack.js.org/api/module-methods/#magic-comments) 配合 [Dynaic Imports](https://webpack.js.org/guides/code-splitting/#dynamic-imports) 来解决需要手动切入多个入口点的问题。\\n\\n当然，这一系列事情比起魔法注释。因为 qwik 本身提倡的就是所谓的延迟加载，所以在框架内部已经帮我们足够智能的去处理这个过程。\\n\\n但是需要注意的是这并不意味着开发者无法自主去控制这个过程。只是在使用框架的过程中，qwik 希望开发者更加专注于他们自身的业务逻辑。\\n\\n2. **当存在非常多的延迟加载时，传统构建工具会从一个大 bundle 分割成为无数个小的 bundle 。**\\n\\n延迟加载模块的确会存在多个 small bundle 的问题，可是当我们拥有的 bundle 越多，其实我们就拥有更多的自由度去以各种各样的方式去拼装成为单个大的 bundle。\\n\\nqwik 中存在足够的方式提供给我们将多个小的 chunk 自由组合成为一个从而有效的减少细碎 chunk 的数量，当然这个点在传统构建工具中也是这样。\\n\\n### 动态创建事件函数会造成内存泄漏吗\\n\\nqwik 的设计思想在与每次事件触发时通过 qwikloader 来动态创建事件处理函数，相信有的同学存在疑问“那么多次触发事件会造成额外的开销吗”。\\n\\nqwik 的作者 **miško hevery** 在 [Hydration is Pure Overhead](https://www.builder.io/blog/hydration-is-pure-overhead) 中明确的表示过 qwik 会在每次事件执行完毕后释放函数，相当于每次事件执行完毕都会进行一次“去水合”的过程。\\n\\n所以，当你触发一次事件和无数次事件函数在执行过程中对于内存占用来说是相差无几的。\\n\\n当然相较于传统 hydration 的方式（在页面首次渲染时在内存中记录所有状态），无疑 qwik 这种并不在内存中记录任何状态的方式恰恰对于内存的占用比 dyration 更加轻量化。\\n   \\n### qwik 真的有那么快吗\\n\\n说了那么多，那么 qwik 真的有那么快吗。\\n\\n![WechatIMG144.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac5dce3a32394eada285886cc1f73aca~tplv-k3u1fbpfcp-watermark.image?)\\n\\n上图是利用 qwik 搭建的 [builder.io](https://www.builder.io/) 官方网站，我相信 builder.io 的数据已经告诉我们答案了。\\n\\n固然上述的数据并不仅仅只是单纯一个 qwik 框架带给网站的优化，一定会有代码层面或者构建层面等等方面的优化配合而来的数据。但是针对于 FCP 和 TTI 时间上的一致性这在一个中型 SSR 应用程序其实可以称得上是非常优秀了，我相信这足以说明了 qwik 的确名副其实。\\n   \\n# 结语\\n\\n我们可以看出来，qwik 的核心思路还是通过更加细粒的代码控制配合惰性加载事件处理程序以及事件委托来缩短首屏 TTI。\\n\\n文章中我们也讲到了 qwik 其实并不是因为使用了多么牛逼的算法导致它有多么快，而它的速度正是得益于它的设计思路，省略了传统 SSR 下首屏需要加载庞大的 JS 进行 hydration 的过程。\\n\\n当然，笔者对于 qwik 也仍是在学习阶段。后续会在公司里的更多项目尝试 qwik 之后也会和大家分享关于它的更多心得。\\n\\n总而言之，qwik 的”无水合“设计思路目前看来的确会在框架层面带来巨大的性能提升。大家如果有机会的话也可以在项目中尝试一下 qwik ，相信会给你带来意想不到的收益效果。\\n\\n\\n\\n\\n  \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
        "tags": [
            "前端",
            "JavaScript",
            "React.js"
        ]
    },
    {
        "article_id": "7193617423751675959",
        "cover_image": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dda05b684c6b4cf2823204422a830f25~tplv-k3u1fbpfcp-watermark.image?",
        "title": "iOS老司机的2022年戒烟之旅, 抽出5分钟没准<<这书能让你戒烟>> ",
        "brief": "讲一个笑话:\"曾有一部电视广告片描述过这样的例子。一个警察决定戒烟，于是在烟盒里塞了一张20块钱的钞票。他决定，如果再想吸烟的话，他必须先把钞票烧掉。结果是他强忍了几天，最后真的把钞票烧掉了。\"",
        "user_name": "JackLee666",
        "view_count": 1559,
        "collect_count": 2,
        "comment_count": 2,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/7cd9ed67feb31cfde4da833439f391b2~300x300.image",
        "category": "阅读",
        "content": "「回顾2022，展望2023，我正在参与[2022年终总结征文大赛活动](https://juejin.cn/post/7172462429929111559 \\\"https://juejin.cn/post/7172462429929111559\\\")」\\n\\n## 前言\\n- 讲一个笑话:\\\"*曾有一部电视广告片描述过这样的例子。一个警察决定戒烟，于是在烟盒里塞了一张20块钱的钞票。他决定，如果再想吸烟的话，他必须先把钞票烧掉。结果是他强忍了几天，最后真的把钞票烧掉了。*\\\"\\n- 回顾2022年, 如果说做了什么最正确的一件事, 我觉得这件事就**戒烟**; 2023年如果想做什么最有价值的力所能及的事, 我觉得这就是就是**帮助能接触到的抽烟的人戒烟**.\\n- 打开百度搜索\\\"中国吸烟人口比例\\\", 我们会发现一个触目惊心的数字, 中国吸烟人数超3亿人! 数字是冰冷的, 数字的背后是无数因吸烟引发的健康问题及各种惨剧.\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6137b03a810e429ebd07ba482664f914~tplv-k3u1fbpfcp-watermark.image?)\\n\\n- 2022年有幸读到这本由亚伦卡尔先生写的<<这书能让你戒烟>>, 让我对戒烟有了更加深刻全面的认识. 作为一个**日均2包烟**并拥有**33年烟龄**的*老烟枪*, 亚伦卡尔先生通过对整个吸烟过程及环境的精辟剖析, 让我们认识到, 戒烟并不是一个关于**意志力**的问题. 吸烟的本质其实是一个**尼古丁中毒 + 洗脑**的过程, 只有认识到了问题的**本质**, 我们才能有机会去解决问题.\\n- 文章纯手打, 抛砖引玉, 如有错误还请评论区指正, 先行谢过了:)\\n\\n## 几乎没有人会喜欢自己的第一支烟\\n- 还记得你的第一支烟吗? 很少有人会说第一支烟是生理感官层面的**享受**. 我们的身体作为一个进化了亿万年的智慧结晶, 有着趋利避害的生理机制. 刚出生的婴儿会恐惧毒蛇这样的生物, 是因为我们已经把对毒蛇的恐惧刻进了DNA中. 同样**绝大多数人抽的第一支烟都有种窒息想吐的感觉**, 这是因为我们的身体在警告我们, 一定要远离这玩意.\\n- 无论你的第一支烟是在什么情况下抽的, 对于绝大多数人来说, 第一支烟的经验大多是痛苦的. 很少有人会相信, 这辣嗓子又呛人的玩意会有成瘾性. 或许是为了扮成熟、亦或许是为了所谓的快速建立社交关系, 我们慢慢地压制身体对烟味的排斥反应. 就这样一步一步, 我们沾染上了尼古丁毒瘾, 被尼古丁戒断症状控制, 疯狂的想去点燃下一支烟.\\n\\n\\n## 烟民越来越难了\\n- 随着社会的进步及发展, 大多数人有了\\\"吸烟有害健康\\\"的认识. 禁烟区越来越多, 留给烟民的空间已经越来越少. 抽过烟后, 有些烟民会习惯性的嚼起口香糖, 只为掩盖烟臭味. 其实大多数烟民在抽完烟后, 自己也会讨厌身上的烟臭味, 这种烟臭味往往很难去除, 对身边的人会造成三手烟的伤害.\\n- 在2022年四五月份的魔都, 由于封控, 有些烟民是买不到烟的. 这种情况下烟民们受到了身心的双重打击, 有的人甚至点起了卷纸, 只为体验一下吞云吐雾的感觉, 然后顺利的呛到了嗓子, 得不偿失.\\n- 抽烟的过程作者做了一个生动的比喻, 就像你应该穿42码的鞋子, 却穿了38码的, 抽烟的动作就是把小鞋脱下的那几分钟. 被烟瘾奴役时, 就是又穿回了那双38码的鞋子. 如果有的选, 我想大多数烟民都想回到那个未曾沾染烟瘾的状态, 做个非吸烟者.\\n\\n## 烟民已经中毒了, 认识尼古丁戒断症状\\n- \\\"戒断症状\\\"这个词往往都用在毒品上面, 亚伦对烟草中的尼古丁定位跟海洛因差不多, 都是毒品. 当沾染上毒品后, 得不到毒品, 才会出现令人十分不适的\\\"戒断症状\\\", 只有所沾染上的毒品得到补充, \\\"戒断症状\\\"才能有所缓解. 但这种缓解无疑依旧是饮鸩止渴, 如果不做个了断, 一辈子都会生活在**尼古丁戒断症状**的阴影中难以自拔.\\n- 想象一下, 海洛因上瘾者如果得不到海洛因, 该有多么痛苦, 而当他们终于得到海洛因注射时, 痛苦就会缓解. 你能把这种暂时的缓解称为享受吗? 非海洛因上瘾者绝不会有这样的**享受**, 因为他们**原本就没有痛苦**. 痛苦是由海洛因导致的. 尼古丁的戒断症状就是会让人感觉到空虚, 烟民们在高兴的时候想点支烟、在难过的时候想点支烟、在压力大的时候也想点支烟、在空虚的时候还想点支烟. 殊不知这四种情绪已经包含了人的绝大多数时间, 抽烟并不能填补空虚, 只会造成空虚.\\n- 好消息是, 如果你决定戒烟, 尼古丁生理上的戒断症状只会持续**仅仅两周左右**. 体内残留的尼古丁, 会被我们的身体快速地分解代谢掉, 只要你停止摄入尼古丁, 半个月后我们的身体就会摆脱尼古丁的戒断症状.\\n\\n## 抽烟的连锁反应--洗脑\\n- 不要听他们说了什么, 多去看看他们做了什么. \\n- 烟草公司在它们的产品宣传中, 总会强调它们生产的香烟是高品质的, 但人们为什么要去关心一种毒药的质量是好还是坏? 的确, 明面上的烟草广告已经被国家禁烟部门明令禁止, 我们看不到. 但是各种电影电视里的软广告, 时刻在向懵懂的青少年们传达着这样一个信息--\\\"看这些明星网红多成熟多酷\\\", 就这样这些有影响力的明星抽烟的动作被无数不谙世事的青少年们模仿了. 但事实是抽烟一点也不酷, 只是沾染了尼古丁这种毒品而已, 这就是一个符合相关利益集团利益的大型的**洗脑陷阱**.\\n\\n- <<这书能让你戒烟>>中有这样一个统计: \\\"*2002年，英美两国的吸烟人口比率分别为22%和26%，而中国更是高达31%，其中大部分人的生活并不富裕，只能节省基本生活费满足烟瘾。全世界每年都有近500万人死于吸烟引发的各种疾病。吸烟是现代社会的头号杀手，同时又是盈利最高的行业之一。仅在英国，政府每年因烟草销售获取的利税额就高达80亿英镑。正是由于政府的姑息纵容，各大烟草公司才能用虚伪的宣传毒害人们的思想，继续赚取肮脏的黑钱。*\\\"\\n\\n- 利益集团做了什么? 利益集团会在每盒烟上印上\\\"吸烟有害健康\\\"的字样. 但这样的戒烟宣传对吸烟者完全没有任何帮助, 因为**宣传的理念和方式完全不对**. 这样的宣传只会增加吸烟者的**恐惧**, 而恐惧只会让烟民对吸烟产生更强的依赖性. \\n- 利益集团会在电视、手机、各大杂志等媒体上进行戒烟宣传, 然后告诉人们\\\"我们已经警告过你们了, 是否吸烟只是你自己的选择.\\\"然而事实真的是这样吗? 烟民们完全没有选择, 正如海洛因上瘾者完全完全没有选择一样. 发他们不是自己决定染上烟瘾的, 而是不幸掉进了一个符合利益集团利益的陷阱. 吸烟会让平均寿命变短、会让烟民损失大量金钱、会让更多的人吸烟, 这就是一个大型的洗脑连锁反应, 而利益的箭头究竟指向何方? 这确实是一个值得每一个烟民思考的问题.\\n\\n## 认识那条尼古丁毒虫, 离开它\\n- 下面是<<这书能让你戒烟>>的作者亚伦, 一个33年老烟枪的戒烟感悟:\\n- \\\"*我们觉得生活充满了压力。事实并不是这样的，真正的压力早已远离我们的生活。现在你离开家时，完全不必担心会被野兽袭击，也不必操心能否吃到下一顿饭，能否找到遮风避雨的地方睡觉。想象一下野生动物的生活。兔子每次从洞里钻出来，都是冒着生命危险，但是兔子能够应付这种危险。它能分泌肾上腺素等一系列应激激素，提高逃离危险的能力——我们也能。事实上，对于任何生物来说，幼年都是生存压力最大的时期。但是经过30亿年的自然选择，我们已经拥有了化解生存压力的能力。第二次世界大战爆发时我刚五岁，我们居住的城市遭到轰炸，我和父母分开长达两年之久。我被分配到一间集体宿舍，其他孩子对我并不好。那是我生命中的一段阴暗经历，但我还是撑了下来。那段经历并没有对我造成任何永久性的伤害，相反，我变得更加坚强了。回首过去，我唯一对付不了的，就是烟瘾的奴役。总说生活并不仅仅是健康那么简单，吸烟饮酒都是生活的一部分。现在我已经意识到，当年的我实在愚不可及。只有身心都保持健康状态，你才能享受生活的高潮，直面生活的低谷。我们总是混淆责任与压力。只有当你身心孱弱，无力承担责任时，责任才会转化成压力。*\\\"\\n\\n- 我们不妨把戒烟过程当成一场**地球online游戏**. 把尼古丁毒瘾想象成一条**毒虫**, 正在你的身体里肆虐. 只要两三个星期不吸烟, 你就可以让这条毒虫饿死赢得这场游戏. 这段时间里, 这条尼古丁毒虫会不断诱惑你点上一支烟, 维持它的生命. \\n- 除此之外, 这条毒虫还会努力让你感到痛苦. 有时你的朋友会递过来一支烟, 如果你忘了自己**已经戒烟成功**, 就有可能接过来点上. 它会让你产生**被剥夺**的感觉. 做好**心理准备**, 无论受到什么样的诱惑, 你心里都要清楚, **你已经饿了它三四天, 哪怕一口烟都让它觉得十分宝贵. 为了得到这一口烟, 它会想尽办法腐蚀你的潜意识, 让你质疑当初戒烟的决定. 这都是毒虫的把戏, 只要你能经受住诱惑, 就会给它严重的打击, 增加战胜这条毒虫的概率.**\\n- 你必须尽快杀死**身体里的小毒虫(让尼古丁毒瘾自行消散)**, 之后就是**潜意识里的大毒虫(摆脱洗脑的影响)**. \\n- 如果你也决定戒烟, 就不要犹豫, 因为犹豫只会导致痛苦. 上一支烟就是你的**最后一支烟**, 现在你已经是个非吸烟者! 哪怕一次戒烟失败, 也要有开始下一次戒烟之旅的勇气. \\n\\n\\n\\n\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/058a81d0afa449329921ae83dbb4db41~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## 结语，一起打卡戒烟\\n- 2022年无论如何已经离我们远去, 如果你也想在2023年戒烟, 不妨点赞此文, 评论区打卡戒烟, 我们相互鼓励一起在路上~\\n- 希望看到此文的朋友们都能成功戒烟🙏🏻~\\n- 请记住, 在戒烟的路上你并不孤单, **失败并不可耻, 不去尝试却是愚蠢的~**\\n\\n\\n#### 发文不易, 喜欢点赞的人更有好运气👍 :), 定期更新+关注不迷路~\\n\\nps：欢迎加入笔者18年建立的研究iOS审核及前沿技术的三千人扣群：662339934，坑位有限，备注“掘金网友”可被群管通过~\\n\\n「回顾2022，展望2023，我正在参与[2022年终总结征文大赛活动](https://juejin.cn/post/7172462429929111559 \\\"https://juejin.cn/post/7172462429929111559\\\")」\\n\\n",
        "tags": [
            "前端",
            "后端",
            "电子书"
        ]
    },
    {
        "article_id": "7181729461274935333",
        "cover_image": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae92393cad3f4ca48d9671436fec6b70~tplv-k3u1fbpfcp-watermark.image?",
        "title": "裁员、面试、阳过、副业｜2022 多舛的一年，希望 2023 一切顺利",
        "brief": "2022 多舛的一年，经历了裁员，找工作，阳过，开始寻求新的方向。 翻开掘金，才发现离上次发文章已经过了 8 个月，今年经历的事情太多，也让我有了新的思考。",
        "user_name": "番茄先森",
        "view_count": 2861,
        "collect_count": 7,
        "comment_count": 24,
        "avatar": "https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/18/1718c0c372ca9c04~tplv-t2oaga2asx-image.image",
        "category": "前端",
        "content": "---\\ntheme: smartblue\\n---\\n「回顾2022，展望2023，我正在参与[2022年终总结征文大赛活动](https://juejin.cn/post/7172462429929111559 \\\"https://juejin.cn/post/7172462429929111559\\\")」\\n## 前言\\n\\n2022 多舛的一年，经历了裁员，找工作，阳过，开始寻求新的方向。\\n翻开掘金，才发现离上次发文章已经过了 8 个月，今年经历的事情太多，也让我有了新的思考，马上到 2023 也是离我正式到 30 岁越来越近，都说三十而立，但是为什么感觉恐惧更多。\\n\\n## 谈谈今年吧-工作\\n\\n去年进入了某大厂工作，本以为自己要稳定下来，好好努力，因为部门的人都很 nice，技术氛围也很 nice，没想到裁员的信息来的这么快。3月份，北京疫情，大家都在居家办公，突然同事转发的一条脉脉的信息让我震惊，说是我们事业群将要裁员，顿时心里慌的不行，但是依旧心存侥幸心想毕竟我们前端在组内只有 3 个人，应该不会轮到我们，但是没想到居家办公返回职场的第一天，我同事就被 HR 叫了过去，没错他被裁了。\\n\\n这一波裁员之后，大家人心惶惶，因为不知道下一波将会到什么时候到来。稳定了 3 个月后，依旧是北京疫情，依旧是居家办公，依旧是同事的一条脉脉信息，第二波裁员来了！这次走的人不多，上面给的信息也是留下来的人将会并入到新的业务线，开始新的征程，大家悬着的心也终于落了下来，开始了对新的业务线的展望，并对新的业务进行调研，一切都在往好的方向发展。\\n\\n一般按照剧情，一切的平静都是暴风雨的前兆，然后会有幸运儿躲避暴风雨，没错！我一直运气没有那么好，在大家都沉浸在并入新业务线如何如何时，晴天霹雳的消息突然发来，新的业务线只能接受一部分人，有些部门将会直接解散，这些人会经过挑选来选择谁会留下，不错，我们部门解散了。在老大宣布这个事情的时候，看到了老大的无奈，老大鞠躬跟我们道歉说对不起我们没办法把我们留下来的时候，听到了他的哽咽，因为他也没办法，他也是被裁员中的一员，他没有了一点话语权，剩下的就只能自己听天由命。\\n\\n接下来就是复习找工作，然后等着留下来的名单，虽然知道留下来的可能性不大，但是还是希望自己是那个幸运儿，生活依旧没有给我满意的答案，留下来的名单中没有我！然后开始释怀，复习，准备活水，但是不知道为什么活水的前端岗位少的可怜，到最后后端们几乎都活水成功了，而我依旧没有。lastday 那天，同事们帮我拿着东西一块去人事大厅，他们办活水，我办离职，那天感觉很不好......\\n\\n## 谈谈今年吧-面试\\n\\n都说今年行情不好，没想到是真的不好！\\n\\n本来心里就有准备，心想拿着补偿金，怎么着还找不到工作？所以前期放松心情，回了一趟老家，陪陪父母，然后准备准备。\\n\\n今年的大厂都在降本增效，一个岗位有超级多的人在应聘，有些面试感觉很好，但是莫名其妙就没过，有些问的问题可能连面试官都答不上来。感觉大厂无望后，就开始了海投，然而随着时间的推移慢慢的从之前的一个星期能约到 4 个面试，到后来一个星期能约到 1 个面试，再到后来一个星期一个都没有，期间找了猎头，朋友，一切能动用的资源。这其中也收到过 offer，但是跟自己预想差太多就拒绝了，还有些 offer 流程走着走着 hc 就没有了。\\n\\n当海投的时候你就会发现，各个公司面试官的水平真的是差强人意，有些公司的面试官技术水平真的差，你回答的他听不懂，他问的你听不懂，然后你说的他还要质疑，质疑之后你跟他解释，他依旧听不明白，最主要的是他面试却给你不通过，很费解！！！但是有些面试还是很不多的，这些都偏在外企或者一些中厂，后期我会整理一些发出来。\\n\\n经历了 3 个多月，总算是收到了还算不错的 offer！\\n\\n## 谈谈今年吧-生活\\n\\n开始减肥了，之前锻炼确实瘦下来了，但是后来懒没去锻炼，体重又蹭蹭的往上长，家里的亲戚朋友都在让我注重减肥，我觉得也有必要继续锻炼了，少吃碳水，多运动，管住嘴迈开腿！\\n\\n阳了。高烧到 39.5，虽说周围都是小洋人，心里做好了早晚都要阳的准备，但是在得的时候，还有有些慌张的。幸亏之前备好了药，但是难受程度还是要比感冒难受的很多，而且得完之后虚的不行，嗓子如刀割一般。杨康后现在有时会感觉胸有些不舒服，准备还是去医院拍个 CT 看一下。\\n\\n## 谈谈今年吧-副业\\n\\n其实从很早就有这个想法了，只是不知道干什么，今年 3 月份第一波裁员的时候，就觉得是时候提上日程了。所以就想一个成本低的副业，就是拍视频，从最开始不知道怎么拍，怎么剪，到现在稍微有些自己想法，虽然粉丝不多，但是也是迈出的第一步，有没有也做视频的可以在评论区一块交流一下！\\n\\n![飞书20221227-193236.jpg](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7558912d6374448b9a1dea0fef35e790~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n## 谈谈三十岁\\n\\n虽说我的生日较小，刚过了 29 岁生日没多长时间，但是 30 岁这个节骨眼却马上来了，转眼就要 30 了，以前总觉得自己是个二十多岁的小屁孩，现在也是父母口中的大人了，说真的会对即将到来的 30 岁惶恐，说不上来的感受，可能矫情了！\\n\\n## 明年的计划\\n\\n1. 把短视频账号做好，先定一个小目标 1k 粉丝\\n2. 算法继续做起来，长久的过程，出一个关于算法的文章\\n3. 三十而立，希望能领悟更多\\n4. 摄影 拍！拍！拍！\\n5. 体重降到正常水平\\n6. 希望 2023 年一切顺利\\n",
        "tags": [
            "年终总结",
            "面试",
            "前端"
        ]
    },
    {
        "article_id": "7156417273463799838",
        "cover_image": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/84213553ce23482f8520de30c442790d~tplv-k3u1fbpfcp-watermark.image?",
        "title": "超强的苹果官网滚动文字特效实现",
        "brief": "每年的苹果新产品发布，其官网都会配套更新相应的单页滚动产品介绍页。其中的动画特效都非常有意思，今年 iPhone 14 Pro 的介绍页不例外。 最近，刚好有朋友问到，其对官网的一段文字特效特别感兴趣",
        "user_name": "chokcoco",
        "view_count": 25360,
        "collect_count": 366,
        "comment_count": 43,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/d5909b97177d58b77d02a83a620abd18~300x300.image",
        "category": "前端",
        "content": "每年的苹果新产品发布，其官网都会配套更新相应的单页滚动产品介绍页。其中的动画特效都非常有意思，今年 [iPhone 14 Pro](https://www.apple.com.cn/iphone-14-pro/) 的介绍页不例外。\\n\\n最近，刚好有朋友问到，其对官网的一段文字特效特别感兴趣，看适用简单却不知从何下手，我们来看看：\\n\\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f7265f9a5e664794b2d91de85ab271af~tplv-k3u1fbpfcp-watermark.image?)\\n\\n整个动画大致是，随着页面的向下滚动，整个文字从无到出现，再经历一轮渐变色的变化，最后再逐渐消失。\\n\\n本文，就将介绍 2 种使用 CSS 实现该效果的方式。\\n\\n## 使用 background-clip 实现\\n\\n第一种方式是借助 `background-clip`。\\n\\n`background-clip`：background-clip 设置元素的背景（背景图片或颜色）是否延伸到边框、内边距盒子、内容盒子下面。\\n\\n而 `background-clip: text` 可以实现背景被裁剪成文字的前景色。使用了这个属性的意思是，以区块内的文字作为裁剪区域向外裁剪，文字的背景即为区块的背景，文字之外的区域都将被裁剪掉。\\n\\n看个最简单的 Demo ，没有使用 `background-clip:text` : \\n\\n``` HTML\\n<div>Clip</div>\\n\\n<style>\\ndiv {\\n  font-size: 180px;\\n  font-weight: bold;\\n  color: deeppink;\\n  background: url($img) no-repeat center center;\\n  background-size: cover;\\n}\\n</style>\\n```\\n效果如下：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b7643b7ee274f1593984b7029a96ac1~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n[CodePen Demo](https://codepen.io/Chokcoco/pen/WjOBzB)\\n\\n### 使用 `background-clip:text`\\n\\n我们稍微改造下上面的代码，添加 `background-clip:text`：\\n\\n```CSS\\ndiv {\\n  font-size: 180px;\\n  font-weight: bold;\\n  color: deeppink;\\n  background: url($img) no-repeat center center;\\n  background-size: cover;\\n  background-clip: text;\\n}\\n```\\n效果如下：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f94617c535c7411e8b964773f2f9d37c~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n看到这里，可能有人就纳闷了，![wtf](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/23e5e2660e01486bb25247fcb8e41986~tplv-k3u1fbpfcp-zoom-1.image)，啥玩意呢，这不就是文字设置 `color` 属性嘛。\\n\\n### 将文字设为透明 `color: transparent` \\n\\n别急！当然还有更有意思的，上面由于文字设置了颜色，挡住了 div 块的背景，如果将文字设置为透明呢？文字是可以设置为透明的 `color: transparent` 。\\n\\n```CSS\\ndiv {\\n  color: transparent;\\n  background-clip: text;\\n}\\n```\\n效果如下：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e11bbcb5bb9401f96e72062e232ea84~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n[CodePen Demo - background-clip: text](https://codepen.io/Chokcoco/pen/oWwRmE)\\n\\n通过将文字设置为透明，原本 div 的背景就显现出来了，而文字以外的区域全部被裁剪了，这就是 `background-clip: text` 的作用。\\n\\n因此，对于上述效果，我们只需要实现一个**从透明到渐变色到透明**的渐变背景即可，随着鼠标的滚动移动背景的 `background-position` 即可！\\n\\n有了上面的铺垫，我们很容易的实现上述的苹果官网的文字效果。（先不考虑滚动的话）\\n\\n看看代码：\\n\\n```HTML\\n<div class=\\\"g-wrap\\\">\\n    <p>灵动的 iPhone 新玩法，迎面而来。重大的安全新功能，为拯救生命而设计。创新的 4800 万像素主摄，让细节纤毫毕现。更有 iPhone 芯片中的速度之王，为一切提供强大原动力。  \\n    </p>\\n</div>\\n```\\n```CSS\\n.g-wrap {\\n    background: #000;\\n    \\n    p {\\n        width: 800px;\\n        color: transparent;\\n        background: linear-gradient(-4deg, transparent, transparent 25%, #ffb6ff, #b344ff,transparent 75%, transparent);\\n        background-clip: text;\\n        background-size: 100% 400%;\\n        background-position: center 0;\\n        animation: textScroll 6s infinite linear alternate;\\n    }    \\n}\\n\\n@keyframes textScroll {\\n    100% {\\n        background-position: center 100%;\\n    }\\n}\\n```\\n\\n我们这里核心的就是借助了 `linear-gradient(-4deg, transparent, transparent 25%, #ffb6ff, #b344ff,transparent 75%, transparent)` 这个渐变背景，实现一个**从透明到渐变色到透明**的渐变背景，配合了 `background-clip: text`。\\n\\n再利用动画，控制背景的 `background-position`，这样一个文字渐现再渐隐的文字动画就实现了：\\n\\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf228ba5fb264b0da0fd9959b10df590~tplv-k3u1fbpfcp-watermark.image?)\\n\\n[CodePen Demo -- iPhone 14 Pro Text Animation | background-clip: text](https://codepen.io/Chokcoco/pen/NWMoQXx)\\n\\n## 使用 mix-blend-mode 实现\\n\\n上面一种方式很好，这里再介绍另外一种使用混合模式 `mix-blend-mode` 实现的方式。\\n\\n假设，我们先实现这样一幅黑底白字的结构：\\n\\n```HTML\\n<div class=\\\"text\\\">灵动的 iPhone 新玩法，迎面而来。重大的安全新功能，为拯救生命而设计。创新的 4800 万像素主摄，让细节纤毫毕现。更有 iPhone 芯片中的速度之王，为一切提供强大原动力。\\n</div>\\n```\\n```CSS\\n.text {\\n    color: #fff;\\n    background: #000;\\n}\\n```\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35999e9dd6d74226b776edecf912f6df~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n再另外实现这样一个渐变背景，从**黑色到渐变色（#ffb6ff 到 #b344ff）到黑色的渐变色**：\\n\\n```HTML\\n<div class=\\\"g-wrap\\\">\\n    <div class=\\\"text\\\">灵动的 iPhone 新玩法，迎面而来。重大的安全新功能，为拯救生命而设计。创新的 4800 万像素主摄，让细节纤毫毕现。更有 iPhone 芯片中的速度之王，为一切提供强大原动力。\\n        <div class=\\\"bg\\\"></div>\\n    </div>\\n</div>\\n```\\n```CSS\\n.text {\\n    position: relative;\\n    color: #fff;\\n    background: #000;\\n}\\n.bg {\\n    position: absolute;\\n    top: 0;\\n    left: 0;\\n    right: 0;\\n    width: 100%;\\n    height: 400%;\\n    background: linear-gradient(-3deg, #000, #000 25%, #ffb6ff 30%, #ffb6ff, #b344ff, #b344ff 70%, #000 75%, #000);\\n}\\n```\\n\\n`.bg` 大概是长这样，相对于 `.text` 而言，其高度是其 4 倍：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/44dae418c68b4ed0baa69c4d44ff089d~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n这两个图形叠加在一起会是咋样？应该不会有太多**化学反应**：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b3fdd89b8e4e46f4a942439068c8b58c~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n我们给 `.bg` 加上一个上下移动的动画，我们看看效果：\\n\\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1926cd81bb21447a8e30cd07ba09a022~tplv-k3u1fbpfcp-watermark.image?)\\n\\n好像没什么东西？文字也被挡住了。但是！如果在这里，我们运用上混合模式，那效果就完全不一样了，这里，我们会运用到 `mix-blend-mode: darken`。\\n\\n```CSS\\n.bg {\\n    //...\\n    mix-blend-mode: darken\\n}\\n```\\n\\n再看看效果：\\n\\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a7483047deb144c48981560468843e11~tplv-k3u1fbpfcp-watermark.image?)\\n\\nWow，借助不同的混合模式，我们可以实现不同的颜色叠加效果。这里 `mix-blend-mode: darken` 的作用是，只有白色文字部分会显现出上层的 `.bg` 的颜色，而黑色背景部分与上层背景叠加的颜色仍旧为黑色，与 `background-clip: text` 有异曲同工之妙。\\n\\n再简单的借助 `overflow: hidden`，裁剪掉 `.text` 元素外的背景移动，整个动画就实现了。\\n\\n完整的代码如下：\\n\\n```HTML\\n<div class=\\\"g-wrap\\\">\\n    <div class=\\\"text\\\">灵动的 iPhone 新玩法，迎面而来。重大的安全新功能，为拯救生命而设计。创新的 4800 万像素主摄，让细节纤毫毕现。更有 iPhone 芯片中的速度之王，为一切提供强大原动力。\\n        <div class=\\\"bg\\\"></div>\\n    </div>\\n</div>\\n```\\n```CSS\\n.g-wrap {\\n    width: 100vw;\\n    height: 100vh;\\n    background: #000;\\n    \\n    .text {\\n        position: relative;\\n        color: transparent;\\n        color: #fff;\\n        background: #000;\\n        overflow: hidden;\\n    }    \\n    \\n    .bg {\\n        position: absolute;\\n        top: 0;\\n        left: 0;\\n        right: 0;\\n        width: 100%;\\n        height: 400%;\\n        background: linear-gradient(-3deg, #000, #000 25%, #ffb6ff 30%, #ffb6ff, #b344ff, #b344ff 70%, #000 75%, #000);\\n        mix-blend-mode: darken;\\n        animation: textScroll 6s infinite linear alternate;\\n    }\\n}\\n@keyframes textScroll {\\n    100% {\\n        transform: translate(0, -75%);\\n    }\\n}\\n```\\n\\n这样，借助混合模式，我们也实现了题目的文字特效：\\n\\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab3b62075ea043f388546f8802833ebd~tplv-k3u1fbpfcp-watermark.image?)\\n\\n[CodePen Demo -- iPhone 14 Pro Text Animation | mix-blend-mode](https://codepen.io/Chokcoco/pen/jOxJLpM)\\n\\n## 结合滚动实现动画\\n\\n当然，原动画的实现是结合页面的滚动实现的。\\n\\n在之前，我介绍了 CSS 最新的特性 `@scroll-timeline`，譬如这两篇文章：\\n\\n+ [革命性创新，动画杀手锏 @scroll-timeline](https://github.com/chokcoco/iCSS/issues/166)\\n+ [超酷炫的转场动画？CSS 轻松拿下！](https://github.com/chokcoco/iCSS/issues/191)\\n\\n`@scroll-timeline` 能够设定一个动画的开始和结束由滚动容器内的滚动进度决定，而不是由时间决定。\\n\\n意思是，我们可以定义一个动画效果，该动画的开始和结束可以通过容器的滚动来进行控制。\\n\\n但是！伤心的是，这个如此好的特性，**最近已经被规范废弃，已经不再推荐使用了**：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97edb95f0d4642de97682bfc0d6308ea~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n这里，我们使用传统的方法，那就必须得借助了 JavaScript 了，JavaScript 结合滚动的部分不是本文的重点，对于页面滚动配合动画时间轴，我们通常会使用 GSAP。\\n\\n我们结合上述的混合模式的方法，很容易得到结合页面滚动的完整代码：\\n\\n```HTML\\n<div class=\\\"g-wrap\\\">\\n    <div class=\\\"text\\\">灵动的 iPhone 新玩法，迎面而来。重大的安全新功能，为拯救生命而设计。创新的 4800 万像素主摄，让细节纤毫毕现。更有 iPhone 芯片中的速度之王，为一切提供强大原动力。\\n        <div class=\\\"bg\\\"></div>\\n    </div>\\n</div>\\n<div class=\\\"g-scroll\\\"></div>\\n```\\n```CSS\\n.g-wrap {\\n    position: fixed;\\n    top: 0;\\n    left: 0;\\n    display: flex;\\n    width: 100vw;\\n    height: 100vh;\\n    background: #000;\\n    \\n    .text {\\n        position: relative;\\n        width: 800px;\\n        color: #fff;\\n        background: #000;\\n        overflow: hidden;\\n    }    \\n    \\n    .bg {\\n        position: absolute;\\n        top: 0;\\n        left: 0;\\n        right: 0;\\n        width: 100%;\\n        height: 400%;\\n        background: linear-gradient(-3deg, #000, #000 25%, #ffb6ff, #b344ff, #000 75%, #000);\\n        mix-blend-mode: darken;\\n    }\\n}\\n\\n.g-scroll {\\n    position: relative;\\n    width: 100vw;\\n    height: 400vw;\\n}\\n```\\n```Javascript\\ngsap.timeline({\\n    scrollTrigger: {\\n        trigger: \\\".g-scroll\\\",\\n        start: \\\"top top\\\",\\n        end: \\\"bottom bottom\\\",\\n        scrub: 1\\n    }\\n}).fromTo(\\\".bg\\\", { y: 0 }, { y: \\\"-75%\\\" }, 0);\\n```\\n\\n可以看到，唯一的不同之处，就是利用了 `gsap.timeline` 结合滚动容器，触发动画。\\n\\n效果如下：\\n\\n\\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea6e3b15316f4daaa687becbfe7e451b~tplv-k3u1fbpfcp-watermark.image?)\\n\\n[CodePen Demo -- iPhone 14 Pro Text Animation | GSAP](https://codepen.io/Chokcoco/pen/GRdzVXK)\\n\\n## 最后\\n\\n好了，本文到此结束，希望本文对你有所帮助 :)\\n\\n更多精彩 CSS 技术文章汇总在我的 [Github -- iCSS](https://github.com/chokcoco/iCSS) ，持续更新，欢迎点个 star 订阅收藏。\\n\\n如果还有什么疑问或者建议，可以多多交流，原创文章，文笔有限，才疏学浅，文中若有不正之处，万望告知。",
        "tags": [
            "前端",
            "CSS",
            "JavaScript"
        ]
    },
    {
        "article_id": "7167635563904761887",
        "cover_image": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b813efd1bfaa4933904137d14f1db4ec~tplv-k3u1fbpfcp-watermark.image?",
        "title": "Ant Design 5.0 正式发布了，你要升级吗",
        "brief": "antd正式发布了5.0版本，笔者是antd重度用户，公司的B端业务组件就是基于antd定制开发的，在5.0发布之前，也在一直在关注beta版本，让我们一起看看5.0在技术上引入了什么新的变化吧",
        "user_name": "秋染蒹葭",
        "view_count": 8247,
        "collect_count": 15,
        "comment_count": 15,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/72916df0d0bbea4bbca9d5ce701e1e9e~300x300.image",
        "category": "前端",
        "content": "***本文正在参加[「金石计划 . 瓜分6万现金大奖」](https://juejin.cn/post/7162096952883019783 \\\"https://juejin.cn/post/7162096952883019783\\\")***\\n\\n周五了，这周忙里偷闲去了两天桐庐，淡季加上工作日，人好少。而且作为一个标准的江南小城，山青水秀，慢生活的基调就会让人整个松弛下来，即使就简单的在酒店附近走走，就已经是很舒服了。\\n\\n好了，闲话少说，昨天antd正式发布了5.0版本，笔者是antd重度用户，公司的B端业务组件就是基于antd定制开发的，在5.0发布之前，也在一直在关注beta版本，让我们一起看看5.0在技术上引入了什么新的变化吧\\n\\n\\n本文不对设计的变化做评价，仅在技术选型、工程化等技术角度进行分析\\n\\n## css-in-js\\nantd动态主题使用了css-in-js方案，抛弃了一直以来的less，放弃了css variables能力，这算是5.0引入的最大变化了，说到css-in-js旧不得不说最近关于css-in-js的一些争议\\n\\n### css-in-js争议\\n最近由于Sam的那篇[Why We're Breaking Up with CSS-in-JS](https://dev.to/srmagura/why-were-breaking-up-wiht-css-in-js-4g9b)，直接将css-in-js推到了风口浪尖上，其实这个时候发布了强依赖css-in-js的5.0多少有些尴尬，官方也没有对这个问题进行过多的说明，只是复述了一下使用场景\\n\\n归根结底，还是Sam这篇文章写的太客观，作为[Emotion](https://emotion.sh/docs/introduction)主要开发者，对css-in-js的有着更深的理解，很客观的说明了方案的优缺点，最后抛出弃用css-in-js最核心的原因：性能问题，这一点是无解的，css-in-js需要在react重渲染组件时序列化className，这就不可避免地带来运行时的性能损失\\n\\n目前作者使用的方案是css module，除了在css中直接使用js变量需要特定的方式兼容外，其他css-in-js提供的有点，都可以直接兼容，并且没有性能的损失，这应该就是作者弃用css-in-js的核心原因了\\n\\n### ant design 5.0用css-in-js做了什么\\n对于动态定制主题而言，关键也是在于如何在性能和维护成本之间做取舍，css-in-js方案可以直接在样式中使用js变量，这对定制主题而言确实可以省掉一些模版代码。and design 5.0使用了[@ant-design/cssinjs](https://github.com/ant-design/cssinjs)作为自己的css-in-js方案，打开文档去看看，官方说法也很明确\\n> It's a subset of Emotion with design token logic wrapper.\\n\\n是基于`Emotion`定制了一部分能力的，直接依赖了`@emotion/hash`, `@emotion/unitless`，文档上也直接推荐使用`Emotion`，而`@ant-design/cssinjs`通过牺牲动态性来获取更高的缓存效率，从而减少运行时的性能损耗，`@ant-design/cssinjs`提供的DerivativeToken能力也是这一版本一个亮点，可以简化一些动态主题的配置，会在下一节进行介绍\\n\\n另外使用了css-in-js后，天然支持TreeShaking，不需要再配置插件了\\n\\n## Design Token\\n在ant design v4版本是，笔者经历的使用antd的ToB项目中，很多是需要主题定制的,需要动态主题的地方目前主要还是定义css变量的方式，比如：\\n```css\\ncolor: var(--color);\\n```\\n通过将`--color`挂在到`:root`的方式，进行动态主题配置，在v5版本的介绍中，通过Design Token 模型可以派生出几乎所有需要定制的颜色、间距、大小等。且利用上文提到的css-in-js方案，也不再需要和v4一样定义一堆挂在到`:root`上的变量了，确实简化了很多动态主题的配置，这里贴上一张官方的配图\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e90ebc9f484a43f1bfac36b0815b1b96~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n除了整体的可定制，各个组件也可以通过外层的配置来实现样式定制能力,这里就贴一下官方的demo\\n```js\\n<ConfigProvider\\n    theme={{\\n      components: {\\n        Radio: {\\n          colorPrimary: '#00b96b',\\n        },\\n      },\\n    }}\\n  >\\n    <Radio>Radio</Radio>\\n    <Checkbox>Checkbox</Checkbox>\\n  </ConfigProvider>\\n```\\n## 总结\\n作为antd的深度用户，笔者也会慢慢将自己基于antd的内部组件库慢慢开始升级，目前来看相对痛点的就是自定义主题的升级，因为很难复用旧的逻辑，这点需要先利用v5的能力，保留旧的方案，慢慢替换为design token的方式；另外，还是需要观察一下css-in-js的性能，虽然是B端项目，用户体验上也是不能打折。\\n\\n**参考资料**\\n[Ant Design 5.0 正式发布](https://mp.weixin.qq.com/s/qL7UMdHicrk-4b1vYVSIWQ)\\n\\n***本文正在参加[「金石计划 . 瓜分6万现金大奖」](https://juejin.cn/post/7162096952883019783 \\\"https://juejin.cn/post/7162096952883019783\\\")***",
        "tags": [
            "前端",
            "Ant Design",
            "掘金·金石计划"
        ]
    },
    {
        "article_id": "7167673879693885476",
        "cover_image": "",
        "title": "13个很酷但很少有人知道的HTML元素",
        "brief": "本文正在参加「金石计划 . 瓜分6万现金大奖」 1. meter & progress 元素是显示进度条的语义正确方式。 除了在已知范围内显示标量测量值外，它还允许我们指定值的低，高和最佳范围。 效果",
        "user_name": "海拥",
        "view_count": 5427,
        "collect_count": 333,
        "comment_count": 12,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/27c5a90fca52beadf8a2dc4bc0efb3f8~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: smartblue\\nhighlight: a11y-dark\\n---\\n\\n\\n**本文正在参加[「金石计划 . 瓜分6万现金大奖」](https://juejin.cn/post/7162096952883019783 \\\"https://juejin.cn/post/7162096952883019783\\\")**\\n\\n> - 原文链接：https://dev.to/ruppysuppy/7-cool-html-elements-nobody-uses-330c\\n> https://dev.to/ruppysuppy/6-cool-things-boring-old-html-can-do-3160\\n> - 原文作者：[塔帕约蒂·博斯](https://dev.to/ruppysuppy)\\n\\n## 1. `meter` & `progress`\\n\\n元素是显示进度条的语义正确方式。\\n\\n除了在已知范围内显示标量测量值外，它还允许我们指定值的**低**，**高**和**最佳**范围。\\n\\n\\n```html\\n<meter\\n  min=\\\"0\\\"\\n  max=\\\"100\\\"\\n  low=\\\"25\\\"\\n  high=\\\"75\\\"\\n  optimum=\\\"80\\\"\\n  value=\\\"50\\\"\\n></meter>\\n```\\n\\n效果\\n\\n\\n\\n![4znrursszrxsuiqqmauj.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ca68cd5a3414e01a9cfb4272a392062~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## 2. `sup` & `sub`\\n\\n我们可以在文档中添加**上标**和**下标**。``x²``sup``x₀``sub\\n\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c2f7ad7475114d4d95146a357f561a94~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/16544dc295fa4ab099f11a085cf5506f~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## 3. `datalist`\\n\\n`datalist`允许我们将自动完成建议添加到元素中\\n\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ddd4b744c7dd467299e0def0f1cdaa32~tplv-k3u1fbpfcp-watermark.image?)\\n\\n### 注意\\n\\n1.  建议不仅限于文本，还可以与**颜色**，**日期**，**时间**甚至**范围**输入一起使用。\\n1.  虽然建议的默认样式看起来**很简陋**。但是我们可以使用**CSS**设置其样式。\\n\\n## 4. `map` & `area`\\n\\n`map`并允许我们创建**图像映射**，这是**具有可单击区域图像**的一种使用办法。\\n\\n```\\n<img\\n  src=\\\"workplace.jpg\\\"\\n  alt=\\\"Workplace\\\"\\n  usemap=\\\"#workmap\\\"\\n  width=\\\"400\\\"\\n  height=\\\"379\\\"\\n/>\\n\\n<map name=\\\"workmap\\\">\\n  <area\\n    shape=\\\"rect\\\"\\n    coords=\\\"34,44,270,350\\\"\\n    alt=\\\"Computer\\\"\\n    href=\\\"computer.html\\\"\\n  />\\n  <area\\n    shape=\\\"rect\\\"\\n    coords=\\\"290,172,333,250\\\"\\n    alt=\\\"Phone\\\"\\n    href=\\\"phone.html\\\"\\n  />\\n  <area\\n    shape=\\\"circle\\\"\\n    coords=\\\"337,300,44\\\"\\n    alt=\\\"Cup of coffee\\\"\\n    href=\\\"coffee.html\\\"\\n  />\\n</map>\\n```\\n\\n\\n![uzi08fh85fvfb0ycz9de.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35e5746c50834ae88d2b8fd3efc61107~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## 5. `details` & `summary`\\n\\n`details`并且用于创建**可折叠的内容**，并且无需使用任何**JavaScript**。这是创建**下拉列表**的语义方法。\\n\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eea1133ac3e244f4bbf1a0de544a0f45~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## 6. `object`\\n\\n不知道怎样在你的网站上嵌入文件？不要找了，用`object`吧\\n\\n`object`允许我们嵌入各种文件，如**PDF**，**图像**，**视频**，**音频** 甚至 **视频**。\\n\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/00b9f11275b246638a64dc07071c11da~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## 7. `abbr`\\n\\n该元素允许我们向文档添加**缩写**。当用户将鼠标悬停在**缩写**上时，将显示完整窗体。此外，**屏幕阅读器**还可以配置为在遇到**缩写**时读出完整表格。\\n\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/18cfd2ef572f4755af6b4da70e1d2939~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## 8.预加载和缓存资源 📥\\n\\n想知道如何 **预加载** 和 **缓存资源** 吗？只需要一行代码，你就完成了！\\n\\n\\n```html\\n<link\\n  rel=\\\"preload\\\"\\n  href=\\\"https://example.com/asset.png\\\"\\n  as=\\\"image\\\"\\n/>\\n```\\n\\n## 9.为页面🖼️添加自定义链接预览\\n\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b09e809326f84c7cbc7f3b4e7a6ba394~tplv-k3u1fbpfcp-watermark.image?)\\n\\n对链接预览的生成方式感到疑惑？我们所需要的只是标签！\\n\\n\\n```html\\n<meta property=\\\"og:title\\\" content=\\\"Page title\\\" />\\n<meta\\n  property=\\\"og:description\\\"\\n  content=\\\"Page description\\\"\\n/>\\n<meta\\n  property=\\\"og:image\\\"\\n  content=\\\"https://example.com/asset.png\\\"\\n/>\\n```\\n\\n上面显示的标签使用 Open Graph Protocol（开放图谱协议），你可以使用任何标签生成器为所有其他平台生成标签\\n\\n## 10.重定向到另一个链接↪️\\n\\n将用户重定向到其他链接（通常在付款确认后使用）只需一行代码即可！\\n\\n\\n```html\\n<meta\\n  http-equiv=\\\"refresh\\\"\\n  content=\\\"3; url=https://juejin.cn/\\\"\\n/>\\n```\\n\\n上面的代码将在 3 秒后将用户重定向到 **掘金**。\\n\\n## 11. 拨打电话或邮件 📞\\n\\n需要一个链接来拨打 **电话** 或发送 **邮件**！\\n\\n```html\\n<a href=\\\"tel:+12345678910\\\">Call</a>\\n<a href=\\\"mailto:user@email.com\\\">Mail</a>\\n```\\n\\n## 12. 添加颜色选择器 🎨\\n\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a6f350287bf4476964dda842dd8c780~tplv-k3u1fbpfcp-watermark.image?)\\n\\n想要向您的网站添加 **颜色选择器**？您只需要一行，不需要花哨的 **库** 甚至也不需要 **JavaScript**！\\n\\n```html\\n<input type=\\\"color\\\" />\\n```\\n\\n## 13. 可编辑内容 ✏️\\n\\n只需将属性添加到元素即可使任何内容**可编辑**。\\n\\n\\n```html\\n<p contenteditable=\\\"true\\\">\\n  这是一段可编辑的话\\n</p>\\n```",
        "tags": [
            "前端",
            "HTML",
            "掘金·金石计划"
        ]
    },
    {
        "article_id": "7158710428372041742",
        "cover_image": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a9ff5b1766744215969aaab72e672d13~tplv-k3u1fbpfcp-watermark.image?",
        "title": "比 Vite 快 10 倍的 Turbopack！？Webpack 的继承者。",
        "brief": "Vercel 的使命是提供代码创造者在灵感迸发瞬间所需的速度和可靠性。去年，我们专注于提升 Next.js 打包 App 的速度。 每次我们从基于 JavaScript 的工具转移到基于 Rust 的",
        "user_name": "ssh_晨曦时梦见兮",
        "view_count": 38523,
        "collect_count": 175,
        "comment_count": 99,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/090d6608420cd5864d7564939c8f72ab~300x300.image",
        "category": "前端",
        "content": "> 原文：https://vercel.com/blog/turbopack\\n\\nVercel 的使命是提供代码创造者在灵感迸发瞬间所需的速度和可靠性。去年，我们专注于提升 Next.js 打包 App 的速度。\\n\\n每次我们从基于 JavaScript 的工具转移到基于 Rust 的工具时，我们都能看到巨大的改进。我们迁移了 Babel，提升了 17 倍的速度。我们替换了 Terser，压缩的速度提高了 6 倍，从而减少了加载时间和带宽的使用。\\n\\n还有一个障碍：Webpack。Webpack 已被下载超过 30 亿次。它已经成为构建 Web 的不可分割的一部分，但现在是时候加速，无限制扩展了！\\n\\n今天，我们推出[Turbopack](https://turbo.build/)：Webpack 的接班人。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/53d12368e96646c2897fa708a2ca78bb~tplv-k3u1fbpfcp-zoom-1.image '屏幕截图')\\n\\n由 Webpack 的创始人 Tobias Koppers 牵头创立，Turbopack 将会是 Web 下一代的打包工具。我们将使用高性能的工具来构建它，在未来对所有的框架开放。\\n\\n在 Next 中尝试 Turbopack 的 Alpha 版本：`next dev --turbo`。\\n\\n## Turbopack 有多快\\n\\nTurbopack 建立在新的增量体系结构上，以获得最快的开发体验。在大型应用中，它展示出了 **10 倍于 Vite 的速度，700 倍于 Webpack 的速度**。在更大的应用中，差异更加巨大 —— 通常**比 Vite 快 20 倍**。\\n\\nTurbopack 在开发环境只打包需要的最小资产，所以**启动飞快**。在一个 3000 个模块的应用里，**Turbopack 只花了 1.8 秒启动，Vite 花了 11.4 秒。**\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/41d8fd9a711d434a81e8a1398fc246ee~tplv-k3u1fbpfcp-zoom-1.image '屏幕截图')\\n\\n在[文档](https://turbo.build/pack/docs/core-concepts)里查看关于 Turbopack 打包和查看 benchmarks 的信息。\\n\\n## 为什么 Turbopack 这么快？\\n\\nTurbopack 的架构吸取了 Turborepo 和 Google 的 Bazel 等工具的经验教训，两个工具都专注于使用缓存，**永远不会重复相同的工作。**\\n\\nTurbopack 是建立在 Turbo 之上的，Turbo 是基于 Rust 的开源、增量记忆化框架。Turbo 可以缓存程序中任何函数的结果。当程序再次运行时，函数将不会重新运行，除非它的参数改变了。这种粒度的架构使您的程序能够在函数级别跳过大量工作。\\n\\n增量响应式系统，又有 Rust 的速度加持？Turbopack 是不可阻挡的！\\n\\n在 [Turbo 的讲解](https://turbo.build/pack/docs/core-concepts)里学习更多。\\n\\n## Turbo 的未来\\n\\n首先，Turbopack 将用于 Next.js 的开发服务器。它将为闪电般快速的 HMR 提供动力，并**天然支持 React Server Component**，Typescript，JSX，CSS 等也一样。\\n\\nTurbopack 最终也会赋能 Next.js 的生产环境构建，无论是本地还是云端。我们会**在你的整个团队里共享 Turbo 的缓存**，用[Vercel Remote Caching](https://vercel.com/docs/concepts/monorepos/remote-caching)。\\n\\nWebpack 用户还可以期望未来可以增量迁移到 Rust-based 的 Turbopack 特性。\\n\\n我们对 Turbo 生态系统的未来感到更加兴奋，我们推动它来帮助你更快速的迭代，在灵感到来时更好的创造。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae972655e80341e79a7a9af6ee128e69~tplv-k3u1fbpfcp-zoom-1.image '屏幕截图')\\n",
        "tags": [
            "前端",
            "JavaScript",
            "Vite"
        ]
    },
    {
        "article_id": "7168809452508807182",
        "cover_image": "",
        "title": "一文搞定Base64编码原理足矣",
        "brief": "Base64编码要求把3个8位的字节（3`*`8=24）转化为4个6位的字节（4`*`6=24），之后在6位的前面补两个0，形成8位一个字节的形式。 如果剩下的字符不足3个字节，则用0填充，输出字符使",
        "user_name": "Morakes",
        "view_count": 28570,
        "collect_count": 133,
        "comment_count": 12,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/84a8ce51843fa237aff620eb96b2ce76~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: channing-cyan\\n---\\n\\n开启掘金成长之旅！这是我参与「掘金日新计划 · 12 月更文挑战」的第1天，[点击查看活动详情](https://juejin.cn/post/7167294154827890702 \\\"https://juejin.cn/post/7167294154827890702\\\")\\n\\n# 早上好中午好下午好晚上好! 欢迎来到Morakes频道\\n# 本文将带你探索Base64编码的原理\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb1f9913236a40c2b7a696392437adb8~tplv-k3u1fbpfcp-watermark.image?)\\n\\n把图片丢进浏览器，打开sources能看到一长串字符串，这是图片的Base64编码。这一长串编码到底是怎么生成的呢？\\n我们接下来探索一下base64编码的原理\\n\\n## Base64 名称的由来\\nBase64编码要求把3个8位的字节（3`*`8=24）转化为4个6位的字节（4`*`6=24），之后在6位的前面补两个0，形成8位一个字节的形式。 如果剩下的字符不足3个字节，则用0填充，输出字符使用'='，因此编码后输出的文本末尾可能会出现1或2个'='。\\n\\n为了保证所输出的编码位可读字符，Base64制定了一个编码表，以便进行统一转换。编码表的大小为2^6=64，这也是Base64名称的由来。(下面是Base64编码表)\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1189f188c43347a2b8307cd27fe9ff03~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## 思路\\n原始数据对应ASCII，生成8位的二进制，3个8位的字节（3`*`8=24）转化为4个6位的字节（4`*`6=24），不够补零。分割之后，得出来6位字节的二进制转化成十进制，再从base64表中寻找对应的字符\\n\\n\\n```mermaid\\ngraph TD\\n原始数据 --> 每个字符按照ASCII编码生成3个8位的二进制 --> 3个8位的字节分割为4个6位字节 --> 再转化成十进制生成Base64编码\\n```\\n## 实现过程\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/29ee0163c7104ef7b81310f716e08be0~tplv-k3u1fbpfcp-watermark.image?)\\n（补一张ASCII编码表）\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87f10dc48dec4885959edfd18d8cabdf~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n原始数据：Mz1\\n\\n根据ASCII表转换成8位二进制：01001101 | 01111010 | 00110001\\n\\n将 3`*`8 切割成 4`*`6：010011 | 010111 | 101000 | 110001\\n\\n分别转化成十进制：19 | 23 | 40 | 49\\n\\n最后再去Base64编码表中找到数字对应的字符：T | X | o | x\\n\\n最终 Mz1 的 Base64 ：TXox\\n\\n\\n## 强化训练\\nQ：**写出TB对应的Base64编码**\\n\\n1.TB 对应的ASCII\\n\\n    T：01010100 B：01000010\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e246c6dc2fc43d48b7b56826e5a1ec3~tplv-k3u1fbpfcp-watermark.image?)\\n\\n2.将三个8位的二进制分割成4个6位的二进制\\n\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c7938907309547aea9ec91925b6ea689~tplv-k3u1fbpfcp-watermark.image?)\\n\\n3.将二进制转换成十进制\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dfa535e584df4201b9dcee3e94687622~tplv-k3u1fbpfcp-watermark.image?)\\n\\n4.将十进制按照Base64表得到Base64编码\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/819869e04ef943b882501f3f8ffb921e~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\nA：**TB所对应的Base64编码为 VEI=**\\n\\n\\n## 用Base64的来呈现图片的有什么优势呢？\\n1. 减少http网络请求：网页上的图片资源如果采用http形式的url的话都会额外发送一次请求，网页发送的http请求次数越多，会造成页面加载速度越慢。而采用Base64格式的编码，将图片转化为字符串后，图片文件会随着html元素一并加载，这样就可以减少http请求的次数，对于网页优化是一种比较好的手段。\\n2. 不会造成跨域请求的问题。\\n3. 没有图片更新要重新上传，不会造成清理图片缓存的问题\\n\\n不足之处就在于**增加了CSS文件的尺寸**，**造成数据库数据量的增大**，**IE6 IE7并不支持**\\n\\n\\n对你有帮助的话，就点个赞吧！\\n",
        "tags": [
            "前端",
            "算法",
            "掘金·日新计划"
        ]
    },
    {
        "article_id": "7194767712537542711",
        "cover_image": "",
        "title": "antd 3.x升4.x踩坑之路～",
        "brief": "该篇文章详细讲解了如何从 antd3 升级到 antd4 其中的步骤，以及团队在实践过程中发现的一些问题和对应的解决方案。",
        "user_name": "袋鼠云数栈UED团队",
        "view_count": 1273,
        "collect_count": 1,
        "comment_count": 2,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/3ea29bc8a0c685b68e006b1c9c9e30cd~300x300.image",
        "category": "前端",
        "content": ">我们是袋鼠云数栈 UED 团队，致力于打造优秀的一站式数据中台产品。我们始终保持工匠精神，探索前端道路，为社区积累并传播经验价值。\\n\\n## 兼容性问题\\n#### 第三方依赖兼容问题\\n\\n   - React - 最低 v16.9，部分组件使用 hooks 重构 [react升级相关文档](https://reactjs.org/blog/2017/09/26/react-v16.0.html#breaking-changes)\\n   - Less - 最低 v3.1.0，建议升级到 less 4.x\\n   - @ant-design/icons-antd - 不再内置 Icon 组件，请使用独立的包\\n#### 对 3.x 的兼容性处理\\n或许是考虑到部分组件升级的毁坏性，antd4.x 中依然保留了对 3.x 版本的兼容，废弃的组件通过 @ant-design/compatible 保持兼容，例如 Icon, Form\\n注：建议 @ant-design/compatible 仅在升级过程中稍作依赖，升级 4.x 请完全剔除对该过渡包的依赖\\n\\n## 升级步骤（只有一步）\\n1、@ant-design/codemod-v4 自带升级脚本，会自动替换代码\\n\\n```shell\\n# 通过 npx 直接运行\\nnpx -p @ant-design/codemod-v4 antd4-codemod apps/xxxx\\n\\n# 或者全局安装\\n# 使用 npm\\nnpm i -g @ant-design/codemod-v4\\n# 或者使用 yarn\\nyarn global add @ant-design/codemod-v4\\n\\n# 运行\\nantd4-codemod src\\n```\\n\\n**注意：** 该命令和脚本只会进行代码替换，不会进行AntD的版本升级，需要手动将其升级至4.22.5\\n```\\n该命令完成的工作：\\n    1. 将 Form 与 Mention 组件通过 @ant-design/compatible 包引入 \\n    2. 用新的 @ant-design/icons 替换字符串类型的 icon 属性值 \\n    3. 将 Icon 组件 + type =“” 通过 @ant-design/icons 引入 \\n    4. 将 v3 LocaleProvider 组件转换成 v4 ConfigProvider 组件 \\n    5. 将 Modal.method() 中字符串 icon 属性的调用转换成从 @ant-design/icons 中引入 \\n```\\n\\n### antd4-codemod\\n![codemod_error.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33dd4b9ff3fd45be85f82b485e7d7e3d~tplv-k3u1fbpfcp-zoom-1.image)\\n上图这类报错是 Icon 组件自动替换错误，有 2 种处理方式：\\n\\n1. 报错文件的 Icon 比较少的情况，可以直接手动替换该文件中的 Icon 组件。具体替换成 Icon 中的哪个组件可以根据 type 在 [Icon文档](https://ant.design/components/icon-cn/) 中找。\\n2. 下图中是具体报错的节点，可以看到 JSXSpreadAttribute 节点也就是**拓展运算符**中没有 name 属性，所以把 Icon 组件的拓展运算符改一下再执行替换脚本就可以了\\n\\n    ![JSXSpreadAttribute.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b8c3482c5ca42ee9e088744a33f9fd8~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n## antd4 问题修复\\n### styled-components\\nstyled-components 依赖需要转换写法\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f9874df1ad0475abe7f189f59708112~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n###  Icon\\n不要使用兼容包的 icon  \\n在 3.x 版本中，Icon 会全量引入所有 svg 图标文件，增加了打包产物  \\n在 4.x 版本中，对 Icon 进行了按需加载，将每个 svg 封装成一个组件  \\n注：antd 不再内置 Icon 组件，请使用独立的包 `@ant-design/icons`\\n\\n- 使用\\n    ```javascript\\n    import { Icon } from 'antd';\\n    mport { SmileOutlined } from '@ant-design/icons';\\n\\n    const Demo = () => (\\n      <div>\\n         <Icon type=\\\"smile\\\" />\\n         <SmileOutlined />\\n         <Button icon={<SmileOutlined />} />\\n      </div>\\n    );\\n    ```\\n\\n- 兼容\\n    ```javascript\\n    import { Icon } from '@ant-design/compatible';\\n    const Demo = () => (\\n      <div>\\n        <Icon type=\\\"smile\\\" />\\n        <Button icon=\\\"smile\\\" />\\n      </div>\\n    );\\n    ```\\n### Form\\n\\n[antd Form 从 v3 到 v4](https://ant.design/components/form/v3-cn/#%E5%8E%BB%E9%99%A4-Form.create)\\n\\n#### Form.create()\\n\\n在 3.x 中，表单中任意一项的修改，都会导致 Form.create() 包裹的表单重新渲染，造成性能消耗  \\n在 4.x 中，Form.create() 不再使用  \\n如果需要使用 form 的 api，例如 setFieldsValue 等，需要通过 `Form.useForm()` 创建 Form 实体进行操作\\n- 函数组件写法\\n    ```javascript\\n    // antd v4\\n    const Demo = () => {\\n      const [form] = Form.useForm();\\n\\n      React.useEffect(() => {\\n        form.setFieldsValue({\\n          username: 'Bamboo',\\n        });\\n      }, []);\\n\\n      return (\\n        <Form form={form} {...props}> ... </Form>\\n      )\\n    };\\n    ```\\n- 如果是 class component, 也可以通过 ref 获取\\n    ```javascript\\n    class Demo extends React.Component {\\n      formRef = React.createRef();\\n\\n      componentDidMount() {\\n        this.formRef.current.setFieldsValue({\\n          username: 'Bamboo',\\n        });\\n      }\\n\\n      render() {\\n        return (\\n          <Form ref={this.formRef}>\\n            <Form.Item name=\\\"username\\\" rules={[{ required: true }]}>\\n              <Input />\\n            </Form.Item>\\n          </Form>\\n        );\\n      }\\n    }\\n    ```\\n当我们使用 From.create() 的时候，可能会传入参数，做数据处理，例如：\\n```javascript\\nexport const FilterForm: any = Form.create<Props>({\\n  onValuesChange: (props, changedValues, allValues) => {\\n    const { onChange } = props;\\n    onChange(allValues);\\n  },\\n})(Filter);\\n```\\n由于 Form.create 的删除，需要放到 `<Form>` 中\\n```javascript\\n<Form\\n  ref={this.formRef}\\n  layout=\\\"vertical\\\"\\n  className=\\\"meta_form\\\"\\n  onValuesChange={(_, allValues) => {\\n    const { onChange } = this.props;\\n    onChange(allValues);\\n  }}\\n>\\n```\\n#### getFieldDecorator\\n在 4.x 中，不在需要 getFieldDecorator 对 Item 进行包裹。\\n注意以下问题\\n\\n   - 将之前写在 getFieldDecorator 中的 name, rules 等移到属性中\\n   - 初始化在 form 中处理，避免同名字段冲突问题\\n   - 关于表单联动的问题，官方提供了 shouldUpdate 方法，\\n```javascript\\n// antd v4\\nconst Demo = () => (\\n  <Form initialValues={{ username: 'yuwan' }}>\\n    <Form.Item name=\\\"username\\\" rules={[{ required: true }]}>\\n      <Input />\\n    </Form.Item>\\n  </Form>\\n);\\n```\\n#### initialValue\\n##### 历史问题\\ninitialValue 从字面意来看，就是初始值 defaultValue，但是可能会有部分同学使用他的时候会误以为 initialValue 等同于 value\\n造成这样的误解是因为在 3.x 的版本中，一直存在一个很神奇的问题，受控组件的值会跟随 initialValue 改变\\n看下面的例子，点击 button 修改 username, input 框的 value 也会随之改变\\n```javascript\\nconst Demo = ({ form: { getFieldDecorator } }) => (\\n  const [username, setUsername] = useState('');\\n  const handleValueChange = () => {\\n    setUsername('yuwan');\\n  }\\n  return (\\n    <Fragment>\\n      <Form>\\n        <Form.Item>\\n          {getFieldDecorator('username', {\\n             initialValue: username,\\n             rules: [{ required: true }],\\n          })(<Input />)}\\n        </Form.Item>\\n      </Form>\\n      <Button onClick={handleValueChange}>Change</Button>\\n    </Fragment>\\n  )\\n);\\n\\nconst WrappedDemo = Form.create()(Demo);\\n```\\n但当 input 框被编辑过，initialValue 和 input 的绑定效果就消失了，正确的做法应该是通过 setFieldsVlaue 方法去 set 值\\n##### 4.x 版本的 initialValue\\n在 4.x，antd 团队已经把这个 bug 给解了，并且其一是为了 name 重名问题，二是再次强调其初始值的功能，现在提到 Form 中了，\\n当然，如果继续写在 Form. Item 中也是可以的，但需要注意优先级\\n\\n#### shouldUpdate\\n前面有说过，form 表单不再会因为表单内部某个值的改变而重新渲染整个结构，而设有 shouldUpdate 为 true 的 Item，任意变化都会使该 Form. Item 重新渲染\\n它会接收 render props，从而允许你对此进行控制\\n这里稍微注意一下，请勿在设置 shouldUpdate 的外层 Form. Item 上添加 name， 否则，你会得到一个 error\\n```javascript\\n<Form.Item shouldUpdate={(prev, next) => prev.name !== next.name}>\\n  {form => form.getFieldValue('name') === 'antd' && (\\n    <Form.Item name=\\\"version\\\">\\n      <Input />\\n    </Form.Item>\\n  )}\\n</Form.Item>\\n```\\n在使用 shouldUpdate 的时候，需要在第一个 Form.Item 上加上 noStyle，否则就会出现下面的情况，会有留白占位的情况\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/04b4164ce3424031bd08804e136b3a4a~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n#### validateTrigger\\n`onBlur` 时不再修改选中值，且返回 React 原生的 `event` 对象。  \\n如果你在使用兼容包的 Form 且配置了 `validateTrigger` 为 `onBlur` ，请改至 `onChange` 以做兼容。\\n\\n#### validator\\n在 antd3 时，我们使用 callback 返回报错。但是 antd4 对此做了修改，自定义校验，接收 Promise 作为返回值。[示例](https://ant.design/components/form-cn/#components-form-demo-register)参考\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7267a2af261e4113a5433219a1002603~tplv-k3u1fbpfcp-zoom-1.image)\\n- antd3 的写法\\n```javascript\\n<FormItem label=\\\"具体时间\\\" {...formItemLayout}>\\n  {getFieldDecorator('specificTime', {\\n    rules: [\\n      {\\n        required: true,\\n        validator: (_, value, callback) => {\\n          if (!value || !value.hour || !value.min) {\\n             return callback('具体时间不可为空');\\n          }\\n          callback();\\n        },\\n      },\\n    ],\\n  })(<SpecificTime />)}\\n</FormItem>\\n```\\n- antd4 的写法\\n```javascript\\n<FormItem\\n  label=\\\"具体时间\\\"\\n  {...formItemLayout}\\n  name=\\\"specificTime\\\"\\n  rules={[\\n    {\\n      required: true,\\n      validator: (_, value) => {\\n        if (!value || !value.hour || !value.min) {\\n            return Promise.reject('具体时间不可为空');\\n        }\\n        return Promise.resolve();\\n      },\\n    },\\n  ]}\\n>\\n  <SpecificTime />)\\n</FormItem>\\n```\\n#### validateFields\\n不在支持 callback，该方法会直接返回一个 Promise，可以通过 then / catch 处理\\n```javascript\\nthis.formRef.validateFields()\\n  .then((values) => {\\n    onOk({ ...values, id: appInfo.id || '' });\\n})\\n  .catch(({ errorFields }) {\\n    this.formRef.scrollToField(errorFields[0].name);\\n  })\\n```\\n或者使用 async/await\\n```javascript\\ntry {\\n  const values = await validateFields();\\n} catch ({ errorFields }) {\\n  scrollToField(errorFields[0].name);\\n}\\n```\\n#### validateFieldsAndScroll\\n该 api 被拆分了，将其拆分为更为独立的 `scrollToField` 方法\\n```javascript\\nonFinishFailed = ({ errorFields }) => {\\n  form.scrollToField(errorFields[0].name);\\n};\\n```\\n\\n#### form.name\\n在 antd 3.x 版本，绑定字段时，可以采用`.`分割的方式。如：\\n\\n```javascript\\ngetFieldDecorator('sideTableParam.primaryKey')\\ngetFieldDecorator('sideTableParam.primaryValue')\\ngetFieldDecorator('sideTableParam.primaryName')\\n```\\n\\n在最终获取 values 时，antd 3.x 的版本会对字段进行汇总，得到如下：\\n```javascript\\nconst values = {\\n  sideTableParam: {\\n    primaryKey: xxx,\\n    primaryValue: xxx,\\n    primaryName: xxx,\\n  }\\n}\\n```\\n\\n而在 antd 4.x下，会得到如下的values 结果：\\n```javascript\\nconst values = {\\n  'sideTableParam.primaryKey': xxx,\\n  'sideTableParam.primaryValue': xxx,\\n  'sideTableParam.primaryName': xxx,\\n}\\n```\\n解决方法：\\n在 antd 4.x 版本传入数组\\n```javascript\\nname={['sideTableParam', 'primaryKey']}\\nname={['sideTableParam', 'primaryValue']}\\nname={['sideTableParam', 'primaryName']}\\n```\\n使用 setFieldsValue 设置值：\\n```javascript\\nsetFieldsValue({\\n  sideTableParam: [\\n    {\\n      primaryKey: 'xxx',\\n      primaryValue: 'xxx',\\n      primaryName: 'xxx',\\n    },\\n  ],\\n});\\n```\\n当我们使用 name={['sideTableParam', 'primaryKey']} 方式绑定值的时候，与其关联的 dependencies/getFieldValue 都需要设置为['sideTableParam', 'primaryKey']\\n例如：\\n```javascript\\n\\n<FormItem dependencies={[['alert', 'sendTypeList']]} noStyle>\\n  {({ getFieldValue }) => {\\n    const isShowWebHook = getFieldValue(['alert', 'sendTypeList'])?.includes(\\n      ALARM_TYPE.DING\\n    );\\n   return (\\n     isShowWebHook &&\\n       RenderFormItem({\\n         item: {\\n           label: 'WebHook',\\n           key: ['alert', 'dingWebhook'],\\n           component: <Input placeholder=\\\"请输入WebHook地址\\\" />,\\n           rules: [\\n             {\\n               required: true,\\n               message: 'WebHook地址为必填项',\\n             },\\n           ],\\n           initialValue: taskInfo?.alert?.dingWebhook || '',\\n         },\\n       })\\n     );\\n  }}\\n</FormItem>\\n```\\n当我们希望通过 validateFields 拿到的数据是数组时，例如这样：\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f2b11863d9174cf3a3b2ef53003c9ff7~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n我们可以设置为这样\\n```javascript\\nconst formItems = keys.map((k: React.Key) => (\\n  <Form.Item key={k} required label=\\\"名称\\\">\\n    <Form.Item\\n      noStyle\\n      name={['names', k]}\\n      rules={[\\n        { required: true, message: '请输入标签名称' },\\n        { validator: utils.validateInputText(2, 20) },\\n      ]}\\n    >\\n      <Input placeholder=\\\"请输入标签名称\\\" style={{ width: '90%', marginRight: 8 }} />\\n    </Form.Item>\\n     <i className=\\\"iconfont iconicon_deletecata\\\" onClick={() => this.removeNewTag(k)} />\\n  </Form.Item>\\n));\\n```\\n\\n#### Tooltip\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2309b5344934427cab2d191ab592023a~tplv-k3u1fbpfcp-zoom-1.image)\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a12ff8937ecd4b52af1113e94696ea27~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n#### extra\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e82527bef924b04ba6974f02696062b~tplv-k3u1fbpfcp-zoom-1.image)\\n```javascript\\n<FormItem\\n  label=\\\"过滤条件\\\"\\n  extra={\\n    <Tooltip title={customSystemParams}>\\n      系统参数配置&nbsp;\\n       <QuestionCircleOutlined />\\n     </Tooltip>\\n   }\\n>\\n  <Input.TextArea />\\n</FormItem>\\n```\\n###  Select\\n#### rc-select\\n底层重写\\n   - 解决些许历史问题\\n      - rc-select & rc-select-tree 的 inputValue & searchValue 之争\\nrc-select-tree 是 rc-select 结合 tree 写的一个组件，相似但又不同，searchValue 就是其中一点，也不是没人提过 issue，只是人的忘性很大，时间长了就忘了，混了，导致在 rc-select 中甚至出现了 searchValue 的字样\\n      - inputValue 历史问题，this.state.inputValue\\n![rc-select-inputvalue.jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea8456f4a9e5469cb740f6d168a65230~tplv-k3u1fbpfcp-zoom-1.image)\\n也不是不想改，只是改了之后改出了一堆 bug，真真应了一句话，每一个历史包袱的存在，都有他存在的原因，，\\n      - onSelect 清空了值，又会被 onChange 赋值回来\\n   - 模块复用\\n\\n在新版的 `rc-select` 中，antd 官方抽取了一个 generator 方法。它主要接收一个 `OptionList` 的自定义组件用于渲染下拉框部分。这样我们就可以直接复用选择框部分的代码，而自定义 Select 和 TreeSelect 对应的列表或者树形结构了。\\n\\n####  labelInValue \\n在 3.x 版本为 {key: string, label: ReactNode} \\n\\n在 4.x 版本为 {value: string, label: ReactNode} \\n\\n### Table\\n#### fixed\\n![table-fixed.jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c9f87bab9cb24b71b8cfb2706a4bb49b~tplv-k3u1fbpfcp-zoom-1.image)\\n固定列时，文字过长导致错位的问题，被完美解决了，✿✿ヽ(°▽°)ノ✿\\n##### 历史原因\\n3.x 中对 table fixed 的实现，是写了两个 table, 顶层 fixed 的是一个，底层滚动的是一个，这样，出现这种错位的问题就很好理解了。\\n\\n要解决也不是没有办法，可以再特定的节点去测算表格列的高度，但是这个行为会导致重排，会影响性能问题\\n\\n##### 解决方案\\n4.x 中，table fixed 不在通过两个 table 来实现，他使用了一个 position 的新特性：position: sticky;\\n\\n> 元素根据正常文档流进行定位，然后相对它的_最近滚动祖先（nearest scrolling ancestor）_和 [containing block](https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block) (最近块级祖先 nearest block-level ancestor)，包括 table-related 元素，基于 `top` , `right` , `bottom` , 和 `left` 的值进行偏移。偏移值不会影响任何其他元素的位置。\\n\\n优点\\n\\n   - 根据正常文档流进行定位\\n   - 相对最近滚动祖先 & 最近块级祖先进行偏移\\n\\n缺点\\n\\n   - 不兼容 <= IE11\\n\\n解决了使用 absolute | fixed 脱离文档流无法撑开高度的问题，也不在需要对高度进行测量\\n\\n#### table.checkbox\\n##### 问题描述\\n资产升级后，checkbox 宽度被挤压了。\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e049dcbb9ff4454cb95c7eb1c6d4f462~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n##### 解决方案\\n通过在 **rowSelection** 中设置 columnWidth 和 fixed 解决。\\n\\n```javascript\\nconst rowSelection = {\\n  fixed: true,\\n  columnWidth: 45,\\n  selectedRowKeys,\\n  onChange: this.onSelectChange,\\n};\\n```\\n#### 渲染条件\\nantd4 Table 对渲染条件进行了优化，对 props 进行“浅比较”，如果没有变化不会触发 render。\\n\\n#### 类名更改\\n. ant-table-content 更改为 .ant-table-container\\n\\n.ant-form-explain 更改为 .ant-form-item-explain\\n\\n#### dataIndex 修改\\n\\n在 antd3.0 的时候，我们采用 user.userName 能够读到嵌套的属性\\n```javascript\\n{\\n  title: '账号',\\n  dataIndex: 'user.userName',\\n  key: 'userName',\\n  width: 200,\\n}\\n```\\nantd4.0 对此做了修改，同 Form 的 name\\n```javascript\\n{\\n  title: '账号',\\n  dataIndex: ['user', 'userName'],\\n  key: 'userName',\\n  width: 200,\\n}\\n```\\n\\n#### table pagination showSizeChanger\\n\\n##### 问题描述\\n\\n升级 antd4 后，发现一些表格分页器多了 pageSize 切换的功能，代码中 onChange 又未对 size 做处理，会导致 底部分页器 pageSize 和数据对不上，因此需要各自排查 Table 的 pagination 和 Pagination 组件，和请求列表接口的参数\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9dd760ab63af47a8a068aafc20dbec31~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n\\n```javascript\\n<Table\\n  rowKey=\\\"userId\\\"\\n  pagination={{\\n  total: users.totalCount,\\n    defaultPageSize: 10,\\n  }}\\n  onChange={this.handleTableChange}\\n  style={{ height: tableScrollHeight }}\\n  loading={this.state.loading}\\n  columns={this.initColumns()}\\n  dataSource={users.data}\\n  scroll={{ x: 1100, y: tableScrollHeight }}\\n/>\\n\\nhandleTableChange = (pagination: any) => {\\n  this.setState(\\n    {\\n      current: pagination.current,\\n    },\\n    this.search\\n  );\\n};\\n\\nsearch = (projectId?: any) => {\\n  const { name, current } = this.state;\\n  const { project } = this.props;\\n  const params: any = {\\n    projectId: projectId || project.id,\\n    pageSize: 10,\\n    currentPage: current || 1,\\n    name: name || undefined,\\n    removeAdmin: true,\\n  };\\n  this.loadUsers(params);\\n};\\n```\\nantd4.0 对此做了修改，同 Form 的 name\\n```javascript\\n<Table\\n  rowKey=\\\"userId\\\"\\n  pagination={{\\n    showTotal: (total) => `共${total}条`,\\n    total: users.totalCount,\\n    current,\\n    pageSize,\\n  }}\\n  onChange={this.handleTableChange}\\n  style={{ height: tableScrollHeight }}\\n  loading={this.state.loading}\\n  columns={this.initColumns()}\\n  dataSource={users.data}\\n  scroll={{ x: 1100, y: tableScrollHeight }}\\n/>\\n\\nhandleTableChange = (pagination: any) => {\\n  this.setState(\\n    {\\n      current: pagination.current,\\n      pageSize: pagination.pageSize,\\n    },\\n    this.search\\n  );\\n};\\n\\nsearch = (projectId?: any) => {\\n  const { name, current, pageSize } = this.state;\\n  const { project } = this.props;\\n  const params: any = {\\n    projectId: projectId || project.id,\\n    pageSize,\\n    currentPage: current || 1,\\n    name: name || undefined,\\n    removeAdmin: true,\\n  };\\n  this.loadUsers(params);\\n};\\n```\\n\\n另外，一些同学在 Table 中 既写了 onChange，也写了 onShowSizeChange，这个时候要注意，当切换页码条数的时候两个方法都会触发，onShowSizeChange 先触发，onChange 后触发，这个时候如果 onChange 内未对 pageSize 做处理可能导致切页失败，看下面代码就明白了，写的时候稍微注意一下即可。\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc8892fcad1a437a96c370e78a20efbc~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n#### table sorter columnKey\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed2674811d8848608c02fd306ede591b~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n##### 问题描述\\n\\n表格中如果要对表格某一字段进行排序需要在 columns item 里设置 sorter 字段，然后在 onChange 里拿到 sorter 对象进行参数处理，再请求数据，需要注意的是，很多用到了 sorter.columnKey 来进行判断，容易出现问题，sorter.columnKey === columns item.key，如果未设置 key，那么获取到的 columnKey 就为空，导致搜索失效，要么设置 key，再进行获取，同理， sorter.field === columns item.dataIndex，设置 dataIndex，通过 sorter.field 进行获取，两者都可以\\n\\n```tsx\\ncolumns={\\n  [\\n    {\\n      title: '创建时间',\\n      dataIndex: 'gmtCreate1',\\n      key: 'aa',\\n      sorter: true,\\n      render(n: any, record: any) {\\n        return DateTime.formatDateTime(record.gmtCreate);\\n      }\\n    },\\n    ...\\n  ]\\n}\\nonChange={(pagination: any, filters: any, sorter: any) {\\n  console.log(pagination, '--pagination');\\n  console.log(filters, '--filters');\\n  console.log(sorter, '--sorter');\\n}}\\n```\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f9406c6d05de4b1fbd1b53c87f5ae847~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n### Tree\\nTree 组件取消 value 属性，现在只需要添加 key 属性即可\\n\\n**特别注意， 此问题会导致功能出问题，需要重点关注！！！**\\n\\n在项目中经常在 TreeItem 中增加参数，如：`<TreeItem value={value} data={data} >`。在拖拽等回调中就可以通过 `nodeData.props.data`的方式获取到 data 的值。\\n但在 antd4 中，获取参数的数据结构发生了改变，原先直接通过 props 点出来的不行了。\\n有两种方式取值\\n1. 不使用props。直接采用 nodeData.data 的方式，也可以直接拿到\\n2. 继续使用 props。在antd4中，还是可以通过 props 找到参数，只不过 antd 会把所有参数使用 data 进行包裹。就需要改成 `nodeData.props.data.data`\\n\\n**新版数据结构如下：**\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b30509fa6e454b18aa7b9ed0a6228ea9~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n#### drag\\n拖拽节点位置的确定与 3.x 相比进行了变更，官网并没有说明。具体如下图\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d81746f018b74bd9a1e534d196f7875d~tplv-k3u1fbpfcp-zoom-1.image)\\n左侧为 3.x，右侧为 4.x。\\n在3.x版本，只要把节点拖拽成目标节点的上中下，即代表着目标节点的同级上方，子集，同级下方\\n\\n在 4.x 版本，是根据当前拖拽节点与目标节点的相对位置进行确定最终的拖拽结果。\\n当拖拽节点处于目标节点的下方，且相对左侧对齐的位置趋近于零，则最终的位置为目标节点的同级下方。\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e043861470954c6d9c8f4a5a381c6e02~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n当拖拽节点处于目标节点的下方，且相对左侧一个缩近的位置。则最终的位置为目标节点的子集。\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5857304b812d4c12bf2a7e3341dd381e~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n当拖拽节点处于目标节点的上方，且相对左侧对齐的位置趋近于零，则最终的位置为目标节点的同级上方。\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/21f7d38f4abe4bf09f91567aec5017fc~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n### Pagination\\n`Pagination`自 4.1.0 版本起，会默认将 `showSizeChanger` 参数设置为 true ，因而在数据条数超过50时，pageSize 切换器会默认显示。这个变化同样适用于 Table 组件。可通过 `showSizeChanger: false` 关闭\\n如果 size 属性值为 small，则删除 size 属性。\\n\\n### Drawer\\n当我们在 Drawer 上 设置了 getContainer={false} 属性之后，Drawer 会添加上 .ant-drawer-inline 的类名导致我们 position: fixed 失效\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe06944765234a828313c5af19eb137a~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n### Button\\n在 antd 3.0  中危险按钮采用 type\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/15694321cef2430c840f7721edc25920~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n\\n使用如下：\\n设计改动点 type、dangr 属性\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a750e6fe16e24a65b0abc13276d30500~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n### Tabs\\n使标签页不被选中\\n```javascript\\n// 3.x\\nactiveKey={undefined}\\n// 4.x\\nactiveKey={null}\\n```\\n\\n## 总结\\n该篇文章详细讲解了如何从 antd3 升级到 antd4 其中的步骤，以及团队在实践过程中发现的一些问题和对应的解决方案。\\n\\n**开启掘金成长之旅！这是我参与「掘金日新计划 · 2 月更文挑战」的第 1 天，[点击查看活动详情](https://juejin.cn/post/7194721470063312933 \\\"https://juejin.cn/post/7194721470063312933\\\")**\\n\\n",
        "tags": [
            "Ant Design",
            "前端",
            "掘金·日新计划"
        ]
    },
    {
        "article_id": "7171274503152992287",
        "cover_image": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d158b670810c4830a267fc2d21abcf7e~tplv-k3u1fbpfcp-watermark.image?",
        "title": "实现一个靠谱好用的全屏组件，顺手入门 Headless 组件",
        "brief": "聊聊一个使用频率还挺高的组件——全屏组件，顺便了解下什么是 Headless 组件，并尝试动手将一个普通组件改造成 Headless 组件。",
        "user_name": "Tusi",
        "view_count": 2531,
        "collect_count": 74,
        "comment_count": 5,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/5cdce3dcf685b7b55f5727ffca322944~300x300.image",
        "category": "前端",
        "content": "> 本文为稀土掘金技术社区首发签约文章，14天内禁止转载，14天后未获授权禁止转载，侵权必究！\\n>\\n> 专栏上篇文章传送门：[衍生需求：按钮集成图标组件 & 图标选择器](https://juejin.cn/post/7166029886128128014)\\n> \\n> 本节涉及的内容源码可在[vue-pro-components c5 分支](https://github.com/cumt-robin/vue-pro-components/tree/c5)找到，欢迎 star 支持！\\n\\n# 前言\\n\\n本文是 [基于Vite+AntDesignVue打造业务组件库](https://juejin.cn/column/7140103979697963045 \\\"https://juejin.cn/column/7140103979697963045\\\") 专栏第 6 篇文章【实现一个靠谱好用的全屏组件，顺手入门 Headless 组件】，聊聊一个使用频率还挺高的组件——全屏组件，顺便了解下什么是 Headless 组件，并尝试动手将一个普通组件改造成 Headless 组件。\\n\\n# 全屏组件\\n\\n我们在项目中或多或少会用到进出全屏的功能，这样可以最大化利用可视区域，但是，实现一个完善的全屏功能并不简单。\\n\\n首先，各浏览器内核对于全屏 API 的实现不一样，你可能会看到诸如`requestFullscreen`, `webkitRequestFullScreen`, `mozRequestFullScreen`, `msRequestFullscreen`之类的进入全屏的方法，退出全屏的方法也不例外。\\n\\n其次，各浏览器中能用来判断全屏状态的属性和方法也不尽相同，比如`document.fullscreenElement`, `document.webkitFullscreenElement`等等，甚至有的情况下用`document.fullscreenElement`也无法准确反映全屏的状态，比如你在 Chrome, Edge, Firefox 等浏览器中通过 F11 按键进入全屏后，`document.fullscreenElement`的值会是`null`，并且`fullscreenchange`事件也不会触发；而通过调用`requestFullscreen()` API 进入全屏后，`document.fullscreenElement`的值就是正确的。\\n\\n对于做项目的开发者们来说，这种不一致就让人很恼火，因为我们仅靠`document.fullscreenElement`并不能确保在界面上可以反馈正确的状态，此时我们需要寻找一种方法 hack，解决这种不一致问题。\\n\\n![全屏状态不一致.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b576d07532684e308e6ca2ef86b51854~tplv-k3u1fbpfcp-watermark.image?)\\n\\n全屏/退出全屏的触发方式比较多，可能有通过按键`F11`, `ESC`等触发，也有可能通过监听某个界面元素的交互事件并结合全屏 API 触发，这会让全屏的状态判断变得更复杂。\\n\\n为了解决这些问题，我们有必要把这些繁琐和不确定性集中处理掉，对外提供干净、简洁、一致的 API。那么我们要做哪些事情呢？我想大概有以下几点：\\n\\n- 检测当前环境是否允许/支持全屏能力（对应`fullscreenEnabled`）。\\n- 提供进入/退出全屏的 API（名字可以是`enterFullscreen`, `exitFullscreen`）。\\n- 提供统一的判断全屏状态的方法（名字可以是`isFullscreen`）。\\n- 提供获取全屏元素的方法（名字可以是`getFullscreenElement`）。\\n- 提供监听/取消监听全屏事件的能力（名字可以是`subscribeFullscreenChange`, `unsubscribeFullscreenChange`）\\n\\n## 检测当前环境是否允许/支持全屏能力\\n\\n由于浏览器厂商的具体实现差异，可能会出现部分浏览器不支持全屏 API的情况，或者有提供某种配置或开关，能够做到启用/禁用全屏特性。因此最保险的做法是：在我们使用全屏 API 之前，做一次全屏特性支持度检测。\\n\\n检测的逻辑并不复杂，只要将标准的`fullscreenEnabled`用上，同时将浏览器前缀考虑在内即可。\\n\\n```\\n/**\\n * @description 判断浏览器当前状态是否允许启用全屏特性\\n */\\nexport function isFullscreenEnabled(): boolean {\\n    return !!(document.fullscreenEnabled || document.webkitFullScreenEnabled || document.mozFullScreenEnabled || document.msFullScreenEnabled);\\n}\\n```\\n\\n## TypeScript 类型扩展\\n\\n但是我们可以发现，在使用 TypeScript 编写这部分代码时，IDE 会在类型上给我们抛出错误信息，这是因为标准的`lib.dom.d.ts`中没有声明带有各个浏览器前缀的 API，所以是不能直接用`webkitFullScreenEnabled`, `mozFullScreenEnabled`等方法的。\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4752a67e24b43df866a4a0550370a09~tplv-k3u1fbpfcp-watermark.image?)\\n\\n而为了照顾各种浏览器，我们又不得不写这些兼容代码。因此，我们需要对`interface Document`做一些扩展，使得扩展出来的类型能够支持调用`webkitFullScreenEnabled`等方法。\\n\\n考虑到`document`对象是浏览器运行时的全局属性，第一种做法是直接在`global`上扩展`Document`接口。\\n\\n```\\ndeclare global {\\n    interface Document {\\n        webkitFullScreenEnabled?: boolean\\n        mozFullScreenEnabled?: boolean\\n        msFullScreenEnabled?: boolean\\n    }\\n}\\n```\\n\\n在`.ts`文件中，通过`declare global`可以扩展全局类型，再依靠`interface`的 Merge 能力，我们就能对`Document`接口进行扩展，补充一些运行时特有的属性或方法。此时，我们可以观察到类型错误信息已经不存在。\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b8cb3b7ef4f4bf695596282c18d9abb~tplv-k3u1fbpfcp-watermark.image?)\\n\\n另一种做法是定义一个子类型（SubType）继承`Document`接口，我们把这个子类型命名为`EnhancedDocument`，再对这个子类型做扩展，接着用类型断言将`document`对象断言为`EnhancedDocument`类型。\\n\\n```\\ninterface EnhancedDocument extends Document {\\n    webkitFullScreenEnabled?: boolean\\n    mozFullScreenEnabled?: boolean\\n    msFullScreenEnabled?: boolean\\n}\\n```\\n\\n> Sometimes you will have information about the type of a value that TypeScript can’t know about.\\n\\n类型断言是一个从抽象到更具体的做法，有时候我们能知道一些 TypeScript 无法感知的类型信息。在 TypeScript 层面，它认为 document 就是 Document 类型，这是因为 TypeScript 无法确定具体的运行时环境是什么样的。而作为开发者，我们很清楚，当代码在浏览器执行时，它可能会有`webkitFullScreenEnabled`或`mozFullScreenEnabled`等可选属性（取决于浏览器实现），所以断言为`EnhancedDocument`类型也是合理的。\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72f7202f76494d1b873a3ac330baee6e~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## 进入/退出全屏\\n\\n对于进入全屏而言，触发的目标元素可能是`document.body`，也可能是具体的某一个页面元素。考虑到调用[requestFullscreen](https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullScreen)会返回一个 Promise，我们可以将`enterFullscreen`封装为一个异步函数。\\n\\n```typescript\\n/**\\n * 进入全屏\\n * https://developer.mozilla.org/zh-CN/docs/Web/API/Element/requestFullScreen\\n * @param {EnhancedHTMLElement} [element=document.body] - 全屏目标元素，默认是 body\\n * @param {FullscreenOptions} options - 全屏选项\\n */\\nexport async function enterFullscreen(element: EnhancedHTMLElement = document.body, options?: FullscreenOptions) {\\n    try {\\n        if (element.requestFullscreen) {\\n            await element.requestFullscreen(options)\\n        } else if (element.webkitRequestFullScreen) {\\n            await element.webkitRequestFullScreen()\\n        } else if (element.mozRequestFullScreen) {\\n            await element.mozRequestFullScreen()\\n        } else if (element.msRequestFullscreen) {\\n            await element.msRequestFullscreen()\\n        } else {\\n            throw new Error('该浏览器不支持全屏API')\\n        }\\n    } catch (err) {\\n        console.error(err)\\n    }\\n}\\n```\\n\\n退出全屏有一点不一样，因为退出全屏的 API 只在 Document 接口中有定义，这一点可以参考[Fullscreen API Standard](https://fullscreen.spec.whatwg.org/)。\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e93d27f61fb406d808abfc56e76756b~tplv-k3u1fbpfcp-watermark.image?)\\n\\n退出全屏的代码封装如下：\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1d87e8050f64712acd95c050c832f59~tplv-k3u1fbpfcp-watermark.image?)\\n\\n其中有一个`webkitExitFullscreen`和`webkitCancelFullScreen`让我迷惑了一会，最后从 WebKit JS 的文档中了解到已经不建议使用`webkitCancelFullScreen`了。\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc5e4fc5bf584541bc293575e2679f28~tplv-k3u1fbpfcp-watermark.image?)\\n\\n为了避免写太多`as`类型断言，这里通过一个变量`doc`接收了`document`的值，同时将`doc`的类型声明为`EnhancedDocument`。\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/246d56ac93444015b20aa284776596fe~tplv-k3u1fbpfcp-watermark.image?)\\n\\n从类型兼容的角度看，`EnhancedDocument`是`Document`的子类型，一个父类型的值（document）赋给一个子类型的变量（doc）看起来似乎不是类型安全的，但是实际赋值过程中并没有报类型错误，这似乎有违我之前的认知。\\n\\n> 你可以把狗赋值给动物类型，但是不能把动物赋值给狗类型。这就符合类型安全。\\n\\n仔细观察后，我发现这是因为`EnhancedDocument`扩展的属性都是可选的，这种时候，TypeScript 会认为`EnhancedDocument`和`Document`是互相兼容的。从类型的使用上来看也是安全的，如果你要用到可选属性，必然少不了要用到类型守卫。\\n\\n一旦我们给`EnhancedDocument`增加一个必选属性，这种赋值就违背类型兼容了。\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3dd8694be445461380bdd7a926a315d8~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## 获取全屏元素\\n\\n获取全屏元素也只能通过`document`上的`fullscreenElement`属性取得，这在标准中也有定义。\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c61d88b6e0794b578b74b24181be9f9c~tplv-k3u1fbpfcp-watermark.image?)\\n\\n代码相对简单，封装如下：\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f50fffe124f445bcbcd134690f2867f8~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## 判断全屏状态\\n\\n标准中没有告诉我们怎么判断全屏状态，但是我们可以在【获取全屏元素】的基础上得到启发。如果通过`getFullscreenElement`函数得到的结果不是`null`，就可以认为当前是全屏状态。\\n\\n```\\n/**\\n * @description 判断当前是否是全屏状态\\n */\\nexport function isFullscreen(): boolean {\\n    return !!getFullscreenElement() || window.innerHeight === window.screen.height\\n}\\n```\\n\\n为了确保准确性，我还加了一个或的逻辑（判断视口高度和屏幕高度是否一致）。\\n\\n## 监听/取消监听全屏事件\\n\\n事件监听也不复杂，主要是将参数的支持做好，并且把浏览器兼容性考虑在内。\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5de4c561199e4e189ac0f433b87b2221~tplv-k3u1fbpfcp-watermark.image?)\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae42722df02e43548e9c37a783fd89ae~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## 全屏状态一致性问题\\n\\n前面介绍了好几个应用层面的 API，但是我们还遗漏了一个重要问题，就是在上文中提到的 F11 按键和调用 API 的不一致问题，这会导致我们在获取全屏元素和判断全屏状态时都有可能出错。\\n\\n我的做法是：既然 F11 的行为与预期不一致，那我就将 F11 按键逻辑优化一下，禁止其默认行为（进入全屏），并根据当前是否是全屏状态调用`enterFullscreen()`或者`exitFullscreen()`。这样一来，就能保证进入全屏的入口都是通过 API 触发的，从而保证全屏状态的一致性。\\n\\n```\\n/**\\n * 阻止F11按键的默认行为，并根据当前的全屏状态调用进入/退出全屏，\\n * 解决通过F11按键和API两种方式进入全屏时出现的状态不一致问题。\\n */\\nexport function patchF11DefaultAction(): void {\\n    window.addEventListener('keydown', (e) => {\\n        // https://w3c.github.io/uievents-code/\\n        if (e.code === 'F11') {\\n            e.preventDefault()\\n            if (isFullscreen()) {\\n                exitFullscreen()\\n            } else {\\n                enterFullscreen()\\n            }\\n        }\\n    })\\n}\\n```\\n\\n如果您想了解全屏API更细致的内容，可以查阅[Fullscreen API Standard](https://fullscreen.spec.whatwg.org/)。\\n\\n## 封装为 Vue 组件\\n\\n对基础的全屏API做了封装后，我们就可以在此基础上封装一个全屏业务组件了。\\n\\n核心逻辑不复杂，主要是：\\n\\n- 根据当前是否是全屏状态，在 UI 上提供进入/退出全屏的能力。\\n- 在适当的时机检查全屏状态，比如挂载/全屏事件触发后。\\n- 提供函数类型的属性`getElement`，让调用者可以自由选择进入全屏的目标元素。之所以提供函数类型的`getElement`，是为了兼容 dom 异步挂载的情况。\\n\\n由于不同的项目可能对全屏这块的 UI 实现有不同的要求，这里就不细说了，唯一要注意的是全屏态的叠加问题，如果你希望控制 top layer 的叠加问题，就需要在逻辑中控制好进出全屏的顺序问题（比如先退出，再进入，保证只有一个全屏 layer）。注意看 body 和 div 标签右侧的 top-layer。\\n\\n![全屏top-layer叠加.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b92d1dee78cc420da19fa7efe8a47e35~tplv-k3u1fbpfcp-watermark.image?)\\n\\n如果你想要了解组件的具体实现，可以前往[源码](https://github.com/cumt-robin/vue-pro-components/blob/c5/packages/vue-pro-components/src/fullscreen/fullscreen.vue)查看。\\n\\n# Headless 组件\\n\\nHeadless 组件的概念可以类比于 Headless 浏览器，其核心是一种重逻辑、轻 UI 的思想。\\n\\n> 引用 TanStack Table 给出的介绍：\\n>\\n> **Headless UI** is a term for libraries and utilities that provide the logic, state, processing and API for UI elements and interactions, but **do not provide markup, styles, or pre-built implementations**.\\n\\n虽然各大流行组件库都提供了较为通用的样式，并且也能通过覆盖样式支持一定程度上的定制。但是，这种 UI 范式也很难满足复杂的定制需求，我们可能会有这样的困惑：\\n\\n- 明明逻辑很相似，我却无法复用这个组件，需要改源码或者重新开发一个新组件。\\n- 这个组件很契合我的需求，需求做到一半时发现：就差一个 div 不能定制了，其他的都满足需求......\\n- 本来 2 人天的需求，因为某个 UI 组件不可控，直接导致人天翻倍。\\n\\n对于业务开发者来说，我们可能会提出这样的诉求：组件库能不能在提供一套 UI 实现的同时，把组件的所有状态和 API 都开放出来，让我们有自行实现 UI 渲染的可能性呢？这在某种程度上和 Headless 组件的理念不谋而合。\\n\\n## 我对 Headless 的理解\\n\\n介绍 Headless 组件的文章也有不少了，这里简单谈谈我对 Headless 组件的一点粗浅的理解和看法。\\n\\n在我看来，Headless 组件适合的场景是：\\n\\n- 组件逻辑相对简单，但是 UI 通用性不强，经常需要根据业务需求定制 UI 的场景。\\n- 组件逻辑很复杂，需要通过抽象来实现复用，但是服务的上层通常不是具体的业务项目，大概率是组件库。\\n- 跨框架复用，状态和逻辑用纯 js 管理，上层应用再针对框架去做适配层。\\n\\n举实际的例子说明下：\\n\\n场景1：我要实现一个全屏组件，但是有的业务项目希望全屏组件**对应的 UI 是一个按钮**，有的业务项目希望是一个**图标**，有的希望是**图标 + 文字**，甚至有更多可能性......虽然在 UI 方面有**多样性**的需求，但是**底层逻辑都是一样或类似**的，无非就是控制进出全屏、监听全屏的状态等。这种时候，提供一个可复用的 Hook 或者 Headless 组件是值得考虑的。\\n\\n场景2；我所在的公司是字节挑逗（瞎编的），公司有两个子品牌，一个是 dy，一个是 tt，两个团队都有一套组件库，都实现了比较复杂的 Table, Form 等组件，并且都服务了很多个上层业务，可能从直观上看，两套组件库主要是 UI 长得有点不一样，但是底层逻辑差不多。此时，我希望**两个品牌方团队能共用一套逻辑实现组件库，将关键逻辑下沉**。那么 Headless 组件可能是一个解决方案。\\n\\n场景3：我所在的公司是字节挑逗，公司的前端框架既有 Vue，也有 React，在这两套框架之上，都实现了对应的组件库，此时我想把逻辑下沉实现更大程度复用，**状态和逻辑不再依赖任何框架**（纯 js 撸一套，可能再用个类封装下），而在具体的框架之上再做**适配**工作（将**底层封装好的状态和逻辑**与**框架中的状态/属性/事件等概念**结合起来）。当然，这**也适用于跨平台的场景**。\\n\\nHeadless 是**直接服务业务方**，还是**服务特定框架下的 UI 组件库**，亦或是**对接框架或平台的适配层**，都是有可能的，这需要结合实际场景来考虑。Headless 不是万能和普适的，但确实给我们提供了一个新的值得探索的思路。\\n\\n## 开发一个 Headless 组件\\n\\n虽然 Headless 组件也火了一段时间了，但是目前在社区中还没有形成对 Headless 的共识，没有一个我们公认为**最佳实践**的做法。我们的第一个问题可能是：我开发的 Headless 组件要对外输出什么内容？是一个组件，还是一段逻辑？\\n\\n从 Headless 组件的中心思想——**逻辑层与表现层解耦**（具体表现为：内部封装状态和逻辑，对外支持 UI 的高度定制化）来看，这似乎与 Render Props / 作用域插槽 / Hooks 等概念有一定的相似性。如果要跨框架或者跨平台，Headless 组件可能也是纯 JS 的。这就决定了 Headless 组件并不是拘泥于某一种特定的形式，从现在社区中有的一些产品中，我们也能看出一些端倪。\\n\\n- 比如 Semi Design 就将一个组件分为了 Foundation 和 Adapter 部分，Foundation 负责实现组件通用的 JS 逻辑，Adapter 则是针对各个前端框架的适配层。\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ceb99297116455dbefb606c33151456~tplv-k3u1fbpfcp-watermark.image?)\\n\\n- [React Hook Form](https://react-hook-form.com/)也是一种 Headless 的实现，其在 Hook 内部把表单的核心逻辑都实现了，对外提供了状态，方法等，你只要拿着暴露出来的状态和 API，与视图做交互即可，这样一来，你可以在表单 UI 的实现上发挥充分的想象力，而不是局限于修改 css 或者拿着几个有限的 Render Props 做定制。\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d6f64d2a7054410b9cfbadd8e22f8f1~tplv-k3u1fbpfcp-watermark.image?)\\n\\n- 还有直接挂上 Headless 招牌的 TanStack Table。\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/41dff1655b43428487658d602cf33b8a~tplv-k3u1fbpfcp-watermark.image?)\\n\\nTanStack Table 在底层用纯 JS 实现了通用的 core 核心，并在上层提供了各大前端框架的 Adapter，当然你也可以选择直接用它的核心模块`createTable`。\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dadf25bf144b4415a2970574a7356189~tplv-k3u1fbpfcp-watermark.image?)\\n\\n以 Vue 为例，对外提供的`useVueTable`就是将`createTable`核心与 Vue 的各个 API 做了 binding。\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd87d88ebf414a56b4203bc79041716c~tplv-k3u1fbpfcp-watermark.image?)\\n\\n你可能会认为这跟 Hooks 之类的没有区别，这无可厚非，它们确实很相似。不过换个角度看，你可以认为 Hooks 之类的技术底座，是实现 Headless 组件的一种方式或者途径，但是它们并不是严格意义上的一回事。\\n\\n以我们目前实现的这个全屏组件而言，其实它最适合的 Headless 形式是 Hook。首先，我做的这个组件库是面向 Vue 框架的，并不需要像 Semi Design 或者 TanStack Table 这类方案一般提供 JS 层面的抽象。因此，我们借助 Vue Composition API，就能很快抽象出一个可复用的 Headless 组件，这样一来，业务方基于此就能很快定制出自己想要的 UI 效果。\\n\\n> 说了一圈，好像又陷入僵局了。额，Headless 可以是 Hook，也可以不是，不要纠结。\\n\\n那么我们就以这个全屏组件为例说说，怎么做一个 Headless 组件。\\n\\n不管 UI 怎么变，其实只关注两个事情：\\n\\n- 当前是否为全屏状态\\n- 切换全屏状态的 API\\n\\n所以，我们可以把逻辑抽象成这样，对外只暴露`isTargetFullscreen`和`toggleFullscreen`即可：\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3354dcf7e0cf4aedb5a5fe5c9753989a~tplv-k3u1fbpfcp-watermark.image?)\\n\\n这样一来，我们封装的全屏组件就能以这个 Hook 为基础简化：\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d5b767f1ce324c86a81ddacbdeff054f~tplv-k3u1fbpfcp-watermark.image?)\\n\\n同时，外部也可以直接使用`@vue-pro-components/headless`提供的`useFullscreen`能力，实现 UI 自主可控（比如用一个开关组件承载全屏能力）。\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/04511af35001421aa86ed567adb7cc86~tplv-k3u1fbpfcp-watermark.image?)\\n\\n![useFullscreen.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e721d092d0f4552ad069cd8b24d4df5~tplv-k3u1fbpfcp-watermark.image?)\\n\\n# 结语\\n\\n本文和前2篇文章都聚焦于**怎么实现基础的复杂度不高的业务组件**，看起来可能有点枯燥乏味，但也是为了**打个基础，引导部分还不太熟悉组件开发的读者慢慢进入状态，掌握组件开发的一些基本思想**。实际上，**开发组件**和**发布可用的组件**之间还**隔着一条鸿沟**，这就是从开发环境到生产环境必经的路，也是组件库研发过程中最复杂的部分。要越过这条鸿沟，就必须掌握一些工程化能力。如果您对我的专栏感兴趣，欢迎您[订阅关注本专栏](https://juejin.cn/column/7140103979697963045 \\\"https://juejin.cn/column/7140103979697963045\\\")，接下来可以一同探讨和交流组件库开发过程中遇到的问题。",
        "tags": [
            "前端",
            "Vue.js",
            "Vite"
        ]
    },
    {
        "article_id": "7188067538423513144",
        "cover_image": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2ecf2803bad44479ae6b29b1f8fe3bd~tplv-k3u1fbpfcp-watermark.image?",
        "title": "Wasm+vue | 无服务端 录屏、转码、转GIF",
        "brief": "WebAssembly 无服务端实现本地视频转码、屏幕录制、录屏转码、录屏转GIF动图等操作。wasm 作为前端和计算机底层汇编语言直接打交道的媒介，在遇到媒体操作或者大型计算的时候能够以接近本地速度",
        "user_name": "suke",
        "view_count": 1526,
        "collect_count": 45,
        "comment_count": 5,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/9cda32321f2b127f04533d1037e039e4~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: juejin\\n---\\n\\n\\n\\n`wasm`,全称 `WebAssembly`，官网描述： 一种用于基于堆栈的虚拟机的二进制指令格式。`wasm`被设计为一个可移植的目标，用于编译`C/c++/Rust`等高级语言，支持在web上部署客户端和服务器应用程序。`wasm` 的开发者参考文档可以在 [MDN](https://developer.mozilla.org/en-US/docs/WebAssembly) 找到。\\n\\n用大白话讲就是你用 `C/C++/Rust`等语言写的代码，编译后（这个文件一般以wasm结尾）得到汇编指令，然后通过`JavaScript` 相关 `API`配合将该文件加载到Web容器中，字面理解 `WebAssembly` 就是运行在 `Web 容器`里的 `Assembly`（汇编），你可以理解为一种技术就行，其他的不用纠结。\\n既然要用它那必然是因为它有自己独特的优势：即提供了一种以接近本地速度在 Web 上运行以多种语言编写的代码的方法，尤其是涉及到 `CPU` 或者`GPU`计算的时候，比如：`媒体编解码`、`深度学习计算`、`图像处理`等场景。而本文中我们就以`媒体操作`为例，看看能玩出什么花样。\\n\\n## 演示\\n\\n[在线演示地址](https://lav.wangsrbus.cn/)\\n> 宽带比较低，多等一会等wasm文件加载完毕即可体验哦。\\n\\n![GIF.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0cde8f667f94c80a64fa021f0a6a5fd~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n\\n## 预备知识\\n\\n 1.`wasm` 文件在浏览器中单独是无法玩的，既然是浏览器那必然离不开`JavaScript` 相关的 `API`，因为我们在使用现成的一些编译好的模块的时候一定会有初始化的步骤。\\n\\n2.对于 `WebAssembly` 而言，它最终成型的文件就是底层代码，既然是代码那就可以操作内存，相关内存限制为2-4G，[相关文档](https://v8.dev/blog/4gb-wasm-memory#:~:text=Thanks%20to%20recent%20work%20in%20Chrome%20and%20Emscripten%2C,That%E2%80%99s%20up%20from%20the%20previous%20limit%20of%202GB.),但是对于我们使用者而言，内存和我们自己的机器是相关的，如果你的电脑只有4G内存，而且因为其他的程序已经占用了大部分，那么对于wasm代码而言，可以操作的内存就很少了。\\n\\n## 实战\\n\\n这里我们用已经编译好的包 `FFmpeg.wasm` ,去实现我们Web端的媒体编辑，[FFmpeg官网地址](https://github.com/ffmpegwasm/ffmpeg.wasm)。\\n首先我们了解下这个包能干什么？\\n  - 浏览器内存中直接操作文件系统([文件系统接口文档](https://emscripten.org/docs/api_reference/Filesystem-API.html))。\\n  - 支持原生 FFmpeg 的指令，重点。\\n  - 编解码支持 h.265/264等，重点。\\n  \\n我们在本文中用到的就是前面2条，文件操作和FFmpeg原生指令执行，接下来看看我们要达成的目标。\\n- 视频转码\\n- 视频转Gif\\n- 浏览器文件快捷操作\\n  \\n### wasm代码加载\\n> 初始化加载实例并加载wasm代码文件，这里我们并没有看到怎么去加载wasm代码的，实际上我们使用的这个组件给我们封装好了，内部通过 `WebAssembly`模块的相关JavaScript的 API加载 wasm 汇编码然后去初始化。\\n```\\nconst ffmpeg = createFFmpeg({\\n    log: true,//打开日志\\n    progress:p=>{console.log(p)},//回调 展示进度\\n    corePath: new URL('assets/f-core/ffmpeg-core.js', document.location).href,//本地离线wasm代码文件\\n});\\nasync function init(){\\n    await ffmpeg.load();\\n    console.log(\\\"ffmpeg loaded\\\")\\n}\\n```\\n加载成功则如下显示：\\n\\n![1.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cdc57cbbe6df47cf9ea9f586f7f9d837~tplv-k3u1fbpfcp-watermark.image?)\\n\\n### 文件操作\\n 因为涉及到转码，那么必然是要对浏览器产生的相关文件进行所谓的 “本地化”操作，拿到二进制流之后，通过文件系统的 API 去本地化到内存文件系统（MEMFS）中，这里的API并不是`FFmpeg.wasm`自己的，而是它去调用了[相关的API](https://emscripten.org/docs/api_reference/Filesystem-API.html)去实现了这个目的，详细的我们不再阐述，因为里面东西还是比较多的。\\n\\n以本文Demo操作为例\\n\\n- 获取文件二进制流\\n\\n```\\n// file 可以为连接文件 也可以为 二进制的数据\\nlet data = await fetchFile(this.file)\\n\\n```\\n- 写入MEMFS\\n  \\n```\\nthis.ffmpeg.FS(\\\"writeFile\\\", \\\"suke.mp4\\\", data);\\n\\n```\\n- 读取文件到浏览器中\\n\\n```\\n//读取视频数据\\nlet memfsData = ffmpeg.FS('readFile', 'suke.mp4');\\n//创建虚拟URL\\nthis.transcodeUrl = URL.createObjectURL(new Blob([memfsData.buffer], { type: \\\"video/mp4\\\" }));\\n\\n```\\n- 文件系统中删除数据\\n\\n```\\nffmpeg.FS('unlink', 'suke.mp4');\\n\\n```\\n\\n### 媒体操作\\n将相关文件本地化到文件系统之后，我们就可以利用 ffmpeg的原生命令去执行转码操作，比如将mp4格式转为avi的\\n\\n```\\n//本地化文件\\nthis.ffmpeg.FS(\\\"writeFile\\\", \\\"suke.avi\\\", await fetchFile(this.file));\\n//进行转码\\nawait this.ffmpeg.run(\\\"-i\\\", \\\"suke.avi\\\", \\\"suke.mp4\\\");\\n//转码完成后读取数据\\nconst data = this.ffmpeg.FS(\\\"readFile\\\", \\\"suke.mp4\\\");\\n//获取页面DOM实例，然后挂载虚拟URL\\nconst video = document.getElementById('playerForTransf');\\nthis.transcodeUrl = URL.createObjectURL(\\n    new Blob([data.buffer], { type: \\\"video/mp4\\\" })\\n);\\nvideo.src = this.transcodeUrl\\n```\\n\\n\\n![2222.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee396d21b24342e0af7a5160969f761a~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n\\n### 视频转GIF\\n\\n这个操作实际上和上一步一样，都是执行的原生ffmpeg的命令，然后输出GIF文件，展示并下载\\n\\n```\\n//GIF时长\\nlet time = this.formForGifParams.time+\\\"\\\"\\n//GIF的FPS\\nlet fps = this.formForGifParams.fps\\n//GIF的清晰度\\nlet vh = this.formForGifParams.scale\\nlet params = `fps=${fps},scale=${vh}:-1:flags=lanczos,split[s0][s1];[s0]palettegen[p];[s1][p]paletteuse`\\n//this.chunks 为本地录制屏幕的二进制数据 也可以和文件连接一样 本地化到文件系统中\\nthis.ffmpeg.FS(\\\"writeFile\\\", \\\"out.mp4\\\", await fetchFile((this.chunks)));\\n//转换为GIF操作\\nawait this.ffmpeg.run(\\\"-t\\\", time, \\\"-i\\\", \\\"out.mp4\\\", \\\"-vf\\\",params, \\\"-loop\\\", \\\"0\\\" ,\\\"output.gif\\\");\\n//读取GIF数据\\nconst data = this.ffmpeg.FS(\\\"readFile\\\", \\\"output.gif\\\");\\nconst image = document.getElementById('imagePre');\\n//本地DOM实例中展示\\nimage.src = URL.createObjectURL(\\n    new Blob([data.buffer], { type: \\\"image/gif\\\" })\\n);\\n//操作完成后删除文件\\nthis.ffmpeg.FS('unlink','out.mp4')\\n```\\n\\n\\n![333.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/48b2fc4133254e8fbffbc1580a2a8123~tplv-k3u1fbpfcp-watermark.image?)\\n### 获取录屏的二进制数据并本地化\\n\\n```\\nasync function screenRecord(){\\n    ElNotification({\\n        title: '温馨提示',\\n        message: '开始录屏，请选择要录制的窗口',\\n        type: 'success',\\n    })\\n    stream = await navigator.mediaDevices.getDisplayMedia(mediaConstraints);\\n    var options = {mimeType: recordMediaType};\\n    mediaRecorder = new MediaRecorder(stream, options);\\n    mediaRecorder.start();\\n    //停止录屏后触发保存\\n    mediaRecorder.ondataavailable = async function(e) {\\n        console.log(\\\"data available\\\", e.data);\\n        chunks.value = e.data\\n        //这一步并不一定要在这里本地化到文件系统 等需要媒体操作的时候再进行最佳\\n        this.ffmpeg.FS(\\\"writeFile\\\", \\\"suke.avi\\\", await fetchFile(this.chunks));\\n\\n    }\\n    recordStatus.value = mediaRecorder.state\\n}\\n\\n\\n```\\n\\n### 获取摄像头录制的二进制数据并本地化\\n\\n```\\nasync function localCamRecord(){\\n    ElNotification({\\n        title: '温馨提示',\\n        message: '开始摄像头画面录制',\\n        type: 'success',\\n    })\\n    stream = await navigator.mediaDevices.getUserMedia(mediaConstraints);\\n    var options = {mimeType: recordMediaType};\\n    mediaRecorder = new MediaRecorder(stream, options);\\n    mediaRecorder.start();\\n    //停止录屏后触发保存\\n    mediaRecorder.ondataavailable = async function(e) {\\n        console.log(\\\"data available\\\", e.data);\\n        chunks.value = e.data\\n        //同上 按照实际情况处理\\n        this.ffmpeg.FS(\\\"writeFile\\\", \\\"suke.avi\\\", await fetchFile(this.chunks));\\n    }\\n    recordStatus.value = mediaRecorder.state\\n}\\n```\\n\\n\\n## 完整代码\\n\\n[完整代码](https://gist.github.com/wangsrGit119/46380e8bedc48157037c4ca622b7f30e)\\n\\n\\n\\n## 最后\\n\\n- 上面涉及到了和摄像头、流媒体相关的，如果大家对WebRTC感兴趣的话可以看看掘金小册[使用WebRTC搭打造私有化直播会议系统](https://juejin.cn/book/7168418382318927880)\\n- 有问题评论区一起讨论\\n",
        "tags": [
            "前端",
            "WebAssembly",
            "Vue.js"
        ]
    },
    {
        "article_id": "7195014110411980859",
        "cover_image": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89f9364d7dce407ab61868373f494b11~tplv-k3u1fbpfcp-watermark.image?",
        "title": "灰色预测模型一文详解+Python实例代码",
        "brief": "开启掘金成长之旅！这是我参与「掘金日新计划 · 2 月更文挑战」的第 1 天，点击查看活动详情 前言 博主参与过大大小小十次数学建模比赛，也获得了不少建模奖项。对于一些小批量样本数据去做预测或者是评估",
        "user_name": "fanstuck",
        "view_count": 581,
        "collect_count": 1,
        "comment_count": 0,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/0bb8420994c6b7846f639a097bd11e95~300x300.image",
        "category": "人工智能",
        "content": "**开启掘金成长之旅！这是我参与「掘金日新计划 · 2 月更文挑战」的第 1 天，[点击查看活动详情](https://juejin.cn/post/7194721470063312933 \\\"https://juejin.cn/post/7194721470063312933\\\")**\\n\\n# 前言\\n博主参与过大大小小十次数学建模比赛，也获得了不少建模奖项。对于一些小批量样本数据去做预测或者是评估其规律性的话，比较适合的模型一般都是选择灰色预测模型。该模型解释性强而且易于理解，建模手段也比较简单。在一些不确定是否存在相关标量或者是存在位置特征的时候，用灰色预测模型尤为明显，牵扯太多变量时候可以以量曾量减的方式显现其变化规律，是建模比较好用的算法和思路。但是首先我们要明白该模型的使用场景以及优缺点才能更好的解释建模的效果。故为接下来的美赛，我将把一些常用建模的模型和代码补上。\\n\\n# 一、模型理论\\n灰色预测模型是通过少量的、不完全的信息，建立数学模型做出预测的一种预测方法。是基于客观事物的过去和现在的发展规律，借助于科学的方法对未来的发展趋势和状况进行描述和分析，并形成科学的假设和判断。\\n\\n我们称信息完全未确定的系统为**黑色系统**，称信息完全确定的系统为**白色系统**，灰色系统就是这介于这之间，**一部分信息是已知的，另一部分信息是未知的**，系统内各因素间有不确定的关系。\\n\\n不知道大家知不知道白盒测试和黑盒测试，我们可以这样通俗的理解，黑色系统就好比一个黑色的盒子你看不到里面装着几个小球，从里面拿出几个小球或者是章鱼都是未知数。而白色系统就像是透明的盒子，你能很清楚的看到里面是什么你想要拿什么出来拿多少个。而这个灰色系统介于他们之间，盒子是灰色的，只能模糊的看到一些小球，看不到几个或者是有除了小球以外的其他东西。\\n\\n灰色预测通过鉴别系统因素之间发展趋势的相异程度，即进行关联分析，并对原始数据进行生成处理来寻找系统变动的规律，生成有较强规律性的数据序列，然后建立相应的微分方程模型，从而预测事物未来发展趋势的状况。其用等时距观测到的反映预测对象特征的一系列数量值构造灰色预测模型，预测未来某一时刻的特征量，或达到某一特征量的时间。\\n## 特点\\n-   用灰色数学处理不确定量，使之量化。\\n-   充分利用已知信息寻求系统的运动规律。\\n-   灰色系统理论能处理贫信息系统。\\n\\n# 二、模型场景\\n## 1.预测种类\\n\\n- 灰色时间序列预测；即用观察到的反映预测对象特征的时间序列来构造灰色预测模型，预测未来某一时刻的特征量，或达到某一特征量的时间。\\n- 畸变预测；即通过灰色模型预测异常值出现的时刻，预测异常值什么时候出现在特定时区内。\\n- 系统预测；通过对系统行为特征指标建立一组相互关联的灰色预测模型，预测系统中众多变量间的相互协调关系的变化。\\n- 拓扑预测；将原始数据作曲线，在曲线上按定值寻找该定值发生的所有时点，并以该定值为框架构成时点序列，然后建立模型预测该定值所发生的时点。\\n## 2.适用条件\\n\\n灰色预测模型可针对数量非常少（比如仅4个），数据完整性和可靠性较低的数据序列进行有效预测，其利用微分方程来充分挖掘数据的本质，建模所需信息少，精度较高，运算简便，易于检验，也不用考虑分布规律或变化趋势等。但灰色预测模型一般只适用于短期预测，只适合指数增长的预测，比如人口数量，航班数量，用水量预测，工业产值预测等。\\n\\n# 三、建模流程\\n总体建模流程可以参考：\\n\\n![图片.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/41f19c7976dd49a38b7bbce5a4a9538a~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## 1.级比校验\\n首先我们要保证该数据适用于GM(1,1)模型，那么就要对已知数据进行校验是否可用。\\n假设原始数据![x^{(0)}](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/80ef59bf0749410ebf38274c0873aa64~tplv-k3u1fbpfcp-zoom-1.image):\\n\\n![x^{(0)}=(x^{(0)}(1),x^{(0)}(2),x^{(0)}(3),...,x^{(0)}(n))](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/60c97ce67cc940eaa873f3d249d4c6f6~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n计算数列的级比![\\\\lambda (k)](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/432f0d46daf84cf1aa5430110e565e69~tplv-k3u1fbpfcp-zoom-1.image):\\n\\n\\n![图片.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72779a99bd51452393b6b8bcaaf8fbfe~tplv-k3u1fbpfcp-watermark.image?)\\n\\n如果所有的级比![\\\\lambda (k)](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94c0566529084386a79390ed37b4ae9f~tplv-k3u1fbpfcp-zoom-1.image)都落在![(e^\\\\frac{-2}{n+1},e^\\\\frac{2}{n+2})](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/892541e102864ac085c7036868c4126b~tplv-k3u1fbpfcp-zoom-1.image)内，则数列![x^{(0)}](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a7c384b3651408688c39aa394d864cf~tplv-k3u1fbpfcp-zoom-1.image)可以作为模型GM(1,1)的数据进行灰色预测。**如果没通过，对数列**![x^{(0)}](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e42c666016e940b9a87c3fc148cbcb5b~tplv-k3u1fbpfcp-zoom-1.image)**做变化处理，使其落入范围内。即取适当的常数c** **，做平移交换：**\\n\\n\\n![图片.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a2b220733184cd5a5e5b42f98622fa2~tplv-k3u1fbpfcp-watermark.image?)\\n\\n再进行级比检验，直至通过或者更换模型。\\n## 2.**数据累加和微分方程构造**\\n对原始数据列![x^{(0)}](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87e4d2ef5dfe4c12910514f392095f3a~tplv-k3u1fbpfcp-zoom-1.image)做一次累加(AGO)生成数列![x^{(1)}](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c9d4d8e778648dfa5cc301b3489eb27~tplv-k3u1fbpfcp-zoom-1.image):\\n\\n\\n![图片.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c8d66e0f1ad24e36b192574bb1d7aebb~tplv-k3u1fbpfcp-watermark.image?)\\n\\n对应的微分方程为：(a为发展系数，u为灰作用量）\\n\\n![图片.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a60fc7eb1934db7ad189dc4206cbf1c~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## 3.系数求解\\n\\n接下来就到了最关键的一部，想要求解上述微分方程：\\n![图片.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c3a5a719f914482a471917fe05489ff~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n就必须解出系数a和b，让**微分方程的解与真实的已知数据最接近。** 函数表达式的**参数a和u未知**，而**变量t和x^(1)的数值已知**，这种问题就要用**最小二乘法**，通过最小化误差的平方和求得最佳的参数a和b。\\n\\n1、数据是离散的而不是连续的，所以：\\n\\n![\\\\frac{dx^{(1)}}{dt}](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/767e85da41b04e89b64800fe24eeb3ec~tplv-k3u1fbpfcp-zoom-1.image)写作![\\\\frac{\\\\Delta x^{(1)}}{\\\\Delta t}](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea488e93918046bbbee31279d4df1e34~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n2.根据累加生成序列公式可知：\\n\\n![\\\\Delta x^{(1)}=x^{(1)}(t)-x^{(1)}(t-1)=x^{(0)}(t)](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2621647b3a434bccaf044120a14c737b~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n3.由1和2可得到\\n\\n![x^{(0)}(t)+ax^{(1)}(t)=d](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ecf15dd44b84a72bbfa9bacb6eb9c61~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n4.移项得：\\n\\n![x^{(0)}(t)=-ax^{(1)}(t)+d](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/34b0f8bcefd94c6795f193e855fb010f~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n5、式子左边是已知数据，右边就是含有未知数的函数，此时就可用最小二乘法求出参数a和u\\n\\n数据矩阵B：\\n\\n![图片.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/702a20ebec114ee5b4c7074a29c260f0~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n数据向量Y：\\n\\n\\n![图片.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c97db9f7e5e4a44b4ac199bcc00fae6~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n其中z(1)为加权平均值：\\n\\n![图片.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be472a490eda49cc8ad95fdc4b354258~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n计算系数u(最小二乘法)：\\n\\n![图片.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c6745eafd8d543cf83692d0d25ed3228~tplv-k3u1fbpfcp-watermark.image?)\\n\\n对前面的微分方程求解可得：\\n\\n![图片.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b9e297ba44d945c98d3e2a47ef145b3d~tplv-k3u1fbpfcp-watermark.image?)\\n\\n由上面三式可得：(**最终结果**)\\n\\n![图片.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e83e12baf5347c1ac82acb02f71d8c0~tplv-k3u1fbpfcp-watermark.image?)\\n\\n##  4.**残差检验与级比偏差检验**\\n\\n残差检验\\n\\n![图片.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36cbaae2ba5e41f58b4fbf2b8e03fd9f~tplv-k3u1fbpfcp-watermark.image?)\\n\\n如果![\\\\varepsilon (k)](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d7eef480798f4a12a5f367a951b41341~tplv-k3u1fbpfcp-zoom-1.image)<0.2,，则可认为达到一般要求；如果![\\\\varepsilon (k)](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b29fabcc3de4b8d9e9f47e4c37f9862~tplv-k3u1fbpfcp-zoom-1.image)<0.1，则认为达到较高的要求。\\n\\n\\n级比偏差检验\\n\\n![图片.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76d5af27c4dc417f85865b97dd781c4b~tplv-k3u1fbpfcp-watermark.image?)\\n\\n如果![\\\\rho (k)<0.2](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/248bb09c0cbf40da9b2c803baba97caf~tplv-k3u1fbpfcp-zoom-1.image)，则可认为达到一般要求；如果![\\\\rho (k)<0.2](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/418ec762bb1f4a7d93190a334bac6ad5~tplv-k3u1fbpfcp-zoom-1.image)，则认为达到较高的要求。\\n\\n# 四、Python实例实现\\n\\n![图片.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f9b8364800f409b9b88dfbd1656e488~tplv-k3u1fbpfcp-watermark.image?)\\n\\n我们通过得到的周数拥堵车辆数据进行测试：\\n\\n```\\nimport numpy as np\\nimport pandas as pd\\nfrom decimal import *\\nimport matplotlib.pyplot as plt\\ndef Grade_ratio_test(X0):\\n    lambds = [X0[i - 1] / X0[i] for i in range(1, len(X0))]\\n    X_min = np.e ** (-2 / (len(X0) + 1))\\n    X_max = np.e ** (2 / (len(X0) + 1))\\n    for lambd in lambds:\\n        if lambd < X_min or lambd > X_max:\\n            print('该数据未通过级比检验')\\n            return False\\n    print('该数据通过级比检验')\\n    return True\\ndef model_train(X0_train):\\n    #AGO生成序列X1\\n    X1 = X0_train.cumsum()\\n    Z= (np.array([-0.5 * (X1[k - 1] + X1[k]) for k in range(1, len(X1))])).reshape(len(X1) - 1, 1)\\n    # 数据矩阵A、B\\n    A = (X0_train[1:]).reshape(len(Z), 1)\\n    B = np.hstack((Z, np.ones(len(Z)).reshape(len(Z), 1)))\\n    # 求灰参数\\n    a, u = np.linalg.inv(np.matmul(B.T, B)).dot(B.T).dot(A)\\n    u = Decimal(u[0])\\n    a = Decimal(a[0])\\n    print(\\\"灰参数a：\\\", a, \\\"，灰参数u：\\\", u)\\n    return u,a\\ndef model_predict(u,a,k,X0):\\n    predict_function =lambda k: (Decimal(X0[0]) - u / a) * np.exp(-a * k) + u / a \\n    X1_hat = [float(predict_function(k)) for k in range(k)]\\n    X0_hat = np.diff(X1_hat)\\n    X0_hat = np.hstack((X1_hat[0], X0_hat))\\n    return X0_hat\\n'''\\n根据后验差比及小误差概率判断预测结果\\n:param X0_hat: 预测结果\\n:return:\\n'''\\ndef result_evaluate(X0_hat,X0):\\n    S1 = np.std(X0, ddof=1)  # 原始数据样本标准差\\n    S2 = np.std(X0 - X0_hat, ddof=1)  # 残差数据样本标准差\\n    C = S2 / S1  # 后验差比\\n    Pe = np.mean(X0 - X0_hat)\\n    temp = np.abs((X0 - X0_hat - Pe)) < 0.6745 * S1    \\n    p = np.count_nonzero(temp) / len(X0)  # 计算小误差概率\\n    print(\\\"原数据样本标准差：\\\", S1)\\n    print(\\\"残差样本标准差：\\\", S2)\\n    print(\\\"后验差比：\\\", C)\\n    print(\\\"小误差概率p：\\\", p)\\n\\nif __name__ == '__main__':\\n    plt.rcParams['font.sans-serif'] = ['SimHei']  # 步骤一（替换sans-serif字体）\\n    plt.rcParams['axes.unicode_minus'] = False  # 步骤二（解决坐标轴负数的负号显示问题）\\n        # 原始数据X\\n    \\n    data = pd.read_excel('./siwei_day_traffic.xlsx')\\n    X=data[data['week_day']=='周五'].jam_num[:5].astype(float).values\\n    print(X)\\n    # 训练集\\n    X_train = X[:int(len(X) * 0.7)]\\n    # 测试集\\n    X_test = X[int(len(X) * 0.7):]\\n \\n    Grade_ratio_test(X_train)  # 判断模型可行性\\n    a,u=model_train(X_train)  # 训练\\n    Y_pred = model_predict(a,u,len(X),X)  # 预测\\n    Y_train_pred = Y_pred[:len(X_train)]\\n    Y_test_pred = Y_pred[len(X_train):]\\n    score_test = result_evaluate(Y_test_pred, X_test)  # 评估\\n \\n    # 可视化\\n    plt.grid()\\n    plt.plot(np.arange(len(X_train)), X_train, '->')\\n    plt.plot(np.arange(len(X_train)), Y_train_pred, '-o')\\n    plt.legend(['负荷实际值', '灰色预测模型预测值'])\\n    plt.title('训练集')\\n    plt.show()\\n \\n    plt.grid()\\n    plt.plot(np.arange(len(X_test)), X_test, '->')\\n    plt.plot(np.arange(len(X_test)), Y_test_pred, '-o')\\n    plt.legend(['负荷实际值', '灰色预测模型预测值'])\\n    plt.title('测试集')\\n    plt.show()\\n \\n \\n```\\n\\n# 总结\\n\\n模型优点：数据少且无明显规律时可用，利用微分方程挖掘数据本质规律。\\n\\n模型缺点：灰色预测只适合短期预测、指数增长的预测。",
        "tags": [
            "数据分析",
            "数据挖掘",
            "掘金·日新计划"
        ]
    },
    {
        "article_id": "7172463807363547149",
        "cover_image": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/360520dcb58949f0a11b52bc4dd11b91~tplv-k3u1fbpfcp-watermark.image?",
        "title": "你不会还不知道如何监测用户的网络是否在线吧？",
        "brief": "我最近遇到一个需求，要给网站添加一个用户网络离线提醒。要求我们要实时监测用户的网络状态，当用户断网了，我们要立马给用户弹出一个断网提醒。 那你可能会问，为什么要做这么一个需求呢？用户断网了，网页不就",
        "user_name": "zayyo",
        "view_count": 4238,
        "collect_count": 95,
        "comment_count": 16,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/b59e1130f17ce4c67aabab53ceea5d0e~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: scrolls-light\\nhighlight: solarized-light\\n---\\n开启掘金成长之旅！这是我参与「掘金日新计划 · 12 月更文挑战」的第11天，[点击查看活动详情](https://juejin.cn/post/7167294154827890702 \\\"https://juejin.cn/post/7167294154827890702\\\")\\n\\n我最近遇到一个需求，要给网站添加一个用户网络离线提醒。要求我们要实时监测用户的网络状态，当用户断网了，我们要立马给用户弹出一个断网提醒。\\n\\n那你可能会问，为什么要做这么一个需求呢？用户断网了，网页不就加载不出来了吗？用户不就知道了吗？\\n\\n哈哈这确实也是一种情况，但是这只其中一种情况，在现实中更多的情况是，用户在访问我们的网站时发生断网，这时我们的网站数据已经被浏览器缓存，因此在网站上并看不出有什么不同。只有在加载新内容的情况下才会有所区别。那当然这样给用户的体验是十分不好的，所以我们要在用户网络断开的时候，给用户弹出一个弹框。来告诉用户网站新内容加载不出来的原因。来提高用户的体验感\\n\\n# 如何检查是否有网络\\n我们可以利用`navigator.onLine`API 来检测网络状态。`navigator.onLine`会返回一个布尔值来显示用户是否在线。`true`表示在线，`false`表示离线，只要浏览器连接到网络的状态发生改变，属性值就会发生改变\\n\\n我们可以监听网页加载事件，在网页加载时获取`navigator.onLine`的值\\n```js\\nwindow.addEventListener('load', () => {\\n  const status = navigator.onLine;\\n});\\n```\\n上面的做法在网站最开始加载的时，是可以准确获取用户的网站状态的。但是有一个缺点，就是当获取完用户的网络状态后，网络又发生改变，状态值会无法及时更新！！！\\n\\n### 怎么才能解决这个问题呢？\\n> 我们可以写一个监听断网和联网来解决这个问题\\n\\n```js\\nwindow.addEventListener('offline', (e) => {\\n  console.log('offline');\\n});\\n\\nwindow.addEventListener('online', (e) => {\\n  console.log('online');\\n});\\n```\\n那我们来做一个完整的小案例来监测我们的用户是否断网\\n## 小案例\\n\\n![a.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f6b972225b347d59ee9c15ab3d92f5a~tplv-k3u1fbpfcp-watermark.image?)\\n[代码片段](https://code.juejin.cn/pen/7172449448751497252)\\n#### HTML\\n```\\n<div class=\\\"status\\\">\\n  <div class=\\\"offline-msg\\\">你的网络断开了  😢</div>\\n  <div class=\\\"online-msg\\\"> 你已经连上网络 🔗</div>\\n</div>\\n```\\n#### CSS\\n\\n```js\\nhtml, body {\\n    padding: 0;\\n    margin: 0;\\n}\\n.status {\\n    background: #efefef;\\n    display: flex;\\n    justify-content: center;\\n    align-items: center;\\n    min-height: 100vh;\\n}\\n.offline .online-msg {\\n    display: none;\\n}\\n.offline .offline-msg {\\n    display: block;\\n}\\n div {\\n    padding: 1rem 2rem;\\n    font-size: 3rem;\\n    border-radius: 1rem;\\n    color: white;\\n    font-family: Roboto, \\\"Helvetica Neue\\\", Arial, sans-serif;\\n}\\n .online-msg {\\n    background: green;\\n    display: block;\\n}\\n.offline-msg {\\n    background: red;\\n    display: none;\\n}\\n\\n```\\n#### JavaScript\\n\\n```js\\nconst status1 = document.querySelector(\\\".status\\\");\\n//load 监听网页加载事件\\nwindow.addEventListener(\\\"load\\\", () => {\\n  const handleNetworkChange = () => {\\n    if (navigator.onLine) {\\n      //给status下的offline-msg和online-msg添加类名样式\\n      status1.classList.remove(\\\"offline\\\");\\n    } else {\\n      //给status下的offline-msg和online-msg添加类名样式\\n      status1.classList.add(\\\"offline\\\");\\n    }\\n  };\\n// online该事件在浏览器开始在线工作时触发\\n  window.addEventListener(\\\"online\\\", handleNetworkChange);\\n  // offline该事件在浏览器开始离线工作时触发。\\n  window.addEventListener(\\\"offline\\\", handleNetworkChange);\\n});\\n\\n```\\n",
        "tags": [
            "掘金·日新计划",
            "前端",
            "JavaScript"
        ]
    },
    {
        "article_id": "7193206064962404411",
        "cover_image": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9953778d8d4f463884966f8d5cb8a3d0~tplv-k3u1fbpfcp-watermark.image?",
        "title": "作为一个学会智能合约的前端开发者，该如何找到 Web3 工作？",
        "brief": "最近有个朋友咨询我一个问题。 他做前端大概有五年了，技术比较一般。从去年开始就一直非常看好 web3 方向。但在 web2 的公司做久了，有一种思维定性，没有下定决心学习 web3 的技术，也不知道从",
        "user_name": "代码与野兽",
        "view_count": 3963,
        "collect_count": 85,
        "comment_count": 7,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/dac9f5ba3e7b6d8015a9b37536d4ef59~300x300.image",
        "category": "前端",
        "content": "最近有个朋友咨询我一个问题。\\n\\n他做前端大概有五年了，技术比较一般。从去年开始就一直非常看好 web3 方向。但在 web2 的公司做久了，有一种思维定性，没有下定决心学习 web3 的技术，也不知道从何而起。\\n\\n后来他看到我开始布道 web3，纠结了一段时间，前段时间终于下定决心，开始跟着我学起了他犹豫了一年的 web3 技术。\\n\\n从 solidity 开始，到 truffle、ethersjs 等等，把常用的技术全学了一遍。也根据我的 github 项目做了三四个入门级别的 DApp，整个开发流程也相对熟悉。\\n\\n这是 Github 项目地址：[github.com/luzhenqian/web3-examples](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fluzhenqian%2Fweb3-examples \\\"https://github.com/luzhenqian/web3-examples\\\")\\n\\n\\n但现在仍然很迷茫，因为现在的他需要一个真正转型的契机，也就是寻找一份 web3 工作。\\n\\n这种迷茫，在我的理解中，应该是一类通用问题，也就是：**作为一个前端开发者，在学会了智能合约后如何加入到 Web3 开发的公司或者团队。**\\n\\n我相信存在这类问题的人不在少数，所以在我帮朋友解惑后，顺便把这个过程中的一些思考整理出来，帮助更多存在同类问题的小伙伴答疑。\\n\\n要完成这个任务，我认为需要做四个阶段的准备：确认自身技术栈、确认自身领域、确认目标公司、自我准备。\\n\\n首先第一个就是整理好你的定位与技术栈。找工作这件事，其实就是营销。你需要把自己包装成产品，然后要对产品进行定位与美化。\\n\\n如果仍然锚定做开发者，那么定位主要分两个：\\n\\n1.  仍然主做前端。\\n1.  全栈。做合约开发，同时也做前端。\\n\\n第二个就是确定好自己切入的细分领域，你可以理解为主要业务范畴。\\n\\nWeb3 目前的领域非常多，比如：\\n\\n-   交易所。\\n-   公链。\\n-   NFT 交易所。\\n-   钱包。\\n-   链游。\\n-   DID。\\n\\n第三个就是想好自己要加入的公司类型，这个时候公司就是你的用户，你需要给公司画用户画像。\\n\\n以 base 为维度进行划分，基本上有三类：\\n\\n-   remote\\n-   国外\\n-   国内\\n\\n以规模进行划分，大概也有几类：\\n\\n-   顶级大厂，比如头部交易所和公链。\\n-   独角兽公司，拿到千万级别美金的知名公司。\\n-   商业化公司，拿到千万级别人民币的知名项目。\\n-   增长阶段的公司，有一些用户，拿到了一些资本投资，处于增长阶段的公司。\\n-   创业公司，还没有什么钱，也没有什么用户的刚起步的公司。\\n\\n最后一个，你需要编写自己的简历。\\n\\n如果你没有经验，那就自己给自己增加一些经验，比如想办法参加一些黑客松，参加一些社区活动，也可以在 Github 上做一些小项目，不一定功能很庞大很复杂，但一定要有创意和创新，小而美。\\n\\n## 产品定位\\n\\n先来看产品定位，也就是自身的问题。\\n\\n技术栈我推荐你这么选：\\n\\n-   next.js：最流行的前端框架，没有备选。\\n-   tailwindcss：最流行的 CSS 框架，没有备选。\\n-   solidity：最流行的智能合约编程语言，没有备选。\\n-   ethersjs：最流行的智能合约交互库，备选是 web3.js。\\n-   wagmi：最流行的 React Hook 智能合约交互库，没有备选。\\n-   hardhat：最流行的智能合约开发框架，备选是 truffle。\\n-   open zeppelin：最流行的智能合约库。\\n\\n业务领域没有局限，都可以选择。但一定要有自己最擅长的那一个，也就是专精领域。在你的专精领域中，你就是专家，你可以一直侃侃而谈，但一定不能被问得哑口无言。比如选择 NFT。你需要把 NFT 相关的协议全部搞得非常明白，比如 ERC721、ERC1155 等。同时还需要知道白名单是怎么做的、荷兰拍卖该怎么去做、NFT 交易所怎么做，手续费如何抽取、NFT 的一些种类，PFP 背后的逻辑等等、一些蓝筹项目是如何运作起来的、NFT 创作网站的流程及实现方案等等。千万不要什么都懂，但什么都不精通。\\n\\n## 用户画像\\n\\n接下来就是用户画像，也就是公司的定位。\\n\\n我推荐的公司画像是这样：remote、国外。规模的话自然是越大越好，因为薪资报酬相对都更稳定。当然一些小而美的公司也不错。在正式投递简历之前，一定要对公司进行全方位了解。比如公司的主营业务是什么，不存在实际价值的公司一定不要去。所谓实际价值，就是能够解决某一个或一类真实存在并有意义的实际问题。同时也要看一下团队背景和创始人背景。\\n\\n简历阶段，我建议根据意向岗位来定制自己的简历。提高通过率，节省时间成本。首先在简历上把自己的技术体系写清楚，尽量契合目标岗位。在商业化以上的公司里面，更注重个人领域的细分，他们通常更看重你的技术深度，因为他们把你招进去是要做螺丝钉的。所以你需要在这方面多加准备。如果是创业阶段或者增长阶段的公司，他们通常更看重你的想法，因为在这个阶段中，他们的产品也是在得到用户反馈后迅速变化的，并没有形成固有的形态，他们需要你去和他们一起 building 产品。\\n\\n另外在简历上也有一些小技巧。比如尽量把头像放上去，很多欧美的公司都需要通过头像知道你的肤色和你是哪国人。同时简历中不要使用很糟糕的英文。有找一些优质的简历模板进行参照。总之要从一些细节之处来展现你的专业度。\\n\\n最后祝你早日加入理想的公司。\\n\\n我们是一群立志改变世界的人。而 Web3 是未来世界一大变数，我们想帮助更多人了解并加入 Web3，如果你对 Web3 感兴趣，可以添加我的微信：LZQ20130415，邀你入群，一起沉淀、一起成长、一起拥抱未来。\\n",
        "tags": [
            "前端",
            "后端",
            "web3"
        ]
    },
    {
        "article_id": "7160491044222533639",
        "cover_image": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d14b9284489a41fb9894453e3740469c~tplv-k3u1fbpfcp-watermark.image?",
        "title": "【Canvas实战】仿明日方舟Logo粒子动画 vue3+ts",
        "brief": "本文通过实现明日方舟游戏官网中的Logo粒子动画来学习如何更深层次的使用canvas，相信最后你也会喜欢上它😊。 canvasAPI数量精简，参数清晰，学习并不复杂，更多的是如何实践应用。",
        "user_name": "西维",
        "view_count": 4300,
        "collect_count": 207,
        "comment_count": 35,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/edcdbbde0d6f5cb89d7c28187ed55480~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: arknights\\nhighlight: a11y-dark\\n---\\n\\n> 输出内容才能更好的理解学习的知识  \\n> \\n> 对于Canvas不够了解的同学，欢迎查阅前文[《一文入坑【Canvas】多图与案例详解》](https://juejin.cn/post/7152355177666707493)\\n## 前言🎀  \\n如果你是明日方舟玩家肯定对[游戏官网](https://ak.hypergryph.com/)有深刻的印象，不得不说鹰角的前端很厉害。\\n\\n作为前端开发者肯定是第一时间F12开始审查元素😆不难发现页面中不少特效都是通过`<canvas>`标签实现的。\\n\\n例如这个阵营Logo的粒子动画：\\n\\n![粒子动画.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09c7828e41d3461e83df40ab12c8d7b5~tplv-k3u1fbpfcp-watermark.image?)\\n\\n很明显使用了 canvas2d 中的 **像素操作**，今天我们一起研究下它是怎么实现的。\\n\\n如果觉得有收获还望大家点赞、收藏🌹\\n\\n## 最终效果\\n后续内容论述较多，就先把最终效果放上来了。\\n\\n### 动画\\n![粒子动画2.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/26cd3f9122f3471a8afe6018255cdfcf~tplv-k3u1fbpfcp-watermark.image?)\\n### demo  \\n不知道为啥要运行两次，想试用的同学再点下运行就可以看了\\n[代码片段](https://code.juejin.cn/pen/7140233634119680014)\\n\\n### 源码  \\n应掘友要求整理上传了份源码：\\n\\nhttps://github.com/XIwE1/ark-particle-animation\\n\\n顺便简述下实现方法，希望能帮助你理解😉\\n\\n主要使用三个类：Particle 粒子类、LogoImg 图片类、ParticleCanvas 画布类\\n\\n1. **Particle：** 记录粒子位置、颜色、大小、动画耗时 和 x/y 方向上的移动速度，提供绘制粒子方法`draw`、更新方法`update`、替换方法`change`\\n2. **LogoImg：** 记录图片解析后的粒子数组信息`particleData`\\n3. **ParticleCanvas：** 记录目标画布、画布中的粒子数组和鼠标在画布中的位置，提供绘制画布方法`drawCanvas`、改变粒子数组方法`changeImg`\\n\\n流程：\\n\\n- 实例化一个`ParticleCanvas`对象`prtCanvas`\\n- 点击某个图片`clickLogo`时调用`prtCanvas.changeImg(particleData)`方法传入其粒子数组信息。\\n- - 首次 changeImg，直接赋值\\n- - 非首次，对比粒子数组 移除/生成粒子，并随机映射\\n\\n这里就已经实现粒子动画了，粒子的生成和移动就不细说了看代码！\\n\\n然后就是吸引/排斥：\\n\\n- 鼠标在实例对象`prtCanvas`对应的画布移动时触发`mousemove`回调，根据回调参数重新计算鼠标位置`mouseX/mouseY`\\n- - `prtCanvas`的绘制画布方法`drawCanvas`一直随着事件循环在执行，`drawCanvas`中遍历画布粒子数组并调用每一项的`update`方法并传入重新计算后的`mouseX/mouseY`\\n- - `particle.update`中又根据距离和设置好的引力/斥力重新计算`vx/vy`...\\n\\n```javascript\\nthis.ParticleArr.forEach((particle) => {\\n  particle.update(this.mouseX, this.mouseY);\\n  particle.draw();\\n});\\n```\\n\\nParticle 的 draw 方法符合面向对象的写法是接收一个 content 上下文参数，图方便就直接读取了 😁\\n\\n## 分析\\n实现该动画主要的步骤为：\\n1. 解析图片转换为粒子 \\n2. 绘制时添加动画 \\n3. 根据鼠标位置对粒子进行排斥\\n\\n解析图片通过Canvas的**getImageData**获取像素数据实现。\\n\\n**较难点**在于 绘制动画 和 粒子排斥，涉及到 数学应用 和 动画/交互逻辑。\\n\\n> 先简单复习下**像素操作**相关的知识，也可以查看我之前写的[文章](https://juejin.cn/post/7152355177666707493#heading-25)\\n> \\n## 像素操作\\ncanvas提供了 绘制图片 和 获取图片像素 的方法，但在绘制图片或者获取图片信息用于操作之前，首先要**获取目标图片源**。\\n\\n我们通过在JS里创建`Image`对象 在`onload`回调时读取数据源。\\n\\n一旦获得了源图对象，我们就可以使用 `drawImage` 方法将它渲染到 canvas 里。\\n\\n通过canvas的`getImageData`方法可以获得`ImageData`对象，而`ImageData.data`属性中存储着canvas对象真实的**像素数据。**\\n```javascript\\n    ......\\n    let img = new Image();\\n    img.src = src;\\n    // canvas 获取粒子位置数据\\n    img.onload = () => {\\n      // 获取图片像素数据\\n      const tmp_canvas = document.createElement(\\\"canvas\\\"); // 创建一个空的canvas\\n      const tmp_ctx = tmp_canvas.getContext(\\\"2d\\\");\\n\\n      tmp_ctx?.drawImage(img, 0, 0, imgW, imgH); // 将图片绘制到canvas中\\n      const imgData = tmp_ctx?.getImageData(0, 0, imgW, imgH).data; // 获取像素点数据\\n      tmp_ctx?.clearRect(0, 0, width, height);\\n    };\\n    ......\\n```\\n`ImageData`的`data`属性为 [Uint8ClampedArray](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FUint8ClampedArray \\\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray\\\") 类型的一维数组，包含了指定区域里**每个像素点的RGBA格式的整型数据**，范围在0至255之间（包括255）。\\n\\n每一个像素点有4个值占据data数组4个索引位置，对应像素rgba(R, G, B, A)的四个值。如图：\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d37673fee1e4fba80f64848534365e3~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## canvas动画\\n**canvas的动画主要是通过 在一些定时方法中去执行重绘操作实现的。**\\n\\ncanvas实现动画的过程通常是 **清理->绘制->清理->绘制...**  不断重复的过程。\\n\\n一般通过 setTimeOut、setInterval、requestAnimationFrame 等定时执行的方法去调用重绘，实现动画的操控。\\n## 实现\\n### 生成粒子/绘制画布\\n> 像素会经过一系列操作转换为粒子，粒子绘制到画布后初始位置随机，并逐渐向目标方向移动。  \\n> 画布不断调用粒子中的更新方法和绘制方法，重新绘制画布。\\n#### 粒子类\\n创建粒子类`Particle`，其构造器接收 **像素对象** 为参数**转换**为 **粒子实例对象**。\\n```javascript\\nclass Particle {\\n  totalX: number; // 粒子x轴的目标位置\\n  totalY: number; // 粒子y轴的目标位置\\n  r: number; // 粒子的半径\\n  color: number[]; // 粒子的颜色\\n  opacity: number; // 粒子的透明度\\n  constructor(totalX: number, totalY: number, time: number, color: number[]) {\\n    // 目标位置dx、dy，总耗时time\\n    this.totalX = totalX;\\n    this.totalY = totalY;\\n    // 设置粒子的颜色和半径\\n    this.r = 1.2;\\n    this.color = [...color];\\n    this.opacity = 0;\\n  }\\n  // 在画布中绘制粒子\\n  draw() {}\\n  // 更新粒子\\n  update() {}\\n  // 切换粒子\\n  change() {}\\n}\\n```\\n\\n#### 筛选像素\\n\\n因为并不是每一个像素点都需要绘制，所以在获得了上文`ImageData.data`的像素数据后，先对数据进行一遍筛选，同时将符合条件的像素点生成为粒子。\\n```javascript\\n......\\n    img.onload = () => {\\n      // 获取图片像素数据\\n      ......\\n      const imgData = tmp_ctx?.getImageData(0, 0, imgW, imgH).data; // 获取像素点数据\\n      tmp_ctx?.clearRect(0, 0, width, height);\\n\\n      // 筛选像素点\\n      for (let y = 0; y < imgH; y += 5) {\\n        for (let x = 0; x < imgW; x += 5) {\\n          // 像素点的索引\\n          const index = (x + y * imgW) * 4;\\n          // 在数组中对应的值\\n          const r = imgData![index];\\n          const g = imgData![index + 1];\\n          const b = imgData![index + 2];\\n          const a = imgData![index + 3];\\n          const sum = r + g + b + a;\\n          // 筛选条件\\n          if (sum >= 100) {\\n            const particle = new Particle(x, y, animateTime, [r, g, b, a]);\\n            this.particleData.push(particle);\\n          }\\n        }\\n      }\\n    };\\n......\\n```\\n#### 创建粒子\\n首先我们观察到动画中的粒子是从**随机位置**（或者有一套算法确定位置，但肯定不在原位置）出现的，并逐渐位移向目标位置，同时会逐渐清晰（不透明度++）。\\n\\n所以我们需要调整粒子类：\\n1. `x、y`属性表示粒子当前位置 \\n2. `mx、my`属性表示粒子需要移动的距离 \\n3. `vx、vy`属性表示粒子在方向上的移动速度\\n4. `time`属性表示粒子过渡动画所耗时间\\n5. `update`方法在粒子更新时调用，在其中动态计算`mx、my、vx、vy`\\n6. `draw`方法在画布中绘制粒子\\n```javascript\\nclass Particle {\\n  x: number; // 粒子x轴的初始位置\\n  y: number; // 粒子y轴的初始位置\\n  totalX: number; // 粒子x轴的目标位置\\n  totalY: number; // 粒子y轴的目标位置\\n  mx?: number; // 粒子x轴需要移动的距离\\n  my?: number; // 粒子y轴需要移动的距离\\n  vx?: number; // 粒子x轴移动速度\\n  vy?: number; // 粒子y轴移动速度\\n  time: number; // 粒子移动耗时\\n  r: number; // 粒子的半径\\n  color: number[]; // 粒子的颜色\\n  opacity: number; // 粒子的透明度\\n  constructor(totalX: number, totalY: number, time: number, color: number[]) {\\n    // 设置粒子的初始位置x、y，目标位置dx、dy，总耗时time\\n    this.x = (Math.random() * width) >> 0;\\n    this.y = (Math.random() * height) >> 0;\\n    this.totalX = totalX;\\n    this.totalY = totalY;\\n    this.time = time;\\n    // 设置粒子的颜色和半径\\n    this.r = 1.2;\\n    this.color = [...color];\\n    this.opacity = 0;\\n  }\\n  /** 更新粒子\\n   * @param {number} mouseX 鼠标X位置\\n   * @param {number} mouseY 鼠标Y位置\\n   */\\n  update(mouseX?: number, mouseY?: number) {\\n    // 设置粒子需要移动的距离\\n    this.mx = this.totalX - this.x;\\n    this.my = this.totalY - this.y;\\n    // 设置粒子移动速度\\n    this.vx = this.mx / this.time;\\n    this.vy = this.my / this.time;\\n    this.x += this.vx;\\n    this.y += this.vy;\\n    // 随着移动不断增加透明度\\n    if (this.opacity < 1) this.opacity += opacityStep;\\n  }\\n  // 在画布中绘制粒子\\n  draw() {\\n    context.beginPath()\\n    context.value!.fillStyle = `rgba(${this.color.toString()})`;\\n    context.value!.arc(this.x, this.y, this.r * 2, 0, 2 * Math.PI);\\n    context.value!.fill();\\n    context.closePath()\\n  }\\n}\\n```\\n#### 绘制画布\\n在明确怎么创建粒子后，需要将粒子绘制到画布上，画布不断更新其中的粒子实现动画效果。\\n\\n于是我们创建图片类`LogoImg`、画布类`ParticleCanvas`便于 存放数据 和 操作画布。\\n```javascript\\n/** Logo图片类 */\\nclass LogoImg {\\n  src: string;\\n  name: string;\\n  particleData: Particle[]; // 用于保存筛选后的粒子\\n  constructor(src: string, name: string) {\\n    this.src = src;\\n    this.name = name;\\n    this.particleData = [];\\n    let img = new Image();\\n    img.crossOrigin = '';\\n    img.src = src;\\n    // canvas 获取粒子位置数据\\n    img.onload = () => {\\n      // 获取图片像素数据\\n      const tmp_canvas = document.createElement(\\\"canvas\\\"); // 创建一个空的canvas\\n      const tmp_ctx = tmp_canvas.getContext(\\\"2d\\\");\\n      const imgW = width;\\n      const imgH = ~~(width * (img.height / img.width));\\n      tmp_canvas.width = imgW;\\n      tmp_canvas.height = imgH;\\n      tmp_ctx?.drawImage(img, 0, 0, imgW, imgH); // 将图片绘制到canvas中\\n      const imgData = tmp_ctx?.getImageData(0, 0, imgW, imgH).data; // 获取像素点数据\\n      tmp_ctx?.clearRect(0, 0, width, height);\\n\\n      // 同上筛选像素点\\n    };\\n  }\\n}\\n\\n// 画布类\\nclass ParticleCanvas {\\n  canvasEle: HTMLCanvasElement;\\n  ctx: CanvasRenderingContext2D;\\n  width: number;\\n  height: number;\\n  ParticleArr: Particle[];\\n  constructor(target: HTMLCanvasElement) {\\n    this.canvasEle = target;\\n    this.ctx = target.getContext(\\\"2d\\\") as CanvasRenderingContext2D;\\n    this.width = target.width;\\n    this.height = target.height;\\n    this.ParticleArr = [];\\n  }\\n  // 改变画布数据源\\n  changeImg(img: LogoImg) {\\n      this.ParticleArr = img.particleData.map(\\n        (item) =>\\n          new Particle(item.totalX, item.totalY, animateTime, item.color)\\n      );\\n  }\\n  // 画布绘制方法\\n  drawCanvas() {\\n    this.ctx.clearRect(0, 0, this.width, this.height);\\n    this.ParticleArr.forEach((particle) => {\\n      particle.update();\\n      particle.draw();\\n    });\\n    window.requestAnimationFrame(() => this.drawCanvas());\\n  }\\n}\\n```\\n\\n### 切换动画\\n> 在切换图片（即粒子数据源）时，复用页面上已存在的粒子，将其随机映射到新的位置。  \\n> 由粒子数量对比分为 相同、大于、小于 3种情况，根据情况画布中的粒子数组进行移除或添加。\\n\\n可以发现在切换图片的时候并不是清空画布并重新生成所有粒子，**已存在的粒子会按比例复用并移动到新的目标位置**，即旧粒子随机对应新粒子（官方应该有一套算法确定映射，但肯定不会顺序对应）。\\n\\n所以我们在画布类`ParticleCanvas.changeImg`切换数据源时对比新旧粒子数量，遍历新粒子数组，每次循环判断复用`arr[idx].change(...);`,还是生成新粒子。\\n\\n之后对比`newLen < oldLen`，变少了就通过`splice`删除，变多了则在上述遍历中已通过`new Particle(...)`添加。\\n\\n最后随机打乱粒子最终对应的位置，每次循环随机的取一个粒子`arr[randomIdx]` 和 倒序的取一个粒子`arr[tmp_len]`，并且上限逐渐递减`tmp_len--`（避免多个粒子映射到同一个粒子上）。\\n```javascript\\n  // 改变图片 如果已存在图片则进行额外切换操作\\n  changeImg(img: LogoImg) {\\n    if (this.ParticleArr.length) {\\n      // 如果当前粒子数组大于新的粒子数组 删除多余的粒子\\n      let newPrtArr = img.particleData;\\n      let newLen = newPrtArr.length;\\n      let arr = this.ParticleArr;\\n      let oldLen = arr.length;\\n\\n      // 调用change修改已存在粒子\\n      for (let idx = 0; idx < newLen; idx++) {\\n        const { totalX, totalY, color } = newPrtArr[idx];\\n        if (arr[idx]) {\\n          // 找到已存在的粒子 调用change 接收新粒子的属性\\n          arr[idx].change(totalX, totalY, color);\\n        } else {\\n          arr[idx] = new Particle(totalX, totalY, animateTime, color);\\n        }\\n      }\\n\\n      if (newLen < oldLen) this.ParticleArr = arr.splice(0, newLen);\\n      let tmp_len = arr.length;\\n      // 随机打乱粒子最终对应的位置 使切换效果更自然\\n      while (tmp_len) {\\n        // 随机的一个粒子 与 倒序的一个粒子\\n        let randomIdx = ~~(Math.random() * tmp_len--);\\n        let randomPrt = arr[randomIdx];\\n        let { totalX: tx, totalY: ty, color } = randomPrt;\\n\\n        // 交换位置\\n        randomPrt.totalX = arr[tmp_len].totalX;\\n        randomPrt.totalY = arr[tmp_len].totalY;\\n        randomPrt.color = arr[tmp_len].color;\\n        arr[tmp_len].totalX = tx;\\n        arr[tmp_len].totalY = ty;\\n        arr[tmp_len].color = color;\\n      }\\n    } else {\\n      this.ParticleArr = img.particleData.map(\\n        (item) =>\\n          new Particle(item.totalX, item.totalY, animateTime, item.color)\\n      );\\n    }\\n  }\\n```\\n\\n### 粒子排斥\\n> 每个粒子会根据与鼠标距离的比例受到x、y方向的力，在转换为对应方向上的速度后重新计算粒子的移动轨迹（这涉及到一些三角函数），即可实现粒子排斥效果。\\n\\n#### 整理思路\\n\\n明显观察到画布会**以鼠标为中心对粒子进行一定范围的排斥**，越接近中心排斥的速度越快。\\n\\n我们可以向particle对象的`update`方法中传入鼠标在canvas画布中的位置`mouseX, mouseY`。\\n\\n并结合`粒子当前位置(x, y)` 和 `排斥力度Inten` 重新计算移动速度`vx、vy`。由此**使粒子不断远离中心**。\\n\\n#### 设计方案\\n\\n调整粒子类`Particle`的`update`方法，重新计算`vx、vy`：  \\n1. 设置固定值 `Radius(斥力影响范围)`、`Inten(斥力标准值)`。\\n2. 设置鼠标位置 `(mouseX, mouseY)` 为斥力中心。\\n3. 计算每个粒子与中心的 `直线距离distance`。\\n4. 通过 `Radius / distance` 获得 中心影响范围 与 直线距离 的`比例disPercent`。<br>**比例越大越接近中心，受到的斥力也越大。**\\n5. 将 粒子与中心形成的 `夹角angle`、`比例disPercent`和`斥力值Inten`，转换为粒子x、y轴的速度`repX`、`repY`。\\n6. `vx += repX` & `vy += repY`，**粒子逐渐远离中心。**\\n\\n#### 实现\\n> 注意：canvas坐标系采用**第四象限**，即x轴正向为右，y轴正向为下\\n\\n![ucs.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9cb7a0eadaa6498581f80d42534180e5~tplv-k3u1fbpfcp-watermark.image?)\\n\\n如图，假设`某点Z`为斥力中心，同时取三个粒子，位置分别为：`A.边界外` `B.边界内` `C.边界上`。\\n\\n用`dx、dy`代表粒子与中心的`x、y`轴距离，并用正负表示方向。 \\n\\n例如A粒子 `dx = 2 - 4 = -2`、`dy = 2 - 4 = -2`，通过三角函数[Math.atan2](https://zhuanlan.zhihu.com/p/306534228)计算出 夹角`angle = Math.atan2(-2, -2)`。\\n\\n再通过`angle`和 正弦/余弦函数 计算出 `sin = Math.sin(angle)`、`cos = Math.cos(angle)`。\\n\\n将`disPercent * Inten`计算出的力度转换为x、y方向上的速度 `repX = cos * disPercent * -Inten` ... 因为是排斥，所以我们使用`-Inten` **去掉负号则是吸引效果了**。\\n\\n重新计算`vx += repX`、 `vy += repY`。\\n\\n\\n```javascript\\n// Particle.class -> update\\n  update(mouseX?: number, mouseY?: number) {\\n      ....\\n      if (mouseX && mouseY) {\\n          let dx = mouseX - this.x;\\n          let dy = mouseY - this.y;\\n          let distance = Math.sqrt(dx ** 2 + dy ** 2);\\n          // 粒子相对鼠标距离的比例 判断受到的力度比例\\n          let disPercent = Radius / distance;\\n          // 设置阈值 避免粒子受到的斥力过大\\n          disPercent = disPercent > 7 ? 7 : disPercent;\\n          // 获得夹角值 正弦值 余弦值\\n          let angle = Math.atan2(dy, dx);\\n          let cos = Math.cos(angle);\\n          let sin = Math.sin(angle);\\n          // 将力度转换为速度 并重新计算vx vy\\n          let repX = cos * disPercent * -Inten;\\n          let repY = sin * disPercent * -Inten;\\n          this.vx += repX;\\n          this.vy += repY;\\n      }\\n      ....\\n    }\\n```\\n同理可计算B、C粒子的速度。\\n\\n## 优化\\n### 减少绘制操作\\ncanvas绘制圆（arc）相比绘制矩形（rect）会消耗更多的性能，arc 每次绘制都要开启、闭合路径，而 rect 则直接绘制。\\n\\n当粒子数量过多时会有明显的**性能差异**，且在较小比例的情况下圆和矩形视觉上是类似的，所以可以用fillRect(...) 替换 arc(...)。\\n\\n### 面向对象\\n将画布、粒子、配置、图片**抽象为类**，通过对象的属性和方法去渲染、切换。这里很多参数都固定了就没再去抽象配置类，感兴趣的同学可以试试。\\n\\n### 事件循环\\n因为浏览器执行机制是 **宏任务->微任务->渲染->宏任务...** 这样一个循环，因此页面上的粒子排斥效果也不是实时的，有可能鼠标到了某个位置但是刚结束上一次循环的计算和渲染。\\n\\n所以在页面上监听`mousemove`事件 回调使用`requestAnimationFrame`，回调中根据鼠标位置在页面上添加一个白圈，表明当前循环渲染的位置，优化视觉效果，详情查看index.html中的代码。\\n\\n### 粒子渐入\\n因为方便计算和还原粒子本身颜色 所以**没有实现不透明度逐渐增加**的操作（一开始是写了的 但考虑到还原粒子），导致动画少了渐入的视觉，追求完美复原的同学可以研究下。\\n\\n感觉主要问题在粒子筛选的条件上，使用`#fff`背景可以观察到画布中有黑色的粒子。\\n\\n## 题外话\\n真的很喜欢明日方舟的美术风格、游戏剧情，从各方面来说都是一款佳作😆话说这算安利了吧\\n\\n开服咸鱼玩家，以前的号忘了另起炉灶，欢迎大家加我好友一起 ~~白嫖三模令姐~~ **FIGHT FOR THE DAWN** ，ID：鸩羽昙#9367。\\n\\n![QQ截图20221030042852.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3aa3f58516e244889cf360c212b8f0e0~tplv-k3u1fbpfcp-watermark.image?)\\n\\n祝大家新卡池一发入魂~\\n## 结语🎉 \\ncanvasAPI数量精简，参数清晰，学习并不复杂，更多的是如何实践应用。如果感兴趣的话建议自己实现一些功能，相信你也能发现canvas的亮点。\\n\\n不要光看不实践哦，后续会持续更新前端相关的知识，欢迎大家关注第一时间收到更新消息哦😊\\n\\n写作不易，如果觉得有收获还望大家点赞、收藏🌹\\n> 才疏学浅，如有问题或建议欢迎大家指教。\\n",
        "tags": [
            "Canvas",
            "JavaScript",
            "前端"
        ]
    },
    {
        "article_id": "7183237715217874999",
        "cover_image": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e707369634444d778fffa3ddf668687c~tplv-k3u1fbpfcp-watermark.image?",
        "title": "💯💯💯 Map、Set、WeakMap、WeakSet看这一篇就够",
        "brief": "作为前端开发人员,我们最常用的一些数据结构就是Object、Array 之类的,毕竟它们使用起来非常的方便。往往有些刚入门的同学都会忽视Set和Map这两种数据结构的存在。",
        "user_name": "Moment",
        "view_count": 2645,
        "collect_count": 100,
        "comment_count": 15,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/4ae08cddb21bbb8e795235baef9a095e~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: nico\\nhighlight: atom-one-dark\\n---\\n\\n# 前言\\n作为前端开发人员,我们最常用的一些数据结构就是 `Object`、`Array` 之类的,毕竟它们使用起来非常的方便。往往有些刚入门的同学都会忽视 `Set` 和 `Map` 这两种数据结构的存在,因为能用 `set` 和 `map` 实现的,基本上也可以使用对象或数组实现,而且还更简单。\\n\\n但是 `Map` 和 `Obejct`的区别你又知道吗,通过这篇文章你将学习到:\\n- `Obejct` 和 `Map` 的区别;\\n- `Object` 中 `key` 的顺序;\\n- `Map` 和 `Set` 的基本使用;\\n- `WeakMap` 和 `WeakSet` 使用场景;\\n\\n# Map\\n在 `ECMAScript 6` 以前,在 `JavaScript` 中实现 `\\\"键/值\\\"`式存储可以使用 `Object`来方便高效地完成,也就是使用对象属性作为键,再使用属性来引用值。因此 `ECMAScript 6` 新增了 `Map` 集合类型。\\n\\n`Map` 对象保存键值对,并且能够记住键的原始插入顺序,任何值(对象或者基本类型)都可以作为一个键或一个值。`Map` 的大多数特性都可以通过 `Object` 类型实现,但二者之间还是存在一些细微的差异。具体实践中使用哪一个,还是值得细细甄别。\\n\\n## 基本使用\\n使用 `new` 关键字和 `Map` 构造函数可以创建一个空映射:\\n```js\\nconst map = new Map();\\n```\\n\\n通过查看原型,有以下属性和方法:\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b3ea3d2e1e24f81afa7531882c7ee09~tplv-k3u1fbpfcp-watermark.image?)\\n\\n如果想在创建的同时初始化实例,可以给 `Map` 构造函数传入一个可迭代对象,需要包含 `\\\"键/值\\\"` 对数组。可迭代对象中途的每个 `\\\"键值\\\"` 对都会按照迭代顺序插入到新映射实例中:\\n```js\\nconst map = new Map([\\n  [\\\"key1\\\", \\\"val1\\\"],\\n  [\\\"key2\\\", \\\"val2\\\"],\\n  [\\\"key3\\\", \\\"val3\\\"],\\n]);\\n\\nconsole.log(map.size); // 3\\n```\\n\\n通过 `size` 属性可以获取 `Map` 对象的键值对的个数,这在 `Object` 的键值对需要手动计算。\\n\\n## has 和 get\\n和 `Object` 类似,`Map` 对象也可以获取对象是否有这个键以及获取这个键的值,在 `Map` 中提供了 `has(...)` 方法和 `get(...)` 实例方法。其中 `has(...)` 方法的返回值是一个布尔值,用来表明 `Map` 对象中是否存在指定的键 `key` 关联的值,而 `get(...)` 返回与指定的键 `key` 关联的值,若不存在关联的值,则返回 `undefined`,代码如下所示:\\n```js\\nconst map = new Map([\\n  [1, \\\"val1\\\"],\\n  [2, \\\"val2\\\"],\\n  [3, \\\"val3\\\"],\\n]);\\n\\nconsole.log(map.has(\\\"moment\\\")); // false\\nconsole.log(map.has(\\\"1\\\")); // false\\nconsole.log(map.has(1)); // true\\n\\nconsole.log(map.get(1)); // val1\\nconsole.log(map.get(7)); // undefined\\n```\\n\\n## set\\n\\n在初始化之后,可以使用 `set(...)` 方法添加 `键/值` 对,该方法两个参数,一个是 `key` 作为要添加到 `Map` 对象的元素的键,该值可以是任何数据类型,一个是 `value` 作为要添加到 `Map` 对象的元素的值,该值可以是任何数据类型,代码示例如下:\\n```js\\nconst map = new Map([[\\\"1\\\", \\\"moment\\\"]]);\\n\\nmap.set(\\\"1\\\", \\\"你小子\\\");\\nmap.set(-0, \\\"111\\\");\\n\\nconsole.log(map); // Map(2) { '1' => '你小子', 0 => '111' }\\n```\\n\\n值得注意的是,`Map` 中的键是唯一的,当初始化时或者 `set(...)` 方法添加的键,它会首先通过 `forEach(...)` 方法进行遍历,通过当前的键 `key` 去查找值 `value`,如果存在,就重新赋值,如果不存在就添加一个键值对,如果传进来的键是 `-0` 则会把键设置为 `+0` 再赋值。\\n\\n## delete\\n`delete(...)` 方法用于移除 `Map` 对象中指定的元素。依然是通过遍历整个记录,查找 `delete(...)` 方法传进来的参数,如果不为空,则将当前的键和值设为空,并且返回 `true`,如果不存在这个 `key`,则返回 `false`,示例代码如下:\\n```js\\nconst map = new Map([\\n  [\\\"1\\\", \\\"moment\\\"],\\n  [\\\"2\\\", \\\"你小子\\\"],\\n]);\\n\\nconsole.log(map); // Map(2) { '1' => 'moment', '2' => '你小子' }\\nconsole.log(map.delete(\\\"1\\\")); // true\\nconsole.log(map.delete(777)); // false\\nconsole.log(map); // Map(1) { '2' => '你小子' }\\n```\\n\\n## clear\\n`clear(...)` 方法会移除 `Map` 对象中的所有元素,该方法首先通过遍历整个 `Map` 实例,并且将所有的键和值设为空,最后返回的值是 `undefined`,示例代码如下:\\n```js\\nconst map = new Map([\\n  [\\\"1\\\", \\\"moment\\\"],\\n  [\\\"2\\\", \\\"你小子\\\"],\\n]);\\n\\nconsole.log(map.clear()); // undefined\\n```\\n\\n## 顺序与迭代\\n与 `Object` 类型相比的一个主要差异是,`Map` 实例会维护键值对的插入顺序,因此可以根据插入顺序执行迭代操作。 映射实例可以提供一个迭代器(`Iterator`)能以插入顺序生成 `[key, value]` 形式的数组。可以 通过 `entries(...)` 方法或者 `Symbol.iterator` 属性,它引用 `entries()` 取得这个迭代器:\\n```js\\nconst m = new Map([\\n  [\\\"key1\\\", \\\"val1\\\"],\\n  [\\\"key2\\\", \\\"val2\\\"],\\n  [\\\"key3\\\", \\\"val3\\\"],\\n]);\\nconsole.log(m.entries === m[Symbol.iterator]); // true\\nfor (const [key, value] of m.entries()) console.log(key, value);\\nfor (const [key, value] of m[Symbol.iterator]()) console.log(key, value);\\n// key1 val1\\n// key2 val2\\n// key3 val3\\n```\\n\\n因为 `entries()` 是默认迭代器,所以可以直接对映射实例使用扩展操作,把映射转换为数组:\\n```js\\nconst m = new Map([\\n  [\\\"key1\\\", \\\"val1\\\"],\\n  [\\\"key2\\\", \\\"val2\\\"],\\n  [\\\"key3\\\", \\\"val3\\\"],\\n]);\\n\\nconsole.log(Array.from(m));\\nconsole.log([...m]);\\n// [\\n//   [\\\"key1\\\", \\\"val1\\\"],\\n//   [\\\"key2\\\", \\\"val2\\\"],\\n//   [\\\"key3\\\", \\\"val3\\\"],\\n// ];\\n```\\n\\n## forEach\\n如果不使用迭代器,而是使用回调方式,则可以调用 `forEach(...)` 方法并传入回调,依次迭代每个 `键/值` 对。传入的回调接收可选的第二个参数,这个参数用于重写回调内部 `this` 的值:\\n```js\\nconst m = new Map([\\n  [\\\"key1\\\", \\\"val1\\\"],\\n  [\\\"key2\\\", \\\"val2\\\"],\\n  [\\\"key3\\\", \\\"val3\\\"],\\n]);\\n\\nm.forEach((value, key, map) => {\\n  console.log(key, value, map);\\n});\\n// key1 val1 Map(3) { 'key1' => 'val1', 'key2' => 'val2', 'key3' => 'val3' }\\n// key2 val2 Map(3) { 'key1' => 'val1', 'key2' => 'val2', 'key3' => 'val3' }\\n// key3 val3 Map(3) { 'key1' => 'val1', 'key2' => 'val2', 'key3' => 'val3' }\\n```\\n\\n在上面代码中,`key` 代表每个迭代的键,`value` 代表每个迭代的值,而 `map` 代表当前正在迭代的 `Map` 实例。\\n\\n## keys\\n`keys(...)` 返回一个引用的迭代器对象。它包含按照顺序插入 `Map` 实例对象中每个元素的 `key` 值。具体代码实例如下:\\n```js\\nconst m = new Map([\\n  [\\\"key1\\\", \\\"val1\\\"],\\n  [\\\"key2\\\", \\\"val2\\\"],\\n  [\\\"key3\\\", \\\"val3\\\"],\\n]);\\n\\nconsole.log(m.keys()); // [Map Iterator] { 'key1', 'key2', 'key3' }\\n```\\n\\n## values\\n`values(...)` 方法返回一个新的迭代器对象。它包含按顺序插入 Map 实例对象中每个元素的 `value` 值,具体代码如下:\\n```js\\nconst m = new Map([\\n  [\\\"key1\\\", \\\"val1\\\"],\\n  [\\\"key2\\\", \\\"val2\\\"],\\n  [\\\"key3\\\", \\\"val3\\\"],\\n]);\\n\\nconsole.log(m.values()); // [Map Iterator] { 'val1', 'val2', 'val3' }\\n```\\n\\n# Map 和 Object 的区别\\n了解 `Map` 和 `Object` 的区别对我们开发者很重要,这不仅是面试中经常被问到的话题,而且对于在乎内存和性能的开发者来说,`Object` 和 `Map` 之间确实存在着显著的差别。\\n\\n## 继承\\n`Map` 对象继承自 `Obejext` 对象,你可以通过原型继承去调用 `Object` 身上的原型方法,例如:\\n```js\\nconst m = new Map([[\\\"key3\\\", \\\"val3\\\"]]);\\nconsole.log(m.toString()); // [object Map]\\n```\\n\\n在上面的代码,`map` 是 `Map` 对象的实例对象,而 `Map` 对象继承自 `Obeject`,而创建的普通对象是 `Obejct` 的实例对象,我们只需查找一次便可以查找到顶层对象 `Object`,具体代码如下所示:\\n```js\\nconst m = new Map([[\\\"key3\\\", \\\"val3\\\"]]);\\nconst obj = {};\\nconsole.log(m.__proto__.__proto__.constructor === obj.__proto__.constructor);\\n// true\\n```\\n\\n## 创建实例\\n创建 `Map` 实例只有一种方式,就是使用其内置的构造函数以及 `new` 语法,而创建对象则有多种方法,具体代码示例如下:\\n```js\\nconst m = new Map([[\\\"key\\\", \\\"value\\\"]]);\\n\\nconst object = {...};\\nconst object = new Object();\\nconst object = Object.create(null);\\n```\\n\\n而通过使用 `Object.create(null)` 来创建的对象,它可以生成一个不继承 `Object.prototyoe` 的实例对象。 \\n\\n## 迭代\\n通过 `Map` 创建出来的实例对象能通过 `for...of` 方法进行遍历,而普通对象则不能,但是能通过 `for...in` 方法去枚举所有的 `key`,要想查看当前对象是否可以被 `for...of` 遍历,我们通过查看该对象本身是否有定义了 `Symbol.Iterator` 方法,,如果存在则可以变遍历:\\n```js\\nconst map = new Map();\\nconst object = {};\\n\\nconsole.log(map[Symbol.iterator]); // [Function: entries]\\nconsole.log(object[Symbol.iterator]); // undefined\\n```\\n通过上面的代码可以看出,普通的对象并没有定义 `Symbol.Iterator` 方法,输出为 `undefined`。详情可以看这篇文章 [跳转链接](https://juejin.cn/post/7178768412582084664)。\\n\\n普通对象可以眼使用`Object.keys(obj)`只能获取所有 `key` 并进行遍历:\\n```js\\nconst object = {\\n  a: 1,\\n  1: 2,\\n  foo: \\\"moment\\\",\\n};\\n\\nconsole.log(Object.keys(object)); // [ '1', 'a', 'foo' ]\\n```\\n该方法返回一个由 `key` 组成的数组,可以通过该数组进行遍历。\\n\\n## key的有序和无序\\n在 `Map` 中,`key` 的顺序是按插入时间进行排序的:\\n```js\\nconst m = new Map([\\n  [\\\"key1\\\", \\\"val1\\\"],\\n  [\\\"key2\\\", \\\"val2\\\"],\\n  [\\\"key3\\\", \\\"val3\\\"],\\n  [1, \\\"val4\\\"],\\n]);\\n\\nconsole.log(...m.keys()); // key1 key2 key3 1\\n```\\n\\n但是在普通对象中就不同了,在最开始学习 `JavaScript` 的时候,我们一直被灌输 `Object` 中的 `key` 是无序的,不可靠的,而与之相对的是 `Map` 实例会维护 `键/值对` 的插入顺序。\\n\\n在一些现代的浏览器当中,`key` 的输出顺序是可以预测的:\\n- 如果当前的 `key` 是整数或者 `0`,就按照自然数的大小进行排序;\\n\\n- 如果当前的 `key` 是字符类型的,则按照加入的时间顺序进行排序;\\n\\n- 如果当前的 `key` 是 `Symbol` 类型的,则按照加入的时间顺序进行排序;\\n\\n- 如果是以上类型的相互结合,结果是先按照自然数升序进行排序,然后按照非数字的 `string` 的加入时间排序,然后按照 `Symbol` 的时间顺序进行排序,也就是说他们会先按照上述的分类进行拆分,先按照自然数、非自然数、`Symbol` 的顺序进行排序,然后根据上述三种类型下内部的顺序进行排序。\\n\\n具体代码演示如下所示:\\n```js\\nconst object1 = {\\n  1: 111,\\n  3: 3333,\\n  2: 222,\\n};\\n\\nconst object2 = {\\n  a: 111,\\n  c: 3333,\\n  b: 222,\\n};\\n\\nconst object3 = {\\n  [Symbol(\\\"1\\\")]: \\\"first\\\",\\n  [Symbol(\\\"3\\\")]: \\\"second\\\",\\n  [Symbol(\\\"2\\\")]: \\\"last\\\",\\n};\\n\\nconst result = {\\n  [Symbol(\\\"你小子\\\")]: \\\"moment\\\",\\n  1: 1111,\\n  aaa: \\\"牛逼\\\",\\n};\\n\\nconsole.log(Reflect.ownKeys(object1)); // [ '1', '2', '3' ]\\nconsole.log(Reflect.ownKeys(object2)); // [ 'a', 'c', 'b' ]\\nconsole.log(Reflect.ownKeys(object3)); // [ Symbol(1), Symbol(3), Symbol(2) ]\\nconsole.log(Reflect.ownKeys(result)); // [ '1', 'aaa', Symbol(你小子) ]\\n```\\n\\n## 键的值\\n在 `Map` 对象中,该对象的 `key` 可以是任何类型的值,而在普通对象中的 `key` 只能是 `string` 类型(`number`类型会自动转变成 `string` 类型)和 `Symbol` 类型,如果传进来的是复杂类型会自动报错:\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94fa2c8dc58b4317a2e0268b56696987~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## 选择 Object 还是 Map\\n至于如何选择,我们可以从四个方面进行考虑,分别是 `内存占用`、`插入性能`、`查找速度`、`删除性能`,详情请看以下:\\n\\n- 内存占用: `Object` 和 `Map` 的工程级实现在不同浏览器间存在明显差异,但存储单个 `键/值对` 所占用的内存数量 都会随键的数量线性增加。批量添加或删除 `键/值对` 则取决于各浏览器对该类型内存分配的工程实现。不同浏览器的情况不同,但给定固定大小的内存,`Map` 大约可以比 `Object` 多存储 `50%`的 `键/值对`。\\n\\n- 插入性能: 向 `Object` 和 `Map` 中插入新 `键/值对` 的消耗大致相当,不过插入 `Map` 在所有浏览器中一般会稍微快一点儿。对这两个类型来说,插入速度并不会随着 `键/值对` 数量而线性增加。如果代码涉及大量插入操 作,那么显然 Map 的性能更佳。这也是我们在刷leetcode算法的时候多是使用 `Map` 的原因之一了。\\n\\n- 查找速度: 与插入不同,从大型 `Object` 和 `Map` 中查找 `键/值对` 的性能差异极小,但如果只包含少量 `键/值对`, 则 `Object` 有时候速度更快。在把 `Object` 当成数组使用的情况下（比如使用连续整数作为属性），浏 览器引擎可以进行优化,在内存中使用更高效的布局。这对 `Map` 来说是不可能的。对这两个类型而言,查找速度不会随着 `键/值对` 数量增加而线性增加。如果代码涉及大量查找操作,那么某些情况下可能选择 `Object` 更好一些。\\n\\n- 删除性能: 使用 `delete` 删除 `Object` 属性的性能一直以来饱受诟病,目前在很多浏览器中仍然如此。为此,出现了一些伪删除对象属性的操作,包括把属性值设置为 `undefined` 或 `null`。但很多时候,这都是一种讨厌的或不适宜的折中。而对大多数浏览器引擎来说,`Map` 的 `delete(...)` 操作都比插入和查找更快。如果代码涉及大量删除操作,那么毫无疑问应该选择 Map。\\n\\n > 以上四点摘抄自 JavaScript高级程序设计第四版...\\n\\n## Object和Map的应用场景\\n即使 `Map` 相对于 `Object` 有很多优点,但是依然存在某些使用 `Object` 会更好的场景,毕竟 `Object` 是 `JavaScript` 中最基础的概念。\\n\\n- 如果你知道所有的 `key`,它们都为字符串或整数或是 `Symbol` 类型,你需要一个简单的结构去存储这些数据,`Object` 是一个非常好的选择。构建一个 `Object` 并通过知道的特定 `key` 获取元素的性能要优于 `Map`;\\n- 如果需要在对象中保持自己独有的逻辑和属性,只能使用 `Object`,`Object` 能维护自己的 `this`:\\n```js\\nconst info = {\\n  nickname: \\\"xun\\\",\\n  age: \\\"18\\\",\\n  address: \\\"广州\\\",\\n  detail: function () {\\n    return `${this.nickname} 现在居住在广州,已经${this.age}岁了`;\\n  },\\n};\\n\\nconsole.log(info.detail()); // xun 现在居住在广州,已经18岁了\\n```\\n- `JSON`直接支持 `Object`,但尚未支持 `Map`。因此,在某些我们必须使用 `JSON` 的情况下,应将Object视为首选:\\n```js\\nconst m = new Map([\\n  [\\\"key1\\\", \\\"val1\\\"],\\n  [\\\"key2\\\", \\\"val2\\\"],\\n  [\\\"key3\\\", \\\"val3\\\"],\\n  [1, \\\"val4\\\"],\\n]);\\n\\nconst info = {\\n  nickname: \\\"xun\\\",\\n  age: \\\"18\\\",\\n  address: \\\"广州\\\",\\n};\\n\\nconsole.log(JSON.stringify(m)); // {}\\n\\nconsole.log(JSON.stringify(info));\\n// {\\\"nickname\\\":\\\"xun\\\",\\\"age\\\":\\\"18\\\",\\\"address\\\":\\\"广州\\\"}\\n```\\n\\n# Set\\n`ECMAScript 6` 新增的 `Set` 是一种新集合类型,为这门语言带来集合数据结构。`Set` 在很多方面都像是加强的 `Map`,这是因为它们的大多数 API 和行为都是共有的。\\n\\n## Set的基本使用\\n因为 `Set` 的 `API` 和 `Map` 的一致,这里就不详细讲了,值得注意的是 `Set` 对象没有 `get(...)` 方法,使用代码如下:\\n```js\\nconst s = new Set([\\\"val1\\\", \\\"val2\\\", \\\"val3\\\"]);\\ns.add(111);\\ns.delete(\\\"val1\\\");\\n\\nconsole.log(s.has(\\\"val1\\\")); // true\\nconsole.log(s.values()); // [Set Iterator] { 'val2', 'val3', 111 }\\nconsole.log(s.keys()); // [Set Iterator] { 'val2', 'val3', 111 }\\n\\ns.forEach((key, value) => {\\n  console.log(key, value);\\n});\\n// val2 val2\\n// val3 val3\\n// 111 111\\n```\\n\\n## Set使用场景\\n在日常开发中,我们可以通过使用 `Set` 进行数组去重:\\n```js\\nconst result = [1, 2, 3, 4, 5, 5, 6, 7, 7, 7, 8];\\n\\nconsole.log([...new Set(result)]); // [1, 2, 3, 4, 5, 6, 7, 8];\\n```\\n\\n# WeakMap\\n`es6` 新增的 `WeakMap` 对象是一种新的集合类型,它一组 `键/值对` 的集合,其中的键是弱引用的。其键必须是对象,而值可以是任意的。`WeakMap` 是 `Map` 的兄弟类型,其 `API` 也是 `Map` 的子集。`WeakMap` 中的 `weak(弱)`,描述的是 `JavaScript` 垃圾回收程序对待 `弱映射` 中键的方式。\\n\\n## 基本使用\\n`WeakMap` 是一个构造函数,所以在实例化的时候必须使用 `new` 关键字,否则会报 `TypeError` 的错误:\\n```js\\nconst m = WeakMap(); // TypeError: Constructor WeakMap requires 'new' at WeakMap\\n```\\n如果想在实例化的时候填充弱映射,则构造函数可以接收一个可迭代对象,其中需要包含 `键/值对` 数组:\\n```js\\nconst obj1 = { nickname: 77 };\\nconst obj2 = { nickname: \\\"moment\\\" };\\n\\nconst map = new WeakMap([\\n  [obj1, 77],\\n  [obj2, \\\"moment\\\"],\\n]);\\n\\nconsole.log(map.get(obj1)); // 77\\nconsole.log(map.get(obj2)); // moment\\n```\\n\\n但是如果键使用的是原始值则会报错:\\n```js\\nconst m = new WeakMap();\\nm.set(\\\"1\\\", \\\"1111\\\");\\nconst m = new WeakMap();\\nm.set(\\\"1\\\", \\\"1111\\\");\\n// TypeError: Invalid value used as weak map key at WeakMap.set\\n```\\n\\n`WeakMap` 有以下的方法可供使用,和 `Map` 对应的 `API` 的功能一致:\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0008fd8efe4840689e53190d5fde0301~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## 弱键\\n`WeakMap` 中 `weak` 表示弱映射的键是 `\\\"弱弱地拿着\\\"` 的。意思就是,这些键不属于正式的引用,不会阻止垃圾回收。但要注意的是,弱映射中值的引用可不是`\\\"弱弱地拿着\\\"` 的。只要键存在,`键/值对` 就会存在于映射中,并被当作对值的引用,因此就不会被当作垃圾回收。\\n\\n来看下面的例子:\\n```js\\nconst map = new WeakMap();\\n\\nmap.set({}, \\\"777\\\");\\n```\\n`set(...)` 方法初始化了一个新对象并将它用作一个字符串的键。因为没有指向这个对象的其他引用,所以当这行代码执行完成后,这个对象键就会被当作垃圾回收。然后,这个 `键/值对` 就从弱映射中消失了,使其成为一个空映射。在这个例子中,因为值也没有被引用,所以这对 `键/值` 被破坏以后,值本身也会成为垃圾回收的目标。也就是说,`WeakMap` 对某个对象的引用,不会影响其垃圾回收,如果引用的键被垃圾回收清除掉了,其对应的 `键/值对` 也会被清除掉。\\n\\n```js\\nconst wm = new WeakMap();\\nconst container = {\\n  key: {},\\n};\\nwm.set(container.key, \\\"val\\\");\\n\\nfunction removeReference() {\\n  container.key = null;\\n}\\n```\\n\\n在上面的例子中,`container` 对象维护着一个对弱映射键的引用,因此这个对象键不会成为垃圾回收的目 标。不过,如果调用了 `removeReference()`,就会摧毁键对象的最后一个引用,垃圾回收程序就可以把这个`键/值对` 清理掉。\\n\\n`WeakMap` 的结构是特殊且有效的,其用于映射的 `key` 只有在其没有被回收时才是有效的,正由于这样的弱引用,`WeakMap` 的 `key` 是不可枚举的(没有方法能给出所有的 `key`)。如果 `key` 是可枚举的话,其列表将会受垃圾回收机制的影响,从而得到不确定的结果,因为某个键名是否存在不可预测,跟垃圾回收机制是否运行相关,这一秒可以取得键名,下一秒垃圾回收机制突然运行了,这个键名就没了🤣🤣🤣\\n\\n## WeakMap示例\\n因为 `WeakMap` 示例不会妨碍垃圾回收,所以非常适合保存关联元数据,来看下面这个例子:\\n```js\\nconst button = document.querySelector(\\\"button\\\");\\n\\nconst result = [button, \\\"你小子\\\"];\\n\\nresult=null\\n```\\n当我们不需要的时候需要手动设置 `null` 对其进行接触引用,这样释放引用的写法很不方便,造成没必要的代码.一旦忘了写,就会造成内存泄漏。\\n\\n`WeakMap` 的诞生就很好的解决了这个问题,一旦不再需要,`WeakMap` 里面的键名对象和所对应的 `键/值对`会自动消失,不用手动删除引用,具体代码实例如下:\\n```js\\nconst map = new WeakMap();\\n\\nconst button = document.querySelector(\\\"button\\\");\\n\\nmap.set(button, \\\"又是你小子\\\");\\nconsole.log(map.get(button)); // 又是你小子\\n```\\n在这个时候 `WeakMap` 里面对 `button` 的引用就是弱引用,不会被计入垃圾回收机制,但当节点从 `DOM` 树中被删除后,垃圾回收程序就可以立即释放其内存,`WeakMap` 中的键也就不存在了。\\n\\n再举一个例子🌰🌰🌰当我们需要在不修改原有对象的情况下存储某些属性等,但是又不想管理这些数据是,可以使用 `WeakMap`:\\n```js\\nconst cache = new WeakMap();\\n\\nfunction storage(obj) {\\n  if (cache.has(obj)) return cache.get(obj);\\n  else {\\n    const length = Object.keys(obj).length;\\n    cache.set(obj, length);\\n\\n    return length;\\n  }\\n}\\n\\n```\\n\\n# WeakSet\\n`WeakSet` 对象也是和前面的 `WeakMap` 一样,不会影响垃圾回收,并且也是只能是对象的集合,不能像 `Set` 那样可以是任何类型的任意值,它也具有 `Set` 部分 `Api`:\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20961be1174e4f61b12b7695f33b6839~tplv-k3u1fbpfcp-watermark.image?)\\n\\n因为这些 `API` 和前面讲到的基本没什么区别,这里就不再进行讲解。\\n\\n我们来考虑一下这样一个场景,我们需要一个数组来保存着被禁止掉的 `DOM` 元素:\\n```js\\nconst disabledElements = new Set();\\nconst loginButton = document.querySelector(\\\"button\\\");\\n// 通过加入对应集合，给这个节点打上“禁用”标签\\ndisabledElements.add(loginButton);\\n```\\n通过上面的例子查询元素在不在 `disabledElements` 中,就可以知道它是不是被禁用了,但是假如\\n元素从 `DOM` 树中被删除了,它的引用却仍然保存在 `Set` 中,它的键依然引用着,因此垃圾回收程序也不能回收它,这就很容易造成内存泄漏。\\n\\n使用 `WeakSet` 对象就很好的解决了这个问题:\\n```js\\nconst disabledElements = new WeakSet();  \\nconst loginButton = document.querySelector('#login');  \\n// 通过加入对应集合，给这个节点打上“禁用”标签 \\ndisabledElements.add(loginButton);\\n```\\n\\n这样只要 `WeakSet` 中任何元素从 `DOM` 树中被删除,垃圾回收程序就可以忽略其存在,而立即释放其内存。\\n\\n# 参考文献\\n- 书籍 `JavaScript高级程序设计`;\\n- [MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map)\\n\\n# 结尾 \\n- 如果你对垃圾回收不是很理解,可以通过这篇文章进行学习,[跳转链接](https://juejin.cn/post/7173644980240515085);\\n- 如果想要技术交流的可以私信添加我微信进行相互学习;\\n- 最后一个文章有说错的地方欢迎批评指出,如果觉得不错也希望能点个赞;\\n- 春天会如约而至,但在那之前,一定要做好破土而出的准备;\\n",
        "tags": [
            "前端",
            "JavaScript",
            "面试"
        ]
    },
    {
        "article_id": "7187582297124634680",
        "cover_image": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c951520613e74d08ac597c2bc3d94465~tplv-k3u1fbpfcp-watermark.image?",
        "title": "你知道，前端工程部署有哪些方式嘛？",
        "brief": "本文原文地址 此文章是回答知乎问题总结而来。 我将其分为四个阶段：手动部署、命令工具部署、docker镜像部署、平台化部署。 这几个阶段，越往后越复杂，越往后越友好，毕竟平台化部署有备份还可回退，那是",
        "user_name": "大流星",
        "view_count": 8012,
        "collect_count": 222,
        "comment_count": 30,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/2fa645188333863ce130edfd9c909032~300x300.image",
        "category": "前端",
        "content": "[本文原文地址](https://github.com/AttemptWeb/Record/issues/37)\\n\\n**_[此文章是回答知乎问题总结而来](https://www.zhihu.com/people/liu-heng-88-71)_**。\\n\\n我将其分为四个阶段：**手动部署**、**命令工具部署**、**docker镜像部署**、**平台化部署**。 这几个阶段，越往后越复杂，越往后越友好，毕竟平台化部署有备份还可回退，那是相当安全的。\\n\\n  \\n\\n手动部署\\n----\\n\\n    // 打包文件，生产dist目标文件 \\n    npm run build\\n\\n将dist下的文件使用 **\\\\_FTP文件传输工具 \\\\_**，上传到服务器上去，就可以直接访问最新文件了。\\n\\n**前提**：服务器上已有web服务器，类似nginx服务、Apache服务，**服务代理已经启动**。\\n\\n### 流程：本地build构建打包 ——> FTP文件上传 ——> 通过域名访问最新文件\\n\\n  \\n\\n命令工具部署\\n------\\n\\n命令工具部署其实和 手动部署是一样，只是简化而已。\\n\\n命令工具部署就是将本地build构建 和 FTP文件上传，直接通过程序来实现。例如我们通过gitlab的CI/CD工具 或 github action上传前端文件。\\n\\ngitlab CI/CD或github action通过监听master分支push操作，进行运行你的配置命令，下面我以github action配置作为例子：\\n\\n    // .github/workflows/main.yml\\n    # name: deploy to aliyun\\n    # on:\\n    #   push:\\n    #     branches:\\n    #       - master\\n    # jobs:\\n    #   build:\\n    #     runs-on: ubuntu-latest\\n    #     steps:\\n    #       # 切换分支\\n    #       - name: Checkout\\n    #         uses: actions/checkout@master\\n    #       - name: work around permission issue\\n    #         run: git config --global --add safe.directory /github/workspace\\n    #       # 使用 node:10\\n    #       - name: use Node.js 10\\n    #         uses: actions/setup-node@v1\\n    #         with:\\n    #           node-version: 10\\n    #       # npm install 同时 build 打包\\n    #       - name: npm install and build\\n    #         run: |\\n    #           npm install\\n    #           npm run build\\n    #         env:\\n    #           CI: true\\n    #       # Deploy 上传到阿里云, secrets.ACCESS_TOKEN为配置token\\n    #       - name: Deploy aliyun\\n    #         uses: easingthemes/ssh-deploy@v2.0.7\\n    #         env:\\n    #           SSH_PRIVATE_KEY: ${{ secrets.ACCESS_TOKEN }}\\n    #           ARGS: \\\"-avz --delete\\\"\\n    #           SOURCE: \\\"./docs/.vuepress/dist/\\\"\\n    #           REMOTE_HOST: \\\"47.111.149.160\\\"\\n    #           REMOTE_USER: \\\"root\\\"\\n    #           TARGET: \\\"/var/www/HerryLo.github.io\\\"\\n\\n具体细节可以参考下面的文章↓\\n\\n[真香！GitHub Action一键部署](https://juejin.cn/post/6844904022239870984)\\n\\n**前提**：服务器上已有web服务器，类似nginx服务、Apache服务，**服务代理已经启动**。\\n\\n### 流程：git push代码到代码仓库 ——> gitlab CI/CD或github action 依赖配置文件打包并构建上传 ——> 通过域名访问最新文件\\n\\n  \\n\\nDocker镜像部署\\n----------\\n\\ndocker部署是平台化部署的基础，算是命令工具部署，如果说便捷程度，其实\\\\*\\\\*命令工具部署 和 docker部署 \\\\*\\\\*差不多，但是它有个好处：docker镜像可备份；\\n\\n下面是docker镜像的Dockerfile文件和配置：\\n\\n    FROM node:latest\\n    COPY package.json /\\n    RUN npm i --registry=https://registry.npm.taobao.org\\n    # 打包\\n    RUN npm run build\\n    \\n    FROM nginx:latest\\n    # 这里的dist/目录是你的项目打包后的文件目录\\n    COPY ./dist/ /usr/share/nginx/html/\\n    COPY ./nginx.conf /etc/nginx/conf.d/\\n    \\n    EXPOSE 80\\n\\nnginx配置文件:\\n\\n    server {\\n        listen 80 default_server;\\n        server_name _;\\n    \\n        location / {\\n          root   /usr/share/nginx/html/web;\\n          index  index.html index.htm;\\n          try_files $uri $uri/ /index.html;\\n        }\\n    \\n        # 接口代理示例\\n        # location /api {\\n        #     proxy_pass http://xxx.com;\\n        #     proxy_set_header Host $host:$server_port;\\n        #     proxy_set_header X-Real-IP $remote_addr;\\n            #     proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\\n        #     proxy_set_header Cookie $http_cookie;\\n        #     proxy_buffering off;\\n        #     proxy_cache off;\\n        # }\\n      }\\n\\n通过 docker build 、docker push 镜像名 将镜像打包并推到远端仓库（一般是自己公司项目的私库），然后在服务器上拉取更新最新的镜像，然后将最新的镜像启动即可。\\n\\n**提示**：docker 镜像一般会直接把nginx服务打包在一起，所以不用再在服务器上开启单独的服务，只需要将docker端口开放即可。当然，如果是为了统一管理端口，也是可以通过专门的代理服务管理。\\n\\n### 流程：本地 build打包文件 ——> docker打包镜像 ——> 服务器更新镜像并开启最新镜像 ——> 通过域名访问最新文件\\n\\n具体细节可以参考下面的文章↓\\n\\n[Docker构建前端项目](https://juejin.cn/post/7022815091305218078)\\n\\n  \\n\\n平台化部署\\n-----\\n\\n平台化部署其实就是全流程： **命令工具部署** + **docker镜像的组合版。**\\n\\n只需要将代码push提交，之后通过网页访问构建打包平台，例如：阿里云效流水线 或 jekins打包构建 等平台，_**可以通过点击按钮，下一步下一步的方式，完成打包构建，镜像上传**_。\\n\\n至于更新，我是使用rancher平台来进行，服务的管理或更新，镜像上传完之后，可以在rancher平台配置好相关的负载服务，剩下就只是点击更新按钮就可以。\\n\\n下面是以 阿里codeup流水线 + rancher作为流程示例：\\n\\n**提示**：阿里codeup流水线 或 jekins打包构建 就类似于docker镜像打包，rancher部署就类似于我们将最新镜像上传到服务器上，然后开启服务。（**rancher部署可能更加复杂，因为还涉及到k8s集群知识**）\\n\\n### #流程：git push代码到代码仓库 ——> 通过 codeup流水线构建打包上传镜像 ——> rancher等平台更新镜像 ——> 通过域名访问最新文件\\n\\n具体细节可以参考下面的文章↓\\n\\n[知识扩展-Rancher前端服务发布](https://juejin.cn/post/7094136532499431437)\\n\\n  \\n\\n总结\\n--\\n\\n前端应用部署变化到现在的阶段，也是项目众多不便于管理导致，实际的业务情况，进而推动部署方式的发展。 前端部署的流程，在每个公司都有一套自己的，学习它，适应它，就好了，没有太多疑难问题。\\n\\n使用工具没有什么难度，如果有难度，可能是你用的不太熟。\\n\\n### 你的点赞、收藏是我更新的动力！！",
        "tags": [
            "前端",
            "Docker",
            "全栈"
        ]
    },
    {
        "article_id": "7154261916733407246",
        "cover_image": "",
        "title": "自适应布局和响应式布局",
        "brief": "写在前面 布局的历史发展 随着互联网和相关设备的发展，前端的布局大概经历了这几个阶段：table布局阶段、div+css布局阶段、静态布局阶段、流式布局阶段、自适应布局阶段、响应式布局阶段、弹性布局",
        "user_name": "元子不圆呀",
        "view_count": 6141,
        "collect_count": 158,
        "comment_count": 10,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/936f60b31cdd1f3e9d497fc38cb8feb4~300x300.image",
        "category": "前端",
        "content": "> 持续创作，加速成长！这是我参与「掘金日新计划 · 10 月更文挑战」的第5天，[点击查看活动详情](https://juejin.cn/post/7147654075599978532 \\\"https://juejin.cn/post/7147654075599978532\\\")\\n\\n*写在前面*\\n> 我们在开发的时候，经常会听到关于各种布局的概念，而且里面有些概念经常会混淆，这篇文章主要就是介绍一下静态布局、流式布局、自适应布局、响应式布局和弹性布局的特点和应用场景\\n\\n# 布局的历史发展\\n随着互联网和相关设备的发展，前端的布局大概经历了这几个阶段：table布局阶段、div+css布局阶段、静态布局阶段、流式布局阶段、自适应布局阶段、响应式布局阶段、弹性布局阶段。前面两种布局已经基本上看不到了，而且现在的布局也越来越往弹性布局靠近。下面的内容主要是重点介绍一下后面几种布局。\\n\\n# 静态布局\\n##### 1. 静态布局的特点\\n- 网页中所有元素的单位都是px.不管浏览器尺寸是多少，网页布局始终按照最初写代码的布局来显示，也就是说所有的屏幕看到的页面都是一样的。\\n- 一般的网站（pc端）都是按照这种方式来布局的\\n- 屏幕太小的话，页面会出现滚动条\\n- 屏幕太大的话，页面会有很多的空白，整体页面布局不紧凑\\n##### 2. 静态布局的原理\\n给主要容器设置一个min-width,居中布局。如果屏幕大小小于这个min-width，那么就会增加横向滚动条。如果屏幕大小大于这个宽度，那么就会居中显示，旁边留白的显示的底层的背景。\\n```\\n.container {\\n  min-width: 1190px；\\n  margin: 0 auto;\\n  .content {\\n    width: 1190px;\\n  }\\n}\\n```\\n##### 3. 静态布局的应用场景\\n一般用于官网（pc端）或者其他pc端网站。如果要在移动端显示，一般用的是另外的一套布局。\\n以京东官网为例：\\n\\n**3.1 屏幕比页面宽度大**\\n\\n![企业微信截图_198fc75a-1511-4168-85e3-a960586ec522.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b6426e443b5c4f75ade02892c8d82326~tplv-k3u1fbpfcp-watermark.image?)\\n**3.2 屏幕比页面宽度小**\\n\\n![企业微信截图_272cac48-210c-448b-8853-e121b17b4c2d.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8926bbc251fe42bfab8dc5893b111b12~tplv-k3u1fbpfcp-watermark.image?)\\n\\n**3.3 特殊说明**\\n\\n京东官网并不是全部用的静态布局，里面还用到了媒体查询，但是这里的效果是和静态布局类似。\\n\\n# 流式布局\\n##### 1. 流式布局的特点\\n流式布局也称为液态布局，从名称我们就可以看出来，它的宽度是随着视口的变化而变化的。流式布局具有以下特点：\\n- 屏幕大小变化，页面元素的大小也会跟着变化，但是布局不变\\n- 屏幕太小的时候，页面内容挤成一坨，内容都重叠了，导致页面布局一团乱。\\n- 屏幕太大的时候，页面会拉伸的很长，导致内容在一行显示很长，阅读习惯不好。\\n##### 2. 流式布局的原理\\n页面最外层的容器的尺寸使用百分比搭配min-width和max-width来设置，高度一般还是使用px来设置。\\n```\\n.container {\\n  width: 100%;\\n  min-width: 1200px;\\n  .content {\\n    width: 50%;\\n    height: 400px;\\n  }\\n}\\n```\\n##### 3. 流式布局的应用场景\\n流式布局在早期的pc端布局中还是用的比较多的，但是在现在，不推荐这样使用，因为页面的宽度是随着屏幕的大小来变化的，但是高度还是固定的，就会导致在大屏幕上宽度被拉的很长，但是高度不变，布局看起来不太正常。\\n就像下面这种情况：\\n\\n**3.1 屏幕太大**\\n\\n![企业微信截图_a42f6c6a-fb46-49d7-b6dd-71d42dfc724d.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d817199c91f4c68ae9fc1ad8dec5340~tplv-k3u1fbpfcp-watermark.image?)\\n\\n**3.2 屏幕太小**\\n\\n![企业微信截图_873ebaaa-e701-42cd-ae7c-0f83a9d80e70.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a25953845bc746d591a7b517b502b6f2~tplv-k3u1fbpfcp-watermark.image?)\\n\\n# 自适应布局\\n##### 1. 自适应布局的特点\\n- 分别为不同的分辨率的屏幕定义布局。每一个静态布局对应一个分辨率范围。\\n- 在每个静态布局中，页面元素的尺寸不随屏幕大小的变化而变化。除非屏幕尺寸变化让页面从这个静态布局变成了另外一个静态布局。\\n- 自适应布局虽然有好几套样式布局，但是对于用户来说网页是一样的，只是页面的元素的大小发生了变化。\\n##### 2. 自适应布局的原理\\n针对不同分辨率采用@media媒体查询给不同范围的屏幕分别写一套样式布局，每一套样式布局采用的还是静态布局的方式。\\n### 2.1 添加元标签\\n```\\n// 添加元标签\\n<meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1\\\" />\\n```\\n### 2.2 尽量少使用绝对宽度\\n### 2.3 字体使用相对大小\\n### 2.4 媒体查询\\n```\\n@media screen and (min-width: 768px) {\\n  .block{\\n    width: 680px;\\n    background-color: yellow;\\n  }\\n}\\n@media screen and (min-width: 1024px) {\\n  .block{\\n    width: 768px;\\n    background-color: blue;\\n  }\\n}\\n@media screen and (min-width: 1580px) {\\n  .block{\\n    width: 1190px;\\n    background-color: red;\\n  }\\n}\\n```\\n##### 3. 自适应布局的应用场景\\n自适应布局在pc端和移动端其实都会用到，也是目前网页开发中常常用到的布局方式之一。一般要么是针对pc端做自适应布局，要么针对移动端做自适应布局。如果要想同时兼容移动端和pc端，那么最好还是使用响应式布局啦。\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5151612fb7344d8b9fc80ff4b6e2f528~tplv-k3u1fbpfcp-watermark.image?)\\n\\n# 响应式布局\\n响应式布局也会用到媒体查询，前面我们提到自适应布局是在不同的屏幕下看到的页面布局是一样，如果屏幕太小的话，即使对小屏幕进行适配，会发现页面还是过于拥挤，而响应式正式为了解决这个问题，它可以识别屏幕大小，还是根据屏幕大小调整页面的布局。\\n##### 1. 响应式布局的特点\\n- 屏幕大小变化，元素的大小和位置也会发生改变。\\n- 能同时适应pc和移动端，在不同屏幕大小都有一个良好的布局。\\n##### 2. 响应式布局的原理\\n响应式布局的三个原则：移动优先，@media媒体查询，流式布局（也称为液体布局）。其中首要的就是移动优先，移动优先指的是优先设置移动端（也就是小屏的布局），然后针对不同屏幕使用渐进增强。\\n### 2.1 添加元标签\\n```\\n<meta name=\\\"applicable-device\\\" content=\\\"pc,mobile\\\">\\n<meta http-equiv=\\\"Cache-Control\\\" content=\\\"no-transform \\\">\\n<meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1\\\">\\n```\\n### 2.2 移动优先\\n首先写好小屏幕的样式，也就是移动端的样式，推荐使用vw或者rem的方式来实现。具体参考我的另外一篇文章\\n\\n[移动端布局适配方案](https://juejin.cn/post/7153087500313952263)\\n### 2.3 媒体查询\\n写好小屏幕样式之后，需要测试一下小屏幕的各种适配情况，然后再使用媒体查询去根据不同的屏幕范围加载对应的样式，这里需要特别说明的是，需要跟设计统一好不同屏幕下的布局，毕竟在设计这块他们还是专业的。\\n```\\n@media screen and (min-width: 768px) {\\n  .block{\\n    width: 680px;\\n    background-color: yellow;\\n  }\\n}\\n@media screen and (min-width: 1024px) {\\n  .block{\\n    width: 768px;\\n    background-color: blue;\\n  }\\n}\\n@media screen and (min-width: 1580px) {\\n  .block{\\n    width: 1190px;\\n    background-color: red;\\n  }\\n}\\n```\\n### 2.4 流式布局\\n尽量少给主容器元素设置具体的宽度，这里我推荐使用的是vw或者百分比的流式布局，然后其他的尺寸尽量使用相对单位。\\n##### 3. 响应式布局的应用场景\\n响应式布局的应用场景就是需要同时兼容pc端和移动端的样式的布局一般都采用这种响应式布局，还有一些公司是pc端有一套样式，移动端也有一套样式，比如京东就是这样。像这种的话主要还是看公司业务需要。\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/46d6a9e9f1974a319016af6addfcac5b~tplv-k3u1fbpfcp-watermark.image?)\\n# 弹性布局\\n##### 1. 弹性布局的特点\\n弹性布局指的是页面能够根据屏幕的大小进行缩放，实现这种布局的方式有两种类型：\\n- rem/vw: 实现页面的元素大小随着视口的变化而变化\\n- flex: 实现页面的元素的自动增长和压缩\\n##### 2. 弹性布局的原理\\n关于弹性布局的这块我就不详细介绍了，感兴趣的可以参考我的另外两篇文章：\\n\\n[移动端布局适配方案](https://juejin.cn/post/7153087500313952263)\\n\\n[flex布局详解](https://juejin.cn/post/7142033884434628644)\\n##### 3. 弹性布局的应用场景\\n- rem/vh： 主要应用到适配多种设备\\n- flex: 主要应用到主容器的布局方式，比如三栏式布局、垂直居中布局、两列布局、等高布局等。",
        "tags": [
            "前端",
            "CSS",
            "掘金·日新计划"
        ]
    },
    {
        "article_id": "7171609307253833764",
        "cover_image": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/927caf6c03c24c37bf779ef2ddb4e174~tplv-k3u1fbpfcp-watermark.image?",
        "title": "现代 CSS 高阶技巧，不规则边框解决方案",
        "brief": "现代 CSS 与 Web 动画解决方案，专注于实现复杂布局，制作酷炫动画，制作复杂交互，构建奇思妙想效果等方面的内容。 去实现过往 CSS 中非常难以实现的一个点，本文来看看如何绘制不规则图形的边框。",
        "user_name": "chokcoco",
        "view_count": 14858,
        "collect_count": 138,
        "comment_count": 7,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/d5909b97177d58b77d02a83a620abd18~300x300.image",
        "category": "前端",
        "content": "> 本文为稀土掘金技术社区首发签约文章，14 天内禁止转载，14 天后未获授权禁止转载，侵权必究！\\n\\n我的新的专栏 -- [现代 CSS 与 Web 动画解决方案](https://juejin.cn/column/7140150437562286111)。\\n\\n将专注于实现复杂布局，兼容设备差异，制作酷炫动画，制作复杂交互，提升可访问性及构建奇思妙想效果等方面的内容。\\n\\n在兼顾基础概述的同时，注重对技巧的挖掘，结合实际进行运用，欢迎大家关注。\\n\\n正文从这里开始。\\n\\n本文是 CSS Houdini 之 CSS Painting API 系列第四篇。\\n\\n+ [现代 CSS 之高阶图片渐隐消失术](https://juejin.cn/post/7167160342101884935)\\n+ [现代 CSS 高阶技巧，像 Canvas 一样自由绘图构建样式！](https://juejin.cn/post/7168984450230353950)\\n+ [现代 CSS 高阶技巧，完美的波浪进度条效果！](https://juejin.cn/post/7170868201645932551)\\n\\n在上三篇中，我们详细介绍了 CSS Painting API 是如何一步一步，实现自定义图案甚至实现动画效果的！\\n\\n在这一篇中，我们将继续探索，尝试使用 CSS Painting API，去实现过往 CSS 中非常难以实现的一个点，那就是如何绘制不规则图形的边框。\\n\\n## CSS Painting API\\n\\n再简单快速的过一下，什么是 CSS Painting API。\\n\\nCSS Painting API 是 CSS Houdini 的一部分。而 Houdini 是一组底层 API，它们公开了 CSS 引擎的各个部分，从而使开发人员能够通过加入浏览器渲染引擎的样式和布局过程来扩展 CSS。Houdini 是一组 API，它们使开发人员可以直接访问 [CSS 对象模型](https://developer.mozilla.org/zh-CN/docs/Web/API/CSS_Object_Model) （CSSOM），使开发人员可以编写浏览器可以解析为 CSS 的代码，从而创建新的 CSS 功能，而无需等待它们在浏览器中本地实现。\\n\\nCSS Paint API 目前的版本是 [CSS Painting API Level 1](https://drafts.css-houdini.org/css-paint-api/#paintworkletglobalscope)。它也被称为 CSS Custom Paint 或者 Houdini's Paint Worklet。\\n\\n我们可以把它理解为 JS In CSS，利用 JavaScript Canvas 画布的强大能力，实现过往 CSS 无法实现的功能。\\n\\n## 过往 CSS 实现不规则图形的边框方式\\n\\nCSS 实现不规则图形的边框，一直是 CSS 的一个难点之一。在过往，虽然我们有很多方式利用 Hack 出不规则图形的边框，我在之前的多篇文章中有反复提及过：\\n\\n+ [有意思！不规则边框的生成方案](https://github.com/chokcoco/iCSS/issues/106)\\n+ [CSS 奇技淫巧 | 巧妙实现文字二次加粗再加边框](https://github.com/chokcoco/iCSS/issues/145)\\n\\n我们来看看这样一个图形：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d28ca29a96d4c9c936f541c9e3e2da7~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n利用 CSS 实现这样一个图形是相对简单的，可以利用 mask 或者 background 中的渐变实现，像是这样：\\n\\n```HTML\\n<div class=\\\"arrow-button\\\"></div>\\n```\\n```CSS\\n.arrow-button {\\n    position: relative;\\n    width: 180px;\\n    height: 64px;\\n    background: #f49714;\\n\\n    &::after {\\n        content: \\\"\\\";\\n        position: absolute;\\n        width: 32px;\\n        height: 64px;\\n        top: 0;\\n        right: -32px;\\n        background: \\n            linear-gradient(-45deg, transparent 0, transparent 22px, #f49714 22px, #f49714 100%),\\n            linear-gradient(-135deg, transparent 0, transparent 22px, #f49714 22px, #f49714 100%);\\n        background-size: 32px 32px;\\n        background-repeat: no-repeat;\\n        background-position: 0 bottom, 0 top;\\n    }\\n}\\n```\\n\\n但是，如果，要实现这个图形，但是只有一层边框，利用 CSS 就不那么好实现了，像是这样：\\n\\n<img width=\\\"225\\\" alt=\\\"image\\\" src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/833b647d5c3644b49a31486237ce2d23~tplv-k3u1fbpfcp-zoom-1.image\\\">\\n\\n在过往，有两种相对还不错的方式，去实现这样一个不规则图形的边框：\\n\\n1. 借助 filter，利用多重 `drop-shadow()`\\n2. 借助 SVG 滤镜实现\\n\\n我们快速回顾一下这两个方法。\\n\\n### 借助 filter，利用多重 `drop-shadow()` 实现不规则边框\\n\\n还是上面的图形，我们利用多重 `drop-shadow()`，可以大致的得到它的边框效果。代码如下:\\n\\n```CSS\\ndiv {\\n    position: relative;\\n    width: 180px;\\n    height: 64px;\\n    background: #fff;\\n\\n    &::after {\\n        content: \\\"\\\";\\n        position: absolute;\\n        width: 32px;\\n        height: 64px;\\n        top: 0;\\n        right: -32px;\\n        background: \\n            linear-gradient(-45deg, transparent 0, transparent 22px, #fff 22px, #fff 100%),\\n            linear-gradient(-135deg, transparent 0, transparent 22px, #fff 22px, #fff 100%);\\n        background-size: 32px 32px;\\n        background-repeat: no-repeat;\\n        background-position: 0 bottom, 0 top;\\n    }\\n}\\ndiv {\\n    filter: \\n        drop-shadow(0px 0px .5px #000)\\n        drop-shadow(0px 0px .5px #000)\\n        drop-shadow(0px 0px .5px #000);\\n}\\n```\\n\\n可以看到，这里我们通过叠加 3 层 `drop-shadow()`，来实现不规则图形的边框，虽然 `drop-shadow()` 是用于生成阴影的，但是多层值很小的阴影叠加下，竟然有了类似于边框的效果：\\n\\n<img width=\\\"222\\\" alt=\\\"image\\\" src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/381f6745fb3c4e709ee5203a204425ac~tplv-k3u1fbpfcp-zoom-1.image\\\">\\n\\n### 借助 SVG 滤镜实现实现不规则边框\\n\\n另外一种方式，需要掌握比较深的 SVG 滤镜知识。通过实现一种特殊的 SVG 滤镜，再通过 CSS 的 filter 引入，实现不规则边框。\\n\\n看看代码：\\n\\n```HTML\\n<div></div>\\n\\n<svg width=\\\"0\\\" height=\\\"0\\\">\\n    <filter id=\\\"outline\\\">\\n        <feMorphology in=\\\"SourceAlpha\\\" result=\\\"DILATED\\\" operator=\\\"dilate\\\" radius=\\\"1\\\"></feMorphology>\\n        <feMerge>\\n            <feMergeNode in=\\\"DILATED\\\" />\\n            <feMergeNode in=\\\"SourceGraphic\\\" />\\n        </feMerge>\\n    </filter>\\n</svg>\\n```\\n```CSS\\ndiv {\\n    position: relative;\\n    width: 180px;\\n    height: 64px;\\n    background: #fff;\\n\\n    &::after {\\n        content: \\\"\\\";\\n        position: absolute;\\n        width: 32px;\\n        height: 64px;\\n        top: 0;\\n        right: -32px;\\n        background: \\n            linear-gradient(-45deg, transparent 0, transparent 22px, #fff 22px, #fff 100%),\\n            linear-gradient(-135deg, transparent 0, transparent 22px, #fff 22px, #fff 100%);\\n        background-size: 32px 32px;\\n        background-repeat: no-repeat;\\n        background-position: 0 bottom, 0 top;\\n    }\\n}\\ndiv {\\n    filter: url(#outline);\\n}\\n```\\n\\n简单浅析一下这段 SVG 滤镜代码：\\n\\n1. `<feMorphology in=\\\"SourceAlpha\\\" result=\\\"DILATED\\\" operator=\\\"dilate\\\" radius=\\\"1\\\"></feMorphology>` 将原图的不透明部分作为输入，采用了 dilate 扩张模式且程度为 radius=\\\"1\\\"，生成了一个比原图大 1px 的黑色图块\\n2. 使用 feMerge 将黑色图块和原图叠加在一起\\n3. 可以通过控制滤镜中的 radius=\\\"1\\\" 来控制边框的大小\\n\\n这样，也可以实现不规则图形的边框效果：\\n\\n<img width=\\\"222\\\" alt=\\\"image\\\" src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/702be1594baa47af8843dda6483b22f1~tplv-k3u1fbpfcp-zoom-1.image\\\">\\n\\n[CodePen Demo -- 3 ways to achieve unregular border](https://codepen.io/Chokcoco/pen/oNyyNQd)\\n\\n## 利用 CSS Painting API 实现不规则边框\\n\\n那么，到了今天，利用 CSS Painting API ，我们有了一种更为直接的方式，更好的解决这个问题。\\n\\n还是上面的图形，我们利用 clip-path 来实现一下。\\n\\n```HTML\\n<div></div>\\n```\\n```CSS\\ndiv {\\n    position: relative;\\n    width: 200px;\\n    height: 64px;\\n    background: #f49714;\\n    clip-path: polygon(85% 0%, 100% 50%, 85% 100%, 0% 100%, 0% 0%;); \\n}\\n```\\n\\n我们可以得到这样一个图形：\\n\\n<img width=\\\"219\\\" alt=\\\"image\\\" src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d52e4628f7db4638902614cb11b9f09d~tplv-k3u1fbpfcp-zoom-1.image\\\">\\n\\n当然，本文的主角是 CSS Painting API，既然我们有 `clip-path` 的参数，其实完全也可以利用 CSS Painting API 的 borderDraw 来绘制这个图形。\\n\\n我们尝试一下，改造我们的代码：\\n\\n```HTML\\n<div></div>\\n<script>\\nif (CSS.paintWorklet) {              \\n   CSS.paintWorklet.addModule('/CSSHoudini.js');\\n}\\n</script>\\n```\\n```CSS\\ndiv {\\n    position: relative;\\n    width: 200px;\\n    height: 64px;\\n    background: paint(borderDraw);\\n    --clipPath: 85% 0%, 100% 50%, 85% 100%, 0% 100%, 0% 0%;); \\n}\\n```\\n\\n这里，我们将原本的 `clip-path` 的具体路径参数，定义为了一个 CSS 变量 `--clipPath`，传入我们要实现的 `borderDraw` 方法中。整个图形效果，就是要利用 `background: paint(borderDraw)` 绘制出来。\\n\\n接下来，看看，我们需要实现 `borderDraw`。核心的点在于，我们通过拿到 `--clipPath` 参数，解析它，然后通过循环函数利用画布把这个图形绘制出来。\\n\\n```JavaScript\\n// CSSHoudini.js 文件\\nregisterPaint(\\n    \\\"borderDraw\\\",\\n    class {\\n        static get inputProperties() {\\n            return [\\\"--clipPath\\\"];\\n        }\\n\\n        paint(ctx, size, properties) {\\n            const { width, height } = size;\\n            const clipPath = properties.get(\\\"--clipPath\\\");\\n            const paths = clipPath.toString().split(\\\",\\\");\\n            const parseClipPath = function (obj) {\\n                const x = obj[0];\\n                const y = obj[1];\\n                let fx = 0,\\n                    fy = 0;\\n                if (x.indexOf(\\\"%\\\") > -1) {\\n                    fx = (parseFloat(x) / 100) * width;\\n                } else if (x.indexOf(\\\"px\\\") > -1) {\\n                    fx = parseFloat(x);\\n                }\\n                if (y.indexOf(\\\"%\\\") > -1) {\\n                    fy = (parseFloat(y) / 100) * height;\\n                } else if (y.indexOf(\\\"px\\\") > -1) {\\n                    fy = parseFloat(y);\\n                }\\n                return [fx, fy];\\n            };\\n\\n            var p = parseClipPath(paths[0].trim().split(\\\" \\\"));\\n            ctx.beginPath();\\n            ctx.moveTo(p[0], p[1]);\\n            for (var i = 1; i < paths.length; i++) {\\n                p = parseClipPath(paths[i].trim().split(\\\" \\\"));\\n                ctx.lineTo(p[0], p[1]);\\n            }\\n            ctx.closePath();            \\n            ctx.fill();\\n        }\\n    }\\n);\\n```\\n\\n简单解释一下上述的代码，注意其中最难理解的 `parseClipPath()` 方法的解释。\\n\\n1. 首先我们，通过 `properties.get(\\\"--clipPath\\\")`，我们能够拿到传入的 `--clipPath` 参数\\n2. 通过 `spilt()` 方法，将 `--clipPath` 分成一段段，也就是我们的图形实际的绘制步骤\\n3. 这里有一点非常重要，也就是 `parseClipPath()` 方法，由于我们的 `-clipPath` 的每一段可能是 `100% 50%` 这样的构造，但是实际在绘图的过程中，我们需要的实际坐标的绝对值，譬如在一个 100 x 100 的画布上，我们需要将 `50% 50%` 的百分比坐标，转化为实际的 `50 50` 这样的绝对值\\n4. 在理解了 `parseClipPath()` 后，剩下的就都非常好理解了，我们通过 `ctx.beginPath()`、`ctx.move`、`ctx.lineTo` 以及 `ctx.closePath()` 将整个 `--clipPath` 的图形绘制出来\\n5. 最后，利用 `ctx.fill()` 给图形上色\\n\\n这样，我们就得到了这样一个图形：\\n\\n<img width=\\\"212\\\" alt=\\\"image\\\" src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/324a7d18b6cb400f87550cb074d2b818~tplv-k3u1fbpfcp-zoom-1.image\\\">\\n\\n都拿到了完整的图形了，那么我们只给这个图形绘制边框，不上色，不就得到了它的边框效果了吗？\\n\\n简单改造一些 JavaScript 代码的最后部分：\\n\\n```JavaScript\\n// CSSHoudini.js 文件\\nregisterPaint(\\n    \\\"borderDraw\\\",\\n    class {\\n        static get inputProperties() {\\n            return [\\\"--clipPath\\\"];\\n        }\\n        paint(ctx, size, properties) {\\n            // ...\\n            ctx.closePath();            \\n            // ctx.fill();\\n            ctx.lineWidth = 1;\\n            ctx.strokeStyle = \\\"#000\\\";\\n            ctx.stroke();\\n        }\\n    }\\n);\\n```\\n\\n这样，我们就得到了图形的边框效果：\\n\\n<img width=\\\"218\\\" alt=\\\"image\\\" src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8a6163022fe4a7aafebca82906e313f~tplv-k3u1fbpfcp-zoom-1.image\\\">\\n\\n### 仅仅利用 background 绘制的缺陷\\n\\n但是，仅仅利用 `[bacg](background: paint(borderDraw))` 来绘制边框效果，会有一些问题。\\n\\n上述的图形，我们仅仅赋予了 1px 的边框，如果我们把边框改成 5px 呢？看看会发生什么？\\n\\n```JavaScript\\n// CSSHoudini.js 文件\\nregisterPaint(\\n    \\\"borderDraw\\\",\\n    class {\\n        static get inputProperties() {\\n            return [\\\"--clipPath\\\"];\\n        }\\n        paint(ctx, size, properties) {\\n            // ...\\n            ctx.lineWidth = 5;\\n            ctx.strokeStyle = \\\"#000\\\";\\n            ctx.stroke();\\n        }\\n    }\\n);\\n```\\n\\n此时，整个图形会变成：\\n\\n<img width=\\\"237\\\" alt=\\\"image\\\" src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e19315a39cc54befba1cb27ca3b55c64~tplv-k3u1fbpfcp-zoom-1.image\\\">\\n\\n可以看到，没有展示完整的 5px 的边框，这是由于整个画布只有元素的高宽大小，而上述的代码中，元素的边框有一部分绘制到了画布之外，因此，整个图形并非我们期待的效果。\\n\\n因此，我们需要换一种思路解决这个问题，继续改造一下我们的代码，仅仅需要改造 CSS 代码即可：\\n\\n```CSS\\ndiv {\\n    position: relative;\\n    width: 200px;\\n    height: 64px;\\n    margin: auto;\\n    clip-path: polygon(var(--clipPath)); \\n    --clipPath: 85% 0%, 100% 50%, 85% 100%, 0% 100%, 0% 0%;\\n    \\n    &::before {\\n      content:\\\"\\\";\\n      position:absolute;\\n      inset: 0;\\n      mask: paint(borderDraw);\\n      background: #000;\\n    }\\n}\\n```\\n\\n这里，我们的元素本身，还是利用了 `clip-path: polygon(var(--clipPath))` 剪切了自身，同时，我们借助了一个伪元素，利用这个伪元素去实现具体的边框效果。\\n\\n这里其实用了一种内外切割的思想，去实现的边框效果：\\n\\n1. 利用父元素的 `clip-path: polygon(var(--clipPath))` 剪切掉外围的图形\\n2. 利用给伪元素的 mask 作用实际的 `paint(borderDraw)` 方法，把图形的内部镂空，只保留边框部分\\n\\n还是设置 `ctx.lineWidth = 5`，再看看效果：\\n\\n<img width=\\\"217\\\" alt=\\\"image\\\" src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a111335a5dd4fc2925ba92fad430aff~tplv-k3u1fbpfcp-zoom-1.image\\\">\\n\\n看上去不错，但是实际上，虽然设置了 `5px` 的边框宽度，但是实际上，上图的边框宽度只有 `2.5px` 的，这是由于另外一点一半边框实际上被切割掉了。\\n\\n因此，我们如果需要实现 `5px` 的效果，实际上需要 `ctx.lineWidth =10`。\\n\\n当然，我们可以通过一个 CSS 变量来控制边框的大小：\\n\\n```CSS\\ndiv {\\n    position: relative;\\n    width: 200px;\\n    height: 64px;\\n    margin: auto;\\n    clip-path: polygon(var(--clipPath)); \\n    --clipPath: 85% 0%, 100% 50%, 85% 100%, 0% 100%, 0% 0%;\\n    --borderWidth: 5;\\n    \\n    &::before {\\n      content:\\\"\\\";\\n      position:absolute;\\n      inset: 0;\\n      mask: paint(borderDraw);\\n      background: #000;\\n    }\\n}\\n```\\n\\n在实际的 borderDraw 函数中，我们将传入的 `--borderWidth` 参数，乘以 2 使用就好：\\n\\n```JavaScript\\n\\nregisterPaint(\\n    \\\"borderDraw\\\",\\n    class {\\n        static get inputProperties() {\\n            return [\\\"--clipPath\\\", \\\"--borderWidth\\\"];\\n        }\\n        paint(ctx, size, properties) {\\n            const borderWidth = properties.get(\\\"--borderWidth\\\");\\n            // ...\\n            ctx.lineWidth = borderWidth * 2;\\n            ctx.strokeStyle = \\\"#000\\\";\\n            ctx.stroke();\\n        }\\n    }\\n);\\n```\\n\\n这样，我们每次都能得到我们想要的边框长度：\\n\\n<img width=\\\"209\\\" alt=\\\"image\\\" src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b8cbd9f9df2421c8d62d5dbb4901244~tplv-k3u1fbpfcp-zoom-1.image\\\">\\n\\n[CodePen Demo -- CSS Hudini & Unregular Custom Border](https://codepen.io/Chokcoco/pen/MWXXYgJ)\\n\\n到这里，整个实现就完成了，整个过程其实有多处非常关键的点，会有一点点难以理解，具体可能需要自己实际调试一遍找到实现的原理。\\n\\n## 具体应用\\n\\n在掌握了上述的方法后，我们就可以利用这个方式，实现各类不规则图形的边框效果，我们只需要传入对于的 `clip-path` 参数以及我们想要的边框长度即可。\\n\\n好，这样，我们就能实现各类不同的不规则图形的边框效果了。\\n\\n像是这样：\\n\\n```CSS\\ndiv {\\n    position: relative;\\n    width: 200px;\\n    height: 200px;\\n    clip-path: polygon(var(--clipPath)); \\n    --clipPath: 0% 15%, 15% 15%, 15% 0%, 85% 0%, 85% 15%, 100% 15%, 100% 85%, 85% 85%, 85% 100%, 15% 100%, 15% 85%, 0% 85%;\\n    --borderWidrh: 1;\\n    --color: #000;\\n    \\n    &::before {\\n      content:\\\"\\\";\\n      position:absolute;\\n      inset: 0;\\n      mask: paint(borderDraw);\\n      background: var(--color);\\n    }\\n}\\n\\ndiv:nth-child(2) {\\n    --clipPath: 50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%;\\n    --borderWidrh: 2;\\n    --color: #ffcc00;\\n}\\ndiv:nth-child(3) {\\n    --clipPath: 90% 58%90% 58%, 69% 51%, 69% 51%, 50% 21%, 50% 21%, 39% 39%, 39% 39%, 15% 26%, 15% 26%, 15% 55%, 15% 55%, 31% 87%, 31% 87%, 14% 84%, 14% 84%, 44% 96%, 44% 96%, 59% 96%, 59% 96%, 75% 90%, 75% 90%, 71% 83%, 71% 83%, 69% 73%, 69% 73%, 88% 73%, 88% 73%, 89% 87%, 89% 87%, 94% 73%, 94% 73%;\\n    --borderWidrh: 1;\\n    --color: deeppink;\\n}\\ndiv:nth-child(4) {\\n    --clipPath: 0% 0%, 100% 0%, 100% 75%, 75% 75%, 75% 100%, 50% 75%, 0% 75%;\\n    --borderWidrh: 1;\\n    --color: yellowgreen;\\n}\\ndiv:nth-child(5) {\\n    --clipPath: 20% 0%, 0% 20%, 30% 50%, 0% 80%, 20% 100%, 50% 70%, 80% 100%, 100% 80%, 70% 50%, 100% 20%, 80% 0%, 50% 30%;\\n    --borderWidrh: 3;\\n    --color: #c7b311;\\n}\\n```\\n\\n得到不同图形的边框效果：\\n\\n<img width=\\\"1690\\\" alt=\\\"image\\\" src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d577e5b5b01946cbb49186064d637130~tplv-k3u1fbpfcp-zoom-1.image\\\">\\n\\n[CodePen Demo -- CSS Hudini & Unregular Custom Border](https://codepen.io/Chokcoco/pen/KKeROeX)\\n\\n又或者是基于它们，去实现各类按钮效果，这种效果在以往使用 CSS 是非常非常难实现的：\\n\\n<img width=\\\"1131\\\" alt=\\\"image\\\" src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b017bc79b4d407c92daf7c8c4f12f94~tplv-k3u1fbpfcp-zoom-1.image\\\">\\n\\n它们的核心原理都是一样的，甚至加上 Hover 效果，也是非常的轻松：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8b0ffc3fcf04bfabea6d7a48a3e4a92~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n完整的代码，你可以戳这里：[CodePen Demo -- https://codepen.io/Chokcoco/pen/ExRLqdO](https://codepen.io/Chokcoco/pen/ExRLqdO)\\n\\n至此，我们再一次利用 CSS Painting API 实现了我们过往 CSS 完全无法实现的效果。这个也就是 CSS Houdini 的魅力，是 JS In CSS 的魅力。\\n\\n## 兼容性？\\n\\n好吧，其实上一篇文章也谈到了兼容问题，因为可能有很多看到本篇文章并没有去翻看前两篇文章的同学。那么，CSS Painting API 的兼容性到底如何呢？\\n\\n[CanIUse - registerPaint](https://caniuse.com/?search=registerPaint) 数据如下（截止至 2022-11-23）：\\n\\n<img width=\\\"1367\\\" alt=\\\"image\\\" src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6edf9fab6f1740e08b48b1a9d2499b0a~tplv-k3u1fbpfcp-zoom-1.image\\\">\\n\\nChrome 和 Edge 基于 [Chromium](https://www.google.com.hk/search?newwindow=1&rlz=1C5GCEM_enCN988CN988&q=Chromium&spell=1&sa=X&ved=2ahUKEwi3he2ensL7AhVaSmwGHdnzBxgQkeECKAB6BAgoEAE) 内核的浏览器很早就已经支持，而主流浏览器中，Firefox 和 Safari 目前还不支持。\\n\\nCSS Houdini 虽然强大，目前看来要想大规模上生产环境，仍需一段时间的等待。让我们给时间一点时间！\\n\\n## 最后\\n\\n好了，本文到此结束，希望本文对你有所帮助 :)\\n\\n如果还有什么疑问或者建议，可以多多交流，原创文章，文笔有限，才疏学浅，文中若有不正之处，万望告知。",
        "tags": [
            "前端",
            "CSS",
            "JavaScript"
        ]
    },
    {
        "article_id": "7185360908158238776",
        "cover_image": "https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ae5be731ef049aa9a1160186391071a~tplv-k3u1fbpfcp-watermark.image?",
        "title": "为什么建议在某些场景下使用 vue-query 代替 pinia ？看完这篇文章你就明白了",
        "brief": "使用 react 的同学应该对 swr、react-query、ahooks 的 useRequess 并不陌生，在 vue 中这个思想的应用如何呢？",
        "user_name": "马格纳斯",
        "view_count": 5236,
        "collect_count": 45,
        "comment_count": 37,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/a08fad9d5cd37cfe169ffc651a8edc55~300x300.image",
        "category": "前端",
        "content": "## 前言\\n在 vue3 中，状态管理都是用的 pinia 来处理和存储从服务端获取的数据。使用 react 的同学应该对 `swr`、`react-query`、`ahooks 的 useRequest（前两者的模仿）`并不陌生，这些是专门用来处理数据请求的, 能够帮助你处理得到的数据、loading、error，还有缓存数据的功能等等。不止有 `react-query`、`vue-query`, 还有 `svelte-query` 和 `solid-query`，这些其实都是同一个作者，是在同一个库中，通过它的核心底层来实现各个框架的功能。[query 文档地址](https://tanstack.com/query/v4/docs/vue/overview)\\n\\n## 使用区别\\n### pinia\\n\\n```javascript\\n// 根文件\\nconst pinina = createPinia();\\napp.use(pinia);\\n```\\n获取和修改用户信息，需要维护 user 状态, 页面中需要维护两个 loading 状态。\\n```javascript\\nconst useStore = defineStore('main', {\\n  state: () => ({\\n    user: null,\\n  }),\\n  actions: {\\n    async getUser() {\\n      try {\\n        const user = await axios.get(\\\"/api/user\\\");\\n        this.user = user;\\n      } catch(err) {\\n       //\\n      }\\n    },\\n    async updateUser(data) {\\n      try {\\n        const res = await axios.post(\\\"/api/user\\\", data);\\n        // do something\\n        // this.user = res;\\n      } catch(err) {\\n       //\\n      }\\n    }\\n  },\\n})\\n```\\n\\n```javascript\\n<script setup>\\nconst getUserLoading = ref(false);\\nconst updateUserLoading = ref(false);\\n\\n// 获取用户信息\\nonMounted(async() => {\\n  getUserLoading.value = true;\\n  await store.getUser();\\n  getUserLoading.value = false;\\n})\\n\\n// 修改用户信息\\nconst updateUser = async () => {\\n  updateUserLoading.value = true;\\n  await store.updateUser({ username: \\\"123\\\" })\\n  updateUserLoading.value = false;\\n}\\n</script>\\n```\\n\\n### vue-query\\n```javascript\\n// 根文件\\napp.use(VueQueryPlugin)\\n```\\n\\n```javascript\\n// 新建一个文件 useUserQuery.js。需要必传两个值，queryKey 是缓存数据需要的唯一值，是个数组，我的习惯是直接用 api 地址。queryFn 是请求的方法。\\n// useUserQuery.js\\nconst api = \\\"/api/user\\\";\\nexport const useUserQuery = (props) => useQuery({ queryKey: [api], queryFn: () => axios.get(api), ...props });\\n\\n// 新建一个文件 useUserMutation.js，因为是修改数据，并没有缓存这个概念，所以不需要唯一值，只需要传入请求方法即可。\\n// useUserMutation.js\\nconst api = \\\"/api/user\\\";\\nexport const useUserMutation = (props) => useMutation({ mutationFn: (data) => axios.post(api, data), ...props });\\n```\\n\\n```javascript\\n<script setup>\\n// 获取用户信息\\nconst { data, isLoading } = useUserQuery({\\n  onSuccess: (data) => { \\n    // 成功回调\\n  },\\n  onError: (error) => {\\n    // 可以配置全局 onError 错误处理，这里不做介绍\\n  },\\n});\\n\\nconst { isLoading, mutate } = useUserMutation();\\n\\n// 修改用户信息\\nconst updateUser = () => {\\n  mutate({ username: \\\"123\\\" })\\n}\\n</script>\\n```\\n如果你在另一个地方也需要用到这个 user 数据，你可以再调用一次 useUserQuery，因为之前有缓存了，所以不会发出请求，但可以拿到数据。或者使用 queryClient 传入唯一值来获取数据。\\n```javascript\\nconst queryClient = useQueryClient();\\nconst data = queryClient.getQueryData([\\\"/api/user\\\"])\\n```\\n\\n## 总结\\n先来看看官方文档中怎么说 [# Does TanStack Query replace Vuex, Pinia or other global state managers?](https://tanstack.com/query/v4/docs/vue/guides/does-this-replace-client-state)\\n\\nvue-query 只适用于存储从服务端获取的数据，如果有另外的数据需要存储还是要用到 pinia，但是这种数据是比较少的，这样也可以使得 pinia 中的代码量减少很多并简洁。当然这里介绍的 vue-query 的 api 是最简单的，你能想到的功能它基本都有，感兴趣的可以查看文档。\\n\\n## 趋势\\n在 react 中使用 swr、react-query 是大势所趋，可以从 npm 下载量来看出来。相信今后在 vue 中 vue-query 也会有越来越多的使用，因为另外三大框架都是跟随 react 走的 hooks 的思想。",
        "tags": [
            "前端",
            "Vue.js",
            "前端框架"
        ]
    },
    {
        "article_id": "7195066962500649021",
        "cover_image": "https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae0ad772b65c4d5fb6c8033f1d696ca0~tplv-k3u1fbpfcp-watermark.image?",
        "title": "Storybook 7.0 Beta Vue3踩坑随笔",
        "brief": "Storybook踩坑笔记. Storybook 结合 vite + vue3 + pnpm安装教程.Storybook是Vue和Angular 的强大工具. 它拥有蓬勃发展的开发者社区和丰富的插件.",
        "user_name": "65岁退休Coder",
        "view_count": 388,
        "collect_count": 1,
        "comment_count": 1,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/c19771a067c276cf27f87ee59abab930~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: vuepress\\nhighlight: atelier-cave-dark\\n---\\n## 故事背景\\n\\n> 基于 `Vue + Vite + TS` 结合 `pnpm` 的一个 `monorepo` 项目的组件库文档编写，起初个人是比较倾向于直接使用全家桶系列的 `VitePress`。无奈公司中其他库文档均使用 `Storybook`，并且已经升级到最新版本。\\n>\\n> 好吧，到这里就基本知道了自己要做什么了。\\n\\n## 开始\\n\\n> 由于之前也没有接触过这个玩意儿，就去看着官网一步步操作去了。坑也就在这里了，谁知道版本上去了，文档却没有做出相应的调整。然后就有了后续一系列的问题。[Storybook 7.0 下载](https://storybook.js.org/docs/7.0/vue/get-started/install)\\n\\n**坑一：不要按照官网的下载指令一步步操作，因为这样最终会下载 6.5 稳定版**\\n\\n```bash\\n# 错误安装方式\\nnpx storybook init\\nnpx sb init\\n# 正确安装方式\\nnpx storybook@next init \\nnpx sb@next init\\n```\\n\\n**坑二：不要查找 `vite` 的创建项目方式，使用一些不明所以的命令。`Storybook` 会根据你项目技术栈创建出对应的脚手架**\\n\\n```bash\\n# 错误命令\\nnpx sb init --builder @storybook/builder-vite\\nnpx storybook init --builder vite\\n```\\n\\n**坑三：7.0 的版本不要在 `monorepo` 的项目中创建除非是在根目录**\\n\\n```\\n ERR_PNPM_ADDING_TO_ROOT  Running this command will add the dependency to the workspace root, which might not be what you want - if you really meant it, make it explicit by running this command again with the -w flag (or --workspace-root). If you don't want to see this warning anymore, you may set the ignore-workspace-root-check setting to true.\\nAn error occurred while installing dependencies.\\n\\n ERROR  Command failed with exit code 1: /Users/a1234/Library/pnpm/store/v3/tmp/dlx-36847/node_modules/.bin/storybook init --package-manager=pnpm\\n```\\n\\n> so 我的解决方案就是创建一个 `vite` 的项目，然后在这个项目中去初始化 `Storybook` 然后将相关的命令、文件夹及 `devDependencies` 中相关的包全部 `cv` 到对应的子项目中重新下载依赖即可使用。\\n\\n具体操作如下：\\n\\n- `pnpm create vite myApp --template vue-ts` 创建 `vite` 项目，随后安装依赖。\\n- `pnpx storybook@next init --package-manager=pnpm`\\n- 将 `package.json` 中关于 `Storybook` 的内容进行 `cv`，包括 `scripts` 中的两条指令，`devDependencies` 中的一些包，项目中的两个目录。\\n- 复制到对应的 `monorepo` 的子项目中，删除子项目原有的 `node_modeules` 重新执行 `pnpm install` 即可。\\n\\n**坑四：做完以上操作后，`.vue` 文件中模板的 `class` 类名 `jsx` 错误，要求你使用 `className` 而不是 `class`**\\n\\n[问题 issue](https://github.com/storybookjs/storybook/issues/17576) 问题大致就是模板类型检查错误导致的（@vue/runtime-dom）解决方案及具体原因[解决方案](https://github.com/storybookjs/storybook/issues/17576)内都有相关介绍。\\n\\n**注意：**\\n\\n- 不要尝试使用 `--type vue3` 类似的指令创建对应的项目，大概率不会成功。\\n- `Storybook` 默认使用 `yarn` 作为包管理工具，如果想要切换执行指令时末尾增加 `--package-manager=pnpm`\\n\\n\\n## 总结\\n\\n目前来看经过上面一系列的摸索过后，本地测试，打包都没有什么问题，就看后续部署了。如果后续在使用过程中碰到其他问题也会持续在这里进行更新。",
        "tags": [
            "前端",
            "Vue.js",
            "前端框架"
        ]
    },
    {
        "article_id": "7184249126669221946",
        "cover_image": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/16fdbf2bda5845068647fb1146983e1d~tplv-k3u1fbpfcp-watermark.image?",
        "title": "揭秘web3元宇宙千万级项目的财富密码：凭什么一个div卖一千块？",
        "brief": "最近有朋友给我分享了一个元宇宙项目，非常赚钱。它长下面这个样子： 一个 44*44 的 div 小格子，卖价从 100 元到 1300 元不等，越靠上面的格子越贵，因为曝光率越高。你买了这个小格子",
        "user_name": "代码与野兽",
        "view_count": 21283,
        "collect_count": 73,
        "comment_count": 43,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/dac9f5ba3e7b6d8015a9b37536d4ef59~300x300.image",
        "category": "前端",
        "content": "# 基本介绍\\n\\n最近有朋友给我分享了一个元宇宙项目，非常赚钱。它长下面这个样子：\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb5dbaef6a7b4773b88dadae35f03f6a~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n一个 44*44 的 div 小格子，卖价从 100 元到 1300 元不等，越靠上面的格子越贵，因为曝光率越高。你买了这个小格子，就可以放一张图片或者文字，别人就可以看到，然后联系你。像这种格子，每个区有 2400 个，每个城市可以有 N 个区，可以通过投票的方式扩张区块。那有多少个城市呢？\\n\\n现实有多少个，这里面就有多少个。截止 2021 年，中国已经有 691 个城市了。2022 年的数据还没出来，我估计会突破 700 个。\\n\\n而且它还可以创建城市，也就意味着它可以无限增长。\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f76dcc4e4a0b484bb74645ca5ba36728~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n像这类项目还有很多，属于割韭菜的老玩法了。\\n\\n下面我开始分析一下这类项目。\\n\\n声明一下：不针对这个项目，也不透露项目名字和更多信息，所有相关信息均有特殊处理。如果认出来是哪个项目，也请不要说出来，谢谢。如有雷同，纯属巧合。\\n\\n揭秘项目是一件很伤人的事情，断人财路如杀人父母。\\n\\n但我想让更多人了解更多 Web3 的套路、打破黑箱子、去除魔法、看到本质。防止更多人踩雷当韭菜，我必须这么做。项目方，得罪了！\\n\\n# 技术分析\\n\\n首先科普一下区块链的类型，防止有些人不明白。\\n\\n目前区块链分三种：公链、联盟链、私有链。\\n\\n主要的差异在于去中心化的程度，公链完全公开、完全透明，人人皆可参与，以太坊、比特币都是这类。联盟链半公开、半透明，只能由特定的成员和有限的第三方参与，IBM 的 Fabrice 就是这类。私有链的读写权、记账权都在一个组织手里。不公开也不透明。\\n\\n上述这类项目基本上都是基于私有链进行开发的。\\n\\n现在，关于私有链是什么，你应该有了一个基本印象。什么人最喜欢私有链呢？诈骗团队。\\n\\n三种类型的区块链同样是区块链，但不一定所有基于区块链的应用都是安全的。如果你要入局某个区块链应用，最好选择公链，其次选择联盟链，至于私链，一定要慎之又慎。很多韭菜就是因为分不清链的类型才被割。\\n\\n总结一下，假联盟链和私有链是不可信的。和 Web2 中心化的服务没什么本质上的区别。另外，即使是公链也同样可能存在问题。\\n\\n聊完区块链端，再聊聊前端。\\n\\n可能很多人接触元宇宙的人都听过各种类似这样的宣传：**元宇宙的基础是 3D 和 VR，是立体感、沉浸感、虚拟现实感**。\\n\\n我不能说这是错的，但这不是元宇宙的底层核心逻辑。这从技术角度出发是没问题的，但这些都只是一种交互方式而已，不是必须，传统的交互形式同样不影响赚钱。\\n\\n元宇宙更重要的一个玩法，很多人都不了解，那就是虚拟地产。在虚拟地产中，只要保证这个虚拟资产的唯一性和权利明确就够了。至于虚拟资产对应的是一个 div 还是一个 3D 模型，不重要，真的不重要。\\n\\n只要你买了虚拟土地，就可以在土地上去做你想要做的事。比如打广告，或者像现实世界一样去炒房。\\n\\n这也就是为什么人人都可以写一个 div，你的 div 一文不值，而别人的 div 值上千块的原因。div 不重要，重要的是 div 背后蕴含的东西。\\n\\n**摆脱技术视角，才能看清商业的全貌。**\\n\\n那这种项目难度如何？\\n\\n技术上并不难，这种项目我的团队半个月内就可以做出来。\\n\\n但我们却做不到，为什么呢？\\n\\n这和技术关系就不大了。其实技术一点儿都不重要，重要的是商业模式，也就是下面我要讲的部分。\\n\\n# 商业模式\\n\\n虽然我已经处于 All in Web3 的边缘状态。但我不能回避 Web3 的问题。\\n\\n目前所有 Web3 的项目，实际价值都非常有限。特别像这种打着元宇宙旗号的虚拟地产项目。\\n\\n有任何价值吗？主要的用途就只有打广告而已，除此之外没有任何实际价值。这事儿，放到 Web2 里面做，所需要花费的成本将会远远降低。\\n\\n可能你会想，这种产品，会有人买吗？确实会有人买。\\n\\n这个问题就像是为什么传销这种东西都有人信呢？\\n\\n从技术角度想的话，你永远都想不明白。因为这是理性人的思考。事实是：现实世界里无论多么愚蠢的谎言，总会有人信。\\n\\n这种产品，需要很强的市场营销能力。\\n\\n他们会在非常豪华的酒店举办发布会，会请很多拖儿来渲染气氛，会请一些名人来充当门面，会找一些媒体来进行采访报道。\\n\\n总之，需要把这个一文不值的 div 包装成无价之宝。\\n\\n只要你相信它值钱，它就真的值钱。这个玩法就是资金盘。\\n\\n只有初始用户是不够的，如果用户不能源源不断地增加，那么再好的项目也会逐渐走向死亡。很多 Web3 项目归零，就是因为它的支持者越来越少。所以必须让更多的人加入进来。**Web3 项目，流通性是核心。**\\n\\n怎么让新用户加入呢？让初始支持者去自发地、主动地帮我们推广就可以了。当然这需要利益驱动。比如你分享你的专属链接给你的朋友，你的朋友花了 1000 块买了一块地皮后，平台收 6 成，剩下的 4 成，也就是 400 块就归你了。这和传统的病毒营销一模一样。\\n\\n同时把现实世界炒房的概念挪进虚拟地产中：比如你花 1200 买了个 div，可以继续以 1500 的价格售卖，只要有人愿意买，你就能赚钱。只要有源源不断的人加入进来，虚拟地产就能炒起来。可能炒到几万、几十万都有可能。但背后的真正价值是什么？div 仍旧是一个 div。\\n\\n这个玩法就是传销盘。\\n\\n上面这一套玩法组合起来，就是庞氏骗局、杀猪盘。\\n\\n这也是为什么在大陆做 Web3 很容易游走于法律边缘的原因。\\n\\n国内法律明确禁止通过发行代币或 NFT 进行融资、以及在二级市场炒作是有原因的。\\n\\n大多数 Web3 项目都会和它打擦边球。比如虚拟地产这类项目，虽然它具有 NFT 的属性，但它并不是 NFT，实际上只是购买了平台提供的服务。一旦平台出现问题，钱也就打了水漂。这和传统 Web2 的模式几乎没什么区别。但因为有金融属性在里面，很容易被扣上非法融资的帽子。\\n\\n如果你真的想买 Web3 产品，建议去买有顶级大平台背书的产品。至于哪些是顶级大平台，我就不再举例了，我也不会提供任何投资建议。\\n\\n最后谈下我从自己亲身经历 Web3 血与泪的过去中总结的经验：**不要以为自己看了一些视频、读了一些文章、接触了几个项目，就认为自己很懂 Web3 了。杀猪盘杀的就是这些似懂非懂的猪。** 目前网上大多数讲 Web3 各种分析、趋势的文章、视频都有营销成分。没有自己的理解和判断，Web3 是很难玩明白的。\\n\\n我认为**作为一个开发者，参与 Web3 更合适的渠道是以技术的方式为一些 Web3 公司工作。** 大部分 Web3 的公司都是远程工作方式。不用 996，不用挤地铁，还能拿到高薪。你完全可以在十八线小县城赚美元，进入 work life balance 的状态。最近两年从大厂辞职投入 Web3 阵营的开发者已经屡见不鲜，这或许是告别卷成一团乱麻的传统互联网的新方式。\\n\\n我们是一群立志改变世界的人。而 Web3 是未来世界一大变数，我们想帮助更多人了解并加入 Web3，如果你对 Web3 感兴趣，可以添加我的微信：LZQ20130415，邀你入群，一起沉淀、一起成长、一起拥抱未来。",
        "tags": [
            "前端",
            "后端",
            "web3"
        ]
    },
    {
        "article_id": "7186459084303335481",
        "cover_image": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb591e3a2a174b39950fb5f7dde4dd26~tplv-k3u1fbpfcp-watermark.image?",
        "title": "老板说：把玉兔迎春图实现高亮",
        "brief": "兔年来临，老板意气风发的说：我们的系统登录页要换做玉兔迎春的背景页，而且用户`ctrl+f`搜索【玉兔迎春】关键字时，图片要高亮。我们只需要盖一层div在图片上，然后设置文字透明，浏览器`ctrl+f",
        "user_name": "Dignity_呱",
        "view_count": 5763,
        "collect_count": 10,
        "comment_count": 15,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/5c6084ef8bfcf6e37087a1455a905668~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: fancy\\nhighlight: arduino-light\\n\\n---\\n\\n我正在参加「兔了个兔」创意投稿大赛，详情请看：[「兔了个兔」创意投稿大赛](https://juejin.cn/post/7185104994801025061)\\n\\n\\n## 前言\\n\\n- [常网IT](http://zhengzemin.cn:3000)戳我呀！\\n- [常网IT源码](https://github.com/git-Dignity/vueAndTsAndKoa2)上线啦！\\n- 本篇录入[杂乱汚章](https://juejin.cn/column/7037765847980474376)专栏，各位看官感兴趣可移步🚶。\\n- 兔年来临，老板意气风发的说：我们的系统登录页要换做玉兔迎春的背景页，而且用户`ctrl+f`搜索【玉兔迎春】关键字时，图片要高亮。\\n\\n---\\n\\n> 新的一年，祝大家身体健康、Bug--\\n\\n\\n\\n![1.jpg](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5b216e190dbd4e2da267325ec7900ee9~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n\\n\\n## 一、明确需求\\n\\n将系统的登录页面背景换做如上图【玉兔迎春】。\\n\\n而且，用户可以通过搜索关键字【玉兔迎春】让背景图的文字进行高亮。\\n\\n\\n\\n下面我们进行分析一下。\\n\\n\\n## 二、进行分析\\n\\n接到该需求的时候，心里是这样子的。\\n\\n\\n![3.jpg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef74ff3f225249878eaff14ea32c57ee~tplv-k3u1fbpfcp-watermark.image?)\\n\\n\\n于是，老板像是看穿我的疑惑时，语重心长的对我们说：我们要给用户一个焕然一新的感觉。\\n\\n疯狂点点头，并想好如何让图片里面的文字进行高亮的对策。\\n\\n静下来思考片刻，其实不是很难。\\n\\n### 2.1 思路\\n\\n我们只需要盖一层div在图片上，然后设置文字透明，浏览器`ctrl+f`搜索的时候，会给文字他高亮黄的颜色，我们就可以看到文字了。\\n\\n盖的这层div，里面包含着我们的文字。\\n\\n\\n\\n![4.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6b12d88f3fc4b768fa5f0bfed2df0ba~tplv-k3u1fbpfcp-watermark.image?)\\n\\n那么，难点就是怎么从图片获取文字出来。\\n\\n其实这个技术，有个专业词语来描述，叫`ocr`识别技术。\\n\\n\\n### 2.2 ocr\\n\\nocr，其实也叫“光学字符识别技术”，是最为常见的、也是目前最高效的文字扫描技术，它可以从图片或者PDF中识别和提取其中的文字内容，输出文本文档，方便验证用户信息，或者直接进行内容编辑。\\n\\n揭秘该技术：实现文字识别？从图片到文字的过程发生了什么？\\n\\n![6.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5596ebbfda3a4dcabbab17103c0af5a7~tplv-k3u1fbpfcp-watermark.image?)\\n\\n分别是输入、图像与处理、文字检测、文本识别，及输出。每个过程都需要算法的深度配合，因此从技术底层来讲，从图片到文字输出，要经历以下的过程：\\n\\n1、图像输入：读取不同图像格式文件；\\n\\n2、图像预处理：主要包括图像二值化，噪声去除，倾斜校正等；\\n\\n3、版面分析：将文档图片分段落，分行；\\n\\n4、字符切割：处理因字符粘连、断笔造成字符难以简单切割的问题；\\n\\n5、字符特征提取：对字符图像提取多维特征；\\n\\n6、字符识别：将当前字符提取的特征向量与特征模板库进行模板粗分类和模板细匹配，识别出字符；\\n\\n7、版面恢复：识别原文档的排版，按原排版格式将识别结果输出到文本文档；\\n\\n8、后处理校正: 根据特定的语言上下文的关系，对识别结果进行校正。\\n\\n\\n### 2.3 应用\\n\\n随着ocr技术的成熟，不少软件已经出了该功能。\\n\\n比如：微信、qq、语雀等等。\\n\\n还有一些试卷试题，都会用到ocr识别技术。\\n\\n\\n![7.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/449ef5d15e7e4bc78d998ac3fdf87087~tplv-k3u1fbpfcp-watermark.image?)\\n\\n还有一些技术文档，实现自定义搜索功能，表格关键字高亮。\\n\\n\\n![9.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf12285f5e434da2b4fc6b4b899d8eec~tplv-k3u1fbpfcp-watermark.image?)\\n\\n老板这次需求：把玉兔迎春图实现高亮。\\n\\n和如上实现的技术思路类似。\\n\\n我们也可以自定义颜色，加个`span`标签给其想要的样式。\\n\\n\\n## 三、使用\\n\\n当然，我们可能并不关心底层的实现，只关心怎么怎么去使用。\\n\\n我们可以调用百度API：[文字提取技术](https://console.bce.baidu.com/ai/?_=1673173521195&fromai=1#/ai/ocr/overview/index)\\n\\n还可以使用java的`tesseract-ocr`库，其实就是文字的训练。\\n\\n所以会有个弊端，就是文件可能会有点大，存放着大量文字。\\n\\n\\n\\n\\n\\n## 后记\\n\\n在一个需求的产生之后，我们如果没什么思路，可以借鉴一下，目前市场上有没有类似的技术的沉淀，从而实现需求。\\n\\n最后，望大家的新的一年，工作顺利，身体健康。\\n\\n玉兔迎春啦🐇🧨🐇🏮🐇~\\n\\n\\n\\n\\n\\n> 👍 如果对您有帮助，您的点赞是我前进的润滑剂。\\n\\n\\n\\n## 以往推荐\\n\\n [叮~寒中取暖，来自Dignity_呱的2022](https://juejin.cn/post/7178669900284559397)\\n\\n [三面：请设计一个虚拟DOM算法吧！](https://juejin.cn/post/7173809965772046350)\\n\\n [Vue3的响应式到底比Vue2优雅在哪](https://juejin.cn/post/7168274276787683341)\\n \\n [开局面试官就让我设计一个路由](https://juejin.cn/post/7170888152461082637)\\n \\n [实战v-model如何绑定多循环表达式(内含原理)](https://juejin.cn/post/7166786222419869732)\\n \\n [靓仔，说一下keep-alive缓存组件后怎么更新及原理？](https://juejin.cn/post/7165675789885636616)\\n\\n [面试官问我watch和computed的区别以及选择？](https://juejin.cn/post/7163447762053251109)\\n \\n [面试官问我new Vue阶段做了什么？](https://juejin.cn/post/7164563220714225695)\\n \\n [多图详解，一次性啃懂原型链（上万字）](https://juejin.cn/post/7010942653915201543)\\n\\n [Vue-Cli3搭建组件库](https://juejin.cn/post/6890116253449453575)\\n\\n [Vue实现动态路由（和面试官吹项目亮点）](https://juejin.cn/post/6872344841293037582)\\n\\n [VuePress搭建项目组件文档](https://juejin.cn/post/6854573219773415437)\\n\\n\\n\\n\\n\\n## 原文链接\\n\\n[https://juejin.cn/post/7186459084303335481/](https://juejin.cn/post/7186459084303335481/)\\n\\n\\n\\n\\n\\n\\n",
        "tags": [
            "前端",
            "人工智能",
            "Vue.js"
        ]
    },
    {
        "article_id": "7152404093632249893",
        "cover_image": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/adacad17066346bf96cc011610c975bb~tplv-k3u1fbpfcp-watermark.image?",
        "title": "啥,要我前端去对接外部?我也不会呀",
        "brief": "我正在参加「掘金·启航计划」 一般来说，现在公司的业务都是后端去对接外部官方接口。但是现在加个紧急需求，往我这丢了几个对接文档，让前端去对接，我内心也是打咩。",
        "user_name": "小杨不睡了",
        "view_count": 8821,
        "collect_count": 133,
        "comment_count": 14,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/df428c807d0a62df0df7c42173136d3f~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: smartblue\\n---\\n我正在参加「掘金·启航计划」\\n> 一般来说，现在公司的业务都是后端去对接外部官方接口。但是现在加个紧急需求，往我这丢了几个对接文档，让前端去对接，我内心也是打咩。\\n\\n### 一、梳理开发对接流程\\n1. 大概预览一遍对接文档，发现是需要引入外部提供给的js文件，然后再调用特定方法名通过jsonp的形式与外部联调。\\n2. 因为调用特定方法需要提供域名给对方备案，这样才能权限调起接口。业务这边上报了几个域名给对方，但是问题来了，本地要这么联调呢？ 我%x#！@#&*，我也没做过哇，只能查资料开始准备工作。\\n\\n### 二、准备工作\\n#### 1. 首先需要将本地的访问都修改伪装成报备的域名。那要怎么做呢？了解修改hots文件就可以实现，那么开始动手。\\n1.1 首先找到hots文件，windows它路径一般是在C:\\\\Windows\\\\System32\\\\drivers\\\\etc，如下图\\n![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c7a55176dbde48748cae959e781eb0c3~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n\\n1.2 打开hots文件，添加解析。把本地访问指向后面报备的域名。（域名可以不用加协议，我这里报备的是https的域名）\\n\\n![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/848d197a1f53419ca648fb811b3172f6~tplv-k3u1fbpfcp-zoom-1.image)\\n#### 2. 运行项目。\\n2.1 一开始只在vue.config.js配置了端口，在通过命令跑起项目\\n```javascript\\nmodule.exports = {\\n  devServer: {\\n    port: 9012,\\n  },\\n}\\n```\\n\\n![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d38899fb94a347389019a569d674218f~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n2.2 复制ip链接，浏览器打开，会出现资源加载不到的问题\\n\\n![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1cdfcd8a99924deb9b293d06b10e8a0f~tplv-k3u1fbpfcp-zoom-1.image)\\n2.3  替换成配置hots里面的域名，会发现项目无法运行\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f990c3fc02974acc8aa47e4d50853548~tplv-k3u1fbpfcp-watermark.image?)\\n想起来报备配置的域名是https，所以vue.config.js里面随便写的port端号号是不行的，因为https默认端口号是443。\\n2.4 修改端口号为443，并且开启https服务，重跑项目\\n```javascript\\nmodule.exports = {\\n  devServer: {\\n    https: true,\\n    port: 443,\\n  },\\n}\\n```\\n出现以下提示，点击立即前往就行\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/455985a96a0f4779b809e601be4bdfa7~tplv-k3u1fbpfcp-watermark.image?)\\n2.5 进入页面却又会提示以下错误，搜索发现可以配置vue.config.js解决\\n\\n![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33314fa1e7ac404d83e2b59981b7f958~tplv-k3u1fbpfcp-zoom-1.image)\\n添加配置\\n\\n```javascript\\nmodule.exports = {\\n  devServer: {\\n    https: true,\\n    port: 443,\\n    disableHostCheck: true,\\n  },\\n}\\n```\\n> 如果上面这种方案不行可以替换成下面这种：\\n> 在webpack 5 中disableHostCheck应该被遗弃了\\n查看文档了解到需将 disableHostCheck:true\\n替换为\\nhistoryApiFallback: true,\\nallowedHosts: “all”,\\n```javascript\\nmodule.exports = {\\n  devServer: {\\n    https: true,\\n    port: 443,\\n    historyApiFallback: true,\\n    allowedHosts: \\\"all\\\",\\n  },\\n}\\n```\\n2.6 重跑项目,发现已经是可以进入页面了\\n![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8d2f42579dd43ae9940614c3da8b968~tplv-k3u1fbpfcp-zoom-1.image)\\n#### 3.开始对接\\n3.1 在idnex.html引入文档提供的外部js\\n\\n![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/694b2c651d5a46569d8ad3ee5b0e2dd3~tplv-k3u1fbpfcp-zoom-1.image)\\n3.2 打开控制台发现以下错误\\n\\n![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1274922b8fbe47079416ebf29bb137b9~tplv-k3u1fbpfcp-zoom-1.image)\\n>搜索了解到:https地址中，如果加载了http资源，浏览器将认为这是不安全的资源，将会默认阻止，这就会给你带来资源不全的问题了，比如：图片显示不了，样式加载不了，JS加载不了。\\n>\\n**解决**:. 在index.html页面中加入（meta）头中添加upgrade-insecure-requests\\n```javascript\\n<meta http-equiv=\\\"Content-Security-Policy\\\" content=\\\"upgrade-insecure-requests\\\">\\n```\\n3.3 刷新页面,会发现调用特定方法成功\\n\\n![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bcd0441273d04a749bd2f28964fa208b~tplv-k3u1fbpfcp-zoom-1.image)\\n#### 4. 到此就可以开始写页面对接其他接口了。\\n\\n \\n",
        "tags": [
            "前端",
            "Vue.js",
            "JavaScript"
        ]
    },
    {
        "article_id": "7156957907890733063",
        "cover_image": "",
        "title": "从 0 搭建 Vite 3 + Vue 3 前端工程化项目",
        "brief": "前言 Vue 3 正式版已经发布有一段时间了，随着 Vite 脚手架注定成为下一代前端工具链，许多用户都想基于 Vite 来构建 Vue 项目，如果想基于 Vite 构建 Vue 3 项目，社区模板完",
        "user_name": "威廉王子",
        "view_count": 5853,
        "collect_count": 311,
        "comment_count": 32,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/e45c85bfcd55b999085c64af7a0f2654~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: channing-cyan\\n---\\n\\n# 前言\\n\\nVue 3 正式版已经发布有一段时间了，随着 Vite 脚手架注定成为下一代前端工具链，许多用户都想基于 Vite 来构建 Vue 项目，如果想基于 Vite 构建 Vue 3 项目，社区模板完全满足您的需求，如果想构建 Vite 3 + Vue 3 + JavaScript 项目，那社区模板不太能满足您的需求，因为社区模板提供 Vue 3 项目几乎是基于 Vite 2 + TypeScript 构建，对于不熟悉 TypeScript 语言的用户不是很友好，因此接下来从 0 开始手把手带大家搭建一套规范的 Vite 3 + Vue 3 + JavaScript 前端工程化项目环境。\\n\\n本文章篇幅较长，从以下几个方面展开：\\n\\n- 基础搭建\\n- 代码规范\\n- 提交规范\\n- 自动部署\\n\\n> 本项目完整代码托管在 [GitHub 仓库](https://github.com/ElanYoung/vite-vue-js-starter-template)，欢迎点亮小星星 🌟🌟\\n\\n# 技术栈\\n\\n+ ⚡️ [Vite 3](https://cn.vitejs.dev) - 构建工具（就是快！）\\n+ 🖖 [Vue 3](https://cn.vuejs.org) - 渐进式 JavaScript 框架\\n+ 🚦 [Vue Router](https://router.vuejs.org/zh) - 官方路由管理器\\n+ 📦 [Pinia](https://pinia.vuejs.org/zh) - 值得你喜欢的 Vue Store\\n+ 💻 [TDesign](https://tdesign.tencent.com/vue-next/getting-started) - TDesign 适配桌面端的组件库\\n+ 🎨 [Less](https://less.bootcss.com/) - CSS 预处理器\\n+ 🔗 [Axios](https://axios-http.com/zh/) - 一个基于 promise 的网络请求库，可以用于浏览器和 node.js\\n+ 🧰 [Husky](https://typicode.github.io/husky/#/) + [Lint-Staged](https://github.com/okonet/lint-staged) - Git Hook 工具\\n+ 🛡️ [EditorConfig](http://editorconfig.org) + [ESLint](http://eslint.cn) + [Prettier](https://prettier.cn) + [Stylelint](https://stylelint.cn) - 代码规范\\n+ 🔨 [Commitizen](https://cz-git.qbb.sh/zh) + [Commitlint](https://commitlint.js.org) - 提交规范\\n+ 💡 [GitHub Actions](https://docs.github.com/cn/actions/learn-github-actions) - 自动部署\\n\\n# 基础搭建\\n\\n## 构建项目雏形\\n\\n确保你安装了最新版本的 [Node.js](https://nodejs.org/)，然后在命令行中运行以下命令：\\n\\n```bash\\n# npm 6.x\\nnpm create vite@latest vite-vue-js-template --template vue\\n\\n# npm 7+, extra double-dash is needed:\\nnpm create vite@latest vite-vue-js-template -- --template vue\\n\\n# yarn\\nyarn create vite vite-vue-js-template --template vue\\n\\n# pnpm\\npnpm create vite vite-vue-js-template --template vue\\n```\\n\\n这一指令将会安装并执行 [create-vite](https://github.com/vitejs/vite/tree/main/packages/create-vite)，它是一个基本模板快速启动项目工具。\\n\\n![初始化项目](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be38346077c94795825caabf915ab287~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n在项目被创建后，通过以下步骤安装依赖并启动开发服务器：\\n\\n```bash\\n# 打开项目\\ncd <your-project-name>\\n\\n# 安装依赖\\nnpm install\\n\\n# 启动项目\\nnpm run dev\\n```\\n\\n![启动项目](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e366d4bdf71d43af89da642069ac0485~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n## Vite 基础配置\\n\\nVite 配置文件 `vite.config.js` 位于项目根目录下，项目启动时会自动读取。\\n\\n本项目针对公共基础路径、自定义路径别名、服务器选项、构建选项等做了如下基础配置：\\n\\n```js\\nimport { defineConfig } from 'vite';\\nimport { resolve } from 'path';\\nimport vue from '@vitejs/plugin-vue';\\n\\nexport default defineConfig({\\n    base: './',\\n    plugins: [\\n      vue(),\\n    ],\\n    resolve: {\\n      alias: {\\n        '@': resolve(__dirname, './src') ,\\n      },\\n    },\\n    server: {\\n      // 是否开启 https\\n      https: false,\\n      // 端口号\\n      port: 3000,\\n      // 监听所有地址\\n      host: '0.0.0.0',\\n      // 服务启动时是否自动打开浏览器\\n      open: true,\\n      // 允许跨域\\n      cors: true,\\n      // 自定义代理规则\\n      proxy: {},\\n    },\\n    build: {\\n      // 设置最终构建的浏览器兼容目标\\n      target: 'es2015',\\n      // 构建后是否生成 source map 文件\\n      sourcemap: false,\\n      //  chunk 大小警告的限制（以 kbs 为单位）\\n      chunkSizeWarningLimit: 2000,\\n      // 启用/禁用 gzip 压缩大小报告\\n      reportCompressedSize: false,\\n    },\\n});\\n```\\n\\n关于 Vite 更多配置项及用法，请查看 Vite 官网 [vitejs.dev/config/](https://cn.vitejs.dev/config/) 。\\n\\n## 规范目录结构\\n\\n```\\n├── dist/\\n└── src/\\n    ├── api/                       // 接口请求目录\\n    ├── assets/                    // 静态资源目录\\n    ├── common/                    // 通用类库目录\\n    ├── components/                // 公共组件目录\\n    ├── router/                    // 路由配置目录\\n    ├── store/                     // 状态管理目录\\n    ├── style/                     // 通用样式目录\\n    ├── utils/                     // 工具函数目录\\n    ├── views/                     // 页面组件目录\\n    ├── App.vue\\n    ├── main.js\\n├── tests/                         // 单元测试目录\\n├── index.html\\n├── jsconfig.json                  // JavaScript 配置文件\\n├── vite.config.js                 // Vite 配置文件\\n└── package.json\\n```\\n\\n## 集成 Vue Router 路由工具\\n\\n### 安装依赖\\n\\n```bash\\nnpm i vue-router@4\\n```\\n\\n### 创建路由配置文件\\n\\n在 `src/router` 目录下新建 `index.js` 文件与 `modules` 文件夹\\n\\n```\\n└── src/\\n    ├── router/\\n    \\t├── modules/  // 路由模块\\n        ├── index.js  // 路由配置文件\\n```\\n\\n关于路由表，建议根据功能的不同来拆分到 `modules` 文件夹中，好处是：\\n\\n+ 方便后期维护\\n\\n+ 减少 Git 合并代码冲突可能性\\n\\n```js\\nexport default [\\n  {\\n    path: '/',\\n    name: 'home',\\n    component: () => import('@/views/HomeView.vue'),\\n  },\\n  {\\n    path: '/about',\\n    name: 'about',\\n    component: () => import('@/views/AboutView.vue'),\\n  },\\n];\\n```\\n\\n```js\\nimport { createRouter, createWebHistory } from 'vue-router';\\n\\nimport baseRouters from './modules/base';\\n\\nconst routes = [...baseRouters];\\n\\nconst router = createRouter({\\n  history: createWebHistory(import.meta.env.BASE_URL),\\n  routes,\\n  scrollBehavior() {\\n    return {\\n      el: '#app',\\n      top: 0,\\n      behavior: 'smooth',\\n    };\\n  },\\n});\\n\\nexport default router;\\n```\\n\\n根据路由配置的实际情况，需要在 `src` 下创建 `views` 目录，用来存储页面组件。\\n\\n### 挂载路由配置\\n\\n在 `main.js` 文件中挂载路由配置\\n\\n```js\\nimport { createApp } from 'vue';\\n\\nimport App from './App.vue';\\nimport router from './router';\\n\\ncreateApp(App).use(router).mount('#app');\\n```\\n\\n## 集成 Pinia 全局状态管理工具\\n\\n### 安装依赖\\n\\n```bash\\nnpm i pinia\\n```\\n\\n### 创建仓库配置文件\\n\\n在 `src/store` 目录下新建 `index.js` 文件与 `modules` 文件夹\\n\\n```\\n└── src/\\n    ├── store/\\n    \\t├── modules/  // 仓库模块\\n        ├── index.js  // 仓库配置文件\\n```\\n\\n```js\\nimport { defineStore } from 'pinia';\\n\\nexport const useCounterStore = defineStore('counter', {\\n  state: () => ({\\n    count: 1,\\n  }),\\n  actions: {\\n    accumulate() {\\n      this.count++;\\n    },\\n  },\\n});\\n```\\n\\n```js\\nimport { createPinia } from 'pinia';\\n\\nconst store = createPinia();\\n\\nexport default store;\\n\\nexport * from './modules/counter';\\n```\\n\\n开发中需要将不同功能所对应的状态，拆分到不同的 `modules`，好处如同路由模块一样。\\n\\n### 挂载 Pinia 配置\\n\\n在 `main.js` 文件中挂载 `Vuex` 配置\\n\\n```js\\nimport { createApp } from 'vue';\\n\\nimport App from './App.vue';\\nimport store from './store';\\nimport router from './router';\\n\\ncreateApp(App).use(router).use(store).mount('#app');\\n```\\n\\n## 集成 TDesign Vue Next 组件库\\n\\n### 安装依赖\\n\\n```bash\\nnpm i tdesign-vue-next\\n```\\n\\n### 基础使用\\n\\n```js\\nimport { createApp } from 'vue';\\n\\nimport TDesign from 'tdesign-vue-next';\\n\\n// 引入组件库全局样式资源\\nimport 'tdesign-vue-next/es/style/index.css';\\n\\nconst app = createApp(App);\\napp.use(TDesign);\\n```\\n\\n### 按需引入\\n\\n使用 `unplugin-vue-components` 和 `unplugin-auto-import` 来实现自动导入：\\n\\n```bash\\nnpm install unplugin-vue-components unplugin-auto-import -D\\n```\\n\\n在 Vite 对应的配置文件 `vite.config.js` 添加上述插件：\\n\\n```js\\nimport AutoImport from 'unplugin-auto-import/vite';\\nimport Components from 'unplugin-vue-components/vite';\\nimport { TDesignResolver } from 'unplugin-vue-components/resolvers';\\n\\nexport default {\\n  plugins: [\\n    AutoImport({\\n      resolvers: [TDesignResolver({\\n        library: 'vue-next'\\n      })],\\n    }),\\n    Components({\\n      resolvers: [TDesignResolver({\\n        library: 'vue-next'\\n      })],\\n    }),\\n  ],\\n};\\n```\\n\\n## 集成 Axios HTTP 工具\\n\\n### 安装依赖\\n\\n```bash\\nnpm i axios\\n```\\n\\n### 请求配置\\n\\n在 `utils` 目录下创建 `request.js` 文件，配置好适合自己业务的请求拦截和响应拦截：\\n\\n```\\n└── src/\\n    ├── api  // 接口\\n    ├── utils/\\n        ├── request.js  // axios 请求库二次封装\\n```\\n\\n```js\\nimport axios from 'axios';\\n\\n// 创建请求实例\\nconst instance = axios.create({\\n  baseURL: '/api',\\n  // 指定请求超时的毫秒数\\n  timeout: 1000,\\n  // 表示跨域请求时是否需要使用凭证\\n  withCredentials: false,\\n});\\n\\n// 前置拦截器（发起请求之前的拦截）\\ninstance.interceptors.request.use(\\n  (config) => {\\n    /**\\n     * 在这里一般会携带前台的参数发送给后台，比如下面这段代码：\\n     * const token = getToken()\\n     * if (token) {\\n     *  config.headers.token = token\\n     * }\\n     */\\n    return config;\\n  },\\n  (error) => {\\n    return Promise.reject(error);\\n  },\\n);\\n\\n// 后置拦截器（获取到响应时的拦截）\\ninstance.interceptors.response.use(\\n  (response) => {\\n    /**\\n     * 根据你的项目实际情况来对 response 和 error 做处理\\n     * 这里对 response 和 error 不做任何处理，直接返回\\n     */\\n    return response;\\n  },\\n  (error) => {\\n    const { response } = error;\\n    if (response && response.data) {\\n      return Promise.reject(error);\\n    }\\n    const { message } = error;\\n    console.error(message);\\n    return Promise.reject(error);\\n  },\\n);\\n\\n// 导出常用函数\\n\\n/**\\n * @param {string} url\\n * @param {object} data\\n * @param {object} params\\n */\\nexport const post = (url, data = {}, params = {}) => {\\n  return instance({\\n    method: 'post',\\n    url,\\n    data,\\n    params,\\n  });\\n};\\n\\n/**\\n * @param {string} url\\n * @param {object} params\\n */\\nexport const get = (url, params = {}) => {\\n  return instance({\\n    method: 'get',\\n    url,\\n    params,\\n  });\\n};\\n\\n/**\\n * @param {string} url\\n * @param {object} data\\n * @param {object} params\\n */\\nexport const put = (url, data = {}, params = {}) => {\\n  return instance({\\n    method: 'put',\\n    url,\\n    params,\\n    data,\\n  });\\n};\\n\\n/**\\n * @param {string} url\\n * @param {object} params\\n */\\nexport const _delete = (url, params = {}) => {\\n  return instance({\\n    method: 'delete',\\n    url,\\n    params,\\n  });\\n};\\n\\nexport default instance;\\n```\\n\\n之后在 `api` 文件夹中以业务模型对接口进行拆分，举个例子，将所有跟用户相关接口封装在 `User` 类中，此类称作用户模型。\\n\\n在 `User` 类中比如有登录、注册、获取用户信息等方法，如果有业务逻辑变动，只需要修改相关方法即可。\\n\\n```js\\nimport { post } from '@/utils/request';\\n\\nexport default class User {\\n  /**\\n   * 登录\\n   * @param {String} username 用户名\\n   * @param {String} password 密码\\n   * @returns\\n   */\\n  static async login(username, password) {\\n    return post('/login', {\\n      username,\\n      password,\\n    });\\n  }\\n}\\n```\\n\\n把每个业务模型独立成一个 js 文件，声明一个类通过其属性和方法来实现这个模型相关的数据获取，这样可以大大提升代码的可读性与可维护性。\\n\\n### 模拟演示\\n\\n在需要使用接口的地方，引入对应的业务模型文件，参考如下：\\n\\n```html\\n<script>\\nimport User from '@/api/user';\\n\\nexport default {\\n  data() {\\n    return {\\n      username: '',\\n      password: '',\\n    };\\n  },\\n  methods: {\\n    async login() {\\n      const res = await User.login(this.username, this.password);\\n      console.log(res);\\n    },\\n  },\\n};\\n</script>\\n```\\n\\n## 集成 CSS 预处理器 Less\\n\\n本项目使用 CSS 预处理器 Less，直接安装为开发依赖即可。\\n\\nVite 内部已帮我们集成了相关的 `loader`，不需要额外配置。\\n\\n### 安装依赖\\n\\n```bash\\nnpm i less -D\\n```\\n\\n### 如何使用\\n\\n在 `<style></style>` 样式标签中引用 `lang=\\\"less\\\"` 即可。\\n\\n```html\\n<style lang=\\\"less\\\"></style>\\n```\\n\\n> CSS 命名规范推荐 BEM 命名规范\\n>\\n> 参考链接：[CSS BEM 书写规范](https://github.com/Tencent/tmt-workflow/wiki/%E2%92%9B-%5B%E8%A7%84%E8%8C%83%5D--CSS-BEM-%E4%B9%A6%E5%86%99%E8%A7%84%E8%8C%83)\\n\\n### 全局样式\\n\\n在 `src/style` 目录下创建 `variables.less` 全局样式文件：\\n\\n```\\n└── src/\\n    ├── style/\\n        ├── variables.less  // 全局样式文件\\n```\\n\\n在 `vite.config.js` 配置文件中新增CSS 预处理器相关配置即可实现 less 全局样式：\\n\\n```js\\nimport { resolve } from 'path';\\n\\nexport default defineConfig({\\n    css: {\\n      preprocessorOptions: {\\n        less: {\\n          modifyVars: {\\n            hack: `true; @import (reference) \\\"${resolve('src/style/variables.less')}\\\";`,\\n          },\\n          math: 'strict',\\n          javascriptEnabled: true,\\n        },\\n      },\\n    },\\n});\\n```\\n\\n### 样式穿透\\n\\n[官方文档](https://vuejs.org/api/sfc-css-features.html#scoped-css)\\n\\n在 Vue3 中，改变了以往样式穿透的语法，如果继续使用 `::v-deep`、`/deep/`、`>>>` 等语法的话，会出现一个警告，下面是新的语法：\\n\\n```css\\n/* 深度选择器 */\\n:deep(selector) {\\n  /* ... */\\n}\\n\\n/* 插槽选择器 */\\n:slotted(selector) {\\n  /* ... */\\n}\\n\\n/* 全局选择器 */\\n:global(selector) {\\n  /* ... */\\n}\\n```\\n\\n至此，一个基于 JavaScript + Vite3 + Vue3 + Vue Router + Pinia + Axios + Less 的前端项目开发环境搭建完毕。\\n\\n项目托管在 [GitHub 仓库](https://github.com/ElanYoung/vite-vue-js-starter-template)，需要的同学可以去下载下来，参考学习。\\n\\n接下来增加代码规范约束、提交规范约束、单元测试、自动部署等，让其更完善、更健壮。\\n\\n# 代码规范\\n\\n随着前端应用逐渐变得大型化和复杂化，在同一个项目中有多个人员参与时，每个人的前端能力程度不等，他们往往会用不同的编码风格和习惯在项目中写代码，长此下去，势必会让项目的健壮性越来越差。解决这些问题，理论上讲，口头约定和代码审查都可以，但是这种方式无法实时反馈，而且沟通成本过高，不够灵活，更关键的是无法把控。不以规矩，不能成方圆，我们不得不在项目使用一些工具来约束代码规范。\\n\\n本文讲解如何使用 **EditorConfig + ESLint + Prettier + Stylelint** 组合来实现代码规范化。\\n\\n这样做带来好处：\\n\\n- 解决团队之间代码不规范导致的可读性差和可维护性差的问题。\\n- 解决团队成员不同编辑器导致的编码规范不统一问题。\\n- 提前发现代码风格问题，给出对应规范提示，及时修复。\\n- 减少代码审查过程中反反复复的修改过程，节约时间。\\n- 自动格式化，统一编码风格，从此和脏乱差的代码说再见。\\n\\n## 集成 EditorConfig 配置\\n\\n[EditorConfig](https://editorconfig.org/) 主要用于统一不同 IDE 编辑器的编码风格。\\n\\n在项目根目录下添加 `.editorconfig` 文件：\\n\\n```\\n# 表示是最顶层的 EditorConfig 配置文件\\nroot = true\\n\\n# 表示所有文件适用\\n[*]\\n# 缩进风格（tab | space）\\nindent_style = space\\n# 控制换行类型(lf | cr | crlf)\\nend_of_line = lf\\n# 设置文件字符集为 utf-8\\ncharset = utf-8\\n# 去除行首的任意空白字符\\ntrim_trailing_whitespace = true\\n# 始终在文件末尾插入一个新行\\ninsert_final_newline = true\\n\\n# 表示仅 md 文件适用以下规则\\n[*.md]\\nmax_line_length = off\\ntrim_trailing_whitespace = false\\n\\n# 表示仅 ts、js、vue、css 文件适用以下规则\\n[*.{ts,js,vue,css}]\\nindent_size = 2\\n```\\n\\n> 很多 IDE 中会默认支持此配置，但是也有些不支持，如：VSCode、Atom、Sublime Text 等。\\n> \\n> 具体列表可以参考官网，如果在 VSCode 中使用需要安装 `EditorConfig for VS Code` 插件。\\n\\n![EditorConfig for VS Code](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/667956e2c9e44b9c85d2e0128a7921dc~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n## 集成 ESLint 配置\\n\\n[ESLint](http://eslint.cn/) 是针对 EScript 的一款代码检测工具，它可以检测项目中编写不规范的代码，如果写出不符合规范的代码会被警告。\\n\\n由此我们就可以借助于 ESLint 强大的功能来统一团队的编码规范。\\n\\n### 安装依赖\\n\\n- [`ESLint`](https://github.com/eslint/eslint) - ESLint 本体\\n- [`eslint-define-config`](https://github.com/Shinigami92/eslint-define-config) - 改善 ESLint 规范编写体验\\n- [`eslint-plugin-vue`](https://github.com/vuejs/eslint-plugin-vue) - 适用于 Vue 文件的 ESLint 插件\\n- [`eslint-config-airbnb-base`](https://github.com/airbnb/javascript/tree/master/packages/eslint-config-airbnb-base) - Airbnb JavaScript 风格指南\\n- [`eslint-plugin-import`](https://github.com/import-js/eslint-plugin-import) - 使用 `eslint-config-airbnb-base` 时必须安装的前置插件\\n- [`vue-eslint-parser`](https://github.com/vuejs/vue-eslint-parser) - 使用 `eslint-plugin-vue` 时必须安装的 ESLint 解析器\\n\\n```bash\\nnpm i eslint eslint-define-config eslint-config-airbnb-base eslint-plugin-import eslint-plugin-vue vue-eslint-parser -D\\n```\\n\\n### 安装插件\\n\\nVisual Studio Code 编辑器使用 `ESLint` 配置需要下载插件 **ESLint** 。\\n\\n![ESLint](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/90f4ff512ca24962a95645c56dc7834b~tplv-k3u1fbpfcp-zoom-1.image)\\n\\nJetBrains 系列编辑器（WebStorm、IntelliJ IDEA 等）则不用额外安装插件。\\n\\n### 创建 ESLint 配置文件\\n\\n在项目根目录创建 `.eslintrc.js` 文件，并填入以下内容：\\n\\n```javascript\\nconst { defineConfig } = require('eslint-define-config');\\n\\nmodule.exports = defineConfig({\\n  root: true,\\n  env: {\\n    browser: true,\\n    node: true,\\n    jest: true,\\n    es6: true,\\n  },\\n  plugins: ['vue'],\\n  parser: 'vue-eslint-parser',\\n  parserOptions: {\\n    ecmaVersion: 'latest',\\n    sourceType: 'module',\\n    allowImportExportEverywhere: true,\\n    ecmaFeatures: {\\n      jsx: true,\\n    },\\n  },\\n  extends: [\\n    'eslint-config-airbnb-base',\\n    'eslint:recommended',\\n    'plugin:vue/vue3-essential',\\n    'plugin:vue/vue3-recommended',\\n    'plugin:prettier/recommended',\\n  ],\\n  rules: {\\n    // 禁止使用多余的包\\n    'import/no-extraneous-dependencies': 0,\\n    // 确保在导入路径内一致使用文件扩展名\\n    'import/extensions': 0,\\n    // 确保导入指向可以解析的文件/模块\\n    'import/no-unresolved': 0,\\n    // 首选默认导出导入/首选默认导出\\n    'import/prefer-default-export': 0,\\n    // 要求使用 let 或 const 而不是 var\\n    'no-var': 'error',\\n    // 禁止使用 new 以避免产生副作用\\n    'no-new': 1,\\n    // 禁止变量声明与外层作用域的变量同名\\n    'no-shadow': 0,\\n    // 禁用 console\\n    'no-console': 0,\\n    // 禁止标识符中有悬空下划线\\n    'no-underscore-dangle': 0,\\n    // 禁止在可能与比较操作符相混淆的地方使用箭头函数\\n    'no-confusing-arrow': 0,\\n    // 禁用一元操作符 ++ 和 --\\n    'no-plusplus': 0,\\n    // 禁止对 function 的参数进行重新赋值\\n    'no-param-reassign': 0,\\n    // 禁用特定的语法\\n    'no-restricted-syntax': 0,\\n    // 禁止在变量定义之前使用它们\\n    'no-use-before-define': 0,\\n    // 禁止直接调用 Object.prototypes 的内置属性\\n    'no-prototype-builtins': 0,\\n    // 禁止可以在有更简单的可替代的表达式时使用三元操作符\\n    'no-unneeded-ternary': 'error',\\n    // 禁止重复模块导入\\n    'no-duplicate-imports': 'error',\\n    // 禁止在对象中使用不必要的计算属性\\n    'no-useless-computed-key': 'error',\\n    // 禁止不必要的转义字符\\n    'no-useless-escape': 0,\\n    // 禁用 continue 语句\\n    'no-continue': 0,\\n    // 强制使用一致的缩进\\n    indent: ['error', 2, { SwitchCase: 1 }],\\n    // 强制使用骆驼拼写法命名约定\\n    camelcase: 0,\\n    // 强制类方法使用 this\\n    'class-methods-use-this': 0,\\n    // 要求构造函数首字母大写\\n    'new-cap': 0,\\n    // 强制一致地使用 function 声明或表达式\\n    'func-style': 0,\\n    // 强制一行的最大长度\\n    'max-len': 0,\\n    // 要求 return 语句要么总是指定返回的值，要么不指定\\n    'consistent-return': 0,\\n    // 强制switch要有default分支\\n    'default-case': 2,\\n    // 强制剩余和扩展运算符及其表达式之间有空格\\n    'rest-spread-spacing': 'error',\\n    // 要求使用 const 声明那些声明后不再被修改的变量\\n    'prefer-const': 'error',\\n    // 强制箭头函数的箭头前后使用一致的空格\\n    'arrow-spacing': 'error',\\n    // 只强制对象解构，不强制数组解构\\n    'prefer-destructuring': ['error', { object: true, array: false }],\\n  },\\n});\\n```\\n\\n> 关于更多配置项信息，请前往 ESLint 官网查看 [ESLint-Configuring](http://eslint.cn/docs/user-guide/configuring) \\n\\n### 创建 ESLint 过滤规则\\n\\n在项目根目录添加一个 `.eslintignore` 文件，内容如下：\\n\\n```\\ndist\\nnode_modules\\n!.prettierrc.js\\ncomponents.d.ts\\nauto-imports.d.ts\\n```\\n\\n## 集成 Prettier 配置\\n\\n[Prettier](https://prettier.io) 是一款强大的代码格式化工具，支持 JavaScript、TypeScript、CSS、SCSS、Less、JSX、Angular、Vue、GraphQL、JSON、Markdown 等语言，基本上前端能用到的文件格式它都可以搞定，是当下最流行的代码格式化工具。\\n\\n### 安装依赖\\n\\n```bash\\nnpm i prettier -D\\n```\\n\\n### 安装插件\\n\\nVisual Studio Code 编辑器使用 `Prettier` 配置需要下载插件 **Prettier - Code formatter** 。\\n\\n![Prettier - Code formatter](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/53c405a237e7466fa48eda44a58499b8~tplv-k3u1fbpfcp-zoom-1.image)\\n\\nJetBrains 系列编辑器（WebStorm、IntelliJ IDEA 等）则不用额外安装插件，可直接使用 `Prettier` 配置。\\n\\n### 创建 Prettier 配置文件\\n\\nPrettier 支持多种格式的[配置文件](https://prettier.io/docs/en/configuration.html)，比如 `.json`、`.yml`、`.yaml`、`.js`等。\\n\\n在项目根目录创建 `.prettierrc.js` 文件，并填入以下内容：\\n\\n```javascript\\nmodule.exports = {\\n  // 一行最多 120 字符\\n  printWidth: 120,\\n  // 使用 2 个空格缩进\\n  tabWidth: 2,\\n  // 不使用缩进符，而使用空格\\n  useTabs: false,\\n  // 行尾需要有分号\\n  semi: true,\\n  // 使用单引号\\n  singleQuote: true,\\n  // 对象的 key 仅在必要时用引号\\n  quoteProps: 'as-needed',\\n  // jsx 不使用单引号，而使用双引号\\n  jsxSingleQuote: false,\\n  // 末尾需要有逗号\\n  trailingComma: 'all',\\n  // 大括号内的首尾需要空格\\n  bracketSpacing: true,\\n  // jsx 标签的反尖括号需要换行\\n  jsxBracketSameLine: false,\\n  // 箭头函数，只有一个参数的时候，也需要括号\\n  arrowParens: 'always',\\n  // 每个文件格式化的范围是文件的全部内容\\n  rangeStart: 0,\\n  rangeEnd: Infinity,\\n  // 不需要写文件开头的 @prettier\\n  requirePragma: false,\\n  // 不需要自动在文件开头插入 @prettier\\n  insertPragma: false,\\n  // 使用默认的折行标准\\n  proseWrap: 'preserve',\\n  // 根据显示样式决定 html 要不要折行\\n  htmlWhitespaceSensitivity: 'css',\\n  // vue 文件中的 script 和 style 内不用缩进\\n  vueIndentScriptAndStyle: false,\\n  // 换行符使用 lf\\n  endOfLine: 'lf',\\n  // 格式化嵌入的内容\\n  embeddedLanguageFormatting: 'auto',\\n  // html, vue, jsx 中每个属性占一行\\n  singleAttributePerLine: false,\\n};\\n```\\n\\n> 关于更多配置项信息，请前往 Prettier 官网查看 [Prettier-Options](https://prettier.io/docs/en/options.html) \\n\\n### 创建 Prettier 过滤规则\\n\\n在项目根目录添加一个 `.prettierignore` 文件，内容如下：\\n\\n```\\n## OS\\n.DS_Store\\n.idea\\n.editorconfig\\npnpm-lock.yaml\\n.npmrc\\n\\n# Ignored suffix\\n*.log\\n*.md\\n*.svg\\n*.png\\n*.ico\\n*ignore\\n\\n## Local\\n.husky\\n\\n## Built-files\\n.cache\\ndist\\n```\\n\\n## 解决 Prettier 和 ESLint 冲突\\n\\n本项目中的 ESLint 配置使用了 Airbnb JavaScript 风格指南校验，其规则之一是*代码结束后面要加分号*，而在 Prettier 配置文件中加了*代码结束后面不加分号*配置项，从而冲突了。\\n\\n解决两者冲突问题，需要用到 **eslint-plugin-prettier** 和 **eslint-config-prettier**。\\n\\n- `eslint-plugin-prettier` 将 Prettier 的规则设置到 ESLint 的规则中\\n- `eslint-config-prettier` 关闭 ESLint 中与 Prettier 中会发生冲突的规则\\n\\n最后形成优先级：`Prettier 配置规则` > `ESLint 配置规则`\\n\\n### 安装依赖\\n\\n```bash\\nnpm i eslint-plugin-prettier eslint-config-prettier -D\\n```\\n\\n### 修改 ESLint 配置文件\\n\\n修改 `.eslintrc.js` 文件，在 `extends` 中添加 `plugin:prettier/recommended` 规则（此规则一定要加在最后）。\\n\\n```javascript\\nmodule.exports = {\\n  extends: [\\n    'airbnb-base',\\n    'eslint:recommended',\\n    'plugin:vue/vue3-essential',\\n    'plugin:vue/vue3-recommended',\\n    'plugin:prettier/recommended'\\n  ],\\n}\\n```\\n\\n## 自动格式化代码\\n\\nVisual Studio Code 在 `settings.json` 设置文件中，增加以下代码：\\n\\n```json\\n{\\n  \\\"editor.codeActionsOnSave\\\": {\\n    \\\"source.fixAll\\\": true,\\n    \\\"source.fixAll.eslint\\\": true\\n  }\\n}\\n```\\n\\nWebStorm 打开设置窗口，按如下操作，最后点击 `Apply` -> `OK`：\\n\\n![WebStorm](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1313ca0777a348a6a438cbcea3ce096b~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n## 集成 Stylelint 配置\\n\\nStylelint 是一个强大、先进的 CSS 代码检查器（linter），可以帮助你规避 CSS 代码中的错误并保持一致的编码风格。\\n\\n### 安装依赖\\n\\n- [`Stylelint`](https://stylelint.io/) - Stylelint 本体\\n- [`stylelint-less`](https://github.com/ssivanatarajan/stylelint-less) - Stylelint Less 规则\\n- [`stylelint-config-prettier`](https://github.com/prettier/stylelint-config-prettier) - 关闭 Stylelint 中与 Prettier 中会发生冲突的规则\\n- [`stylelint-config-standard`](https://github.com/stylelint/stylelint-config-standard) - Stylelint 官方推荐规则\\n- [`stylelint-config-recess-order`](https://github.com/stormwarning/stylelint-config-recess-order) - 对 CSS 声明进行排序\\n- [`stylelint-order`](https://github.com/hudochenkov/stylelint-order) - CSS 属性顺序规则插件\\n\\n```bash\\nnpm i stylelint stylelint-less stylelint-config-prettier stylelint-config-standard stylelint-config-recess-order stylelint-order -D\\n```\\n\\n### 安装插件\\n\\nVisual Studio Code 编辑器使用 `Stylelint` 配置需要下载插件 **Stylelint** 。\\n\\n![Stylelint](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f07053b53264fe4b2df3d5fecea82e6~tplv-k3u1fbpfcp-zoom-1.image)\\n\\nJetBrains 系列编辑器（WebStorm、IntelliJ IDEA 等）则不用额外安装插件。\\n\\n### 创建 Stylelint 配置文件\\n\\n在项目根目录创建 `.stylelintrc.js` 文件，并填入以下内容：\\n\\n```javascript\\nmodule.exports = {\\n  root: true,\\n  defaultSeverity: 'error',\\n  plugins: ['stylelint-order', 'stylelint-less'],\\n  extends: [\\n    'stylelint-config-standard', // the standard shareable config for Stylelint\\n    'stylelint-config-html/html', // the shareable html config for Stylelint.\\n    'stylelint-config-html/vue', // the shareable vue config for Stylelint.\\n    'stylelint-config-recess-order', // use the clean order for properties\\n    'stylelint-config-prettier', // turn off any rules that conflict with Prettier\\n  ],\\n  rules: {\\n    // 禁止在覆盖高特异性选择器之后出现低特异性选择器\\n    'no-descending-specificity': null,\\n    // 禁止空源码\\n    'no-empty-source': null,\\n    // 禁止字体族中缺少泛型族关键字\\n    'font-family-no-missing-generic-family-keyword': null,\\n    // 禁止未知的@规则\\n    'at-rule-no-unknown': [\\n      true,\\n      {\\n        ignoreAtRules: [\\n          'tailwind',\\n          'apply',\\n          'variants',\\n          'responsive',\\n          'screen',\\n          'function',\\n          'if',\\n          'each',\\n          'include',\\n          'mixin',\\n        ],\\n      },\\n    ],\\n    // 不允许未知函数\\n    'function-no-unknown': null,\\n    // 不允许未知单位\\n    'unit-no-unknown': [true, { ignoreUnits: ['rpx'] }],\\n    // 不允许选择器使用供应商前缀\\n    'selector-no-vendor-prefix': null,\\n    // 指定关键帧名称的模式\\n    'keyframes-name-pattern': null,\\n    // 指定类选择器的模式\\n    'selector-class-pattern': null,\\n    // 不允许值使用供应商前缀\\n    'value-no-vendor-prefix': null,\\n    // 要求或禁止在规则之前的空行\\n    'rule-empty-line-before': ['always', { ignore: ['after-comment', 'first-nested'] }],\\n    // 指定字符串使用单引号\\n    'string-quotes': 'single',\\n    // 指定@规则名的大小写\\n    'at-rule-name-case': 'lower',\\n    // 指定缩进\\n    indentation: [2, { severity: 'warning' }],\\n  },\\n  ignoreFiles: ['**/*.js', '**/*.jsx', '**/*.tsx', '**/*.ts'],\\n};\\n```\\n\\n### 创建 Stylelint 过滤规则\\n\\n在项目根目录添加一个 `.stylelintignore` 文件，内容如下：\\n\\n```plain\\n# .stylelintignore\\n# 旧的不需打包的样式库\\n*.min.css\\n\\n# 其他类型文件\\n*.js\\n*.jpg\\n*.woff\\n\\n# 测试和打包目录\\n/test/\\n/dist/*\\n/public/*\\npublic/*\\n/node_modules/\\n```\\n\\n### 启用 Vue 文件支持\\n\\n`Stylelint` v14 版本默认不支持 vue 文件中的 style 代码自动检测，详情查看[官方迁移指南](https://github.com/stylelint/stylelint/blob/main/docs/migration-guide/to-14.md)\\n\\n#### 安装依赖\\n\\n- [`stylelint-config-html`](https://github.com/ota-meshi/stylelint-config-html) - 解析 vue 文件\\n- [`postcss-html`](https://github.com/ota-meshi/postcss-html) - 使用 `stylelint-config-html` 依赖的模块\\n- [`postcss-less`](https://github.com/shellscape/postcss-less) - 对 less 文件进行解析\\n\\n```bash\\nnpm i stylelint-config-html postcss-html postcss-less -D\\n```\\n\\n#### 修改 Stylelint 配置文件\\n\\n修改 `.stylelintrc.js` 文件，添加如下配置：\\n\\n```javascript\\nmodule.exports = {\\n  overrides: [\\n    {\\n      files: ['*.vue', '**/*.vue', '*.html', '**/*.html'],\\n      customSyntax: 'postcss-html',\\n      rules: {\\n        // 禁止未知的伪类选择器\\n        'selector-pseudo-class-no-unknown': [true, { ignorePseudoClasses: ['deep', 'global'] }],\\n        // 禁止未知的伪元素选择器\\n        'selector-pseudo-element-no-unknown': [true, { ignorePseudoElements: ['v-deep', 'v-global', 'v-slotted'] }],\\n      },\\n    },\\n    {\\n      files: ['*.less', '**/*.less'],\\n      customSyntax: 'postcss-less',\\n      rules: {\\n        'less/color-no-invalid-hex': true,\\n        'less/no-duplicate-variables': true,\\n      },\\n    },\\n  ],\\n};\\n```\\n\\n#### 修改 Visual Studio Code 工作区配置\\n\\nVisual Studio Code 在 `settings.json` 设置文件中，增加以下代码：\\n\\n```json\\n{\\n  \\\"stylelint.validate\\\": [\\\"css\\\", \\\"less\\\", \\\"postcss\\\", \\\"scss\\\", \\\"vue\\\", \\\"sass\\\", \\\"html\\\"]\\n}\\n```\\n\\n## 集成 husky 和 lint-staged\\n\\n在项目中已集成 ESLint 和 Prettier，在编码时，这些工具可以对代码进行实时校验，在一定程度上能有效规范所写代码，但有些人可能觉得这些限制很麻烦，从而选择视“提示”而不见，依旧按自己编程风格来写代码，或者干脆禁用掉这些工具，开发完成就直接把代码提交到了仓库，日积月累，ESLint 也就形同虚设。\\n\\n所以，还需要做一些限制，让没通过 ESLint 检测和修复的代码禁止提交，从而保证仓库代码都是符合规范的。\\n\\n为了解决这个问题，需要用到 Git Hook，在本地执行 `git commit` 的时候，就对所提交的代码进行 ESLint 检测和修复（即执行 `eslint --fix`），如果这些代码没通过 ESLint 规则校验，则禁止提交。\\n\\n实现这一功能，需要借助 [husky](https://github.com/typicode/husky) + [lint-staged](https://github.com/okonet/lint-staged) 。\\n\\n### 配置 husky\\n\\n> 注意：本项目使用 husky 6.x 版本，6.x 版本配置方式跟之前版本有较大差异，当发现配置方法不一致时，一切以 [husky 官网](https://typicode.github.io/husky/#/?id=usage)为准。\\n\\n使用 `husky-init` 命令快速在项目初始化 `husky` 配置：\\n\\n```bash\\n# 初始化仓库\\ngit init\\n\\n# 初始化\\nnpx husky-init\\n\\n# 安装依赖\\nnpm install\\n```\\n\\nhusky 包含很多 `hook`（钩子），常用有：`pre-commit`、`commit-msg`。\\n\\n使用 `pre-commit` 来触发 ESLint 命令，修改 `.husky/pre-commit` 文件触发命令：\\n\\n```bash\\neslint --fix ./src --ext .vue,.js,.ts\\n```\\n\\n`pre-commit` hook 文件作用是：当执行 `git commit -m \\\"xxx\\\"` 时，会先对 `src` 目录下所有的 `.vue`、`.js`、`.ts `文件执行 `eslint --fix` 命令，如果 ESLint 通过，成功 `commit`，否则终止 `commit`。\\n\\n但是又存在一个问题：有时候明明只改动了一两个文件，却要对所有的文件执行 `eslint --fix`。\\n\\n假如这是一个历史项目，在中途配置了 ESLint 规则，那么在提交代码时，也会对其他未修改的“历史”文件都进行检查，可能会造成大量文件出现 ESLint 错误，显然这不是我们想要的结果。\\n\\n所以只需要用 ESLint 修复此次写的代码，而不去影响其他的代码，此时需要借助 **lint-staged** 工具。\\n\\n### 配置 lint-staged\\n\\nlint-staged 一般结合 husky 来使用，它可以让 husky 的 `hook` 触发的命令只作用于 `git` 暂存区的文件，而不会影响到其他文件。\\n\\n#### 安装依赖\\n\\n```bash\\nnpm i lint-staged -D\\n```\\n\\n#### 新增配置\\n\\n在 `package.json` 里增加 `lint-staged` 配置项：\\n\\n```json\\n{\\n  \\\"lint-staged\\\": {\\n    \\\"*.{js,jsx,ts,tsx}\\\": [\\n      \\\"prettier --write\\\",\\n      \\\"eslint --fix\\\"\\n    ],\\n    \\\"*.vue\\\": [\\n      \\\"prettier --write\\\",\\n      \\\"eslint --fix\\\",\\n      \\\"stylelint --fix\\\"\\n    ],\\n    \\\"*.{html,vue,vss,sass,less}\\\": [\\n      \\\"prettier --write\\\",\\n      \\\"stylelint --fix\\\"\\n    ],\\n    \\\"package.json\\\": [\\n      \\\"prettier --write\\\"\\n    ],\\n    \\\"*.md\\\": [\\n      \\\"prettier --write\\\"\\n    ]\\n  },\\n}\\n```\\n\\n#### 修改触发命令\\n\\n修改 `.husky/pre-commit` 文件触发命令为：\\n\\n```shell\\nnpx lint-staged\\n```\\n\\n![pre-commit](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f71e208ff34b48eda618ec44c2a53776~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n经过以上配置之后，就可以在每次提交之前对所有代码进行格式化，保证线上代码的规范性。\\n\\n# 提交规范\\n\\n多人协作项目中，在提交代码环节，也存在一种情况：不能保证每个人对提交信息的准确描述，因此会出现提交信息紊乱、风格不一致的情况。\\n\\n如果 `git commit` 的描述信息精准，在后期维护和 Bug 处理时会变得有据可查，项目开发周期内还可以根据规范的提交信息快速生成开发日志，从而方便我们追踪项目和把控进度。\\n\\n社区最流行、最知名、最受认可的 [Angular](https://github.com/angular) 团队提交规范：\\n\\n![Angular 团队提交规范](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/08e334007edf4bfaad0f5ed4d9e82c2a~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n参考链接： [Angular Style Commit Message Conventions](https://gist.github.com/stephenparish/9941e89d80e2bc58a153)\\n\\n## Commit Message 格式规范\\n\\n`commit message` 由 Header、Body、Footer 组成。\\n\\n```\\n<Header>\\n\\n<Body>\\n\\n<Footer>\\n```\\n\\n### Header\\n\\nHeader 部分包括三个字段 type（必需）、scope（可选）和 subject（必需）。\\n\\n```\\n<type>(<scope>): <subject>\\n```\\n\\n**type**\\n\\ntype 用于说明 commit 的提交类型（必须是以下几种之一）。\\n\\n| 值       | 描述                                                         |\\n| -------- | ------------------------------------------------------------ |\\n| feat     | 新增功能                                                     |\\n| fix      | 修复问题                                                     |\\n| docs     | 文档变更                                                     |\\n| style    | 代码格式（不影响功能，例如空格、分号等格式修正）             |\\n| refactor | 代码重构                                                     |\\n| perf     | 改善性能                                                     |\\n| test     | 测试                                                         |\\n| build    | 变更项目构建或外部依赖（例如 scopes: webpack、gulp、npm 等） |\\n| ci       | 更改持续集成软件的配置文件和 package 中的 scripts 命令，例如 scopes: Travis, Circle 等 |\\n| chore    | 变更构建流程或辅助工具                                       |\\n| revert   | 代码回退                                                     |\\n\\n**scope**\\n\\nscope 用于指定本次 commit 影响的范围。\\n\\nscope 依据项目而定，例如在业务项目中可以依据菜单或者功能模块划分，如果是组件库开发，则可以依据组件划分。\\n\\n**subject**\\n\\nsubject 是本次 commit 的简洁描述，长度约定在 50 个字符以内，通常遵循以下几个规范：\\n\\n- 用动词开头，第一人称现在时表述，例如：change 代替 changed 或 changes\\n- 第一个字母小写\\n- 结尾不加句号（.）\\n\\n### Body\\n\\nbody 是对本次 commit 的详细描述，可以分成多行。\\n\\n跟 subject 类似，用动词开头，body 应该说明修改的原因和更改前后的行为对比。\\n\\n### Footer\\n\\n如果本次提交的代码是突破性的变更或关闭缺陷，则 Footer 必需，否则可以省略。\\n\\n- 突破性的变更\\n\\n  当前代码与上一个版本有突破性改变，则 Footer 以 BREAKING CHANGE 开头，后面是对变动的描述、以及变动的理由。\\n\\n- 关闭缺陷\\n\\n  如果当前提交是针对特定的 issue，那么可以在 Footer 部分填写需要关闭的单个 issue 或一系列 issues。\\n\\n### 参考例子\\n\\n- feat\\n\\n  ```\\n  feat(browser): onUrlChange event (popstate/hashchange/polling)\\n  \\n  Added new event to browser:\\n  - forward popstate event if available\\n  - forward hashchange event if popstate not available\\n  - do polling when neither popstate nor hashchange available\\n  \\n  Breaks $browser.onHashChange, which was removed (use onUrlChange instead)\\n  ```\\n\\n- fix\\n\\n  ```\\n  fix(compile): couple of unit tests for IE9\\n  \\n  Older IEs serialize html uppercased, but IE9 does not...\\n  Would be better to expect case insensitive, unfortunately jasmine does\\n  not allow to user regexps for throw expectations.\\n  \\n  Closes #392\\n  Breaks foo.bar api, foo.baz should be used instead\\n  ```\\n\\n- style\\n\\n  ```\\n  style(location): add couple of missing semi colons\\n  ```\\n\\n- chore\\n\\n  ```\\n  chore(release): v3.4.2\\n  ```\\n\\n## 集成 cz-git 实现规范提交\\n\\n> 一款工程性更强，轻量级，高度自定义，标准输出格式的 [commitizen](https://github.com/commitizen/cz-cli) 适配器\\n>\\n> 官方网站：[cz-git](https://cz-git.qbb.sh/zh/)\\n\\n![cz-git](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/12d9e35b52304043a0ee99b1d0bde6b9~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n### 安装依赖\\n\\n```bash\\nnpm install -D cz-git\\n```\\n\\n### 指定适配器\\n\\n修改 `package.json` 文件，添加 `config` 指定使用的适配器\\n\\n```json\\n{\\n  \\\"scripts\\\": {},\\n  \\\"config\\\": {\\n    \\\"commitizen\\\": {\\n      \\\"path\\\": \\\"node_modules/cz-git\\\"\\n    }\\n  }\\n}\\n```\\n\\n### 自定义配置（可选）\\n\\n**cz-git 与 [commitlint](https://github.com/conventional-changelog/commitlint) 进行联动给予校验信息**，所以可以编写于 [commitlint](https://github.com/conventional-changelog/commitlint#config) 配置文件之中。\\n\\n例如：([⇒ 配置模板](https://cz-git.qbb.sh/zh/config/))\\n\\n```js\\n/** @type {import('cz-git').UserConfig} */\\nmodule.exports = {\\n  extends: ['@commitlint/config-conventional'],\\n  rules: {},\\n  prompt: {\\n    useEmoji: false,\\n    emojiAlign: 'center',\\n    allowCustomIssuePrefixs: false,\\n    allowEmptyIssuePrefixs: false,\\n  },\\n};\\n```\\n\\n本项目配置文件可参考：[commitlint.config.js](https://github.com/ElanYoung/vite-vue-js-starter-template/blob/master/commitlint.config.js)\\n\\n### 全局使用\\n\\n> 全局安装的好处在于：在任何项目下都可以利用 `cz` 或 `git cz` 命令启动命令行工具，生成标准化 commit message\\n\\n#### 安装全局依赖\\n\\n```sh\\nnpm install -g cz-git commitizen\\n```\\n\\n#### 全局配置适配器类型\\n\\n```sh\\necho '{ \\\"path\\\": \\\"cz-git\\\" }' > ~/.czrc\\n```\\n\\n#### 自定义配置（可选）\\n\\n**方式一：** 编辑 `~/.czrc` 文件以 **json** 形式添加配置，例如：\\n\\n```json\\n{\\n  \\\"path\\\": \\\"cz-git\\\",\\n  \\\"useEmoji\\\": true\\n}\\n```\\n\\n**方式二：与 [commitlint](https://github.com/conventional-changelog/commitlint) 配合**，在 `$HOME` 路径下创建配置文件\\n([↓ 配置模板](https://cz-git.qbb.sh/zh/config/))\\n\\n## 集成 commitlint 验证规范提交\\n\\n在“代码规范”章节中提到，尽管制定了规范，但在多人协作的项目中，总有些人依旧我行我素。\\n\\n因此提交代码这个环节，也增加一个限制：**只让符合 Angular 规范的 commit message 通过**。\\n\\n此功能需借助 `@commitlint/config-conventional` 和 `@commitlint/cli` 工具来实现。\\n\\n### 安装\\n\\n- [`@commitlint/cli`](https://commitlint.js.org) - Commitlint 本体\\n- [`@commitlint/config-conventional`](https://github.com/conventional-changelog/commitlint) - 通用提交规范\\n\\n```bash\\nnpm i @commitlint/cli @commitlint/config-conventional -D\\n```\\n\\n### 配置\\n\\n在项目根目录创建 `commitlint.config.js` 文件，并填入以下内容：\\n\\n```js\\nmodule.exports = {\\n  extends: ['@commitlint/config-conventional']\\n}\\n```\\n\\n使用 husky 命令在 `.husky` 目录下创建 `commit-msg` 文件，并在此执行验证命令：\\n\\n```bash\\nnpx husky add .husky/commit-msg \\\"npx --no-install commitlint --edit $1\\\"\\n```\\n\\n![commit-msg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e93e8fcd5324b0f8c01ffc2760c1a25~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n> 本项目完整代码托管在 [GitHub 仓库](https://github.com/ElanYoung/vite-vue-js-starter-template)，欢迎点亮小星星 🌟🌟\\n\\n# 自动部署\\n\\n本章节将介绍如何使用 CI（Continuous Integration 持续集成）服务来完成项目部署工作。\\n\\n常见的 CI 工具有 GitHub Actions、GitLab CI、Travis CI、Circle CI 等。\\n\\n本项目使用 `GitHub Actions` 来完成这一操作。\\n\\n🔗 参考链接：[GitHub Actions 入门教程](https://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html)\\n\\n\\n\\n## 创建 GitHub 仓库\\n\\n因为 GitHub Actions 只对 GitHub 仓库有效，所以[创建 GitHub 仓库](https://github.com/new)来托管项目代码。\\n\\n![创建 GitHub 仓库](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0db35e7ca2974a5bba03dae06bb5f92a~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n- `master` 分支存储项目源代码\\n- `gh-pages` 分支存储打包后的静态文件\\n\\n## 创建 GitHub Token\\n\\n创建一个有 **repo** 和 **workflow** 权限的 [GitHub Token](https://github.com/settings/tokens/new)\\n\\n![创建 GitHub Token](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/faff3548df1f4cf78f8842cf4ae0c7ee~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n> 注意：新生成的 Token 只会显示一次。\\n\\n![Token](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70e367490ae848d8a4e3e47570febe8b~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n## 添加 Actions secret\\n\\n将上述创建的 Token 添加到 GitHub 仓库中的 `Secrets` 里，并将这个新增的 `secret` 命名为 `VITE_VUE_DEPLOY` 。\\n\\n步骤：仓库 -> `Settings` -> `Secrets` -> `Actions` -> `New repository secret`。\\n\\n![New secret](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e5df14de9bd4605a70b654e7d936282~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n> 注意：新创建的 secret `VITE_VUE_DEPLOY` 在 Actions 配置文件中要用到，两个地方需保持一致！\\n\\n## 修改 package.json\\n\\n打开 `package.json` 文件，新增 `homepage` 字段，表示该应用发布后的根目录（参见[官方文档](https://create-react-app.dev/docs/deployment#building-for-relative-paths)）。\\n\\n```json\\n\\\"homepage\\\": \\\"https://[username].github.io/github-actions-demo\\\",\\n```\\n\\n上面代码中，将 `[username]` 替换成你的 GitHub 用户名，参见[范例](https://github.com/ElanYoung/vite-vue-js-starter-template/blob/master/package.json#L11)。\\n\\n## 创建 Actions 配置文件\\n\\n（1）在项目根目录下创建 `.github` 目录。\\n\\n（2）在 `.github` 目录下创建 `workflows` 目录。\\n\\n（3）在 `workflows` 目录下创建 `deploy.yml` 文件。\\n\\n![.github/workflows/deploy.yml](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/01ca2c1f76fa4162971a46297c270a9e~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n```yaml\\nname: Vite Vue Deploy\\n\\non:\\n  push:\\n    # master 分支有 push 时触发\\n    branches: [master]\\n\\njobs:\\n  deploy:\\n    # 指定虚拟机环境\\n    runs-on: ubuntu-latest\\n\\n    strategy:\\n      matrix:\\n        node-version: [14.x, 16.x]\\n\\n    steps:\\n      - name: Checkout\\n        # 拉取 GitHub 仓库代码\\n        uses: actions/checkout@v3\\n\\n      - name: Use Node.js ${{ matrix.node-version }}\\n        # 设定 Node.js 环境\\n        uses: actions/setup-node@v3\\n        with:\\n          node-version: ${{ matrix.node-version }}\\n\\n      - name: Install\\n        # 安装依赖\\n        run: npm install\\n\\n      - name: Build\\n        # 打包\\n        run: npm run build\\n\\n      - name: Deploy\\n        uses: JamesIves/github-pages-deploy-action@v4\\n        with:\\n          # 部署打包目录\\n          folder: dist\\n          # 密钥名\\n          token: ${{ secrets.VITE_VUE_DEPLOY }}\\n          # 分支\\n          branch: gh-pages\\n```\\n\\n> 🔗 通过此链接 [https://ElanYoung.github.io/vite-vue-js-starter-template](https://ElanYoung.github.io/vite-vue-js-starter-template) 即可访问本项目\\n\\n# 文章总结\\n\\n本文从技术选项到架构搭建、从代码规范约束到提交信息规范约束，一步一步带领大家如何从一个最简单的前端项目骨架到规范的前端工程化环境，基本涵盖前端项目开发的整个流程，特别适合刚接触前端工程化的同学学习。\\n\\n因篇幅较长，所涉及技术点较多，难免会出现错误，希望大家多多指正，谢谢大家！\\n\\n# 参考出处\\n\\n- XPoet：[从 0 开始手把手带你搭建一套规范的 Vue3.x 项目工程环境](https://juejin.cn/post/6951649464637636622)",
        "tags": [
            "Vite",
            "Vue.js",
            "前端"
        ]
    },
    {
        "article_id": "7174176729475317791",
        "cover_image": "https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f831c415bb8d4953aa1784502b3b49f3~tplv-k3u1fbpfcp-watermark.image?",
        "title": "常用！提前 reject promise 的 2 种场景，收藏等于学会",
        "brief": "想一想，Promise 如何实现中断？ 讲道理，我们回忆下就知道 Promise 的特性就是：不能中断。 一旦执行，我们无法知道它具体执行到哪里了，只知道在 pending，最后 resolve",
        "user_name": "掘金安东尼",
        "view_count": 3270,
        "collect_count": 59,
        "comment_count": 7,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/4fdb253f3b5bb8d9e875e3dcabea82cb~300x300.image",
        "category": "前端",
        "content": "**想一想，Promise 如何实现提前 reject？**\\n\\n讲道理，我们回忆下就知道 Promise 的特性就是：不能中断。\\n\\n一旦执行，我们无法知道它具体执行到哪里了，只知道在 pending，最后 resolve 或者 reject 才知道执行完毕。\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/11f7e2d8bf514cfa89470e2a6be54823~tplv-k3u1fbpfcp-watermark.image?)\\n\\n但需要提前 reject的这种应用场景也确实是存在的。\\n\\n比如：\\n\\n**1. 点击按钮，发起请求，再点击另外一个按钮，通过提前 reject Promise，不再依赖后续请求；**\\n\\n或\\n\\n**2. 用 Promise 封装异步请求，当超过 N 秒后还未执行完，提前 reject Promise ，执行后续操作；**\\n\\n>**这里的取消请求，并不是撤回 XHR 请求，而是不再需要请求结果，直接执行后面的步骤；**\\n\\n<hr>\\n\\n## p1\\n\\n如何实现？\\n\\n不急，先想想，同步的中断 promise 的情况，它大概是这样的： \\n\\n```\\nfunction someAsyncFunction() {\\n  return new Promise(function(resolve, reject) {\\n    // 在这里执行异步操作\\n    if (/* 某个条件成立 */) {\\n      // 如果条件成立，中断 promise \\n      reject(new Error(\\\"The promise was interrupted\\\"));\\n    }\\n  });\\n}\\n\\nsomeAsyncFunction().catch(function(error) {\\n  // 处理 promise 中断的回调函数\\n  console.error(error.message);\\n});\\n```\\n\\n没什么毛病，如果某个条件成立，reject 错误信息；\\n\\n\\n那么，那对于第一个问题，就很好理解了：\\n\\n>1. 点击按钮，发起请求，再点击另外一个按钮，通过中断 Promise，取消请求；\\n\\n\\n实现步骤拆解：\\n\\n1. 为了方便测试，我们找一个可供在线测试的 API https://jsonplaceholder.typicode.com/posts GET 请求可以直接拿到返回报文；\\n2. 不借助请求库，就用原生 XHR；\\n3. 为了加强模拟效果，我们再用一个 setTimeout 函数，延长成功返回的时间，意思是：请求至少要 10s+ 才会成功返回；\\n4. 写一个全局的 cancelFn 方法，然后在 promise 内部重写它，当调用时，会直接 reject ，便实现了中断；\\n\\n```\\nconst baseURL='https://jsonplaceholder.typicode.com/posts';\\n\\nlet cancelFn=function(){}\\n\\nfunction request(req){\\n\\treturn new Promise((resolve,reject)=>{\\n\\t\\tlet xhr=new XMLHttpRequest();\\n\\t\\txhr.open(req.method || 'GET',baseURL);\\n\\t\\txhr.onload=function(){\\n\\t\\t\\tif(xhr.readyState==4 && (xhr.status>=200 && xhr.status<300)){\\n\\t\\t\\t\\tsetTimeout(()=>{\\n\\t\\t\\t\\t\\tresolve({data:JSON.parse(xhr.responseText)})\\n\\t\\t\\t\\t},10000)\\n\\t\\t\\t}else{\\n\\t\\t\\t\\treject(xhr.status)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\txhr.onerror=function(){\\n\\t\\t\\treject('中断 promise...')\\n\\t\\t}\\n\\t\\txhr.send(req.data || null);\\n\\n\\t\\tcancelFn=function(msg){\\n\\t\\t\\treject({message:msg})\\n\\t\\t}\\n\\t})\\n};\\n\\nlet send=document.querySelector('.send');\\nlet cancel=document.querySelector('.cancel');\\nsend.addEventListener('click',async function(){\\n\\tconsole.log('正在请求中...')\\n\\tlet {data}=await request({})\\n\\tconsole.log(data)\\n});\\ncancel.addEventListener('click',function(){\\n\\tcancelFn('中断 promise');\\n})\\n```\\n\\n可以在码上掘金，打开控制台测测看。\\n\\nhttps://code.juejin.cn/pen/7173900335335866407\\n\\n\\n## p2\\n\\n对于第 2 个问题：\\n\\n>2. 用 Promise 封装异步请求，当超过 N 秒后还未执行完，中断 Promise ，执行后续操作；\\n\\n解决这个问题，用到一个巧思：\\n\\n**Promise.race：**\\n\\n**一旦迭代器中的某个 *promise* 解决或拒绝,返回的 *promise* 就会解决或拒绝。**\\n\\n我们把手动执行的超时中断，和业务逻辑的 prosmie 链条放在一起，超过 N 秒后，调用 cancelFn 方法，在 race 的 **竞争策略** 下，若 N 秒后请求还没返回，则直接 reject 返回，则实现了中断；\\n\\n代码实现：\\n\\n```\\nconst baseURL='https://jsonplaceholder.typicode.com/posts';\\n\\nlet cancelFn=function(){}\\n\\nlet readUrlPromise=url=>{\\n    return new Promise((resolve,reject)=>{\\n        let xhr=new XMLHttpRequest();\\n        xhr.open(\\\"GET\\\",url);\\n        xhr.onreadystatechange=function(){\\n            if(xhr.readyState==4 && xhr.status==200){\\n                setTimeout(()=>{\\n                        resolve({data:JSON.parse(xhr.responseText)})\\n                },3000) // 用 setTimeout 假设请求至少需要 3 s\\n            }else if(xhr.readyState==4 && xhr.status!=200){\\n                reject('请求失败');\\n            }\\n        }\\n        xhr.onerror=function(){\\n            reject('请求失败');\\n        }\\n        xhr.send(null);\\n        cancelFn=function(msg){\\n            reject(msg);\\n        }\\n    })\\n}\\n\\nlet rest=function(N){\\n    return Promise.race([\\n        readUrlPromise(baseURL),\\n        uploadTimeout(N)\\n    ]).then(data=>{\\n        console.log('url1');\\n        console.log(data);\\n    })\\n}\\n\\nfunction uploadTimeout(N){\\n    return new Promise((resolve,reject)=>{\\n        setTimeout(()=>{\\n            cancelFn('请求超时，中断promise')\\n        },N*1000)\\n    })\\n}\\n\\nrest(2) // 设定 2 s 后中断 promise；\\n```\\n\\n控制台截图：\\n\\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/057f4815c73945068ea8ce71e7b6c136~tplv-k3u1fbpfcp-watermark.image?)\\n\\n如果 N < 请求响应时间，则不会触发中断拦截；\\n\\nhttps://code.juejin.cn/pen/7174026521235963912\\n\\n另外，要提一下的是，著名请求库 axios。也有中断请求的功能，同样是利用 promise 实现一个竞态限制，有兴趣可自行研究；\\n\\n<hr>\\n\\n>OK，以上便是本篇分享，希望各位工友喜欢~ 欢迎点赞、收藏、评论 🤟\\n>\\n>我是掘金安东尼 🤠 100 万人气前端技术博主 💥 INFP 写作人格坚持 1000 日更文 ✍ 关注我，安东尼陪你一起度过漫长编程岁月 🌏\\n\\n<sub>**😹 加我微信 [ATAR53](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93fbb0597b124aca9fa3f606616ae6bf~tplv-k3u1fbpfcp-watermark.image?)，拉你入群，定期抽奖、粉丝福利多多。只学习交友、不推文卖课~**</sub>\\n\\n<sub>**😸 我的公众号：[掘金安东尼](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5cd8bb380f84d1ab52d275b1cb4e441~tplv-k3u1fbpfcp-watermark.image?)，在上面，不止编程，更多还有生活感悟~**</sub>\\n\\n<sub>**😺 我的 GithubPage: [https://tuaran.github.io](https://link.juejin.cn/?target=https%3A%2F%2Ftuaran.github.io%2F \\\"https://link.juejin.cn?target=https%3A%2F%2Ftuaran.github.io%2F\\\")，它已经被维护 4 年+ 啦~**</sub>\\n\\n<hr>\\n\\n***本文正在参加[「金石计划 . 瓜分6万现金大奖」](https://juejin.cn/post/7162096952883019783 \\\"https://juejin.cn/post/7162096952883019783\\\")***",
        "tags": [
            "前端",
            "JavaScript",
            "面试"
        ]
    },
    {
        "article_id": "7182979797130149943",
        "cover_image": "https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/135a0a014ba943ca9525bbed876f37b0~tplv-k3u1fbpfcp-watermark.image?",
        "title": "计划 | 2022年终总结",
        "brief": "那一天我二十一岁，在我一生的黄金时代。我有好多奢望。我想爱，想吃，还想在变成天上半明半暗的云。勇敢面对生活。",
        "user_name": "星空海绵",
        "view_count": 1336,
        "collect_count": 2,
        "comment_count": 14,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/ce0dfdbd73924405dbf127de87ed065a~300x300.image",
        "category": "代码人生",
        "content": "---\\ntheme: condensed-night-purple\\n---\\n\\n「回顾2022，展望2023，我正在参与[2022年终总结征文大赛活动](https://juejin.cn/post/7172462429929111559 \\\"https://juejin.cn/post/7172462429929111559\\\")」\\n\\n>去年我[年终总结](https://juejin.cn/post/7049743331953213447)的关键词是**改变**，而今年年初我给我定的2022年的关键词就是**计划**。想着今年每个月定计划，每天定计划生活，结果就是并没有实行计划生活，以前咋样生活，今年还是咋样生活。\\n\\n# 1.前言\\n\\n本来今年年中的时候，我想写篇年中总结的，结果各种拖拉就一直没写，到年底了，年终总结肯定还是得写的,好好总结一下走过的这个2022。\\n今年还不像去年，去年年终总结的时候，还是有几件能摆上台面上的事：例如跳槽成功，一年里每天坚持记录生活，还有坚持读书，而今年呢，读书还是坚持了，但是阅读时间还没去年的阅读时间多呢。\\n\\n>看着我2022年年初列的2022年的目标，好像没有完全完成的。\\n\\n~~- 1.存钱，今年又是没存到钱的一年，等个年终奖过年吧。~~\\n\\n- 2.~~早睡早起~~，好像并没有一整年都早睡早起，不过倒是想明白早睡早起的原理，这项2023年可以继续坚持实施，规律的生活节奏还是很重要的，让我们能拥有一个强健的身体。\\n\\n~~- 3.健身，今年好像没怎么健身，年底一上称，重了10斤，这我真的不能接受，啊啊啊啊。~~\\n\\n- 4.~~读书不低于40本~~。年底满打满算才读了25本，这项没有完成。\\n\\n~~- 5.找女朋友，年年计划里都有，但是年年都是没有完成这项。~~\\n\\n~~- 6.其他的什么涨薪跳槽啊，考驾照啊，都没完成。~~\\n\\n# 2.生活\\n\\n>今年好像工作并不是我生活的重点，今年工作之外的生活才是我生活的重点。\\n\\n## 1.读书\\n\\n>今年生活里的重点大概应该是读书了，虽然说今年的读书时间可能没有去年多，但是在我的生活中还是占了很大一块时间的。2022年已经读完的书的书单。[2022年读书记录](https://github.com/yukiyukixing/books-2022)。\\n\\n![书单.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e341510ec51343ea9f2795a73663036a~tplv-k3u1fbpfcp-watermark.image?)\\n\\n>买书如山倒，读书如抽丝。2023不能买书了，这些够我看几年了。\\n\\n![读完的书.jpg](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/602b8e9586954c2aa28cce617e85087c~tplv-k3u1fbpfcp-watermark.image?)\\n\\n![2.jpg](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/12a7230fe3ef4f5ea7477da762632648~tplv-k3u1fbpfcp-watermark.image?)\\n\\n![3.jpg](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f89645374f845478e822ff2520db465~tplv-k3u1fbpfcp-watermark.image?)\\n\\n虽然2022年的读书时间没有2021年多，也没有完成40本读书量的要求，但也还是读了一些书的，颇有一些收获，希望2023年继续加油，争取完成读完**50本书**的目标并多多积极分享。然后2022具体的[阅读记录](https://juejin.cn/post/7187049609749856316)在这。\\n\\n## 2.旅行\\n\\n>今年虽然没有像去年一样进行一段为期一周的长旅行，但周末还是有出去玩，虽然只是北京周边。\\n\\n- 1.一月份去了翠鸟谷徒步\\n\\n![翠鸟谷.jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/193789029c5541aaac50130c80fca5b3~tplv-k3u1fbpfcp-watermark.image?)\\n\\n- 2.二月份去了白河踏冰\\n\\n![白河踏冰.jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8a763d49a1e4f558c6458a9aaae34c8~tplv-k3u1fbpfcp-watermark.image?)\\n\\n- 3.二月份还去了长城梅花节\\n\\n>这里忘记拍照了，相册里没有照片。\\n\\n- 4.三月份去了潭柘寺\\n\\n![潭柘寺一日游.jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93da17d3d8ab4555bba2cc3adeb1f61b~tplv-k3u1fbpfcp-watermark.image?)\\n\\n- 5.八月份去了云海涯露营\\n\\n>为什么直接从三月份就跳到八月份了，可能是因为疫情，也可能是因为我这段时间在疯狂打王者或者是在做视频，具体忘了。\\n\\n>云海涯露营这里的风景真的非常漂亮，从手机里看当时拍的照片，任何一张风景照都非常的美。\\n\\n![云海涯露营.jpg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/67ca54a506724e98b2c2c3a2bcb111bb~tplv-k3u1fbpfcp-watermark.image?)\\n\\n![云海涯.jpg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a814c043eaf840c39ad086560eed4ef7~tplv-k3u1fbpfcp-watermark.image?)\\n\\n- 6.八月份还去了坝上草原\\n\\n>坝上草原的风景也非常的漂亮。\\n\\n![坝上草原1.jpg](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5833da9174ac45689a3422d63773e697~tplv-k3u1fbpfcp-watermark.image?)\\n\\n![坝上草原2.jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13d82f37b449411baf17cdc4a1dc69f8~tplv-k3u1fbpfcp-watermark.image?)\\n\\n![坝上草原3.jpg](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a9d6569078944d4382bc82f2c349c91d~tplv-k3u1fbpfcp-watermark.image?)\\n\\n- 7.九月份去了海坨山谷露营\\n\\n>海坨山谷的风景也非常的漂亮。\\n\\n![海坨山谷1.jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2055394fe89e41ea9a8b6e7e198eb222~tplv-k3u1fbpfcp-watermark.image?)\\n\\n![海坨山谷2.jpg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7dd9af329861416ba859bf0d75d854b9~tplv-k3u1fbpfcp-watermark.image?)\\n\\n![海坨山谷3.jpg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8d930a9b576445d48c9e68f26e023279~tplv-k3u1fbpfcp-watermark.image?)\\n\\n![海坨山谷4.jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/32c9f54da8d7498daba8b6a28261ea65~tplv-k3u1fbpfcp-watermark.image?)\\n\\n- 8.九月份还去了百里画廊\\n\\n>百里画廊就更不用说了，听这名字就知道很漂亮。\\n\\n![百里画廊1.jpg](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb47863d0d5d4cd793ae84fdb1d103db~tplv-k3u1fbpfcp-watermark.image?)\\n\\n![百里画廊2.jpg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b00a7926f144376a9f3e935e405b52a~tplv-k3u1fbpfcp-watermark.image?)\\n\\n![百里画廊4.jpg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/48ef27dddce047d8b311d31df1b6bf17~tplv-k3u1fbpfcp-watermark.image?)\\n\\n![百里画廊3.jpg](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a387b969a2b4e5693ddbea38598f150~tplv-k3u1fbpfcp-watermark.image?)\\n\\n>今年真的是周一到周五为了生活出卖灵魂，周末通过美丽的风景净化灵魂和洗刷工作的疲惫。但是今年其实旅行上也有遗憾，就是没有去一次其他城市进行一个长旅行，然后就是没有遇到一个能一起旅行吃吃吃的对象，还是比较遗憾的。但是在没有对象的情况下，自己一个人能感受到这么美的风景也非常的治愈，让我觉得生活真是美好，周末好像进行了一次充电，然后下一周又能好好工作了。但是什么都是有代价的，旅行也一样，旅行的代价就是坐车时间长，在车上的时间比较难熬，虽然可以睡觉，但是我总是感觉车上好闷，我觉得这是周末在周边旅行最大的缺点。\\n\\n## 3.做视频\\n\\n今年应该是6月份到7月份两个月，突然又想开始做视频了。因为以前2020年的时候有段时间做过鬼畜视频，然后今年不知道想啥呢，又想做，以前2020年那时候做的偏调音向的鬼畜，然后今年想着做rap类的，然后就6月份开始学习怎么做，然后7月份做了2个视频。做鬼畜视频太耗费精力和时间了，然后和收益也不成正比，如果不是真的热爱，谁坚持做鬼畜啊，做了两个，然后就不想做了，后面也就没做了。\\n\\n![鬼畜1.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/23cb2c8f963c412989b155cbd107d3e6~tplv-k3u1fbpfcp-watermark.image?)\\n\\n![鬼畜2.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1edd2c1140b64109b02e8b0792d8b5c1~tplv-k3u1fbpfcp-watermark.image?)\\n\\n![鬼畜3.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b3438d04d53a43a092071a1d11fb84de~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## 4.其他\\n\\n然后除了上面说过的读书，旅行，做视频，今年生活里还有的事情那可能就是游戏，应该是上半年有段时间，沉迷王者荣耀，后面因为王者荣耀匹配机制以及家里网络问题，不想玩了，把账号注销了，然后也就没玩了。然后什么找对象的，不能说一点没有努力吧，基本上也就没有努力。然后今年还有逃不掉的疫情，核酸等等大环境下的东西。当然也有世界杯，一场举世瞩目的体育赛事，让我们的生活中多了一些娱乐和谈资。然而今年还有疫情放开，我也不可避免的🐏了，发烧，头疼，身上疼，刀片嗓子也都经历了，然后幸好没什么大事，好了，家里亲人也🐏了，也基本没啥大问题，都好了，还算是幸运吧。放开了从某种意义上来说，也算疫情结束了吧，我们可以恢复比较正常的生活了，明年充满干劲，元气满满捏。\\n\\n![核酸.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d41384b4b2934701833d7863ef817051~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## 5.生活总结\\n\\n今年的生活怎么说呢，总的来说还行吧。虽然2022年的Flag没完成几个，但是也读书了，旅行了，尽管有些地方还是不如人意。但是人生大事什么的，一样也没解决，什么车子房子对象，是一样没有，存钱也没存到啥钱，跳槽也没有，涨薪涨了一丢丢，其实原本想着今年跳槽出去涨个40%的，结果今年这形势，也没跳。然后有一天突然想到王小波的一句话：\\n\\n>那一天我二十一岁，在我一生的黄金时代。我有好多奢望。我想爱，想吃，还想在变成天上半明半暗的云。\\n\\n虽然我不是21岁，但是今年我感觉确实是我一生的黄金时代，我想爱，找一个对的人一起去旅行，去吃好吃的，去看电影，冬天一起窝在家里看电视剧看动漫看纪录片，一起做饭，一起饭后散步。可惜今年我并没有遇到找到那个人，我还是一个人对抗着这无聊的生活，大多数时候把阅读当作一座随身携带的避难所，躲在经典文学的世界里，看文学世界里的人生百态。幸好有书籍，让我今年的生活不至于太无聊。\\n\\n# 3.工作\\n\\n## 1.裁员\\n\\n由于大环境原因，今年公司也裁员了，把整个自动驾驶部门干掉了。然而我因为是前端，只要研发产品前端后端都还是用得着的，然后裁员的时候我可以选择n+1和转到另外的一个部门。因为裁员都10月份了，我想着还有2个月就年底了，年终奖啊，然后我就选择转到另外一个部门。裁员前今年我主要做自动驾驶相关的数据可视化的功能，还有一些项目的整合（微前端），今年用了webpack5的模块联邦功能，就是微前端的一种方案，然后项目也成功上线使用，还不错。因为我做的自动驾驶数据包可视化的功能还比较重要，然后有段时间就挺忙的。但就整年的维度来说也还好，并没有出现我去年那样想办法去平衡工作和生活，今年工作和生活都算得上游刃有余吧。然后公司整个自动驾驶部门进行裁员后，转到其他部门后，适应的也比较快，也不是很忙，也还行。然后就是今年疫情，有好几段时间居家办公，公司也还算不错，让我们居家办公。\\n\\n## 2.成长\\n\\n今年工作上的成长说没有吧，肯定不可能，一年也干了不少活。但是下班后回家学习，那是基本没有，不像去年，下班后回家那是嘎嘎学啊，然后跳槽换了现在这份工作。因为今年跳槽的目标并不是很坚定，即使在能拿n+1的情况下，也没有选择走。一是公司也确实还行，然后去年7月份才跳过来，想着还能待就还待一段时间吧，再加上今年大环境肉眼可见的不是很好。今年技术上的成长不是很多吧，但是在解决问题，业务上的能力感觉强了不少，独挑大梁不是问题。\\n\\n## 3.副业\\n\\n看很多同学写年终总结，都有副业，我并没有副业，我感觉我不是很想做副业。没有那么大赚钱的动力，现在的工资说实话在北京买房肯定买不了，但是就我生活来说，那是完全够了，但是我今年也没咋攒下钱，花钱大手大脚的，明年攒吧。\\n\\n# 4.2022年总结\\n\\n2022年虽然立的Flag基本都没完成，但是自我感觉也还行，平平安安，健健康康的，家人也都还好。工作也没啥问题，生活中也能看看书，旅行旅行，也不算很无聊。虽然感觉这一年过的有点平淡，甚至可以说是躺平躲避现实的一年，试图找到一种很有意义的生活方式，在这一年的慢慢的自我探寻中，学会了**耐心**和**温柔**的对待生活和这个世界，少了一些戾气，我感觉在认知上和精神上，今年我也成长了不少。人生漫长，独处的时候我们也要学会读书思考，耐心温柔的对待我们所接触到的世界。\\n\\n# 5.2023年展望（Flag）\\n\\n- [ ] 1.在疫情放开的大背景下，保持身体健康。\\n\\n- [ ] 2.规律生活，早睡早起。\\n\\n- [ ] 3.读书至少50本。\\n\\n- [ ] 4.好好赚钱，存钱。\\n\\n- [ ] 5.把驾照考了。\\n\\n- [ ] 6.涨薪或者跳槽。\\n\\n- [ ] 7.健身，一周至少2次健身运动吧。\\n\\n- [ ] 8.至少2次长旅行。\\n\\n- [ ] 9.今年换房子的时候租个一室一厅，自己买菜做饭吃，一个人的时候也要好好热爱生活。\\n\\n- [ ] 10.好好体验生活，感悟生活，勇敢面对生活。\\n\\n- [ ] 11.找对象，随缘吧。\\n\\n>2023加油，冲冲冲，干劲十足，元气满满捏。\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
        "tags": [
            "前端",
            "年终总结",
            "程序员"
        ]
    },
    {
        "article_id": "7183342474876682295",
        "cover_image": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ebd38cea2d6648f6a39d1e7402852875~tplv-k3u1fbpfcp-watermark.image?",
        "title": "2022年终总结：相信时间的力量",
        "brief": "虽然疫情贯穿了2022一整年，好在该推进的工作都正常推进了。再过2分钟 2022 年就结束了，还是那句话，做好该做的事，静待水到渠成。",
        "user_name": "程序媛最可爱",
        "view_count": 1728,
        "collect_count": 3,
        "comment_count": 7,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/b1be29961955d72fc980491c09d16dd4~300x300.image",
        "category": "代码人生",
        "content": "---\\ntheme: smartblue\\nhighlight: atom-one-dark\\n---\\n\\n2022 年整年都在疫情的影响当中：\\n\\n- 2-3 月新冠轨迹重叠分别在商场、公司、家隔离了 1 天、2 天 、2 周；\\n- 8-9 月新冠轨迹重叠加高温限电居家办公 3 周；\\n- 10 月回老家轨迹重叠居家隔离 2 天；\\n- 12 月家人感染新冠作为密接居家隔离 1 周；\\n\\n虽然疫情贯穿了一整年，好在该推进的工作都正常推进了。\\n下面就来汇报一下今年在技术、社区、工作和生活上的进展吧。\\n\\n## 技术\\n\\n- React + ts 上线项目   \\n  打开了 React + Typescript 的大门，完成了一个 React + Umi 技术框架的中型 CRM 项目。\\n  2 年没写 React，这次算是又捡起来啦，学会了 hooks。\\n\\n- 微信小程序原生开发 复习   \\n  顺利上线了一个企业微信端的微信小程序，把小程序的原理及使用细节摸清楚了。\\n\\n- 基础知识 复习   \\n  由于担任前端面试官，所以 “被迫” 复习了 1 遍基础知识（理解又加深了些），leetcode 刷了 30 道（加上去年的共 110），共面试 20+ 位开发。\\n\\n  一些我比较关心的面试题，可发散：\\n\\n  - 沟通能力 语言描述能力\\n  - 讲清楚自己负责的项目 难点是如何解决的？\\n  - this 的认识\\n  - 页面渲染流程\\n  - 深拷贝的实现\\n  - 模块化的理解\\n  - http 和 https 的发展和区别？ https 为什么更安全？\\n  - Vue 与 React 的区别\\n  - Webpack 打包原理\\n\\n  如果基础答的不好大概率就挂了，然后会问一些框架使用的题。  \\n  行业内卷，下半年大厂纷纷提高了简历门槛，非 985 211 院校的不过，所以我们也收到了一些经历非常好（硕士、大厂、985）的简历，惶恐。\\n  也面试了几位前端 Team Leader，意识到不管是管理还是开发岗位，技术都很重要，不能丢。\\n  顺便关注了一下招聘市场，boss 上面招人的公司真心不多，希望明年可以慢慢恢复往常，打工人真不容易（前同事今年被裁员 2 次）。\\n\\n- svelte 初探   \\n  svelte 类似 Vue、React，国内使用的人比较少。没有虚拟 DOM、语法简单、响应式、打包体积小，但是生态和社区发展不够好，适合一些纯展示的项目，大家感兴趣可以试试，[文档](https://svelte.dev/)很清晰。\\n\\n- PhotoShop + 画图 提升   \\n  文章封面图 5 张，卡通人物图 10+ 张， 项目中图片自行处理，制作了自己各平台的头像 3 张。\\n\\n## 掘金社区\\n\\n今年一共分享了 4 篇技术文章，其中 3 篇受到大家的喜欢，勉强过关。\\n\\n- [Vue2 到 React 一遍过](https://juejin.cn/post/7133506041391611912) 200+ 点赞\\n\\n- [一份热乎的微信小程序使用经验](https://juejin.cn/post/7081452878690254884)  50+ 点赞\\n\\n- [前端请装上这个 chrome 插件](https://juejin.cn/post/7049211255181017102) 1500+点赞    \\n体验了一下提 merge request，给仓库贡献了一点点代码\\n\\n在掘金学到很多知识，输出一些还算有用的文章算是反馈社区，从社区中来，到社区中去。\\n\\n另外参加掘金活动，获得了 一个 虎虎生金-保温杯（送老爸）、一个马克杯（送对象）；每日打卡兑换了一个马克杯、一张线圈毛巾、一个公益助力包（给山区的孩子送文具）。可惜奖品中没有可以兑换来送小朋友的礼物，想跟宝宝也分享学习的快乐。\\n\\n## 工作\\n\\n这一年在公司接触到了更多的人和事，不再局限于本部门，而是往外拓展。   \\n在与人交往，和沟通技巧上更近了一步，也更能换位思考，针对不同的人，换不同的说话方式和推进技巧，尝试向上管理。    \\n在工作岗位上又稳稳的度过了一年，能够 cover 项目中遇到的技术难题，顺利成为 3 年的老员工。   \\n虽然疫情，幸运的我还是拿到了点点涨薪，职级也升到了高级，开心，哈哈，感谢老板和平时给予帮助的同事们，感谢！   \\n去年我比较熟悉的后端和运维大佬离职了，幸运的是今年跟一位领导成了比较好的朋友，了解到管理视角的人和事，在为人处事上给了我很多启发，学到很多东西。\\n\\n## 生活\\n\\n- 孩子的教育   \\n  由于搬家孩子从私立幼儿园转入了公立幼儿园，科目知识都不教了，所以我有机会就会给她安排学习。\\n\\n  + 数学上 10 以内的加减乘除法掌握；拼音上掌握了单韵母、声母 15+；\\n  + 汉字方面掌握了近 80 个字；\\n  + 画画上颜色搭配提升、能够画出包含五官和身体细节的卡通人物，自己画了一本故事书（报了班）；\\n  + 舞蹈上能够开横叉了（报了班）。\\n  + 音乐和英语，报了线上班，但是没怎么要求，认识大部分的字母，能听懂常见的水果，进步缓慢，\\n  \\n  总体来说，今年还是有些收获，明年需要继续努力，争取在上小学之前数学掌握简单的四则运算、学完拼音、掌握300汉字、日常英语口语尽量多的掌握。\\n  \\n  时间主要来源于睡前、居家隔离时坐我旁边陪我上班和周末见缝插针。\\n\\n- 家人身体   \\n  这 2 年由于疫情很多人过得磕磕绊绊，好在我的家人身体都还算健康、工作也没怎么受影响，这就是最好的事情啦。\\n\\n- 学习群   \\n  今年 8 月初，无意中发现小区妈妈群里的邻居创建了一个学习群，于是开心的加入了，在这个群里面打卡了 React 及周边的相关知识、读了 5 本技术以外的书、把小学到高中需要掌握的英语单词又复习了一遍（百词斩-用于与孩子日常对话的素材）。\\n  读过还不错的书：\\n\\n  - 《说话的魅力》- 想要办成事情如何讲话更得体\\n  - 《我不是教你诈》- 职场和社会中人际交往的一些法则\\n  - 《萤窗小语》- 抚慰心灵\\n  - 《正面管教》- 尊重孩子和自己 给予信任\\n  - 《创造》- 产品思维 在读中\\n\\n  读书时学过的很多单词忘记了，最近复习的过程中加深了印象，nice。  \\n  这个群人最多的时候 7 个人，现在剩下 3 个人，除了生病可以请假，严格要求每天打卡 30min+。  \\n  我一般是中午午休、通勤路上、晚上洗漱之后的时间用来完成一天的打卡任务，有时候很累不想做，几次打卡超过了 12 点， 但还是坚持下来了，收获满满。\\n\\n- 搬进新家   \\n  去年 11 月开始微改精装房，8 月成功搬进了新家，现在仅剩生活阳台收纳柜还没定（因为最近大家都阳了，可能要等到明年才能安装），总体不影响生活啦！\\n  家里新增了扫地机器人（科沃斯-扫拖一体真的好用，解放双手，推荐）、烘干机（海尔-冬天的衣服拿出来就能穿还是暖和的，推荐）。\\n  装修遇到了很多坑（感叹自己还是太年轻了），希望能帮到一些要装修的小伙伴：\\n\\n  <details>\\n  <summary>装修中的坑事</summary>\\n  <pre>\\n  <code>\\n\\n  - 天然气改管\\n    增加 4 米室内管道 移动热水器 收费 1066（有种被讹的感觉）\\n    师傅带的燃气管与热水器之间的连接管不匹配 就说不是他负责的事 甩锅给微改 查资料搞清楚后投诉到燃气公司才解决\\n\\n  - 美缝\\n    师傅说是环氧彩砂 做完了才知道他用的其实是叫环氧彩砂的美缝剂 环氧彩砂更环保  \\n    （“最后知道真相的我，眼泪掉下来” 真的感觉自己很好笑啊，因为那段时间工作太忙了，没提前查资料，该的）\\n\\n  - 微改贴地砖\\n    瓷砖空鼓、不平、花色倒贴 计划之外多定了一片瓷砖备用 后来施工过程中师傅说不够还要再补两片\\n    当面计算面积后 师傅才说是他们切坏了可以赔\\n\\n  - 墙面刷漆\\n    墙面多处凹凸不平 关了灯用手机一照 惊了 到处都有问题 反复修补了 3 遍  \\n    （师傅说：你怎么用手机照嘛 哪里着得住）\\n\\n  - 门套打胶\\n    门套的胶只给看得到的地方随便打了点 顶上直接没打\\n\\n  - 封洞\\n    钢板看起来是工业废弃钢板 不像全新的 用的钢材量少 感觉不结实 反复请求说好话 师傅才给加了几根\\n\\n  - 封窗\\n    下单的时候说的专业垫片 还有专利 现场安装时师傅直接用木头塞上 指出来还把师傅惹恼了 最后敷衍的垫了几片\\n    销售说安装现场和验收她会来帮忙把控安装细节 结果从我交了钱那天开始就没见过她\\n\\n  - 微改施工\\n    师傅进场第一天就把我放在门口的定制柜板材和处理好的木条直接抬走了 问起来说不是他们拿的 我说电梯有监控他才承认 说已经切了做成别的东西 无法复原\\n\\n  - 开发商\\n    橱柜下面挡板拿开 发现没贴地砖\\n    收房当天进门就看见墙纸掉了一大块\\n    主卧 墙面在射灯下呈波浪形\\n    次卧 多处木地板下面是空的 踩一脚冒灰上来\\n    客厅 地砖坏了几片 有根波导线突起\\n    门槛石磨花了未抛光\\n    （好在，开发商的问题都解决得比较快，维修师傅态度也特别好）\\n\\n</code>\\n</pre>\\n</details>\\n\\n\\n## tips\\n\\n这一年的一些感悟：\\n\\n- 不同人的能力确实有差别，不是每个人都愿意学、学得会，大部分人没有改变的动力      \\n    以前一直相信大家都是好学的、自觉的。严于律己我做到了，但宽以待人还需要继续修炼。\\n\\n- 不是每个人都能讲道理，道理只在讲道理的人身上有用   \\n    有的人不讲道理，只讲利益。但讲利益未必是坏事，这样的人可能更容易合作。\\n\\n- 工作和家庭都不是生活的全部，想清楚自己要什么，给自己留点时间   \\n   工具人压力太大、内心会很空虚，找到一个工作以外的爱好，读书和画画可以让我放松下来。\\n\\n- 不要一时间用力过猛，拼搏和休息都应该放在每一天，保持一个平和的心态，健康的身体   \\n   掌握生活的节奏才能走得更远\\n\\n- 对于打工人来说沟通能力和责任心占首要位置   \\n    团队里有一个比较“特殊”的成员，会影响团队其他成员\\n\\n\\n\\n## 2023 年计划\\n\\n1. 在项目的发展过程中，每一个角色都很重要，但是开发离客户和用户比较远，想要更多的去接触客户和用户，多多的了解售前、售后的故事。和不同的人打交道很难但克服之后会发现很有意思，希望自己有机会体验项目管理的角色。\\n   \\n2. 在掘金社区每月至少输出1篇文章，坚持把 “程序媛最可爱” 这个 IP 经营下去\\n\\n3. 初探人工智能 或者 尝试做视频教程 （这个还没想清楚，元旦假期再好好查查资料，跟朋友们讨论讨论，也欢迎大家给建议）\\n\\n## 最后\\n\\n再过2分钟 2022 年就结束了，还是那句话，做好该做的事，静待水到渠成。\\n\\n最后，希望看见这篇文章的你天天开心，年年涨薪，bye ～\\n\\n「回顾2022，展望2023，我正在参与[2022年终总结征文大赛活动](https://juejin.cn/post/7172462429929111559 \\\"https://juejin.cn/post/7172462429929111559\\\")」\\n",
        "tags": [
            "前端",
            "程序员",
            "年终总结"
        ]
    },
    {
        "article_id": "7195086390357393469",
        "cover_image": "",
        "title": "5. 「vue@2.6.11 源码分析」组件渲染之创建虚拟DOM",
        "brief": "vue@2.x中用到了虚拟DOM技术，基于第三方虚拟DOM库sanbbdom修改。建议阅读本文之前对snabbdom的使用和原理 有一定的了解，可以参考 snabbdom@3.5.1 源码分析。",
        "user_name": "_tinyant",
        "view_count": 942,
        "collect_count": 2,
        "comment_count": 0,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/83b31e0da1a2c77ea1f3bae752e4b586~300x300.image",
        "category": "前端",
        "content": "vue@2.x中用到了虚拟DOM技术，基于第三方虚拟DOM库sanbbdom修改。建议阅读本文之前对snabbdom的使用和原理 有一定的了解，可以参考 [snabbdom@3.5.1 源码分析](https://juejin.cn/column/7193906348935872567)。\\n\\nvue2中组件渲染的核心入口如下：\\n```js\\n// src/core/instance/lifecycle.js\\nexport function mountComponent (vm: Component, el: ?Element, hydrating?: boolean): Component {\\n  vm.$el = el\\n  //...\\n\\n let updateComponent\\n updateComponent = () => {\\n   vm._update(vm._render(), hydrating)\\n }\\n new Watcher(vm, updateComponent, noop, {\\n   before () {\\n     if (vm._isMounted && !vm._isDestroyed) {\\n       callHook(vm, 'beforeUpdate')\\n     }\\n   }\\n }, true /* isRenderWatcher */)\\n    \\n //...\\n\\n return vm\\n}\\n```\\n其中`vm._render`用来生产虚拟节点树的，就像snabbdom中使用`h`函数创建虚拟节点树一样。而`vm._update`用来将上一步即vm._render生成的虚拟节点树经过`patch`操作同步到界面上。\\n\\n`new Wacher(...)`用法在上一节[数据驱动](https://juejin.cn/post/7193639761477795901)详细分析过。updateComponent在首次创建watcher实例时会执行一次，当updateComponent依赖的响应式数据变化时会再次执行。\\n\\n因此上面``new Watcher(vm, updateComponent,..)``方法中的两个操作_render() -> _update()，相当于snabbdom的如下操作\\n\\n- 初始化时类比\\n```js\\nconst container = document.getElementById(\\\"container\\\");\\nconst vnode = h(...); // 创建虚拟节点树\\npatch(container, vnode); // 同步虚拟DOM树同步到界面\\n```\\n\\n- 响应式数据更新时类比\\n```js\\n// 如果此时有数据变更引起界面变更\\nconst newVnode = h(...); // 新的虚拟节点树\\npatch(vnode, newVnode); // 和上一次的虚拟节点树进行diff，将差异同步到界面上\\n```\\n\\n这里的巧妙出是new Watcher两个步骤合并到一起。\\n\\n下面我们重点看下vue@2.x中关于虚拟DOM的相关逻辑。主要逻辑在src/core/vdom文件夹中。\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/099e78032a3f421190e2950ffa168617~tplv-k3u1fbpfcp-watermark.image?)\\n\\n# 从入口讲起（对应snabbdom库 init 方法）\\npatch方法是跨平台的，因此在编译入口处便做了区分，web平台下\\n\\n运行时的编译入口在：src/platforms/web/runtime/index.js，此时就定义了`__patch__`方法，然后在`vm._update`会调用`vm.__patch__`实现diff能力\\n```\\n// src/platforms/web/runtime/index.js\\n\\nimport { patch } from './patch'\\n//...\\n// install platform patch function\\nVue.prototype.__patch__ = inBrowser ? patch : noop\\n//...\\n```\\n\\n```\\n// src/platforms/web/runtime/patch.js\\n\\nimport * as nodeOps from 'web/runtime/node-ops'\\nimport { createPatchFunction } from 'core/vdom/patch'\\nimport baseModules from 'core/vdom/modules/index'\\nimport platformModules from 'web/runtime/modules/index'\\n\\n// the directive module should be applied last, after all\\n// built-in modules have been applied.\\nconst modules = platformModules.concat(baseModules)\\n\\nexport const patch: Function = createPatchFunction({ nodeOps, modules })\\n```\\ncreatePatchFunction就相当于snabbdom中init方法，nodeOps是因为跨平台的原因放在这里（私有化），这里重点关注modules，在snabbdom中说到module会借助patch过程中触发的各种钩子参与DOM的修改。这里都有哪些module呢，分为两类：基础module和跨平台module，如下：\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc26392ebef74cf294b8a36b1a2749fc~tplv-k3u1fbpfcp-watermark.image?)\\n\\n可能会单独出一个小节分析这些module\\n\\n## 小结\\n这里主要是创建`patch`方法的过程\\n\\n# vnode\\nvue@2.x中vnode在snabbdom定义的vnode基础上增加了很多其他的属性，\\n- [ ] 后面用到逐个介绍？最终统一在这里汇总一次？\\n\\n# _render：创建虚拟节点树\\n我们先看下`vm._render`方法的定义\\n\\n```js\\n  Vue.prototype._render = function (): VNode {\\n    const vm: Component = this\\n    const { render, _parentVnode } = vm.$options\\n\\n    if (_parentVnode) {\\n      //... slot相关，暂忽略\\n    }\\n\\n    // set parent vnode. this allows render functions to have access\\n    // to the data on the placeholder node.\\n    vm.$vnode = _parentVnode\\n    // render self\\n    let vnode\\n    try {\\n      // There's no need to maintain a stack because all render fns are called\\n      // separately from one another. Nested component's render fns are called\\n      // when parent component is patched.\\n      currentRenderingInstance = vm\\n      vnode = render.call(vm._renderProxy, vm.$createElement)\\n    } catch (e) {\\n        //... 异常处理\\n    } finally {\\n      currentRenderingInstance = null\\n    }\\n    //... \\n    // set parent\\n    vnode.parent = _parentVnode\\n    return vnode\\n  }\\n```\\n这里关注三个地方\\n1. render 函数的执行，render函数长什么样子呢？    \\n    ```html\\n    <!-- 原始模板 -->\\n    <div id=\\\"app\\\"> {{ message }} </div>\\n    ```\\n    ```js\\n    // 编译后的render函数\\n    (function anonymous() {\\n      with (this) {\\n        return _c('div', {attrs: {\\\"id\\\": \\\"app\\\"}}, [_v(\\\"\\\\n  \\\" + _s(message) + \\\"\\\\n\\\")])\\n      }\\n    })\\n    ```\\n    **render来自哪里？**\\n    1. render函数可以由开发者自己提供\\n    2. 也提供了`编译 + 运行时`版本，即可有运行时编译，框架会自动处理将模板处理成render函数\\n    3. 更为常见的是`.vue`单文件开发，vue-loader会将其自动将template部分处理成render函数\\n   \\n2. `currentRenderingInstance` 的设置    \\n4. 关系链接\\n    1. `vm.$vnode = _parentVnode`，当前组件实例的$vnode指向父虚拟节点\\n    2. 虚拟节点父子关系建立：`vnode.parent = _parentVnode`\\n    3. 这里返回的vnode，会在vm.update中被设置给vm：`vm._vnode = vnode`\\n\\n下面重点看下`render`函数的执行，还是以上面的`render`函数为例，如下\\n```html\\n<!-- 原始模板 -->\\n<div id=\\\"app\\\"> {{ message }} </div>\\n```\\n```js\\n// 编译后的render函数\\n(function anonymous() {\\n  with (this) {\\n    return _c('div', {attrs: {\\\"id\\\": \\\"app\\\"}}, [_v(\\\"\\\\n  \\\" + _s(message) + \\\"\\\\n\\\")])\\n  }\\n})\\n```\\n\\n显然里面用到了的_c、_v都是函数，主要是_c，该函数等价于snabbdom的`h`函数，用来创建虚拟DOM。\\n\\n需要注意到`with`的用法，with中的this就是组件实例，该实例上挂载_c这些方法，以及render函数中用到数据如上面demo中的`message`。[with特性](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/with)\\n\\n下面看下_c，_v的定义\\n```js\\n// src/core/instance/render.js\\nimport { createElement } from '../vdom/create-element'\\nexport function initRender (vm: Component) {\\n    //...\\n    vm._c = (a, b, c, d) => createElement(vm, a, b, c, d, false)\\n    // normalization is always applied for the public version, used in\\n    // user-written render functions.\\n    vm.$createElement = (a, b, c, d) => createElement(vm, a, b, c, d, true)\\n    //...\\n}\\n```\\n\\n当vue运行时代码执行时就会执行 renderMixin -> installRenderHelpers(Vue.prototype)，该方法挂载了一些工具方法和创建DOM节点的方法。\\n```js\\nexport function installRenderHelpers (target: any) { // target: Vue.prototype\\n  //...\\n  target._s = toString\\n  //...\\n  target._v = createTextVNode\\n  //...\\n}\\n```\\n\\n我们重点关注_c指向的createElement方法\\n\\n## createElement：创建vnode\\n```js\\nimport VNode, { createEmptyVNode } from './vnode'\\nimport { createComponent } from './create-component'\\n//...\\n\\n// alwaysNormalize： 调用 vm.$createElement 方法时，传递ture，看到 _render() -> render.call(vm, vm.$createElement)，也就是执行用户自己提供的render函数时会走这里\\n// createFunctionComponent 又有可能\\nexport function createElement (context: Component, tag: any, data: any, children: any, normalizationType: any, alwaysNormalize: boolean): VNode | Array<VNode> {\\n  //... 参数纠正  \\n  //... 特殊场景，属性规范化设置，不重要\\n  \\n  return _createElement(context, tag, data, children, normalizationType)\\n}\\n\\nexport function _createElement (context: Component, tag?: string | Class<Component> | Function | Object, data?: VNodeData, children?: any, normalizationType?: number): VNode | Array<VNode> {\\n  //... vnode data 不能是响应式数据，如果是返回空vnode\\n  \\n  // object syntax in v-bind\\n  if (isDef(data) && isDef(data.is)) { // 动态组件\\n    tag = data.is\\n  }\\n  \\n  //... 如果没有tag，返回空vnode  \\n  //... 规范化孩子，不重要\\n  \\n  let vnode, ns\\n  if (typeof tag === 'string') {\\n    let Ctor\\n    ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag)\\n    if (config.isReservedTag(tag)) { \\n      vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context)\\n    } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) { // 组件\\n      // component\\n      vnode = createComponent(Ctor, data, context, children, tag)\\n    } else {\\n      // unknown or unlisted namespaced elements\\n      // check at runtime because it may get assigned a namespace when its\\n      // parent normalizes children\\n      vnode = new VNode(tag, data, children, undefined, undefined, context)\\n    }\\n  } else { // new Vue({render: h => h(App)}) // 用户手动提供 render函数\\n    // direct component options / constructor\\n    vnode = createComponent(tag, data, context, children)\\n  }\\n  \\n  ，\\n  if (Array.isArray(vnode)) { \\n     // 如果vnode是数组，取第一个\\n  } else if (isDef(vnode)) {\\n    //...\\n    if (isDef(data)) registerDeepBindings(data)\\n    return vnode\\n  } else {\\n    // 如果没有返回空vnode\\n  }\\n}\\n\\n// ref #5318\\n// necessary to ensure parent re-render when deep bindings like :style and\\n// :class are used on slot nodes\\nfunction registerDeepBindings (data) {\\n  if (isObject(data.style)) {\\n    traverse(data.style)\\n  }\\n  if (isObject(data.class)) {\\n    traverse(data.class)\\n  }\\n}\\n```\\n\\n- 上面注释提到了children的规范化，解释参考[黄轶-vue技术揭秘](https://ustbhuangyi.github.io/vue-analysis/v2/data-driven/create-element.html#children-%E7%9A%84%E8%A7%84%E8%8C%83%E5%8C%96)\\n- [ ] 记个todo，验证下（虽然不影响整体流程） \\n\\n下面看下核心逻辑，实际上很清晰了\\n1. 如果`tag`是对象或者是组件构造函数，则调用`createComponent`创建组件的虚拟节点（注意，这里并不会创建组件的vue实例，更不会进入组件内部去创建组件的实际内容），createComponent仅仅是创建`组件标签`（如`<todo-item>`）对应的vnode，本质上和div并无太多区别，主要是会挂载很多信息（props, events等等）\\n2. 如果是保留`tag`如`div`，直接new vnode\\n3. 如果不是保留tag如`todo-item`，并从 `vm.components` 中查找有没有定义该组件\\n    1. 如果有则 `createComponent`\\n    2. 否则就是创建一个位置节点，同样会new vnode （和`div`的vnode的创建没啥区别）\\n\\n- [ ] 记个todo， registerDeepBindings 作用？看起来是处理slot场景的bug❓❓❓\\n\\n下面看下组件vnode创建场景：createComponent\\n\\n## createComponent：创建【组件tag】的vnode（并不会进入组件内部）\\n```js\\nexport function createComponent (Ctor: Class<Component> | Function | Object | void, data: ?VNodeData, context: Component, children: ?Array<VNode>, tag?: string): VNode | Array<VNode> | void {\\n  if (isUndef(Ctor)) return\\n\\n  const baseCtor = context.$options._base\\n  if (isObject(Ctor)) {\\n    Ctor = baseCtor.extend(Ctor)\\n  }\\n \\n  if (typeof Ctor !== 'function') return\\n\\n  // async component\\n  let asyncFactory\\n  if (isUndef(Ctor.cid)) {\\n   // return ... 异步组件，单独的逻辑，后面会单独小节说\\n  }\\n\\n  data = data || {}\\n\\n  // resolve constructor options in case global mixins are applied after\\n  // component constructor creation\\n  resolveConstructorOptions(Ctor)\\n\\n  // transform component v-model data into props & events\\n  if (isDef(data.model)) {\\n    transformModel(Ctor.options, data)\\n  }\\n\\n  // extract props\\n  const propsData = extractPropsFromVNodeData(data, Ctor, tag)\\n\\n  if (isTrue(Ctor.options.functional)) {\\n      // return ... 函数式组件的创建 是单独的逻辑，后面有可能单独小节说下\\n  }\\n  \\n  // extract listeners, since these needs to be treated as\\n  // child component listeners instead of DOM listeners\\n  const listeners = data.on\\n  // replace with listeners with .native modifier\\n  // so it gets processed during parent component patch.\\n  data.on = data.nativeOn\\n\\n  if (isTrue(Ctor.options.abstract)) {\\n    //... 抽象组件的slot需要特殊处理？ 如果时间允许单独看看\\n  }\\n\\n  // install component management hooks onto the placeholder node\\n  installComponentHooks(data)\\n\\n  // return a placeholder vnode\\n  const name = Ctor.options.name || tag\\n  const vnode = new VNode(`vue-component-${Ctor.cid}${name ? `-${name}` : ''}`, \\n    data, undefined, undefined, undefined, context,\\n    { Ctor, propsData, listeners, tag, children }, asyncFactory)\\n \\n\\n  return vnode\\n}\\n```\\n\\n1. 创建组件肯定需要一个构造函数的，如果是组件对象如Ctor（data/props/methods等等），会通过Vue.extend(Ctor)，该方法通过原型继承返回一个构造函数，后面会说到。\\n2. 如果是异步组件，则走异步组件vnode创建逻辑\\n3. resolveConstructorOptions：从注释来看，是担心先创建的组件构造函数而后再注册全局mixin\\n    - [ ] 待验证，处理特殊场景，非核心逻辑，不重要\\n4. transformModel：（[自定义组件v-model](https://v2.cn.vuejs.org/v2/guide/components-custom-events.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E7%9A%84-v-model)），看起来只是语法糖：取值，添加事件回调，\\n    - [ ] TODO，demo验证下？，不影响主流程\\n    ```js\\n    // transform component v-model info (value and callback) into\\n    // prop and event handler respectively.\\n    function transformModel (options, data: any) {\\n      const prop = (options.model && options.model.prop) || 'value'\\n      const event = (options.model && options.model.event) || 'input'\\n      ;(data.attrs || (data.attrs = {}))[prop] = data.model.value\\n      const on = data.on || (data.on = {})\\n      const existing = on[event]\\n      const callback = data.model.callback\\n      if (isDef(existing)) {\\n        if (Array.isArray(existing) ? existing.indexOf(callback) === -1 : existing !== callback) {\\n          on[event] = [callback].concat(existing)\\n        }\\n      } else {\\n        on[event] = callback\\n      }\\n    }\\n    ```\\n6. extractPropsFromVNodeData：这里只是从传递个组件的数据（vnode.data.attrs || vnode.data.props）中提取属性值（组件定义的props）。这里返回的是一个新对象，该对象后面会变成响应式对象，以被当前组件监听。<br/>\\n    **注意：** 有个细节：从vnode.data.attrs中提取完数据，会对应的属性删除掉，而vnode.data.props则不会。\\n    - [ ] 为什么这么做呢❓❓❓❓\\n    ```js\\n    export function extractPropsFromVNodeData (data: VNodeData, Ctor: Class<Component>, tag?: string): ?Object {\\n      // we are only extracting raw values here.\\n      // validation and default values are handled in the child\\n      // component itself.\\n      const propOptions = Ctor.options.props\\n      if (isUndef(propOptions)) {\\n        return\\n      }\\n      const res = {}\\n      const { attrs, props } = data\\n      if (isDef(attrs) || isDef(props)) {\\n        for (const key in propOptions) {\\n          const altKey = hyphenate(key) \\n          checkProp(res, props, key, altKey, true) || checkProp(res, attrs, key, altKey, false)\\n        }\\n      }\\n      return res\\n    }\\n    ```\\n7. 如果是函数组件，则单独走函数组件vnode创建逻辑\\n8. 获取事件回调，自定义事件在data.on上，native事件在data.nativeOn，处理后自定义事件保存到vnode.componentOptions.listeners上，native事件保存到vnode.data.on上。（在 _init -> initEvent中会用到）\\n10. installComponentHooks：给 vnode.data 添加部分钩子(init、prepatch、insert、destroy)，后面会碰到每个vnode钩子调用的时机，碰到时在针对每个钩子细说。\\n11. 获取组件名称，创建组件标签对应的vnode(new vnode)，这里重点是保存了组件的数据（事件、属性数据等），因为在后面_update会深入组件内部，进入组件的渲染，而组件的渲染是需要这些数据支撑的。\\n\\n\\n\\n# 总结\\n创建虚拟DOM树，下一步就是调用vm._update将虚拟DOM树同步到界面上。\\n\\n下一节，重点分析虚拟DOM到界面的过程（包括初始化和更新）。\\n\\n\\n\\n",
        "tags": [
            "前端",
            "JavaScript",
            "Vue.js"
        ]
    },
    {
        "article_id": "7160670274521104397",
        "cover_image": "",
        "title": "我从 webpack 换到 vite，又换回了 webpack",
        "brief": "一次 webpack 到 vite 的失败迁移体验。`Vite` 经过一段时间的发展，目前的生态已经非常丰富了。所以就着手把项目的 `Webpack` 替换为 `Vite`。",
        "user_name": "ARRON",
        "view_count": 35111,
        "collect_count": 328,
        "comment_count": 89,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/9b87b704d6f7e9c481e69d04a45b9709~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: channing-cyan\\n---\\n\\n# 前言\\n\\n`Vite` 经过一段时间的发展，目前的生态已经非常丰富了。它不仅用于 `Vue`，`React`、`Svelte`、`Solid`、`Marko`、`Astro`、`Shopify Hydrogen`，以及 `Storybook`、`Laravel`、`Rails` 等项目都已经接入了`Vite`，而且也趋于稳定，所以就着手把项目的 `Webpack` 替换为 `Vite`。\\n\\n## 切换为 Vite\\n\\n`Vite` 生态现在很丰富了，基本上插件按名称搜索一下，照着文档就可以把 `webpack` 替换到 `Vite`。因为每个项目的配置都不一样，所以也没有什么统一的操作步骤，下面列一些典型替换的例子。\\n\\n### 入口\\n\\n`index.html` 的位置需要放到项目的最外层，而不是 `public` 文件夹内。同样 `entry` 的入口文件也需要从 `pages` 里换到 `index.html` 里。由 `<script type=\\\"module\\\" src=\\\"...\\\">` 引入。\\n```js\\nmodule.exports = defineConfig({\\n  pages: {\\n    index: {\\n      // page 的入口\\n      entry: 'src/main.ts',\\n      // 模板来源\\n      template: 'index.html',\\n      chunks: ['chunk-vendors', 'chunk-common', 'index']\\n    }\\n  }\\n})\\n```\\n```html\\n<!DOCTYPE html>\\n<html lang=\\\"en\\\">\\n  <head>\\n    <meta charset=\\\"utf-8\\\" />\\n    <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" />\\n    <meta name=\\\"viewport\\\" content=\\\"width=device-width,initial-scale=1.0\\\" />\\n    <link rel=\\\"icon\\\" href=\\\"/assets/favicon.ico\\\" />\\n  </head>\\n  <body>\\n    <div id=\\\"app\\\"></div>\\n    <script type=\\\"module\\\" src=\\\"/src/main.ts\\\"></script>\\n  </body>\\n</html>\\n```\\n\\n### 文件loader\\n这里挑几个例子(下面例子 webpack 版本都为 webpack5)。\\n1. `yaml` 由原来的 `yaml-loader` 替换为 `rollup-plugin-yamlx`\\n```js\\n    rules: [\\n      {\\n        test: /\\\\.ya?ml$/,\\n        use: 'yaml-loader'\\n      }\\n    ]\\n```   \\n```js\\nimport PluginYamlX from 'rollup-plugin-yamlx'\\n\\nplugins: [\\n  ...other,\\n  PluginYamlX()\\n]\\n```\\n2. `svg-sprite` 由原来的 `svg-sprite-loader` 替换为 `vite-plugin-svg-icons`\\n\\n```js\\nconst resolve = (...dirs) => require('path').resolve(__dirname, ...dirs)\\nchainWebpack(config) {\\n    const svgRule = config.module.rule('svg')\\n    svgRule.exclude.add(resolve('base/assets/icons')).end()\\n    config.module\\n      .rule('icons')\\n      .test(/\\\\.svg$/)\\n      .include.add(resolve('base/assets/icons'))\\n      .end()\\n      .use('svg-sprite-loader')\\n      .loader('svg-sprite-loader')\\n      .options({\\n        symbolId: 'ys-svg-[name]'\\n      })\\n      .end()\\n}\\n```\\n```ts\\nimport { createSvgIconsPlugin } from 'vite-plugin-svg-icons'\\nimport { resolve } from 'path'\\nconst pathResolve = (dir: string): string => {\\n  return resolve(__dirname, '.', dir)\\n}\\n\\nplugins: [\\n  ...other,\\n  createSvgIconsPlugin({\\n    // Specify the icon folder to be cached\\n    iconDirs: [pathResolve('base/assets/icons/svg')],\\n    // Specify symbolId format\\n    symbolId: 'ys-svg-[name]'\\n  }),\\n]\\n```\\n3. 注意文件加载方式的一致性，比如原来的 `svg-loader` 直接 `import` 引用的是路径地址，而 `vite-svg-loader` 默认是 `Vue` 组件。\\n所以 `Vite` 需要把默认方式改成和 `webpack lodaer` 一致。\\n```ts\\nplugins: [\\n  svgLoader({ defaultImport: 'url' })\\n]\\n```\\n> 每个替换的插件都要看一下文档，也许某个配置就是你需要的功能。\\n\\n### 全局常量\\n比如开发的版本信息，开发环境变量等等。\\n```js\\nnew webpack.DefinePlugin({\\n  APP_VERSION: process.env.VUE_APP_VERSION,\\n  ENV_TEST: process.env.VUE_ENV_TEST\\n})\\n```\\n```ts\\nimport { defineConfig, loadEnv } from 'vite'\\nconst { VITE_SENV_TEST, VITE_APP_VERSION } = loadEnv(mode, process.cwd())\\nexport default ({ mode }: { mode: string }) => {\\n  return defineConfig({\\n    define： {\\n      APP_VERSION： VITE_APP_VERSION，\\n      ENV_TEST：VITE_SENV_TEST\\n    }\\n  })\\n})\\n```\\n> 这里注意，Vite 和 webpack 默认暴露的环境变量前缀不一样。\\n### 自动加载模块\\n比如 `lodash`\\n```js\\nplugins: [\\n  new webpack.ProvidePlugin({\\n    _: 'lodash'\\n  }),\\n]\\n```\\n```ts\\nimport inject from '@rollup/plugin-inject'\\n\\nplugins: [\\n  inject({\\n    _: 'lodash',\\n    exclude: ['**/*.css', '**/*.yaml'],\\n    include: ['**/*.ts', '**/*.js', '**/*.vue', '**/*.tsx', '**/*.jsx']\\n  }),\\n]\\n```\\n> 基本上所有在用的插件都可以找到对应替换的，甚至像 `monaco`，`qiankun`，`sentry`使用量相对没那么大的都有。\\n\\n> 这里只是举例兼容旧代码，lodash 最好还是写个工具替换成 es-loadsh。\\n\\n### webpack require context\\n\\n在 webpack 中我们可以通过 `require.context` 方法**动态**解析模块。比较常用的一个做法就是指定某个目录，通过正则匹配等方式加载某些模块，这样在后续增加新的模块后，可以起到**动态自动导入**的效果。\\n\\n比如 `layout，router` 的自动注册都可以这样用。\\n```js\\nconst modules = require.context('base/assets/icons/svg', false, /\\\\.svg$/)\\n```\\n\\nVite 支持使用特殊的 `import.meta.glob` 函数从文件系统导入多个模块：\\n```js\\nconst modules = import.meta.glob('base/assets/icons/svg/*.svg')\\n```\\n\\n### externals\\n```js\\nexternals: {\\n  config: 'config',\\n}\\n```\\n```ts\\nimport { viteExternalsPlugin } from 'vite-plugin-externals'\\n\\nplugins: [\\n  viteExternalsPlugin({\\n    config: 'config'\\n  })\\n]\\n```\\n\\n### ESM 模块\\n\\n由于 `Vite` 使用了 ESM 模块方式，所以 `commonJs模块` 都需要替换成 `ESM模块`。\\n\\n```js\\nconst path = require('path')\\n\\nimport path from 'path'\\n```\\n> 也正是因为这个原因，所以才会又换回了 webpack，这个下面再讲。\\n\\n### 自动化转换\\n\\n社区也有一些自动化从`Wepback`转为`Vite`的工具，比如[vue-cli-plugin-vite](https://github.com/IndexXuan/vue-cli-plugin-vite)，[webpack-to-vite](https://github.com/originjs/webpack-to-vite)，[wp2vite](https://github.com/tnfe/wp2vite)等等。\\n\\n如果是小项目，可以尝试一下。大项目不建议使用，不可控。感兴趣的可以去看对应的文档。\\n\\n## ESM 的循环引用问题\\n\\n可以看到 `Vite` 的 `Issues` 有很多相关的问题讨论。\\n\\nhttps://github.com/vitejs/vite/issues/5439 https://github.com/vitejs/vite/issues/4430\\n\\n如果是 Vue SFC 文件的循环引用，按官方文档来就可以解决。\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a40907016a8644959749853de9cf7cdf~tplv-k3u1fbpfcp-watermark.image?)\\n\\n如果是其他文件的循环引用，也可以梳理更改。但是吊诡的地方在于，调用栈会出现 `null`。这个在开发中出现了根本没办法`debug`。有时候有上下文，只是中间出现`null`还能推断一下，如果提示一串`null`，那根本没办法开发。\\n\\n![NCl9q2URwr.jpg](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dbab68a139844d5a87403ce3c73977ae~tplv-k3u1fbpfcp-watermark.image?)\\n\\n> CommonJs 与 ESM 对于循环依赖的处理的策略是截然不同的，webpack 在运行时注入的 **webpack_require** 逻辑在处理循环依赖时的表现与 CommonJs 规范一致。Webapck 根据 moduleId，先到缓存里去找之前有没有加载过，如果有加载过，就直接拿缓存中的模块。如果没有，就新建一个 module，并赋值给缓存中，然后调用 moduleId 模块。所以由于缓存的存在，出现循环依赖时才不会出现无限循环调用的情况。\\n> \\n> 由于 ESM 的静态 import 能力，可以在代码运行之前对依赖链路进行静态分析。所以在 ESM 模式下，一旦发现循环依赖，ES6 本身就不会再去执行依赖的那个模块了，所以程序可以正常结束。这也说明了 ES6 本身就支持循环依赖，保证程序不会因为循环依赖陷入无限调用。\\n\\n正是因为处理机制的不同，导致 `Vite` 下循环引用的文件都会出现调用栈为 `null` 的情况。\\n\\n找了个`webpack`插件`circular-dependency-plugin` 检查了一下循环引用的文件，发现像下面这样跨多组件引用的地方有几十处。改代码也不太现实，只能先换回`webpack`了。\\n\\n![origin_img_v2_b82d566d-9648-4d7a-b090-da969e69055g.jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b0e44d8c182473b9d1a63c6aeeeb56f~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## webpack 的优化\\n\\n`webpack` 还是用官方封装的 `Vue CLI`。\\n\\n\\n### 缓存\\n\\n`webpack4` 还是使用 `hard-source-webpack-plugin` 为模块提供中间缓存的，但是 `webpack5` 已经内置了该功能。\\n\\n```ts\\nmodule.exports = {\\n  chainWebpack(config) {\\n    config.cache(true)\\n  }\\n}\\n```\\n> `hard-source-webpack-plugin` 作者已经被 `webpack` 招安了，原插件也已经不维护了，所以有条件还是升级到 `webpack5` 。\\n\\n### esbuild 编译\\n编译可以使用 `esbuild-loader` 来替换 `babel-loader`，打包这一块就和 `Vite` 相差不多了。\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5d9353b58d56469885e16a697f28ab26~tplv-k3u1fbpfcp-watermark.image?)\\n\\n看了下 `vue-cli` 的配置，需要换的 `rule` 是这几个。大概的配置如下：\\n\\n```ts\\nchainWebpack(config) {\\nconst rule = config.module.rule('js')\\n    // 清理自带的babel-loader\\n    rule.uses.clear()\\n    // 添加esbuild-loader\\n    rule\\n      .use('esbuild-loader')\\n      .loader('esbuild-loader')\\n      .options({\\n        jsxFactory: 'h',\\n\\tjsxFragment: 'Fragment',\\n\\tloader: 'jsx',\\n\\ttarget: 'es2015'\\n      })\\n      .end()\\n\\nconst tsRule = config.module.rule('typescript')\\n    tsRule.uses.clear()\\n\\n    tsRule\\n      .use('ts')\\n      .loader('esbuild-loader')\\n      .end()\\n}\\n```\\n> 注意，上面的 `jsx` 配置只适用于 `Vue3`，因为 `Vue2` 没有暴露 `h` 方法。\\n\\n如果要在 `Vue2` 上使用 `jsx` 解析，得需要一个解析 `Vue2` 语法完整运行时的包。  \\n`pnpm i @lancercomet/vue2-jsx-runtime -D`\\n> [React 关于全新 JSX 转换的思想](https://zh-hans.reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html)  \\n[@lancercomet/vue2-jsx-runtime github](https://github.com/LancerComet/vue2-jsx-runtime)\\n\\n大概就是把 `jsx transform` 从框架单独移了出来，以脱离框架适配 `SWC`，`TSC` 或者 `ESBuild` 的 `jsx transform`。\\n```\\n    const rule = config.module.rule('js')\\n    // 清理自带的babel-loader\\n    rule.uses.clear()\\n    // 添加esbuild-loader\\n    rule\\n      .use('esbuild-loader')\\n      .loader('esbuild-loader')\\n      .options({\\n        target: 'es2015',\\n        loader: 'jsx',\\n        jsx: 'automatic',\\n        jsxImportSource: '@lancercomet/vue2-jsx-runtime'\\n      })\\n      .end()\\n```\\n同时需要修改 `tsconfig.json`\\n```\\n{\\n  \\\"compilerOptions\\\": {\\n    ...\\n    \\\"jsx\\\": \\\"react-jsx\\\",  // Please set to \\\"react-jsx\\\". \\n    \\\"jsxImportSource\\\": \\\"@lancercomet/vue2-jsx-runtime\\\"  // Please set to package name.\\n  }\\n}\\n```\\n### 类型检查\\n类型检查这块开发时可以交给 `IDE` 来处理，没必要再跑一个线程。\\n\\n```ts\\n  chainWebpack(config) {\\n    // disable type check and let `vue-tsc` handles it\\n    config.plugins.delete('fork-ts-checker')\\n  }\\n```\\n### 代码压缩\\n这些其实性能影响已经不大了，聊胜于无。\\n```ts\\nconst { ESBuildMinifyPlugin } = require('esbuild-loader')\\n  chainWebpack(config) {\\n    config.optimization.minimizers.delete('terser')\\n    config.optimization.minimizer('esbuild').use(ESBuildMinifyPlugin, [{ minify: true, css: true }])\\n  }\\n```\\n\\n### 优化结果\\n\\n这是 `Vue-CLI` 优化之后的打包，已经和 `Vite` 基本一致了。至于开发，两者的逻辑不一样，热更新确实是慢。\\n\\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2ead921cf4349dfaf0849e0e5d63248~tplv-k3u1fbpfcp-watermark.image?)\\n\\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2959622e4cab4410a08c3e8ef5957ac0~tplv-k3u1fbpfcp-watermark.image?)\\n\\n# 结束\\n`Vite` 的生态已经很丰富了，基本能满足绝大多数的需求了。我们这次迁移由于平时开发遗留的一些问题而失败了。应该反省平时写代码不能只为了快，而忽略一些细节。\\n\\n\\n这就是本篇文章的全部内容了，感谢大家的观看。\\n\\n",
        "tags": [
            "前端",
            "Vue.js",
            "Vite"
        ]
    },
    {
        "article_id": "7185413265789288507",
        "cover_image": "https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4af5f55f0aac467d898b5f13e1df9f01~tplv-k3u1fbpfcp-watermark.image?",
        "title": "用Three.js做个兔吉宝箱给大家拜个年",
        "brief": "不知不觉兔年已经来到，今年用什么形式庆贺新春呢，思来想去，就准备用Three.js做个拜年宝箱动画，宝箱落下后点击就可以打开，一直萌萌哒的小兔吉就给我拜年啦，而且每次说出的贺词都是不同的哦~",
        "user_name": "jsmask",
        "view_count": 6250,
        "collect_count": 119,
        "comment_count": 29,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/3cc923506359b8170e1d8b9051bb2bef~300x300.image",
        "category": "前端",
        "content": "---\\ntheme: qklhk-chocolate\\n---\\n我正在参加「兔了个兔」创意投稿大赛，详情请看：[「兔了个兔」创意投稿大赛](https://juejin.cn/post/7185104994801025061)”\\n\\n## 介绍\\n\\n不知不觉兔年已经来到，今年用什么形式庆贺新春呢，思来想去，就准备用Three.js做个拜年宝箱动画，宝箱落下后点击就可以打开，一直萌萌哒的小兔吉就给我拜年啦，每次说出的贺词都是不同的，所以我把这个宝箱命名为兔吉宝箱~\\n\\n## 演示\\n\\n![演示.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f17dcd1db54b404d923ee5b76593db50~tplv-k3u1fbpfcp-watermark.image?)\\n\\n> 演示地址： https://jsmask.gitee.io/rabbit-lucky-chest\\n>\\n> 源码地址：https://gitee.com/jsmask/rabbit-lucky-chest\\n\\n## 正文\\n\\n### 基础搭建\\n\\n本项目将使用vite4来实现：\\n\\n```sh\\nyarn create vite\\n```\\n\\n起好项目名，选择vue3后，就构建成功一个基础项目了。\\n\\n再配置一下 `vite.config.js` 文件，拿些文件的时候至少得要个别名吧，因为项目也比较小，目前就简单配置了。\\n\\n```js\\nimport { defineConfig } from 'vite'\\nimport vue from '@vitejs/plugin-vue'\\nimport { resolve } from \\\"path\\\"\\n\\n// https://vitejs.dev/config/\\nexport default defineConfig({\\n  base:\\\"./\\\",\\n  server: {\\n    host: '0.0.0.0',\\n    open: false,\\n  },\\n  resolve: {\\n    alias: {\\n      \\\"@\\\": resolve(__dirname, \\\"src\\\")\\n    }\\n  },\\n  plugins: [vue()],\\n})\\n\\n```\\n\\n当然这还远远不够，我们还要安装scss来为更好的书写样式:\\n\\n```sh\\nyarn add scss -D\\n```\\n\\n这里我还安装了 `reset.css` ，目的是清除一些浏览器的默认样式。\\n\\n```sh\\nyarn add reset.css\\n```\\n\\n而且导入在 style.scss 里，然后可以在里面写一些定义的公共样式。最后把 `style.scss` 直接再导入到 `main.js` 中。\\n\\n```scss\\n// style.scss\\n@import url(\\\"reset.css\\\");\\n// ...\\n```\\n\\n为了更方便的获取一些资源，我们还要把资源文件放置到 `public` 文件夹中，这样我们就可以直接用音频，图片，模型这些资源了。\\n\\n![目录.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0680ccc879104c848e54f0f0e1065e86~tplv-k3u1fbpfcp-watermark.image?)\\n\\n### 场景搭建\\n\\n这个项目一共分两个场景，一个是刚进来默认的初始确认场景，一个是3D动画的主场景，主要实现的业务代码还是比较多的，详细请看上面的源码。\\n\\n![初始.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/424e08516d6f4de8ab1d3415c47285fa~tplv-k3u1fbpfcp-watermark.image?)\\n\\n初始场景就是非常普通页面，就是用css写一个闪动的文字动画，然后监听键盘和鼠标当按下后，闪动加快一段时间后就跳入到3D动画的场景中。\\n\\n加入这个初始默认场景的主要目的有三个，第一让用户点击后实现了交互激活音效功能，第二让用户有个准备不要一上来就开始了失去了趣味，第三点因为里面的音效有四个资源这里希望在默认来的时候先加载他们不至于后面播放不出来。\\n\\n```js\\n// audio.js\\nexport let AUDIODATA = {\\n    BGMMAIN: \\\"assets/audio/bgm.mp3\\\",\\n    PRESS:\\\"assets/audio/press.mp3\\\",\\n    OPEN: \\\"assets/audio/open.mp3\\\",\\n    FADE:\\\"assets/audio/fade.mp3\\\",\\n}\\n\\nlet bgm = new Audio();\\nbgm.src = AUDIODATA.BGMMAIN\\n\\nexport function playBGM(continuate = true) {\\n    if (!continuate) bgm.currentTime = 0;\\n    bgm.volume = 60 / 100;\\n    bgm.loop = true;\\n    bgm.play();\\n    return bgm\\n}\\n\\nexport function stopBGM() {\\n    if (!bgm) return;\\n    bgm.paused();\\n    bgm.currentTime = 0;\\n}\\n\\n// ...\\n```\\n\\n![动画场景.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/74133222342f48c3ae4c26a1d822b2d5~tplv-k3u1fbpfcp-watermark.image?)\\n\\n接下来就是3D动画的场景，要做3D首先安装 `three.js` \\n\\n```sh\\nyarn add three\\n```\\n\\n然后写一个脚本文件 `index.js` 引入将`three.js` 其中，这个文件也是我们的主逻辑脚本，其中会实现一个 `Game` 的类，在这个里面我们将实现场景初始化，引入摄像机灯光模型等 ，后面会将这个类实例化，传入到显示容器中。\\n\\n```js\\n// game/index.js\\nimport * as THREE from \\\"three\\\"\\nexport default class Game {\\n    constructor(parentEl) {\\n        this.parentEl = parentEl;\\n        this.init();\\n    }\\n    init(){\\n        this.renderer = new THREE.WebGLRenderer({\\n            antialias: true,\\n        });\\n        this.renderer.outputEncoding = THREE.sRGBEncoding;\\n        this.renderer.gammaFactor = 3;\\n        this.renderer.shadowMap.enabled = true;\\n        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;\\n        this.renderer.setPixelRatio(window.devicePixelRatio);\\n        this.renderer.setSize(window.innerWidth, window.innerHeight);\\n        this.renderer.domElement.id = \\\"game-canvas\\\"\\n        this.parentEl.appendChild(this.renderer.domElement);\\n        // ...\\n    }\\n    // ...\\n}\\n```\\n\\n```vue\\n<!--MainScene.vue-->\\n<template>\\n\\t<div ref=\\\"gameRef\\\" class=\\\"main-game\\\"></div>\\n</template>\\n\\n<script setup>\\n    import { ref, onMounted, onUnmounted } from \\\"vue\\\"\\n    import { playBGM } from \\\"@/game/audio\\\"\\n    const gameRef = ref(null)\\n    let game;\\n    onMounted(() => {\\n        playBGM();\\n        game = new Game(gameRef.value)\\n    })\\n    onUnmounted(() => {\\n        game.destroy()\\n    })\\n</script>    \\n```\\n\\n### 场景切换\\n\\n场景有了但是我们这么快速的切换呢，此时很多人都直接使用vue-router来切换。但是考虑目前项目只有两个场景到是可以不使用，这样减少了一个库，减少了资源的使用。二来路由切换后地址栏会有杂质。而且我们还没有对游戏一些自定义配置需要用到状态管理类的库，不如就用状态管理暂时充当路由使用，反正就俩场景，用 `v-if` 控制好了。\\n\\n```vue\\n<!--App.vue-->\\n<script setup>\\nimport PressScene from \\\"./view/PressScene.vue\\\"\\nimport MainScene from \\\"./view/MainScene.vue\\\"\\nimport { useSystemStore } from \\\"@/store/system\\\";\\nconst store = useSystemStore();\\n</script>\\n\\n<template>\\n    <press-scene v-if=\\\"store.scene == 'press'\\\" />\\n    <main-scene v-if=\\\"store.scene == 'play'\\\" />\\n</template>\\n```\\n\\n当然，可以看到系统管理我们用到了 `pinia` 。\\n\\n先安装一下：\\n\\n```sh\\nyarn add pinia\\n```\\n\\n再写一个专门管理系统状态的文件：\\n\\n```js\\n// system.js\\nimport { defineStore } from 'pinia'\\n\\nconst defaultState = {\\n    scene: \\\"press\\\",\\n}\\n\\nexport const useSystemStore = defineStore('system', {\\n    state: () => {\\n        return {\\n            ...defaultState\\n        };\\n    },\\n    actions: {\\n        changeScene(sceneName) {\\n            this.scene = sceneName;\\n        },\\n    }\\n})\\n```\\n\\n目前还是比较简单，就是单纯的控制场景是哪一个，当然你还可以加一些别的配置比如音量或者播放速度的控制等等。\\n\\n每次切换场景只要通知一些系统，状态要改变了，场景就会发生变化。\\n\\n```js\\n// PressScene.vue\\nwindow.addEventListener(\\\"keydown\\\", handleClick)\\nfunction handleClick() {\\n    store.changeScene(\\\"play\\\")\\n    window.removeEventListener(\\\"keydown\\\", handleClick)\\n}\\n```\\n\\n### 模型加载\\n\\n加载和导入模型，我们以宝箱为例：\\n\\n```js\\nimport * as THREE from \\\"three\\\"\\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader';\\nimport bus from \\\"./bus\\\"\\n\\nexport default class Chest {\\n    constructor(game) {\\n        this.game = game;\\n        this.scene = game.scene;\\n        this.camera = game.camera;\\n        this.target = null;\\n        this.isOpen = false;\\n        this.state = \\\"wait\\\"\\n        this.init();\\n    }\\n    init() {\\n        let loader = new GLTFLoader();\\n        loader.load(\\\"./assets/mod/chest/scene.gltf\\\", gltf => {\\n            this.target = gltf.scene;\\n            this.animations = gltf.animations;\\n            this.target.scale.set(.005, .005, .005);\\n            this.target.position.set(0, 5, 0)\\n            this.target.traverse(c => {\\n                c.castShadow = true;\\n                c.receiveShadow = true;\\n                if (c.material && c.material.map) {\\n                    c.material.map.encoding = THREE.sRGBEncoding;\\n                }\\n            });\\n            this.mixer = new THREE.AnimationMixer(this.target);\\n            this.mixer.addEventListener('finished', this.finishedAnimation.bind(this));\\n            this.scene.add(this.target);\\n            bus.$emit(\\\"loaded\\\",\\\"chest\\\")\\n        }\\n    }\\n    // ...\\n}\\n```\\n\\n因为宝箱模型是gltf格式的，所以通过实例化 `GLTFLoader` 来实现一个Loader。通过load方法来传入地址来加载它，这里要注意地址要设置成相对路径。加载成功后会就可以拿到模型信息，此时你可以设置该模型的大小位置方向等等，当然这个模型是有动画的所有我们还要保存一下它动画的信息。\\n\\n模型对象有 `traverse` 可以对此模型进行遍历，这里是对其添加一些阴影设置，当然如果有需要还可以更换材质节点等等操作。\\n\\n最后，你会发现我们这里自定义了一个bus作为来发布订阅一些消息，这里是把该模型的加载的消息发出去。然后主逻辑获取这些信息。\\n\\n发布订阅我们使用了 `mitt.js` 库来实现。\\n\\n```js\\n// bus.js\\nimport mitt from \\\"mitt\\\";\\n\\nconst bus = {};\\nconst emitter = mitt();\\n\\nbus.$on = emitter.on;\\nbus.$off = emitter.off;\\nbus.$emit = emitter.emit;\\n\\nexport default bus;\\n```\\n\\n这样在主逻辑脚本中，可以接收到加载完的消息从而通知界面逻辑。\\n\\n```js\\n// game/index.js\\nconst loadModNameList = []\\nbus.$on(\\\"loaded\\\", (name) => {\\n    loadModNameList.push(name)\\n    bus.$emit(\\\"progress\\\", ~~(loadModNameList.length / 3 * 100))\\n    if (loadModNameList.length >= 3) {\\n        setTimeout(()=>{\\n            this.chest.playGame()\\n        },500)\\n    }\\n})\\n```\\n\\n![出来.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf27f8c656a2412ea0cbedfb03bfe30d~tplv-k3u1fbpfcp-watermark.image?)\\n\\n### 宝箱选中\\n\\n这个3D动画其中一个交互是你要点击宝箱后才能打开，小兔吉出来拜年，那么怎么才能判断你点中了宝箱模型呢？其实非常简单，只要你绑定好点击事件，点击画面后就可以拿到坐标将其变成三维坐标，再根据摄像机位置，实例出 `THREE.Raycaster` 在场景中发出一道射线会捕获到经过的物体，然后根据这些物体遍历，如果其中有的物体属于宝箱的，那么就意味着刚才的点击就选中了宝箱模型。然后就可以对其发出打开等指令操作了。\\n\\n```js\\nexport default class Chest {  \\n\\tbindEvent() {\\n        window.addEventListener(\\\"mouseup\\\", this.handleClick.bind(this));\\n        window.addEventListener(\\\"touchend\\\", this.handleClick.bind(this))\\n    }\\n    handleClick(e) {\\n        let vector = new THREE.Vector3();\\n        vector.set(\\n            (e.clientX / window.innerWidth) * 2 - 1,\\n            -(e.clientY / window.innerHeight) * 2 + 1,\\n            0.5);\\n        vector.unproject(this.camera);\\n        let raycaster = new THREE.Raycaster(this.camera.position, vector.sub(this.camera.position).normalize());\\n        let intersects = raycaster.intersectObjects(this.scene.children);\\n        let isActive = false;\\n        // 遍历射线是否经过宝箱\\n        for (const item of intersects) {\\n            this.target.traverse(c => {\\n                if (c == item.object) isActive = true;\\n            })\\n        }\\n        // 如果选中并且没有打开就直接打开指令打开宝箱\\n        if (isActive && this.state == \\\"wait\\\" && !this.isOpen) {\\n            this.open();\\n        }\\n    }\\n}    \\n```\\n\\n![1.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b6df5c1dadb3476d94e108291c6e8fd2~tplv-k3u1fbpfcp-watermark.image?)\\n\\n### 模型动画\\n\\n还是以宝箱模型打开动画为例，当初模型加载完成的时候，已经把模型信息里的动画存储下来放到了 `animations` 中。\\n\\n```js\\nexport default class Chest {  \\n\\topen() {\\n        console.log(\\\"open begin\\\")\\n        this.isOpen = true;\\n        bus.$emit(\\\"open\\\")\\n        playSeOpen()\\n        this.mixer.stopAllAction();\\n        let anim = this.animations[0]\\n        let curAction = this.mixer.clipAction(anim);\\n        curAction.enabled = true;\\n        curAction.time = 0.0;\\n        curAction.clampWhenFinished = true;\\n        curAction.setEffectiveTimeScale(1.0);\\n        curAction.setEffectiveWeight(1.0);\\n        curAction.setLoop(THREE.LoopOnce, 1);\\n        curAction.play();\\n    }   \\n}\\n```\\n\\n我们先拿到所需要的打开动画 `anim` ,在动画混合器 `mixer`中，设置当前动画的动作。因为打开动画是只播放一次不需要去循环播放，所以就要设置它循环次数为1，当然还有很多细节上的设置要去调整，之后就可以使用 `play` 方法播放了。\\n\\n最后别忘了，动画每一帧都是需要更新才会有效果的。\\n\\n```js\\nexport default class Chest {     \\n\\tupdate(delta) {\\n        this.mixer && this.mixer.update(delta);\\n    }\\n}\\n```\\n\\n![2.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c27ccb4267e473b980b199afbb6c535~tplv-k3u1fbpfcp-watermark.image?)\\n\\n### 缓动动画\\n\\n这个3d世界中所有缓动动画比如宝箱下落回弹，摄像机视角的前进，都是使用gsap.js来实现的，所以先安装一下：\\n\\n```sh\\nyarn add gsap\\n```\\n\\n这里用到了gsap的时间线动画，非常简单就是实例化 `gsap.timeline` ，在某个阶段用什么缓动效果持续多久实现某个动画，结束之后会怎么都可以轻松设置。\\n\\n```js\\nimport gsap, { Bounce } from \\\"gsap\\\"\\nexport default class Chest {  \\n\\tplayGame(){\\n        this.runTimeLine();\\n    }\\n    runTimeLine() {\\n        this.timer = new gsap.timeline({\\n            defaults: { duration: 0 },\\n        });\\n        playSeFade()\\n        this.timer.to(\\n            this.target.position,\\n            {\\n                duration: 1,\\n                y: 0,\\n                ease: Bounce.easeOut,\\n                onComplete: () => {\\n                    this.rabbit.setVisible(true)\\n                },\\n            }\\n        );\\n        this.timer.to(\\n            this.camera.position,\\n            {\\n                duration: 1.2,\\n                z: 2.4,\\n                onComplete: () => {\\n                    this.bindEvent();\\n                },\\n            },\\n            1.5\\n        );\\n    }\\n}\\n```\\n\\n![4.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e6d7278ab3d4faab0aa65d1b5791c29~tplv-k3u1fbpfcp-watermark.image?)\\n\\n### 贺词动效\\n\\n贺词是做css来实现，因为打开宝箱后镜头会固定住完全可以在指定位置做文字动画，又不用再引入3D字体模型来增加资源消耗。\\n\\n![贺词.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/66627bc72b574a20a06585d4c59b7b56~tplv-k3u1fbpfcp-watermark.image?)\\n\\n当然，你会发现这些文字动画，每个文字都带了些角度偏移，从而整个贺词形成拱形。这里就不得不夸赞用scss来快速实现这个样式了。\\n\\n```scss\\n@use 'sass:math';\\n$color: rgb(255, 201, 101);\\n$border-width: 2px;\\n$border-color: #000;\\n$num: 9;\\n$deg: 12deg;\\n$delay: 350ms;\\n\\nh1 {\\n        position: relative;\\n        display: flex;\\n        justify-content: center;\\n        align-items: center;\\n        color: $color;\\n        letter-spacing: #{$border-width * 1.5};\\n        -webkit-text-stroke-color: $border-color;\\n        -webkit-text-stroke-width: $border-width;\\n        font-size: 12px;\\n        position: absolute;\\n        left: 50%;\\n        top: 50%;\\n        transform: translate(-50%, -235px);\\n\\n        &>span {\\n            position: absolute;\\n            font-size: 4.2em;\\n            font-weight: bolder;\\n            transform-origin: 50% #{$num * .85em};\\n\\n            @for $i from 0 through $num {\\n                &:nth-child(#{$i + 1}) {\\n                    transform: rotate(#{$deg * $i - (floor(math.div($num,2))+0.1) * $deg});\\n                    z-index: #{$num - $i};\\n                    animation: show 0.4s backwards;\\n                    animation-delay: #{$i * $delay + 1500};\\n                }\\n            }\\n\\n            @keyframes show {\\n                0% {\\n                    font-size: 6em;\\n                    filter: blur(0.1em);\\n                    opacity: 0;\\n                }\\n\\n                80% {\\n                    font-size: 3.6em;\\n                    filter: blur(0.001em);\\n                    opacity: 1;\\n                }\\n\\n                100% {\\n                    font-size: 4.2em;\\n                    filter: blur(0);\\n                    opacity: 1;\\n                }\\n            }\\n        }\\n}\\n```\\n\\n通过 `scss` 的 `@for` 去遍历每一个文字，然后设置他们的偏移角度和动画的延迟等，可以轻轻松松完成这个贺词动画。\\n\\n![3.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7074efbe7f7b42a9bf4305179ce89652~tplv-k3u1fbpfcp-watermark.image?)\\n\\n## 结语\\n\\n本篇算是比较基础的带小伙伴们进入web的3d世界的搭建和交互，介绍了一些库的组合与使用，希望各位会喜欢，也希望各位也发挥想象力实现更加惊艳的效果。\\n\\n这是今年的第一篇文章，希望大家多点赞多鼓励，来年争取将更好的作品带来。新的一年，希望大家健健康康，阖家欢乐，兔年大吉。\\n\\n",
        "tags": [
            "前端",
            "three.js",
            "JavaScript"
        ]
    },
    {
        "article_id": "7151221875224346637",
        "cover_image": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da64f164dff44fc0b4665ae732c9d788~tplv-k3u1fbpfcp-watermark.image?",
        "title": "2022年我的面试万字总结（代码篇）",
        "brief": "又到了金九银十季，最近我也是奔波于各种面试。我自己总结整理了很多方向的前端面试题。借着国庆这个假期，也把这些题目总结分享给大家，也祝正在面试的朋友们能够拿到满意的offer。",
        "user_name": "逍丶",
        "view_count": 16365,
        "collect_count": 788,
        "comment_count": 21,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/a87f08adcd0dad907726396180915552~300x300.image",
        "category": "前端",
        "content": "---\\nhighlight: arduino-light\\ntheme: orange\\n---\\n持续创作，加速成长！这是我参与「掘金日新计划 · 10 月更文挑战」的第6天，[点击查看活动详情](https://juejin.cn/post/7147654075599978532 \\\"https://juejin.cn/post/7147654075599978532\\\")\\n\\n# 前言\\n\\n又到了金九银十季，最近我也是奔波于各种面试。我自己总结整理了很多方向的前端面试题。借着国庆这个假期，也把这些题目总结分享给大家，也祝正在面试的朋友们能够拿到满意的offer。\\n# 往期文章\\n（1）[ 2022年我的面试万字总结（浏览器网络篇）](https://juejin.cn/post/7149438206419664927)\\n\\n（2）[ 2022年我的面试万字总结（CSS篇）](https://juejin.cn/post/7149716216167268366)\\n\\n（3）[  2022年我的面试万字总结（HTML篇）](https://juejin.cn/post/7150109570609152014)\\n\\n（4）[ 2022年我的面试万字总结（JS篇上） ](https://juejin.cn/post/7150462512817782815)\\n\\n（5）[ 2022年我的面试万字总结（JS篇下）](https://juejin.cn/editor/drafts/7150847615263834119)\\n\\n（7）[ 2022年我的面试万字总结（Vue上）](https://juejin.cn/post/7151597651719356446)\\n\\n（8）[ 2022年我的面试万字总结（Vue下）](https://juejin.cn/post/7151604799077613599)\\n\\n（9）[ 2022年我的面试万字总结（Vue3+TS）](https://juejin.cn/post/7160962909332307981)\\n \\n （10）[ 2022年我的面试万字总结（Node、webpack、性能优化）](https://juejin.cn/post/7161292246526984228)\\n  \\n（11）[ 2022年我的面试万字总结（小程序、git）](https://juejin.cn/post/7161584249898795045)\\n\\n# 一、手写代码题\\n## 1. 手写Object.create\\n\\n思路：将传入的对象作为原型\\n\\n```\\nfunction create(obj) {\\n  function F() {}\\n  F.prototype = obj\\n  return new F()\\n}\\n```\\n\\n## 2. 手写instanceof\\n\\ninstanceof 运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。\\n\\n实现步骤：\\n\\n0.  首先获取类型的原型\\n0.  然后获得对象的原型\\n0.  然后一直循环判断对象的原型是否等于类型的原型，直到对象原型为 `null`，因为原型链最终为 `null`\\n\\n```\\nfunction myInstanceof(left, right) {\\n  let proto = Object.getPrototypeOf(left), // 获取对象的原型\\n      prototype = right.prototype; // 获取构造函数的 prototype 对象\\n​\\n  // 判断构造函数的 prototype 对象是否在对象的原型链上\\n  while (true) {\\n    if (!proto) return false;\\n    if (proto === prototype) return true;\\n​\\n    proto = Object.getPrototypeOf(proto);\\n  }\\n}\\n```\\n\\n## 3. 手写 new\\n\\n（1）首先创建了一个新的空对象\\n\\n（2）设置原型，将对象的原型设置为函数的 prototype 对象。\\n\\n（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）\\n\\n（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。\\n\\n```\\n function myNew(fn, ...args) {\\n      // 判断参数是否是一个函数\\n      if (typeof fn !== \\\"function\\\") {\\n        return console.error(\\\"type error\\\");\\n      }\\n      // 创建一个对象，并将对象的原型绑定到构造函数的原型上\\n      const obj = Object.create(fn.prototype);\\n      const value = fn.apply(obj, args); // 调用构造函数，并且this绑定到obj上\\n      // 如果构造函数有返回值，并且返回的是对象，就返回value ;否则返回obj\\n      return value instanceof Object ? value : obj;\\n    }\\n```\\n\\n## 4. 手写promise(简易版)\\n\\n```\\nclass MyPromise {\\n  constructor(fn){\\n    // 存储 reslove 回调函数列表\\n    this.callbacks = []\\n    const resolve = (value) => {\\n      this.data = value // 返回值给后面的 .then\\n      while(this.callbacks.length) {\\n        let cb = this.callbacks.shift()\\n        cb(value)\\n      }\\n    }\\n    fn(resolve)\\n  }\\n  then(onResolvedCallback) {\\n    return new MyPromise((resolve) => {\\n      this.callbacks.push(() => {\\n        const res = onResolvedCallback(this.data)\\n        if (res instanceof MyPromise) {\\n          res.then(resolve)\\n        } else {\\n          resolve(res)\\n        }\\n      })\\n    })\\n  }\\n}\\n// 这是测试案例\\nnew MyPromise((resolve) => {\\n  setTimeout(() => {\\n    resolve(1)\\n  }, 1000)\\n}).then((res) => {\\n    console.log(res)\\n    return new MyPromise((resolve) => {\\n      setTimeout(() => {\\n        resolve(2)\\n      }, 1000)\\n    })\\n}).then(res =>{console.log(res)})\\n```\\n\\n### 4.2 Promise.all\\n\\n```\\nMyPromise.all = function (promisesList) {\\n  return new MyPromise((resolve, reject) => {\\n    if (!Array.isArray(promiselList) return reject(new Error('必须是数组'))\\n    if (!promisesList.length) return resolve([])\\n    let arr = [], count = 0\\n    // 直接循环同时执行传进来的promise\\n    for (let i = 0, len = promisesList.length; i < len; i++) {\\n      // 因为有可能是 promise 有可能不是，所以用resolve()不管是不是都会自动转成promise\\n      Promise.resolve(promise).then(result => {\\n          // 由到promise在初始化的时候就执行了，.then只是拿结果而已，所以执行完成的顺序有可能和传进来的数组不一样\\n          // 也就是说直接push到arr的话，顺序有可能会出错\\n          count++\\n          arr[i] = result\\n          // 不能用arr.length===len，是因为数组的特性\\n          // arr=[]; arr[3]='xx'; console.log(arr.length) 这打印出来会是4 而不是1\\n          if(count === len) resolve(arr)\\n      }).catch(err => reject(err))\\n    }\\n  })\\n}\\n```\\n\\n### 4.3 Promise.race\\n\\n传参和上面的 all 一模一样，传入一个 Promise 实例集合的数组，然后全部同时执行，谁先快先执行完就返回谁，只返回一个结果\\n\\n```\\nMyPromise.race = function(promisesList) {\\n  return new MyPromise((resolve, reject) => {\\n    // 直接循环同时执行传进来的promise\\n    for (const promise of promisesList) {\\n      // 直接返回出去了，所以只有一个，就看哪个快\\n      promise.then(resolve, reject)\\n    }\\n  })\\n}\\n```\\n\\n## 5. 防抖和节流\\n\\n函数防抖是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。\\n\\n函数节流是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。\\n\\n```\\n// //防抖\\nfunction debounce(fn, date) {\\n  let timer  //声明接收定时器的变量\\n  return function (...arg) {  // 获取参数\\n    timer && clearTimeout(timer)  // 清空定时器\\n    timer = setTimeout(() => {  //  生成新的定时器\\n      //因为箭头函数里的this指向上层作用域的this,所以这里可以直接用this，不需要声明其他的变量来接收\\n      fn.apply(this, arg) // fn()\\n    }, date)\\n  }\\n}\\n//--------------------------------\\n// 节流\\nfunction debounce(fn, data) {\\n  let timer = +new Date()  // 声明初始时间\\n  return function (...arg) { // 获取参数\\n    let newTimer = +new Date()  // 获取触发事件的时间\\n    if (newTimer - timer >= data) {  // 时间判断,是否满足条件\\n      fn.apply(this, arg)  // 调用需要执行的函数,修改this值,并且传入参数\\n      timer = +new Date() // 重置初始时间\\n    }\\n  }\\n}\\n```\\n\\n## 6. 手写 call 函数\\n\\n**call 函数的实现步骤：**\\n\\n0.  判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。\\n0.  判断传入上下文对象是否存在，如果不存在，则设置为 window 。\\n0.  处理传入的参数，截取第一个参数后的所有参数。\\n0.  将函数作为上下文对象的一个属性。\\n0.  使用上下文对象来调用这个方法，并保存返回结果。\\n0.  删除刚才新增的属性。\\n0.  返回结果。\\n\\n```\\n// call函数实现\\nFunction.prototype.myCall = function(context) {\\n  // 判断调用对象\\n  if (typeof this !== \\\"function\\\") {\\n    console.error(\\\"type error\\\");\\n  }\\n  // 获取参数\\n  let args = [...arguments].slice(1),\\n      result = null;\\n  // 判断 context 是否传入，如果未传入则设置为 window\\n  context = context || window;\\n  // 将调用函数设为对象的方法\\n  context.fn = this;\\n  // 调用函数\\n  result = context.fn(...args);\\n  // 将属性删除\\n  delete context.fn;\\n  return result;\\n};\\n```\\n\\n## 7. 手写 apply 函数\\n\\n**apply 函数的实现步骤：**\\n\\n0.  判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。\\n0.  判断传入上下文对象是否存在，如果不存在，则设置为 window 。\\n0.  将函数作为上下文对象的一个属性。\\n0.  判断参数值是否传入\\n0.  使用上下文对象来调用这个方法，并保存返回结果。\\n0.  删除刚才新增的属性\\n0.  返回结果\\n\\n```\\n// apply 函数实现\\nFunction.prototype.myApply = function(context) {\\n  // 判断调用对象是否为函数\\n  if (typeof this !== \\\"function\\\") {\\n    throw new TypeError(\\\"Error\\\");\\n  }\\n  let result = null;\\n  // 判断 context 是否存在，如果未传入则为 window\\n  context = context || window;\\n  // 将函数设为对象的方法\\n  context.fn = this;\\n  // 调用方法\\n  if (arguments[1]) {\\n    result = context.fn(...arguments[1]);\\n  } else {\\n    result = context.fn();\\n  }\\n  // 将属性删除\\n  delete context.fn;\\n  return result;\\n};\\n```\\n\\n## 8. 手写 bind 函数\\n\\n**bind 函数的实现步骤：**\\n\\n0.  判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。\\n0.  保存当前函数的引用，获取其余传入参数值。\\n0.  创建一个函数返回\\n0.  函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。\\n\\n```\\n// bind 函数实现\\nFunction.prototype.myBind = function(context) {\\n  // 判断调用对象是否为函数\\n  if (typeof this !== \\\"function\\\") {\\n    throw new TypeError(\\\"Error\\\");\\n  }\\n  // 获取参数\\n  var args = [...arguments].slice(1),\\n      fn = this;\\n  return function Fn() {\\n    // 根据调用方式，传入不同绑定值\\n    return fn.apply(\\n      this instanceof Fn ? this : context,\\n      args.concat(...arguments)\\n    );\\n  };\\n};\\n```\\n\\n## 9. 函数柯里化的实现\\n\\n函数柯里化指的是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。\\n\\n```\\n\\nfunction curry(fn, ...args) {\\n  return fn.length <= args.length ? fn(...args) : curry.bind(null, fn, ...args);\\n}\\n```\\n\\n## 10. 手写AJAX请求\\n\\n**创建AJAX请求的步骤：**\\n\\n-   创建一个 XMLHttpRequest 对象。\\n-   在这个对象上**使用 open 方法创建一个 HTTP 请求**，open 方法所需要的参数是请求的方法、请求的地址、是否异步和用户的认证信息。\\n-   在发起请求前，可以为这个对象**添加一些信息和监听函数**。比如说可以通过 setRequestHeader 方法来为请求添加头信息。还可以为这个对象添加一个状态监听函数。一个 XMLHttpRequest 对象一共有 5 个状态，当它的状态变化时会触发onreadystatechange 事件，可以通过设置监听函数，来处理请求成功后的结果。当对象的 readyState 变为 4 的时候，代表服务器返回的数据接收完成，这个时候可以通过判断请求的状态，如果状态是 2xx 或者 304 的话则代表返回正常。这个时候就可以通过 response 中的数据来对页面进行更新了。\\n-   当对象的属性和监听函数设置完成后，最后调**用 sent 方法来向服务器发起请求**，可以传入参数作为发送的数据体。\\n\\n```\\nconst SERVER_URL = \\\"/server\\\";\\nlet xhr = new XMLHttpRequest();\\n// 创建 Http 请求\\nxhr.open(\\\"GET\\\", SERVER_URL, true);\\n// 设置状态监听函数\\nxhr.onreadystatechange = function() {\\n  if (this.readyState !== 4) return;\\n  // 当请求成功时\\n  if (this.status === 200) {\\n    handle(this.response);\\n  } else {\\n    console.error(this.statusText);\\n  }\\n};\\n// 设置请求失败时的监听函数\\nxhr.onerror = function() {\\n  console.error(this.statusText);\\n};\\n// 设置请求头信息\\nxhr.responseType = \\\"json\\\";\\nxhr.setRequestHeader(\\\"Accept\\\", \\\"application/json\\\");\\n// 发送 Http 请求\\nxhr.send(null);\\n```\\n\\n## 11. 使用Promise封装AJAX请求\\n\\n```\\n// promise 封装实现：\\nfunction getJSON(url) {\\n  // 创建一个 promise 对象\\n  let promise = new Promise(function(resolve, reject) {\\n    let xhr = new XMLHttpRequest();\\n    // 新建一个 http 请求\\n    xhr.open(\\\"GET\\\", url, true);\\n    // 设置状态的监听函数\\n    xhr.onreadystatechange = function() {\\n      if (this.readyState !== 4) return;\\n      // 当请求成功或失败时，改变 promise 的状态\\n      if (this.status === 200) {\\n        resolve(this.response);\\n      } else {\\n        reject(new Error(this.statusText));\\n      }\\n    };\\n    // 设置错误监听函数\\n    xhr.onerror = function() {\\n      reject(new Error(this.statusText));\\n    };\\n    // 设置响应的数据类型\\n    xhr.responseType = \\\"json\\\";\\n    // 设置请求头信息\\n    xhr.setRequestHeader(\\\"Accept\\\", \\\"application/json\\\");\\n    // 发送 http 请求\\n    xhr.send(null);\\n  });\\n  return promise;\\n}\\n```\\n\\n## 12. 手写深拷贝\\n\\n```\\n function fn(obj) {\\n      // 判断数据是否是复杂类型\\n      if (obj instanceof Object) {\\n        //判断数据是否是数组\\n        if (Array.isArray(obj)) {\\n          //声明一个空数组来接收拷贝后的数据\\n          let result = []\\n          obj.forEach(item => {\\n            // 需要递归深层遍历，否则复制的是地址\\n            result.push(fn(item))\\n          })\\n          // 返回输出这个数组,数组拷贝完成\\n          return result\\n        } else {\\n          //如果是对象,就声明一个空对象来接收拷贝后的数据\\n          let result = {}\\n          for (let k in obj) {\\n            // 使用递归深层遍历\\n            result[k] = fn(obj[k])\\n          }\\n          // 返回输出这个对象,对象拷贝完成\\n          return result\\n        }\\n      }\\n      // 简单数据类型则直接返回输出\\n      return obj\\n    }\\n```\\n\\n## 13. 手写打乱数组顺序的方法\\n\\n主要的实现思路就是：\\n\\n-   取出数组的第一个元素，随机产生一个索引值，将该第一个元素和这个索引对应的元素进行交换。\\n-   第二次取出数据数组第二个元素，随机产生一个除了索引为1的之外的索引值，并将第二个元素与该索引值对应的元素进行交换\\n-   按照上面的规律执行，直到遍历完成\\n\\n```\\nlet arr = [1,2,3,4,5,6,7,8,9,10];\\nfor (let i = 0; i < arr.length; i++) {\\n  const randomIndex = Math.round(Math.random() * (arr.length - 1 - i)) + i;\\n  [arr[i], arr[randomIndex]] = [arr[randomIndex], arr[i]];\\n}\\nconsole.log(arr)\\n​\\n```\\n\\n## 14. 实现数组扁平化\\n\\n通过循环递归的方式，一项一项地去遍历，如果每一项还是一个数组，那么就继续往下遍历，利用递归程序的方法，来实现数组的每一项的连接：\\n\\n```\\nlet arr = [1, [2, [3, 4, 5]]];\\nfunction flatten(arr) {\\n  let result = [];\\n​\\n  for(let i = 0; i < arr.length; i++) {\\n    if(Array.isArray(arr[i])) {\\n      result = result.concat(flatten(arr[i]));\\n    } else {\\n      result.push(arr[i]);\\n    }\\n  }\\n  return result;\\n}\\nflatten(arr);  //  [1, 2, 3, 4，5]\\n```\\n\\n## 15. 实现数组的flat方法\\n\\n```\\nfunction _flat(arr, depth) {\\n  if(!Array.isArray(arr) || depth <= 0) {\\n    return arr;\\n  }\\n  return arr.reduce((prev, cur) => {\\n    if (Array.isArray(cur)) {\\n      return prev.concat(_flat(cur, depth - 1))\\n    } else {\\n      return prev.concat(cur);\\n    }\\n  }, []);\\n}\\n```\\n\\n## 16. 实现数组的push方法\\n\\n```\\nlet arr = [];\\nArray.prototype.push = function() {\\n    for( let i = 0 ; i < arguments.length ; i++){\\n        this[this.length] = arguments[i] ;\\n    }\\n    return this.length;\\n}\\n​\\n```\\n\\n## 17. 实现数组的filter方法\\n\\n```\\nArray.prototype._filter = function(fn) {\\n    if (typeof fn !== \\\"function\\\") {\\n        throw Error('参数必须是一个函数');\\n    }\\n    const res = [];\\n    for (let i = 0, len = this.length; i < len; i++) {\\n        fn(this[i]) && res.push(this[i]);\\n    }\\n    return res;\\n}\\n```\\n\\n## 18. 实现数组的map方法\\n\\n```\\nArray.prototype._map = function(fn) {\\n   if (typeof fn !== \\\"function\\\") {\\n        throw Error('参数必须是一个函数');\\n    }\\n    const res = [];\\n    for (let i = 0, len = this.length; i < len; i++) {\\n        res.push(fn(this[i]));\\n    }\\n    return res;\\n}\\n```\\n\\n## 19. 实现 add(1)(2)(3)(4)\\n\\n可以实现任意数量数字相加，但是需要用+号隐式转换\\n\\n```\\n function fn() {\\n      let result = [];\\n      function add(...args) {\\n        // ...args剩余参数,可以获取到传进来的参数\\n        result = [...result, ...args]\\n        return add;\\n      };\\n      // 创建一个取代 valueOf 方法的函数,覆盖自定义对象的 valueOf 方法\\n      add.toString = () => result.reduce((sum, k) => sum + k, 0);\\n      return add;\\n    };\\nlet add = fn()\\n   console.log(+add(1)(2)(3)(4)) // --->10\\n    // let add2 = fn();\\n    console.log(+add2(1, 2, 3)(4)) // --->10\\n```\\n\\n参数固定的情况下，不需要用+号，可以根据参数长度来判断返回值\\n\\n```\\n    function currying(fn, length) {\\n      length = length || fn.length; // 第一次调用,给length赋值fn的长度,后面每次重复调用,length的长度都会减去参数的长度\\n      return function (...args) {\\n        return args.length >= length // 当前传递进来的参数的长度与length长度进行比较\\n          ? fn.apply(this, args) // 把最后一组实参传给为赋值的形参,此时所有形参都已赋值,并调用fn函数\\n          : currying(fn.bind(this, ...args), length - args.length)\\n        // 每一次调用fn.bind,都会把当前的args里的实参依次传给fn的形参,length的长度减去参数的长度\\n        // 相当于fn.bind(this, 1).bind(this, 2, 3),bind的连续调用,来填充fn的参数\\n        // 直到某一次调用,fn的形参即将全部都被赋值时,条件成立,会执行fn.apply,把最后的参数传递过去,并且调用fn\\n      }\\n    }\\n    function fn(a, b, c, d) {\\n      return a + b + c + d\\n    }\\n    const add = currying(fn)\\n    add(4)(3)(1)(2) //10\\n    add(1, 3)(4)(2) //10\\n    add(1)(3, 4, 2) //10\\n```\\n\\n## 20. 用Promise实现图片的异步加载\\n\\n```\\nlet imageAsync=(url)=>{\\n            return new Promise((resolve,reject)=>{\\n                let img = new Image();\\n                img.src = url;\\n                img.οnlοad=()=>{\\n                    console.log(`图片请求成功，此处进行通用操作`);\\n                    resolve(image);\\n                }\\n                img.οnerrοr=(err)=>{\\n                    console.log(`失败，此处进行失败的通用操作`);\\n                    reject(err);\\n                }\\n            })\\n        }\\n        \\nimageAsync(\\\"url\\\").then(()=>{\\n    console.log(\\\"加载成功\\\");\\n}).catch((error)=>{\\n    console.log(\\\"加载失败\\\");\\n})\\n```\\n\\n## 21. 手写发布-订阅模式\\n\\n```\\nclass EventCenter{\\n  // 1. 定义事件容器，用来装事件数组\\n    let handlers = {}\\n​\\n  // 2. 添加事件方法，参数：事件名 事件方法\\n  addEventListener(type, handler) {\\n    // 创建新数组容器\\n    if (!this.handlers[type]) {\\n      this.handlers[type] = []\\n    }\\n    // 存入事件\\n    this.handlers[type].push(handler)\\n  }\\n​\\n  // 3. 触发事件，参数：事件名 事件参数\\n  dispatchEvent(type, params) {\\n    // 若没有注册该事件则抛出错误\\n    if (!this.handlers[type]) {\\n      return new Error('该事件未注册')\\n    }\\n    // 触发事件\\n    this.handlers[type].forEach(handler => {\\n      handler(...params)\\n    })\\n  }\\n​\\n  // 4. 事件移除，参数：事件名 要删除事件，若无第二个参数则删除该事件的订阅和发布\\n  removeEventListener(type, handler) {\\n    if (!this.handlers[type]) {\\n      return new Error('事件无效')\\n    }\\n    if (!handler) {\\n      // 移除事件\\n      delete this.handlers[type]\\n    } else {\\n      const index = this.handlers[type].findIndex(el => el === handler)\\n      if (index === -1) {\\n        return new Error('无该绑定事件')\\n      }\\n      // 移除事件\\n      this.handlers[type].splice(index, 1)\\n      if (this.handlers[type].length === 0) {\\n        delete this.handlers[type]\\n      }\\n    }\\n  }\\n}\\n```\\n\\n## 22. Object.defineProperty(简易版)\\n\\n```\\n //  Vue2的响应式原理，结合了Object.defineProperty的数据劫持，以及发布订阅者模式\\n //  Vue2的数据劫持，就是通过递归遍历data里的数据，用Object.defineProperty给每一个属性添加getter和setter,\\n //  并且把data里的属性挂载到vue实例中，修改vue实例上的属性时，就会触发对应的setter函数，向Dep订阅器发布更新消息，\\n //  对应的Watcher订阅者会收到通知，调用自身的回调函数，让编译器去更新视图。\\n    const obj = {\\n      name: '刘逍',\\n      age: 20\\n    }\\n    const p = {}\\n    for (let key in obj) {\\n      Object.defineProperty(p, key, {\\n        get() {\\n          console.log(`有人读取p里的${key}属性`);\\n          return obj[key]\\n        },\\n        set(val) {\\n          console.log(`有人修改了p里的${key}属性,值为${val},需要去更新视图`);\\n          obj[key] = val\\n        }\\n      })\\n    }\\n```\\n\\n## 23. Proxy数据劫持(简易版)\\n\\n```\\n // Vue3的数据劫持通过Proxy函数对代理对象的属性进行劫持，通过Reflect对象里的方法对代理对象的属性进行修改，\\n // Proxy代理对象不需要遍历，配置项里的回调函数可以通过参数拿到修改属性的键和值\\n // 这里用到了Reflect对象里的三个方法，get，set和deleteProperty，方法需要的参数与配置项中回调函数的参数相同。\\n // Reflect里的方法与Proxy里的方法是一一对应的，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。\\n   const obj = {\\n      name: '刘逍',\\n      age: 20\\n    }\\n   const p = new Proxy(obj, {\\n      // 读取属性的时候会调用getter\\n      get(target, propName) {  //第一个参数为代理的源对象,等同于上面的Obj参数。第二个参数为读取的那个属性值\\n        console.log(`有人读取p对象里的${propName}属性`);\\n        return Reflect.get(target, propName)\\n      },\\n      // 添加和修改属性的时候会调用setter\\n      set(target, propName, value) { //参数等同于get，第三个参数为修改后的属性值\\n        console.log(`有人修改了p对象里的${propName}属性,值为${value},需要去修改视图`);\\n        Reflect.set(target, propName, value)\\n      },\\n      // 删除属性时，调用deleteProperty\\n      deleteProperty(target, propName) { // 参数等同于get\\n        console.log(`有人删除了p对象里的${propName}属性，需要去修改视图`);\\n        return Reflect.deleteProperty(target, propName)\\n      }\\n    })\\n```\\n\\n## 24. 实现路由(简易版)\\n\\n```\\n// hash路由\\nclass Route{\\n  constructor(){\\n    // 路由存储对象\\n    this.routes = {}\\n    // 当前hash\\n    this.currentHash = ''\\n    // 绑定this，避免监听时this指向改变\\n    this.freshRoute = this.freshRoute.bind(this)\\n    // 监听\\n    window.addEventListener('load', this.freshRoute, false)\\n    window.addEventListener('hashchange', this.freshRoute, false)\\n  }\\n  // 存储\\n  storeRoute (path, cb) {\\n    this.routes[path] = cb || function () {}\\n  }\\n  // 更新\\n  freshRoute () {\\n    this.currentHash = location.hash.slice(1) || '/'\\n    this.routes[this.currentHash]()\\n  }\\n}\\n```\\n\\n## 25. 使用 setTimeout 实现 setInterval\\n\\n实现思路是使用递归函数，不断地去执行 setTimeout 从而达到 setInterval 的效果\\n\\n```\\nfunction mySetInterval(fn, timeout) {\\n  // 控制器，控制定时器是否继续执行\\n  var timer = {\\n    flag: true\\n  };\\n  // 设置递归函数，模拟定时器执行。\\n  function interval() {\\n    if (timer.flag) {\\n      fn();\\n      setTimeout(interval, timeout);\\n    }\\n  }\\n  // 启动定时器\\n  setTimeout(interval, timeout);\\n  // 返回控制器\\n  return timer;\\n}\\n```\\n\\n## 26. 使用setInterval实现setTimeout\\n\\n```\\n    function mySetInterval(fn, t) {\\n      const timer = setInterval(() => {\\n        clearInterval(timer)\\n        fn()\\n      }, t)\\n    }\\n \\n    mySetInterval(() => {\\n      console.log('hoho');\\n    }, 1000)\\n```\\n\\n## 27. 实现 jsonp\\n\\n```\\n// 动态的加载js文件\\nfunction addScript(src) {\\n  const script = document.createElement('script');\\n  script.src = src;\\n  script.type = \\\"text/javascript\\\";\\n  document.body.appendChild(script);\\n}\\naddScript(\\\"http://xxx.xxx.com/xxx.js?callback=handleRes\\\");\\n// 设置一个全局的callback函数来接收回调结果\\nfunction handleRes(res) {\\n  console.log(res);\\n}\\n// 接口返回的数据格式\\nhandleRes({a: 1, b: 2});\\n```\\n\\n## 28. 提取出url 里的参数并转成对象\\n\\n```\\nfunction getUrlParams(url){\\n  let reg = /([^?&=]+)=([^?&=]+)/g\\n  let obj = { }\\n  url.replace(reg, function(){\\n      obj[arguments[1]] = arguments[2]\\n  })\\n  // 或者\\n  const search = window.location.search\\n  search.replace(/([^&=?]+)=([^&]+)/g, (m, $1, $2)=>{obj[$1] = decodeURIComponent($2)})\\n  \\n  return obj\\n}\\nlet url = 'https://www.junjin.cn?a=1&b=2'\\nconsole.log(getUrlParams(url)) // { a: 1, b: 2 }\\n```\\n\\n## 29. 请写至少三种数组去重的方法？（原生js）\\n\\n```\\n//利用filter\\nfunction unique(arr) {\\n  return arr.filter(function(item, index, arr) {\\n    //当前元素，在原始数组中的第一个索引==当前索引值，否则返回当前元素\\n    return arr.indexOf(item, 0) === index;\\n  });\\n}\\n    var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];\\n        console.log(unique(arr))\\n```\\n\\n```\\n//利用ES6 Set去重（ES6中最常用）\\nfunction unique (arr) {\\n  return Array.from(new Set(arr))\\n}\\nvar arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];\\nconsole.log(unique(arr))\\n //[1, \\\"true\\\", true, 15, false, undefined, null, NaN, \\\"NaN\\\", 0, \\\"a\\\", {}, {}]\\n```\\n\\n```\\n//利用for嵌套for，然后splice去重（ES5中最常用）\\nfunction unique (arr) {\\n        for(var i=0; i<arr.length; i++){\\n            for(var j=i+1; j<arr.length; j++){\\n                if(arr[i]==arr[j]){         //第一个等同于第二个，splice方法删除第二个\\n                    arr.splice(j,1);\\n                    j--;\\n                }\\n            }\\n        }\\nreturn arr;\\n}\\nvar arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];\\n    console.log(unique(arr))\\n    //[1, \\\"true\\\", 15, false, undefined, NaN, NaN, \\\"NaN\\\", \\\"a\\\", {…}, {…}]     \\n    //NaN和{}没有去重，两个null直接消失了\\n```\\n\\n# 二、算法基础\\n## 1. 时间&空间复杂度\\n\\n-   复杂度是数量级（方便记忆、推广），不是具体数字。\\n-   常见复杂度大小比较：O(n^2) > O(nlogn) > O(n) > O(logn) > O(1)\\n\\n### 1.1 时间复杂度\\n\\n常见时间复杂度对应关系：\\n\\n-   O(n^2)：2层循环（嵌套循环）\\n-   O(nlogn)：快速排序（循环 + 二分）\\n-   O(n)：1层循环\\n-   O(logn)：二分\\n\\n### 1.2 空间复杂度\\n\\n常见空间复杂度对应关系：\\n\\n-   O(n)：传入一个数组，处理过程生成一个新的数组大小与传入数组一致\\n\\n## 2. 八大数据结构\\n\\n### 1. 栈\\n\\n`栈`是一个`后进先出`的数据结构。`JavaScript`中没有`栈`，但是可以用`Array`实现`栈`的所有功能。\\n\\n```\\n// 数组实现栈数据结构\\nconst stack = []\\n​\\n// 入栈\\nstack.push(0)\\nstack.push(1)\\nstack.push(2)\\n​\\n// 出栈\\nconst popVal = stack.pop() // popVal 为 2\\n```\\n\\n**使用场景**\\n\\n-   场景一：十进制转二进制\\n-   场景二：有效括号\\n-   场景三：函数调用堆栈\\n\\n### 2. 队列\\n\\n`队列`是一个`先进先出`的数据结构。`JavaScript`中没有`队列`，但是可以用`Array`实现`队列`的所有功能。\\n\\n```\\n// 数组实现队列数据结构\\nconst queue = []\\n​\\n// 入队\\nstack.push(0)\\nstack.push(1)\\nstack.push(2)\\n​\\n// 出队\\nconst shiftVal = stack.shift() // shiftVal 为 0\\n\\n```\\n\\n**使用场景**\\n\\n-   场景一：日常测核酸排队\\n-   场景二：JS异步中的任务队列\\n-   场景三：计算最近请求次数\\n\\n### 3. 链表\\n\\n`链表`是多个元素组成的列表，元素存储不连续，用`next`指针连在一起。`JavaScript`中没有`链表`，但是可以用`Object`模拟`链表`。\\n\\n**使用场景**\\n\\n-   场景一：JS中的原型链\\n-   场景二：使用链表指针获取 JSON 的节点值\\n\\n### 4. 集合\\n\\n`集合`是一个`无序且唯一`的数据结构。`ES6`中有集合：`Set`，集合常用操作：去重、判断某元素是否在集合中、求交集。\\n\\n```\\n// 去重\\nconst arr = [1, 1, 2, 2]\\nconst arr2 = [...new Set(arr)]\\n​\\n// 判断元素是否在集合中\\nconst set = new Set(arr)\\nconst has = set.has(3) // false\\n​\\n// 求交集\\nconst set2 = new Set([2, 3])\\nconst set3 = new Set([...set].filter(item => set2.has(item)))\\n```\\n\\n**使用场景**\\n\\n-   场景一：求交集、差集\\n\\n### 5. 字典(哈希)\\n\\n`字典`也是一种存储`唯一值`的数据结构，但它以`键值对`的形式存储。`ES6`中的字典名为`Map`，\\n\\n```\\n// 字典\\nconst map = new Map()\\n​\\n// 增\\nmap.set('key1', 'value1')\\nmap.set('key2', 'value2')\\nmap.set('key3', 'value3')\\n​\\n// 删\\nmap.delete('key3')\\n// map.clear()\\n​\\n// 改\\nmap.set('key2', 'value222')\\n​\\n// 查\\nmap.get('key2')\\n\\n```\\n\\n**使用场景**\\n\\n-   场景：leetcode刷题\\n\\n### 6. 树\\n\\n`树`是一种`分层`的数据模型。前端常见的树包括：DOM、树、级联选择、树形控件……。`JavaScript`中没有`树`，但是可以通过`Object`和`Array`构建`树`。树的常用操作：深度/广度优先遍历、先中后序遍历。\\n\\n**使用场景**\\n\\n-   场景一：DOM树\\n-   场景二：级联选择器\\n\\n### 7. 图\\n\\n`图`是网络结构的抽象模型，是一组由边连接的节点。图可以表示任何二元关系，比如道路、航班。JS中没有图，但是可以用`Object`和`Array`构建`图`。图的表示法：邻接矩阵、邻接表、关联矩阵。\\n\\n**使用场景**\\n\\n-   场景一：道路\\n-   场景二：航班\\n\\n### 8. 堆\\n\\n`堆`是一种特殊的完全二叉树。所有的节点都大于等于（最大堆）或小于等于（最小堆）它的子节点。由于`堆`的特殊结构，我们可以用`数组`表示`堆`。\\n\\n**使用场景**\\n\\n-   场景：leetcode刷题\\n\\n## 3. 排序方法\\n\\n### 3.1 冒泡排序\\n\\n比较两个记录键值的大小，如果这两个记录键值的大小出现逆序，则交换这两个记录\\n\\n**每遍历一个元素，都会把之前的所有相邻的元素都两两比较一遍，即便是已经排序好的元素**\\n\\n```\\n//[1,3,4,2]->[1,3,2,4]->[1,2,3,4]->[1,2,3,4]\\n\\nlet n = 0\\nfunction bubbleSort(arr){\\n    for(let i = 1;i < arr.length;i++){\\n        for(let j = i;j > 0;j--){\\n            n++ // 1+2+3+...+arr.length-1\\n            if(arr[j] < arr[j-1]){\\n                [arr[j],arr[j-1]] = [arr[j-1],arr[j]];\\n            }\\n        }\\n    }\\n    return arr;\\n}\\n​\\n```\\n\\n### 3.2 插入排序\\n\\n第i（i大于等于1）个记录进行插入操作时，R1、 R2，...，是排好序的有序数列，取出第i个元素，在序列中找到一个合适的位置并将她插入到该位置上即可。\\n\\n**相当于把当前遍历的元素取出，在序列中找到一个合适的位置将它插入。它的第二层循环不必遍历当前元素之前的所有元素，因为当前元素之前的序列是排序好的，碰到第一个小于当前元素的值，就可以停止继续向前查找了，然后把当前元素插入当前位置即可**\\n\\n```\\n\\nfunction insertSort(arr){\\n    for(let i = 1;i < arr.length;i++){\\n        let j = i-1;\\n        if(arr[i]<arr[j]){\\n            let temp = arr[i];\\n            while(j >= 0 && temp < arr[j]){\\n                arr[j+1] = arr[j];\\n                j--;\\n            }\\n            arr[j+1] = temp;\\n        }\\n    }\\n    return arr;\\n}\\n​\\n//[1,3,4,2] ->[1,3,4,4]->[1,3,3,4]->[1,2,3,4]\\n//i=3 temp=2 j=2 arr[j]=4 arr[3]=4 [1,3,4,4]； j=1 arr[2]=3 [1,3,3,4]； j=0  [1,2,3,4]\\n```\\n\\n### 3.3 希尔排序\\n\\n算法先将要排序的一组数按某个增量d（n/2,n为要排序数的个数）分成若干组，每组中记录的下标相差d.对每组中全部元素进行直接插入排序，然后再用一个较小的增量（d/2）对它进行分组，在每组中再进行直接插入排序。当增量减到1时，进行直接插入排序后，排序完成。\\n\\n```\\n\\nfunction hillSort(arr){\\n    let len = arr.length;\\n    for(let gap = parseInt(len / 2);gap >= 1;gap = parseInt(gap / 2)){\\n        for(let i = gap;i < len;i++){\\n            if(arr[i] < arr[i-gap]){\\n                let temp = arr[i];\\n                let j = i - gap;\\n                while(j >= 0 && arr[j] > temp){\\n                    arr[j+gap] = arr[j];\\n                    j -= gap;\\n                }\\n                arr[j+gap] = temp;\\n            }\\n        }\\n    }\\n    return arr;\\n}\\n​\\n```\\n\\n\\n\\n![微信截图_20221006102742.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1612c370bd704e48aa83741d72119e63~tplv-k3u1fbpfcp-watermark.image?)\\n\\n### 3.4 选择排序\\n\\n在第i次选择操作中，通过n-i次键值间比较，从n-i+1个记录中选出键值最小的记录，并和第i（1小于等于1小于等于n-1）个记录交换\\n\\n**每一次遍历，都把当前元素与剩下元素里的最小值交换位置**\\n\\n```\\n//[4,1,3,2]->[1,4,3,2]->[1,2,4,3]->[1,2,3,4]\\n\\nfunction selectSort(arr){\\n    for(let i = 0;i < arr.length;i++){\\n        let min = Math.min(...arr.slice(i));\\n        let index\\n        for (let j = i; j < arr.length; j++) {\\n          if (arr[j] === min) {\\n            index = j\\n            break\\n          }\\n        }\\n        [arr[i],arr[index]] = [arr[index],arr[i]];\\n    }\\n    return arr;\\n}\\n​\\n```\\n\\n### 3.5 快排\\n\\n在n个记录中取某一个记录的键值为标准，通常取第一个记录键值为基准，通过一趟排序将待排的记录分为小于或等于这个键值的两个独立的部分，这是一部分的记录键值均比另一部分记录的键值小，然后，对这两部分记录继续分别进行快速排序，以达到整个序列有序\\n\\n**取当前排序数组的第一个值作为基准值keys，通过一次遍历把数组分为right大于基准值和left小于等于基准值的两部分，然后对两个部分重复以上步骤排序，最后return的时候按照[left,keys,right]的顺序返回**\\n\\n```\\n\\nfunction quickSort(arr){\\n    if(arr.length <= 1) return arr;\\n    let right = [],left = [],keys = arr.shift();\\n    for(let value of arr){\\n        if(value > keys){\\n            right.push(value)\\n        }else{\\n            left.push(value);\\n        }\\n    }\\n    return quickSort(left).concat(keys,quickSort(right));\\n}\\n\\n//[4,1,3,2]-->quickSort([1,3,2]).concat(4,quickSort([]))\\n//         -->quickSort([]).concant(1,quickSort([3,2])).concat(4,quickSort([]))\\n//         -->quickSort([]).concant(1,quickSort([2]).concant(3)).concat(4,quickSort([]))\\n//         -->[1,2,3,4]\\n//keys=4 R[] L[1,3,2]  \\n-------quickSort(left)\\n//keys=1 R[3,2] L[]\\n//keys=3 R[] L[2]\\n//quickSort(left)=[1,2,3]\\n​\\n```\\n\\n### **3.6各排序算法的稳定性，时间复杂度，空间复杂度**\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2eb6796900134ba7b4c4420f5dce5fd2~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n每个语言的排序内部实现都是不同的。\\n\\n对于 JS 来说，数组长度大于 10 会采用快排，否则使用插入排序。选择插入排序是因为虽然时间复杂度很差，但是在数据 量很小的情况下和 O(N * logN) 相差无几，然而插入排序需要的常数时间很小，所以相对别的排序来说更快。\\n\\n## 4. JS尾递归优化斐波拉契数列\\n\\n正常的斐波拉契数列js实现方式\\n\\n```\\nconst Fibonacci = (n) => {\\n    if (n <= 1) return 1;\\n    return  Fibonacci(n - 1) + Fibonacci(n - 2);\\n}\\nFibonacci(10) // 89\\nFibonacci(40) // 165580141 计算缓慢有延迟了\\nFibonacci(100) // 栈溢出，无法得到结果复制代码\\n```\\n\\n使用尾递归优化该方法\\n\\n```\\nconst Fibonacci = (n, sum1 = 1, sum2 = 1) => {\\n     if (n <= 1) return sum2;\\n     return Fibonacci(n - 1, sum2, sum1 + sum2)\\n}\\nFibonacci(10) // 89\\nFibonacci(100) // 573147844013817200000 速度依旧很快\\nFibonacci(1000) // 7.0330367711422765e+208 还是没有压力复制代码\\n```\\n\\n尾递归优化可以在数量较大的计算中，可以起到很好的作用\\n",
        "tags": [
            "前端",
            "JavaScript",
            "面试"
        ]
    }
]